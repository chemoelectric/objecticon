#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package lang

record ClassInfo(template_fields, fnum_map, curr_fields)

#
# An implementation of {object_encode} and {object_decode}.  The subclass
# may override the method {get_template()} to return a list of
# pairs.  The first element of each pair is an arbitrary string used
# to identify the field; the second element is the name of the field.
#
# @example
# @   # This will save the three fields {increment_size}, {value} and {is_range_flag}.
# @   private get_template()
# @      return  [
# @          ["Increment Size", "increment_size"],
# @          ["Value", "value"],
# @          ["Is Range Flag", "is_range_flag"]]
# @   end
#
# The programmer may change the name of the field afterwards; for example {value} may
# be re-named {initial_value}, and the data would still be restored correctly.
#
# Alternatively, any of the pairs may be a string field name, in which the label
# is the field name itself.  This does not permit the field name to change without
# rendering the encoded string invalid.
#
# If not overridden, the default {get_template()} returns a list of all of the fields
# in the class.
#
class SelectiveObjectCodec()
   #
   # This empty method may be overridden; it is invoked just before
   # the object is encoded.
   #
   protected pre_encode()
   end

   #
   # This empty method may be overridden; it is invoked just after
   # the object has been encoded.
   #
   protected post_encode()
   end

   #
   # This empty method may be overridden; it is invoked just before
   # the object is decoded.
   #
   protected pre_decode()
   end

   #
   # This empty method may be overridden; it is invoked just after
   # the object has been decoded.
   #
   protected post_decode()
   end

   private object_encode(e, ff)
      local p, m, x

      p := self.load_structs()
      if \ff then
         e.encode(p.template_fields) | fail

      pre_encode()
      m := p.fnum_map
      every x := !p.template_fields do
         e.encode(Class.get(self, m[x])) | fail
      post_encode()
      return
   end

   private object_decode(e, ff)
      local p, m, v, f

      p := self.load_structs()
      if \ff then
         p.curr_fields := e.decode() | fail

      pre_decode()
      m := p.fnum_map
      every f := !p.curr_fields do {
         v := e.decode() | fail
         Class.get(self, \m[f]) := v
      }
      post_decode()
      return
   end

   #
   # Get the conversion info structures for this class, using caching
   # for efficiency.  The result is a record with two items.  The
   # first element is the template, adjusted so that single elements
   # are expanded to lists with two elements the same eg ... "x" ->
   # ["x","x"].  The second element is a table mapping the field names
   # to field numbers.
   #
   private load_structs()
      local e, class_name, fnum_map, template_fields, p
      static cache
      initial {
         cache := table()
      }

      class_name := subtype(self)

      if member(cache, class_name) then
         return cache[class_name]

      # Create a list of field names and a table mapping field
      # names to class field indices.  Check for duplicate names and
      # non-existent variable names.
      #
      template_fields := []
      fnum_map := table()
      every e := !get_template() do {
         if type(e) == "string" then {
            put(template_fields, e)
            /fnum_map[e] := Class.get_field_index(self, e) | 
               runerr("invalid template: can't map " || e)
         } else {
            put(template_fields, e[1])
            /fnum_map[e[1]] := Class.get_field_index(self, e[2]) | 
               runerr("invalid template: can't map " || e[1] || " to " || e[2])
         }
      }

      p := ClassInfo(template_fields, fnum_map)
      insert(cache, class_name, p)
      return p
   end

   #
   # This method is overridden by a subclass to return the field
   # template (see above).  By default, the method returns a list
   # containing all of the instance fields of the class.
   #
   protected get_template()
      local l
      l := []
      every put(l, Class.get_instance_field_names(self))
      return l
   end
end
