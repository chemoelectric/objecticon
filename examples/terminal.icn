import 
   gui,
   io,
   posix,
   graphics,
   net,
   lang,
   util,
   xdg,
   ipl.options,
   ipl.sort,
   ipl.pdco,
   ipl.wildcard,
   ipl.lists,
   ipl.functional,
   ipl.filegui,
   ipl.childwait,
   ipl.vt,
   ipl.columnize,
   ipl.strings

global opts

$load EXIT "rpp.EXIT_24.gif"
$load SAVE "rpp.SAVE_24.gif"
$load MIXFILE "rpp.MIXFILE_24.png"
$load TERMINAL_LOGO "rpp.TERMINAL_LOGO.png"

abstract class Runner()
   public abstract get_command()
end

class ImmediateRunner(Runner)
   public const
      cmd

   public get_command()
      return cmd
   end

   public new(cmd)
      self.cmd := cmd
      return
   end
end

abstract class ExternalRunner(Runner)
   public abstract get_working_dir()
end

class LaunchRunner(ExternalRunner)
   public const
      cmd,
      wd

   public get_working_dir()
      return \wd
   end

   public get_command()
      return cmd
   end

   public new(cmd, wd)
      self.cmd := cmd
      self.wd := wd
      return
   end
end

class DesktopRunner(ExternalRunner)
   public const
      # The DesktopEntry giving the command and other parameters.
      desktop_entry,
      # The string to substitute to create a command to run
      subst,
      # The url itself (a URL object).
      url

   public get_working_dir()
      return \desktop_entry.path
   end

   public get_command()
      local line
      if url.scheme == u"file" then
         line := integer(url.extract_cgi_parameters()["line"][1])
      return desktop_entry.subst_file(Format.shell_escape(subst), line)
   end

   public new(desktop_entry, url, subst)
      self.desktop_entry := desktop_entry
      self.url := url
      self.subst := subst
      return
   end
end

class TerminalMenu(DynamicMenu)
   public populate()
      local m
      if m := parent_component.parent_dialog.tabs.which_one.create_context_menu() then
         every add(!m.children)
   end
end

class ColumnsMenu(DynamicMenu)
   public populate()
      local m
      if m := parent_component.parent_dialog.tabs.which_one.create_columns_context_menu() then
         every add(!m.children)
   end

   public finally()
      DynamicMenu.finally()
   end
end

class TerminalDialog(Dialog)
   private readable
      favourite_dirs,
      tabs

   private on_quit(ev)
      dispose()
   end

   public do_tab_cmd(l)
      local s, t, cmd
      # l is a list of strings (not ucs).
      t := tabs.which_one
      while s := get(l) do {
         s ? if =":" then {
            cmd := tab(0)
            \t | return error("Command before tab directory: " || cmd)
            t.do_tab_cmd(cmd) | fail
         } else
            t := if *s > 0 then new_tab(, s) else new_tab()
      }
      return self
   end

   public new_tab(sel, dir, other)
      local bt
      bt := Terminal(dir, other, tabs.which_one).
         set_is_hidden(&yes)
      tabs.add(bt, 0)
      if is_live() then
         tabs.do_layout().invalidate()
      if \sel then
         tabs.set_which_one(bt)
      return bt
   end

   private on_new_tab(ev)
      new_tab(&yes)
   end

   private on_clone_tab(ev)
      new_tab(&yes,, tabs.which_one)
   end

   private on_xdg_refresh(ev)
      Xdg.refresh()
      tabs.which_one.info_msg("XDG database reloaded")
   end

   public on_favourite_dirs(ev)
      local d
      d := FavouriteDirectoriesDialog()
      d.show_modal(self)
      \d.okay | fail
      every (!tabs.children).refresh_favourite_dirs()
   end

   public launch_prog(runner)
      local pid, nul, cmd
      if \opts["v"] then write("Desktop entry: ", to_string(runner.desktop_entry, 3, 1))
      pid := System.fork() | fail
      if pid > 0 then {
         # Parent
         ChildWait.add_pid(pid, on_child_exit)
         return
      }
      # Set the working directory for the child process
      Files.chdir(runner.get_working_dir() | Files.get_home())
      # Get the command to run.
      cmd := runner.get_command()
      System.setpgid()
      if nul := FileStream("/dev/null", FileOpt.RDWR) then {
         every nul.dup2(FileStream.stdin | FileStream.stdout | FileStream.stderr)
         nul.close()
      }
      System.exec("/bin/bash", ["-c", "exec " || cmd]) | stop(&why)
      syserr("Not reached")
   end

   private on_child_exit(r)
      if \opts["v"] then
         write("Child process exited: ",to_string(r))
   end

   public new()
      local quit_menu_item, menu_bar, file_menu, terminal_menu, columns_menu, 
         new_tab_item, clone_tab_item, favourite_dirs_item, xdg_refresh_item
      Dialog.new()
      set_size(scale(1200), scale(850))
      self.set_resize(&yes)
      new_tab_item := TextMenuItem().
         connect(on_new_tab, Event.ACTION).
         set_label("New Tab")
      clone_tab_item := TextMenuItem().
         connect(on_clone_tab, Event.ACTION).
         set_label("Clone Tab")
      favourite_dirs_item := TextMenuItem().
         connect(on_favourite_dirs, Event.ACTION).
         set_label("Favourite dirs...")
      xdg_refresh_item := TextMenuItem().
         connect(on_xdg_refresh, Event.ACTION).
         set_label("Refresh XDG")
      quit_menu_item := TextMenuItem().
         connect(on_quit, Event.ACTION).
         set_label("Quit")
      file_menu := Menu().
         set_label("File").
         add(new_tab_item).
         add(clone_tab_item).
         add(favourite_dirs_item).
         add(xdg_refresh_item).
         add(quit_menu_item)
      terminal_menu := TerminalMenu().
         set_label("Terminal")
      columns_menu := ColumnsMenu().
         set_label("List")
      menu_bar := MenuBar().
         set_size(scale(100)).
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("l_inset", 0).
         set_constraint("r_inset", 0).
         set_constraint("t_inset", 0).
         set_constraint("b_inset", 0).
         set_constraint("x_fill", &yes).
         add(file_menu).
         add(columns_menu).
         add(terminal_menu)
      self.add(menu_bar)
      tabs := TabSet().
         clear_constraints().
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("y_fill", &yes).
         set_constraint("y_weight", 1.0).
         set_constraint("l_inset", 0).
         set_constraint("r_inset", 0).
         set_constraint("t_inset", 0).
         set_constraint("b_inset", 0).
         set_remember_focus(&yes).
         set_draggable_tabs(&yes).
         set_no_click_focus(&yes)
      self.add(tabs)
      self.connect(self.on_quit, Event.WINDOW_CLOSE_BUTTON)
      self.set_layout(GridLayout().set_extra("cells"))
      set_label("Terminal")
      return
   end
end

class Columns(LineBasedScrollArea)
   private readable
      data,
      item_border,
      item_paint,
      gutter,
      held,
      over,
      highlight,
      cursor

   private
      data_w,
      col_w,
      n_rows,
      prev_columnize_dw

   public initially()
      \self.item_paint | runerr("ItemPaint not set")
      LineBasedScrollArea.initially()
      self.item_paint.initially(self)
      self.item_border.initially(self)
   end

   public finally()
      LineBasedScrollArea.finally()
      self.item_paint.finally()
      self.item_border.finally()
   end

   #
   # Set a border to draw along with each item.
   #
   public set_item_border(b)
      if is_initialized() then {
         (\self.item_border).finally()
         self.item_border := b
         self.item_border.initially(self)
      } else
         self.item_border := b
      return self
   end

   public set_item_paint(r)
      if is_initialized() then {
         (\self.item_paint).finally()
         self.item_paint := r
         self.item_paint.initially(self)
      } else
         self.item_paint := r
      return self
   end

   public draw_line(xp, yp, lh, i)
      local e, j, r, s, k, W
      every j := 1 to *col_w do {
         k := i + (j - 1) * n_rows
         e := data[k] | break
         s := item_paint.get_size(view.cbwin, e)
         r := Rect(xp, yp, s.w + item_border.get_total_width(), lh)
         if k === highlight then  {
            use {
               W := view.cbwin.clone(),
               {
                  W.set_fg("red")
                  item_paint.draw_rect(W, e, item_border.float(r, s))
                  item_border.draw_rect(W, r)
               }
            }
         } else {
            item_paint.draw_rect(view.cbwin, e, item_border.float(r, s))
            item_border.draw_rect(view.cbwin, r)
         }
         if k === cursor then {
            if has_focus() & is_unshaded() then { 
               use {
                  W := Gui.style.get_cursor_clone(view.cbwin),
                  W.draw_rectangle(r.x, r.y, r.w, r.h, Gui.FINE_WIDTH)
               }
            } else
               Gui.style.draw_dashed_rectangle(view.cbwin, r.x, r.y, r.w, r.h)
         }
         if k === over then 
            Gui.style.fill_over_rectangle(view.cbwin, r.x, r.y, r.w, r.h)
         xp +:= col_w[j] + gutter
      }
   end

   public calculate_subject_width()
      do_columnize(predict_view_width(w, vsb))
      return col_w[1]
   end

   private invalidate_columnize()
      data_w := prev_columnize_dw := &null
      return self
   end

   public focus_changed(e) 
      if is_live() then
         invalidate_line(get_row_for_index(\cursor))
   end

   public layout()
      invalidate_subject_width()
      invalidate_line_count()
      ScrollArea.layout()
   end

   public set_internal_fields()
      local had_vsb
      had_vsb := self.vsb
      ScrollArea.set_internal_fields()
      if had_vsb ~=== self.vsb then {
         invalidate_subject_width()
         invalidate_line_count()
         ScrollArea.set_internal_fields()
      }
   end

   public get_default_subject_height(dw)
      do_columnize(dw)
      return n_rows * get_line_height()
   end

   private do_columnize(dw)
      local cr, tb
      if \prev_columnize_dw &
         (dw = prev_columnize_dw |
          (*col_w = 1 & dw < prev_columnize_dw)) then
         return
      prev_columnize_dw := dw
      if /data_w then {
         tb := item_border.get_total_width( )
         data_w := ipl.pdco.List{ item_paint.get_width(view.cbwin, (!data)) + tb }
      }
      cr := columnize(data_w, dw, gutter)
      n_rows := cr.rows
      col_w := cr.width
   end

   public calculate_line_height()
      return item_paint.get_constant_height(view.cbwin) + item_border.get_total_height() | runerr("Need a constant height")
   end

   public calculate_line_count()
      do_columnize(predict_view_width(w, vsb))
      return n_rows
   end

   public get_element_under_pointer(e)
      local i, j, d, s, r, xp, yp, fs, k
      i := get_line_under_pointer(e) | fail
      xp := get_subject_x()
      yp := get_subject_y() + get_line_height() * (i - 1)
      every j := 1 to *col_w do {
         if xp <= e.x < xp + col_w[j] then {
            k := i + (j - 1) * n_rows
            d := data[k] | fail
            s := item_paint.get_size(view.cbwin, d)
            r := Rect(xp, yp, col_w[j], get_line_height())
            fs := item_border.float(r, s)
            if fs.inside(e.x, e.y) then
               return k
            else
               fail
         }
         xp +:= col_w[j] + gutter
      }
   end

   private handle_in_chain(e)
      local k
      *parent_dialog.held = 0 | fail
      if k := get_element_under_pointer(e) then {
         set_over(k)
         view.set_pointer("hand1")
      } else {
         set_over()
         view.set_pointer()
      }
   end

   private handle_exit(e)
      *parent_dialog.held = 0 | fail
      set_over()
   end

   public set_over(n)
      if n ~=== over then {
         invalidate_line(get_row_for_index(\over))
         over := n
         invalidate_line(get_row_for_index(\over))
         fire("over-changed")
      }
      return self
   end

   public handle_lmdrag(e)
      if \held = get_element_under_pointer(e) then {
         set_highlight(held)
         set_over(held)
      } else {
         set_highlight()
         set_over()
      }
   end

   public handle_lrelease(e)
      \held | fail
      if \over then {
         set_highlight()
         fire("lclicked", e)
      }
      held := &null
   end

   public handle_mrelease(e)
      \held | fail
      if \over then {
         set_highlight()
         fire("mclicked", e)
      }
      held := &null
   end

   public get_row_for_index(n)
      return (n - 1) % \n_rows + 1
   end

   public get_col_for_index(n)
      return (n - 1) / \n_rows + 1
   end

   public set_cursor(n)
      if cursor ~=== n then {
         invalidate_line(get_row_for_index(\cursor))
         cursor := n
         constrain_cursor()
         invalidate_line(get_row_for_index(\cursor))
      }
      return self
   end

   public set_highlight(n)
      if highlight ~=== n then {
         set_cursor(\n)
         invalidate_line(get_row_for_index(\highlight))
         highlight := n
         ensure_line_visible(get_row_for_index(\highlight)) 
         invalidate_line(get_row_for_index(\highlight))
      }
      return self
   end

   public get_highlight()
      return .\highlight
   end

   public get_held()
      return .\held
   end

   public object_get_cursor()
      return data[.\cursor]
   end

   public object_set_cursor(o)
      return set_cursor(keyof(data, o))
   end
   
   public get_cursor()
      return .\cursor
   end

   public handle_lmpress(e)
      *parent_dialog.held = 1 | fail
      if \over then {
         if /e.shift then {
            set_highlight(over)
            held := over
         } else
            set_cursor(over)
      } 
   end

   public handle_key_page_up(e)
      local t
      t := get_page_movement(cursor, -1)
      t <:= n_rows * (get_col_for_index(cursor) - 1) + 1
      return t
   end

   public handle_key_page_down(e)
      local t
      t := get_page_movement(cursor, 1)
      t >:= n_rows * get_col_for_index(cursor)
      return t
   end

   public handle_key_up(e)
      return cursor - 1
   end

   public handle_key_down(e)
      return cursor + 1
   end

   public handle_key_left(e)
      local t
      (cursor > 1) | fail
      t := cursor - n_rows
      if t < 1 then {
         t +:= *col_w * n_rows - 1
         if t > *data then
            t -:= n_rows
      }
      return t
   end

   public handle_key_right(e)
      local t
      t := cursor + n_rows
      if t > *data then {
         t := (t - 1) % n_rows + 2
         t <= n_rows | fail
      }
      return t
   end

   public handle_key_home(e)
      return 1
   end

   public handle_key_end(e)
      return *data
   end

   public handle_return(e)
      local t
      \cursor | fail
      ensure_line_visible(get_row_for_index(cursor))
      set_highlight(cursor)
      t := Dispatcher.new_task{{
         t.sleep(50)
         set_highlight()
         fire("lclicked", e)
         t.revert()
      }}
      t.start()
   end

   private handle_key_move(f)
      \cursor | fail
      set_cursor(f())
      ensure_line_visible(get_row_for_index(cursor))
   end

   public handle_key(e)
      case e.code of {
         Key.HOME : handle_key_move(handle_key_home)
         Key.END : handle_key_move(handle_key_end)
         Key.PGUP : handle_key_move(handle_key_page_up)
         Key.PGDN : handle_key_move(handle_key_page_down)
         Key.UP : handle_key_move(handle_key_up)
         Key.DOWN : handle_key_move(handle_key_down)
         Key.LEFT : handle_key_move(handle_key_left)
         Key.RIGHT : handle_key_move(handle_key_right)
         "\r" | "\l": handle_return(e)
      }
   end

   public constrain_cursor()
      if *data = 0 then
         cursor := &null
      else {
         /cursor := 1
         cursor <:= 1
         cursor >:= *data
      }
   end

   public set_held(d)
      self.held := d
      return self
   end

   public data_changed()
      # set_over() is necessary even if the caller does a
      # resynch_pointer, since we store over as an index (which may
      # change) rather than the underlying object.
      set_over()
      invalidate_columnize()
      invalidate_subject_width()
      invalidate_line_count()
      compute_and_invalidate()
      constrain_cursor()
      return self
   end

   public set_data(l)
      self.data := l
      data_changed()
      return self
   end

   public set_gutter(n)
      self.gutter := n
      return self
   end

   public keeps(e)
      return member(Key.CURSOR, e.code)
   end

   public new()
      LineBasedScrollArea.new()
      data := []
      gutter := scale(8)
      item_paint := TextItemPaint()
      item_border := NullBorder().set_x_align(Align.L)
      view.connect(self.handle_lmpress, Event.MOUSE_LEFT_PRESS)
      view.connect(self.handle_lmpress, Event.MOUSE_MIDDLE_PRESS)
      view.connect(self.handle_lmdrag, Event.MOUSE_LEFT_DRAG)
      view.connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE)
      view.connect(self.handle_lmdrag, Event.MOUSE_MIDDLE_DRAG)
      view.connect(self.handle_mrelease, Event.MOUSE_MIDDLE_RELEASE)
      view.connect(self.handle_in_chain, Event.IN_POINT_CHAIN)
      view.connect(self.handle_exit, Event.MOUSE_EXIT)
      connect(self.handle_key, Event.KEY_PRESS)
      return
   end
end

class DirList(ButtonOnlyList)
   public create_button()
      local b
      b := IconButton().set_paint(ImagePaint().set_cache("gui.FAVOURITES_24"))
      theme_toolbar_button(b, "emblem-favorite")
      return b
   end

   public create_popup()
      return ItemPaintList().
         set_item_paint(StringDirItemPaint()).
         set_item_border(EmptyBorder().
                            set_insets(Gui.TEXT_INSET, Gui.TEXT_INSET, 0, 0).
                            set_x_align(Align.L))
   end
end

# Store objects rather than just strings in the history list to avoid
# confusion when the dir changes whilst the history list is open.
# With just strings we wouldn't be able to match up the selected
# string with a position in the (possibly changed) history.

record HistoryEntry(dir)

class HistoryEntryItemPaint(StringDirItemPaint)
   public get_string(data)
      return data.dir
   end
end

class HistoryList(ButtonOnlyList)
   public create_button()
      local b
      b := IconButton().set_paint(ImagePaint())
      theme_toolbar_button(b, "view-history")
      return b
   end

   public create_popup()
      local t
      t := parent.parent
      set_selection_list(copy(t.history))
      set_selection(t.history_pos)
      return ItemPaintList().
         set_item_paint(HistoryEntryItemPaint()).
         set_item_border(EmptyBorder().
                            set_insets(Gui.TEXT_INSET, Gui.TEXT_INSET, 0, 0).
                            set_x_align(Align.L))
   end
end

class Terminal(TabItem, VtUI)
   public static const
      MAX_HISTORY_SIZE,
      SHOW_NAME_ONLY,
      SHOW_DATE,
      SHOW_SIZE

   private
      prev_button,
      next_button,
      date_button,
      name_button,
      size_button,
      favourites_list,
      message_label,
      search_panel,
      search_field,
      search_label, 
      search_close_button,
      search_next_button,
      search_prev_button, 
      history_list,
      trail,
      best_focus         # Either columns or output (the vt)

   private readable
      ascending,
      sorter,
      annotate_opt,
      filter,
      refresh_button,
      up_button,
      home_button,
      close_button,
      focus_columns_button,
      output,
      columns,
      split,
      columns_pos_table,
      history,
      history_pos,
      nav_dir,
      io_task,
      check_cwd_task,
      pid, 
      tty,
      input,
      cwd,
      cwd_mtime,
      cwd_list,
      show_hidden_menu_item,
      mix_entries_menu_item,
      sort_dirs_menu_item,
      revert_tab

   private static init()
      MAX_HISTORY_SIZE := 100
      SHOW_NAME_ONLY := 1
      SHOW_DATE := 2
      SHOW_SIZE := 3
   end

   public get_label_width()
      return scale(100)
   end

   public link_left_clicked(url)
      open_link(url)
   end

   public vt_size_changed(cols, rows)
      if \opts["v"] then
         write("Vt size changed to: ", cols, ",", rows)
      tty.set_size(cols, rows)
   end

   public do_tab_cmd(s)
      case string(s) of {
         "minimize" : on_min_terminal()
         "maximize" : on_max_terminal()
         "normal-size" : on_normal_terminal()
         "list-focus" : {
            focus_columns_button.toggle_is_checked().invalidate()
            on_focus_columns_button()
         }
         "reorient" | "re-orient" : on_reorient()
         "sort-name" : on_name_button()
         "sort-date" : on_date_button()
         "sort-size" : on_size_button()
         "show-name-only" : on_show_name_only()
         "show-date" : on_show_date()
         "show-size" : on_show_size()
         "mix-entries" : {
            mix_entries_menu_item.toggle_is_checked()
            on_mix_entries_menu_item()
         }
         "show-hidden" : {
            show_hidden_menu_item.toggle_is_checked()
            on_show_hidden_menu_item()
         }
         "sort-dirs" : {
            sort_dirs_menu_item.toggle_is_checked()
            on_sort_dirs_menu_item()
         }
         "select" : {
            parent.set_which_one(self)
         }
         default: return error("Invalid command: " || s)
      }
      return self
   end

   private on_max_terminal()
      split.first.set_size(0, 0).reset_layout()
      if is_live() then
         split.do_layout().invalidate()
   end

   private on_min_terminal()
      split.first.set_size(lang.Limit.MaxWord, lang.Limit.MaxWord).reset_layout()
      if is_live() then
         split.do_layout().invalidate()
   end

   private on_normal_terminal()
      split.first.set_size()
      if is_live() then
         split.do_layout().invalidate()
   end

   public link_middle_clicked(url, ev)
      insert_link(url, ev)
   end

   public send_tty(s)
      s := string(s) | runerr(103, s)
      put(input, s)
      # We may be in the io_task already since some writes to the vt
      # cause it to output something (eg device attr string).  So in
      # that case we must not interrupt.  Otherwise, the io_task
      # must be sleeping in poll().  Interrupt it so it goes round
      # its loop again, and polls for both input and output.
      (/io_task | Dispatcher.get_curr_task() === io_task) | io_task.interrupt()
      return self
   end

   public msg(s, n)
      message_label.set(s, n)
   end

   private setup_shell()
      local env, sh, xd, fp, s, sh2
      env := []
      every put(env, System.environ())
      put(env, "TERMLINKS=1")
      put(env, "TERM=xterm")
      sh := System.getpw(System.getuid()).shell | "/bin/sh"
      if /opts["nx"] then {
         s := \opts["x"] | Files.get_home() || "/termlinks-extras/bin"
         fp := FilePath(s).canonical()
         xd := fp.str()
         if Files.access(xd) then {
            put(env, "PATH=" || xd || ":" || System.getenv("PATH"))
            if sh == "/bin/sh" | find("bash", sh) then {
               sh2 := fp.child("bash").str()
               if Files.access(sh2) then
                  sh := sh2
               else
                  info_msg("Unable to access extras bash shell '" || sh2 || "'")
            }
         } else
            info_msg("Unable to access extras bin directory '" || xd || "'")
      }
      tty := PttyStream() | fail
      (tty.flag(FileOpt.NONBLOCK) &
       pid := System.fork()) | {
         tty.close()
         fail
      }
      if pid > 0 then {
         # Parent
         return
      } else {
         # Child
         System.setsid() | stop(&why)
         tty.close()
         tty := tty.open_slave() | stop(&why)
         tty.dup2(FileStream.stdout) | stop(&why)
         tty.dup2(FileStream.stdin) | stop(&why)
         tty.dup2(FileStream.stderr) | stop(&why)
         System.exec(sh, [], env) | stop(&why)
         syserr("Not reached")
      }
   end

   public get_pats()
      local pat, pats
      pats := []
      filter.get_contents() ? {
         repeat {
            pat := tab(upto(';') | 0)
            put(pats, Wildcard(pat))
            move(1) | break
         }
      }
      return pats
   end

   private check_pwd()
      local s
      s := ucs(Files.readlink("/proc/" || pid || "/cwd")) | fail
      if s ~== cwd then {
         set_cwd(s, if s === nav_dir then &yes else &no)
         nav_dir := &null
      }
   end

   # Avoid a little glitch which happens when a button is greyed out
   # while held down, leaving it stuck like that, since it never gets the
   # release event.
   #
   private set_is_shaded_ex(b, v)
      if \v then
         b.clear_down()
      b.set_is_shaded(v)
   end

   private update_grey()
      set_is_shaded_ex(prev_button, if history_pos < *history then &no else &yes)
      set_is_shaded_ex(next_button, if history_pos > 1 then &no else &yes)
   end

   private send_vt(s)
      output.input(s)
   end

   private check_cwd()
      local t
      repeat {
         if t := get_ns_mtime(cwd) then {
            if t ~= cwd_mtime then
               refresh_cwd()
         }
         check_cwd_task.sleep(500)
      }
   end

   private service_tty()
      local x, s, n, i, some_in
      repeat {
         # The some_in flag ensures we don't send anything to the tty
         # until we've seen some input (a prompt).  This is since
         # readline will misinterpret what's in the buffer before it
         # starts up, muddling up \n with \r, because readline clears the
         # ICRNL bit in the termios c_iflag structure (see rltty.c).
         i := if *input > 0 & \some_in then Poll.IN + Poll.OUT else Poll.IN
         x := io_task.poll([tty, i]) | {
            if /io_task.interrupt_flag then {
               err_msg(u"IO problem polling tty: " || ucs(&why))
               break
            } else {
               # We were interrupted, meaning that some input has gone into the
               # buffer; so go round again.
               next
            }
         }
         if DescStream.poll_out_test(x[1]) then {
            s := get(input) | syserr("Poll out, but input buffer empty")
            n := tty.out(s) | {
               err_msg(u"IO problem on tty: " || ucs(&why))
               break
            }
            if n < *s then
               push(input, s[n + 1:0])
            if \opts["v"] then
               write("Out: ", image(s))
         } else if DescStream.poll_in_test(x[1]) then {
            s := tty.in(1048576) | {
               err_msg(u"IO problem on tty: " || ucs(&why))
               break
            }
            if /s then {
               err_msg(u"EOF on tty")
               break
            }
            if \opts["v"] then
               write("In: ", image(s))
            send_vt(s)
            check_pwd()
            some_in := &yes
         }
      }
      io_task.revert()
   end

   public open_link(url)
      local r
      case string(url.scheme) of {
         "text": send_tty(ucs(url.get_decoded_path()))
         "tab": {
            parent_dialog.do_tab_cmd(ipl.pdco.List{ URL.percent_decode(separate(url.get_path(), ';')) }) |
               info_msg(&why)
         }
         default: {
            if r := get_runners(url) then {
               if is(r, ExternalRunner) then
                  parent_dialog.launch_prog(r)
               else
                  run_prog(r.get_command())
            } else
               info_msg(&why)
         }
      }
   end

   public insert_link(url, ev)
      local s, es
      if url.scheme == u"file" then {
         if s := ucs(url.get_decoded_path()) then {
            es := if /ev.ctrl & 
               is_local_host(url) &
               s[1+:*cwd] == cwd & 
               s[*cwd + 1] == u"/" then
               u"./" || Format.shell_escape(s[*cwd+2:0])
            else
               Format.shell_escape(s)
            if Files.is_directory(s) then
               es ||:= u"/"
            else
               es ||:= u" "
            send_tty(es)
         }
      } else
         send_tty(url.ucs())
   end

   public err_msg(s)
      send_vt(u"\n\e[31m(Message from terminal:) " || s || u"\e[m")
      msg(s, 3000)
   end

   public info_msg(s)
      msg(s, 3000)
   end

   private static get_possible_desktop_entries(s)
      suspend Unique{Xdg.gen_desktop_entries(Xdg.alternative_mime_types(Xdg.get_mime_type_for_file(FilePath(s).get(-1))))}
   end

   private static get_possible_scheme_handler_desktop_entries(url)
      suspend Xdg.gen_desktop_entries("x-scheme-handler/" || string(url.scheme))
   end

   private static is_local_host(url)
      return url.host == ("localhost" | &host)
   end

   private get_runners(url)
      local s, cd, de, fl
      case string(url.scheme) of {
         "file" : {
            is_local_host(url) | return error(u"Can't run a file on another host (" || url.host || u")")
            s := ucs(url.get_decoded_path()) | return error(u"URL decoded path not utf8")
            if Files.is_directory(s) then
               return ImmediateRunner(u"cd " || Format.shell_escape(s))
            # Get a DesktopEntry based on the content-type if available, or the filename.
            every de := get_possible_desktop_entries(s) do {
               fl := 1
               suspend DesktopRunner(de, url, s)
            }
            return if /fl then error(u"No matching desktop entry for this URL")
         }
         "run" : {
            s := ucs(url.get_decoded_path()) | return error(u"URL decoded path not utf8")
            return ImmediateRunner(s)
         }
         "launch" : {
            s := ucs(url.get_decoded_path()) | return error(u"URL decoded path not utf8")
            if cd := member(url.extract_cgi_parameters(), "wd")[1] then
               cd := ucs(cd) | return error(u"CD decoded path not utf8")
            return LaunchRunner(s, cd)
         }
         default : {
            every de := get_possible_scheme_handler_desktop_entries(url) do {
               fl := 1
               suspend DesktopRunner(de, url, url.ucs())
            }
            return if /fl then error(u"No desktop entry for url scheme " || url.scheme)
         }
      }
   end

   private on_columns_lclick()
      local item
      item := columns.data[columns.get_cursor()] | fail
      open_link(item_to_url(item))
   end

   private item_to_url(item)
      local s
      s := FilePath(cwd).child(item.name).ucs() | fail
      return URL(u"file://" || URL.percent_encode(s, URL.UNRESERVED ++ '/'))
   end

   private on_columns_mclick(ev)
      local item
      item := columns.data[columns.get_cursor()]
      insert_link(item_to_url(item), ev)
   end

   private on_columns_over_changed(ev)
      local s, url
      if /columns.over then
         msg()
      else {
         s := FilePath(cwd).child(columns.data[columns.over].name).ucs() | fail
         url := URL(u"file://" || URL.percent_encode(s, URL.UNRESERVED ++ '/')) | fail
         msg(url.ucs())
      }
   end

   private copy_link(url)
      local s
      s := ucs(url.get_decoded_path()) | fail
      if url.scheme == u"file" then
         s := Format.shell_escape(s)
      parent_dialog.own_selection(Selection.CLIPBOARD, 
                                  StaticTextSelectionOwner(s))
   end

   private copy_link_url(url)
      parent_dialog.own_selection(Selection.CLIPBOARD,
                                  URLSelectionOwner([url]))
   end 

   private rename(s)
      local d
      d := RenameDialog(s)
      d.show_modal()
      s := \d.result | fail
      msg("Renamed OK", 3000)
      if cwd == FilePath(s).parent().ucs() then
         refresh_cwd()
   end

   private on_paste(e)
      output.handle_paste(e)
   end

   private on_copy(e)
      output.handle_copy(e)
   end

   private on_copy_cwd(e)
      parent_dialog.own_selection(Selection.CLIPBOARD, 
                                  StaticTextSelectionOwner(Format.shell_escape(cwd)))
   end

   private on_select_all()
      output.handle_select_all()
   end

   private open_in_new_tab(dir)
      parent_dialog.new_tab(, dir)
   end

   private on_reorient(e)
      split.first.set_size().reset_layout()
      split.reorient()
   end

   public create_context_menu()
      local m
      m := Menu()
      if output.get_current_text_selection() then {
         m.add(TextMenuItem().
               set_label("Copy text").
               connect(on_copy, Event.ACTION))
      }
      m.add(TextMenuItem().
            set_label("Paste").
            connect(on_paste, Event.ACTION))
      m.add(TextMenuItem().
            set_label("Select all").
            connect(on_select_all, Event.ACTION))
      m.add(TextMenuItem().
            set_label("Copy cwd").
            connect(on_copy_cwd, Event.ACTION))
      m.add(TextMenuItem().
            set_label("Reorient").
            connect(on_reorient, Event.ACTION))
      if split.first.w_spec ~=== 0 then {
         m.add(TextMenuItem().
               set_label("Maximize").
               connect(on_max_terminal, Event.ACTION))
      }
      if split.first.w_spec ~=== lang.Limit.MaxWord then {
         m.add(TextMenuItem().
               set_label("Minimize").
               connect(on_min_terminal, Event.ACTION))
      }
      if split.first.w_spec === (0 | lang.Limit.MaxWord) then {
         m.add(TextMenuItem().
               set_label("Normal size").
               connect(on_normal_terminal, Event.ACTION))
      }
      if not search_panel.is_live() then
         m.add(TextMenuItem().
               set_label("Search").
               connect(open_search_panel, Event.ACTION))
      return m
   end

   private create_insert_cmd(r)
      return create send_tty(r.get_command())
   end

   private create_launch(r)
      return create parent_dialog.launch_prog(r)
   end

   private create_open_with_menu(url)
      local m, m1, r, de
      m := Menu().set_label("Open with")
      every r := get_runners(url) do {
         if is(r, DesktopRunner) then {
            de := r.desktop_entry
            m1 := TextMenuItem().
               set_label(de.name).
               connect(create_launch(r), Event.ACTION)
            m1.set_paint_left(ImagePaint().set_cache(Xdg.find_icon_and_cache(\de.icon, 12)))
            m.add(m1)
         }
      }
      if *m.children > 0 then
         return m
   end

   public create_link_menu(url)
      local m, s, r
      m := Menu()
      if url.scheme == (u"file" | u"text" | u"run") then {
         m.add(TextMenuItem().
               set_label("Copy").
               connect(create copy_link(url), Event.ACTION))
      }
      m.add(TextMenuItem().
            set_label("Copy URL").
            connect(create copy_link_url(url), Event.ACTION))
      if r := get_runners(url) then
         m.add(TextMenuItem().
            set_label("Insert command").
            connect(create_insert_cmd(r), Event.ACTION))
      if url.scheme == u"file" then {
         if is_local_host(url) & s := ucs(url.get_decoded_path()) then {
            if Files.is_directory(s) then {
               m.add(TextMenuItem().
                     set_label("Open in new tab").
                     connect(create open_in_new_tab(s), Event.ACTION))
            } else
               m.add(create_open_with_menu(url))

            m.add(TextMenuItem().
                  set_label("Rename").
                  connect(create rename(s), Event.ACTION))
         }
      } else
         m.add(create_open_with_menu(url))
      return m
   end

  private on_columns_rpress(e)
      local i, m, pm, item, url
      pm := PopupMenu()
      if item := columns.data[i := columns.get_element_under_pointer(e)] then {
         url := item_to_url(item) | fail
         columns.set_highlight(i).set_over()
         m := create_link_menu(url)
         pm.connect(on_popup_closed, Event.POPUP_CLOSED)
      } else
         m := create_columns_context_menu()
      pm.popup(parent_dialog, m, e.x, e.y)
   end

   public get_tab_tooltip()
      if tab_w - label_border.get_total_width() < cbwin.text_width(paint.str) then
         return paint.str
   end

   private on_show_name_only(e)
      annotate_opt := SHOW_NAME_ONLY
      annotate_cwd_list()
      columns.data_changed()
   end

   private on_show_date(e)
      annotate_opt := SHOW_DATE
      annotate_cwd_list()
      columns.data_changed()
   end

   private on_show_size(e)
      annotate_opt := SHOW_SIZE
      annotate_cwd_list()
      columns.data_changed()
   end

   private on_mix_entries_menu_item(e)
      annotate_cwd_list()
      resort_cwd()
   end

   private on_sort_dirs_menu_item(e)
      annotate_cwd_list()
      resort_cwd()
   end

   private on_show_hidden_menu_item(e)
      resort_cwd(&yes)
   end

   public create_columns_context_menu()
      local m
      m := Menu()
      if annotate_opt ~= SHOW_NAME_ONLY then
         m.add(TextMenuItem().
            set_label("Name only").
            connect(on_show_name_only , Event.ACTION))
      if annotate_opt ~= SHOW_DATE then
         m.add(TextMenuItem().
            set_label("Show date").
            connect(on_show_date, Event.ACTION))
      if annotate_opt ~= SHOW_SIZE then
         m.add(TextMenuItem().
            set_label("Show size").
            connect(on_show_size, Event.ACTION))
      m.add(MenuSeparator())
      m.add(show_hidden_menu_item)
      if mix_entries_menu_item.is_unchecked() then
         m.add(sort_dirs_menu_item)
      m.add(mix_entries_menu_item)
      return m
   end

   private on_popup_closed()
      columns.set_highlight()
   end

   private run_prog(s)
      send_tty(s || u"\r")
   end

   public goto_dir(d, nav)
      d := ucs(d) | fail
      nav_dir := if /nav then &null else d
      run_prog(u"cd " || Format.shell_escape(d))
   end

   private synch_paints()
      local cp, np, sp, dp, sz
      sz := Gui.TOOLBAR_ICON_SIZE
      cp := CompoundPaint().set_top(ImagePaint().set_cache(if /ascending then "gui.TINY_ARROW_DOWN" else "gui.TINY_ARROW_UP"))
      np := ImagePaint().set_cache(ImageCache.get_key_with_resize("gui.FONT_24", sz, sz))
      sp := ImagePaint().set_cache(ImageCache.get_key_with_resize("gui.FILESIZE_24", sz, sz))
      dp := ImagePaint().set_cache(ImageCache.get_key_with_resize("gui.CLOCK_24", sz, sz))
      case sorter of {
         Files.name_cmp: {
            name_button.set_paint(cp.set_bottom(np))
            date_button.set_paint(dp)
            size_button.set_paint(sp)
         }
         Files.size_cmp: {
            name_button.set_paint(np)
            date_button.set_paint(dp)
            size_button.set_paint(cp.set_bottom(sp))
         }
         Files.date_cmp: {
            name_button.set_paint(np)
            date_button.set_paint(cp.set_bottom(dp))
            size_button.set_paint(sp)
         }
      }
      resort_cwd()
   end

   private on_date_button(ev)
      if sorter === Files.date_cmp then
         ascending := toggle_flag(ascending)
      else
         sorter := Files.date_cmp
      synch_paints()
   end

   private on_name_button(ev)
      if sorter === Files.name_cmp then
         ascending := toggle_flag(ascending)
      else
         sorter := Files.name_cmp
      synch_paints()
   end

   private on_size_button(ev)
      if sorter === Files.size_cmp then
         ascending := toggle_flag(ascending)
      else
         sorter := Files.size_cmp
      synch_paints()
   end

   private static get_ns_mtime(f)
      local st
      st := Files.stat(f) | fail
      return st.mtime * 1000000000 + st.mtime_ns
   end

   private load_cwd_list()
      cwd_mtime := get_ns_mtime(cwd) | 0
      (cwd_list := Files.ucs_list(cwd, AnnotatedListEntryWithIcon)) | {
         info_msg("Failed to read cwd: " || &why)
         cwd_list := []
      }
   end

   private annotate_cwd_list()
      local e, fl, now
      # flag indicates whether to annotate dirs with size/date
      if mix_entries_menu_item.is_checked() | sort_dirs_menu_item.is_checked() then
         fl := &yes
      now := Time.get_system_seconds()
      every e := !cwd_list do {
         if /fl & e.stat.mode_str[1] == "d" then
            e.annotate_name()
         else case annotate_opt of {
            SHOW_NAME_ONLY : e.annotate_name()
            SHOW_DATE : e.annotate_date(now)
            SHOW_SIZE : e.annotate_size()
            default : syserr("Bad annotate_opt")
         }
      }
   end

   private sort_cwd_list()
      local dirs, files, e, s, pats
      pats := get_pats()
      dirs := []
      files := []
      every e := !cwd_list do {
         s := e.name
         if (/pats | (!pats).match(s) = *s + 1)\1 &
            (show_hidden_menu_item.is_checked() | not(Files.is_hidden(s))) then {
            if e.stat.mode_str[1] == "d" then
               Files.is_relative_dir(s) | put(dirs, e)
            else
               put(files, e)
         }
      }
      if mix_entries_menu_item.is_checked() then
         while put(files, get(dirs))
      else {
         if sort_dirs_menu_item.is_checked() then
            qsort(dirs, if /ascending then sorter else flip(sorter))
         else
            qsort(dirs, Files.name_cmp)
      }
      qsort(files, if /ascending then sorter else flip(sorter))
      columns.set_data(dirs ||| files)
   end

   private resort_cwd(track_cursor)
      local i, ino, info, vis, high, held
      \cwd | fail
      if is_live() then {
         if \track_cursor & i := columns.get_row_for_index(columns.get_cursor()) then {
            # Set vis to &yes if the last highlight is currently visible; also get the ino of
            # the last highlight.
            info := columns.get_line_info()
            if info.first_whole <= i <= info.last_whole then
               vis := &yes
            ino := columns.object_get_cursor().stat.ino
            if columns.get_cursor() === columns.get_highlight() then
               high := &yes
            if columns.get_cursor() === columns.get_held() then
               held := &yes
         }
         sort_cwd_list()
         # Search for the old ino in the new data.  If found, set the highlight and if the old
         # cursor was visible, ensure the new one is too.
         if \track_cursor & i := Positions{(!columns.data).stat.ino, \ino} then {
            columns.set_cursor(i)
            if \vis then
               columns.ensure_line_visible(columns.get_row_for_index(columns.get_cursor()))
            if \high then
               columns.set_highlight(i)
            if \held then
               columns.set_held(i)
         } else
            columns.set_cursor()
         # Since the pointer may be over the files list, update the pointer.
         parent_dialog.resynch_pointer()
      } else
         sort_cwd_list()
   end

   private update_filter_list()
      local e, l, ex
      ex := table(0)
      every e := !cwd_list do {
         (e.stat.mode_str[1] == "d") |
            Files.is_hidden(e.name) |
            (ex[Files.get_extension(e.name)] +:= 1)
      }
      l := [u"*"]
      every e := back(sort(ex, 2)) do
         put(l, u"*." || e[1])
      filter.set_selection_only().synch_set_selection_list(l)
   end

   private refresh_cwd()
      load_cwd_list()
      annotate_cwd_list()
      resort_cwd(&yes)
      update_filter_list()
   end

   private set_cwd(s, nav)
      local lh, t, i
      s := ucs(s) | fail
      if \cwd then {
         lh := columns.data[columns.get_cursor()].name
         insert(columns_pos_table, 
                FilePath(cwd).canonical().str(), 
                FileDialogPos(lh, columns.get_area_y()))
      }
      cwd := s
      trail.set_path(cwd)
      load_cwd_list()
      annotate_cwd_list()
      # Reset filter to "*"
      filter.set_selection(1)
      sort_cwd_list()
      synch_favourites_list()
      update_filter_list()

      if is_live() then {
         if t := member(columns_pos_table, FilePath(cwd).canonical().str()) then {
            columns.set_area_y(t.area_y).set_area_x(0)
            if i := Positions{(!columns.data).name, \t.cursor_name} then
               columns.set_cursor(i)
            else
               columns.set_cursor()
         } else
            columns.set_area_y(0).set_area_x(0).set_cursor()
         parent_dialog.resynch_pointer()
      }

      if /nav then {
         every 1 to history_pos - 1 do
            pop(history)
         push(history, HistoryEntry(cwd))
         history_pos := 1
         while *history > MAX_HISTORY_SIZE do
            pull(history)
         update_grey()
      }
      set_paint(AbbreviatedTextPaint(FilePath(cwd).get(-1)))
      return self
   end

   public get_favourites_directories()
      local t
      t := []
      every put(t,
                Files.getcwd() | 
                FavouriteDirectoriesDialog.gen_directories())
      return lunique(FileDialog.ucs_list(t))
   end

   public refresh_favourite_dirs()
      favourites_list.set_selection_list(get_favourites_directories())
      synch_favourites_list()
   end

   private synch_favourites_list()
      favourites_list.object_set_selection(cwd) | favourites_list.set_selection()
   end

   private on_trail(ev)
      goto_dir(ev)
   end

   public new(dir, other, revert_tab)
      local cd
      TabItem.new()
      self.revert_tab := revert_tab
      setup()
      setup_search_panel()

      if \other then {
         if other.focus_columns_button.is_checked() then {
            focus_columns_button.set_is_checked(&yes)
            columns.set_accepts_focus(&yes)
         }
         if \other.split.sizer.is_horizontal_flag then
            split.reorient()
         split.first.set_size(other.split.first.w_spec, other.split.first.h_spec)
         sorter := other.sorter
         ascending := other.ascending
         annotate_opt := other.annotate_opt
         set_remembered_focus(if other.parent_dialog.focus === other.columns.find_focus() then
            columns.find_focus()
         else
            output.find_focus())
      } else {
         if \opts["hs"] then
            split.reorient()
         sorter := Files.name_cmp
         annotate_opt := SHOW_NAME_ONLY
         set_remembered_focus(output.find_focus())
      }
      synch_paints()
      set_label_border(EmptyBorder().set_x_align(Align.L))
      columns.
         set_item_paint(AnnotatedIconFilesItemPaint()).
         set_item_border(EmptyBorder().
                             set_insets(Gui.TEXT_INSET, Gui.TEXT_INSET, 0, 0).
                             set_x_align(Align.L)).
         connect(on_columns_lclick, "lclicked").
         connect(on_columns_mclick, "mclicked").
         connect(on_columns_over_changed, "over-changed").
         connect(on_columns_rpress, Event.MOUSE_RIGHT_PRESS)
      trail.
         set_size().
         set_constraint("l_inset", scale(10)).
         connect(on_trail, FileTrail.DIR_CHANGED_EVENT)

      output.
         set_ui(self)
      output.set_history_size(\opts["h"])
      if \opts["v"] then
         output.set_verbose(&yes)
      output.set_normal_fg(\opts["tfg"])
      output.set_normal_bg(\opts["tbg"])
      output.set_reverse_fg(\opts["trevfg"])
      output.set_reverse_bg(\opts["trevbg"])
      output.set_font(\opts["tfont"])

      favourites_list.set_size().set_selection_list(get_favourites_directories())
      sort_dirs_menu_item := CheckBoxMenuItem().
         set_label("Sort dirs").
         connect(on_sort_dirs_menu_item, Event.ACTION)
      mix_entries_menu_item := CheckBoxMenuItem().
         set_label("Mix files & dirs").
         connect(on_mix_entries_menu_item, Event.ACTION)
      show_hidden_menu_item := CheckBoxMenuItem().
         set_label("Show hidden files").
         connect(on_show_hidden_menu_item, Event.ACTION)
      if \other then {
         sort_dirs_menu_item.set_is_checked(other.sort_dirs_menu_item.get_status())
         mix_entries_menu_item.set_is_checked(other.mix_entries_menu_item.get_status())
         show_hidden_menu_item.set_is_checked(other.show_hidden_menu_item.get_status())
      }
      filter.set_selection_list([u"*"])
      history_list.set_size().set_selection_list([])
      input := []
      theme_toolbar_button(close_button, "window-close")
      theme_toolbar_button(prev_button, "go-previous")
      theme_toolbar_button(next_button, "go-next")
      theme_toolbar_button(up_button, "go-up")
      theme_toolbar_button(home_button, "go-home")
      theme_toolbar_button(refresh_button, "view-refresh")
      theme_toolbar_button(focus_columns_button, "key-enter")
      cd := ucs(Files.getcwd()) | u"/"
      if \other then {
         history := clone(other.history)
         history_pos := other.history_pos
         columns_pos_table := clone(other.columns_pos_table)
         set_cwd(cd, &yes)
         if other.cwd ~== cwd then
            goto_dir(other.cwd, &yes)
      } else {
         history := []
         history_pos := 0
         columns_pos_table := table()
         set_cwd(cd)
         if \dir ~== cwd then
            goto_dir(dir)
      }
      update_grey()
      return
   end

   public initially()
      TabItem.initially()
      setup_shell() | stop(&why)
      io_task := Dispatcher.new_task{service_tty()}
      io_task.start()
      check_cwd_task := Dispatcher.new_task{check_cwd()}
      check_cwd_task.start()
   end

   public finally()
      TabItem.finally()
      check_cwd_task.stop()
      io_task.stop()
      System.kill(pid, Signal.SIGHUP)
      tty.close()
      System.wait(pid)
      check_cwd_task := io_task := tty := &null
   end

   private on_favourites_list(ev)
      goto_dir(favourites_list.object_get_selection())
   end

   private on_history_list(ev)
      local he
      he := history_list.object_get_selection()
      history_pos := keyof(history, he) | fail
      update_grey()
      goto_dir(he.dir, &yes)
   end

   private on_home_button(ev)
      goto_dir(Files.get_home())
   end

   private on_refresh_button(ev)
      refresh_cwd()
   end

   private on_up_button(ev)
      local t
      t := FilePath(cwd).canonical()
      if t.size() > 1 then
         goto_dir(t.parent().str())
   end

   private on_close_button(ev)
      local t, i
      if *parent.children = 1 then
         parent_dialog.dispose()
      else {
         (i := parent.get_index(\revert_tab)) | {
            i := parent.get_index(self)
            if i > 1 then
               i -:= 1
            else
               i +:= 1
         }
         t := parent.children[i] | syserr("Couldn't find other tab")
         parent.
            remove(self).
            set_which_one(t).
            do_layout().
            invalidate()
      }
   end

   private on_filter_action(ev)
      resort_cwd(&yes)
      parent_dialog.set_focus(best_focus)
   end

   private on_filter_content_changed(ev)
      if filter.was_applied(ev) then
         on_filter_action()
   end

   private on_prev_button(ev)
      local he
      (history_pos < *history) | fail
      he := history[history_pos +:= 1]
      update_grey()
      goto_dir(he.dir, &yes)
   end

   private on_next_button(ev)
      local he
      (history_pos > 1) | fail
      he := history[history_pos -:= 1]
      update_grey()
      goto_dir(he.dir, &yes)
   end

   private on_focus_columns_button(ev)
      local f
      f := focus_columns_button.get_status()
      columns.set_accepts_focus(f)
      if is_live() then {
         if /f then
            parent_dialog.set_focus(output)
         else
            parent_dialog.set_focus(columns)
      } else {
         if /f then
            set_remembered_focus(output)
         else
            set_remembered_focus(columns)
      }
   end

   private on_columns_focus(ev)
      best_focus := columns
   end

   private on_vt_focus(ev)
      best_focus := output
   end

   private open_search_panel()
      split.second.
         add(search_panel, 0).
         reset_layout().
         do_layout().
         invalidate()
      parent_dialog.set_focus(search_field)
   end

   private close_search_panel()
      split.second.
         remove(search_panel).
         reset_layout().
         do_layout().
         invalidate()
      parent_dialog.set_focus(output.find_focus())
   end

   public search_msg(s)
      /s := ""
      search_label.set_label(s)
   end

   private on_search_field()
      output.do_search(search_field.get_contents())
   end

   private on_search_next()
      output.do_search_next()
   end

   private on_search_prev()
      output.do_search_prev()
   end

   private setup_search_panel()
      search_panel := Component().
         set_constraint("eol", &yes).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_layout(GridLayout().set_doi(0).set_dii(2).set_extra("cells"))
      search_close_button := IconButton().
         set_tooltip(TextPaint("Close")).
         connect(close_search_panel, Event.ACTION).
         set_no_click_focus(&yes).
         set_paint(ImagePaint().set_cache("gui.CLOSE_24"))
      search_panel.add(search_close_button)
      search_field := TextField().
         set_width(scale(150)).
         set_contents(u"").
         connect(on_search_field, Event.CONTENT_CHANGED).
         connect(on_search_field, Event.ACTION)
      search_panel.add(search_field)
      search_prev_button := IconButton().
         set_tooltip(TextPaint("Prev")).
         connect(self.on_search_prev, Event.ACTION).
         set_no_click_focus(&yes).
         set_paint(ImagePaint().set_cache("gui.PREV_24"))
      search_panel.add(search_prev_button)
      search_next_button := IconButton().
         set_tooltip(TextPaint("Next")).
         connect(self.on_search_next, Event.ACTION).
         set_no_click_focus(&yes).
         set_paint(ImagePaint().set_cache("gui.NEXT_24"))
      search_panel.add(search_next_button)
      search_label := Label().
         set_label("").
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("l_inset", 5).
         set_width(scale(75))
      search_panel.add(search_label)
   end

   private setup()
      local paint_2, paint_14, paint_27, paint_32, paint_7, layout_4, paint_11, paint_37, paint_42, panel_4, paint_29, split_content_3, split_content_4, paint_9, layout_6, paint_13, paint_31, paint_44, paint_6, layout_3, paint_10, paint_23, paint_41, paint, paint_3, paint_28, paint_8, border_1, layout_5, paint_12, paint_30, paint_40
      paint_10 := ImagePaint().
         set_cache("rpp.EXIT_24")
      paint_9 := TextPaint("Close")
      close_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_9).
         set_accel("c").
         connect(self.on_close_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_10)
      paint_8 := ImagePaint().
         set_cache("gui.HOME_24")
      paint := TextPaint("Home")
      home_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint).
         connect(self.on_home_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_8)
      paint_3 := ImagePaint().
         set_cache("gui.UP_24")
      paint_2 := TextPaint("Up")
      up_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_2).
         connect(self.on_up_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_3)
      paint_7 := ImagePaint().
         set_cache("gui.REFRESH_24")
      paint_6 := TextPaint("Refresh")
      refresh_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_6).
         connect(self.on_refresh_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_7)
      paint_12 := ImagePaint().
         set_cache("gui.PREV_24")
      paint_11 := TextPaint("Prev")
      prev_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_11).
         connect(self.on_prev_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_12)
      paint_14 := ImagePaint().
         set_cache("gui.NEXT_24")
      paint_13 := TextPaint("Next")
      next_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_13).
         connect(self.on_next_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_14)
      paint_41 := TextPaint("History")
      history_list := HistoryList().
         set_size(scale(37), scale(30)).
         clear_constraints().
         set_tooltip(paint_41).
         connect(self.on_history_list, Event.SELECTION_CHANGED)
      paint_44 := TextPaint("")
      paint_42 := TextPaint("Columns focus")
      focus_columns_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_42).
         connect(self.on_focus_columns_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&yes).
         set_paint(paint_44)
      paint_23 := TextPaint("Filter")
      filter := EditList().
         set_size(scale(150)).
         set_align(Align.L, Align.B).
         clear_constraints().
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_tooltip(paint_23).
         connect(self.on_filter_action, Event.ACTION).
         connect(self.on_filter_content_changed, Event.CONTENT_CHANGED).
         set_selection_list([""])
      paint_28 := ImagePaint().
         set_cache("gui.FONT_24")
      paint_27 := TextPaint("Sort by name")
      name_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_27).
         connect(self.on_name_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_28)
      paint_30 := ImagePaint().
         set_cache("gui.CLOCK_24")
      paint_29 := TextPaint("Sort by date")
      date_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_29).
         connect(self.on_date_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_30)
      paint_32 := ImagePaint().
         set_cache("gui.FILESIZE_24")
      paint_31 := TextPaint("Sort by size")
      size_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_31).
         connect(self.on_size_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_32)
      paint_37 := TextPaint("Favourite directories")
      favourites_list := DirList().
         set_size(scale(37), scale(30)).
         clear_constraints().
         set_tooltip(paint_37).
         connect(self.on_favourites_list, Event.SELECTION_CHANGED)
      trail := FileTrail().
         set_size(scale(100), scale(20)).
         clear_constraints().
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0)
      layout_6 := GridLayout().
         set_doi(scale(0)).
         set_dii(scale(2)).
         set_extra("cells")
      panel_4 := Panel().
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_layout(layout_6).
         add(close_button).
         add(home_button).
         add(up_button).
         add(refresh_button).
         add(prev_button).
         add(next_button).
         add(history_list).
         add(focus_columns_button).
         add(filter).
         add(name_button).
         add(date_button).
         add(size_button).
         add(favourites_list).
         add(trail)
      self.add(panel_4)
      columns := Columns().
         set_size(scale(300), scale(300)).
         clear_constraints().
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("y_fill", &yes).
         set_constraint("y_weight", 1.0).
         connect(self.on_columns_focus, Event.GOT_FOCUS)
      layout_5 := GridLayout().
         set_doi(scale(0)).
         set_extra("cells")
      split_content_3 := Component().
         clear_constraints().
         set_layout(layout_5).
         add(columns)
      output := Vt().
         set_size(scale(100), scale(100)).
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("y_fill", &yes).
         set_constraint("y_weight", 1.0).
         connect(self.on_vt_focus, Event.GOT_FOCUS)
      layout_4 := GridLayout().
         set_doi(scale(0)).
         set_extra("cells")
      split_content_4 := Component().
         clear_constraints().
         set_layout(layout_4).
         add(output)
      split := Split().
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("y_fill", &yes).
         set_constraint("y_weight", 1.0).
         set_left(split_content_3).
         set_right(split_content_4)
      self.add(split)
      paint_40 := TextPaint("")
      border_1 := CompoundBorder().
         set_outer(SunkenBorder()).
         set_inner(EmptyBorder().
            set_l_inset(scale(3))).
         set_x_align(Align.L)
      message_label := MessageLabel().
         set_fg("red").
         clear_constraints().
         set_constraint("b_inset", scale(0)).
         set_constraint("l_inset", scale(0)).
         set_constraint("r_inset", scale(0)).
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_border(border_1).
         set_paint(paint_40)
      self.add(message_label)
      layout_3 := GridLayout().
         set_extra("cells")
      self.set_layout(layout_3)
   end
end

procedure main(a)
   local d, t
   opts := options(a, "-x: -nx! -v! -h+ -hs! -tfg: -tbg: -trevfg: -trevbg: -tfont:")
   ImageCache.
      name_image("rpp.EXIT_24", EXIT).
      name_image("rpp.SAVE_24", SAVE).
      name_image("rpp.MIXFILE_24", MIXFILE)
   insert(Dialog.ROOT_WATTRIBS, "icon", Pixels(TERMINAL_LOGO))
   d := TerminalDialog()
   if *a = 0 | a[1][1] == ":" then
      push(a, "")
   d.do_tab_cmd(a) | stop(&why)
   t := \d.tabs.which_one | d.tabs.children[1]
   d.set_focus(t.remembered_focus)
   d.show_modal()
   if \opts["v"] then write("Exiting")
end

### Ivib-v2 layout: layouts/$.layout
