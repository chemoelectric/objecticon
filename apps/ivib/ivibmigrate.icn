#
# $Id$
#

#
# Convert old Ivib layout lines to new ones
#

import lang, gui, util, io


class Loader()
   private readable
      fname,
      lname

   public load()
      local f, r
      f := open(fname) | return error("Couldn't open " || fname)
      r := load_impl(f)
      close(f)
      return \r
   end

   public load_impl(f)
      local s
      repeat {
         s := read(f) | return error("No Ivib layout in " || fname)
         if s == Ivib.V1_MARKER then
            return Source1(load_layout(f))
         if s == Ivib.V2_MARKER then
            return Source2(load_layout(f))
         s ? if =Ivib.V2i_MARKER then {
            lname := tab(0)
            return Source2(load_ilayout())
         }
      }
   end

   public load_ilayout()
      local t, g
      t := resolve_layout_filename(fname, lname)
      g := open(t) | return error("Couldn't open layout file:" || t)
      t := read(g)
      close(g)
      return t
   end

   public load_layout(f)
      local s, t
      t := ""
      while s := read(f) do {
         if s[1] == "#" then
            t ||:= s[2:0]
         else
            break
      }
      if *t = 0 then
         return error("Misformed Ivib layout in " || fname)

      return t
   end

   public new(fname)
      self.fname := fname
      return
   end
end


class Source()
   public 
      version, 
      code

   public defer createconverterset()

   public migrate()
      local cs, d, o, e
      cs := createconverterset()
      if any(&lcase, code) then
         d := LegacyCustomDecode(cs)
      else
         d := CustomDecode(cs)
      o := (code ? d.decode()) | fail
      e := CustomEncode()
      e.encode(o)
      return e.get_string()
   end

end


class Source1(Source)
   #
   # ConverterSet for MenuComponents
   #
   public createcmc_converter(s)
      local c
      c := Converter(s)
      c.add_action("Var Category", MenuVarCategoryAction())
      c.add_extra(AddAction("Import Name", "gui"))
      return c
   end

   #
   # ConverterSet for Components
   #
   public createcc_converter(s)
      local c
      c := Converter(s)
      c.add_action("Tooltip", FixTooltipAction())
      c.add_action("Var Category", VarCategoryAction())
      c.add_extra(AddAction("Import Name", "gui"))
      c.add_extra(FixDefaultDimensionsAction())
      c.add_extra(FixAttribsAction())
      return c
   end

   #
   # Create the ConverterSet to use.
   #
   public createconverterset()
      local cs, c
      cs := ConverterSet()

      c := Converter("CDialog")
      c.add_extra(FixAttribsAction())
      cs.add(c)

      c := Converter("Canvas")
      c.add_action("Gen Methods", RemoveAction())
      c.add_action("Items", ChildrenAction())
      c.add_action("Button Groups", FixGroupsAction())
      c.add_action("Checkbox Groups", FixGroupsAction())
      c.add_extra(AddAction("SuperClass Name", "Dialog"))
      c.add_extra(AddAction("Import Name", "gui"))
      c.add_extra(AddAction("Event Handlers", [["&null", "handle_v2_events"]]))
      cs.add(c)

      c := createcc_converter("CanvasBorder")
      c.add_action("Components", ChildrenAction())
      cs.add(c)

      c := Converter("CanvasButtonGroup")
      c.add_extra(AddAction("Import Name", "gui"))
      cs.add(c)

      c := createcc_converter("CanvasCheckBox")
      c.add_action("Img Up", ConvertIconAction())
      c.add_action("Img Down", ConvertIconAction())
      c.add_action("Label", StringToPaintAction("Paint"))
      cs.add(c)

      c := Converter("CanvasCheckBoxGroup")
      c.add_extra(AddAction("Import Name", "gui"))
      cs.add(c)

      c := createcc_converter("CanvasCustom")
      c.add_action("W Default", ChangeAction(&null))
      c.add_action("H Default", ChangeAction(&null))
      cs.add(c)

      c := createcc_converter("CanvasEditableTextList")
      c.add_action("Draw Border", ChangeAction(1))
      cs.add(c)

      c := createcc_converter("CanvasEditList")
      cs.add(c)

      c := createcc_converter("CanvasIcon")
      c.add_action("Img", ImgToPaintAction("Paint"))
      cs.add(c)

      c := createcc_converter("CanvasIconButton")
      c.add_action("Img Up", ImgToPaintAction("Paint"))
      c.add_action("Img Down", ImgToPaintAction("Paint down"))
      cs.add(c)

      c := createcc_converter("CanvasImage")
      cs.add(c)

      c := createcc_converter("CanvasLabel")
      c.add_action("Label", StringToPaintAction("Paint"))
      cs.add(c)

      c := createcc_converter("CanvasList")
      cs.add(c)

      c := createcc_converter("CanvasOverlayItem")
      c.add_action("Components", ChildrenAction())
      cs.add(c)

      c := createcc_converter("CanvasOverlaySet")
      c.add_action("Components", ChildrenAction())
      cs.add(c)

      c := createcc_converter("CanvasPanel")
      c.add_action("Components", ChildrenAction())
      cs.add(c)

      c := createcc_converter("CanvasScrollBar")
      cs.add(c)

      c := createcc_converter("CanvasTabItem")
      c.add_action("Components", ChildrenAction())
      c.add_action("Label", StringToPaintAction("Paint"))
      cs.add(c)

      c := createcc_converter("CanvasTable")
      c.add_extra(FixSelectionAction())
      cs.add(c)

      c := createcc_converter("CanvasTableColumn")
      c.add_action("Label", StringToPaintAction("Paint"))
      cs.add(c)

      c := createcc_converter("CanvasTabSet")
      c.add_action("Components", ChildrenAction())
      cs.add(c)

      c := createcc_converter("CanvasTextButton")
      c.add_action("Label", StringToPaintAction("Paint"))
      cs.add(c)

      c := createcc_converter("CanvasTextField")
      cs.add(c)

      c := createcc_converter("CanvasTextList")
      c.add_action("Draw Border", ChangeAction(1))
      c.add_extra(FixSelectionAction())
      cs.add(c)

      c := createcmc_converter("CanvasTextMenuItem")
      c.add_action("Label", StringToPaintAction("Paint mid"))
      c.add_action("Label Left", StringToPaintAction("Paint left"))
      c.add_action("Label Right", StringToPaintAction("Paint right"))
      c.add_action("Img Left", ImgToPaintAction("Paint left"))
      c.add_action("Img Right", ImgToPaintAction("Paint right"))
      cs.add(c)

      c := createcmc_converter("CanvasMenu")
      c.add_action("Menus", MenuChildrenAction("Children"))
      c.add_action("Label", StringToPaintAction("Paint mid"))
      c.add_action("Label Left", StringToPaintAction("Paint left"))
      c.add_action("Label Right", StringToPaintAction("Paint right"))
      c.add_action("Img Left", ImgToPaintAction("Paint left"))
      c.add_action("Img Right", ImgToPaintAction("Paint right"))
      cs.add(c)

      c := createcmc_converter("CanvasCheckBoxMenuItem")
      c.add_action("Label", StringToPaintAction("Paint mid"))
      c.add_action("Img Up", ConvertIconAction())
      c.add_action("Img Down", ConvertIconAction())
      cs.add(c)

      c := createcc_converter("CanvasMenuBar")
      cs.add(c)

      c := createcc_converter("CanvasMenuButton")
      cs.add(c)

      c := createcmc_converter("CanvasMenuSeparator")
      cs.add(c)

      c := createcc_converter("CanvasToolBar", "CanvasBorder")
      cs.add(c)

      return cs
   end

   public new(s)
      version := 1
      code := s
      return
   end
end


class Source2(Source)
   #
   # ConverterSet for MenuComponents
   #
   private createcmc_converter(s)
      local c
      c := Converter(s)
      return c
   end

   #
   # ConverterSet for Components
   #
   private createcc_converter(s, t)
      local c
      c := Converter(s, t)
      c.add_action("Tooltip", FixTooltipAction())
      c.add_extra(FixDefaultDimensionsAction())
      c.add_extra(FixAttribsAction())
      c.add_extra(FixEventsAction())
      return c
   end

   #
   # Create the ConverterSet to use.
   #
   public createconverterset()
      local cs, c
      cs := ConverterSet()

      c := Converter("CDialog")
      c.add_extra(FixAttribsAction())
      cs.add(c)

      c := Converter("Canvas")
      c.add_action("Items",RenameAction("Children"))
      c.add_action("Button Groups", FixGroupsAction())
      c.add_action("Checkbox Groups", FixGroupsAction())
      c.add_extra(FixEventsAction())
      cs.add(c)

      cs.add(createcc_converter("CanvasBorder"))
      cs.add(createcc_converter("CanvasCustom"))
      cs.add(createcc_converter("CanvasEditableTextList"))
      cs.add(createcc_converter("CanvasEditList"))
      cs.add(createcc_converter("CanvasImage"))
      cs.add(createcc_converter("CanvasList"))
      cs.add(createcc_converter("CanvasOverlayItem"))
      cs.add(createcc_converter("CanvasOverlaySet"))
      cs.add(createcc_converter("CanvasPanel"))
      cs.add(createcc_converter("CanvasScrollBar"))
      cs.add(createcc_converter("CanvasTabSet"))
      cs.add(createcc_converter("CanvasTextField"))
      cs.add(createcc_converter("CanvasMenuButton"))

      c := createcc_converter("CanvasMenuBar")
      cs.add(c)

      c := createcc_converter("CanvasTextButton")
      c.add_action("Label", StringToPaintAction("Paint"))
      cs.add(c)

      c := createcc_converter("CanvasIconButton")
      c.add_action("Img Up", ImgToPaintAction("Paint"))
      c.add_action("Img Down", ImgToPaintAction("Paint down"))
      cs.add(c)

      c := createcc_converter("CanvasCheckBox")
      c.add_action("Label", StringToPaintAction("Paint"))
      cs.add(c)

      c := createcc_converter("CanvasTabItem")
      c.add_action("Label", StringToPaintAction("Paint"))
      cs.add(c)

      c := createcmc_converter("CanvasTextMenuItem")
      c.add_action("Label", StringToPaintAction("Paint mid"))
      c.add_action("Label Left", StringToPaintAction("Paint left"))
      c.add_action("Label Right", StringToPaintAction("Paint right"))
      c.add_action("Img Left", ImgToPaintAction("Paint left"))
      c.add_action("Img Right", ImgToPaintAction("Paint right"))
      cs.add(c)

      c := createcmc_converter("CanvasMenu")
      c.add_action("Children", MenuChildrenAction("Children"))
      c.add_action("Label", StringToPaintAction("Paint mid"))
      c.add_action("Label Left", StringToPaintAction("Paint left"))
      c.add_action("Label Right", StringToPaintAction("Paint right"))
      c.add_action("Img Left", ImgToPaintAction("Paint left"))
      c.add_action("Img Right", ImgToPaintAction("Paint right"))
      cs.add(c)

      c := createcmc_converter("CanvasCheckBoxMenuItem")
      c.add_action("Label", StringToPaintAction("Paint mid"))
      cs.add(c)

      c := createcc_converter("CanvasTableColumn")
      c.add_action("Label", StringToPaintAction("Paint"))
      c.add_extra(FixAutoWidthAction())
      cs.add(c)

      c := createcc_converter("CanvasTable")
      c.add_extra(FixSelectionAction())
      cs.add(c)

      c := createcc_converter("CanvasTree")
      c.add_extra(FixSelectionAction())
      cs.add(c)

      c := createcc_converter("CanvasTextList")
      c.add_extra(FixSelectionAction())
      cs.add(c)

      c := createcc_converter("CanvasIcon")
      c.add_action("Img", ImgToPaintAction("Paint"))
      cs.add(c)

      c := createcc_converter("CanvasLabel")
      c.add_action("Label", StringToPaintAction("Paint"))
      cs.add(c)

      c := createcc_converter("CanvasToolBar", "CanvasBorder")
      cs.add(c)

      return cs
   end

   public new(s)
      version := 2
      code := s
      return
   end
end




#
# An action to apply to a field of a class
#
class Action()
   public defer apply()
end


#
# Rename the key
#
class RenameAction(Action)
   public new_key

   public apply(decode, proxy, key, val)
      proxy.add(new_key, val)
   end

   public new(new_key)
      self.new_key := new_key
      return
   end
end


#
# Change the entry
#
class ChangeAction(Action)
   public new_val

   public apply(decode, proxy, key, val)
      proxy.add(key, new_val)
   end

   public new(new_val)
      self.new_val := new_val
      return
   end
end


#
# Remove the entry
#
class RemoveAction(Action)
   public apply()
   end
end


#
# Add a new entry
#
class AddAction(Action)
   public key, val

   public apply(decode, proxy)
      proxy.add(key, val)
   end

   public new(key, val)
      self.key := key
      self.val := val
      return
   end
end


#
# This class holds the details of how to convert one class, as a table
# of actions to apply to the encoded fields.
#
class Converter()
   public orig_name, new_name, actions, extras

   public add_action(key, a)
      insert(actions, key, a)
   end

   public add_extra(a)
      put(extras, a)
   end

   public get_new_name()
      return new_name
   end

   public get_orig_name()
      return orig_name
   end

   public apply_extras(decode, proxy)
      every (!extras).apply(decode, proxy)
   end

   public apply(decode, proxy, key, val)
      if member(actions, key) then
         actions[key].apply(decode, proxy, key, val)
      else
         proxy.add(key, val)
   end

   public new(s, t)
      orig_name := s
      new_name := \t | s
      actions := table()
      extras := []
      return
   end
end


#
# Simple holder for several Converters stored in a map.
#
class ConverterSet()
   public map

   public add(c)
      insert(map, c.get_orig_name(), c)
   end

   public get_converter(s)
      if member(map, s) then
         return map[s]
   end

   public new()
      map := table()
      return
   end
end


#
# Simple class to hold the values of the fields representing a class as a
# table of field names.
#
class ClassProxy()
   public name, l, t

   public add(name, val)
      local i
      if i := \t[name] then
         l[i][2] := val
      else {
         put(l, [name, val])
         t[name] := *l
      }
   end

   public get_name()
      return name
   end

   public get_map()
      return l
   end

   public get(name)
      return l[\t[name]][2]
   end

   public new(s)
      name := s
      l := []
      t := table()
      return
   end
end

#
# An amended Decoder with decode_class changed to output to ClassProxy instances.
#
class LegacyCustomDecode(LegacyDecode)
   private cs

   private decode_object()
      local cname, res, n, i, key, val, c
      cname := line_in() | fail
      if c := cs.get_converter(cname) then {
         res := ClassProxy(c.get_new_name())
         note_seen(res)
         n := integer(line_in()) | fail
         every i := 1 to n do {
            key := line_in() | fail
            val := decode() | fail
            c.apply(self, res, key, val)
         }
         c.apply_extras(self, res)
      } else {
         res := ClassProxy(cname)
         note_seen(res)
         n := integer(line_in()) | fail
         every i := 1 to n do {
            key := line_in() | fail
            val := decode() | fail
            res.add(key, val)
         }
      }
      return res
   end

   public new(cs)
      cast(self,LegacyDecode).new()
      self.cs := cs
      return
   end
end

class CustomDecode(Decode)
   private cs

   private decode_object()
      local cname, res, n, i, key, val, c

      cname := line_in() | fail
      if c := cs.get_converter(cname) then {
         res := ClassProxy(c.get_new_name())
         note_seen(res)
         n := integer(decode()) | fail
         every i := 1 to n do {
            key := decode() | fail
            val := decode() | fail
            c.apply(self, res, key, val)
         }
         c.apply_extras(self, res)
      } else {
         res := ClassProxy(cname)
         note_seen(res)
         n := integer(decode()) | fail
         every i := 1 to n do {
            key := decode() | fail
            val := decode() | fail
            res.add(key, val)
         }
      }

      return res
   end

   public new(cs)
      cast(self,Decode).new()
      self.cs := cs
      return
   end
end


#
# The converse of CustomDecode, this creates the amended string.
#
class CustomEncode(Encode)
   private encode_object(o)
      local l, e
      if is(o, ClassProxy) then {
         line_out(o.get_name())
         note_seen(o)
         l := o.get_map()
         encode(*l)
         every e := !l do {
            encode(e[1])
            encode(e[2])
         }
      } else {
         cast(self,Encode).encode_object(o)
      }
   end
end


global convert_icon_table

class ConvertIconAction(Action)
   public apply(decode, proxy, key, val)
      if member(convert_icon_table, val) then
         val := convert_icon_table[val]
      proxy.add(key, val)
   end

   public new()
      initial {
         convert_icon_table := table()
         insert(convert_icon_table, old_img_style("box_up"), Icon.BOX_UP)
         insert(convert_icon_table, old_img_style("box_down"), Icon.BOX_DOWN)
         insert(convert_icon_table, old_img_style("diamond_up"), Icon.DIAMOND_UP)
         insert(convert_icon_table, old_img_style("diamond_down"), Icon.DIAMOND_DOWN)
      }
      return
   end
end


class StringToPaintAction(Action)
   public new_key

   public apply(decode, proxy, key, val)
      proxy.add(new_key, CanvasTextPaint(\val))
   end

   public new(new_key)
      self.new_key := new_key
      return
   end
end


class ImgToPaintAction(Action)
   public new_key

   public apply(decode, proxy, key, val)
      proxy.add(new_key, CanvasImagePaint("image=",\val))
   end

   public new(new_key)
      self.new_key := new_key
      return
   end
end


class FixTooltipAction(Action)
   public apply(decode, proxy, key, val)
      if type(\val) == "string" then
         proxy.add(key, CanvasTextPaint(val))
      else
         proxy.add(key, val)
   end
end


#
# Convert event handling
#
class VarCategoryAction(Action)
   public apply(decode, proxy, key, val)
      case val of {
         &null : {
            proxy.add("Class Variable", 1)
            proxy.add("Event Handlers", [["&null", "handle_v2_events"]])
         }
         1 :
            proxy.add("Class Variable", 1)
         2 :
            proxy.add("Class Variable", &null)
      }
   end
end


class FixGroupsAction(Action)
   public apply(decode, proxy, key, val)
      if type(val) == "list" then
         proxy.add(key, val)
      else
         proxy.add(key, val.get("Boxes"))
   end
end


#
# Convert children fields
#
class ChildrenAction(Action)
   public apply(decode, proxy, key, val)
      proxy.add("Children", val)
      every (!val).add("Parent Component", proxy)
   end
end


#
# Convert children fields
#
class MenuChildrenAction(Action)
   public apply(decode, proxy, key, val)
      proxy.add("Children", val)
      every (!val).add("Parent", proxy)
   end
end


class FixAutoWidthAction(Action)
   public apply(decode, proxy)
      if \proxy.get("Auto width flag") then
         proxy.add("Column Width", &null)
   end
end


class FixSelectionAction(Action)
   public apply(decode, proxy)
      if \proxy.get("Select One") then
         proxy.add("Select Mode", Select.ONE)
      if \proxy.get("Select Many") then
         proxy.add("Select Mode", Select.MANY)
   end
end


class FixDefaultDimensionsAction(Action)
   public apply(decode, proxy)
      if \proxy.get("W Default") then
         proxy.add("W Spec", &null)
      if \proxy.get("H Default") then
         proxy.add("H Spec", &null)
   end
end


class FixAttribsAction(Action)
   public apply(decode, proxy)
      local e, k, v, t
      # Ignore if we already have a table
      if proxy.get("WAttribs") then
         return
      t := table()
      every e := !\proxy.get("Attribs") do {
         e ? {
            k := tab(upto('='))
            ="="
            v := tab(0)
            insert(t, k, v)
         }
      }
      proxy.add("WAttribs", t)
   end
end


class FixEventsAction(Action)
   public apply(decode, proxy)
      local e
      static t
      initial {
         t := table()
         insert(t, "CLOSEBUTTON", "Event.WINDOW_CLOSE_BUTTON")
         insert(t, "CLOSE_BUTTON_EVENT", "Event.WINDOW_CLOSE_BUTTON")
         insert(t, "MOUSEMOVED", "Event.MOUSE_MOVEMENT")
         insert(t, "MOUSE4UP", "Event.MOUSE_WHEEL_UP")
         insert(t, "MOUSE5UP", "Event.MOUSE_WHEEL_DOWN")
         insert(t, "&lpress", "Event.MOUSE_LEFT_PRESS")
         insert(t, "&mpress", "Event.MOUSE_MIDDLE_PRESS")
         insert(t, "&rpress", "Event.MOUSE_RIGHT_PRESS")
         insert(t, "&ldrag", "Event.MOUSE_LEFT_DRAG")
         insert(t, "&mdrag", "Event.MOUSE_MIDDLE_DRAG")
         insert(t, "&rdrag", "Event.MOUSE_RIGHT_DRAG")
         insert(t, "&lrelease", "Event.MOUSE_LEFT_RELEASE")
         insert(t, "&mrelease", "Event.MOUSE_MIDDLE_RELEASE")
         insert(t, "&rrelease", "Event.MOUSE_RIGHT_RELEASE")
         insert(t, "&windowclose", "Event.WINDOW_CLOSE_BUTTON")
         insert(t, "&mousemove", "Event.MOUSE_MOVEMENT")
         insert(t, "&wheelup", "Event.MOUSE_WHEEL_UP")
         insert(t, "&wheeldown", "Event.MOUSE_WHEEL_DOWN")
         insert(t, "INVOKELATER", "Event.INVOKE_LATER")
         insert(t, "ICON_EVENT", "Event.ICON")
         insert(t, "BUTTON_RELEASE_EVENT", "Event.BUTTON_RELEASE")
         insert(t, "BUTTON_PRESS_EVENT", "Event.BUTTON_PRESS")
         insert(t, "BUTTON_HELD_EVENT", "Event.BUTTON_HELD")
         insert(t, "SELECTION_CHANGED_EVENT", "Event.SELECTION_CHANGED")
         insert(t, "CONTENT_CHANGED_EVENT", "Event.CONTENT_CHANGED")
         insert(t, "CURSOR_MOVED_EVENT", "Event.CURSOR_MOVED")
         insert(t, "VALUE_CHANGED_EVENT", "Event.VALUE_CHANGED")
         insert(t, "ACTION_EVENT", "Event.ACTION")
         insert(t, "TREE_NODE_EXPANSION_EVENT", "Event.TREE_NODE_EXPANSION")
         insert(t, "SIZER_PRESSED_EVENT", "Event.SIZER_PRESS")
         insert(t, "SIZER_DRAGGED_EVENT", "Event.SIZER_DRAG")
         insert(t, "SIZER_RELEASED_EVENT", "Event.SIZER_RELEASE")
         insert(t, "MOUSE_ENTER_EVENT", "Event.MOUSE_ENTER")
         insert(t, "MOUSE_EXIT_EVENT", "Event.MOUSE_EXIT")
         insert(t, "KEY_EVENT", "Event.KEY_PRESS")
         insert(t, "Event.KEY", "Event.KEY_PRESS")
         insert(t, "TICK_EVENT", "Event.TICK")
         insert(t, "GOT_FOCUS_EVENT", "Event.GOT_FOCUS")
         insert(t, "LOST_FOCUS_EVENT", "Event.LOST_FOCUS")
         insert(t, "DIALOG_CLOSED_EVENT" , "Event.DIALOG_CLOSED")
      }
      every e := !\proxy.get("Event Handlers") do
         e[1] := \t[e[1]]
   end
end


#
# Add a key if it is absent, or its value is &null
#
class AddMissingKeyAction(Action)
   public key, val

   public apply(decode, proxy)
      \proxy.get(key) | proxy.add(key, val)
   end

   public new(key, val)
      self.key := key
      self.val := val
      return
   end
end


class FixBorderContentAction(Action)
   public apply(decode, proxy)
      local children
      if proxy.get("Content") then
         return
      children := proxy.get("Children")
   end
end


#
# Menu event handling
#
class MenuVarCategoryAction(Action)
   public apply(decode, proxy, key, val)
      case val of {
         &null : {
            proxy.add("Class Variable", 1)
            proxy.add("Event Method", "handle_v2_events")
         }
         1 :
            proxy.add("Class Variable", 1)
         2 :
            proxy.add("Class Variable", &null)
      }
   end
end


procedure old_img_style(s)
   return case s of {
      "box_up" :
"11,g2,_
11111111111_
11111111110_
11~~~~~~~00_
11~~~~~~~00_
11~~~~~~~00_
11~~~~~~~00_
11~~~~~~~00_
11~~~~~~~00_
11~~~~~~~00_
11000000000_
10000000000_
"
         "box_down" :
"11,g2,_
00000000001_
00000000011_
00000000011_
00000000011_
00000000011_
00000000011_
00000000011_
00000000011_
00000000011_
01111111111_
11111111111_
"
      "diamond_up" :
"11,g5,_
~~~~~4~~~~~_
~~~~444~~~~_
~~~44~44~~~_
~~44~~~44~~_
~44~~~~~44~_
44~~~~~~~44_
~00~~~~~00~_
~~00~~~00~~_
~~~00~00~~~_
~~~~000~~~~_
~~~~~0~~~~~_
"
         "diamond_down" :
"11,g5,_
~~~~~0~~~~~_
~~~~000~~~~_
~~~00000~~~_
~~0000000~~_
~000000000~_
00000000000_
~440000044~_
~~4400044~~_
~~~44044~~~_
~~~~444~~~~_
~~~~~4~~~~~_
"
   }
end






