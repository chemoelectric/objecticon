<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>strings.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     strings.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures for manipulating strings
<a name="6"/>#
<a name="7"/>#	Author:   Ralph E. Griswold
<a name="8"/>#
<a name="9"/>#	Date:     June 10, 2001
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>
<a name="17"/>package ipl.strings
<a name="18"/>
<a name="19"/>import lang(Text), util
<a name="20"/>
<a name="21"/># Concatenates an arbitrary number of strings.
<a name="22"/>procedure cat(args[])			
<a name="23"/>   local result
<a name="24"/>
<a name="25"/>   result := ""
<a name="26"/>
<a name="27"/>   every result ||:= !args
<a name="28"/>
<a name="29"/>   return result
<a name="30"/>
<a name="31"/>end
<a name="32"/>
<a name="33"/># Returns the number of instances of characters in `c` in `s`.
<a name="34"/>procedure charcnt(s, c)			
<a name="35"/>   local count
<a name="36"/>
<a name="37"/>   count := 0
<a name="38"/>
<a name="39"/>   s ? {
<a name="40"/>      while tab(upto(c)) do
<a name="41"/>         count +:= *tab(many(c))
<a name="42"/>      }
<a name="43"/>
<a name="44"/>   return count
<a name="45"/>
<a name="46"/>end
<a name="47"/>
<a name="48"/># Collates the characters of `s1` and `s2`.  For example,
<a name="49"/># ~
<a name="50"/>#    collate("abc", "def")
<a name="51"/># ~
<a name="52"/># produces `"adbecf"`.
<a name="53"/>#
<a name="54"/>procedure collate(s1, s2)		
<a name="55"/>   local length, ltemp, rtemp
<a name="56"/>   static llabels, rlabels, clabels, blabels, half
<a name="57"/>
<a name="58"/>   initial {
<a name="59"/>      llabels := "ab"
<a name="60"/>      rlabels := "cd"
<a name="61"/>      blabels := llabels || rlabels
<a name="62"/>      clabels := "acbd"
<a name="63"/>      half := 2
<a name="64"/>      ltemp := left(&amp;cset, *&amp;cset / 2)
<a name="65"/>      rtemp := right(&amp;cset, *&amp;cset / 2)
<a name="66"/>      clabels := collate(ltemp, rtemp)
<a name="67"/>      llabels := ltemp
<a name="68"/>      rlabels := rtemp
<a name="69"/>      blabels := string(&amp;cset)
<a name="70"/>      half := *llabels
<a name="71"/>      }
<a name="72"/>
<a name="73"/>   length := *s1
<a name="74"/>   if length &lt;= half then
<a name="75"/>      return map(left(clabels, 2 * length), left(llabels, length) ||
<a name="76"/>         left(rlabels, length), s1 || s2)
<a name="77"/>   else return map(clabels, blabels, left(s1, half) || left(s2, half)) ||
<a name="78"/>      collate(right(s1, length - half), right(s2, length - half))
<a name="79"/>
<a name="80"/>end
<a name="81"/>
<a name="82"/># Generates the combinations of characters from `s` taken `i` at a time.
<a name="83"/>procedure comb(s, i)			
<a name="84"/>   local j
<a name="85"/>
<a name="86"/>   if i &lt; 1 then fail
<a name="87"/>   suspend if i = 1 then !s
<a name="88"/>      else s[j := 1 to *s - i + 1] || comb(s[j + 1:0], i - 1)
<a name="89"/>
<a name="90"/>end
<a name="91"/>
<a name="92"/># Compresses consecutive occurrences of characters in `c` that occur
<a name="93"/># in `s`; `c` defaults to `&amp;cset`.
<a name="94"/>procedure compress(s, c)		
<a name="95"/>   local result, s1
<a name="96"/>
<a name="97"/>   /c := &amp;uset
<a name="98"/>
<a name="99"/>   result := ""
<a name="100"/>
<a name="101"/>   s ? {
<a name="102"/>      while result ||:= string(tab(upto(c))) do {
<a name="103"/>         result ||:= string(s1 := move(1))
<a name="104"/>         tab(many(s1))
<a name="105"/>         }
<a name="106"/>      return result || tab(0)
<a name="107"/>      }
<a name="108"/>end
<a name="109"/>
<a name="110"/># Produces the common prefix of list of strings `L`: the longest
<a name="111"/># initial substring shared by all, which may be the empty string.
<a name="112"/>#
<a name="113"/>procedure coprefix(L)
<a name="114"/>   local i, s, e
<a name="115"/>   every i := seq() do {
<a name="116"/>      s := L[1][i] | break
<a name="117"/>      every e := !L do
<a name="118"/>         e[i] == s | break break
<a name="119"/>   }
<a name="120"/>   return L[1][1:i]
<a name="121"/>end
<a name="122"/>
<a name="123"/># Produces the common suffix list of strings `L`: the longest trailing
<a name="124"/># substring shared by all, which may be the empty string.
<a name="125"/>#
<a name="126"/>procedure cosuffix(L)
<a name="127"/>   local i, s, e
<a name="128"/>   every i := seq(-1, -1) do {
<a name="129"/>      s := L[1][i] | break
<a name="130"/>      every e := !L do
<a name="131"/>         e[i] == s | break break
<a name="132"/>   }
<a name="133"/>   return L[1][i + 1:0]
<a name="134"/>end
<a name="135"/>
<a name="136"/># Produces the characters of `s` in lexical order.
<a name="137"/>procedure csort(s)			
<a name="138"/>   local c, s1
<a name="139"/>
<a name="140"/>   s1 := s[1:1]
<a name="141"/>
<a name="142"/>   every c := !cset(s) do
<a name="143"/>      every find(c, s) do
<a name="144"/>         s1 ||:= c
<a name="145"/>
<a name="146"/>   return s1
<a name="147"/>
<a name="148"/>end
<a name="149"/>
<a name="150"/># Produces a string consisting of every other character of `s`. If `i`
<a name="151"/># is odd, the odd-numbered characters are selected, while if `i` is
<a name="152"/># even, the even-numbered characters are selected.  The default value
<a name="153"/># of `i` is 1.
<a name="154"/>#
<a name="155"/>procedure decollate(s, i)		
<a name="156"/>   local ssize
<a name="157"/>   static dsize, image, object
<a name="158"/>
<a name="159"/>   initial {
<a name="160"/>      image := collate(left(&amp;cset, *&amp;cset / 2), left(&amp;cset, *&amp;cset / 2))
<a name="161"/>      object := left(&amp;cset, *&amp;cset / 2)
<a name="162"/>      dsize := *image
<a name="163"/>      }
<a name="164"/>
<a name="165"/>   /i := 1
<a name="166"/>
<a name="167"/>   i %:= 2
<a name="168"/>   ssize := *s
<a name="169"/>
<a name="170"/>   if ssize + i &lt;= dsize then
<a name="171"/>      return map(object[1+:(ssize + i) / 2], image[(i + 1)+:ssize], s)
<a name="172"/>   else return map(object[1+:(dsize - 2) / 2], image[(i + 1)+:dsize - 2],
<a name="173"/>      s[1+:(dsize - 2)]) || decollate(s[dsize - 1:0], i)
<a name="174"/>
<a name="175"/>end
<a name="176"/>
<a name="177"/># Deletes occurrences of characters in `c` from `s`.
<a name="178"/>procedure deletec(s, c)			
<a name="179"/>   return replacec(s, c, "")
<a name="180"/>end
<a name="181"/>
<a name="182"/># Deletes all characters of `s` at positions specified in `L`.
<a name="183"/>procedure deletep(s, L)
<a name="184"/>
<a name="185"/>   L := sort(L)
<a name="186"/>
<a name="187"/>   while s[pull(L)] := ""
<a name="188"/>
<a name="189"/>   return s
<a name="190"/>
<a name="191"/>end
<a name="192"/>
<a name="193"/># Deletes occurrences of `s2` in `s1`.
<a name="194"/>#
<a name="195"/>procedure deletes(s1, s2)		
<a name="196"/>   return replace(s1, s2, "")
<a name="197"/>end
<a name="198"/>
<a name="199"/># Returns count of the number of different characters in `s`.
<a name="200"/>procedure diffcnt(s)			
<a name="201"/>
<a name="202"/>   return *cset(s)
<a name="203"/>
<a name="204"/>end
<a name="205"/>
<a name="206"/># Replicates `s` to length `n`.
<a name="207"/>procedure extend(s, n)			
<a name="208"/>   local i
<a name="209"/>
<a name="210"/>   if *s = 0 then fail
<a name="211"/>
<a name="212"/>   i := n / *s
<a name="213"/>   if n % *s &gt; 0 then i +:= 1
<a name="214"/>
<a name="215"/>   return left(repl(s, i), n)
<a name="216"/>
<a name="217"/>end
<a name="218"/>
<a name="219"/># Returns characters of `s` in order of decreasing frequency
<a name="220"/>procedure fchars(s)			
<a name="221"/>   local counts, clist, bins, blist, result
<a name="222"/>
<a name="223"/>   counts := table(0)
<a name="224"/>   every counts[!s] +:= 1
<a name="225"/>   clist := sort(counts, 4)
<a name="226"/>
<a name="227"/>   bins := table('')
<a name="228"/>   while bins[pull(clist)] ++:= pull(clist)
<a name="229"/>   blist := sort(bins, 3)
<a name="230"/>
<a name="231"/>   result := s[1:1]
<a name="232"/>   while result ||:= pull(blist) do
<a name="233"/>      pull(blist)
<a name="234"/>
<a name="235"/>   return result
<a name="236"/>
<a name="237"/>end
<a name="238"/>
<a name="239"/># Interleaves characters `s2` extended to the length of `s1` with `s1`.
<a name="240"/>procedure interleave(s1, s2)		
<a name="241"/>
<a name="242"/>   return collate(s1, extend(s2, *s1)) | fail
<a name="243"/>
<a name="244"/>end
<a name="245"/>
<a name="246"/># Succeeds and returns `s` if it is a palindrome.
<a name="247"/>procedure ispal(s)			
<a name="248"/>
<a name="249"/>   if s == reverse(s) then return s else fail
<a name="250"/>
<a name="251"/>end
<a name="252"/>
<a name="253"/># Produces a "meandering" string that contains all n-tuples of
<a name="254"/># characters of `s`.
<a name="255"/>procedure meander(alpha, n)		
<a name="256"/>   local result, trial, t, i, c
<a name="257"/>
<a name="258"/>   i := *alpha
<a name="259"/>   t := n - 1
<a name="260"/>   result := repl(alpha[1], t)			# base string
<a name="261"/>
<a name="262"/>   while c := alpha[i] do {			# try a character
<a name="263"/>      result ? {				# get the potential n-tuple
<a name="264"/>         tab(-t)
<a name="265"/>         trial := tab(0) || c
<a name="266"/>         }
<a name="267"/>      if result ? find(trial) then 		# duplicate, work back
<a name="268"/>         i -:= 1
<a name="269"/>      else {
<a name="270"/>         result ||:= c				# add it
<a name="271"/>         i := *alpha				# and start from end again
<a name="272"/>         }
<a name="273"/>      }
<a name="274"/>
<a name="275"/>   return result[n:0]
<a name="276"/>
<a name="277"/>end
<a name="278"/>
<a name="279"/># Returns the collation of the strings in `L`.
<a name="280"/>procedure multicoll(L)			
<a name="281"/>   local result, i, j
<a name="282"/>
<a name="283"/>   result := ""
<a name="284"/>
<a name="285"/>   every i := 1 to *L[1] do		# no other longer if legal
<a name="286"/>      every j := 1 to *L do
<a name="287"/>         result ||:= L[j][i]
<a name="288"/>
<a name="289"/>   return result
<a name="290"/>
<a name="291"/>end
<a name="292"/>
<a name="293"/># Produces the unique characters of `s` in the order that they first
<a name="294"/># appear in `s`.
<a name="295"/>#
<a name="296"/>procedure ochars(w)			
<a name="297"/>   local out, c
<a name="298"/>
<a name="299"/>   out := w[1:1]
<a name="300"/>
<a name="301"/>   every c := !w do
<a name="302"/>	unless find(c, out) then
<a name="303"/>	    out ||:= c
<a name="304"/>
<a name="305"/>   return out
<a name="306"/>
<a name="307"/>end
<a name="308"/>
<a name="309"/># Inserts values in a numerical string so that adjacent digits follow
<a name="310"/># an odd-even pattern.
<a name="311"/>#
<a name="312"/>procedure odd_even(s)			
<a name="313"/>   local result, i, j
<a name="314"/>
<a name="315"/>
<a name="316"/>   every i := integer(!s) do {
<a name="317"/>      if /result then result := i
<a name="318"/>      else if (i % 2) = (j % 2) then result ||:= (j + 1) || i
<a name="319"/>      else result ||:= i
<a name="320"/>      j := i
<a name="321"/>      }
<a name="322"/>
<a name="323"/>   return result
<a name="324"/>
<a name="325"/>end
<a name="326"/>
<a name="327"/># Generates all the `n`-character palindromes from the characters in `s`.
<a name="328"/>#
<a name="329"/>procedure palins(s, n)			
<a name="330"/>   local c, lpart, mpart, rpart, h, p
<a name="331"/>
<a name="332"/>   if n = 1 then suspend !s
<a name="333"/>   else if n = 2 then
<a name="334"/>      every c := !s do suspend c || c
<a name="335"/>   else if n % 2 = 0 then {		# even
<a name="336"/>      h := (n - 2) / 2
<a name="337"/>      every p := palins(s, n - 2) do {
<a name="338"/>         p ? {
<a name="339"/>            lpart := move(h)
<a name="340"/>            rpart := tab(0)
<a name="341"/>            }
<a name="342"/>         every c := !s do {
<a name="343"/>            mpart := c || c
<a name="344"/>            suspend lpart || mpart || rpart
<a name="345"/>            }
<a name="346"/>         }
<a name="347"/>      }
<a name="348"/>   else {				# odd
<a name="349"/>      h := (n - 1) / 2
<a name="350"/>      every p := palins(s, n - 1) do {
<a name="351"/>         p ? {
<a name="352"/>            lpart := move(h)
<a name="353"/>            rpart := tab(0)
<a name="354"/>            }
<a name="355"/>         every suspend lpart || !s || rpart
<a name="356"/>         }
<a name="357"/>      }
<a name="358"/>    
<a name="359"/>end
<a name="360"/>
<a name="361"/># Generates all the permutations of the string `s`.
<a name="362"/>procedure permutes(s)			
<a name="363"/>   local i
<a name="364"/>
<a name="365"/>   if *s = 0 then return s
<a name="366"/>   suspend s[i := 1 to *s] || permutes(s[1:i] || s[i+1:0])
<a name="367"/>
<a name="368"/>end
<a name="369"/>
<a name="370"/># Returns `s1` concatenated with `s2` and the reversal of `s1` to
<a name="371"/># produce a palindroid; the values of `i` determine "end conditions"
<a name="372"/># for the reversal:
<a name="373"/>#   *  0       pattern palindrome; the default
<a name="374"/>#   *  1       pattern palindrome with center duplicated
<a name="375"/>#   *  2       true palindrome with center not duplicated
<a name="376"/>#   *  3       true palindrome with center duplicated
<a name="377"/>#
<a name="378"/>#  `s2` defaults to the empty string, in which case the result is a
<a name="379"/>#  full palindrome.
<a name="380"/>#
<a name="381"/>procedure reflect(s1, i, s2)			
<a name="382"/>
<a name="383"/>   /i :=0
<a name="384"/>   /s2 := ""
<a name="385"/>
<a name="386"/>   return s1 || s2 || reverse(
<a name="387"/>      case i of {
<a name="388"/>         0:   s1[2:-1]		# pattern palindrome
<a name="389"/>         1:   s1[2:0]		# pattern palindrome with first character at end
<a name="390"/>         2:   s1[1:-1]		# true palindrome with center character unduplicated
<a name="391"/>         3:   s1		# true palindrome with center character duplicated
<a name="392"/>         }
<a name="393"/>      )
<a name="394"/>
<a name="395"/>end
<a name="396"/>
<a name="397"/># Replaces all occurrences of `s2` in `s1` by `s3`; `s2` may not be
<a name="398"/># the empty string.
<a name="399"/>#
<a name="400"/># The result type is the type of `s1`.
<a name="401"/>#
<a name="402"/>procedure replace(s1, s2, s3)		
<a name="403"/>   local result, i
<a name="404"/>
<a name="405"/>   s1 := need_text(s1)
<a name="406"/>   # s1 and s2 must be the same type so that i (=*s2) is correct
<a name="407"/>   s2 := same_string_type(s2, s1)
<a name="408"/>   s3 := string(same_string_type(s3, s1))
<a name="409"/>   i := *s2
<a name="410"/>   if i = 0 then runerr("Empty string given to replace", s2)    # would loop on empty string
<a name="411"/>   result := ""
<a name="412"/>   s1 ? {
<a name="413"/>      while result ||:= string(tab(find(s2))) do {
<a name="414"/>         result ||:= s3
<a name="415"/>         move(i)
<a name="416"/>         }
<a name="417"/>      return result || tab(0)
<a name="418"/>      }
<a name="419"/>
<a name="420"/>end
<a name="421"/>
<a name="422"/># Performs multiple replacements in the style of of `replace()`, where
<a name="423"/># multiple argument pairs may be given, as in
<a name="424"/># ~
<a name="425"/>#     replacem(s, "a", "bc", "d", "cd")
<a name="426"/># ~
<a name="427"/># which replaced all "a"s by "bc"s and all "d"s by "cd"s.
<a name="428"/># Replacements are performed one after another, not in parallel.
<a name="429"/>#
<a name="430"/>procedure replacem(s, pairs[])		
<a name="431"/>
<a name="432"/>   while s := replace(s, get(pairs), get(pairs))
<a name="433"/>
<a name="434"/>   return s
<a name="435"/>
<a name="436"/>end
<a name="437"/>
<a name="438"/># Replace each occurence in string `s` of a character in cset `c` by
<a name="439"/># the string `t` (which may be of any length).  For example :-
<a name="440"/># ~
<a name="441"/>#     replacec("The sum is $2000.00", &amp;digits, "*")
<a name="442"/>#     gives "The sum is $****.**"
<a name="443"/># ~
<a name="444"/>#
<a name="445"/># If `t` is the empty string, then this is equivalent to `deletec`.
<a name="446"/>#
<a name="447"/># The result type is the type of `s`.
<a name="448"/>#
<a name="449"/>procedure replacec(s, c, t)
<a name="450"/>   local result
<a name="451"/>
<a name="452"/>   s := need_text(s)
<a name="453"/>   c := need_cset(c)
<a name="454"/>   t := string(same_string_type(t, s))
<a name="455"/>   result := ""
<a name="456"/>   s ? {
<a name="457"/>      while result ||:= string(tab(upto(c))) do
<a name="458"/>         result ||:= repl(t, *tab(many(c)))
<a name="459"/>      return result || tab(0)
<a name="460"/>    }
<a name="461"/>
<a name="462"/>end
<a name="463"/>
<a name="464"/># Replicates each character of c by the amount given by the values in
<a name="465"/># `L`.
<a name="466"/>#
<a name="467"/>procedure replc(s, L)			
<a name="468"/>   local result
<a name="469"/>
<a name="470"/>   result := s[1:1]
<a name="471"/>
<a name="472"/>   every result ||:= repl(!s, get(L))
<a name="473"/>
<a name="474"/>   return result
<a name="475"/>
<a name="476"/>end
<a name="477"/>
<a name="478"/># Rotates `s` `i` characters to the left (negative `i` produces
<a name="479"/># rotation to the right); the default value of `i` is 1.
<a name="480"/>#
<a name="481"/>procedure rotate(s, i)			
<a name="482"/>
<a name="483"/>   if s == "" then return s
<a name="484"/>   /i := 1
<a name="485"/>   if i = 0 then return s
<a name="486"/>   else if i &lt; 0 then i +:= *s
<a name="487"/>   i %:= *s
<a name="488"/>
<a name="489"/>   return s[(i + 1):0] || s[1:(i + 1)]
<a name="490"/>
<a name="491"/>end
<a name="492"/>
<a name="493"/># Produces the unique characters of `s` in lexical order.
<a name="494"/>procedure schars(s)			
<a name="495"/>
<a name="496"/>   return string(cset(s))
<a name="497"/>
<a name="498"/>end
<a name="499"/>
<a name="500"/># Scrambles (shuffles) the characters of `s` randomly.
<a name="501"/>procedure scramble(s)			
<a name="502"/>   local i
<a name="503"/>
<a name="504"/>   s := string(s) | fail
<a name="505"/>
<a name="506"/>   every i := *s to 2 by -1 do
<a name="507"/>      s[?i] :=: s[i]
<a name="508"/>
<a name="509"/>   return s
<a name="510"/>
<a name="511"/>end
<a name="512"/>
<a name="513"/># Selects characters of `s` that are at positions given in `L`.
<a name="514"/>procedure selectp(s, L)			
<a name="515"/>   local result
<a name="516"/>
<a name="517"/>   result := s[1:1]
<a name="518"/>
<a name="519"/>   every result ||:= s[!L]
<a name="520"/>
<a name="521"/>   return result
<a name="522"/>
<a name="523"/>end
<a name="524"/>
<a name="525"/># Generates column-sized chunks (length &lt;= `n`) of string `s` broken
<a name="526"/># at spans of cset `c`.
<a name="527"/>#
<a name="528"/># Defaults:   `n`    80  
<a name="529"/>#             `c`    `' \t\r\n\v\f'`
<a name="530"/>#
<a name="531"/># Example:
<a name="532"/># ~
<a name="533"/>#     every write("&gt;  ", slugs(msg, 50))
<a name="534"/># ~
<a name="535"/>procedure slugs(s, n, c)  		
<a name="536"/>   local i, t
<a name="537"/>
<a name="538"/>   (/n := 80) | (n := 0 &lt; integer(n)) | runerr(101, n)
<a name="539"/>   /c := ' \t\r\n\v\f'
<a name="540"/>
<a name="541"/>   n +:= 1
<a name="542"/>   while *s &gt; 0 do s ? {
<a name="543"/>      if *s &lt;= n then
<a name="544"/>         return trim(s, c)
<a name="545"/>      if tab(i := (n &gt;= upto(c))) then {
<a name="546"/>         tab(many(c))
<a name="547"/>         while tab(i := (n &gt;= upto(c))) do {
<a name="548"/>            tab(many(c))
<a name="549"/>            }
<a name="550"/>         suspend .&amp;subject[1:i]
<a name="551"/>         }
<a name="552"/>      else {
<a name="553"/>         t := tab(n | 0)
<a name="554"/>         suspend t
<a name="555"/>         }
<a name="556"/>      s := tab(0)
<a name="557"/>      }
<a name="558"/>   fail
<a name="559"/>end
<a name="560"/>
<a name="561"/># Sequence consisting of the closure of `s` starting with the empty
<a name="562"/># string and continuing in lexical order as given in `s`
<a name="563"/>#
<a name="564"/>procedure starseq(s)		
<a name="565"/>
<a name="566"/>   /s := ""
<a name="567"/>
<a name="568"/>   suspend s[1:1] | (starseq(s) || !s)
<a name="569"/>
<a name="570"/>end
<a name="571"/>
<a name="572"/># Produces a count of the number of non-overlapping times `s1` occurs
<a name="573"/># in `s2`; fails is `s1` is null.
<a name="574"/>#
<a name="575"/>procedure strcnt(s1, s2)		
<a name="576"/>   local j, i
<a name="577"/>
<a name="578"/>   if *s1 = 0 then fail			# null string would loop
<a name="579"/>
<a name="580"/>   j := 0
<a name="581"/>   i := *s1
<a name="582"/>
<a name="583"/>   s2 ? {
<a name="584"/>      while tab(find(s1)) do {
<a name="585"/>         j +:= 1
<a name="586"/>         move(i)
<a name="587"/>         }
<a name="588"/>      return j
<a name="589"/>      }
<a name="590"/>
<a name="591"/>end
<a name="592"/>
<a name="593"/># Generates all the substrings of `s` with lengths from `i` to `j`,
<a name="594"/># inclusive; `i` defaults to 1, `j` to `*s`.
<a name="595"/>#
<a name="596"/>procedure substrings(s, i, j)		
<a name="597"/>
<a name="598"/>   /i := 1
<a name="599"/>   /j := *s
<a name="600"/>
<a name="601"/>   s ? {
<a name="602"/>      every tab(1 to *s) do
<a name="603"/>         suspend move(i to j)
<a name="604"/>      }
<a name="605"/>
<a name="606"/>end
<a name="607"/>
<a name="608"/># Transposes `s1` according to label `s2` and transposition `s3`.
<a name="609"/>procedure transpose(s1, s2, s3)		
<a name="610"/>   local n, result
<a name="611"/>
<a name="612"/>   s1 := need_text(s1)
<a name="613"/>   s2 := same_string_type(s2, s1)
<a name="614"/>   s3 := same_string_type(s3, s1)
<a name="615"/>
<a name="616"/>   n := *s2
<a name="617"/>   result := ""
<a name="618"/>
<a name="619"/>   s1 ? {
<a name="620"/>      while result ||:= string(map(s3, s2, move(n)))
<a name="621"/>      return result || tab(0)
<a name="622"/>      }
<a name="623"/>
<a name="624"/>end
<a name="625"/>
<a name="626"/># Generate words formed of adjacent characters in `wc`
<a name="627"/>#
<a name="628"/># :Parameters :
<a name="629"/># :  `s` - the subject string
<a name="630"/># :  `wc` - cset of word characters
<a name="631"/>#
<a name="632"/>procedure words_in(s, wc)
<a name="633"/>   s ? while tab(upto(wc)) do
<a name="634"/>      suspend tab(many(wc)) \ 1
<a name="635"/>end
<a name="636"/>
<a name="637"/># Generate "words" from string `s` separated by chars in `sep`.
<a name="638"/>#
<a name="639"/># :Parameters :
<a name="640"/># :  `s` - the subject string
<a name="641"/># :  `sep` - cset of the separator chars, default ' \t\r\n\v\f'
<a name="642"/>#
<a name="643"/>procedure words(s, sep)
<a name="644"/>   sep := ~\sep | ~' \t\r\n\v\f'
<a name="645"/>   suspend words_in(s, sep)
<a name="646"/>end
<a name="647"/>
<a name="648"/># Succeed if `s1` ends with the string `s2`
<a name="649"/>#
<a name="650"/>procedure endswith(s1, s2)
<a name="651"/>   succeed s1[-*s2:0] == s2
<a name="652"/>end
<a name="653"/>
<a name="654"/>#
<a name="655"/># Separate a string `s` into parts separated by (single) chars in `sep`.
<a name="656"/>#
<a name="657"/># :Parameters :
<a name="658"/># :  `s` - the string to convert
<a name="659"/># :  `sep` - cset of the separator chars, default ','
<a name="660"/>#
<a name="661"/>procedure separate(s, sep)
<a name="662"/>   local t
<a name="663"/>   /sep := ','
<a name="664"/>   s ? {
<a name="665"/>      while t := tab(upto(sep)) do {
<a name="666"/>         suspend t
<a name="667"/>         move(1)
<a name="668"/>      }
<a name="669"/>      return tab(0)
<a name="670"/>   }
<a name="671"/>end
<a name="672"/>
<a name="673"/>#
<a name="674"/># Separate a string into parts separated by end-of-line characters.
<a name="675"/>#
<a name="676"/># :Parameters :
<a name="677"/># :  `s` - the string to convert
<a name="678"/>#
<a name="679"/>procedure separate_lines(s)
<a name="680"/>   local t
<a name="681"/>   every t := separate(s, '\n') do {
<a name="682"/>      # This just tests 't[-1] == "\r"', but avoids an allocation
<a name="683"/>      # if s is ucs.
<a name="684"/>      if any('\r', t, -1) then
<a name="685"/>         t[-1] := ""
<a name="686"/>      suspend t
<a name="687"/>   }
<a name="688"/>end
<a name="689"/>
<a name="690"/># Return a string which is the same as `s`, but with any utf-16
<a name="691"/># surrogate pairs replaced with their equivalent characters.
<a name="692"/>#
<a name="693"/># The procedure fails if `s` contains an invalid surrogate pair
<a name="694"/># encoding.
<a name="695"/>#
<a name="696"/>procedure remove_surrogate_pairs(s)
<a name="697"/>   local t, c1, c2
<a name="698"/>   s := need_text(s)
<a name="699"/>   t := ""
<a name="700"/>   s ? {
<a name="701"/>      while t ||:= string(tab(upto('\ud800-\udfff'))) do {
<a name="702"/>         any('\ud800-\udbff') | fail
<a name="703"/>         c1 := move(1)
<a name="704"/>         any('\udc00-\udfff') | fail
<a name="705"/>         c2 := move(1)
<a name="706"/>         t ||:= Text.utf8_seq(16r10000 + ishift(iand(ord(c1), 16r3ff), 10) + iand(ord(c2), 16r3ff))
<a name="707"/>      }
<a name="708"/>      return t || tab(0)
<a name="709"/>   }
<a name="710"/>end
<a name="711"/>
<a name="712"/># Return a string which is the same as `s`, but with any characters
<a name="713"/># outside the BMP replaced with their UTF-16 surrogate pair
<a name="714"/># equivalent.
<a name="715"/>#
<a name="716"/>procedure add_surrogate_pairs(s)
<a name="717"/>   local t, c, i
<a name="718"/>   s := need_text(s)
<a name="719"/>   t := ""
<a name="720"/>   s ? {
<a name="721"/>      while t ||:= string(tab(upto('\U10000-\U10FFFF'))) do {
<a name="722"/>         c := move(1)
<a name="723"/>         i := ord(c) - 16r10000
<a name="724"/>         t ||:= Text.utf8_seq(16rd800 + ishift(i, -10)) || Text.utf8_seq(16rdc00 + iand(i, 16r3ff))
<a name="725"/>      }
<a name="726"/>      return t || tab(0)
<a name="727"/>   }
<a name="728"/>end
<a name="729"/>
<a name="730"/>#
<a name="731"/># Guess the end-of-line character used in a string (typically a file's
<a name="732"/># contents).  Returns either "\n" or "\r\n".
<a name="733"/>#
<a name="734"/>procedure guess_eol(s)
<a name="735"/>   local i, j
<a name="736"/>   i := j := 0
<a name="737"/>   s ? while tab(upto('\r\n')) do {
<a name="738"/>      if tab(any('\n')) then
<a name="739"/>         i +:= 1
<a name="740"/>      else {
<a name="741"/>         move(1)
<a name="742"/>         if tab(any('\n')) then
<a name="743"/>            j +:= 1
<a name="744"/>      }
<a name="745"/>   }
<a name="746"/>   return if i &gt;= j then "\n" else "\r\n"
<a name="747"/>end
<a name="748"/>
<a name="749"/>#
<a name="750"/># Split the given string into chunks of size `n`, followed by any
<a name="751"/># residual substring, if `n` doesn't divide `s` exactly.  The empty
<a name="752"/># string just returns itself.
<a name="753"/>#
<a name="754"/>procedure chunks(s, n)
<a name="755"/>   local t
<a name="756"/>   n := need_integer(n, 1)
<a name="757"/>   s ? repeat {
<a name="758"/>      t := (move(n) | tab(0))
<a name="759"/>      if pos(0) then
<a name="760"/>         return t
<a name="761"/>      suspend t
<a name="762"/>   }
<a name="763"/>end
</pre></body></html>
