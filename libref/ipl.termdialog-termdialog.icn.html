<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>termdialog.icn</title></head><body><pre>
<a name="1"/>package ipl.termdialog
<a name="2"/>
<a name="3"/>import
<a name="4"/>   gui, io, graphics, util, undo, ipl.vt, xdg
<a name="5"/>
<a name="6"/>class TermTextField(CompleteField)
<a name="7"/>   public override keeps(e)
<a name="8"/>      return
<a name="9"/>   end
<a name="10"/>
<a name="11"/>   public override handle_copy(e)
<a name="12"/>      if has_region() then
<a name="13"/>         CompleteField.handle_copy(e)
<a name="14"/>      else
<a name="15"/>         parent.text.handle_copy(e)
<a name="16"/>   end
<a name="17"/>
<a name="18"/>   protected override do_request()
<a name="19"/>      return (\parent.complete_function)(contents, cursor)
<a name="20"/>   end
<a name="21"/>end
<a name="22"/>
<a name="23"/>package record Save(text, undo)
<a name="24"/>
<a name="25"/>class TermDialog(Dialog, LineBasedOutputStream, VtUI)
<a name="26"/>   private readable
<a name="27"/>      input,
<a name="28"/>      history_limit,
<a name="29"/>      history,
<a name="30"/>      history_start_no,
<a name="31"/>      hpos,
<a name="32"/>      hmod,
<a name="33"/>      text,
<a name="34"/>      need_crnl,
<a name="35"/>      complete_function,
<a name="36"/>      line
<a name="37"/>
<a name="38"/>   public override link_left_clicked(url)
<a name="39"/>      local subst, de
<a name="40"/>      case string(url.scheme) of {
<a name="41"/>         "text": input.insert_string(ucs(url.get_decoded_path()))
<a name="42"/>         "file": {
<a name="43"/>            if subst := Subst.from_URL(url) &amp;
<a name="44"/>               de := Mime.gen_desktop_entries_for_path(subst.file)
<a name="45"/>            then
<a name="46"/>               de.launch_prog(subst)
<a name="47"/>         }
<a name="48"/>      }
<a name="49"/>   end
<a name="50"/>
<a name="51"/>   public override link_middle_clicked(urls)
<a name="52"/>      every input.insert_string(get_url_text(!urls) || u" ")
<a name="53"/>   end
<a name="54"/>
<a name="55"/>   private copy_text(s)
<a name="56"/>      own_selection(Selection.CLIPBOARD, StaticTextSelectionOwner(s))
<a name="57"/>   end
<a name="58"/>
<a name="59"/>   private copy_url(url)
<a name="60"/>      own_selection(Selection.CLIPBOARD, URLSelectionOwner([url]))
<a name="61"/>   end 
<a name="62"/>
<a name="63"/>   private static get_url_text(url)
<a name="64"/>      return case string(url.scheme) of {
<a name="65"/>         "text": ucs(url.get_decoded_path())
<a name="66"/>         "file": ucs(Files.url_to_file(url))
<a name="67"/>      }
<a name="68"/>   end
<a name="69"/>
<a name="70"/>   public override create_link_menu(url)
<a name="71"/>      local m, s
<a name="72"/>      m := Menu()
<a name="73"/>      if s := get_url_text(url) then
<a name="74"/>         m.add(TextMenuItem().
<a name="75"/>               set_label("Copy").
<a name="76"/>               connect(create copy_text(s), Event.ACTION))
<a name="77"/>      m.add(TextMenuItem().
<a name="78"/>            set_label("Copy URL").
<a name="79"/>            connect(create copy_url(url), Event.ACTION))
<a name="80"/>      return m
<a name="81"/>   end
<a name="82"/>
<a name="83"/>   public override create_context_menu()
<a name="84"/>      local m
<a name="85"/>      m := Menu()
<a name="86"/>      if text.get_current_text_selection() then {
<a name="87"/>         m.add(TextMenuItem().
<a name="88"/>               set_label("Copy").
<a name="89"/>               set_label_right("^C").
<a name="90"/>               connect(text.handle_copy, Event.ACTION))
<a name="91"/>      }
<a name="92"/>      m. add(TextMenuItem().
<a name="93"/>             set_label("Select all").
<a name="94"/>             connect(text.handle_select_all, Event.ACTION)).
<a name="95"/>         add(MenuSeparator()).
<a name="96"/>         add(TextMenuItem().
<a name="97"/>             set_label("Clear").
<a name="98"/>             connect(create clear_text(), Event.ACTION)).
<a name="99"/>         add(TextMenuItem().
<a name="100"/>             set_label("Quit").
<a name="101"/>             set_label_right("^Q").
<a name="102"/>             connect(create dispose(), Event.ACTION))
<a name="103"/>      return m.tidy()
<a name="104"/>   end
<a name="105"/>
<a name="106"/>   public override quieten_cursor()
<a name="107"/>   end
<a name="108"/>
<a name="109"/>   public override send_tty(s)
<a name="110"/>   end
<a name="111"/>
<a name="112"/>   public override vt_size_changed(cols, rows)
<a name="113"/>   end
<a name="114"/>
<a name="115"/>   public override msg(s, n)
<a name="116"/>   end
<a name="117"/>
<a name="118"/>   public override search_msg(s)
<a name="119"/>   end
<a name="120"/>
<a name="121"/>   # Clear the log area.
<a name="122"/>   #
<a name="123"/>   public clear_text()
<a name="124"/>      text.input("\e[9J\e[2J\e[H")
<a name="125"/>      need_crnl := &amp;no
<a name="126"/>      link
<a name="127"/>   end
<a name="128"/>
<a name="129"/>   protected override write_line_impl(s)
<a name="130"/>      is_live() | return error("TermDialog not live")
<a name="131"/>      if \need_crnl then
<a name="132"/>         text.input("\r\n")
<a name="133"/>      text.
<a name="134"/>         input(s).
<a name="135"/>         goto_bottom()
<a name="136"/>      need_crnl := &amp;yes
<a name="137"/>      return
<a name="138"/>   end
<a name="139"/>
<a name="140"/>   # Set the limit in lines for the text area log.
<a name="141"/>   #
<a name="142"/>   public set_log_limit(n)
<a name="143"/>      text.set_history_size(n)
<a name="144"/>      link
<a name="145"/>   end
<a name="146"/>
<a name="147"/>   # Set a function to generate completions when the tab key is
<a name="148"/>   # pressed.  The function is given subject and cursor position, and
<a name="149"/>   # should return a list of `gui.CompleteElement` instances.
<a name="150"/>   #
<a name="151"/>   public set_complete_function(f)
<a name="152"/>      self.complete_function := f
<a name="153"/>      link
<a name="154"/>   end
<a name="155"/>
<a name="156"/>   # Set the limit in lines for the command history.
<a name="157"/>   #
<a name="158"/>   public set_history_limit(n)
<a name="159"/>      self.history_limit := /n | need_integer(n, 0)
<a name="160"/>      limit_history()
<a name="161"/>      reset_term()
<a name="162"/>      link
<a name="163"/>   end
<a name="164"/>
<a name="165"/>   # Set the history list.
<a name="166"/>   #
<a name="167"/>   public set_history(l)
<a name="168"/>      self.history := l
<a name="169"/>      self.history_start_no := 1
<a name="170"/>      limit_history()
<a name="171"/>      reset_term()
<a name="172"/>      link
<a name="173"/>   end
<a name="174"/>
<a name="175"/>   public set_popup_on_tab(s)
<a name="176"/>      input.set_popup_on_tab(need_flag(s))
<a name="177"/>      link
<a name="178"/>   end
<a name="179"/>
<a name="180"/>   # Return the history list.
<a name="181"/>   #
<a name="182"/>   public get_history()
<a name="183"/>      return .history
<a name="184"/>   end
<a name="185"/>
<a name="186"/>   # Return the given history number line.
<a name="187"/>   #
<a name="188"/>   public get_history_item(n)
<a name="189"/>      return .history[0 &lt; n - history_start_no + 1]
<a name="190"/>   end
<a name="191"/>
<a name="192"/>   # Get the history number of the first entry in the history.
<a name="193"/>   #
<a name="194"/>   public get_history_start_no()
<a name="195"/>      return .history_start_no
<a name="196"/>   end
<a name="197"/>
<a name="198"/>   private goto_hist(n)
<a name="199"/>      local d
<a name="200"/>      (1 &lt;= n &lt;= *history + 1) | fail
<a name="201"/>      if input.undo_manager.get_last() then {
<a name="202"/>         insert(hmod, hpos, Save(input.get_contents(), input.undo_manager))
<a name="203"/>         # Set a new instance since set_contents will clear the manager
<a name="204"/>         input.set_undo_manager(UndoManager())
<a name="205"/>      }
<a name="206"/>      hpos := n
<a name="207"/>      if d := member(hmod, hpos) then {
<a name="208"/>         input.
<a name="209"/>            set_contents(d.text).
<a name="210"/>            set_undo_manager(d.undo)
<a name="211"/>      } else
<a name="212"/>         input.set_contents(history[hpos] | u"")
<a name="213"/>   end
<a name="214"/>
<a name="215"/>   private get_mod_hist(n)
<a name="216"/>      return member(hmod, n).text | history[n]
<a name="217"/>   end
<a name="218"/>
<a name="219"/>   private move_hist(n)
<a name="220"/>      goto_hist(hpos + n)
<a name="221"/>   end
<a name="222"/>
<a name="223"/>   private limit_history()
<a name="224"/>      while *history &gt; \history_limit do {
<a name="225"/>         pop(history)
<a name="226"/>         history_start_no +:= 1
<a name="227"/>      }
<a name="228"/>   end
<a name="229"/>
<a name="230"/>   public override component_setup()
<a name="231"/>      reset_term()
<a name="232"/>   end
<a name="233"/>
<a name="234"/>   public override end_dialog()
<a name="235"/>   end
<a name="236"/>
<a name="237"/>   public override init_dialog()
<a name="238"/>      text.input("\e[?25l")
<a name="239"/>   end
<a name="240"/>
<a name="241"/>   public get_term_width()
<a name="242"/>      return (text.predict_view_width(text.w, &amp;yes) - 2 * Gui.TEXT_INSET) / text.cbwin.text_width("m")
<a name="243"/>   end
<a name="244"/>
<a name="245"/>   public override new()
<a name="246"/>      Dialog.new()
<a name="247"/>      LineBasedOutputStream.new()
<a name="248"/>      hmod := table()
<a name="249"/>      history := []
<a name="250"/>      history_start_no := 1
<a name="251"/>      self.setup()
<a name="252"/>      text.
<a name="253"/>         set_ui(self).
<a name="254"/>         set_accepts_focus(&amp;no).
<a name="255"/>         set_history_size(600)
<a name="256"/>      return
<a name="257"/>   end
<a name="258"/>
<a name="259"/>   private reset_term()
<a name="260"/>      input.keep_closed()
<a name="261"/>      hpos := *history + 1
<a name="262"/>      clear(hmod)
<a name="263"/>      input.set_contents(u"")
<a name="264"/>   end
<a name="265"/>
<a name="266"/>   private on_input(ev)
<a name="267"/>      if input.was_applied(ev) then
<a name="268"/>         fail
<a name="269"/>      line := input.get_contents()
<a name="270"/>      if *line &gt; 0 then {
<a name="271"/>         put(history, line)
<a name="272"/>         limit_history()
<a name="273"/>      }
<a name="274"/>      reset_term()
<a name="275"/>      fire(Event.ACTION, ev)
<a name="276"/>   end
<a name="277"/>   
<a name="278"/>   private handle_key_up(e)
<a name="279"/>      if /input.popup then
<a name="280"/>         move_hist(-1)
<a name="281"/>   end
<a name="282"/>
<a name="283"/>   private handle_key_down(e)
<a name="284"/>      if /input.popup then
<a name="285"/>         move_hist(1)
<a name="286"/>   end
<a name="287"/>
<a name="288"/>   private handle_key_page_up(e)
<a name="289"/>      if /input.popup then
<a name="290"/>         text.handle_pgup(e)
<a name="291"/>   end
<a name="292"/>
<a name="293"/>   private handle_key_page_down(e)
<a name="294"/>      if /input.popup then
<a name="295"/>         text.handle_pgdn(e)
<a name="296"/>   end
<a name="297"/>
<a name="298"/>   private handle_history_recall()
<a name="299"/>      input.keep_closed()
<a name="300"/>      goto_hist(integer(input.get_contents()) - history_start_no + 1)
<a name="301"/>   end
<a name="302"/>
<a name="303"/>   private handle_history_search(dir)
<a name="304"/>      local i, s, c, curr
<a name="305"/>      input.keep_closed()
<a name="306"/>      c := input.cursor
<a name="307"/>      curr := input.get_contents()
<a name="308"/>      s := curr[1:c]
<a name="309"/>      every i := if dir &gt; 0 then (hpos + 1 to *history) | (1 to hpos - 1)
<a name="310"/>                            else (hpos - 1 to 1 by -1) | (*history to hpos + 1 by -1) do {
<a name="311"/>         if match(s, curr ~== get_mod_hist(i)) then {
<a name="312"/>            goto_hist(i)
<a name="313"/>            input.set_cursor(c)
<a name="314"/>            return
<a name="315"/>         }
<a name="316"/>      }
<a name="317"/>   end
<a name="318"/>
<a name="319"/>   private on_input_key(ev)
<a name="320"/>      case ev.code of {
<a name="321"/>         Key.UP : handle_key_up(ev)
<a name="322"/>         Key.DOWN : handle_key_down(ev)
<a name="323"/>         Key.PGUP : handle_key_page_up(ev)
<a name="324"/>         Key.PGDN : handle_key_page_down(ev)
<a name="325"/>         "\^p": handle_history_recall()
<a name="326"/>         "\^r": handle_history_search(-1)
<a name="327"/>         "\^t": handle_history_search(1)
<a name="328"/>         "\^g": reset_term()
<a name="329"/>      }
<a name="330"/>   end
<a name="331"/>
<a name="332"/>   private on_close_button(ev)
<a name="333"/>      dispose()
<a name="334"/>   end
<a name="335"/>
<a name="336"/>   private on_icon_event(ev)
<a name="337"/>      if ev.code === "\^q" &amp; /ev.release then 
<a name="338"/>         dispose()
<a name="339"/>   end
<a name="340"/>
<a name="341"/>   private setup()
<a name="342"/>      local layout_1
<a name="343"/>      self.set_resize(&amp;yes)
<a name="344"/>      self.set_size(scale(735), scale(510))
<a name="345"/>      text := Vt().
<a name="346"/>         set_size(scale(465), scale(256)).
<a name="347"/>         clear_constraints().
<a name="348"/>         set_constraint(Grid.EOL, &amp;yes).
<a name="349"/>         set_constraint(Grid.X_FILL, &amp;yes).
<a name="350"/>         set_constraint(Grid.X_WEIGHT, 1.0).
<a name="351"/>         set_constraint(Grid.Y_FILL, &amp;yes).
<a name="352"/>         set_constraint(Grid.Y_WEIGHT, 1.0)
<a name="353"/>      self.add(text)
<a name="354"/>      input := TermTextField().
<a name="355"/>         set_size(scale(458)).
<a name="356"/>         clear_constraints().
<a name="357"/>         set_constraint(Grid.X_ALIGN, Align.L).
<a name="358"/>         set_constraint(Grid.X_FILL, &amp;yes).
<a name="359"/>         set_constraint(Grid.X_WEIGHT, 1.0).
<a name="360"/>         connect(self.on_input, Event.ACTION).
<a name="361"/>         connect(self.on_input_key, Event.KEY_PRESS).
<a name="362"/>         set_contents(u"")
<a name="363"/>      self.add(input)
<a name="364"/>      self.connect(self.on_close_button, Event.WINDOW_CLOSE_BUTTON)
<a name="365"/>      self.connect(self.on_icon_event, Event.ICON)
<a name="366"/>      layout_1 := GridLayout().
<a name="367"/>         set_extra("cells")
<a name="368"/>      self.set_layout(layout_1)
<a name="369"/>      self.set_focus(input.find_focus())
<a name="370"/>   end
<a name="371"/>end
<a name="372"/>
<a name="373"/>### Ivib-v2 layout: layouts/$.layout
</pre></body></html>
