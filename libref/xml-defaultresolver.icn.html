<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>defaultresolver.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: defaultresolver.icn 9110 2021-05-16 10:39:53Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package xml
<a name="10"/>
<a name="11"/>import http, net, util, io
<a name="12"/>
<a name="13"/>#
<a name="14"/># The default resolver resolves from a URL or the local file system.
<a name="15"/>#
<a name="16"/># If the system id begins with "http://", it is treated as a web URL, and
<a name="17"/># loaded over the network.  
<a name="18"/>#
<a name="19"/># If it begins with "file://", then it is treated as a
<a name="20"/># local file (for an absolute path on Unix like systems, that would be
<a name="21"/># three forward slashes at the start : "file:///tmp/file.dtd").
<a name="22"/>#
<a name="23"/># Otherwise, the system id is treated as a filename.
<a name="24"/>#
<a name="25"/>class DefaultResolver(Resolver)
<a name="26"/>   private const
<a name="27"/>      public_mapping,
<a name="28"/>      uri_cache
<a name="29"/>   private
<a name="30"/>      cache_uris_flag,
<a name="31"/>      http_client
<a name="32"/>
<a name="33"/>   #
<a name="34"/>   # Set a mapping from a public id to an alternative URI.  The alternative URI
<a name="35"/>   # will then be loaded when the public id is encountered, rather than the
<a name="36"/>   # given system id.  The alternative may be a simple filename if desired.
<a name="37"/>   #
<a name="38"/>   # Example :-
<a name="39"/>   # ~
<a name="40"/>   #    set_public_mapping("-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN", 
<a name="41"/>   #                       "/tmp/web-app_2_3.dtd")
<a name="42"/>   # ~
<a name="43"/>   # :Parameters :
<a name="44"/>   # :  `pub_id` - the public id
<a name="45"/>   # :  `uri` - the alternative uri
<a name="46"/>   #
<a name="47"/>   public set_public_mapping(pub_id, uri)
<a name="48"/>      insert(public_mapping, pub_id, uri)
<a name="49"/>      link
<a name="50"/>   end
<a name="51"/>
<a name="52"/>   #
<a name="53"/>   # Configure whether the resolver remembers URIs internally to save getting them
<a name="54"/>   # more than once.  This is on by default.
<a name="55"/>   #
<a name="56"/>   public set_cache_uris(s)
<a name="57"/>      self.cache_uris_flag := need_flag(s)
<a name="58"/>      link
<a name="59"/>   end
<a name="60"/>
<a name="61"/>   #
<a name="62"/>   # Use the given HttpClient for getting http:// URLs.  Use this to set custom timeout
<a name="63"/>   # or retry values for example.
<a name="64"/>   #
<a name="65"/>   public set_http_client(hc)
<a name="66"/>      self.http_client := hc
<a name="67"/>      link
<a name="68"/>   end
<a name="69"/>
<a name="70"/>   #
<a name="71"/>   # Cache an individual system id (URI) to the given value.
<a name="72"/>   #
<a name="73"/>   public cache_uri(sys_id, val)
<a name="74"/>      val := need_string(val)
<a name="75"/>      insert(uri_cache, sys_id, val)
<a name="76"/>      link
<a name="77"/>   end
<a name="78"/>
<a name="79"/>   public override resolve(base, external_id)
<a name="80"/>      local sys_id, sys_url, res, u, t
<a name="81"/>
<a name="82"/>      base := need_string(\base)
<a name="83"/>
<a name="84"/>      #
<a name="85"/>      # Try to map from the public id (if any) to an alternative URI
<a name="86"/>      #
<a name="87"/>      sys_id := member(public_mapping, 
<a name="88"/>                       external_id.get_public_id()) | external_id.get_system_id()
<a name="89"/>
<a name="90"/>      sys_id := string(sys_id)
<a name="91"/>
<a name="92"/>      unless sys_url := URL(sys_id) &amp; sys_url.scheme == ("http" | "https" | "file") then {
<a name="93"/>         sys_url := if u := URL(\base) &amp;
<a name="94"/>                       u.scheme == ("http" | "https" | "file")
<a name="95"/>         then
<a name="96"/>            #
<a name="97"/>            # Make a URL from sys_id and base.
<a name="98"/>            #
<a name="99"/>            u.get_relative(sys_id)
<a name="100"/>         else
<a name="101"/>            # 
<a name="102"/>            # Make a file URL from the filename.
<a name="103"/>            #
<a name="104"/>            URL(FilePath(sys_id).canonical().to_url())
<a name="105"/>      }
<a name="106"/>
<a name="107"/>      sys_url := sys_url.normal()
<a name="108"/>      sys_id := sys_url.str()
<a name="109"/>
<a name="110"/>      #
<a name="111"/>      # Try the cache.
<a name="112"/>      #
<a name="113"/>      if \cache_uris_flag &amp; t := member(uri_cache, sys_id) then
<a name="114"/>         return Resolved(sys_id, t)
<a name="115"/>
<a name="116"/>      res := resolve_impl(sys_url) | return error("Failed to resolve " || sys_id || ": " || &amp;why)
<a name="117"/>
<a name="118"/>      #
<a name="119"/>      # Cache if appropriate
<a name="120"/>      #
<a name="121"/>      if \cache_uris_flag then
<a name="122"/>         cache_uri(sys_id, res)
<a name="123"/>
<a name="124"/>      return Resolved(sys_id, res)
<a name="125"/>   end
<a name="126"/>
<a name="127"/>   private resolve_impl(url)
<a name="128"/>      return case url.scheme of {
<a name="129"/>         "http" | "https": get_http(url)
<a name="130"/>         "file": get_local(url)
<a name="131"/>         default: syserr("sys_id not a file or http(s) URL")
<a name="132"/>      }
<a name="133"/>   end
<a name="134"/>
<a name="135"/>   private get_local(url)
<a name="136"/>      return Files.file_to_string(Files.url_to_file(url))
<a name="137"/>   end
<a name="138"/>
<a name="139"/>   private get_http(url)
<a name="140"/>      local sb
<a name="141"/>      return use { 
<a name="142"/>         http_client,
<a name="143"/>         use {
<a name="144"/>            sb := RamStream(),
<a name="145"/>            if http_client.retrieve(HttpRequest().set_url(url).set_output_stream(sb)) then
<a name="146"/>               sb.str()
<a name="147"/>         }
<a name="148"/>      }
<a name="149"/>   end
<a name="150"/>
<a name="151"/>   public new()
<a name="152"/>      public_mapping := table()
<a name="153"/>      uri_cache := table()
<a name="154"/>      cache_uris_flag := &amp;yes
<a name="155"/>      self.http_client := HttpClient()
<a name="156"/>      return
<a name="157"/>   end
<a name="158"/>end
<a name="159"/>
</pre></body></html>
