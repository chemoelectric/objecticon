<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>colrmodl.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     colrmodl.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures to convert between color models
<a name="6"/>#
<a name="7"/>#	Author:   Ralph E. Griswold
<a name="8"/>#
<a name="9"/>#	Date:     December 5, 1995
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#     These procedures convert between various color models. A color
<a name="18"/>#  value is represented by a record (see the declarations below).
<a name="19"/>#
<a name="20"/>#  Color values are normalized to a maximum of 1.0.
<a name="21"/>#
<a name="22"/>############################################################################
<a name="23"/>#
<a name="24"/>#  Acknowledgement:  Some of the procedures here are based on information
<a name="25"/>#  given in Computer Graphics; Principles and Practice, second edition;
<a name="26"/>#  James D. Foley, Andries van Dam, Steven K. Feiner, and John F. Hughes;
<a name="27"/>#  Addison-Wesley Publishing Company; 1990.
<a name="28"/>#
<a name="29"/>############################################################################
<a name="30"/>#
<a name="31"/>#  Note:  These procedures have not been extensively tested. Those related
<a name="32"/>#  to the YIQ model are particularly in question.
<a name="33"/>#
<a name="34"/>############################################################################
<a name="35"/>#
<a name="36"/>#  Links:  matrix, numbers
<a name="37"/>#
<a name="38"/>############################################################################
<a name="39"/>
<a name="40"/>package ipl.graphics
<a name="41"/>
<a name="42"/>import
<a name="43"/>   graphics(Window),
<a name="44"/>   ipl.matrix(create_matrix, mult_matrix)
<a name="45"/>
<a name="46"/>record rgb(r, g, b)
<a name="47"/>record cmy(c, m, y)
<a name="48"/>record cmyk(c, m, y, k)
<a name="49"/>record yiq(y, i, q)
<a name="50"/>record hsv(h, s, v)
<a name="51"/>record hls(h, l, s)
<a name="52"/>
<a name="53"/>procedure rgb2cmy(color)
<a name="54"/>
<a name="55"/>   return cmy(1.0 - color.r, 1.0 - color.g, 1.0 - color.b)
<a name="56"/>
<a name="57"/>end
<a name="58"/>
<a name="59"/>procedure cmy2rgb(color)
<a name="60"/>
<a name="61"/>   return rgb(1.0 - color.c, 1.0 - color.m, 1.0 - color.y)
<a name="62"/>
<a name="63"/>end
<a name="64"/>
<a name="65"/>#  Note: The following procedure illustrates the principle of
<a name="66"/>#  undercolor removal, but for pragmatic reasons, it does not
<a name="67"/>#  produce acceptable results in process printing.
<a name="68"/>
<a name="69"/>procedure cmy2cmyk(color)
<a name="70"/>   local k
<a name="71"/>
<a name="72"/>   k := min(color.c, color.m, color.y)
<a name="73"/>
<a name="74"/>   return cmyk(color.c - k, color.m - k, color.y - k, k)
<a name="75"/>
<a name="76"/>end
<a name="77"/>
<a name="78"/>procedure cmyk2cmy(color)
<a name="79"/>   local kdelta
<a name="80"/>
<a name="81"/>   kdelta := color.k / 3
<a name="82"/>
<a name="83"/>   return cmy(color.c + kdelta, color.m + kdelta, color.y + kdelta)
<a name="84"/>
<a name="85"/>end
<a name="86"/>
<a name="87"/>#
<a name="88"/>#  Note: The RGB specification is assumed to be based on the standard
<a name="89"/>#  NTSC phosphors.  See the reference cited above.
<a name="90"/>
<a name="91"/>procedure rgb2yiq(color)
<a name="92"/>   static M, R, Y
<a name="93"/>
<a name="94"/>   initial {
<a name="95"/>      M := create_matrix(3, 3)
<a name="96"/>      M[1, 1] := 0.299
<a name="97"/>      M[1, 2] := 0.587
<a name="98"/>      M[1, 3] := 0.114
<a name="99"/>      M[2, 1] := 0.596
<a name="100"/>      M[2, 2] := -0.275
<a name="101"/>      M[2, 3] := -0.321
<a name="102"/>      M[3, 1] := 0.212
<a name="103"/>      M[3, 2] := -0.528
<a name="104"/>      M[3, 3] := 0.311
<a name="105"/>      }
<a name="106"/>
<a name="107"/>   R := create_matrix(3, 1)
<a name="108"/>   R[1][1] := color.r
<a name="109"/>   R[2][1] := color.g
<a name="110"/>   R[3][1] := color.b
<a name="111"/>
<a name="112"/>   Y := mult_matrix(M, R)
<a name="113"/>
<a name="114"/>   return yiq(Y[1][1], Y[2][1], Y[3][1])
<a name="115"/>
<a name="116"/>end
<a name="117"/>
<a name="118"/>procedure yiq2rgb(color)
<a name="119"/>   static M, R, Y
<a name="120"/>
<a name="121"/>   initial {
<a name="122"/>      M := create_matrix(3, 3)
<a name="123"/>      M[1, 1] := 1.0031
<a name="124"/>      M[1, 2] := 0.9548
<a name="125"/>      M[1, 3] := 0.6179
<a name="126"/>      M[2, 1] := 0.9968
<a name="127"/>      M[2, 2] := -0.2707
<a name="128"/>      M[2, 3] := -0.6448
<a name="129"/>      M[3, 1] := 1.0084
<a name="130"/>      M[3, 2] := -1.1005
<a name="131"/>      M[3, 3] := 1.6996
<a name="132"/>      }
<a name="133"/>
<a name="134"/>   Y := create_matrix(3, 1)
<a name="135"/>   Y[1][1] := color.y
<a name="136"/>   Y[2][1] := color.i
<a name="137"/>   Y[3][1] := color.q
<a name="138"/>
<a name="139"/>   R := mult_matrix(M, Y)
<a name="140"/>
<a name="141"/>   return rgb(R[1][1], R[2][1], R[3][1])
<a name="142"/>
<a name="143"/>end
<a name="144"/>
<a name="145"/>procedure rgb2hsv(color)
<a name="146"/>   local maximum, minimum, delta, h, s, v
<a name="147"/>
<a name="148"/>   maximum := max(color.r, color.g, color.b)
<a name="149"/>   minimum := min(color.r, color.g, color.b)
<a name="150"/>   delta := maximum - minimum
<a name="151"/>
<a name="152"/>   v := maximum
<a name="153"/>
<a name="154"/>   if maximum ~= 0.0 then s := delta / maximum
<a name="155"/>   else s := 0.0
<a name="156"/>
<a name="157"/>   if s = 0.0 then h := 0.0		# use hue 0 if unsaturated
<a name="158"/>   else {
<a name="159"/>      if color.r = maximum then
<a name="160"/>         h := (color.g - color.b) / delta
<a name="161"/>      else if color.g = maximum then 
<a name="162"/>         h := 2 + (color.b - color.r) / delta
<a name="163"/>      else  # color.b = maximum
<a name="164"/>         h := 4 + (color.r - color.g) / delta
<a name="165"/>      h *:= 60                          # convert to degrees
<a name="166"/>      if h &lt; 0.0 then h +:= 360.0	# make sure hue is nonnegative
<a name="167"/>      }
<a name="168"/>
<a name="169"/>   return hsv(h, s, v)
<a name="170"/>
<a name="171"/>end
<a name="172"/>
<a name="173"/>procedure hsv2rgb(color)
<a name="174"/>   local h, i, f, p, q, t, s, v
<a name="175"/>
<a name="176"/>   h := color.h
<a name="177"/>   v := color.v
<a name="178"/>   s := color.s
<a name="179"/>
<a name="180"/>   if s = 0.0 then {
<a name="181"/>      return rgb(v, v, v)    # achromatic case
<a name="182"/>      }
<a name="183"/>   else {
<a name="184"/>      h /:= 60.0             # hue [0.0 - 6.0)
<a name="185"/>      if h &gt;= 6.0 then
<a name="186"/>         h := 0.0
<a name="187"/>
<a name="188"/>      i := integer(h)
<a name="189"/>      f := h - i
<a name="190"/>      p := v * (1.0 - s)
<a name="191"/>      q := v * (1.0 - s * f)
<a name="192"/>      t := v * (1.0 - (s * (1.0 - f)))
<a name="193"/>      return case i of {
<a name="194"/>         0:  rgb(v, t, p)
<a name="195"/>         1:  rgb(q, v, p)
<a name="196"/>         2:  rgb(p, v, t)
<a name="197"/>         3:  rgb(p, q, v)
<a name="198"/>         4:  rgb(t, p, v)
<a name="199"/>         5:  rgb(v, p, q)
<a name="200"/>         default:  fail
<a name="201"/>         }
<a name="202"/>      }
<a name="203"/>
<a name="204"/>end
<a name="205"/>
<a name="206"/>procedure rgb2hls(color)
<a name="207"/>   local maximum, minimum, delta, sum, h, s, l
<a name="208"/>
<a name="209"/>   maximum := max(color.r, color.b, color.g)
<a name="210"/>   minimum := min(color.r, color.b, color.g)
<a name="211"/>
<a name="212"/>   delta := maximum - minimum
<a name="213"/>   sum := maximum + minimum
<a name="214"/>   l := sum / 2				# lightness
<a name="215"/>
<a name="216"/>   if maximum = minimum then {		# achromatic case
<a name="217"/>      h := s := 0.0
<a name="218"/>      }
<a name="219"/>   else {
<a name="220"/>      if l &lt;= 0.5 then
<a name="221"/>         s := delta / sum
<a name="222"/>      else s := delta / (2 - sum)
<a name="223"/>
<a name="224"/>      if color.r = maximum then
<a name="225"/>         h := (color.g - color.b) / delta
<a name="226"/>      else if color.g = maximum then
<a name="227"/>         h := 2 + (color.b - color.r) / delta
<a name="228"/>      else # color.b = maximum
<a name="229"/>         h := 4 + (color.r - color.g) / delta
<a name="230"/>      h *:= 60				# convert to degrees
<a name="231"/>      if h &lt; 0.0 then h +:= 360.0	# make positive
<a name="232"/>      }
<a name="233"/>
<a name="234"/>   return hls(h, l, s)
<a name="235"/>end
<a name="236"/>
<a name="237"/>procedure hls2rgb(color)
<a name="238"/>   local h, l, s, m1, m2
<a name="239"/>
<a name="240"/>   h := color.h
<a name="241"/>   l := color.l
<a name="242"/>   s := color.s
<a name="243"/>
<a name="244"/>   if l &lt;= 0.5 then m2 := l * (1 + s)
<a name="245"/>   else m2 := l + s - l * s
<a name="246"/>   m1 := 2 * l - m2
<a name="247"/>   if s = 0.0 then {			# achromatic case
<a name="248"/>      return rgb(l, l, l)
<a name="249"/>      }
<a name="250"/>   else {
<a name="251"/>      return rgb(
<a name="252"/>         color_value(m1, m2, h + 120.0),
<a name="253"/>         color_value(m1, m2, h),
<a name="254"/>         color_value(m1, m2, h - 120.0)
<a name="255"/>         )
<a name="256"/>      }
<a name="257"/>
<a name="258"/>end
<a name="259"/>
<a name="260"/>procedure color_value(m1, m2, h)
<a name="261"/>
<a name="262"/>   if h &gt; 360.0 then h -:= 360.0
<a name="263"/>   else if h &lt; 0.0 then h +:= 360.0
<a name="264"/>   if h &lt; 60.0 then return m1 + (m2 - m1) * h / 60.0
<a name="265"/>   else if h &lt; 180.0 then return m2
<a name="266"/>   else if h &lt; 240.0 then return m1 + (m2 - m1) * (240.0 - h) / 60.0
<a name="267"/>   else return m1
<a name="268"/>
<a name="269"/>end
<a name="270"/>
<a name="271"/>procedure color2rgb(color)
<a name="272"/>   local t
<a name="273"/>   t := Window.parse_color(color) | fail
<a name="274"/>   return rgb(t.red / 65535.0,
<a name="275"/>              t.green / 65535.0,
<a name="276"/>              t.blue / 65535.0)
<a name="277"/>end
<a name="278"/>
<a name="279"/>procedure rgb2color(rgb)
<a name="280"/>   return rgb.r || "," || rgb.g || "," || rgb.b
<a name="281"/>end
</pre></body></html>
