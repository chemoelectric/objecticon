#
# $Id: sets.icn 3945 2013-02-22 20:36:44Z r.parlett $
#

package datastruct

import lang, util, ipl.pdco-(List)

#
# This is a common superclass for a list-like data structure.
#
abstract class List(HasMode, ObjectOutput, ObjectHash, ObjectEquals)
   public static const
      # An empty list instance
      EMPTY_LIST,
      # Constant indicating modifiable capability
      MODIFY,
      # Constant indicating insert capability
      INSERT,
      # Constant indicating delete capability
      DELETE

   private static init()
      EMPTY_LIST := EmptyList()
      MODIFY := 1
      INSERT := 2
      DELETE := 4
   end

   #
   # Insert a new element `x` at position `i`.  Fails if `i` is
   # invalid; otherwise succeeds and returns `self`.  Only implemented
   # with INSERT capability.
   #
   public optional insert(i, x)
   
   #
   # Delete element at position `i` from the list.  Fails if `i` is
   # invalid; otherwise succeeds and returns `self`.  Only implemented
   # with DELETE capability.
   #
   public optional delete(i)

   #
   # Return the member at position `i`.  If the list has MODIFY
   # capability, a variable is returned, otherwise a value is
   # returned.
   #
   public abstract at(i)

   #
   # Remove and return an element from the left end of list.
   #
   public get()
      return 1(.at(1), delete(1))
   end

   #
   # Remove and return an element from the right end of the list.
   #
   public pull()
      return 1(.at(-1), delete(-1))
   end

   #
   # Push an element onto the left end of the list.
   #
   public push(x)
      return insert(1, x)
   end

   #
   # Push an element onto the right end of the list.
   #
   public put(x)
      return insert(0, x)
   end

   #
   # Generate the members.  If the list has MODIFY capability,
   # variables are generated, otherwise values are generated.
   #
   public gen()
      suspend gen_from(1)
   end

   #
   # Generate the members, starting with the element at index `i`.
   # If the list has MODIFY capability, variables are generated,
   # otherwise values are generated.
   #
   public gen_from(i)
      i := cvpos_item(i, size()) | fail
      repeat {
         suspend at(i)
         if i < size() then
            i +:= 1
         else
            fail
      }
   end

   #
   # Generate the members in reverse order.  If the list has MODIFY
   # capability, variables are generated, otherwise values are
   # generated.
   #
   public back()
      suspend back_from(0)
   end

   #
   # Generate the members in reverse order, starting with the element
   # before index `i` (thus generating the elements in the range 1:i).
   # If the list has MODIFY capability, variables are generated,
   # otherwise values are generated.
   #
   public back_from(i)
      i := need_integer(i)
      i := cvpos_item(i - 1, size()) | fail
      while i > 0 do {
         suspend at(i)
         i := min(i - 1, size())
      }
   end

   #
   # Return the size of the list.
   #
   public abstract size()

   #
   # Clear the list of all elements. Always succeeds and returns
   # `self`.  Only implemented with DELETE capability.
   #
   public clear()
      while delete(1)
      link
   end

   #
   # Generate the indices i such that at(i) === x
   #
   public keyof(x)
      suspend Positions{gen(), x}
   end

   #
   # Return an icon list of the elements.
   #
   public list()
      return ipl.pdco.List{gen()}
   end

   #
   # Return an icon list of the elements in the range i:j
   #
   public slice(i, j)
      local s
      s := cvslice(i, j, size()) | fail
      return ipl.pdco.List{ gen_from(s.lo) \ (s.hi - s.lo) }
   end

   #
   # Succeed iff the size is zero.
   #
   public empty()
      succeed size() = 0
   end

   #
   # Return a random value (cf ?l for a list).  If the list has MODIFY
   # capability, a variable is returned, otherwise a value is
   # returned.
   #
   public random()
      return at(?(0 < size()))
   end

   #
   # Custom equals mirrors the `equals()` behaviour for builtin lists.
   #
   private override object_equals(other, seen)
      local e, x
      other.size() = size() | fail
      e := create other.gen()
      every x := gen() do
         equals(x, @e, seen) | fail
      return not @e
   end

   #
   # Custom hash mirrors the `hash()` behaviour for builtin lists.
   #
   private override object_hash(depth)
      local n, i
      n := size()
      if depth > 1 then
         every i := hash(gen() \ 10, depth - 1) do
            n := 37 * iand(n, 16rffffff)  + i
      return n
   end

   #
   # Output object
   #
   private override object_output(oo)
      local e, sep
      if oo.simple{gen()} then {
         oo.object_start(self)
         every e := gen() do {
            if \sep then
               oo.writes1(",")
            oo.traverse(e)
            sep := &yes
         }
         oo.object_end(self)
      } else {
         oo.nl().
            object_start(self).
            iplus()
         every e := gen() do {
            if \sep then
               oo.writes1(",")
            oo.nl().
               traverse(e)
            sep := &yes
         }
         oo.iminus().
            nl().
            object_end(self)
      }
   end
end

#
# This list wraps another list to provide an unmodifiable view of it.
#
class UnmodifiableList(List)
   private const l

   public override at(i)
      return .l.at(i)
   end

   public override gen_from(i)
      suspend .l.gen_from(i)
   end

   public override back_from(i)
      suspend .l.back_from(i)
   end

   public override size()
      return l.size()
   end

   public override random()
      return .l.random()
   end

   public override get_mode()
      return 0
   end

   public new(l)
      self.l := need_instance(l, List)
      return
   end
end

#
# A `List` that is just a wrapper around a builtin list
#
class BuiltinList(List)
   private const l

   public override insert(i, x)
      link default.insert(l, i, x)
   end

   public override delete(i)
      link default.delete(l, i)
   end

   public override at(i)
      return l[i]
   end

   public override get()
      return default.get(l)
   end

   public override pull()
      return default.pull(l)
   end

   public override push(x)
      default.push(l, x)
      link
   end

   public override put(x)
      default.put(l, x)
      link
   end

   public override keyof(x)
      suspend default.keyof(l, x)
   end

   public override gen()
      suspend !l
   end

   public override back()
      suspend default.back(l)
   end

   public override slice(i, j)
      return l[i:j]
   end

   public override size()
      return *l
   end

   public override random()
      return ?l
   end

   public override clear()
      default.clear(l)
      link
   end

   public override get_mode()
      return MODIFY + INSERT + DELETE
   end

   public new(l)
      self.l := need_list(\l) | []
      return
   end
end

#
# An empty list.  An instance of this class is `List.EMPTY_LIST`.
#
class EmptyList(List)
   public override at(i)
   end

   public override size()
      return 0
   end

   public override get_mode()
      return 0
   end
end

#
# A node in a `LinkedList`.
#
package class LinkedListNode()
   public
      nxt, val

   public new(nxt, val)
      self.nxt := nxt
      self.val := val
      return
   end
end

#
# A `List` implementation based on a simple linked list.  Note some of
# the operations which suspend values may behave differently from the
# builtin list if the list is concurrently modified.
#
class LinkedList(List)
   private nhead

   public override insert(i, x)
      local n
      i := need_integer(i)
      if i <= 0 then
         i := cvpos(i, size()) | fail
      if i = 1 then
         nhead := LinkedListNode(nhead, x)
      else {
         n := node_at(i - 1) | fail
         n.nxt := LinkedListNode(n.nxt, x)
      }
      link
   end

   public override delete(i)
      local n
      i := need_integer(i)
      if i <= 0 then
         i := cvpos_item(i, size()) | fail
      if i = 1 then
         nhead := (\nhead).nxt | fail
      else {
         n := node_at(i - 1) | fail
         n.nxt := (\n.nxt).nxt | fail
      }
      link
   end

   public override at(i)
      return node_at(i).val
   end

   public override empty()
      return /nhead
   end

   public override pull()
      local v, n
      \nhead | fail
      if /nhead.nxt then {
         v := nhead.val
         nhead := &null
      } else {
         n := nhead
         while \n.nxt.nxt do
            n := n.nxt
         v := n.nxt.val
         n.nxt := &null
      }
      return v
   end

   public override gen_from(i)
      local n
      n := node_at(i) | fail
      while \n do {
         suspend n.val
         n := n.nxt
      }
   end

   public override back_from(i)
      local n
      i := need_integer(i)
      n := node_at(i - 1) | fail
      repeat {
         suspend n.val
         n := before(n) | fail
      }
   end

   private before(n)
      local t
      t := nhead
      while \t do {
         if t.nxt === n then
            return t
         t := t.nxt
      }
   end

   public override size()
      local i, n
      i := 0
      n := nhead
      while \n do {
         i +:= 1
         n := n.nxt
      }
      return i
   end

   public override clear()
      nhead := &null
      link
   end

   public override get_mode()
      return MODIFY + INSERT + DELETE
   end

   #
   # Return the head value of the list, or fail if the list is empty.
   #
   public head()
      return (\nhead).val
   end

   #
   # Set the head of the list (ie its first value), or fail if this
   # list is empty.
   #
   public set_head(x)
      link ((\nhead).val := x)
   end

   #
   # Return the tail of the list, or fail if the list is empty.
   #
   public tail()
      return from_node((\nhead).nxt)
   end

   #
   # Set the tail of the list to share the elements of the list
   # `other`, or fail if this list is empty.
   #
   public set_tail(other)
      need_instance(other, LinkedList)
      link ((\nhead).nxt := other.nhead)
   end

   #
   # Set the tail of the list to the empty list (leaving just one
   # element), or fail if this list is empty.
   #
   public clear_tail()
      link ((\nhead).nxt := &null)
   end

   #
   # Set this list to share the same elements as `other`.
   #
   public set_list(other)
      need_instance(other, LinkedList)
      nhead := other.nhead
      link
   end

   #
   # Return a new list which shares the elements of this list from
   # (and including) element `i`.
   #
   public from(i)
      return from_node(node_at(i))
   end

   #
   # Succeed iff this list shares the same elements as list `other`.
   #
   public same(other)
      succeed nhead === other.nhead
   end

   #
   # Return the node containing element `i`, or fail if `i` is out of
   # range.
   #
   private node_at(i)
      local n
      i := need_integer(i)
      if i <= 0 then
         i := cvpos_item(i, size()) | fail
      n := nhead
      while \n & i > 1 do {
         n := n.nxt
         i -:= 1
      }
      return \n
   end

   #
   # Create an instance given a `LinkedListNode` as the list's head node.
   #
   private static from_node(n)
      local i
      i := Class.create_instance()
      i.nhead := n
      return i
   end

   #
   # Create an instance and add each of the given entries.
   #
   public new(entries[])
      every nhead := LinkedListNode(nhead, default.back(entries))
      return
   end
end

#
# A node in a `DoublyLinkedList`.
#
package class DoublyLinkedListNode()
   public
      nxt, prev, val

   public new(prev, nxt, val)
      self.prev := prev
      self.nxt := nxt
      self.val := val
      return
   end
end

#
# A reference to a `DoublyLinkedListNode`.  The reference may move
# along the list, change values, and insert or delete nodes.
#
# Note that removing any elements from a list makes all node
# references presently relating to that list read-only (but see
# `delete` below for an exception).  After being made read-only,
# further attempts to use the reference to insert or delete nodes will
# cause a runtime error; however changing values or moving the
# reference is still permitted.
#
# Insertions into a list do not make any of a list's references
# read-only.
#
class DoublyLinkedListNodeRef()
   private const
      l
   private
      ver,
      n

   private need_write()
      can_write() | runerr("Reference is read-only", self)
   end

   #
   # Succeed iff this reference can be used to write (insert or delete
   # nodes).
   #
   public can_write()
      succeed l.ver = ver
   end

   #
   # Return the value in the currently referenced node.  A variable is
   # returned, allowing the value to be changed.
   #
   public val()
      return n.val
   end

   #
   # Create another instance referencing the same list and node as
   # this instance.
   #
   public dup()
      return DoublyLinkedListNodeRef(l, ver, n)
   end

   #
   # Insert a new node with the given value immediately before the
   # currently referenced node.
   #
   # Example :-
   # ~
   #   l := DoublyLinkedList(10,20,30,40)
   #   r := l.ref(3)
   #   r.insert_before(99)
   #   # Now l is (10,20,99,30,40)
   #   r.val()     # still 30
   # ~
   #
   public insert_before(x)
      need_write()
      l.insert_before_node(n, x)
      link
   end

   #
   # Like `insert_before`, but insert after the currently referenced
   # node.
   #
   public insert_after(x)
      need_write()
      l.insert_after_node(n, x)
      link
   end

   #
   # Insert the contents of another `DoublyLinkedList` immediately
   # before the currently referenced node.  Afterwards, `other` is
   # empty. (see also `DoublyLinkedList.splice()`.)
   #
   public splice_before(other)
      need_write()
      l.splice_before_node(n, other)
      link
   end

   #
   # Like `splice_before`, but insert after the currently referenced
   # node.
   #
   public splice_after(other)
      need_write()
      l.splice_after_node(n, other)
      link
   end

   #
   # Move the referenced node along the list `i` places; negative
   # means towards the head.  Fails (and does nothing) if the desired
   # location does not exist.
   #
   public move(i)
      local t
      i := need_integer(i)
      t := n
      if i > 0 then {
         every 1 to i do
            t := \t.nxt | fail
      } else {
         every 1 to -i do
            t := \t.prev | fail
      }
      n := t
      link
   end

   #
   # Delete the currently referenced node from the enclosing list.
   #
   # `i` optionally specifies a new node to reference after the
   # deletion, being `i` steps from the present node (see `move`).  In
   # this case the reference can continue to be used for further
   # insert and delete operations.  Otherwise, the reference becomes
   # read-only; further inserts or deletes will cause a runtime error.
   #
   # The method succeeds if `i` is null, or the `move` `i` steps to
   # the new node succeeded.  Note that the deletion takes place
   # regardless.
   #
   # Examples :-
   # ~
   #   l := DoublyLinkedList(10,20,30,40,50,60,70)
   #   r := l.ref(4)
   #   r.val()     # 40
   #   r.delete(1) # move 1 right, then delete old node
   #   # Now l is (10,20,30,50,60,70)
   #   r.val()     # 50
   #
   #   l := DoublyLinkedList(3,10,20,3,3,30,3,40,50,60,70,3)
   #   # Delete all the 3's from the list.
   #   r := l.ref(1)
   #   while if r.val() = 3 then r.delete(1) else r.move(1)
   #   # Now l is (10,20,30,40,50,60,70)
   #
   #   l := DoublyLinkedList(99)
   #   r := l.ref(1)
   #   r.delete()
   #   # l is now empty
   #   r.insert_after(100)      # runtime error
   # ~
   #
   public delete(i)
      local t, f
      need_write()
      t := n
      /i | move(i) | (f := &yes)
      l.delete_node(t)
      unless t === n then
         ver := l.ver
      link /f
   end

   package new(l, v, n)
      self.l := l
      self.ver := v
      self.n := n
      return
   end
end

#
# A `List` implementation based on a doubly linked list.  Note some of
# the operations which suspend values may behave differently from the
# builtin list if the list is concurrently modified.
#
class DoublyLinkedList(List)
   private
      nhead,
      ntail,
      sz
   package
      ver

   public override insert(i, x)
      i := cvpos(i, sz) | fail
      if i = 1 then {
         nhead := (if /nhead then ntail else nhead.prev) :=
            DoublyLinkedListNode(, nhead, x)
         sz +:= 1
      } else
         insert_after_node(node_at(i - 1), x)
      link
   end

   package insert_before_node(n, x)
      n.prev := (if /n.prev then nhead else n.prev.nxt) :=
         DoublyLinkedListNode(n.prev, n, x)
      sz +:= 1
      link
   end

   public override clear()
      nhead := ntail := &null
      sz := 0
      mod()
      link
   end

   private mod()
      ver +:= 1
   end

   package insert_after_node(n, x)
      n.nxt := (if /n.nxt then ntail else n.nxt.prev) :=
         DoublyLinkedListNode(n, n.nxt, x)
      sz +:= 1
      link
   end

   #
   # Insert the contents of another `DoublyLinkedList` at position
   # `i`.  Afterwards, `other` is empty.
   #
   # Example :-
   # ~
   #   l := DoublyLinkedList(10,20,30,40)
   #   m := DoublyLinkedList(96,97,98) 
   #   l.splice(3, m)
   #   # Now l is (10,20,96,97,98,30,40)
   #   # and m is empty.
   # ~
   #
   public splice(i, other)
      need_instance(other, DoublyLinkedList)
      i := cvpos(i, sz) | fail
      if i = 1 then {
         if sz = 0 then {
            nhead := other.nhead
            ntail := other.ntail
            sz := other.sz
            other.clear()
         } else
            splice_before_node(nhead, other)
      } else
         splice_after_node(node_at(i - 1), other)
      link
   end

   package splice_before_node(n, other)
      need_instance(other, DoublyLinkedList)
      if other.sz > 0 then {
         if (\n.prev).nxt := other.nhead then
            other.nhead.prev := n.prev
         else
            nhead := other.nhead
         n.prev := other.ntail
         other.ntail.nxt := n
         sz +:= other.sz
         other.clear()
      }
      link
   end

   package splice_after_node(n, other)
      need_instance(other, DoublyLinkedList)
      if other.sz > 0 then {
         if (\n.nxt).prev := other.ntail then
            other.ntail.nxt := n.nxt
         else
            ntail := other.ntail
         n.nxt := other.nhead
         other.nhead.prev := n
         sz +:= other.sz
         other.clear()
      }
      link
   end

   public override delete(i)
      link delete_node(node_at(i))
   end

   package delete_node(n)
      (if /n.prev then nhead else n.prev.nxt) := n.nxt
      (if /n.nxt then ntail else n.nxt.prev) := n.prev
      n.prev := n.nxt := &null
      sz -:= 1
      mod()
      link
   end

   public override at(i)
      return node_at(i).val
   end

   public override size()
      return .sz
   end

   public override gen_from(i)
      local n
      n := node_at(i) | fail
      while \n do {
         suspend n.val
         n := n.nxt
      }
   end

   public override back_from(i)
      local n
      i := need_integer(i)
      n := node_at(i - 1) | fail
      while \n do {
         suspend n.val
         n := n.prev
      }
   end

   #
   # Remove the elements in the range `i:j` and return them as another
   # `DoublyLinkedList` instance.
   #
   # Example :-
   # ~
   #   l := DoublyLinkedList(10,20,30,40,50,60,70)
   #   m := l.extract(2, 5)
   #   # Now l is (10,50,60,70)
   #   # and m is (20,30,40)
   # ~
   #
   public extract(i, j)
      local s, m, n, c
      s := cvslice(i, j, size()) | fail
      c := s.hi - s.lo
      if c > 0 then {
         m := node_at(s.lo)
         n := node_at(s.hi - 1)
         if m === nhead then {
            if n === ntail then
               nhead := ntail := &null
            else {
               nhead := n.nxt
               nhead.prev := n.nxt := &null
            }
         } else {
            if n === ntail then {
               ntail := m.prev
               ntail.nxt := m.prev := &null
            } else {
               m.prev.nxt := n.nxt
               n.nxt.prev := m.prev
               m.prev := n.nxt := &null
            }
         }
         sz -:= c
         mod()
      }
      return from_nodes(m, n, c)
   end

   private static from_nodes(h, t, sz)
      local i
      i := Class.create_instance()
      i.nhead := h
      i.ntail := t
      i.sz := sz
      i.ver := 0
      return i
   end

   public override get_mode()
      return MODIFY + INSERT + DELETE
   end

   #
   # Return a `DoublyLinkedListNodeRef` reference to the node
   # containing element `i`, or fail if `i` is out of range.
   #
   public ref(i)
      return DoublyLinkedListNodeRef(self, ver, node_at(i))
   end

   private node_at(i)
      local n
      i := cvpos_item(i, sz) | fail
      if i < sz / 2 then {
         n := nhead
         while \n & i > 1 do {
            n := n.nxt
            i -:= 1
         }
      } else {
         n := ntail
         i := sz - i + 1
         while \n & i > 1 do {
            n := n.prev
            i -:= 1
         }
      }
      return \n
   end

   #
   # Create an instance and add each of the given entries.
   #
   public new(entries[])
      ver := sz := 0
      every insert(1, default.back(entries))
      return
   end
end

# A convenient equivalent to wrapping a BuiltinList in an
# UnmodifiableList.
#
class UnmodifiableBuiltinList(List)
   private const l

   public override at(i)
      return .l[i]
   end

   public override keyof(x)
      suspend default.keyof(l, x)
   end

   public override gen()
      suspend .!l
   end

   public override back()
      suspend .default.back(l)
   end

   public override slice(i, j)
      return l[i:j]
   end

   public override size()
      return *l
   end

   public override random()
      return .?l
   end

   public override get_mode()
      return 0
   end

   public new(l)
      self.l := need_list(l)
      return
   end
end

#
# This class provides a view of a sublist of another `List`.  No data is
# stored directly in this list.
#
# The indices specified in the constructor use Icon list slice
# semantics, and may be zero or negative.  The indices remain
# constant, and the actual range into the underlying list is
# calculated dynamically.  Should this become out-of-range, then the
# sub-list's size is zero, and insert and delete operations fail.
#
# Example :-
# ~
#   ll := LinkedList(1,2,3,4,5)
#   # A view of the elements 3:0 of ll (3, 4, 5)
#   s := SubList(ll, 3, 0)
#   # After this s is (3, 4, 5, 99); note how the length is now 4.
#   s.put(99)
# ~
#
class SubList(List)
   private const other, lo, hi

   public override insert(i, x)
      local s
      s := cvslice() | fail
      i := cvpos(i, s.hi - s.lo) | fail
      link other.insert(i + s.lo - 1, x)
   end

   public override delete(i)
      local s
      s := cvslice() | fail
      i := cvpos_item(i, s.hi - s.lo) | fail
      link other.delete(i + s.lo - 1)
   end

   public override at(i)
      local s
      s := cvslice() | fail
      i := cvpos_item(i, s.hi - s.lo) | fail
      return other.at(i + s.lo - 1)
   end

   public override size()
      local s
      return if s := cvslice() then
         s.hi - s.lo
      else
         0
   end

   public override gen_from(i)
      local s
      s := cvslice() | fail
      i := cvpos_item(i, s.hi - s.lo) | fail
      i +:= s.lo - 1
      suspend other.gen_from(i) \ (s.hi - i)
   end

   public override back_from(i)
      local s
      s := cvslice() | fail
      i := cvpos(i, s.hi - s.lo) | fail
      i +:= s.lo - 1
      suspend other.back_from(i) \ (i - s.lo)
   end

   private cvslice()
      return util.cvslice(lo, hi, other.size())
   end

   public override get_mode()
      return other.mode()
   end

   #
   # Create a new instance using `other` as the underlying list, and
   # `lo` and `hi` as the slice to view.
   #
   public new(other, lo, hi)
      self.other := need_instance(other, List)
      self.lo := need_integer(lo)
      self.hi := need_integer(hi)
      return
   end
end
