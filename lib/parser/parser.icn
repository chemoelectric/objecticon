package parser

import util, io

class ErrorDetail()
   public const src, line, msg

   # Does the same as abbreviate() in tmain.c
   private abbreviate(name)
      local l
      l := Files.get_path(name).get(-1)
      return if Files.access(name, Access.R_OK) then {
         if Files.get_path(l).canonical().str() == name then
            l
         else
            name
      } else
      l
   end

   #
   # Produce a string version of the message in the same form
   # as produced by the compiler.
   #
   public str()
      local s
      s := "Line " || line || " # " || msg
      if \src then
         s := "File " || abbreviate(src) || "; " || s
      return s
   end

   package final new(src, line, msg)
      self.src := src
      self.line := line
      self.msg := msg
      return
   end
end

class Parser(Connectable)
   private
      first_err, pp, lex, yy

   public static const 
      PREPROCESSOR_ERROR_EVENT, 
      LEXER_ERROR_EVENT,
      PARSER_ERROR_EVENT

   private static init()
      PREPROCESSOR_ERROR_EVENT := "preprocessor error"
      LEXER_ERROR_EVENT := "lexer error"
      PARSER_ERROR_EVENT := "parser error"
   end

   public new()
      cast(self,Connectable).new()
      pp := Preprocessor().
         set_error(pperror)
      lex := Lex().
         set_error(lxerror)
      yy := YY().
         set_error(yyerror)
      return
   end

   public parse(s, encoding)
      local yyval
      first_err := &null
      # Because we don't have the pp-generated # at the top of the file we start
      # at line 1 not line 0, and also in the given encoding.
      yyval := yy.yyparse(create lex.yylex(s,, encoding, 1))
      if \first_err then
         return error(first_err)
      return Prog(yyval)
   end

   #
   # Parse {s}, as an expression (actually, a compound expression).
   #
   public parse_expression(s, encoding)
      s := "procedure main() ; " || s || " end"
      return parse(s, encoding).get_body().get(1).get_body_node()
   end

   public parse_file(fname, predefined_syms)
      local s, yyval
      first_err := &null
      s := pp.preprocess(fname, predefined_syms)
      if \first_err then
         return error(first_err)
      yyval := yy.yyparse(create lex.yylex(s))
      if \first_err then
         return error(first_err)
      return Prog(yyval)
   end

   private yyerror(s, token)
      local ed
      ed := ErrorDetail(token.filename, token.line, image(token.s) || ": " || s)
      fire(PARSER_ERROR_EVENT, ed)
      /first_err := ed.str()
      return
   end

   private lxerror(msg, filename, line)
      local ed
      ed := ErrorDetail(filename, line, msg)
      fire(LEXER_ERROR_EVENT, ed)
      /first_err := ed.str()
      return
   end

   private pperror(msg, filename, line)
      local ed
      ed := ErrorDetail(filename, line, msg)
      fire(PREPROCESSOR_ERROR_EVENT, ed)
      /first_err := ed.str()
      return
   end
end
