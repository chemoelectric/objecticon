#SRC: JCON
#  I/O test -- writes ./tmp1 and ./tmp2 as well as stdout

$include "posix.icn"

import io


procedure main()
   local L, f, m, n, t1, t2

   L := [&input, &output, &errout,
   	m := open("/etc/motd"), n := open("/dev/null", "w")]
   L := sort(L)
   every f := !L do
      write(type(f), ": ", image(f))

   write()
   write(read())
   write(read())
   while write(read()) do break
   write(|read())
   every write(|read() \ 2)
   every write(|read()) \ 2

   write()
   write("flush /etc/motd: ", image(m.flush()) | "FAILED")
   write("close /etc/motd: ", image(m.close()) | "FAILED")
   write("close /etc/motd: ", image(m.close()) | "FAILED")
   write("flush /etc/motd: ", image(m.flush()) | "FAILED")

   write()
   write("flush /dev/null: ", image(n.flush()) | "FAILED")
   write("close /dev/null: ", image(n.close()) | "FAILED")
   write("close /dev/null: ", image(n.close()) | "FAILED")
   write("flush /dev/null: ", image(n.flush()) | "FAILED")

   every remove("tmp1" | "tmp2")
   every remove("tmp1" | "tmp2")
   write(image(open("tmp1")))		# should fail

   write()
   rfile("/dev/null")
   wfile("tmp1", "w", "follow the yellow brick road")
   rfile("tmp1")
   wfile("tmp1", "w", "shorter file")
   rfile("tmp1")
   wfile("tmp1", "a", "gets extended")
   rfile("tmp1")
   wfile("tmp1", "rw", "changed")
   rfile("tmp1")
   wfile("tmp1", "b", "mode b ")
   rfile("tmp1")
   wfile("tmp1", "crw", "cleared anew")
   rfile("tmp1")
   rename("tmp1", "tmp2")
   rfile("tmp2")

   write()
   write(image(t1 := open("tmp1", "w")) | "can't open tmp1")
   write(image(t2 := open("tmp2", "w")) | "can't open tmp2")
   writes(">stdout", t1, ">1a", t2, ">2a", FileStream.b_stdout)
   writes(">stdout", t2, ">2b", t1, ">1b", FileStream.b_stdout)
   write(">stdout", t1, ">1c", t2, t2, ">2c", FileStream.b_stdout)
   write(">stdout", t2, ">2d", t1, t1, ">1d", FileStream.b_stdout)
   every write(t1 | t2)
   writes(t1, ">1e")
   writes(t2, ">2e")
   write(t1, ">1f")
   write(t2, ">2f")
   every (t1 | t2).close()
   rfile("tmp1")
   rfile("tmp2")

   every remove("tmp1" | "tmp2")
   every remove("tmp1" | "tmp2")

   write()
   writes("abc")
   writes("def\nghi")
   writes("\njklmno\n")
   write("pqr\nstu")
   writes("vwxyz")
   writes()
   writes("")
   writes("\n")

   write()
   tsys("echo hello world")			# simple echo
   tsys("ls io.[ids][tca][dnt]")		# check wildcarding

   tpipe()

end



#  wfile(name, mode, s) -- break apart string and write file

procedure wfile(name, mode, s)
   local f

   write()
   writes("write ", name, ",", mode, ":\t ")
   if f := open(name, mode) then s ? {
      writes(s)
      tab(many(' '))
      while not pos(0) do {
	 write(f, tab(upto(' ') | 0))
	 tab(many(' '))
         }
      write(" : ", f.tell())
      f.flush()
      f.close()
      }
   else {
      write("can't open")
      }
   return
end



#  rfile(name) -- read and echo file contents (several different ways)

procedure rfile(name)
   local f, i

   writes("read  ", name, ":\t")
   if not (f := open(name, "r")) then {
      write(" can't open")
      fail
      }

   # read()
   while writes(" ", read(f))
   write()

   # bang
   f.seek(1)
   every writes(" ", "  !f:\t\t" | |read(f) | "\n")

   # both, mixed
   f.seek(1)
   writes("   read/!f:\t")
   while writes(" ", read(f)) do writes(" ", |read(f))
   write()

   # reads()
   f.seek(1)
   writes("   reads():\t")
   while writes(" ", map(f.reads(5), "\n", "."))
   write()

   # nonsequential
   writes("   nonseq:\t ")
   every i := 30 to -30 by -1 do
      if f.seek(i) then
	 writes(map(f.reads(1), "\n", ".") | "?")
      else
	 writes("-")
   write()

   f.close()
   return
end


#  tsys(s) -- test system call

procedure tsys(s)
   write("$ ", s)
   system(s)
   return
end


#  tpipe() -- test pipes

procedure tpipe()
   local p

   # very simple case
   write()
   p := ProgStream.open("echo hello world", O_RDONLY) | stop("can't open echo pipe")
   write(image(p))
   while write("> ", read(p))
   close(p)

   # check unclosed pipe
   write()
   p := ProgStream.open("sed 's/^/=()= /' io.icn", O_RDONLY) | stop("can't open od pipe")
   write(image(p))
   every 1 to 10 do write("> ", read(p))
   # p is deliberately left unclosed

   # check wildcarding, and also !pipe
   write()
   p := ProgStream.open("ls io.i?n io.d?t io.s?d", O_RDONLY) | stop("can't open ls pipe")
   write(image(p))
   every write("> ", |read(p))
   close(p)

   # check output pipe
   write()
   p := ProgStream.open("tr aeiou oaeui", O_WRONLY) | stop("can't open tr pipe")
   write(image(p))
   write(p, "once upon a midnight dreary")
   write(p, "two roads diverged in a yellow wood")
   write(p, "and the mome raths outgrabe")
   write("--- closing output pipe")
   close(p)
   write("--- done closing output pipe")
   remove("tmp1")

   return
end
