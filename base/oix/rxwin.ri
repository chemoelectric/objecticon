/*
 * File: rxwin.ri - X11 system-specific graphics interface code.
 */

#ifdef Graphics

#define RootState IconicState+1
#define CONVERT_ANGLE(ang) (-(ang) * 180 / Pi * 64)

/*
 * Global variables specific to X
 */
wdp wdsplys;

/*
 * function prototypes
 */
static wcp alccontext(wbp w);
static wsp alcwinstate(void);
static int handle_misc(wdp display);
static int handle_config(wbp w, XConfigureEvent *event);
static int handle_exposures(wbp w, XExposeEvent *event);
static void handle_mouse(wbp w, XButtonEvent *event);
static void handle_keypress(wbp w, XKeyEvent *event);
static int setpatternbits(wbp w, int width, int *bits, int nbits);
static int wmap(wbp w);
static int convert_KeySym_to_code_point(KeySym k);
#ifdef HAVE_LIBXFT
int xft_stringwidth(wbp w, char *s, int n);
static char *convert_spec(char *s);
#else
static wfp findfont(wbp w, char *fam, int size, int flags);
static int okfont(char *spec, int size, int flags);
static int fontcmp(char *font1, char *font2, int size, int flags);
static int fieldcmp(char *font1, char *font2, char *value, int field);
static char *xlfd_field(char *s, int i);
static int xlfd_size(char *s, int n);
#endif
static wfp loadfont(wdp wd, char *s);
static wdp alcdisplay (char *s);
static void free_display   (wdp wd);
static wfp alcfont(wbp w, char *s);
static wfp tryfont(wbp w, char *s);
static void resizePixmap(wbp w, int width, int height);
static void setclip(wbp w);
static void unsetclip(wbp w);


#define DEFAULTFONTNAME "fixed"

static stringint fillstyles[] = {
    {0, 7},
    {"masked", FillStippled },
    {"opaquepatterned", FillOpaqueStippled },
    {"opaquestippled", FillOpaqueStippled },
    {"patterned", FillStippled },
    {"solid", FillSolid },
    {"stippled", FillStippled },
    {"textured", FillOpaqueStippled },
};

static stringint drawops[] = {
   { 0, 16},
   {"and",		GXand},
   {"andInverted",	GXandInverted},
   {"andReverse",	GXandReverse},
   {"clear",		GXclear},
   {"copy",		GXcopy},
   {"copyInverted",	GXcopyInverted},
   {"equiv",		GXequiv},
   {"invert",		GXinvert},
   {"nand",		GXnand},
   {"noop",		GXnoop},
   {"nor",		GXnor},
   {"or",		GXor},
   {"orInverted",	GXorInverted},
   {"orReverse",	GXorReverse},
   {"set",		GXset},
   {"xor",		GXxor},
};

static stringint linestyles[] = {
    {0, 5},
    {"dashed",      LineOnOffDash},
    {"doubledash",  LineDoubleDash},
    {"onoff",       LineOnOffDash},
    {"solid",       LineSolid},
    {"striped",     LineDoubleDash},
};

#define NUMCURSORSYMS	78

static stringint cursors[] = {
  { 0, NUMCURSORSYMS},
  {"X cursor",		XC_X_cursor},
  {"arrow",		XC_arrow},
  {"based arrow down",	XC_based_arrow_down},
  {"based arrow up",	XC_based_arrow_up},
  {"boat",		XC_boat},
  {"bogosity",		XC_bogosity},
  {"bottom left corner",XC_bottom_left_corner},
  {"bottom right corner",XC_bottom_right_corner},
  {"bottom side",	XC_bottom_side},
  {"bottom tee",	XC_bottom_tee},
  {"box spiral",	XC_box_spiral},
  {"center ptr",	XC_center_ptr},
  {"circle",		XC_circle},
  {"clock",		XC_clock},
  {"coffee mug",	XC_coffee_mug},
  {"cross",		XC_cross},
  {"cross reverse",	XC_cross_reverse},
  {"crosshair",		XC_crosshair},
  {"diamond cross",	XC_diamond_cross},
  {"dot",		XC_dot},
  {"dotbox",		XC_dotbox},
  {"double arrow",	XC_double_arrow},
  {"draft large",	XC_draft_large},
  {"draft small",	XC_draft_small},
  {"draped box",	XC_draped_box},
  {"exchange",		XC_exchange},
  {"fleur",		XC_fleur},
  {"gobbler",		XC_gobbler},
  {"gumby",		XC_gumby},
  {"hand1",		XC_hand1},
  {"hand2",		XC_hand2},
  {"heart",		XC_heart},
  {"icon",		XC_icon},
  {"iron cross",	XC_iron_cross},
  {"left ptr",		XC_left_ptr},
  {"left side",		XC_left_side},
  {"left tee",		XC_left_tee},
  {"leftbutton",	XC_leftbutton},
  {"ll angle",		XC_ll_angle},
  {"lr angle",		XC_lr_angle},
  {"man",		XC_man},
  {"middlebutton",	XC_middlebutton},
  {"mouse",		XC_mouse},
  {"pencil",		XC_pencil},
  {"pirate",		XC_pirate},
  {"plus",		XC_plus},
  {"question arrow",	XC_question_arrow},
  {"right ptr",		XC_right_ptr},
  {"right side",	XC_right_side},
  {"right tee",		XC_right_tee},
  {"rightbutton",	XC_rightbutton},
  {"rtl logo",		XC_rtl_logo},
  {"sailboat",		XC_sailboat},
  {"sb down arrow",	XC_sb_down_arrow},
  {"sb h double arrow",	XC_sb_h_double_arrow},
  {"sb left arrow",	XC_sb_left_arrow},
  {"sb right arrow",	XC_sb_right_arrow},
  {"sb up arrow",	XC_sb_up_arrow},
  {"sb v double arrow",	XC_sb_v_double_arrow},
  {"shuttle",		XC_shuttle},
  {"sizing",		XC_sizing},
  {"spider",		XC_spider},
  {"spraycan",		XC_spraycan},
  {"star",		XC_star},
  {"target",		XC_target},
  {"tcross",		XC_tcross},
  {"top left arrow",	XC_top_left_arrow},
  {"top left corner",	XC_top_left_corner},
  {"top right corner",	XC_top_right_corner},
  {"top side",		XC_top_side},
  {"top tee",		XC_top_tee},
  {"trek",		XC_trek},
  {"ul angle",		XC_ul_angle},
  {"umbrella",		XC_umbrella},
  {"ur angle",		XC_ur_angle},
  {"watch",		XC_watch},
  {"xterm",		XC_xterm},
  {"num glyphs",	XC_num_glyphs},
};


static int selection_debug = 0;

static struct SharedColor *new_sharedcolor(char *name, int r, int g, int b)
{
    struct SharedColor *res;
    GRFX_ALLOC(res, SharedColor);
    res->r = r;
    res->g = g;
    res->b = b;
    res->c = ((r/257)<<16) | ((g/257)<<8) | (b/257);
    res->name = salloc(name);
    return res;
}

static struct SharedColor *link_sharedcolor(struct SharedColor *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedcolor(struct SharedColor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        free(x->name);
        free(x);
    }
}

static char *atom_fmt(wsp ws,Atom a) {
    static int n = 0;
    static char buff[8][96];
    char *s, *r;
    r = buff[n];
    if (a == None)
        return "None(0)";

    s = XGetAtomName(ws->display->display, a);
    if (s) {
        sprintf(r, "%.64s(%ld)", s, (long)a);
        XFree(s);
    } else {
        sprintf(r, "?unknown atom(%ld)", (long)a);
    }

    n = (n + 1) % 8;
    return r;
}

/*
 * Get the string name of the given Atom into dest.  The string is
 * allocated in the string region.
 */
void get_atom_descriptor(wsp ws, Atom a, dptr dest)
{
    char *s = XGetAtomName(ws->display->display, a);
    cstr2string(s, dest);
    XFree(s);
}

Atom ConvertTarget(Display* display, Atom desired_target)
{
    /* Check for common cases. */
    if ( (desired_target == XInternAtom(display, "TIMESTAMP", False))    ||
         (desired_target == XInternAtom(display, "LIST_LENGTH", False) ) ||
         (desired_target == XInternAtom(display, "LENGTH", False) ) ) {
        return XA_INTEGER;
    }

    if ( desired_target == XInternAtom(display, "CHARACTER_POSITION", False) ) {
        return XInternAtom(display, "SPAN", False);
    }

    if ( desired_target == XInternAtom(display, "TARGETS", False) ) {
        return XA_ATOM;
    }

    if ( desired_target == XInternAtom(display, "CLIENT_WINDOW", False) ) {
        return XA_WINDOW;
    }

    if (( desired_target == XInternAtom(display, "HOST_NAME", False) ) ||
        ( desired_target == XInternAtom(display, "HOSTNAME", False) ) ||
        ( desired_target == XInternAtom(display, "NAME", False) ) ||
        ( desired_target == XInternAtom(display, "OWNER_OS", False) ) ||
        ( desired_target == XInternAtom(display, "USER", False) ) ) {
        return XA_STRING;
    }
    /* Otherwise, no need to convert target. */
    return desired_target;
}

char* PropertyToString(Display* display, Atom target, int number_items,
                       void* data)
{
    Atom            new_target;
    Atom            timestamp, span;
    unsigned long*  long_array;
    int*            int_array;
    char*           string0 = NULL;
    int             i, length;
    char            temp[100];
    char*           atom_name;

    /* Convert our atoms. */
    timestamp = XInternAtom(display, "TIMESTAMP", False);
    span      = XInternAtom(display, "SPAN", False);

    /* Convert target, if necessary. */
    new_target = ConvertTarget(display, target);

    if (new_target == XA_ATOM) {

        long_array = (unsigned long*) data;

        length = number_items * 30;
        MemProtect(string0 = malloc( length + 1 ));
        string0[0] = '\0';

        /* Convert to atom names. */
        for (i = 0; i < number_items; i++) {
            atom_name = XGetAtomName(display, long_array[i] );

            if (atom_name != NULL) {

                /* Check that space is available. */
                length -= strlen(atom_name);
 
                if (length > 1) {
                    strcat(string0, atom_name);
                    strcat(string0, "\n");
                }
                XFree(atom_name);
            }
        }
    }
    else if (new_target == XA_STRING) {
        MemProtect(string0 = malloc(number_items + 1));
        strcpy(string0, (char *)data);
    }
    else if ((new_target == XA_INTEGER) ||
             (new_target == span) ||
             (new_target == timestamp) ) {

        int_array = (int*) data;

        length = number_items * 20;
        MemProtect(string0 = malloc( length + 1 ));
        string0[0] = '\0';

        for (i = 0; i < number_items; i++) {
            sprintf(temp, "%d ", int_array[i]);

            /* Check that space is available. */
            length -= strlen(temp);
            if (length > 0) {
                strcat(string0, temp);
            }
        }
    }
    else if (new_target == XA_WINDOW) {

        long_array = (unsigned long*) data;

        length = number_items * 12;
        MemProtect(string0 = malloc( length + 1 ));
        string0[0] = '\0';

        for (i = 0; i < number_items; i++) {
            sprintf(temp, "0x%8.8lu ", long_array[i]);
            strcat(string0, temp);
        }

    }
    else {
        /* Add extra cases as necessary... */
    }

    return string0;

}

/*
 * Function to append data to an X property.
 */

static int     ErrorFlag = False;
static int     LastError = None;

#define BUFSIZE     1024

#define NUMBER_ERRORS   18

char*  ErrorCodes[ NUMBER_ERRORS ] = {
    "Success",           /* 0  */
    "BadRequest",        /* 1  */
    "BadValue",          /* 2  */
    "BadWindow",         /* 3  */
    "BadPixmap",         /* 4  */
    "BadAtom",           /* 5  */
    "BadCursor",         /* 6  */
    "BadFont",           /* 7  */
    "BadMatch",          /* 8  */
    "BadDrawable",       /* 9  */
    "BadAccess",         /* 10 */
    "BadAlloc",          /* 11 */
    "BadColor",          /* 12 */
    "BadGC",             /* 13 */
    "BadIDChoice",       /* 14 */
    "BadName",           /* 15 */
    "BadLength",         /* 16 */
    "BadImplementation"  /* 17 */
};


static void ErrorHandler(Display* display, XErrorEvent* error_event)
{   
    char string0[BUFSIZE + 1];

    ErrorFlag = True;
    LastError = (int) error_event->error_code;

    /* Find out the error message and print it. */
    XGetErrorText(display, error_event->error_code, string0, BUFSIZE);

    fprintf(stderr, "X Error on display %s.i\nResource %ld:  ",
            DisplayString( display ), error_event->resourceid );

    if ((error_event->error_code > 0 ) && 
        (error_event->error_code < NUMBER_ERRORS ) ) {

        fprintf( stderr, "%s (%s).\n", string0,
                 ErrorCodes[ error_event->error_code ] );
    }
    else {
        fprintf( stderr, "%s.\n", string0 );
    }

    fprintf(stderr, "Op code %d.%d, Error code %d\n", error_event->request_code,
            error_event->minor_code, error_event->error_code );
}


void ResetErrorFlag()
{  
    ErrorFlag = False;
    LastError = None;
}

void SetErrorHandler()
{   
    (void) XSetErrorHandler((XErrorHandler) ErrorHandler);
}

/*
 * handle_misc processes pending events on display.
 * if w is non-null, block until a returnable event arrives.
 * returns 1 on success, 0 on failure.
 */
static int handle_misc(wdp wd)
{
    XEvent event;
    Window evwin;
    static int presscount = 0;
    wbp wb;
    wsp ws = 0;

    while (XPending(wd->display)) {

        XNextEvent(wd->display, &event);
        evwin = event.xexpose.window;  /* go ahead, criticize all you like */

/* could avoid doing this search every event by handling 1 window at a time */
        for (wb = wbndngs; wb; wb=wb->next) {
            ws = wb->window;
            if (ws->display == wd) {
                if (ws->win == evwin) break;
                if (ws->pix == evwin) break;
	    }
        }
        if (!wb) continue;

        switch (event.type) {
            case SelectionRequest: {
                tended struct descrip tmp;
                if (selection_debug)
                    printf("SelectionRequest event:\n\towner=%lx requestor=%lx "
                           "property=%s target=%s selection=%s\n",
                           (long)event.xselectionrequest.owner,
                           (long)event.xselectionrequest.requestor,
                           atom_fmt(ws, event.xselectionrequest.property),
                           atom_fmt(ws, event.xselectionrequest.target),
                           atom_fmt(ws, event.xselectionrequest.selection)
                        );

                MakeInt(SELECTIONREQUEST, &tmp);
                list_put(&ws->listp, &tmp);
                MakeInt((word)event.xselectionrequest.requestor, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselectionrequest.property, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselectionrequest.selection, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselectionrequest.target, &tmp);
                list_put(&ws->listp, &tmp);
                MakeInt(event.xselectionrequest.time, &tmp);
                list_put(&ws->listp, &tmp);
                break;
            }

            case SelectionClear: {
                tended struct descrip tmp;
                if (selection_debug)
                    printf("SelectionClear event win=%lx selection=%s\n",
                           (long)event.xselectionclear.window,
                           atom_fmt(ws, event.xselectionclear.selection));
                MakeInt(SELECTIONCLEAR, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselectionclear.selection, &tmp);
                list_put(&ws->listp, &tmp);
                break;
            }

            case SelectionNotify: {
                Atom actual_type, property;
                int actual_format;
                unsigned long bytes_after, nitems;
                unsigned char *prop;
                word bytes_read;
                tended struct descrip tmp;
                int status;
                char *conv_str;

                if (selection_debug)
                    printf("SelectionNotify: requestor=%lx selection=%s target=%s property=%s\n",
                           (long)event.xselection.requestor,
                           atom_fmt(ws, event.xselection.selection),
                           atom_fmt(ws, event.xselection.target),
                           atom_fmt(ws, event.xselection.property));

                MakeInt(SELECTIONRESPONSE, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselection.selection, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselection.target, &tmp);
                list_put(&ws->listp, &tmp);

                if (event.xselection.property == None) {
                    if (selection_debug)
                        printf("XGetWindowProperty xselection.property == None\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                property = XInternAtom(ws->display->display, "_OBJECTICON_PROP", False);

                status = XGetWindowProperty(ws->display->display,
                                            ws->win,
                                            property,
                                            0,
                                            8192,   /* Means we won't get back > 32kb of stuff */
                                            True,
                                            AnyPropertyType,
                                            &actual_type,
                                            &actual_format,
                                            &nitems,
                                            &bytes_after,
                                            &prop);

                if (status != Success) {
                    if (selection_debug)
                        printf("XGetWindowProperty failed\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                if (actual_type == None) {
                    if (selection_debug)
                        printf("XGetWindowProperty returned actual_type == None\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                /* Shouldn't ever happen */
                if (!prop) {
                    if (selection_debug)
                        printf("XGetWindowProperty set prop to null\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                bytes_read = nitems * (actual_format/8);
                if (selection_debug)
                    printf("Got %lu items x %d bits -> %ld bytes\n",nitems, actual_format, (long)bytes_read);

                conv_str = PropertyToString(ws->display->display,
                                            actual_type,
                                            nitems,
                                            prop);
                if (conv_str) {
                    /* Make an Icon string out of the data */
                    cstr2string(conv_str, &tmp);
                    free(conv_str);
                } else {
                    /* Make an Icon string out of the data */
                    bytes2string((char *)prop, bytes_read, &tmp);
                }
                list_put(&ws->listp, &tmp);

                XFree(prop);
                    
                break;
            }

            case KeyRelease: {
                if (ws->inputmask & KeyReleaseMask) {
                    handle_keypress(wb, (XKeyEvent *)&event);
                }
                break;
            }
            case KeyPress:
                handle_keypress(wb, (XKeyEvent *)&event);
                break;
            case ButtonPress:
                presscount++;
                handle_mouse(wb, (XButtonEvent *)&event);
                break;
            case ButtonRelease:
                if (--presscount < 0) presscount = 0;
                handle_mouse(wb, (XButtonEvent *)&event);
                break;
            case MotionNotify:
                if (presscount || wb->window->inputmask)
                    handle_mouse(wb, (XButtonEvent *)&event);
                break;
            case NoExpose:
                break;
            case Expose:
                if (!handle_exposures(wb, (XExposeEvent *)&event))
                    return 1;
                continue;
            case UnmapNotify:
                wb->window->iconic = IconicState;
                continue;
            case MapNotify:
                if ((ws->width != DisplayWidth(wd->display, wd->screen)) ||
                    (ws->height != DisplayHeight(wd->display, wd->screen)))
                    ws->iconic = NormalState;
                else
                    ws->iconic = MaximizedState;
                continue;
            case ConfigureNotify:
                if (!handle_config(wb, (XConfigureEvent *)&event)) {
                    return 0;
                }
                break;
            case ClientMessage: {
                /*
                 * only client message we handle at present are destroy requests
                 */
                if (event.xclient.data.l[0] == XInternAtom(ws->display->display, 
                                                           "WM_DELETE_WINDOW", False)) {
                    struct descrip d;
                    MakeInt(WINDOWCLOSED, &d);
                    qevent(wb->window, &d, -1, -1, 0, 0, 0);
                    return 1;
                }
                continue;
            }
            case DestroyNotify:
                if (!ISZOMBIE(wb))
                    fatalerr(141, NULL);
                /*
                 * first of all, we are done with this window
                 */
                ws->win = (Window) NULL;

                /*
                 * if there are no more references, we are done with the pixmap
                 *  too.  Free it and the colors allocated for this canvas.
                 */
                if (ws->refcount == 0) {
                    if (wb->window->pix) {
                        Display *d = ws->display->display;
                        XSync(d, False);
                        if (ws->pix)
                            XFreePixmap(d, ws->pix);
                        ws->pix = (Pixmap) NULL;
                    }
#ifdef HAVE_LIBXFT
                    if (ws->pixDraw) {
                        XftDrawDestroy(ws->pixDraw);
                        ws->pixDraw = NULL;
                    }
#endif
                }
                break;
            default:
                continue;
        }
    }
    return 1;
}

/*
 * poll for available events on all opened displays.
 * this is where the interpreter calls into the X interface.
 */
void pollevent()
{
    wdp wd;
    for (wd = wdsplys; wd; wd = wd->next) {
        if (wd->program == curpstate)
            handle_misc(wd);
    }
}

/*
 * wclose - close a window.  If is a real on-screen window,
 * wait for a DestroyNotify event from the server before returning.
 */
void wclose(wbp w)
{
    STDLOCALS(w);

    XSync(stddpy, False);

    pollevent();

    /*
     * Force window to close (turn into a pixmap)
     */
    if (ws->win && ws->refcount > 1) {
        SETZOMBIE(w);
#ifdef HAVE_LIBXFT
        if (ws->winDraw) {
            XftDrawDestroy(ws->winDraw);
            ws->winDraw = NULL;
        }
#endif
        XDestroyWindow(stddpy,stdwin);
        XFlush(stddpy);
        while (ws->win)
            pollevent();
    }
}
/*
 * flush a window
 */
void wflush(wbp w)
{
    STDLOCALS(w);
    XFlush(stddpy);
}
/*
 * flush all windows
 */
void wflushall()
{
    wdp wd;
    for (wd = wdsplys; wd != NULL; wd = wd->next) {
        XFlush(wd->display);
    }
}
/*
 * sync all the servers
 */
void wsync(wbp w)
{
    wdp wd;
    if (w == NULL) {
        for (wd = wdsplys; wd != NULL; wd = wd->next) {
            XSync(wd->display, False);
        }
    }
    else
        XSync(w->window->display->display, False);
}

/*
 * open a window
 */
wbp wcreate(char *display, wbp parent)
{
    wbp w;
    wsp ws;
    w = alcwbinding();
    w->window = alcwinstate();
    if ((w->window->display = alcdisplay(display)) == NULL) {
        LitWhy("Couldn't initialize display structure");
        freewbinding(w);
        return 0;
    }
    ws = w->window;
    ws->vis = DefaultVisual(ws->display->display, ws->display->screen); 
    create_list(64, &ws->listp);

    if (parent)
        ws->transientfor = parent->window->win;

    /*
     * some attributes of the display and window are used in the context
     */
	
    w->context = alccontext(w);

    return w;
}

int wopen(wbp w)
{
    if (wmap(w) != Succeeded) {
        LitWhy("Failed to map window");
        return Failed;
    }
	
    return Succeeded;
}


/*
 * Create a canvas.
 *  If a window, cause the window to actually become visible on the screen.
 *  returns Succeeded, Failed, or Error
 */
static int wmap(wbp w)
{
    XWindowAttributes attrs;
    XGCValues gcv;
    unsigned long gcmask =
        GCFont | GCForeground | GCBackground | GCFillStyle | GCCapStyle;
    struct imgdata *imd;
    int i;
    int new_pixmap = 0;
    struct descrip progname;
    char *p, *s, sbuf[256];
    XWMHints wmhints;
    XClassHint clhints;
    STDLOCALS(w);

    /*
     *  Create a pixmap for this canvas if there isn't one already.
     */
    if (ws->pix == (Pixmap) NULL) {
        ws->pix = XCreatePixmap(stddpy, DefaultRootWindow(stddpy),
                                ws->width, ws->height,
                                DefaultDepth(stddpy,wd->screen));
        ws->pixwidth = ws->width;
        ws->pixheight = ws->height;
        new_pixmap = 1;
        stdpix = ws->pix;
    }

    /*
     * create the X window (or use the DefaultRootWindow if requested)
     */
    if (ws->iconic != HiddenState) {
        Atom WMDeleteWindow;
        XSetWindowAttributes attr;
        attr.background_pixel = wc->bg->c;

        switch (ws->iconic) {
            case RootState:
                ws->win = DefaultRootWindow(stddpy);
                break;
            case PopupState: {
                attr.override_redirect = True;
                ws->win = XCreateWindow(stddpy, DefaultRootWindow(stddpy),
                                        ws->x < 0 ? 0 : ws->x,
                                        ws->y < 0 ? 0 : ws->y, 
                                        ws->width, ws->height, 
                                        0,
                                        DefaultDepth(stddpy,wd->screen),
                                        InputOutput,
                                        CopyFromParent,
                                        CWBackPixel|CWOverrideRedirect,
                                        &attr);
                break;
            }
            default: {
                ws->win = XCreateWindow(stddpy, DefaultRootWindow(stddpy),
                                        ws->x < 0 ? 0 : ws->x,
                                        ws->y < 0 ? 0 : ws->y, 
                                        ws->width, ws->height, 
                                        0,
                                        DefaultDepth(stddpy,wd->screen),
                                        InputOutput,
                                        CopyFromParent,
                                        CWBackPixel,
                                        &attr);
                break;
            }
        }
        if (ws->win == (Window) NULL)
            return Failed;

        /* If the window has a parent, set the WM_TRANSIENT_FOR hint. */
        if (ws->transientfor)
            XSetTransientForHint(stddpy, ws->win, ws->transientfor);

        /* Turn off background; this prevents X filling the background on an expose
           and hence prevents unsightly flicker on a resize. */
        XSetWindowBackgroundPixmap(stddpy, ws->win, None);

        WMDeleteWindow = XInternAtom(ws->display->display, "WM_DELETE_WINDOW", False);
        XSetWMProtocols(ws->display->display, ws->win, &WMDeleteWindow, 1);

        stdwin = ws->win;
        XClearWindow(stddpy, stdwin);
    }

    /*
     * before creating the graphics context, construct a description
     * of any non-default initial graphics context values.
     */
    gcv.foreground = wc->fg->c;
    gcv.background = wc->bg->c;
#ifdef HAVE_LIBXFT
    gcv.font       = wd->xfont->fid;
#else
    gcv.font       = wc->font->fsp->fid;
#endif
    gcv.fill_style = wc->fillstyle->i;
    gcmask |= (GCLineWidth | GCLineStyle);
    gcv.line_width = wc->linewidth;
    gcv.line_style = wc->linestyle->i;
    if (wc->linewidth > 1) {
        gcv.dashes = 3 * wc->linewidth;
        gcmask |= GCDashList;
    }
    gcv.cap_style = CapProjecting;

    /*
     * Create a graphics context (or change an existing one to conform
     * with initial values).
     */
    if (stdgc == NULL) {
        wc->gc = XCreateGC(stddpy, stdpix, gcmask, &gcv);
        stdgc = wc->gc;
        if (stdgc == NULL) return Failed;
    }
    else
        XChangeGC(stddpy, stdgc, gcmask, &gcv);

    if (wc->clipw >= 0)
        setclip(w);

    if (new_pixmap) {
        XSetForeground(stddpy, stdgc, wc->bg->c);
        XFillRectangle(stddpy, ws->pix, stdgc, 0, 0, ws->width, ws->height);
        XSetForeground(stddpy, stdgc, wc->fg->c);
    }

    /* For RootState, need to fill since XClearWindow above fills with a pixmap */
    if (ws->iconic == RootState) {
        XSetForeground(stddpy, stdgc, wc->bg->c);
        XFillRectangle(stddpy, ws->win, stdgc, 0, 0, ws->width, ws->height);
        XSetForeground(stddpy, stdgc, wc->fg->c);
    }

    imd = &ws->initimage;
    if (imd->width) {
        drawimgdata(w, 0, 0, imd);
        freeimgdata(imd);
    }

    if (wc->patternname != NULL) {
        if (setpattern(w, wc->patternname) != Succeeded)
            return Failed;
    }

    /*
     *  if we are opening a pixmap, we are done at this point.
     */
    if (stdwin == (Window) NULL) return Succeeded;

    if (ws->iconic != RootState) {
        XSizeHints size_hints;
        size_hints.flags = PSize | PMinSize | PMaxSize;
        size_hints.width = ws->width;
        size_hints.height= ws->height;
        if (ws->x == -(INT_MAX)) 
            ws->x = 0;
        else
            size_hints.flags |= USPosition;
        if (ws->y == -(INT_MAX)) 
            ws->y = 0;
        else 
            size_hints.flags |= USPosition;
        size_hints.x = ws->x;
        size_hints.y = ws->y;
        if (ISRESIZABLE(w)) {
            size_hints.min_width = ws->minwidth;
            size_hints.min_height = ws->minheight;
            size_hints.max_width = ws->maxwidth;
            size_hints.max_height = ws->maxheight;
        }
        else {
            size_hints.min_width = size_hints.max_width = ws->width;
            size_hints.min_height = size_hints.max_height = ws->height;
        }
        XSetStandardProperties(stddpy, stdwin, ws->windowlabel, ws->windowlabel,
                               0,0,0, &size_hints);
        XSelectInput(stddpy, stdwin, XMasks(ws->inputmask));
    }

    wmhints.input = True;
    wmhints.flags = InputHint;
    if (ws->iconic != RootState) {
        wmhints.flags |= (ws->wmhintflags | StateHint);
        wmhints.initial_state = NormalState;
    }
    XSetWMHints(stddpy, stdwin, &wmhints);

    /*
     * Set the class hints that name the program (for reference by the
     * window manager) following conventions given in O'Reilly.
     */
    cnv:string(kywd_prog, progname);
    if (! (s = getenv("RESOURCE_NAME"))) {
        p = StrLoc(progname);
        s = p + StrLen(progname);
        while (s > p && s[-1] != '/')
            s--;				/* find tail of prog_name */
        clhints.res_name = sbuf;
        clhints.res_class = "IconProg";
        for (i=0; s < p+StrLen(progname); ) clhints.res_name[i++] = *s++;
        clhints.res_name[i] = '\0';
        XSetClassHint(stddpy, stdwin, &clhints);
    }

    if (wd->cmap != DefaultColormap(stddpy,wd->screen)) { /* ? */
        XSetWindowColormap(stddpy, stdwin, wd->cmap);
    }
    XSync(stddpy, False);

    if (ws->iconic != RootState) {
        CLREXPOSED(w);
        XMapWindow(stddpy, stdwin);
    }

    XGetWindowAttributes(stddpy, stdwin, &attrs);
    ws->width = attrs.width;
    ws->height = attrs.height;
    resizePixmap(w, ws->width, ws->height);

    if (stdwin) {
        i = ws->cursor->i >> 1;
        if (!(wd->cursors[i]))
            wd->cursors[i] = XCreateFontCursor(stddpy, 2 * i);
        XDefineCursor(stddpy, stdwin, wd->cursors[i]);
    }

    /*
     * busy loop for an expose event, unless of course we are starting out
     *  in an iconic state
     */
    CLRZOMBIE(w);

    XSetFunction(stddpy, stdgc, wc->drawop->i);
    XSync(stddpy, False);

    return Succeeded;
}

void doconfig(wbp w, int status)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    XTextProperty textprop;

    if (status & C_CLIP) {
        if (wc->clipw >= 0)
            setclip(w);
        else
            unsetclip(w);
    }

    if (status & (C_POS | C_SIZE | C_MINSIZE | C_MAXSIZE | C_RESIZE)) {
        resizePixmap(w, ws->width, ws->height);

        if (ws->win) {
            if (status != C_POS) {
                XSizeHints size_hints;
                long t;

                /* Not just a move */

                XGetWMNormalHints(wd->display, ws->win, &size_hints, &t);
                if (ISRESIZABLE(w)) {
                    size_hints.min_width = ws->minwidth;
                    size_hints.min_height = ws->minheight;
                    size_hints.max_width = ws->maxwidth;
                    size_hints.max_height = ws->maxheight;
                }
                else {
                    size_hints.min_width = size_hints.max_width = ws->width;
                    size_hints.min_height = size_hints.max_height = ws->height;
                }
                XSetWMNormalHints(wd->display, ws->win, &size_hints);
            }

            switch (status & (C_POS|C_SIZE)) {
                case C_POS: {
                    XMoveWindow(wd->display, ws->win, ws->x, ws->y);
                    break;
                }
                case C_SIZE: {
                    XResizeWindow(wd->display, ws->win, ws->width, ws->height);
                    break;
                }
                case C_POS|C_SIZE: {
                    XMoveResizeWindow(wd->display, ws->win, ws->x, ws->y, ws->width, ws->height);
                    break;
                }
            }
            /* XSync is not enough because the window manager gets involved here. */
            XFlush(wd->display);			      /* force out request */
            XGetWMName(wd->display, ws->win, &textprop);    /* force WM round trip */
            XSync(wd->display, False);		      /* NOW sync */
        }
    }

    if (status & C_IMAGE) {
        struct imgdata *imd = &ws->initimage;
        if (imd->width) {
            drawimgdata(w, 0, 0, imd);
            freeimgdata(imd);
        }
    }
}

/*
 * Note that the three strings are pointers into the string space;
 * data is a safe pointer into a frame.
 */
int sendselectionresponse(wbp w, word requestor, char *property, char *selection, char *target, word time, dptr data)
{
    Atom property_atom, target_atom, selection_atom, XA_TARGETS, target_list[32];
    XEvent theevent;
    struct lgstate state;
    tended struct b_lelem *le;
    tended char *cstr_target;
    int target_cnt = 1;
    STDLOCALS(w);

    if (selection_debug)
        printf("sendselectionresponse:\n\trequestor=%lx "
               "property=%s target=%s selection=%s time=%ld\n",
               (long)requestor, property, target, selection, (long)time);

    property_atom = XInternAtom(ws->display->display, property, False);
    target_atom = XInternAtom(ws->display->display, target, False);
    selection_atom = XInternAtom(ws->display->display, selection, False);
    XA_TARGETS = XInternAtom(ws->display->display, "TARGETS", False);

    if (target_atom == XA_TARGETS) {
        if (!is:list(*data))
            ReturnErrVal(108, *data, Error);
        target_list[0] = XA_TARGETS;
        for (le = lgfirst(&ListBlk(*data), &state); le;
             le = lgnext(&ListBlk(*data), &state, le)) {
            if (!cnv:C_string(le->lslots[state.result], cstr_target))
                ReturnErrVal(148, le->lslots[state.result], Error);
            target_list[target_cnt++] = XInternAtom(ws->display->display, cstr_target, False);
            if (selection_debug)
                printf("\tAdding target:%s\n", cstr_target);
        }
        XChangeProperty(ws->display->display,
                        requestor,
                        property_atom,
                        target_atom,
                        32,
                        PropModeReplace,
                        (unsigned char *)target_list,
                        target_cnt);
        theevent.xselection.property = property_atom;
    } else if (is:null(*data)) {
        /* Can't handle this target type */
        if (selection_debug)
            printf("\tSetting property to None\n");
        theevent.xselection.property = None;
    } else {
        if (!cnv:string(*data, *data))
            ReturnErrVal(103, *data, Error);
        if (selection_debug)
            printf("\tSetting property to %d bytes of data\n", (int)StrLen(*data));
        XChangeProperty(ws->display->display,
                        requestor,
                        property_atom,
                        target_atom,
                        8,
                        PropModeReplace,
                        (unsigned char *)StrLoc(*data),
                        StrLen(*data));
        theevent.xselection.property = property_atom;
    }

    theevent.type = SelectionNotify;
    theevent.xselection.serial = 0; /*event.xselectionrequest.serial;*/
    theevent.xselection.send_event = True;
    theevent.xselection.requestor = requestor;
    theevent.xselection.selection = selection_atom;
    theevent.xselection.target = target_atom;
    theevent.xselection.time = time;

    XSendEvent(ws->display->display,
               requestor,
               False, NoEventMask, &theevent);

    return Succeeded;
}

int ownselection(wbp w, char *selname)
{
    Atom selection;
    Window curr;
    {
    STDLOCALS(w);

    selection = XInternAtom(ws->display->display, selname, False);

    curr = XGetSelectionOwner(ws->display->display, selection);
    /* Check for no change in selection */
    if (curr == ws->win)
        return Succeeded;

    if (selection_debug)
        printf("Owner of selection %s set from %lx -> %lx\n", 
               atom_fmt(ws, selection),
               (long)curr,
               (long)ws->win);

    /*
     * X doesn't send a SelectionClear event to us when the selection
     * changes between our own windows, so if the current owner is one
     * our windows, send it a "clear" message.
     */
    if (curr) {
        wsp x;
        for (x = wstates; x; x = x->next) {
            if (x->win == curr) {
                tended struct descrip tmp;
                if (selection_debug)
                    printf("Enqueueing artificial SELECTIONCLEAR to current owner %lx\n",(long)curr);
                MakeInt(SELECTIONCLEAR, &tmp);
                list_put(&x->listp, &tmp);
                get_atom_descriptor(x, selection, &tmp);
                list_put(&x->listp, &tmp);
                break;
            }
        }
    }

    XSetSelectionOwner(ws->display->display, 
                       selection,
                       ws->win,
                       CurrentTime);

    return Succeeded;
    }
}

int requestselection(wbp w, char *selname, char *targetname)
{
    Atom selection, property, target;
    STDLOCALS(w);

    selection = XInternAtom(ws->display->display, selname, False);
    property = XInternAtom(ws->display->display, "_OBJECTICON_PROP", False);
    target = XInternAtom(ws->display->display, targetname, False);
    if (selection_debug)
        printf("getselectioncontent: calling XConvertSelection selection=%s target=%s property=%s requestor=%lx\n",
               atom_fmt(ws, selection),
               atom_fmt(ws, target),
               atom_fmt(ws, property),
               (long)ws->win);

    XConvertSelection(ws->display->display,
                      selection, 
                      target, 
                      property, 
                      ws->win,
                      CurrentTime);

    return Succeeded;
}

int warppointer(wbp w, int x, int y)
{
    wsp ws = w->window;
    XWarpPointer(ws->display->display, None, ws->win, 0,0,0,0, x, y);
    return Succeeded;
}

/*
 * setwindowlabel
 */
int setwindowlabel(wbp w, char *s)
{
    wsp ws = w->window;
    if (ws->windowlabel)
        free(ws->windowlabel);
    ws->windowlabel = salloc(s);

    if (ws->display && ws->display->display && ws->win)
        XStoreName(ws->display->display, ws->win,
                   *ws->windowlabel ? ws->windowlabel : " ");    /* empty string fails */
    return Succeeded;
}



/*
 * setpointer() - define a mouse pointer shape
 */
int setpointer(wbp w, char *val)
{
    stringint *e;
    int i;
    STDLOCALS(w);
    e = stringint_lookup(cursors, val);
    if (!e)
        return Failed;
    ws->cursor = e;
    i = ws->cursor->i >> 1;
    if (!(wd->cursors[i]))
        wd->cursors[i] = XCreateFontCursor(stddpy, 2 * i);
    if (stdwin)
        XDefineCursor(stddpy, stdwin, wd->cursors[i]);
    return Succeeded;
}

#if 0
    int i = stringint_str2int(cursorsyms,val) >> 1;
    STDLOCALS(w);
    if (i < 0 || i >= NUMCURSORSYMS) return Failed;

    ws->theCursor = i;
    if (!(wd->cursors[i]))
        wd->cursors[i] = XCreateFontCursor(stddpy, 2 * i);
    if (stdwin)
        XDefineCursor(stddpy, stdwin, wd->cursors[i]);
    return Succeeded;
}
#endif

/*
 * setdrawop() - set the drawing operation
 */
int setdrawop(wbp w, char *val)
{
    stringint *e;
    STDLOCALS(w);
    XSync(stddpy, False);
    e = stringint_lookup(drawops, val);
    if (!e)
        return Failed;
    wc->drawop = e;
    if (stdgc) XSetFunction(stddpy, stdgc, wc->drawop->i);
    return Succeeded;
}

/*
 * rebind() - bind w's context to that of w2.
 */
int rebind(wbp w, wbp w2)
{
    if (w->window->display != w2->context->display) return Failed;
    w->context = w2->context;
    return Succeeded;
}


static void setclip(wbp w)
{
    wcp wc = w->context;
    XRectangle rec;
    if (wc->gc) {
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XSetClipRectangles(wc->display->display, wc->gc, 0, 0, &rec, 1,Unsorted);
    }
}

static void unsetclip(wbp w)
{
    wcp wc = w->context;
    if (wc->gc) {
        XSetClipMask(wc->display->display, wc->gc, None);
    }
}

void getcanvas(wbp w, char *s)
{
    if (w->window->win == (Window) NULL) sprintf(s, "hidden");
    else
        switch (w->window->iconic) {
            case RootState:
                sprintf(s, "root");
                break;
            case NormalState:
                sprintf(s, "normal");
                break;
            case PopupState:
                sprintf(s, "popup");
                break;
            case IconicState:
                sprintf(s, "iconic");
                break;
            case MaximizedState:
                sprintf(s, "maximal");
                break;
            case HiddenState:
                sprintf(s, "hidden");
                break;
            default:
                sprintf(s, "???");
        }
}


int setinputmask(wbp w, char *val)
{
    wsp ws = w->window;
    if (strchr(val,'k')) {
        ws->inputmask |= KeyReleaseMask;
    }
    else {
        ws->inputmask &= ~KeyReleaseMask;
    }
    if (strchr(val,'m')) {
        ws->inputmask |= PointerMotionMask;
    }
    else {
        ws->inputmask &= ~PointerMotionMask;
    }

    if (ws->win)
        XSelectInput(ws->display->display, ws->win, XMasks(ws->inputmask));
    return Succeeded;
}

/*
 *  Set the canvas type, either during open (pixmap is null, set a flag)
 *   or change an existing canvas to a different type.
 */
int setcanvas(wbp w, char *s)
{
    STDLOCALS(w);

    if (!strcmp(s, "iconic")) {
        if (ws->pix == (Pixmap) NULL) {
            ws->wmhintflags |= StateHint;
            ws->iconic = IconicState;
        }
        else {
            if (ws->iconic != IconicState) {
                if (ws->win == (Window) NULL) {
                    wmap(w);
                }
                XIconifyWindow(ws->display->display, ws->win, ws->display->screen);
                XSync(stddpy, False);
                while (ws->iconic != IconicState)
                    if (handle_misc(wd) < 1) {
                        return Failed;
                    }
	    }
        }
    }

    else if (!strcmp(s, "normal")) {
        if (ws->pix == (Pixmap) NULL) {
            ws->iconic = NormalState;
        }
        else {
            if (ws->win == (Window) NULL) {
                ws->iconic = NormalState;
                wmap(w);
	    }
            else if (ws->iconic == IconicState) {
                XMapWindow(stddpy, stdwin);
                XSync(stddpy, False);
                while (ws->iconic == IconicState)
                    pollevent();
	    }
            else if (ws->iconic == MaximizedState) {
                ws->x = ws->normalx;
                ws->y = ws->normaly;
                ws->width = ws->normalw;
                ws->height = ws->normalh;
                doconfig(w, C_POS | C_SIZE);
                ws->iconic = NormalState;
	    }
        }
    }

    else if (!strcmp(s, "popup")) {
        if (ws->win == (Window) NULL)  {
            ws->iconic = PopupState;
        }
        else {
            return Failed;
        }
    }

    else if (!strcmp(s, "root")) {
        if (ws->win == (Window) NULL)  {
            ws->iconic = RootState;
        }
        else {
            return Failed;
        }
    }

    else if (!strcmp(s, "maximal")) {
        if (ws->iconic != MaximizedState) {
            int expect_config= (ws->width != DisplayWidth(stddpy, wd->screen)) ||
                (ws->height != DisplayHeight(stddpy, wd->screen));
            ws->normalx = ws->x;
            ws->normaly = ws->y;
            ws->normalw = ws->width;
            ws->normalh = ws->height;
            ws->width = DisplayWidth(stddpy, wd->screen);
            ws->height= DisplayHeight(stddpy, wd->screen);
            if (ws->pix != (Pixmap) NULL) {
                if (ws->win == (Window) NULL) {
                    ws->iconic = MaximizedState;
                    wmap(w);
                }
                else if (ws->iconic == IconicState) {
                    XMapWindow(stddpy, stdwin);
                    XSync(stddpy, False);
                    while (ws->iconic == IconicState)
                        pollevent();
                }
                else if (expect_config) {
                    ws->x = ws->y = 0;
                    doconfig(w, C_POS | C_SIZE);
                    pollevent();
                    ws->x = -ws->x;
                    ws->y = -ws->y;
                    doconfig(w, C_POS);
                }
	    }
            ws->iconic = MaximizedState;
        }
    }
    else if (!strcmp(s, "hidden")) {
        if (ws->pix == (Pixmap)NULL) {
            ws->iconic = HiddenState;
        }
        else {
            if (ws->win != (Window) NULL) {
                if (ws->iconic == MaximizedState) {
                    ws->x = ws->normalx;
                    ws->y = ws->normaly;
                    ws->width = ws->normalw;
                    ws->height = ws->normalh;
                    ws->iconic = NormalState;
                }
                if (ws->iconic != IconicState) {
                    SETZOMBIE(w);
#ifdef HAVE_LIBXFT
                    if (ws->winDraw) {
                        XftDrawDestroy(ws->winDraw);
                        ws->winDraw = NULL;
                    }
#endif
                    XDestroyWindow(stddpy, stdwin);
                    XFlush(stddpy);
                    while (ws->win)
                        pollevent();
                }
	    }
        }
    }
    else return Failed;
    XSync(ws->display->display, False);
    return Succeeded;
}


/*
 * Set the context's fill style by name.
 */
int setfillstyle(wbp w, char *val)
{
    stringint *e;
    STDLOCALS(w);
    e = stringint_lookup(fillstyles, val);
    if (!e)
        return Failed;
    wc->fillstyle = e;
    if (stdpix)
        XSetFillStyle(stddpy, stdgc, wc->fillstyle->i);
    return Succeeded;
}

void getfillstyle(wbp w, char *answer)
{
    strcpy(answer, w->context->fillstyle->s);
}


/*
 * Set the context's line style by name.
 */
int setlinestyle(wbp w, char *val)
{
    stringint *e;
    STDLOCALS(w);
    e = stringint_lookup(linestyles, val);
    if (!e)
        return Failed;
    wc->linestyle = e;
    if (stdpix) 
        XSetLineAttributes(stddpy, stdgc,
                           wc->linewidth, wc->linestyle->i, CapProjecting, JoinMiter);
    return Succeeded;
}

/*
 * Set the context's line width
 */
int setlinewidth(wbp w, int linewid)
{
    unsigned long gcmask;
    XGCValues gcv;
    STDLOCALS(w);

    if (linewid < 0) return Error;
    wc->linewidth = linewid;
    if (stdpix) {
        gcv.line_width = linewid;
        gcv.line_style = wc->linestyle->i;
        if (linewid > 1)
            gcv.dashes = 3 * wc->linewidth;
        else
            gcv.dashes = 4;
        gcmask = GCLineWidth | GCLineStyle | GCDashList;
        XChangeGC(stddpy, stdgc, gcmask, &gcv);
    }
    return Succeeded;
}

int getlinewidth(wbp w)
{
    return w->context->linewidth;
}

/*
 * Set the context's foreground color by name.
 */
int setfg(wbp w, char *s)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(s, &r, &g, &b, &a)) {
        LitWhy("Invalid color");
        return Failed;
    }
    if (wc->fg)
        unlink_sharedcolor(wc->fg);
    wc->fg = new_sharedcolor(s, r, g, b);
    if (wc->gc)
        XSetForeground(wc->display->display, wc->gc, wc->fg->c);
    return Succeeded;
}


/*
 * Set the window context's background color by name.
 */
int setbg(wbp w, char *s)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(s, &r, &g, &b, &a)) {
        LitWhy("Invalid color");
        return Failed;
    }
    if (wc->bg)
        unlink_sharedcolor(wc->bg);
    wc->bg = new_sharedcolor(s, r, g, b);
    if (wc->gc)
        XSetBackground(wc->display->display, wc->gc, wc->bg->c);
    return Succeeded;
}

void getdisplay(wbp w, char *answer)
{
    char *tmp;
    wdp wd = w->window->display;
    if (!strcmp(wd->name, "")) {
        if ((tmp = getenv("DISPLAY")) != NULL)
            sprintf(answer, "%s", tmp);
        else
            *answer = '\0';
    }
    else sprintf(answer, "%s", wd->name);
}

int getwindowlabel(wbp w, char *answer)
{
    if (!w->window->windowlabel)
        return Failed;
    strcpy(answer, w->window->windowlabel);
    return Succeeded;
}

int getdisplaysize(wbp w, int *width, int *height)
{
    *width = DisplayWidth(w->window->display->display, w->window->display->screen);
    *height = DisplayHeight(w->window->display->display, w->window->display->screen);
    return Succeeded;
}

int getdepth(wbp w, int *res)
{
    *res = DefaultDepth(w->window->display->display, w->window->display->screen);
    return Succeeded;
}

/*
 * getpos() - update the window state's notion of its current position
 */
int getpos(wbp w)
{
    Window garbage1, garbage2;
    int root_x, root_y, win_x, win_y;
    unsigned int key_buttons;
    STDLOCALS(w);
    if (!stdwin) return Failed;
    /*
     * This call is made because it is guaranteed to generate
     * a synchronous request of the server, not just ask Xlib
     * what the window position was last it knew.
     */
    if (XQueryPointer(stddpy, stdwin, &garbage1, &garbage2,
                      &root_x, &root_y, &win_x, &win_y, &key_buttons) ==
        False) {
        return Failed;
    }
    ws->x = root_x - win_x;
    ws->y = root_y - win_y;
    return Succeeded;
}

void getpattern(wbp w, char *answer)
{
    if (w->context->patternname)
        strcpy(answer, w->context->patternname);
    else 
        strcpy(answer, "black");
}

void getfg(wbp w, char *answer)
{
    strcpy(answer, w->context->fg->name);
}

void getbg(wbp w, char *answer)
{
    strcpy(answer, w->context->bg->name);
}

void getlinestyle(wbp w, char *answer)
{
    strcpy(answer, w->context->linestyle->s);
}

void getpointer(wbp w, char *answer)
{
    strcpy(answer, w->window->cursor->s);
}

void getdrawop(wbp w, char *answer)
{
    strcpy(answer, w->context->drawop->s);
}

int grabpointer(wbp w)
{
    wsp ws = w->window;
    if (!ws->win)
        return Failed;
    if (XGrabPointer(ws->display->display, ws->win,False,
                     EnterWindowMask | LeaveWindowMask | PointerMotionMask |
                     ButtonMotionMask | ButtonPressMask | ButtonReleaseMask |
                     Button1MotionMask | Button2MotionMask | Button3MotionMask, 
                     GrabModeAsync, GrabModeAsync, None, None, CurrentTime) == GrabSuccess)
        return Succeeded;
    else
        return Failed;
}

int ungrabpointer(wbp w)
{
    wsp ws = w->window;
    if (!ws->win)
        return Failed;
    XUngrabPointer(ws->display->display, CurrentTime);
    return Succeeded;
}

/*
 * Set the window's font by name.
 */
int setfont(wbp w, char *s)
{
    wfp tmp;
    STDLOCALS(w);

    /* could free up previously allocated font here */

    Protect(tmp = alcfont(w,s), return Failed);
    wc->font = tmp;

#ifndef HAVE_LIBXFT
    if (stdgc != NULL)
        XSetFont(stddpy, stdgc, wc->font->fsp->fid);
#endif

    return Succeeded;
}

/*
 * callback procedures
 */

static int handle_exposures(wbp w, XExposeEvent *event)
{
    int returnval;
    STDLOCALS(w);
    returnval = ISEXPOSED(w);
    SETEXPOSED(w);
    if (stdwin && !ISZOMBIE(w)) {
        if (wc->drawop->i != GXcopy)
            XSetFunction(stddpy, stdgc, GXcopy);
        if (wc->clipw >= 0)
            unsetclip(w);
        XCopyArea(stddpy, stdpix, stdwin, stdgc, event->x,event->y,
                  event->width,event->height, event->x,event->y);
        if (wc->clipw >= 0)
            setclip(w);
        if (wc->drawop->i != GXcopy)
            XSetFunction(stddpy,stdgc,wc->drawop->i);
    }
    return returnval;
}

/*
 * resizePixmap(w,width,height) -- ensure w's backing pixmap is at least
 * width x height pixels.
 *
 * Resizes the backing pixmap, if needed.  Called when X resize events
 * arrive, as well as when programs make explicit resize requests.
 *
 */
static void resizePixmap(wbp w, int width, int height)
{
    Pixmap p;
    STDLOCALS(w);
    if (ws->pix == (Pixmap) NULL) 
        return;
    if ((width > ws->pixwidth) || (height > ws->pixheight)) {
        int x = ws->pixwidth, y = ws->pixheight;

        ws->pixheight = Max(ws->pixheight, height);
        ws->pixwidth  = Max(ws->pixwidth, width);
        MemProtect(p = XCreatePixmap(stddpy, DefaultRootWindow(stddpy), ws->pixwidth,
                                     ws->pixheight, DefaultDepth(stddpy,wd->screen)));
        /*
         * This staggering amount of redudancy manages to make sure the new
         * pixmap gets initialized including areas not in the old pixmap.
         * The window is redrawn.
         */
        XSetForeground(stddpy, stdgc, wc->bg->c);
        if (wc->drawop->i != GXcopy)
            XSetFunction(stddpy, stdgc, GXcopy);
        if (wc->fillstyle != FillSolid)
            XSetFillStyle(stddpy, stdgc, FillSolid);
        if (wc->clipw >= 0)
            unsetclip(w);
	   
        if (width > x) {
            XFillRectangle(stddpy, p, stdgc, x, 0, width-x, ws->pixheight);
            if (stdwin != (Window) NULL)
                XFillRectangle(stddpy,stdwin,stdgc, x, 0, width-x, ws->pixheight);
        }
        if (height > y) {
            XFillRectangle(stddpy, p, stdgc, 0, y, x, height - y);
            if (stdwin != (Window) NULL)
                XFillRectangle(stddpy, stdwin, stdgc, 0, y, x, height - y);
        }
        XSetForeground(stddpy, stdgc, wc->fg->c);
        XCopyArea(stddpy, stdpix, p, stdgc, 0, 0, x, y, 0, 0);
        if (wc->drawop->i != GXcopy)
            XSetFunction(stddpy,stdgc,wc->drawop->i);
        if (wc->fillstyle->i != FillSolid)
            XSetFillStyle(stddpy, stdgc, wc->fillstyle->i);
        if (wc->clipw >= 0)
            setclip(w);

        XFreePixmap(stddpy, stdpix);	/* free old pixmap */
        ws->pix = p;
#ifdef HAVE_LIBXFT
        if (ws->pixDraw) {
            XftDrawDestroy(ws->pixDraw);
            ws->pixDraw = NULL;
        }
#endif
    }
}

/*
 * Resize operations are made as painless as possible, but the
 * user program is informed anyhow.  The integer coordinates are
 * the new size of the window, in pixels.
 */
static int handle_config(wbp w, XConfigureEvent *event)
{
    struct descrip d;
    STDLOCALS(w);

    /*
     * Update X-Icon's information about the window's configuration
     */

    ws->x = event->x;
    ws->y = event->y;

    /*
     * If this was not a resize, drop it
     */
    if ((event->width == ws->width) && (event->height == ws->height))
        return 1;

    ws->width = event->width;
    ws->height = event->height;

    resizePixmap(w, event->width, event->height);


    /*
     * The initial configure event generates no Icon-level "events"
     */
    if (!ISEXPOSED(w))
        return 1;

    MakeInt(RESIZED, &d);
    qevent(w->window, &d, -1, -1, 0, 0, 0);
    return 1;
}

/*
 * Queue up characters for keypress events.
 */
static void handle_keypress(wbp w, XKeyEvent *event)
{
    int i,j;
    char s[10];
    tended struct descrip d;
    KeySym k;

    /* First try to convert the event to a simple char string, and a KeySym */
    i = XLookupString(event, s, sizeof(s), &k, NULL);
    if (i > 0) {
        /* Found a char string, so generate string event(s) */
        StrLen(d) = 1;
        for (j = 0; j < i; j++) {
            StrLoc(d) = &allchars[s[j] & 0xFF];
            qevent(w->window, &d, event->x, event->y,
                   (uword)event->time, event->state,
                   (event->type == KeyRelease) );
        }
        return;
    }

    /* Second try is to convert to a unicode char; if found generate a 1-char
     * ucs/string */
    i = convert_KeySym_to_code_point(k);
    if (i > 0) {
        if (i < 256) {
            StrLen(d) = 1;
            StrLoc(d) = &allchars[i];
        } else {
            d.dword = D_Ucs;
            BlkLoc(d) = (union block *)make_one_char_ucs_block(i);
        }
        qevent(w->window, &d, event->x, event->y,
               (uword)event->time, event->state,
               (event->type == KeyRelease) );
        return;
    }

    /* Neither of those worked, so it must be a non-character key (cursor key, etc).
     * So just generate the numerical value of the KeySym as an integer.
     */
    MakeInt(k, &d);
    qevent(w->window, &d, event->x, event->y,
           (uword)event->time, event->state,
           (event->type == KeyRelease) );
}

#include "rxkeysyms.ri"

#define swap(a,b) { tmp = a; a = b; b = tmp; }
/*
 * Handle button presses and drag events.  In the case of drags, we should
 * really be looking at an XMotionEvent instead of an XButtonEvent, but
 * the structures are identical up to the button field (which we do not
 * examine for drag events).  Mouse coordinates are queued up after the event.
 */
static void handle_mouse(wbp w, XButtonEvent *event)
{
    static unsigned int buttonorder[3] =
        { Button1Mask, Button2Mask, Button3Mask };
    unsigned int tmp;
    int eventcode = 0;
    struct descrip d;

    if (event->type == MotionNotify) {
        if (event->state & buttonorder[0]) {
            if (buttonorder[0] == Button1Mask)
                eventcode = MOUSELEFTDRAG;
            else if (buttonorder[0] == Button2Mask)
                eventcode = MOUSEMIDDRAG;
            else
                eventcode = MOUSERIGHTDRAG;
        }
        else if (event->state & buttonorder[1]) {
            if (buttonorder[1] == Button1Mask)
                eventcode = MOUSELEFTDRAG;
            else if (buttonorder[1] == Button2Mask)
                eventcode = MOUSEMIDDRAG;
            else
                eventcode = MOUSERIGHTDRAG;
        }
        else if (event->state & buttonorder[2]) {
            if (buttonorder[2] == Button1Mask)
                eventcode = MOUSELEFTDRAG;
            else if (buttonorder[2] == Button2Mask)
                eventcode = MOUSEMIDDRAG;
            else
                eventcode = MOUSERIGHTDRAG;
        }
        else {
            eventcode = MOUSEMOVED;
        }
    }
    else switch (event->button) {
        case Button1: {
            eventcode = MOUSELEFT;
            if (buttonorder[2] == Button1Mask)
                swap(buttonorder[1],buttonorder[2]);
            if (buttonorder[1] == Button1Mask)
                swap(buttonorder[0],buttonorder[1]);
            break;
        }
        case Button2: {
            eventcode = MOUSEMID;
            if (buttonorder[2] == Button2Mask)
                swap(buttonorder[1],buttonorder[2]);
            if (buttonorder[1] == Button2Mask)
                swap(buttonorder[0],buttonorder[1]);
            break;
        }
        case Button3: {
            eventcode = MOUSERIGHT;
            if (buttonorder[2] == Button3Mask)
                swap(buttonorder[1],buttonorder[2]);
            if (buttonorder[1] == Button3Mask)
                swap(buttonorder[0],buttonorder[1]);
            break;
        }
        case Button4: {
            eventcode = MOUSE4;
            break;
        }
        case Button5: {
            eventcode = MOUSE5;
            break;
        }
    }
    if (event->type == ButtonRelease) {
        eventcode -= (MOUSELEFT - MOUSELEFTUP);
        swap(buttonorder[0],buttonorder[1]);
        swap(buttonorder[1],buttonorder[2]);
    }

    /*
     * Don't generate events for these codes.  Rather, MOUSE4UP and
     * MOUSE5UP are used to generate the &wheelup and &wheeldown
     * events respectively.
     */
    if (eventcode == MOUSE4 || eventcode == MOUSE5)
        return;

    MakeInt(eventcode,&d);

    qevent(w->window, &d, event->x, event->y, (uword)event->time, event->state, 0);
}


void drawarc(wbp w, int x, int y, int width, int height, double angle1, double angle2)
{
    XArc arc;
    STDLOCALS(w); 
    arc.x = x;
    arc.y = y;
    arc.width = width;
    arc.height = height;
    arc.angle1 = CONVERT_ANGLE(angle1);
    arc.angle2 = CONVERT_ANGLE(angle2);
    RENDER2(XDrawArcs,&arc,1);
}

void drawlines(wbp w, XPoint *points, int npoints)
{
    STDLOCALS(w); 
    RENDER3(XDrawLines,points,npoints,CoordModeOrigin);
}

void drawpoint(wbp w, int x, int y)
{
    XPoint p;
    STDLOCALS(w);
    p.x = x;
    p.y = y;
    RENDER3(XDrawPoints,&p,1,CoordModeOrigin);
}

void drawrectangle(wbp w, int x, int y, int width, int height)
{
   STDLOCALS(w);
   RENDER4(XDrawRectangle,x,y,width-1,height-1);
}

void fillarc(wbp w, int x, int y, int width, int height, double angle1, double angle2)
{ 
    XArc arc;
    STDLOCALS(w); 
    arc.x = x;
    arc.y = y;
    arc.width = width;
    arc.height = height;
    arc.angle1 = CONVERT_ANGLE(angle1);
    arc.angle2 = CONVERT_ANGLE(angle2);
    RENDER2(XFillArcs, &arc, 1);
}

void fillpolygon(wbp w, XPoint *points, int npoints)
{
    STDLOCALS(w); 
    RENDER4(XFillPolygon, points, npoints, Complex, CoordModeOrigin);
}

/*
 * fill a rectangle
 */
void fillrectangle(wbp w, int x, int y, int width, int height)
{
    XRectangle rec;
    STDLOCALS(w);
    rec.x = x;
    rec.y = y;
    rec.width = width;
    rec.height = height;
    RENDER2(XFillRectangles, &rec, 1);
}

/*
 * erase an area
 */
void erasearea(wbp w, int x, int y, int width, int height)
{
    STDLOCALS(w);

    /*
     * if width >= window width or height >= window height, clear any
     * offscreen portion as well in order to allow the freeing of colors.
     */
    if (x + width  >= ws->width)  width  = ws->pixwidth - x;
    if (y + height >= ws->height) height = ws->pixheight - y;

    /*
     * fill the rectangle with the background color
     */
    XSetForeground(stddpy, stdgc, wc->bg->c);
    if (wc->drawop->i != GXcopy) XSetFunction(stddpy, stdgc, GXcopy);
    if (wc->fillstyle->i != FillSolid) XSetFillStyle(stddpy, stdgc, FillSolid);

    RENDER4(XFillRectangle, x, y, width, height);
    XSetForeground(stddpy, stdgc, wc->fg->c);
    if (wc->drawop->i != GXcopy) XSetFunction(stddpy, stdgc, wc->drawop->i);
    if (wc->fillstyle->i != FillSolid) XSetFillStyle(stddpy, stdgc, wc->fillstyle->i);
}

/*
 * copy an area
 */
int copyarea(wbp w, wbp w2, int x, int y, int width, int height, int x2, int y2)
{
    int lpad, rpad, tpad, bpad;
    Pixmap src;
    wsp ws1 = w->window;
    STDLOCALS(w2);

    if (w->window->display->display != w2->window->display->display) {
        wdp wd1 = ws1->display;
        int i, j;
        Display *d1 = wd1->display;
        XImage *xim;

        /*
         * Copying is between windows on two different displays.
         */
        if (x<0 || y<0 || x+width > ws1->pixwidth || y+height > ws1->pixheight)
            return Failed;		/*#%#%# BOGUS, NEEDS FIXING */
        xim = XGetImage(d1, ws1->pix, x, y, width, height,
                        (1<<DefaultDepth(d1,wd1->screen))-1,XYPixmap);
        XSetFunction(stddpy, stdgc, GXcopy);
        for (i=0; i < width; i++) {
            for (j=0; j < height; j++) {
                XSetForeground(stddpy, stdgc, XGetPixel(xim, i, j));
                RENDER2(XDrawPoint, i + x2, j + y2);
	    }
        }
        XSetForeground(stddpy, stdgc, wc->fg->c);
        XSetFunction(stddpy, stdgc, wc->drawop->i);
        XSync(stddpy,False);
        XDestroyImage(xim);
    }
    else {
        /*
         * Copying is between windows on one display, perhaps the same window.
         */
        src = ws1->pix;
        XSetForeground(stddpy, stdgc, wc->bg->c);
        XSetFunction(stddpy, stdgc, GXcopy);

        if (x+width<0 || y+height<0 || x>=ws1->pixwidth || y>=ws1->pixheight) {
            /* source is entirely offscreen */
            RENDER4(XFillRectangle, x2, y2, width, height);
        }
        else {
            /*
             * Check for source partially offscreen, but copy first and
             * fill later in case the source and destination overlap.
             */
            lpad = rpad = tpad = bpad = 0;
            if (x < 0) {			/* source extends past left edge */
                lpad = -x;
                width -= lpad;
                x2 += lpad;
                x = 0;
            }
            if (x + width > ws1->pixwidth) {  /* source extends past right edge */
                rpad = x + width - ws1->pixwidth;
                width -= rpad;
            }
            if (y < 0) {			/* source extends above top edge */
                tpad = -y;
                height -= tpad;
                y2 += tpad;
                y = 0;
            }
            if (y + height > ws1->pixheight) {  /* source extends below bottom */
                bpad = y + height - ws1->pixheight;
                height -= bpad;
            }
            /*
             * Copy the area.
             */
            if (stdwin)
                XCopyArea(stddpy, src, stdwin, stdgc, x, y, width, height, x2, y2);
            XCopyArea(stddpy, src, stdpix, stdgc, x, y, width, height, x2, y2);
            /*
             * Fill any edges not provided by source.
             */
            if (lpad > 0)
                RENDER4(XFillRectangle, x2-lpad, y2-tpad, lpad, tpad+height+bpad);
            if (rpad > 0)
                RENDER4(XFillRectangle, x2+width, y2-tpad, rpad, tpad+height+bpad);
            if (tpad > 0)
                RENDER4(XFillRectangle, x2, y2-tpad, width, tpad);
            if (bpad > 0)
                RENDER4(XFillRectangle, x2, y2+height, width, bpad);
        }

        XSetForeground(stddpy,stdgc, wc->fg->c);
        XSetFunction(stddpy, stdgc, wc->drawop->i);
    }
    return Succeeded;
}


/*
 * Client for producing pixels from a window
 */
void loadimgmem(wbp w, struct imgmem *imem, int copy)
{
    STDLOCALS(w);
    MemProtect(imem->im = XGetImage(stddpy, stdpix,
                                    imem->x, imem->y, imem->width, imem->height,
                                    AllPlanes, ZPixmap));
}

void getpixel(struct imgmem *imem, int *r, int *g, int *b)
{
    unsigned long c;
    c = XGetPixel(imem->im, imem->xoff, imem->yoff);
    *b = (c&0xff)*257;
    *g = ((c>>8)&0xff)*257;
    *r = ((c>>16)&0xff)*257;
}

void setpixel(struct imgmem *imem, int r, int g, int b)
{
    unsigned long c = ((r/257)<<16) | ((g/257)<<8) | (b/257);
    XPutPixel(imem->im, imem->xoff, imem->yoff, c);
}

void saveimgmem(wbp w, struct imgmem *imem)
{
    STDLOCALS(w);
    if (wc->drawop->i != GXcopy) XSetFunction(stddpy, stdgc, GXcopy);
    RENDER7(XPutImage, imem->im, 0, 0, imem->x, imem->y, imem->width, imem->height);
    if (wc->drawop->i != GXcopy) XSetFunction(stddpy, stdgc, wc->drawop->i);
}

void freeimgmem(struct imgmem *imem)
{
    XDestroyImage(imem->im);
    imem->im = 0;
}


int querypointer(wbp w, int *x, int *y)
{
    Display *theDisplay;
    Window theWindow;
    Window garbage1, garbage2;
    int root_x, root_y;
    unsigned int key_buttons;

    theDisplay = w->window->display->display;
    theWindow  = w->window->win;
    if (!theWindow)
        return Failed;

    XQueryPointer(theDisplay, theWindow, &garbage1, &garbage2,
                  &root_x, &root_y, x, y, &key_buttons);
    return Succeeded;
}

int queryrootpointer(wbp w, int *x, int *y)
{
    Display *theDisplay;
    Window theWindow;
    Window garbage1, garbage2;
    int win_x, win_y;
    unsigned int key_buttons;

    theDisplay = w->window->display->display;
    theWindow  = DefaultRootWindow(theDisplay);
    if (!theWindow)
        return Failed;
    XQueryPointer(theDisplay, theWindow, &garbage1, &garbage2,
                  x, y, &win_x, &win_y, &key_buttons);
    return Succeeded;
}


int patbits[] = {
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFE,0xFF,0xEF,0xFF,0xFE,0xFF,0xEF,0xFF,
    0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,
    0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,
    0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,
    0x01,0x00,0x10,0x00,0x01,0x00,0x10,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,
    0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,
    0x10,0x10,0x10,0xFF,0x10,0x10,0x10,0x10,
    0x82,0x44,0x28,0x10,0x28,0x44,0x82,0x01,

    0x0F,0x0F,0x0F,0x0F,0xF0,0xF0,0xF0,0xF0,
    0x1B,0x18,0x81,0xB1,0x36,0x06,0x60,0x63,
    0x02,0x02,0x05,0xF8,0x20,0x20,0x50,0x8F,
    0x03,0x84,0x48,0x30,0x03,0x84,0x48,0x30,
};

/*
 * pattern symbols
 */
static stringint siPatternSyms[] = {
    {0,		16},
    { "black",	 0},
    { "checkers",	 12},
    { "darkgray",	 2},
    { "diagonal",	 8},
    { "grains",	 13},
    { "gray",	 3},
    { "grid",	 10},
    { "horizontal",9},
    { "lightgray", 4},
    { "scales",	 14},
    { "trellis",	 11},
    { "vertical",	 7},
    { "verydark",	 1},
    { "verylight", 5},
    { "waves",	 15},
    { "white",	 6},
};

/*
 * setpattern
 */
int setpattern(wbp w, char *name)
{
    int width, nbits;
    int i;
    int symbol;
    int v, bits[MAXXOBJS];
    Pixmap p;
    char data[MAXXOBJS];
    char *t, *buf = data;
    STDLOCALS(w);

    /*
     * If the pattern starts with a number it is a width , bits encoding
     */
    if (isdigit((unsigned char)name[0])) {
        nbits = MAXXOBJS;
        if (!parsepattern(name, &width, &nbits, bits)) {
            LitWhy("Invalid pattern");
            return Failed;
        }
        if (stdgc)
            setpatternbits(w, width, bits, nbits);
    } else {
        /*
         * Otherwise, it is a named pattern.  Find the symbol id.
         */
        if ((symbol = stringint_str2int(siPatternSyms, name)) < 0)
            return Failed;

        if (stdgc) {
            for(i = 0; i < 8; i++) {
                v = patbits[symbol * 8 + i];
                *buf++ = v;
            }
            p = XCreateBitmapFromData(stddpy, stdpix, data, 8, 8);
            XSetStipple(stddpy, stdgc, p);
            XSync(stddpy, False);
            XFreePixmap(stddpy, p);
        }
    }

    t = salloc(name);
    if (wc->patternname != NULL)
        free(wc->patternname);
    wc->patternname = t;
   
    return Succeeded;
}

static int setpatternbits(wbp w, int width, int *bits, int nbits)
{
    int v;
    int i, j;
    Pixmap p;
    char data[MAXXOBJS];
    char *buf = data;
    STDLOCALS(w);

    for(i = 0; i < nbits; i++) {
        v = bits[i];
        for(j=0; j<width; j+=8) {
            *buf++ = v;
            v >>= 8;
        }
    }

    p = XCreateBitmapFromData(stddpy, stdpix, data, width, nbits);
    XSetStipple(stddpy, stdgc, p);
    XSync(stddpy, False);
    XFreePixmap(stddpy, p);
    return Succeeded;
}

int raisewindow(wbp w)
{
    XEvent event;
    XWindowAttributes attr;

    wsp ws = w->window;
    if (ws->win) {
        XMapRaised(ws->display->display, ws->win);

        /* Wait for the window to become viewable before giving
           it the focus. */
        for (;;) {
            XGetWindowAttributes(ws->display->display, ws->win, &attr);
            if (attr.map_state == IsViewable)
                break;
            /* Not viewable yet, so wait for a MapNotify event. */
            XWindowEvent(ws->display->display, 
                         ws->win,
                         StructureNotifyMask, 
                         &event);
        }

        /* Now it is viewable, so give it the focus. */
        XSetInputFocus(ws->display->display, ws->win, RevertToParent, CurrentTime);
    }
    return Succeeded;
}

int lowerwindow(wbp w)
{
    if (w->window->win)
        XLowerWindow(w->window->display->display, w->window->win);
    return Succeeded;
}

int walert(wbp w, int volume)
{
    STDLOCALS(w);
    XBell(stddpy, volume);    
    XFlush(stddpy);
    return Succeeded;
}

#ifdef HAVE_LIBXFT
int textwidth(wbp w, char *s, int n)
{
    XGlyphInfo	extents; 

    XftTextExtents8 (w->window->display->display,
                     w->context->font->fsp,
                     (FcChar8 *)s,
                     n,
                     &extents);
    return extents.xOff;
}

int utf8width(wbp w, char *s, int n, int nchars)
{
    XGlyphInfo	extents; 

    XftTextExtentsUtf8 (w->window->display->display,
                        w->context->font->fsp,
                        (FcChar8 *)s,
                        n,
                        &extents);
    return extents.xOff;
}


void drawstring(wbp w, int x, int y, char *str, int slen)
{
    XftColor color;
    Region r;
    XRectangle rec;
    STDLOCALS(w);

    if (ws->win && !ws->winDraw)
        ws->winDraw = XftDrawCreate(ws->display->display,
                                    ws->win,
                                    ws->vis,
                                    ws->display->cmap);

    if (!ws->pixDraw)
        ws->pixDraw = XftDrawCreate(ws->display->display,
                                    ws->pix,
                                    ws->vis,
                                    ws->display->cmap);
    color.pixel = wc->fg->c;
    color.color.red = wc->fg->r;
    color.color.green = wc->fg->g;
    color.color.blue = wc->fg->b;
    color.color.alpha = 0xffff;

    if (wc->clipw >= 0 && wc->cliph >=0) {
        r = XCreateRegion();
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XUnionRectWithRegion(&rec, r, r);
        if (ws->winDraw) 
            XftDrawSetClip(w->window->winDraw, r);
        if (ws->pixDraw) 
            XftDrawSetClip(w->window->pixDraw, r);
        XDestroyRegion(r);
    } else {
        if (ws->winDraw) 
            XftDrawSetClip(w->window->winDraw, 0);
        if (ws->pixDraw) 
            XftDrawSetClip(w->window->pixDraw, 0);
    }

    if (ws->winDraw)
        XftDrawString8 (ws->winDraw,
                        &color,
                        wc->font->fsp,
                        x,
                        y,
                        (FcChar8 *)str,
                        slen);

    if (ws->pixDraw)
        XftDrawString8 (ws->pixDraw,
                        &color,
                        wc->font->fsp,
                        x,
                        y,
                        (FcChar8 *)str,
                        slen);
}

void drawutf8(wbp w, int x, int y, char *str, int slen, int nchars)
{
    XftColor color;
    Region r;
    XRectangle rec;
    STDLOCALS(w);

    if (ws->win && !ws->winDraw)
        ws->winDraw = XftDrawCreate(ws->display->display,
                                    ws->win,
                                    ws->vis,
                                    ws->display->cmap);

    if (!ws->pixDraw)
        ws->pixDraw = XftDrawCreate(ws->display->display,
                                    ws->pix,
                                    ws->vis,
                                    ws->display->cmap);
    color.pixel = wc->fg->c;
    color.color.red = wc->fg->r;
    color.color.green = wc->fg->g;
    color.color.blue = wc->fg->b;
    color.color.alpha = 0xffff;

    if (wc->clipw >= 0 && wc->cliph >=0) {
        r = XCreateRegion();
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XUnionRectWithRegion(&rec, r, r);
        if (ws->winDraw) 
            XftDrawSetClip(w->window->winDraw, r);
        if (ws->pixDraw) 
            XftDrawSetClip(w->window->pixDraw, r);
        XDestroyRegion(r);
    } else {
        if (ws->winDraw) 
            XftDrawSetClip(w->window->winDraw, 0);
        if (ws->pixDraw) 
            XftDrawSetClip(w->window->pixDraw, 0);
    }

    if (ws->winDraw)
        XftDrawStringUtf8 (ws->winDraw,
                           &color,
                           wc->font->fsp,
                           x,
                           y,
                           (FcChar8 *)str,
                           slen);

    if (ws->pixDraw)
        XftDrawStringUtf8 (ws->pixDraw,
                           &color,
                           wc->font->fsp,
                           x,
                           y,
                           (FcChar8 *)str,
                           slen);
}
#else
int textwidth(wbp w, char *s, int n)
{
    return XTextWidth(w->context->font->fsp, s, n);
}

int utf8width(wbp w, char *s, int n, int nchars)
{
    return textwidth(w, s, n);
}

void drawstring(wbp w, int x, int y, char *s, int slen)
{ 
    STDLOCALS(w); 
    RENDER4(XDrawString, x, y, s, slen); 
}
void drawutf8(wbp w, int x, int y, char *s, int slen, int nchars)
{
    STDLOCALS(w); 
    RENDER4(XDrawString, x, y, s, slen);
}
#endif            /* HAVE_LIBXFT */

/*
 * allocate a display on machine s
 */
static wdp alcdisplay(char *s)
{
    wdp wd;

    if (s == NULL) s = getenv("DISPLAY");
    if (s == NULL) s = "";
    for(wd = wdsplys; wd; wd = wd->next)
        if (wd->program == curpstate && !strcmp(wd->name,s)) {
            wd->refcount++;
            return wd;
        }

    GRFX_ALLOC(wd, _wdisplay);

    strcpy(wd->name,s);
    wd->program = curpstate;
    wd->display = XOpenDisplay((*s=='\0') ? NULL : s);

    if (wd->display == NULL) {
        wd->refcount = 0;
        free(wd);
        return NULL;
    }

    wd->screen = DefaultScreen(wd->display);

    wd->black = new_sharedcolor("black", 0, 0, 0);
    wd->white = new_sharedcolor("white", 65535, 65535, 65535);

    wd->cmap = DefaultColormap(wd->display, wd->screen);

    /*
     * Initialize fonts and other things.
     */
#ifdef HAVE_LIBXFT
    wd->fonts = loadfont(wd, convert_spec(DEFAULTFONTNAME));
#else
    wd->fonts = loadfont(wd, DEFAULTFONTNAME);
#endif
    if (wd->fonts == NULL) {
        free(wd);
        return NULL;
    }
    wd->fonts->refcount = 1;
    wd->fonts->next = wd->fonts->previous = NULL;
#ifdef HAVE_LIBXFT
    wd->xfont = XLoadQueryFont(wd->display, "fixed");
#endif
    GRFX_LINK(wd, wdsplys);
    return wd;
}


#ifdef HAVE_LIBXFT

/*
 * Convert a given font spec, which may or may not be in icon font spec format,
 * into fontconfig (used by Xft) style format.  The result is never null.
 * 
 * To avoid ambiguity, a spec can start with "fc:" to indicate it's in fontconfig
 * format; otherwise parsefont is called to decide the format.
 */
static char *convert_spec(char *s)
{
    static char res[256];
    int flags, size;
    char family[MAXFONTWORD+1];
    XftPattern *p;

    if (!strncmp(s, "fc:", 3))
        return s + 3;

    if (!parsefont(s, family, &flags, &size))
        return s;

    p = XftPatternCreate();

    /*
     * Check first for special "standard" family names.
     */
    if (!strcmp(family, "fixed")) {
        XftPatternAddString(p, XFT_FAMILY, "Object Icon fixed");
        XftPatternAddString(p, XFT_FAMILY, "mono");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "mono")) {
        XftPatternAddString(p, XFT_FAMILY, "Object Icon mono");
        XftPatternAddString(p, XFT_FAMILY, "mono");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "typewriter")) {
        XftPatternAddString(p, XFT_FAMILY, "Object Icon typewriter");
        XftPatternAddString(p, XFT_FAMILY, "courier");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "sans")) {
        XftPatternAddString(p, XFT_FAMILY, "Object Icon sans");
        XftPatternAddString(p, XFT_FAMILY, "helvetica");
        flags |= FONTFLAG_PROPORTIONAL;
    }
    else if (!strcmp(family, "serif")) {
        XftPatternAddString(p, XFT_FAMILY, "Object Icon serif");
        XftPatternAddString(p, XFT_FAMILY, "times");
        flags |= FONTFLAG_PROPORTIONAL;
    }
    else
        XftPatternAddString(p, XFT_FAMILY, family);

    if (size > 0)
        XftPatternAddDouble(p, XFT_SIZE, (double)size);

    if (flags & FONTFLAG_MEDIUM)
        XftPatternAddInteger(p, XFT_WEIGHT, XFT_WEIGHT_MEDIUM);
    else if ((flags & FONTFLAG_DEMI) && (flags & FONTFLAG_BOLD))
        XftPatternAddInteger(p, XFT_WEIGHT, XFT_WEIGHT_DEMIBOLD);
    else if (flags & FONTFLAG_BOLD)
        XftPatternAddInteger(p, XFT_WEIGHT, XFT_WEIGHT_BOLD);
    else if (flags & FONTFLAG_LIGHT)
        XftPatternAddInteger(p, XFT_WEIGHT, XFT_WEIGHT_LIGHT);

    if (flags & FONTFLAG_ITALIC)
        XftPatternAddInteger(p, XFT_SLANT, XFT_SLANT_ITALIC);
    else if (flags & FONTFLAG_OBLIQUE)
        XftPatternAddInteger(p, XFT_SLANT, XFT_SLANT_OBLIQUE);
    else if (flags & FONTFLAG_ROMAN)
        XftPatternAddInteger(p, XFT_SLANT, XFT_SLANT_ROMAN);

    if (flags & FONTFLAG_PROPORTIONAL)
        XftPatternAddInteger(p, XFT_SPACING, XFT_PROPORTIONAL);
    if (flags & FONTFLAG_MONO)
        XftPatternAddInteger(p, XFT_SPACING, XFT_MONO);

    XftNameUnparse(p, res, sizeof(res) - 1);
    XftPatternDestroy(p);

    return res;
}

/*
 * allocate font s in the display attached to w
 */
static wfp alcfont(wbp w, char *s)
{
    return tryfont(w,convert_spec(s));
}


#else /* HAVE_LIBXFT */

/*
 * allocate font s in the display attached to w
 */
wfp alcfont(wbp w, char *s)
{
    int flags, size;
    wfp rv = NULL;
    char family[MAXFONTWORD+1];
    char *stdfam;

    /* Explicit X11 font name */
    if (!strncmp(s, "x11:", 4))
        return tryfont(w, s + 4);

    if (strcmp(s, "fixed") != 0 && parsefont(s, family, &flags, &size)) {
        /*
         * This is a legal Icon font spec (and it's not an unadorned "fixed").
         * Check first for special "standard" family names.
         */
        if (!strcmp(family, "mono")) {
            stdfam = "lucidatypewriter";
            flags |= FONTFLAG_MONO + FONTFLAG_SANS;
        }
        else if (!strcmp(family, "typewriter")) {
            stdfam = "courier";
            flags |= FONTFLAG_MONO + FONTFLAG_SERIF;
        }
        else if (!strcmp(family, "sans")) {
            stdfam = "helvetica";
            flags |= FONTFLAG_PROPORTIONAL + FONTFLAG_SANS;
        }
        else if (!strcmp(family, "serif")) {
            stdfam = "times";
            flags |= FONTFLAG_PROPORTIONAL + FONTFLAG_SERIF;
        }
        else stdfam = NULL;

        if (stdfam) {
            /*
             * Standard name: first try preferred family, then generalize.
             */
            rv = findfont(w, stdfam, size, flags);
            if (!rv)
                rv = findfont(w, "*", size, flags);
        }
        else {
            /*
             * Any other name: must match as specified.
             */
            rv = findfont(w, family, size, flags);
        }
        if (rv != NULL)
            return rv;
    }

    /*
     * Not found as an Icon name; may be an X font name.
     */
    return tryfont(w, s);
}

/*
 * return pointer to field i inside XLFD (X Logical Font Description) s.
 */
static char *xlfd_field(char *s, int i)
{
    int j = 0;
    while (j < i) {
        if (*s == '\0') return "";	/* if no such field */
        if (*s++ == '-') j++;
    }
    return s;
}

/*
 * return size of font, treating a scalable font as having size n
 */
static int xlfd_size(char *s, int n)
{
    char *f;
    int z;

    f = xlfd_field(s, XLFD_Size);
    if (!*f)
        return 0;
    z = atoi(f);
    if (z != 0)
        return z;
    else
        return n;
}

/*
 * Find the best font matching a set of specifications.
 */
static wfp findfont(wbp w, char *family, int size, int flags)
{
    char fontspec[MAXFONTWORD+100];
    char *p, *weight, *slant, *width, *spacing, **fontlist;
    int n, champ, challenger, bestsize;

    /*
     * Construct a font specification that enforces any stated requirements
     * of size, weight, slant, set width, or proportionality.
     */
    if (size > 0)
        bestsize = size;
    else
        bestsize = DEFAULTFONTSIZE;

    if (flags & FONTFLAG_MEDIUM)
        weight = "medium";
    else if ((flags & FONTFLAG_DEMI) && (flags & FONTFLAG_BOLD))
        weight = "demibold";
    else if (flags & FONTFLAG_BOLD)
        weight = "bold";
    else if (flags & FONTFLAG_DEMI)
        weight = "demi";
    else if (flags & FONTFLAG_LIGHT)
        weight = "light";
    else
        weight = "*";

    if (flags & FONTFLAG_ITALIC)
        slant = "i";
    else if (flags & FONTFLAG_OBLIQUE)
        slant = "o";
    else if (flags & FONTFLAG_ROMAN)
        slant = "r";
    else
        slant = "*";

    if (flags & FONTFLAG_NARROW)
        width = "narrow";
    else if (flags & FONTFLAG_CONDENSED)
        width = "condensed";
    else if (flags & FONTFLAG_NORMAL)
        width = "normal";
    else if (flags & FONTFLAG_WIDE)
        width = "wide";
    else if (flags & FONTFLAG_EXTENDED)
        width = "extended";
    else
        width = "*";

    if (flags & FONTFLAG_PROPORTIONAL)
        spacing = "p";
    else
        spacing = "*";			/* can't specify {m or c} to X */

    sprintf(fontspec, "-*-%s-%s-%s-%s-*-*-*-*-*-%s-*-*-*",
            family, weight, slant, width, spacing);

    /*
     * Get a list of matching fonts from the X server and find the best one.
     */
    fontlist = XListFonts(w->window->display->display, fontspec, 2500, &n);
    champ = 0;
    while (champ < n && !okfont(fontlist[champ], size, flags))
        champ++;
    if (champ >= n) {
        XFreeFontNames(fontlist);
        return NULL;			/* nothing acceptable */
    }
    for (challenger = champ + 1; challenger < n; challenger++) 
        if (okfont(fontlist[challenger], size, flags)
            && fontcmp(fontlist[challenger], fontlist[champ], bestsize, flags) < 0)
            champ = challenger;

    /*
     * Set the scaling field, if needed, and load the font.
     */
    p = xlfd_field(fontlist[champ], XLFD_Size);
    if (p[0] == '0' && p[1] == '-')
        sprintf(fontspec, "%.*s%d%s", (int)(p - fontlist[champ]),
                fontlist[champ], bestsize, p + 1);
    else
        strcpy(fontspec, fontlist[champ]);
    XFreeFontNames(fontlist);
    return tryfont(w, fontspec);
}

/*
 * check for minimum acceptability of a font
 * (things that couldn't be filtered by the XLFD pattern):
 * -- size wrong (there's a bug in OpenWindows 3.3 else X could do it)
 * -- not monospaced (can't set pattern to match m or c but not p)
 */
static int okfont(char *spec, int size, int flags)
{
    if (size > 0 && xlfd_size(spec, size) != size)
        return 0;			/* can't match explicit size request */
    if ((flags & FONTFLAG_MONO) && xlfd_field(spec, XLFD_Spacing)[0] == 'p')
        return 0;			/* requested mono, but this isn't */
    return 1;
}

/*
 * rank two fonts based on whether XLFD field n matches a preferred value.
 * returns <0 if font1 is better, >0 if font2 is better, else 0.
 */
static int fieldcmp(char *font1, char *font2, char *value, int field)
{
    int len, r1, r2;

    len = strlen(value);
    r1 = (strncmp(xlfd_field(font1, field), value, len) == 0);
    r2 = (strncmp(xlfd_field(font2, field), value, len) == 0);
    return r2 - r1;			/* -1, 0, or 1 */
}

/*
 * rank two fonts.
 * returns <0 if font1 is better, >0 if font2 is better, else 0.
 *
 * Note that explicit requests for size, slant, weight, and width caused
 * earlier filtering in findfont(), so all those flags aren't checked
 * again here; normal values are just favored in case nothing was specified.
 */
static int fontcmp(char *font1, char *font2, int size, int flags)
{
    int n;

/* return if exactly one of the fonts matches value s in field n */
#define PREFER(s,n)                                                     \
    do { int r = fieldcmp(font1, font2, s, n); if (r != 0) return r; } while (0)

/* return if exactly one of the fonts does NOT match value s in field n */
#define SPURN(s,n)                                                      \
    do { int r = fieldcmp(font1, font2, s, n); if (r != 0) return -r; } while (0)

    /*
     * Prefer the font that is closest to the desired size.
     */
    n = abs(size - xlfd_size(font1, size)) - abs(size - xlfd_size(font2, size));
    if (n != 0)
        return n;

    /*
     * try to check serifs (though not always indicated in X font description)
     */
    if (flags & FONTFLAG_SANS) {
        PREFER("sans", XLFD_AddStyle);
        SPURN("serif", XLFD_AddStyle);
    }
    else if (flags & FONTFLAG_SERIF) {
        PREFER("serif", XLFD_AddStyle);
        SPURN("sans", XLFD_AddStyle);
    }

    /*
     * prefer normal values for other fields.  These only have an effect
     * for fields that were wildcarded when requesting the font list.
     */
    PREFER("r", XLFD_Slant);		/* prefer roman slant */
    PREFER("medium", XLFD_Weight);	/* prefer medium weight */
    SPURN("demi", XLFD_Weight);		/* prefer non-demi if no medium */
    PREFER("normal", XLFD_SetWidth);	/* prefer normal width */
    PREFER("iso8859", XLFD_CharSet);	/* prefer font of ASCII chars */
    SPURN("0", XLFD_PointSize);		/* prefer tuned font to scaled */
    PREFER("adobe", XLFD_Foundry);	/* these look better than others */

    /* no significant difference */
    return 0;
}


#endif /* HAVE_LIBXFT */


/*
 * load a font and return a font structure.
 */

static wfp tryfont(wbp w, char *s)
{
    wdp wd = w->window->display;
    wfp rv;
    /*
     * see if the font is already loaded on this display
     */
    for(rv = wd->fonts; rv != NULL; rv = rv->next) {
#ifdef HAVE_LIBXFT
        if (!strcmp(s, rv->name + 3)) break;
#else
        if (!strcmp(s, rv->name + 4)) break;
#endif
    }
    if (rv != NULL) {
        rv->refcount++;
        return rv;
    }
    /*
     * load a new font
     */
    rv = loadfont(wd, s);
    if (rv == NULL) {
        return NULL;
    }

    /*
     * link the font into this display's fontlist (but not at the head!)
     */
    rv->next = wd->fonts->next;
    rv->previous = wd->fonts;
    if (wd->fonts->next) wd->fonts->next->previous = rv;
    wd->fonts->next = rv;
    return rv;
}

static wfp loadfont(wdp wd, char *s)
{
    wfp rv;
    GRFX_ALLOC(rv, _wfont);
#ifdef HAVE_LIBXFT
    rv->fsp = XftFontOpenName(wd->display, wd->screen, s);
#else
    rv->fsp = XLoadQueryFont(wd->display, s);
#endif
    if (rv->fsp == NULL){
        free(rv);
        return NULL;
    }

#ifdef HAVE_LIBXFT
    MemProtect(rv->name = malloc(strlen(s) + 3 + 1));
    sprintf(rv->name, "fc:%s", s);
    {
        XGlyphInfo	extents; 
        /*
         * Xft seems to sometimes give too-small values in its font
         * ascent/descent fields; therefore calculate the GlyphInfo
         * for the first 256 chars and take the maximum ascent/descent
         * of the sample and the font's reported values.
         */
        XftTextExtents8 (wd->display,
                         rv->fsp,
                         (FcChar8 *)allchars,
                         256,
                         &extents);
        rv->ascent = Max(rv->fsp->ascent, extents.y);
        rv->descent = Max(rv->fsp->descent, extents.height - extents.y);
        rv->maxwidth = rv->fsp->max_advance_width;
    }
#else
    MemProtect(rv->name = malloc(strlen(s) + 4 + 1));
    sprintf(rv->name, "x11:%s", s);
    rv->ascent = rv->fsp->ascent;
    rv->descent = rv->fsp->descent;
    rv->maxwidth = rv->fsp->max_bounds.width;
#endif
    rv->height = rv->ascent + rv->descent;
    return rv;
}


/*
 * allocate a context.  Can't be called until w has a display and window.
 */
static wcp alccontext(wbp w)
{
    wcp wc;
    wdp wd = w->window->display;

    GRFX_ALLOC(wc, _wcontext);
    wc->serial = ++context_serial;
    wc->display = wd;
    wd->refcount++;
    wc->bg = link_sharedcolor(wd->white);
    wc->fg = link_sharedcolor(wd->black);
    wc->font = wd->fonts;
    wc->drawop = stringint_lookup(drawops, "copy");
    wc->clipx = wc->clipy = 0;
    wc->clipw = wc->cliph = -1;
    wc->linewidth = 1;
    wc->fillstyle = stringint_lookup(fillstyles, "solid");
    wc->linestyle = stringint_lookup(linestyles, "solid");

    GRFX_LINK(wc, wcntxts);
    return wc;
}

/*
 * allocate a context, cloning attributes from an existing context
 */
wcp clonecontext(wbp w)
{
    wcp wc, rv;
    wdp wd;
    XGCValues gcv;
    XRectangle rec;
    unsigned long gcmask = GCFont | GCForeground | GCBackground |
        GCFillStyle | GCCapStyle | GCLineWidth | GCLineStyle;

    wc = w->context;
    wd = w->context->display;
    rv = alccontext(w);

    rv->dx = wc->dx;
    rv->dy = wc->dy;
    rv->clipx = wc->clipx;
    rv->clipy = wc->clipy;
    rv->clipw = wc->clipw;
    rv->cliph = wc->cliph;
    rv->fg = link_sharedcolor(wc->fg);
    rv->bg = link_sharedcolor(wc->bg);
    rv->font = wc->font;
    rv->font->refcount++;
    rv->fillstyle = wc->fillstyle;
    rv->linestyle = wc->linestyle;
    rv->linewidth = wc->linewidth;
    rv->drawop = wc->drawop;
    rv->bits = wc->bits;

    gcv.foreground = rv->fg->c;
    gcv.background = rv->bg->c;
#ifdef HAVE_LIBXFT
    gcv.font       = wd->xfont->fid;
#else
    gcv.font       = rv->font->fsp->fid;
#endif
    gcv.line_style = rv->linestyle->i;
    gcv.line_width = rv->linewidth;
    if (rv->linewidth > 1) {
        gcv.dashes = 3 * rv->linewidth;
        gcmask |= GCDashList;
    }
    gcv.fill_style = rv->fillstyle->i;
    gcv.cap_style  = CapProjecting;
    MemProtect(rv->gc = XCreateGC(w->window->display->display,w->window->pix,gcmask,&gcv));
    if (rv->clipw >= 0) {
        rec.x = rv->clipx;
        rec.y = rv->clipy;
        rec.width = rv->clipw;
        rec.height = rv->cliph;
        XSetClipRectangles(rv->display->display, rv->gc, 0, 0, &rec, 1,Unsorted);
    }
    if (wc->patternname)
        rv->patternname = salloc(wc->patternname);
    return rv;
}

/*
 * allocate a window state structure
 */
static wsp alcwinstate()
{
    wsp ws;
    GRFX_ALLOC(ws, _wstate);
    ws->serial = ++canvas_serial;
    ws->bits = 1024;				/* echo ON; others OFF */
    ws->listp = nulldesc;
    ws->cursor = stringint_lookup(cursors, "left ptr");
    ws->inputmask =
        ExposureMask | KeyPressMask |
        ButtonPressMask | ButtonReleaseMask | ButtonMotionMask |
        StructureNotifyMask;
    ws->iconic = NormalState;
    ws->x = ws->y = -INT_MAX;
    ws->minwidth = ws->minheight = 1;
    ws->maxwidth = ws->maxheight = INT_MAX;
#ifdef HAVE_LIBXFT
    ws->pixDraw = ws->winDraw = NULL;
#endif
    ws->height = 200;
    ws->width  = 200;
    ws->windowlabel = salloc(DEFAULT_WINDOW_LABEL);
    GRFX_LINK(ws, wstates);
    return ws;
}

/*
 * free a window state
 */
void freewindow(wsp ws)
{
    ws->refcount--;
    if(ws->refcount == 0) {
        struct imgdata *imd;

        ws->bits |= 1;			/* SETZOMBIE */
#ifdef HAVE_LIBXFT
        if (ws->winDraw) {
            XftDrawDestroy(ws->winDraw);
            ws->winDraw = NULL;
        }
        if (ws->pixDraw) {
            XftDrawDestroy(ws->pixDraw);
            ws->pixDraw = NULL;
        }
#endif
        if (ws->win != (Window) NULL) {
            XDestroyWindow(ws->display->display, ws->win);
            XFlush(ws->display->display);
            while (ws->win != (Window) NULL)
                pollevent();
        }
        else {
            /*
             * There was no XDestroyWindow, so it is necessary
             * to free the Pixmap here, as it won't be freed via
             * a DestroyNotify event.
             */
            if (ws->pix != (Pixmap) NULL) {
                Display *d = ws->display->display;
                XFreePixmap(d, ws->pix);
                ws->pix = (Pixmap) NULL;
            }
        }

        imd = &ws->initimage;
        if (imd->width) {
            free(imd->paltbl);
            free(imd->data);
            imd->width = 0;
        }

       if (ws->windowlabel) { 
           free(ws->windowlabel); 
           ws->windowlabel = 0;
       }

        GRFX_UNLINK(ws, wstates);
    }
}

/*
 * free a window context
 */
void freecontext(wcp wc)
{
    wc->refcount--;
    if(wc->refcount == 0) {
        if (wc->gc != NULL)
            XFreeGC(wc->display->display, wc->gc);
        if (wc->patternname)
            free(wc->patternname);
        if (wc->fg)
            unlink_sharedcolor(wc->fg);
        if (wc->bg)
            unlink_sharedcolor(wc->bg);
        free_display(wc->display);
        GRFX_UNLINK(wc, wcntxts);
    }
}

/*
 * free a display
 */
static void free_display(wdp wd)
{
    wd->refcount--;
    if(wd->refcount == 0) {
        if (wd->cmap != DefaultColormap(wd->display, wd->screen))
            XFreeColormap(wd->display, wd->cmap);
        XCloseDisplay(wd->display);
        if (wd->previous) wd->previous->next = wd->next;
        else wdsplys = wd->next;
        if (wd->next) wd->next->previous = wd->previous;
        free(wd);
    }
}

int  readimagefileimpl(char *filename, struct imgdata *imd) 
{
    return NoCvt;
}

int  writeimagefileimpl(wbp w, char *filename, int x, int y, int width, int height)
{
    return NoCvt;
}


#endif            /* Graphics */
