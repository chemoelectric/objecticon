/*
 * File: rxwin.ri - X11 system-specific graphics interface code.
 */

#define GetDepth(wd) DefaultDepth((wd)->display,DefaultScreen((wd)->display))
#define GetVisual(wd) DefaultVisual((wd)->display,DefaultScreen((wd)->display))
#define GetRoot(wd) DefaultRootWindow((wd)->display)

#define UpdateRecent(ws, ev) (ws)->display->recent = (ev)->time

/*
 * Poly edge and mode attributes to use with Pictures we draw onto
 * (pixwin and mask).
 */
#define PolyEdge PolyEdgeSmooth
#define PolyMode PolyModeImprecise

/*
 * Global variables specific to X
 */
static wdp wdsplys;

struct lineinfo {
    double dx, dy;
    double len;
    XPointDouble p0, q0, p1, p2, q1, q2;
};

struct traplist
{
    XTrapezoid *traps;
    int n;
    int alloc;
};

/*
 * function prototypes
 */
static void handle_config(wsp w, XConfigureEvent *event);
static void handle_property(wsp ws, XPropertyEvent *event);
static void handle_exposures(wsp ws, XExposeEvent *event);
static void handle_mouse(wsp ws, XButtonEvent *event);
static void handle_keypress(wsp ws, XKeyEvent *event);
static void handle_crossing(wsp ws, XCrossingEvent *event);
static char *get_progname(void);
static void wmap(wbp w);
static wsp wsp_for_Window(wdp wd, Window w);
static void synch_cursor(wsp ws);
static void synch_cursors(wdp wd, struct wcursor *c);
static void setup_cursors(wdp wd);
static void setup_cursor(wdp wd, char *name, int id);
static struct SharedCursor *new_sharedcursor(wdp wd, Cursor cursor);
static struct SharedCursor *link_sharedcursor(struct SharedCursor *x);
static void unlink_sharedcursor(struct SharedCursor *x);
static struct wcursor *lookup_wcursor(wdp wd, char *name);
static struct wcursor *ensure_wcursor(wdp wd, char *name);
static int convert_KeySym_to_code_point(KeySym k);
static wfp newfont(wdp wd, char *s);
static wdp alcdisplay (char *s);
static void resizepixmap(wbp w);
static void clip(wbp w);
static void no_clip(wsp ws, int and_win);
static int make_mod(unsigned int state);
static char* property_to_string(wdp wd, Atom target, int number_items, void* data);
static Atom convert_target(wdp wd, Atom desired_target);
static void get_atom_descriptor(wdp wd, Atom a, dptr dest);
static void synch_state(wsp ws);
static void synch_state1(wsp ws);
static void synch_net_wm_state(wsp ws, int desired_state);
static void close_screen_win(wsp ws);
static void fill2(wbp w, int op, XRenderColor  *color, int x, int y, int width, int height);
static void pat1(wbp w, int x, int y, int width, int height);
static void pat2(wbp w, int x, int y, int width, int height);
static void maskpic2(wbp w, Picture mask, int x, int y, int width, int height);
static Picture get_draw_picture(wcp wc);
static void pix_to_win(wsp ws, int x, int y, int width, int height);
static void synch_pix_and_win(wsp ws, int x, int y, int width, int height);
static Picture getmask(wdp wd, int width, int height);
static XPointDouble doublept(double x, double y);
static XTrapezoid trapezoid(double top, double x1, double x2, double bottom, double x3, double x4);
static int needmask(wcp wc, int overlap);
static void drawlineinfos(wbp w, struct lineinfo *lis, int nlis, int closed);
static void getlineinfo(wcp wc, XPointDouble *p0, XPointDouble *q0, struct lineinfo *res);
static wcp clonecontext(wcp wc);
static void freecontext(wcp wc);
static void freewindow(wsp ws);
static void apply_windowlabel(wsp ws);
static void apply_windowicon(wsp ws);
static double calc_pt(double *x, double *y, double rx, double ry, double th);
static double calc_progress_factor(double rx, double ry);
static void synch_pos(wsp ws);
static int limit_strlen(word n);
static char *get_atom_name(wdp wd, Atom a);
static void mk_hints(wsp ws, XSizeHints *h);
static char *resource_name, *resource_class, *display;
static XPointDouble intersect(XPointDouble *a1, XPointDouble *a2, XPointDouble *b1, XPointDouble *b2);
static void init_traplist(struct traplist *l, int alloc);
static void free_traplist(struct traplist *l);
static void draw_traplist(struct traplist *l, Display *display, int op, Picture src, Picture dest);
static void add_trap(struct traplist *l, double top, double x1, double x2, double bottom, double x3, double x4);
static void add_rect(struct traplist *l, XPointDouble *tl, XPointDouble *br);
static void add_tri(struct traplist *l, XPointDouble *p1, XPointDouble *p2, XPointDouble *p3);

static void CompositeDoublePoly(Display *, int, Picture, Picture, XRenderPictFormat *,
                                int, int, int, int, XPointDouble *, int, int);

static stringint drawops[] = {
   { 0, 12},
   {"atop",  PictOpAtop},
   {"clear",  PictOpClear},
   {"dest",  PictOpDst},
   {"dest atop",  PictOpAtopReverse},
   {"dest in",  PictOpInReverse},
   {"dest out",  PictOpOutReverse},
   {"dest over",  PictOpOverReverse},
   {"in",  PictOpIn},
   {"out",  PictOpOut},
   {"over",  PictOpOver},
   {"source",  PictOpSrc},
   {"xor",  PictOpXor},
};

static stringint linejoins[] = {
    {0, 3},
    {"bevel",     JoinBevel},
    {"miter",     JoinMiter},
    {"round",     JoinRound},
};

static stringint lineends[] = {
    {0, 4},
    {"flat",      EndFlat},
    {"point",     EndPoint},
    {"round",     EndRound},
    {"square",    EndSquare},
};

static stringint canvastypes[] = {
    {0, 9},
    {"fullscreen",  FullScreenState},
    {"hidden",      HiddenState},
    {"iconic",      IconicState},
    {"maximized",   MaximizedState},
    {"normal",      NormalState},
    {"popup",       PopupState},
    {"root",        RootState},
    {"shaded",      ShadedState},
    {"withdrawn",   WithdrawnState},
};

static const int selection_debug = 0;

#if 0
static void dump_all(void)
{
    int i,j,k;
    wsp x;
    wbp y;
    i = 0;
    for (y = wbndngs; y; y = y->next) {
        printf("Binding %p\n",y);
        printf("\tcanvas %p\n",y->window);
        printf("\tcontext %p\n",y->context);
        ++i;
    }
    printf("============\n");
    j = 0;
    for (x = wstates; x; x = x->next) {
        printf("Canvas %p\n",x);
        printf("\trefcount=%d\n", x->refcount);
        printf("\tlabel=%s\n", x->windowlabel);
        printf("\tgeometry=%d,%d %dx%d\n", x->x,x->y,x->width,x->height);
        printf("\twin=%d\n", (int)x->win);
        ++j; 
    }
    printf("============\n");
    k = 0;
    for (x = vwstates; x; x = x->vnext) {
        printf("Non-hidden Canvas %p\n",x);
        printf("\trefcount=%d\n", x->refcount);
        printf("\tlabel=%s\n", x->windowlabel);
        printf("\tgeometry=%d,%d %dx%d\n", x->x,x->y,x->width,x->height);
        printf("\twin=%d\n", (int)x->win);
        ++k; 
    }

    printf("Total %d bindings %d canvases (%d non-hidden)\n",i,j,k);
}
#endif
#if 0
static void dump_ximage(XImage *xi)
{
    int i,j;
    printf("XImage=%p\n",xi);
    printf("\twidth, height=%d %d\n", xi->width, xi->height);            /* size of image */
    printf("\txoffset=%d\n", xi->xoffset);                  /* number of pixels offset in X direction */
    printf("\tformat=%d\n", xi->format);                  /* XYBitmap, XYPixmap, ZPixmap */
    printf("\tbyte_order=%d\n", xi->byte_order);               /* data byte order, LSBFirst, MSBFirst */
    printf("\tbitmap_unit =%d\n", xi->bitmap_unit);             /* quant. of scanline 8, 16, 32 */
    printf("\tbitmap_bit_order =%d\n", xi->bitmap_bit_order);        /* LSBFirst, MSBFirst */
    printf("\tbitmap_pad   =%d\n", xi->bitmap_pad);            /* 8, 16, 32 either XY or ZPixmap */
    printf("\tdepth  =%d\n", xi->depth);              /* depth of image */
    printf("\tbytes_per_line=%d\n", xi->bytes_per_line);          /* accelerator to next scanline */
    printf("\tbits_per_pixel=%d\n", xi->bits_per_pixel);        /* bits per pixel (ZPixmap) */
    printf("\tred_mask=%lx\n", xi->red_mask);       /* bits in z arrangement */
    printf("\tgreen_mask=%lx\n", xi->green_mask);
    printf("\tblue_mask=%lx\n", xi->blue_mask);
    printf("\n");
    printf("\nPixel dump of region size %d,%d\n",xi->width,xi->height);
    
    for (j=0; j < xi->height; ++j) {
        unsigned long c0=-1;
        printf("\nrow %d:",j);
        for (i = 0; i < xi->width; ++i) {
            unsigned long c;            
            c=XGetPixel(xi,i,j);
            if (c!=c0) {
                printf("%lx ",c);
                c0=c;
            } else
                printf("-");
        }
    }
    printf("\n");
}



#endif

#define ATOM(d, x) ((d)->atoms[ATOM_##x])

struct SharedPicture *new_sharedpicture(wdp wd, struct imgdata *imd)
{
    struct SharedPicture *res;
    XRenderPictureAttributes pa;
    GAlloc(res, SharedPicture);
    res->wd = wd;
    res->pix = imgdata_to_Pixmap(wd, imd);
    pa.repeat = 1;
    res->i = XRenderCreatePicture(wd->display, res->pix, wd->pixfmt, CPRepeat, &pa);
    res->width = imd->width;
    res->height = imd->height;
    return res;
}

struct SharedPicture *link_sharedpicture(struct SharedPicture *x)
{
    ++x->refcount;
    return x;
}

void unlink_sharedpicture(struct SharedPicture *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        if (x->i)
            XRenderFreePicture(x->wd->display, x->i);
        if (x->pix)
            XFreePixmap(x->wd->display, x->pix);
        free(x);
    }
}

struct SharedColor *new_sharedcolor(wdp wd, char *name, int r, int g, int b, int a)
{
    struct SharedColor *res;
    GAlloc(res, SharedColor);
    res->wd = wd;
    res->color.red = Mul16(r, a);
    res->color.green = Mul16(g, a);
    res->color.blue = Mul16(b, a);
    res->color.alpha = a;
    res->brush = XRenderCreateSolidFill(wd->display, &res->color);
    res->name = salloc(name);
    return res;
}

struct SharedColor *link_sharedcolor(struct SharedColor *x)
{
    ++x->refcount;
    return x;
}

void unlink_sharedcolor(struct SharedColor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        XRenderFreePicture(x->wd->display, x->brush);
        free(x->name);
        free(x);
    }
}

static struct SharedCursor *new_sharedcursor(wdp wd, Cursor cursor)
{
    struct SharedCursor *res;
    GAlloc(res, SharedCursor);
    res->wd = wd;
    res->cursor = cursor;
    return res;
}

static struct SharedCursor *link_sharedcursor(struct SharedCursor *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedcursor(struct SharedCursor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        XFreeCursor(x->wd->display, x->cursor);
        free(x);
    }
}

static struct wcursor *lookup_wcursor(wdp wd, char *name)
{
    struct wcursor *rv;
    int i;
    i = hasher(hashcstr(name), wd->cursors);
    for(rv = wd->cursors[i]; rv; rv = rv->next) {
        if (!strcmp(name, rv->name))
            return rv;
    }
    return 0;
}

static struct wcursor *ensure_wcursor(wdp wd, char *name)
{
    struct wcursor *rv;
    int i;
    i = hasher(hashcstr(name), wd->cursors);
    for(rv = wd->cursors[i]; rv; rv = rv->next) {
        if (!strcmp(name, rv->name))
            return rv;
    }
    rv = safe_zalloc(sizeof(struct wcursor));
    rv->name = salloc(name);
    rv->next = wd->cursors[i];
    wd->cursors[i] = rv;
    return rv;
}

void restore(wbp w, int x, int y, int width, int height)
{
    synch_pix_and_win(w->window, x, y, width, height);
}

int definepointer(wbp w, char *name, struct imgdata *imd, int x, int y)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    Pixmap pix;
    Picture pic;
    struct wcursor *rv;
    Cursor nc;

    pix = imgdata_to_Pixmap(wd, imd);
    pic = XRenderCreatePicture(wd->display, pix, wd->pixfmt, 0, 0);
    nc = XRenderCreateCursor(wd->display, pic, x, y);
    rv = ensure_wcursor(wd, name);
    if (rv->shared_cursor) {
        struct SharedCursor *tmp = rv->shared_cursor;
        rv->shared_cursor = new_sharedcursor(wd, nc);
        synch_cursors(wd, rv);
        unlink_sharedcursor(tmp);
    } else
        rv->shared_cursor = new_sharedcursor(wd, nc);

    XFreePixmap(wd->display, pix);
    XRenderFreePicture(wd->display, pic);
    return Succeeded;
}

static void synch_cursors(wdp wd, struct wcursor *c)
{
    wsp x;
    for (x = wd->vwstates; x; x = x->vnext) {
        if (x->cursor == c)
            synch_cursor(x);
    }
}

int copypointer(wbp w, char *dest, char *src)
{
    struct wcursor *sc, *dc;
    wdp wd = w->window->display;
    sc = lookup_wcursor(wd, src);
    if (!sc)
        return Failed;
    dc = ensure_wcursor(wd, dest);
    if (sc != dc) {
        if (dc->shared_cursor) {
            struct SharedCursor *tmp = dc->shared_cursor;
            dc->shared_cursor = link_sharedcursor(sc->shared_cursor);
            synch_cursors(wd, dc);
            unlink_sharedcursor(tmp);
        } else
            dc->shared_cursor = link_sharedcursor(sc->shared_cursor);
    }
    return Succeeded;
}

static void setup_cursor(wdp wd, char *name, int id)
{
    int i;
    struct wcursor *rv;
    i = hasher(hashcstr(name), wd->cursors);
    rv = safe_zalloc(sizeof(struct wcursor));
    rv->name = name;
    rv->shared_cursor = new_sharedcursor(wd, XCreateFontCursor(wd->display, id));
    rv->next = wd->cursors[i];
    wd->cursors[i] = rv;
}

static void setup_cursors(wdp wd)
{
    setup_cursor(wd, "X cursor",	XC_X_cursor);
    setup_cursor(wd, "arrow",		XC_arrow);
    setup_cursor(wd, "based arrow down",XC_based_arrow_down);
    setup_cursor(wd, "based arrow up",	XC_based_arrow_up);
    setup_cursor(wd, "boat",		XC_boat);
    setup_cursor(wd, "bogosity",	XC_bogosity);
    setup_cursor(wd, "bottom left corner",XC_bottom_left_corner);
    setup_cursor(wd, "bottom right corner",XC_bottom_right_corner);
    setup_cursor(wd, "bottom side",	XC_bottom_side);
    setup_cursor(wd, "bottom tee",	XC_bottom_tee);
    setup_cursor(wd, "box spiral",	XC_box_spiral);
    setup_cursor(wd, "center ptr",	XC_center_ptr);
    setup_cursor(wd, "circle",		XC_circle);
    setup_cursor(wd, "clock",		XC_clock);
    setup_cursor(wd, "coffee mug",	XC_coffee_mug);
    setup_cursor(wd, "cross",		XC_cross);
    setup_cursor(wd, "cross reverse",	XC_cross_reverse);
    setup_cursor(wd, "crosshair",	XC_crosshair);
    setup_cursor(wd, "diamond cross",	XC_diamond_cross);
    setup_cursor(wd, "dot",		XC_dot);
    setup_cursor(wd, "dotbox",		XC_dotbox);
    setup_cursor(wd, "double arrow",	XC_double_arrow);
    setup_cursor(wd, "draft large",	XC_draft_large);
    setup_cursor(wd, "draft small",	XC_draft_small);
    setup_cursor(wd, "draped box",	XC_draped_box);
    setup_cursor(wd, "exchange",	XC_exchange);
    setup_cursor(wd, "fleur",		XC_fleur);
    setup_cursor(wd, "gobbler",		XC_gobbler);
    setup_cursor(wd, "gumby",		XC_gumby);
    setup_cursor(wd, "hand1",		XC_hand1);
    setup_cursor(wd, "hand2",		XC_hand2);
    setup_cursor(wd, "heart",		XC_heart);
    setup_cursor(wd, "icon",		XC_icon);
    setup_cursor(wd, "iron cross",	XC_iron_cross);
    setup_cursor(wd, "left ptr",	XC_left_ptr);
    setup_cursor(wd, "left side",	XC_left_side);
    setup_cursor(wd, "left tee",	XC_left_tee);
    setup_cursor(wd, "leftbutton",	XC_leftbutton);
    setup_cursor(wd, "ll angle",	XC_ll_angle);
    setup_cursor(wd, "lr angle",	XC_lr_angle);
    setup_cursor(wd, "man",		XC_man);
    setup_cursor(wd, "middlebutton",	XC_middlebutton);
    setup_cursor(wd, "mouse",		XC_mouse);
    setup_cursor(wd, "pencil",		XC_pencil);
    setup_cursor(wd, "pirate",		XC_pirate);
    setup_cursor(wd, "plus",		XC_plus);
    setup_cursor(wd, "question arrow",	XC_question_arrow);
    setup_cursor(wd, "right ptr",	XC_right_ptr);
    setup_cursor(wd, "right side",	XC_right_side);
    setup_cursor(wd, "right tee",	XC_right_tee);
    setup_cursor(wd, "rightbutton",	XC_rightbutton);
    setup_cursor(wd, "rtl logo",	XC_rtl_logo);
    setup_cursor(wd, "sailboat",	XC_sailboat);
    setup_cursor(wd, "sb down arrow",	XC_sb_down_arrow);
    setup_cursor(wd, "sb h double arrow",	XC_sb_h_double_arrow);
    setup_cursor(wd, "sb left arrow",	XC_sb_left_arrow);
    setup_cursor(wd, "sb right arrow",	XC_sb_right_arrow);
    setup_cursor(wd, "sb up arrow",	XC_sb_up_arrow);
    setup_cursor(wd, "sb v double arrow",	XC_sb_v_double_arrow);
    setup_cursor(wd, "shuttle",		XC_shuttle);
    setup_cursor(wd, "sizing",		XC_sizing);
    setup_cursor(wd, "spider",		XC_spider);
    setup_cursor(wd, "spraycan",	XC_spraycan);
    setup_cursor(wd, "star",		XC_star);
    setup_cursor(wd, "target",		XC_target);
    setup_cursor(wd, "tcross",		XC_tcross);
    setup_cursor(wd, "top left arrow",	XC_top_left_arrow);
    setup_cursor(wd, "top left corner",	XC_top_left_corner);
    setup_cursor(wd, "top right corner",XC_top_right_corner);
    setup_cursor(wd, "top side",	XC_top_side);
    setup_cursor(wd, "top tee",		XC_top_tee);
    setup_cursor(wd, "trek",		XC_trek);
    setup_cursor(wd, "ul angle",	XC_ul_angle);
    setup_cursor(wd, "umbrella",	XC_umbrella);
    setup_cursor(wd, "ur angle",	XC_ur_angle);
    setup_cursor(wd, "watch",		XC_watch);
    setup_cursor(wd, "xterm",		XC_xterm);
}

#begdef CheckUnhidden(ws)
do {
   if (!ws->win) {
      LitWhy("Window is hidden");
      return Failed;
   }
} while(0)
#enddef

/*
 * A convenient wrapper around XGetAtomName, which returns a pointer
 * to a static string.
 */
static char *get_atom_name(wdp wd, Atom a)
{
    static char *t;
    /* XGetAtomName raises an error on None. */
    if (a == None)
        return "(None)";
    if (t)
        XFree(t);
    MemProtect(t = XGetAtomName(wd->display, a));
    return t;
}

/*
 * Get the string name of the given Atom into the descriptor pointed
 * to by dest, which should be tended.
 */
static void get_atom_descriptor(wdp wd, Atom a, dptr dest)
{
    cstr2string(get_atom_name(wd, a), dest);
}

static Atom convert_target(wdp wd, Atom desired_target)
{
    /* Check for common cases. */
    if ( (desired_target == ATOM(wd, TIMESTAMP))    ||
         (desired_target == ATOM(wd, LIST_LENGTH) ) ||
         (desired_target == ATOM(wd, SPAN) ) ||
         (desired_target == ATOM(wd, CHARACTER_POSITION) ) ||
         (desired_target == ATOM(wd, LENGTH) ) ) {
        return XA_INTEGER;
    }

    if ( desired_target == ATOM(wd, TARGETS) ) {
        return XA_ATOM;
    }

    if ( desired_target == ATOM(wd, CLIENT_WINDOW) ) {
        return XA_WINDOW;
    }

    /* Otherwise, no need to convert target. */
    return desired_target;
}

static char* property_to_string(wdp wd, Atom target, int number_items, void* data)
{
    char *result = 0;
    int i, length;

    /* Convert target, if necessary. */
    target = convert_target(wd, target);

    switch (target) {
        case XA_ATOM: {
            int curr_len, total_len;
            unsigned long *long_array = (unsigned long *)data;

            length = 32;
            result = safe_malloc(length);
            *result = 0;
            total_len = 0;

            /* Convert to atom names. */
            for (i = 0; i < number_items; i++) { 
                char *atom_name = get_atom_name(wd, long_array[i]);
                curr_len = strlen(atom_name) + 1;    /* +1 for the \n */
                if (total_len + curr_len + 1 > length) {  /* +1 for the \0 */
                    length = total_len + curr_len + 1;
                    result = safe_realloc(result, length);
                }
                sprintf(result + total_len, "%s\n", atom_name);
                total_len += curr_len;
            }
            break;
        }
        case XA_INTEGER: {
            long *long_array = (long *)data;
            length = number_items * 20 + 1;
            result = safe_malloc(length);
            *result = 0;
            for (i = 0; i < number_items; i++) {
                if (i > 0)
                    strcat(result, " ");
                sprintf(result + strlen(result), "%ld", long_array[i]);
            }
            break;
        }
        case XA_WINDOW: {
            unsigned long *long_array = (unsigned long *)data;
            length = number_items * 12 + 1;
            result = safe_malloc(length);
            *result = 0;
            for (i = 0; i < number_items; i++) {
                if (i > 0)
                    strcat(result, " ");
                sprintf(result + strlen(result), "0x%8.8lu", long_array[i]);
            }
            break;
        }
    }

    return result;
}

static wsp wsp_for_Window(wdp wd, Window w)
{
    wsp ws;
    for (ws = wd->vwstates; ws; ws = ws->vnext) {
        if (ws->win == w)
            return ws;
    }
    return 0;
}

void pollevent(wbp w)
{
    wdp wd = w->window->display;
    XEvent event;
    Window evwin;
    wsp ws;
    while (XPending(wd->display)) {
        XNextEvent(wd->display, &event);
        evwin = event.xexpose.window;  /* go ahead, criticize all you like */
        ws = wsp_for_Window(wd, evwin);
        if (!ws)
            continue;

        switch (event.type) {
            case SelectionRequest: {
                tended struct descrip tmp;
                if (selection_debug) {
                    printf("SelectionRequest event:\n\towner=%lx requestor=%lx property=%s",
                           (long)event.xselectionrequest.owner,
                           (long)event.xselectionrequest.requestor,
                           get_atom_name(wd, event.xselectionrequest.property));
                    printf(" target=%s", get_atom_name(wd, event.xselectionrequest.target));
                    printf(" selection=%s\n", get_atom_name(wd, event.xselectionrequest.selection));
                }

                MakeInt(SELECTIONREQUEST, &tmp);
                list_put(&ws->listp, &tmp);
                MakeInt((word)event.xselectionrequest.requestor, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(wd, event.xselectionrequest.property, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(wd, event.xselectionrequest.selection, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(wd, event.xselectionrequest.target, &tmp);
                list_put(&ws->listp, &tmp);
                MakeInt(event.xselectionrequest.time, &tmp);
                list_put(&ws->listp, &tmp);
                break;
            }

            case SelectionClear: {
                tended struct descrip tmp;
                if (selection_debug)
                    printf("SelectionClear event win=%lx selection=%s\n",
                           (long)event.xselectionclear.window,
                           get_atom_name(wd, event.xselectionclear.selection));
                MakeInt(SELECTIONCLEAR, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(wd, event.xselectionclear.selection, &tmp);
                list_put(&ws->listp, &tmp);
                break;
            }

            case SelectionNotify: {
                Atom actual_type;
                int actual_format;
                unsigned long bytes_after, nitems;
                unsigned char *prop;
                word bytes_read;
                tended struct descrip tmp;
                int status;
                char *conv_str;

                if (selection_debug) {
                    printf("SelectionNotify: requestor=%lx selection=%s",
                           (long)event.xselection.requestor, get_atom_name(wd, event.xselection.selection));
                    printf(" target=%s", get_atom_name(wd, event.xselection.target));
                    printf(" property=%s\n", get_atom_name(wd, event.xselection.property));
                }

                MakeInt(SELECTIONRESPONSE, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(wd, event.xselection.selection, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(wd, event.xselection.target, &tmp);
                list_put(&ws->listp, &tmp);

                if (event.xselection.property == None) {
                    if (selection_debug)
                        printf("XGetWindowProperty xselection.property == None\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                status = XGetWindowProperty(wd->display,
                                            ws->win,
                                            event.xselection.property,
                                            0,
                                            8192,   /* Means we won't get back > 32kb of stuff */
                                            True,
                                            AnyPropertyType,
                                            &actual_type,
                                            &actual_format,
                                            &nitems,
                                            &bytes_after,
                                            &prop);

                if (status != Success) {
                    if (selection_debug)
                        printf("XGetWindowProperty failed\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                /* Shouldn't ever happen */
                if (!prop) {
                    if (selection_debug)
                        printf("XGetWindowProperty set prop to null\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                if (actual_type == None) {
                    if (selection_debug)
                        printf("XGetWindowProperty returned actual_type == None\n");
                    list_put(&ws->listp, &nulldesc);
                    XFree(prop);    // prop is non-null
                    break;
                }

                bytes_read = nitems * (actual_format/8);
                if (selection_debug)
                    printf("Got %lu items x %d bits -> %ld bytes actual_type=%s\n",
                           nitems, actual_format, (long)bytes_read, get_atom_name(wd, actual_type));

                conv_str = property_to_string(wd,
                                              actual_type,
                                              nitems,
                                              prop);
                if (conv_str) {
                    /* Make an Icon string out of the data */
                    cstr2string(conv_str, &tmp);
                    free(conv_str);
                } else {
                    /* Make an Icon string out of the data */
                    bytes2string((char *)prop, bytes_read, &tmp);
                }
                list_put(&ws->listp, &tmp);

                XFree(prop);
                    
                break;
            }

            case KeyRelease:
            case KeyPress:
                handle_keypress(ws, (XKeyEvent *)&event);
                break;
            case ButtonPress:
            case ButtonRelease:
            case MotionNotify:
                handle_mouse(ws, (XButtonEvent *)&event);
                break;
            case LeaveNotify:
            case EnterNotify:
                handle_crossing(ws, (XCrossingEvent *)&event);
                break;
            case NoExpose:
                break;
            case Expose:
                handle_exposures(ws, (XExposeEvent *)&event);
                break;
            case PropertyNotify:
                handle_property(ws, (XPropertyEvent *)&event);
                break;
            case UnmapNotify:
            case MapNotify:
                break;
            case ConfigureNotify:
                handle_config(ws, (XConfigureEvent *)&event);
                break;
            case FocusIn:
                qeventcode(ws, FOCUSIN);
                break;
            case FocusOut:
                qeventcode(ws, FOCUSOUT);
                break;
            case ClientMessage: {
                /*
                 * only client message we handle at present are destroy requests
                 */
                if (event.xclient.data.l[0] == ATOM(wd, WM_DELETE_WINDOW))
                    qeventcode(ws, WINDOWCLOSED);
                break;
            }
            default:
                break;
        }
    }
}

static void close_screen_win(wsp ws)
{
    wdp wd = ws->display;
    XRenderFreePicture(wd->display, ws->wpic);
    XDestroyWindow(wd->display, ws->win);
    XFlush(wd->display);
    ws->win = 0;
    ws->wpic = 0;
    ws->x = ws->y = -INT_MAX;
    GUnlink4(ws, wd->vwstates, vnext, vprevious);
    synch_state(ws);
}

/*
 * open a window
 */
wbp wopen(char *display)
{
    wbp w;
    wsp ws;
    wcp wc;
    wdp wd;
    XRenderPictureAttributes attr;

    if ((wd = alcdisplay(display)) == NULL) {
        /* alcdisplay will have set &why */
        return 0;
    }

    w = alcwbinding(wd);

    GAlloc(ws, _wstate);
    ws->listp = nulldesc;
    ws->windowlabel = defaultwindowlabel;
    add_gc_global(&ws->windowlabel);
    add_gc_global(&ws->listp);
    ws->cursor = lookup_wcursor(wd, "left ptr");
    ws->state = stringint_lookup(canvastypes, "hidden");
    ws->reqx = ws->reqy = ws->x = ws->y = -INT_MAX;
    ws->minwidth = ws->minheight = 1;
    ws->maxwidth = ws->maxheight = INT_MAX;
    ws->width = ws->height = ws->pixwidth = ws->pixheight = 1;
    ws->basewidth = ws->baseheight = 0;
    ws->incwidth = ws->incheight = 1;
    ws->minaspect = ws->maxaspect = 0.0;
    ws->pxft = NULL;
    ws->display = wd;
    w->window = ws;
    create_list(64, &ws->listp);

    GAlloc(wc, _wcontext);
    wc->display = wd;
    wc->bg = link_sharedcolor(wd->white);
    wc->fg = link_sharedcolor(wd->black);
    wc->font = wd->defaultfont;
    wc->leading = defaultleading;
    wc->drawop = stringint_lookup(drawops, "over");
    wc->clipx = wc->clipy = 0;
    wc->clipw = wc->cliph = -1;
    wc->linewidth = 1;
    wc->linejoin = stringint_lookup(linejoins, "round");
    wc->lineend = stringint_lookup(lineends, "flat");

    w->context = wc;

    /*
     * Create the 1x1 pixmap
     */
    ws->pix = XCreatePixmap(wd->display, GetRoot(wd),
                            ws->pixwidth, ws->pixheight,
                            32);
    attr.poly_edge = PolyEdge;
    attr.poly_mode = PolyMode;
    ws->ppic = XRenderCreatePicture(wd->display, ws->pix, wd->pixfmt, CPPolyEdge|CPPolyMode, &attr);

    /* Fill pixmap with background colour */
    XRenderFillRectangle(wd->display,
                         PictOpSrc,
                         ws->ppic,
                         &wc->bg->color,
                         0, 0, ws->width, ws->height);
    return w;
}

int setwindowicon(wbp w, struct imgdata *imd)
{
    wsp ws = w->window;
    int i, j, k;
    free(ws->icondata);
    if (imd) {
        ws->iconlen = 2 + imd->width * imd->height;
        ws->icondata = safe_malloc(ws->iconlen * sizeof(unsigned long));
        k = 0;
        ws->icondata[k++] = imd->width;
        ws->icondata[k++] = imd->height;
        for (j = 0; j < imd->height; ++j) {
            for (i = 0; i < imd->width; ++i) {
                int r, g, b, a;
                imd->format->getpixel(imd, i, j, &r, &g, &b, &a);
                ws->icondata[k++] = ((a/256)<<24) | ((r/256)<<16) | ((g/256)<<8) | (b/256);
            }
        }
        if (ws->win)
            apply_windowicon(ws);
    } else {
        ws->icondata = 0;
        ws->iconlen = 0;
    }
    return Succeeded;
}

int setpattern(wbp w, struct imgdata *imd)
{
    wcp wc = w->context;
    wdp wd = w->window->display;
    if (wc->pattern)
        unlink_sharedpicture(wc->pattern);
    if (imd)
        wc->pattern = new_sharedpicture(wd, imd);
    else
        wc->pattern = 0;
    return Succeeded;
}

/*
 * Return an allocated string giving the part of the prog name after the last '/'.
 */
static char *get_progname()
{
    int n;
    char *p, *s, *m;
    p = StrLoc(kywd_prog);
    s = p + StrLen(kywd_prog);
    while (s > p && s[-1] != '/')
        s--;				/* find tail of prog_name */
    n = p + StrLen(kywd_prog) - s;          /* no. of chars to copy */
    m = safe_malloc(n + 1);
    memcpy(m, s, n);
    m[n] = 0;
    return m;
}

static void synch_pos(wsp ws)
{
    Window junk;
    int new_x, new_y;
    wdp wd = ws->display;
    XTranslateCoordinates(wd->display, ws->win, GetRoot(wd), 0, 0, &new_x, &new_y, &junk);
    if ((new_x != ws->x) || (new_y != ws->y)) {
        ws->x = new_x;
        ws->y = new_y;
        qeventcode(ws, WINDOWMOVED);
    }
}

/*
 *  Open the X window for a non-hidden icon window.
 */
static void wmap(wbp w)
{
    XWindowAttributes attrs;
    XSetWindowAttributes attr;
    char *m1, *m2;
    XWMHints wmhints;
    XClassHint clhints;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;

    /*
     * create the X window (or use the DefaultRootWindow if requested)
     */
    attr.background_pixel = 0xffffff;  /* TODO wc->bg->c; */

    switch (ws->state->i) {
        case RootState:
            ws->win = GetRoot(wd);
            break;
        case PopupState: {
            attr.override_redirect = True;
            ws->win = XCreateWindow(wd->display, GetRoot(wd),
                                    ws->reqx == -INT_MAX ? 0 : ws->reqx,
                                    ws->reqy == -INT_MAX ? 0 : ws->reqy, 
                                    ws->width, ws->height, 
                                    0,
                                    GetDepth(wd),
                                    InputOutput,
                                    CopyFromParent,
                                    CWBackPixel|CWOverrideRedirect,
                                    &attr);
            break;
        }
        default: {
            ws->win = XCreateWindow(wd->display, GetRoot(wd),
                                    ws->reqx == -INT_MAX ? 0 : ws->reqx,
                                    ws->reqy == -INT_MAX ? 0 : ws->reqy, 
                                    ws->width, ws->height, 
                                    0,
                                    GetDepth(wd),
                                    InputOutput,
                                    CopyFromParent,
                                    CWBackPixel,
                                    &attr);
            break;
        }
    }

    ws->wpic = XRenderCreatePicture(wd->display, ws->win, wd->winfmt, 0, NULL);

    /* Set the optional WM_TRANSIENT_FOR hint. */
    if (ws->transientfor && ws->transientfor->win)
        XSetTransientForHint(wd->display, ws->win, ws->transientfor->win);

    /* Turn off background; this prevents X filling the background on an expose
       and hence prevents unsightly flicker on a resize. */
    XSetWindowBackgroundPixmap(wd->display, ws->win, None);

    XSetWMProtocols(wd->display, ws->win, &ATOM(wd, WM_DELETE_WINDOW), 1);

    XClearWindow(wd->display, ws->win);

    GLink4(ws, wd->vwstates, vnext, vprevious);

    /* For RootState, need to fill since XClearWindow above fills with a pixmap */
    if (ws->state->i == RootState) {
        XRenderFillRectangle(wd->display,
                             PictOpSrc,
                             ws->wpic,
                             &wc->bg->color,
                             0, 0, ws->width, ws->height);
    } else {
        XSizeHints size_hints;
        mk_hints(ws, &size_hints);
        size_hints.flags |= PSize;
        size_hints.width = ws->width;
        size_hints.height= ws->height;
        if (ws->reqx != -INT_MAX && ws->reqy != -INT_MAX) {
            size_hints.flags |= USPosition;
            size_hints.x = ws->reqx;
            size_hints.y = ws->reqy;
        }
        apply_windowlabel(ws);
        XSetWMNormalHints(wd->display, ws->win, &size_hints);
        XSelectInput(wd->display, ws->win, 
                     ExposureMask | KeyPressMask | EnterWindowMask | LeaveWindowMask | FocusChangeMask |
                     ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | PropertyChangeMask |
                     StructureNotifyMask | PointerMotionMask | KeyReleaseMask);

        if (ws->icondata)
            apply_windowicon(ws);
    }

    wmhints.input = True;
    wmhints.flags = InputHint;
    switch (ws->state->i) {
        case IconicState: {
            wmhints.flags |= StateHint;
            wmhints.initial_state = IconicState;
            break;
        }
        case WithdrawnState: {
            wmhints.flags |= StateHint;
            wmhints.initial_state = WithdrawnState;
            break;
        }
        case RootState:
            break;
        default: {
            wmhints.flags |= StateHint;
            wmhints.initial_state = NormalState;
            break;
        }
    }
    XSetWMHints(wd->display, ws->win, &wmhints);

    /*
     * Set the class hints that name the program (for reference by the
     * window manager) following conventions given in O'Reilly.
     */
    if (resource_name) {
        clhints.res_name = resource_name;
        m1 = 0;
    } else {
        m1 = get_progname();
        clhints.res_name = m1;
    }
    if (resource_class) {
        clhints.res_class = resource_class;
        m2 = 0;
    } else {
        /* Defaults to prog name, with first letter capitalized (see X(7) manpage). */
        m2 = get_progname();
        m2[0] = oi_toupper(m2[0]);
        clhints.res_class = m2;
    }
    XSetClassHint(wd->display, ws->win, &clhints);
    free(m1);
    free(m2);

    /* This is a convenient way to set the WM_CLIENT_MACHINE and
     * WM_LOCALE_NAME properties. */
    XSetWMProperties(wd->display, ws->win, 0, 0, 0, 0, 0, 0, 0);

    switch (ws->state->i) {
        case MaximizedState: {
            Atom atoms[2];
            atoms[0] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
            atoms[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
            XChangeProperty(wd->display, ws->win,
                            ATOM(wd, _NET_WM_STATE),
                            XA_ATOM, 32,
                            PropModeReplace, (unsigned char *)atoms, 2);
            break;
        }
        case FullScreenState: {
            Atom atoms[1];
            atoms[0] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
            XChangeProperty(wd->display, ws->win,
                            ATOM(wd, _NET_WM_STATE),
                            XA_ATOM, 32,
                            PropModeReplace, (unsigned char *)atoms, 1);
            break;
        }
        case ShadedState: {
            Atom atoms[1];
            atoms[0] = ATOM(wd, _NET_WM_STATE_SHADED);
            XChangeProperty(wd->display, ws->win,
                            ATOM(wd, _NET_WM_STATE),
                            XA_ATOM, 32,
                            PropModeReplace, (unsigned char *)atoms, 1);
            break;
        }
    }

    if (ws->state->i != RootState && ws->state->i != WithdrawnState)
        XMapWindow(wd->display, ws->win);

    XGetWindowAttributes(wd->display, ws->win, &attrs);
    ws->width = attrs.width;
    ws->height = attrs.height;
    resizepixmap(w);

    synch_cursor(ws);

    XSync(wd->display, False);

    synch_pos(ws);
}

static void synch_net_wm_state(wsp ws, int desired_state)
{
    XEvent e;
    wdp wd = ws->display;
    e.xclient.type = ClientMessage;
    e.xclient.serial = 0;
    e.xclient.send_event = True;
    e.xclient.display = wd->display;
    e.xclient.message_type = ATOM(wd, _NET_WM_STATE);
    e.xclient.format = 32;
    e.xclient.window = ws->win;
    e.xclient.data.l[3] = 0;
    switch (desired_state) {
        case NormalState: {
            e.xclient.data.l[0] = _NET_WM_STATE_REMOVE;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
            e.xclient.data.l[2] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_SHADED);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            break;
        }
        case MaximizedState: {
            e.xclient.data.l[0] = _NET_WM_STATE_REMOVE;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_SHADED);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[0] = _NET_WM_STATE_ADD;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
            e.xclient.data.l[2] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            break;
        }
        case FullScreenState: { 
            e.xclient.data.l[0] = _NET_WM_STATE_REMOVE;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
            e.xclient.data.l[2] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_SHADED);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[0] = _NET_WM_STATE_ADD;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            break;
        }
        case ShadedState: { 
            e.xclient.data.l[0] = _NET_WM_STATE_REMOVE;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
            e.xclient.data.l[2] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[0] = _NET_WM_STATE_ADD;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_SHADED);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            break;
        }
        default: {
            syserr("Invalid desired_state");
            break;
        }
    }
    XSync(wd->display, False);
}

static void mk_hints(wsp ws, XSizeHints *h)
{
    h->flags = PMinSize | PMaxSize;
    if (ws->resizable) {
        h->min_width = ws->minwidth;
        h->min_height = ws->minheight;
        h->max_width = ws->maxwidth;
        h->max_height = ws->maxheight;
        if (ws->minaspect != 0.0 || ws->maxaspect != 0.0) {
            h->flags |= PAspect;
            h->min_aspect.x = 10000 * ws->minaspect;
            h->min_aspect.y = 10000;
            if (ws->maxaspect != 0.0) {
                h->max_aspect.x = 10000 * ws->maxaspect;
                h->max_aspect.y = 10000;
            } else {
                h->max_aspect.x = INT_MAX;
                h->max_aspect.y = 1;
            }
        }
        if (ws->incwidth != 1 || ws->incheight != 1) {
            h->flags |= PResizeInc;
            h->width_inc = ws->incwidth;
            h->height_inc = ws->incheight;
        }
        if (h->flags & (PAspect | PResizeInc)) {
            h->flags |= PBaseSize;
            h->base_width = ws->basewidth;
            h->base_height = ws->baseheight;
        }
    }
    else {
        h->min_width = h->max_width = ws->width;
        h->min_height = h->max_height = ws->height;
    }
}

void doconfig(wbp w, int status)
{
    wsp ws = w->window;
    wdp wd = ws->display;

    if (ws->win) {
        if (status & (C_POS | C_SIZE | C_MINSIZE | C_MAXSIZE | C_RESIZE |
                C_MINASPECT | C_MAXASPECT | C_BASESIZE | C_INCSIZE)) {
            if (status != C_POS) {
                XSizeHints size_hints;
                mk_hints(ws, &size_hints);
                XSetWMNormalHints(wd->display, ws->win, &size_hints);
            }

            switch (status & (C_POS|C_SIZE)) {
                case C_POS: {
                    XMoveWindow(wd->display, ws->win, ws->reqx, ws->reqy);
                    break;
                }
                case C_SIZE: {
                    XResizeWindow(wd->display, ws->win, ws->width, ws->height);
                    break;
                }
                case C_POS|C_SIZE: {
                    XMoveResizeWindow(wd->display, ws->win, ws->reqx, ws->reqy, ws->width, ws->height);
                    break;
                }
            }
        }
    }
    if (status & C_SIZE)
        resizepixmap(w);
}

static convert_to_macro(INT32)

/*
 * data is a safe pointer into a frame.
 */
int sendselectionresponse(wbp w, word requestor, char *property, char *selection, char *target, word time, dptr data)
{
    Atom property_atom, target_atom, selection_atom, target_list[32];
    XEvent theevent;
    struct lgstate state;
    tended struct b_lelem *le;
    tended char *cstr_target;
    int target_cnt = 1;
    wsp ws = w->window;
    wdp wd = ws->display;

    if (selection_debug)
        printf("sendselectionresponse:\n\trequestor=%lx "
               "property=%s target=%s selection=%s time=%ld\n",
               (long)requestor, property, target, selection, (long)time);

    property_atom = XInternAtom(wd->display, property, False);
    target_atom = XInternAtom(wd->display, target, False);
    selection_atom = XInternAtom(wd->display, selection, False);

    if (target_atom == ATOM(wd, TARGETS)) {
        if (!is:list(*data))
            ReturnErrVal(108, *data, Error);
        target_list[0] = ATOM(wd, TARGETS);
        for (le = lgfirst(&ListBlk(*data), &state); le;
             le = lgnext(&ListBlk(*data), &state, le)) {
            if (!cnv:C_string(le->lslots[state.result], cstr_target))
                ReturnErrVal(148, le->lslots[state.result], Error);
            if (target_cnt < ElemCount(target_list)) {
                target_list[target_cnt++] = XInternAtom(wd->display, cstr_target, False);
                if (selection_debug)
                    printf("\tAdding target:%s\n", cstr_target);
            }
        }
        XChangeProperty(wd->display,
                        requestor,
                        property_atom,
                        XA_ATOM,
                        32,
                        PropModeReplace,
                        (unsigned char *)target_list,
                        target_cnt);
        theevent.xselection.property = property_atom;
    } else if (is:null(*data)) {
        /* Can't handle this target type */
        if (selection_debug)
            printf("\tSetting property to None\n");
        theevent.xselection.property = None;
    } else if (convert_target(wd, target_atom) == XA_INTEGER) {
        INT32 i32;
        long l;
        if (!cnv:integer(*data, *data))
            ReturnErrVal(101, *data, Error);
        if (!convert_to_INT32(data, &i32))
            /* the convert function has set the error values itself */
            return Error;
        /* The data is sent as a long regardless of whether that is 32 or 64 bits. */
        l = i32;
        if (selection_debug)
            printf("\tSetting property to INTEGER data %ld\n", l);
        XChangeProperty(wd->display,
                        requestor,
                        property_atom,
                        XA_INTEGER,
                        32,
                        PropModeReplace,
                        (unsigned char *)&l,
                        1);
        theevent.xselection.property = property_atom;
    } else {
        if (!cnv:string(*data, *data))
            ReturnErrVal(103, *data, Error);
        if (selection_debug)
            printf("\tSetting property to %d bytes of data\n", (int)StrLen(*data));
        XChangeProperty(wd->display,
                        requestor,
                        property_atom,
                        target_atom,
                        8,
                        PropModeReplace,
                        (unsigned char *)StrLoc(*data),
                        StrLen(*data));
        theevent.xselection.property = property_atom;
    }

    theevent.type = SelectionNotify;
    theevent.xselection.serial = 0; /*event.xselectionrequest.serial;*/
    theevent.xselection.send_event = True;
    theevent.xselection.requestor = requestor;
    theevent.xselection.selection = selection_atom;
    theevent.xselection.target = target_atom;
    theevent.xselection.time = time;

    XSendEvent(wd->display,
               requestor,
               False, NoEventMask, &theevent);

    return Succeeded;
}

int ownselection(wbp w, char *selname, word *time)
{
    Atom selection;
    Window curr;
    wsp ws = w->window;
    wdp wd = ws->display;

    CheckUnhidden(ws);

    selection = XInternAtom(wd->display, selname, False);
    curr = XGetSelectionOwner(wd->display, selection);

    /* Check for no change in selection */
    if (curr == ws->win) {
        if (selection_debug)
            printf("Ownership of selection %s retained by %lx\n",
                   get_atom_name(wd, selection), (long)ws->win);
    } else {
        if (selection_debug)
            printf("Owner of selection %s set from %lx -> %lx\n",
                   get_atom_name(wd, selection), (long)curr, (long)ws->win);

        /*
         * X doesn't send a SelectionClear event to us when the selection
         * changes between our own windows, so if the current owner is one
         * our windows, send it a "clear" message.
         */
        if (curr) {
            wsp x;
            for (x = wd->vwstates; x; x = x->vnext) {
                if (x->win == curr) {
                    tended struct descrip tmp;
                    if (selection_debug)
                        printf("Enqueueing artificial SELECTIONCLEAR to current owner %lx\n", (long)curr);
                    MakeInt(SELECTIONCLEAR, &tmp);
                    list_put(&x->listp, &tmp);
                    get_atom_descriptor(wd, selection, &tmp);
                    list_put(&x->listp, &tmp);
                    break;
                }
            }
        }
    }
    XSetSelectionOwner(wd->display, 
                       selection,
                       ws->win,
                       wd->recent);

    /*
     * Time is an unsigned quantity, maybe 64 bits, but the TIMESTAMP
     * selection must be returned as a 32 bit signed integer, so the
     * Time is cast here.  This may lead to a negative result.
     */

    *time = (word)(INT32)wd->recent;

    if (selection_debug)
        printf("Selection time was %lu, converted to " WordFmt "\n", 
               (unsigned long)wd->recent, *time);

    return Succeeded;
}

int requestselection(wbp w, char *selname, char *targetname)
{
    Atom selection, target, property;
    wsp ws = w->window;
    wdp wd = ws->display;
    CheckUnhidden(ws);
    selection = XInternAtom(wd->display, selname, False);
    target = XInternAtom(wd->display, targetname, False);
    /* 
     * Use 8 property atoms to allow multiple concurrent requests
     * without the results getting mixed up.  Obviously this isn't
     * perfect, but is better than nothing.
     */
    property = wd->atoms[ATOM__OBJECTICON_PROP0 + (ws->propcount++) % 8];
    if (selection_debug) {
        printf("getselectioncontent: calling XConvertSelection selection=%s", get_atom_name(wd, selection));
        printf(" target=%s", get_atom_name(wd, target));
        printf(" property=%s", get_atom_name(wd, property));
        printf(" requestor=%lx\n", (long)ws->win);
    }

    XConvertSelection(wd->display,
                      selection, 
                      target, 
                      property,
                      ws->win,
                      CurrentTime);

    return Succeeded;
}

int warppointer(wbp w, int x, int y)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    XWarpPointer(ws->display->display, None, ws->win, 0,0,0,0, x, y);
    return Succeeded;
}

static void apply_windowlabel(wsp ws)
{
    wdp wd = ws->display;
    XChangeProperty(wd->display, ws->win,
                    ATOM(wd, _NET_WM_NAME), 
                    ATOM(wd, UTF8_STRING),
                    8,
                    PropModeReplace, 
                    (unsigned char *)StrLoc(UcsBlk(ws->windowlabel).utf8),
                    StrLen(UcsBlk(ws->windowlabel).utf8));
}

static void apply_windowicon(wsp ws)
{
    wdp wd = ws->display;
    XChangeProperty(wd->display, ws->win,
                    ATOM(wd, _NET_WM_ICON), 
                    XA_CARDINAL, 
                    32,
                    PropModeReplace, 
                    (unsigned char *)ws->icondata,
                    ws->iconlen);
}

int setwindowlabel(wbp w, dptr val)
{
    wsp ws = w->window;
    ws->windowlabel = *val;
    if (ws->win)
        apply_windowlabel(ws);
    return Succeeded;
}

static void synch_cursor(wsp ws)
{
    XDefineCursor(ws->display->display, ws->win, ws->cursor->shared_cursor->cursor);
}

/*
 * setpointer() - define a mouse pointer shape
 */
int setpointer(wbp w, char *val)
{
    struct wcursor *c;
    wsp ws = w->window;
    c = lookup_wcursor(ws->display, val);
    if (!c)
        return Failed;
    ws->cursor = c;
    if (ws->win)
        synch_cursor(ws);
    return Succeeded;
}

/*
 * setdrawop() - set the drawing operation
 */
int setdrawop(wbp w, char *val)
{
    stringint *e;
    wcp wc = w->context;
    e = stringint_lookup(drawops, val);
    if (!e)
        return Failed;
    wc->drawop = e;
    return Succeeded;
}

wbp clonewindow(wbp w)
{
    wbp w2;
    w2 = alcwbinding(w->window->display);
    w2->window = linkwindow(w->window);
    w2->context = clonecontext(w->context);
    return w2;
}

wbp couplewindows(wbp w1, wbp w2)
{
    wbp w3;
    if (w1->window->display != w2->context->display) {
        LitWhy("Can't couple between different displays");
        return 0;
    }
    w3 = alcwbinding(w1->window->display);
    w3->window = linkwindow(w1->window);
    w3->context = linkcontext(w2->context);
    return w3;
}

static void clip(wbp w)
{
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;
    XRectangle rec;
    if (wc->clipw >= 0) {
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XRenderSetPictureClipRectangles(wd->display,
                                        ws->ppic,
                                        0, 0, &rec, 1);
        if (ws->wpic && !ws->holding)
            XRenderSetPictureClipRectangles(wd->display,
                                            ws->wpic,
                                            0, 0, &rec, 1);
    } else
        no_clip(ws, 1);
}

static void no_clip(wsp ws, int and_win)
{
    XRenderPictureAttributes attr;
    wdp wd = ws->display;
    attr.clip_mask = None;
    XRenderChangePicture(wd->display,
                         ws->ppic,
                         CPClipMask,
                         &attr);
    if (and_win && ws->wpic && !ws->holding)
        XRenderChangePicture(wd->display,
                             ws->wpic,
                             CPClipMask,
                             &attr);
}

/*
 *  Set the canvas type
 */
int setcanvas(wbp w, char *s)
{
    stringint *e;
    wsp ws = w->window;
    wdp wd = ws->display;
    e = stringint_lookup(canvastypes, s);
    if (!e)
        return Failed;
    if (e == ws->state)
        return Succeeded;

    if (!ws->win) {
        if (e->i != HiddenState) {
            ws->state = e;
            wmap(w);
        }
        return Succeeded;
    }

    switch (e->i) {
        case IconicState: {
            if (ws->state->i == RootState || ws->state->i == PopupState)
                return Failed;
            if (ws->state->i == WithdrawnState) {
                XWMHints wmhints;
                wmhints.flags = StateHint;
                wmhints.initial_state = IconicState;
                XSetWMHints(wd->display, ws->win, &wmhints);
                XMapWindow(wd->display, ws->win);
            } else
                XIconifyWindow(wd->display, ws->win, DefaultScreen(wd->display));
            break;
        }

        case WithdrawnState: {
            if (ws->state->i == RootState || ws->state->i == PopupState)
                return Failed;
            XWithdrawWindow(wd->display, ws->win, DefaultScreen(wd->display));
            break;
        }

        case NormalState:
        case MaximizedState:
        case FullScreenState:
        case ShadedState: {
            if (ws->state->i == RootState || ws->state->i == PopupState)
                return Failed;
            if (ws->state->i == WithdrawnState) {
                XWMHints wmhints;
                wmhints.flags = StateHint;
                wmhints.initial_state = NormalState;
                XSetWMHints(wd->display, ws->win, &wmhints);
            }
            /*
             * Use XMapRaised to try to give more consistent results
             * (kwin will restore an iconified window to its previous
             * position in the stack, whilst fvwm puts it to the top)
             */
            XMapRaised(wd->display, ws->win);
            synch_net_wm_state(ws, e->i);
            break;
        }

        case PopupState:
        case RootState:
            return Failed;

        case HiddenState: {
            close_screen_win(ws);
            break;
        }
        default:
            syserr("Unexpected canvas state");
    }
    return Succeeded;
}

/*
 * Set the context's line end style by name.
 */
int setlineend(wbp w, char *val)
{
    stringint *e;
    wcp wc = w->context;
    e = stringint_lookup(lineends, val);
    if (!e)
        return Failed;
    wc->lineend = e;
    return Succeeded;
}

/*
 * Set the context's line join style by name.
 */
int setlinejoin(wbp w, char *val)
{
    stringint *e;
    wcp wc = w->context;
    e = stringint_lookup(linejoins, val);
    if (!e)
        return Failed;
    wc->linejoin = e;
    return Succeeded;
}

/*
 * Set the context's line width
 */
int setlinewidth(wbp w, double linewid)
{
    wcp wc = w->context;
    wc->linewidth = linewid;
    return Succeeded;
}

/*
 * Set the context's foreground color by name.
 */
int setfg(wbp w, char *s)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(s, &r, &g, &b, &a))
        return Failed;
    unlink_sharedcolor(wc->fg);
    wc->fg = new_sharedcolor(wc->display, s, r, g, b, a);
    return Succeeded;
}

/*
 * Set the window context's background color by name.
 */
int setbg(wbp w, char *s)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(s, &r, &g, &b, &a))
        return Failed;
    unlink_sharedcolor(wc->bg);
    wc->bg = new_sharedcolor(wc->display, s, r, g, b, a);
    return Succeeded;
}

char *getdisplay(wbp w)
{
    return w->window->display->name;
}

int getdisplaysize(wbp w, int *width, int *height)
{
    wdp wd = w->window->display;
    *width = DisplayWidth(wd->display, DefaultScreen(wd->display));
    *height = DisplayHeight(wd->display, DefaultScreen(wd->display));
    return Succeeded;
}

int getdisplaysizemm(wbp w, int *width, int *height)
{
    wdp wd = w->window->display;
    *width = DisplayWidthMM(wd->display, DefaultScreen(wd->display));
    *height = DisplayHeightMM(wd->display, DefaultScreen(wd->display));
    return Succeeded;
}

int getdepth(wbp w, int *res)
{
    *res = GetDepth(w->window->display);
    return Succeeded;
}

char *getfg(wbp w)
{
    return w->context->fg->name;
}

char *getbg(wbp w)
{
    return w->context->bg->name;
}

int grabpointer(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    if (XGrabPointer(ws->display->display, ws->win,False, 
                     ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | PointerMotionMask,
                     GrabModeAsync, GrabModeAsync, None, None, CurrentTime) != GrabSuccess) {
        LitWhy("XGrabPointer failed");
        return Failed;
    }
    return Succeeded;
}

int ungrabpointer(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    XUngrabPointer(ws->display->display, CurrentTime);
    return Succeeded;
}

int grabkeyboard(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    if (XGrabKeyboard(ws->display->display, ws->win,False, 
                      GrabModeAsync, GrabModeAsync, CurrentTime) != GrabSuccess) {
        LitWhy("XGrabKeyboard failed");
        return Failed;
    }
    return Succeeded;
}

int ungrabkeyboard(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    XUngrabKeyboard(ws->display->display, CurrentTime);
    return Succeeded;
}

/*
 * Set the window's font by name.
 */
int setfont(wbp w, char *s)
{
    wfp tmp;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;

    tmp = loadfont(wd, s);
    if (!tmp)
        return Failed;
    wc->font = tmp;
    return Succeeded;
}

/*
 * Copy the given region from pix to win, ignoring the clipping
 * region.  If holding is on, do nothing.
 */
static void synch_pix_and_win(wsp ws, int x, int y, int width, int height)
{
    wdp wd = ws->display;
    if (ws->win && !ws->holding) {
        no_clip(ws, 1);
        XRenderComposite(wd->display, PictOpSrc, ws->ppic, 0, ws->wpic,
                         x, y, 0, 0, x, y, width, height);
    }
}

/*
 * Copy the given area from pix to win.  The caller must have called clip()
 * beforehand.  If holding is on, do nothing.
 */
static void pix_to_win(wsp ws, int x, int y, int width, int height)
{
    wdp wd = ws->display;
    if (ws->win && !ws->holding)
        XRenderComposite(wd->display, PictOpSrc, ws->ppic, 0, ws->wpic,
                         x, y, 0, 0, x, y, width, height);
}

/*
 * callback procedures
 */

static void handle_exposures(wsp ws, XExposeEvent *event)
{
    synch_pix_and_win(ws, event->x, event->y, event->width, event->height);
}

/*
 * resizepixmap(w,width,height) -- ensure w's backing pixmap is at least
 * width x height pixels.
 *
 * Resizes the backing pixmap, if needed.  Called when X resize events
 * arrive, as well as when programs make explicit resize requests.
 *
 */
static void resizepixmap(wbp w)
{
    Pixmap p;
    Picture pp;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;
    int old_w, old_h;
    XRenderPictureAttributes attr;

    if ((ws->width == ws->pixwidth) && (ws->height == ws->pixheight))
        return;

    old_w = ws->pixwidth;
    old_h = ws->pixheight;
    ws->pixheight = Max(1, ws->height);
    ws->pixwidth  = Max(1, ws->width);
    p = XCreatePixmap(wd->display, GetRoot(wd), ws->pixwidth, ws->pixheight, 32);
    attr.poly_edge = PolyEdge;
    attr.poly_mode = PolyMode;
    pp = XRenderCreatePicture(wd->display, p, wd->pixfmt, CPPolyEdge|CPPolyMode, &attr);
    /* Fill with bg colour */
    XRenderFillRectangle(wd->display,
                         PictOpSrc,
                         pp,
                         &wc->bg->color,
                         0, 0, ws->pixwidth, ws->pixheight);

    no_clip(ws, 0);
    XRenderComposite(wd->display, PictOpSrc, ws->ppic, 0, pp,
                     0,0,0,0,0,0, old_w, old_h);

    XFreePixmap(wd->display, ws->pix);	/* free old pixmap */
    XRenderFreePicture(wd->display, ws->ppic);
    ws->pix = p;
    ws->ppic = pp;
    if (ws->pxft) {
        XftDrawDestroy(ws->pxft);
        ws->pxft = NULL;
    }
}

static void synch_state(wsp ws)
{
    int t;

    if (ws->win == 0) {
        ws->state = stringint_lookup(canvastypes, "hidden");
        return;
    }

    if (ws->state->i == PopupState || ws->state->i == RootState)
        return;

    t = ws->state->i;
    synch_state1(ws);
    if (t != ws->state->i)
        qeventcode(ws, WINDOWSTATE);
}

static void synch_state1(wsp ws)
{
    Atom actual_type;
    int actual_format;
    unsigned long bytes_after, nitems;
    unsigned char *prop;
    unsigned long state;
    wdp wd = ws->display;

    if (XGetWindowProperty(wd->display,
                           ws->win,
                           ATOM(wd, WM_STATE),
                           0,
                           1,
                           False,
                           ATOM(wd, WM_STATE),
                           &actual_type,
                           &actual_format,
                           &nitems,
                           &bytes_after,
                           &prop) != Success)
        return;
    
    if (actual_type == ATOM(wd, WM_STATE))
        state = *((unsigned long *)prop);
    else 
        /* WM_STATE absent => withdrawn */
        state = WithdrawnState;

    if (prop) XFree(prop);

    if (state == WithdrawnState || state == IconicState) {
        ws->state = stringint_rev_lookup(canvastypes, state);
        return;
    }

    /* Normal state, so check if maximized, etc */

    if (XGetWindowProperty(wd->display,
                           ws->win,
                           ATOM(wd, _NET_WM_STATE),
                           0,
                           8192,
                           False,
                           XA_ATOM,
                           &actual_type,
                           &actual_format,
                           &nitems,
                           &bytes_after,
                           &prop) != Success)
        return;

    if (actual_type == XA_ATOM) {
        int i, max = 0;
        Atom *atoms = (Atom *)prop;
        for (i = 0; i < nitems; ++i) {
            if (atoms[i] == ATOM(wd, _NET_WM_STATE_SHADED))
                max |= 8;
            else if (atoms[i] == ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT))
                max |= 1;
            else if (atoms[i] == ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ))
                max |= 2;
            else if (atoms[i] == ATOM(wd, _NET_WM_STATE_FULLSCREEN))
                max |= 4;
        }
        if (max == 3)
            state = MaximizedState;
        else if (max & 4)
            state = FullScreenState;
        else if (max & 8)
            state = ShadedState;
        else
            state = NormalState;
    } else
        /* Unexpected, assume normal state */
        state = NormalState;

    ws->state = stringint_rev_lookup(canvastypes, state);

    if (prop) XFree(prop);
}

static void handle_property(wsp ws, XPropertyEvent *event)
{
    if (event->atom == ATOM(ws->display, WM_STATE) ||
        event->atom == ATOM(ws->display, _NET_WM_STATE))
        synch_state(ws);
}

static void handle_config(wsp ws, XConfigureEvent *event)
{
    synch_pos(ws);
    if ((event->width != ws->width) || (event->height != ws->height)) {
        ws->width = event->width;
        ws->height = event->height;
        resizepixmap(findwbp(ws));
        qeventcode(ws, WINDOWRESIZED);
    }
}

static int make_mod(unsigned int state)
{
    int x = 0;

    if (state & ShiftMask)
        x |= MOD_SHIFT;
    if (state & LockMask)
        x |= MOD_LOCK;
    if (state & ControlMask)
        x |= MOD_CTRL;
    if (state & Mod1Mask)
        x |= MOD_META;
    if (state & Mod2Mask)
        x |= MOD_META2;
    if (state & Mod3Mask)
        x |= MOD_META3;
    if (state & Mod4Mask)
        x |= MOD_META4;
    if (state & Mod5Mask)
        x |= MOD_META5;
    return x;
}

static void handle_crossing(wsp ws, XCrossingEvent *event)
{
    struct descrip d;
    MakeInt(event->type == EnterNotify ? MOUSEENTERED:MOUSEEXITED, &d);
    qevent(ws, &d, event->x, event->y,
           (word)event->time, 
           make_mod(event->state));
    UpdateRecent(ws, event);
}

/*
 * Queue up characters for keypress events.
 */
static void handle_keypress(wsp ws, XKeyEvent *event)
{
    int i, j, fl;
    char s[10];
    tended struct descrip d;
    KeySym k;

    fl = make_mod(event->state);
    if (event->type == KeyRelease)
        fl |= MOD_RELEASE;
    /* First try to convert the event to a simple char string, and a KeySym */
    i = XLookupString(event, s, sizeof(s), &k, NULL);
    if (i > 0) {
        /* Found a char string, so generate string event(s) */
        StrLen(d) = 1;
        for (j = 0; j < i; j++) {
            StrLoc(d) = &allchars[s[j] & 0xFF];
            qevent(ws, &d, event->x, event->y,
                   (word)event->time, fl);
        }
        return;
    }

    /* Second try is to convert to a unicode char; if found generate a 1-char
     * ucs/string */
    i = convert_KeySym_to_code_point(k);
    if (i > 0) {
        if (i < 256)
            MakeStr(&allchars[i], 1, &d);
        else
            MakeDesc(D_Ucs, make_one_char_ucs_block(i), &d);

        qevent(ws, &d, event->x, event->y,
               (word)event->time, fl);
        return;
    }

    /* Neither of those worked, so it must be a non-character key (cursor key, etc).
     * So just generate the numerical value of the KeySym as an integer.
     */
    MakeInt(k, &d);
    qevent(ws, &d, event->x, event->y,
           (word)event->time, fl);
    UpdateRecent(ws, event);
}

#include "rxkeysyms.ri"

/*
 * Handle button presses and drag events.  In the case of drags, we should
 * really be looking at an XMotionEvent instead of an XButtonEvent, but
 * the structures are identical up to the button field (which we do not
 * examine for drag events).  Mouse coordinates are queued up after the event.
 */
static void handle_mouse(wsp ws, XButtonEvent *event)
{
    int state = 0;
    if (event->state & Button1Mask) state |= 1;
    if (event->state & Button2Mask) state |= 2;
    if (event->state & Button3Mask) state |= 4;
    if (event->state & Button4Mask) state |= 8;
    if (event->state & Button5Mask) state |= 16;
    switch (event->type) {
        case ButtonPress: {
            switch (event->button) {
                case Button1: state |= 1; break;
                case Button2: state |= 2; break;
                case Button3: state |= 4; break;
                case Button4: state |= 8; break;
                case Button5: state |= 16; break;
            }
            break;
        }
        case ButtonRelease: {
            switch (event->button) {
                case Button1: state &= ~1; break;
                case Button2: state &= ~2; break;
                case Button3: state &= ~4; break;
                case Button4: state &= ~8; break;
                case Button5: state &= ~16; break;
            }
            break;
        }
    }
    qmouseevents(ws, state, 
                 event->x, event->y, 
                 (word)event->time, 
                 make_mod(event->state));
    UpdateRecent(ws, event);
}

/*
 * Given an ellipse with major/minor axes rx, ry and centre at origin,
 * return the polar coordinate radius for the given angle th.  Also
 * calculate the (x, y) position corresponding to (r, th).
 */
static double calc_pt(double *x, double *y, double rx, double ry, double th)
{
    double r;
    /* Get the polar coordinates radius relative to center */
    if (rx == ry)    /* Easy case if a circle */
        r = rx;
    else
        r = (rx * ry) / hypot(rx * sin(th), ry * cos(th));
    *x = r * cos(th);
    *y = r * sin(th);
    return r;
}

/*
 * Calculate a factor to use when progressing an angle around an arc,
 * given an ellipse's major and minor axes.
 */
static double calc_progress_factor(double rx, double ry)
{
    double min_r, max_r, arc_res;

    min_r = Min(rx, ry);
    max_r = Max(rx, ry);

    /* The smaller the radius in pixels, the fewer steps we need.  In
     * any case, limit within a range. */
    arc_res = 5.0 / max_r;
    arc_res = Max(arc_res, 0.0125);
    arc_res = Min(arc_res, 0.25);

    /*
     * The returned factor is divided by r, the polar radius for the
     * current angle in the iteration.  The longer r is compared to
     * the shorter axis, the more points we generate.
     */
    return arc_res * min_r;
}

void drawarc(wbp w, double cx, double cy, double rx, double ry, double angle1, double angle2)
{
    double th, r, pf, x, y;
    struct point *pts;
    int maxpts, npts;

    pf = calc_progress_factor(rx, ry);
    maxpts = 100;
    pts = safe_malloc(maxpts * sizeof(struct point));
    npts = 0;
    th = angle1;
    while (th < angle1 + angle2) {
        r = calc_pt(&x, &y, rx, ry, th);
        x += cx;
        y += cy;
        if (npts == 0 || fabs(pts[npts - 1].x - x) >= 1.0 || fabs(pts[npts - 1].y - y) >= 1.0) {
            if (npts == maxpts) {
                maxpts += 100;
                pts = safe_realloc(pts, maxpts * sizeof(struct point));
            }
            pts[npts].x = x;
            pts[npts].y = y;
            ++npts;
        }
        th += pf / r;
    }

    /* Space for the last point */
    if (npts == maxpts) {
        maxpts++;
        pts = safe_realloc(pts, maxpts * sizeof(struct point));
    }

    if (angle2 == 2 * Pi)
        pts[npts] = pts[0];  /* Ensure drawlines recognizes a closed arc */
    else {
        calc_pt(&x, &y, rx, ry, angle1 + angle2);
        pts[npts].x = cx + x;
        pts[npts].y = cy + y;
    }
    ++npts;

    drawlines(w, pts, npts);
    free(pts);
}

static void mk_ellipse(double cx, double cy, double rx, double ry, struct traplist *tl)
{
    double th, r, pf, x, y, t1x, b, b1, t, t1, b1x;

    /* Very small radius circles just add a single square trap of
     * equivalent area. */
    if (rx == ry && rx <= 1 && ry <= 1) {
        double sq;
        /* sq is half the side of a square with the same area as the circle, ie
         *  (2*sq)^2 = Pi*rx^2
         * sq is then reduced slightly since the ellipse algorithm draws
         * within the outline (and thus leaves small gaps).
         */
        sq = 0.98 * rx * sqrt(Pi) / 2;
        add_trap(tl,
                 cy - sq, cx - sq, cx + sq,
                 cy + sq, cx - sq, cx + sq);
        return;
    }
    
    pf = calc_progress_factor(rx, ry);
    th = 0.0;
    t1x = b1x = rx;
    b1 = t1 = cy;
    while (th < Pi / 2.0) {
        r = calc_pt(&x, &y, rx, ry, th);
        t = cy - y;
        if (t < t1) {
            add_trap(tl, t, cx - x, cx + x, t1, cx - t1x, cx + t1x);
            t1 = t;
            t1x = x;
        }

        b = cy + y;
        if (b > b1) {
            add_trap(tl, b1, cx - b1x, cx + b1x, b, cx - x,  cx + x);
            b1 = b;
            b1x = x;
        }
        th += pf / r;
    }

    /* Fill in top/bottom, by setting th = Pi/2 (calc_pt would give
     * r=y=ry, x=0) */
    t = cy - ry;
    if (t < t1)
        add_trap(tl, t, cx, cx, t1, cx - t1x, cx + t1x);

    b = cy + ry;
    if (b > b1)
        add_trap(tl, b1, cx - b1x, cx + b1x, b, cx,  cx);
}

void fillarc(wbp w, double cx, double cy, double rx, double ry, double angle1, double angle2)
{ 
    wsp ws = w->window;
    wdp wd = ws->display;
    wcp wc = w->context;
    int has_wedge;
    struct traplist tl;

    has_wedge = (angle1 != 0 || angle2 != 2 * Pi);

    init_traplist(&tl, 100);

    if (has_wedge || needmask(wc, 0)) {
        Picture mask;
        int x, y, width, height;
        double h2, w2;

        /*
         * calculate width and height for the masks, and their x, y
         * position to draw onto the screen.  Note that width and
         * height are even; this avoids any antialiasing relics when
         * joining trapezoids and rectangles in the wedge mask.
         */
        x = floor(cx - rx);
        y = floor(cy - ry);
        width = 2 * ceil(cx - x);
        height = 2 * ceil(cy - y);
        h2 = height / 2.0;
        w2 = width / 2.0;
        /* printf("cx,cy=%f,%f rx,ry=%f,%f  ->   x,y=%d,%d   width.height=%d,%d   w2,h2=%f,%f\n",cx,cy,rx,ry,x,y,width,height,w2,h2); */

        mk_ellipse(cx - x, cy - y,    /* centre */
                   rx, ry,            /* x/y radius */
                   &tl);
        mask = getmask(wd, width, height);
        draw_traplist(&tl,
                      wd->display, PictOpOver, wd->white->brush,  mask);

        if (has_wedge) {
            XTrapezoid traps[3];
            Picture wedge1, wedge2;
            double x1, x2, y1, y2, a1, a2;
            int op;
            if (angle1 + angle2 < 2 * Pi) {
                /* Calculate a wedge to include */
                a1 = angle1;
                a2 = angle1 + angle2;
                op = PictOpInReverse;
            } else {
                /* Calculate a wedge to exclude */
                a1 = angle1 + angle2 - 2 * Pi;
                a2 = angle1;
                op = PictOpOutReverse;
            }

            /* wedge1 is everything swept forward clockwise from a1 to
             * 3pm.  wedge2 is the area from a2 swept back
             * anticlockwise to 3pm; The intersection of the two gives
             * the wedge to either include or exclude.
             * 
             * The calculations have several cases concerning x1, x2,
             * because taking the tangents of small angles leads to
             * numbers that xrender can't represenent.
             */
            wedge1 = getmask(wd, width, height);
            wedge2 = getmask(wd, width, height);
            if (NearZero(a1 - 2*Pi, 1)) ;
            else if (NearZero(a1, 1))
                XRenderFillRectangle(wd->display, PictOpOver, wedge1, &wd->white->color, 0, 0, width ,height); 
            else if (NearZero(a1 - Pi, 1))
                XRenderFillRectangle(wd->display, PictOpOver, wedge1, &wd->white->color, 0, 0, width ,h2);
            else if (a1 > Pi) {
                x1 = w2 - h2 / tan(a1 - Pi);
                if (x1 < 0) {
                    y1 = h2 - w2 * tan(a1 - Pi);
                    traps[0] = trapezoid(0,0,width,y1,0,width);
                    traps[1] = trapezoid(y1,0,width, h2, w2, width);
                    XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  wedge1, 0, 0, 0, traps, 2);
                } else if (x1 > width) {
                    y1 = h2 - w2 * tan(2 * Pi - a1);
                    traps[0] = trapezoid(y1,width,width, h2, w2, width);
                    XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  wedge1, 0, 0, 0, traps, 1);
                } else {
                    traps[0] = trapezoid(0,x1,width,  h2, w2, width);
                    XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  wedge1, 0, 0, 0, traps, 1);
                }
            } else {
                x1 = w2 - h2 * tan(a1 - Pi/2);
                if (x1 < 0) {
                    y1 = h2 + w2 * tan(Pi - a1);
                    traps[0] = trapezoid(0,0,width, h2,0,width);
                    traps[1] = trapezoid(h2,0,w2, y1,0,0);
                    XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  wedge1, 0, 0, 0, traps, 2);
                }
                else if (x1 > width) {
                    y1 = h2 + w2 * tan(a1);
                    traps[0] = trapezoid(0,0,width, h2,0,width);
                    traps[1] = trapezoid(h2,0,w2,  y1,0,width);
                    traps[2] = trapezoid(y1,0,width, height,0,width);
                    XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  wedge1, 0, 0, 0, traps, 3);
                } else {
                    traps[0] = trapezoid(0,0,width, h2,0,width);
                    traps[1] = trapezoid(h2,0,w2, height,0,x1);
                    XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  wedge1, 0, 0, 0, traps, 2);
                }
            }

            /*
            clip(w);
            maskpic2(w, wedge1, x, y, width, height);
            return;
            */

            if (NearZero(a2, 1)) ;
            else if (NearZero(a2 - 2*Pi, 1))
                XRenderFillRectangle(wd->display, PictOpOver, wedge2, &wd->white->color, 0, 0, width ,height); 
            else if (NearZero(a2 - Pi, 1))
                XRenderFillRectangle(wd->display, PictOpOver, wedge2, &wd->white->color, 0, h2, width ,h2); 
            else if (a2 > Pi) {
                x2 = w2 - h2 / tan(a2 - Pi);
                if (x2 < 0) {
                    y2 = h2 - w2 * tan(a2 - Pi);
                    traps[0] = trapezoid(y2,0,0, h2,0,w2);
                    traps[1] = trapezoid(h2,0,width, height,0,width);
                    XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  wedge2, 0, 0, 0, traps, 2);
                } else if (x2 > width) {
                    y2 = h2 - w2 * tan(2 * Pi - a2);
                    traps[0] = trapezoid(0,0,width, y2,0,width);
                    traps[1] = trapezoid(y2,0,width, h2, 0, w2);
                    traps[2] = trapezoid(h2,0,width, height, 0, width);
                    XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  wedge2, 0, 0, 0, traps, 3);
                } else {
                    traps[0] = trapezoid(0,0,x2,  h2,0,w2);
                    traps[1] = trapezoid(h2,0,width, height, 0, width);
                    XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  wedge2, 0, 0, 0, traps, 2);
                }
            } else {
                x2 = w2 - h2 * tan(a2 - Pi/2);
                if (x2 < 0) {
                    y2 = h2 + w2 * tan(Pi - a2);
                    traps[0] = trapezoid(h2,w2,width,  y2, 0, width);
                    traps[1] = trapezoid(y2,0,width, height, 0, width);
                    XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  wedge2, 0, 0, 0, traps, 2);
                } else if (x2 > width) {
                    y2 = h2 + w2 * tan(a2);
                    traps[0] = trapezoid(h2,w2,width,  y2, width, width);
                    XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  wedge2, 0, 0, 0, traps, 1);
                } else {
                    traps[0] = trapezoid(h2, w2, width,  height, x2, width);
                    XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  wedge2, 0, 0, 0, traps, 1);
                }
            }

            /*
            clip(w);
            maskpic2(w, wedge2, x, y, width, height);
            return;
            */

            XRenderComposite(wd->display,
                             op,
                             wedge1,          /* src */
                             wedge2,         /* mask */
                             mask,           /* dest */
                             0,0,            /* src x,y */
                             0,0,            /* mask x,y */
                             0, 0,           /* dst x,y */
                             width, height);

            XRenderFreePicture(wd->display, wedge1);
            XRenderFreePicture(wd->display, wedge2);
        }
        clip(w);
        maskpic2(w, mask, x, y, width, height);
        XRenderFreePicture(wd->display, mask);
    } else {
        clip(w);

        mk_ellipse(cx, cy,
                   rx, ry,
                   &tl);
        draw_traplist(&tl,
                      wd->display,
                      wc->drawop->i,
                      get_draw_picture(wc),
                      ws->ppic);
        pix_to_win(ws, cx - rx - 2, cy - ry - 2, 2 * rx + 4, 2 * ry + 4);
    }

    free_traplist(&tl);
}

/*
 * Some simple functions for accumulating an array of XTrapezoids.
 */

static void init_traplist(struct traplist *l, int alloc)
{
    l->n = 0;
    l->traps = safe_malloc(alloc * sizeof(XTrapezoid));
    l->alloc = alloc;
}

static void free_traplist(struct traplist *l)
{
    free(l->traps);
    l->traps = 0;
    l->alloc = l->n = 0;
}

static void draw_traplist(struct traplist *l, Display *display, int op, Picture src, Picture dest)
{
    XRenderCompositeTrapezoids(display, op, src, dest, 0,0,0, l->traps, l->n);
}

static void ensure_traps(struct traplist *l, int need)
{
    if (l->n + need > l->alloc) {
        l->alloc = 2 * (l->n + need);
        l->traps = safe_realloc(l->traps, l->alloc * sizeof(XTrapezoid) );
    }
}

#define Swap(a,b) { XPointDouble *v; v = a; a = b; b = v; }

static void add_tri(struct traplist *l,
                    XPointDouble *p1, XPointDouble *p2, XPointDouble *p3)
{
    XTrapezoid t1, t2;

    if (p1->x == p2->x && p2->x == p3->x)
        return;

    /* Sort the points into ascending y order. */
    if (p1->y > p3->y) { Swap(p1,p3); }
    if (p1->y > p2->y) { Swap(p1,p2); }
    if (p2->y > p3->y) { Swap(p2,p3); }

    ensure_traps(l, 2);

    /*
     * Turning a triangle into 2 trapezoids falls into two cases.  In
     * the first case the left line is shared between the two and in
     * the second, the right line is shared.
     * 
     * Example first case :-
     * 
     *        -------x1---------------------------- y1
     *                \ \
     *                 \   \
     *                  \     \
     *                   \       \
     *        ------------\---------x2------------- y2
     *                     \      /
     *                      \   /
     *                       \/
     *        ---------------x3-------------------- y3
     * 
     * 
     * Example second case :-
     * 
     * 
     *        ----------------x1------------------- y1
     *                       / \
     *                      /   \
     *                     /     \
     *                    /       \
     *        -----------x2--------\--------------- y2
     *                     \        \
     *                        \      \
     *                           \    \
     *        -------------------------x3---------- y3
     * 
     * 
     */
    t1.top = XDoubleToFixed(p1->y);
    t1.bottom = t2.top = XDoubleToFixed(p2->y);
    t2.bottom = XDoubleToFixed(p3->y);
    t1.left.p1.x = XDoubleToFixed(p1->x);
    t1.left.p1.y = t1.top;          // p1->y
    if ( (p1->x <= p2->x && p2->x <= p3->x) ||
         (p1->x <= p3->x && p3->x <= p2->x) ||
         (p3->x <= p1->x && p1->x <= p2->x) )
    {
        t1.left.p2.x = XDoubleToFixed(p3->x);
        t1.left.p2.y = t2.bottom;   // p3->y
        t1.right.p1 = t1.left.p1;
        t1.right.p2.x = XDoubleToFixed(p2->x);
        t1.right.p2.y = t1.bottom;  // p2->y
        t2.left = t1.left;
        t2.right.p1 = t1.right.p2;
        t2.right.p2 = t2.left.p2;
    }
    else {
        t1.left.p2.x = XDoubleToFixed(p2->x);
        t1.left.p2.y = t1.bottom;   // p2->y
        t1.right.p1 = t1.left.p1;
        t1.right.p2.x = XDoubleToFixed(p3->x);
        t1.right.p2.y = t2.bottom;  // p3->y
        t2.left.p1 = t1.left.p2;
        t2.left.p2 = t1.right.p2;
        t2.right = t1.right;
    }

    if (t1.top != t1.bottom)
        l->traps[l->n++] = t1;
    if (t2.top != t2.bottom)
        l->traps[l->n++] = t2;
}

static void add_trap(struct traplist *l,
                     double top, double x1, double x2, double bottom, double x3, double x4)
{
    ensure_traps(l, 1);
    l->traps[l->n++] = trapezoid(top, x1, x2, bottom, x3, x4);
}

static void add_rect(struct traplist *l, XPointDouble *tl, XPointDouble *br)
{
    add_trap(l, tl->y, tl->x, br->x,  br->y, tl->x, br->x);
}


/*
 * The orientation of the computed corner points is always the same
 * (p0 and q0 are the given input points, linewidth comes from the
 * context), as follows :-
 *  
 *   p2 -------------------- q2      ^
 *   |                       |       |
 *   p0       -->--          q0   linewidth
 *   |                       |       |
 *   p1 ---------------------q1      v
 *
 *   <-------- len ---------->
 */

static void getlineinfo(wcp wc, XPointDouble *p0, XPointDouble *q0, struct lineinfo *res)
{
    double ex, ey;
    res->dx = q0->x - p0->x;
    res->dy = q0->y - p0->y;
    res->len = hypot(res->dx, res->dy);
    res->p0 = *p0;
    res->q0 = *q0;
    ex = (wc->linewidth * res->dy) / (2 * res->len);
    ey = -(wc->linewidth * res->dx) / (2 * res->len);
    res->p1 = doublept(p0->x - ex ,p0->y - ey);
    res->p2 = doublept(p0->x + ex, p0->y + ey);
    res->q1 = doublept(q0->x - ex ,q0->y - ey);
    res->q2 = doublept(q0->x + ex, q0->y + ey);
}

static XPointDouble get_miter_point(struct lineinfo *prev, struct lineinfo *curr)
{
    if (curr->dx * prev->dy > curr->dy * prev->dx)
        return intersect(&curr->p1, &curr->q1, &prev->p1, &prev->q1);
    else
        return intersect(&curr->p2, &curr->q2, &prev->p2, &prev->q2);
}

static double dotprod(struct lineinfo *u, struct lineinfo *v)
{
    return u->dx * v->dx + u->dy * v->dy;
}

/*
 * Get the angle between two line segments.
 * 
 *  https://math.stackexchange.com/questions/1858274/how-to-determine-if-two-lines-are-parallel-almost-parallel
 */
static double anglediff(struct lineinfo *u, struct lineinfo *v)
{
    double det, s;
    det = u->dx * v->dy - u->dy * v->dx;
    s = det / (u->len * v->len);
    return asin(s);
}

static int almost_straight(struct lineinfo *u, struct lineinfo *v)
{
    return fabs(anglediff(u, v)) < 0.1;
}

static void calc_extent(wcp wc, struct lineinfo *lis, int n, int closed, int *x, int *y, int *width, int *height)
{
    int i;
    double x1, x2, y1, y2;
    x1 = x2 = y1 = y2 = 0.0;
    for (i = 0; i < n; ++i) {
        struct lineinfo *li = &lis[i]; 
        if (i == 0) {
            x1 = x2 = li->p1.x;
            y1 = y2 = li->p1.y;

            if (closed && wc->linejoin->i == JoinMiter && !almost_straight(&lis[n - 1], &lis[i])) {
                XPointDouble m;
                m = get_miter_point(&lis[n - 1], &lis[i]);
                if (m.x < x1) x1 = m.x;
                if (m.x > x2) x2 = m.x;
                if (m.y < y1) y1 = m.y;
                if (m.y > y2) y2 = m.y;
            }

        } else {
            if (li->p1.x < x1) x1 = li->p1.x;
            if (li->p1.x > x2) x2 = li->p1.x;
            if (li->p1.y < y1) y1 = li->p1.y;
            if (li->p1.y > y2) y2 = li->p1.y;
            if (wc->linejoin->i == JoinMiter && !almost_straight(&lis[i - 1], &lis[i])) {
                XPointDouble m;
                m = get_miter_point(&lis[i - 1], &lis[i]);
                if (m.x < x1) x1 = m.x;
                if (m.x > x2) x2 = m.x;
                if (m.y < y1) y1 = m.y;
                if (m.y > y2) y2 = m.y;
            }
        }
        if (li->p2.x < x1) x1 = li->p2.x;
        if (li->p2.x > x2) x2 = li->p2.x;
        if (li->p2.y < y1) y1 = li->p2.y;
        if (li->p2.y > y2) y2 = li->p2.y;
        if (li->q1.x < x1) x1 = li->q1.x;
        if (li->q1.x > x2) x2 = li->q1.x;
        if (li->q1.y < y1) y1 = li->q1.y;
        if (li->q1.y > y2) y2 = li->q1.y;
        if (li->q2.x < x1) x1 = li->q2.x;
        if (li->q2.x > x2) x2 = li->q2.x;
        if (li->q2.y < y1) y1 = li->q2.y;
        if (li->q2.y > y2) y2 = li->q2.y;
    }
    x1 -= wc->linewidth / 2.0;
    y1 -= wc->linewidth / 2.0;
    x2 += wc->linewidth / 2.0;
    y2 += wc->linewidth / 2.0;
    range_extent(x1, y1, x2, y2, x, y, width, height);
}

static XPointDouble doublept(double x, double y)
{
    XPointDouble t;
    t.x = x;
    t.y = y;
    return t;
}

static XTrapezoid trapezoid(double top, double x1, double x2, double bottom, double x3, double x4)
{
    XTrapezoid t;
    t.top = XDoubleToFixed(top);
    t.left.p1.x = XDoubleToFixed(x1);
    t.left.p1.y = t.top;
    t.right.p1.x = XDoubleToFixed(x2);
    t.right.p1.y = t.top;
    t.bottom = XDoubleToFixed(bottom);
    t.left.p2.x = XDoubleToFixed(x3);
    t.left.p2.y = t.bottom;
    t.right.p2.x = XDoubleToFixed(x4);
    t.right.p2.y = t.bottom;
    return t;
}

static void roundjoin(wcp wc, XPointDouble *r, struct traplist *tl)
{
    double radius;
    radius = wc->linewidth / 2.0;
    mk_ellipse(r->x, r->y,
               radius, radius,
               tl);
}

/*
 * Return the intersection of the two straight lines defined by the
 * pairs of points (a1,a2) and (b1,b2).
 */
static XPointDouble intersect(XPointDouble *a1, XPointDouble *a2, XPointDouble *b1, XPointDouble *b2)
{
    double a, b, d;

    a = (a1->x * a2->y - a1->y * a2->x);
    b = (b1->x * b2->y - b1->y * b2->x);
    d = ( (a1->x - a2->x) * (b1->y - b2->y) - (a1->y - a2->y) * (b1->x -b2->x) );

    return doublept((a * (b1->x -b2->x) - (a1->x - a2->x) * b ) / d,
                    (a * (b1->y- b2->y) - (a1->y - a2->y) * b ) / d);
}

/*
 * Given two points a and b on a straight line, extend the line d
 * units from b.  Positive d means away from a :-
 * 
 *    a                          b    d>0  r     
 *    +--------------------------+---------+
 * 
 * or
 * 
 *    a                 r  d<0   b     
 *    +-----------------+--------+
 * 
 * where r is the result.
 */
static XPointDouble nudge(XPointDouble *a, XPointDouble *b, double d)
{
    double dx, dy, ex, ey, h;

    dx = b->x - a->x;
    dy = b->y - a->y;

    if (dy == 0) {
        if (dx < 0)
            return doublept(b->x - d, b->y);
        else
            return doublept(b->x + d, b->y);
    }

    h = hypot(dx, dy);
    ex = dx * (h + d) / h;
    ey = dy * (h + d) / h;

    return doublept(a->x + ex, a->y + ey);
}

/*
 * Output a segment.  It is important to output a vertical or
 * horizontal segment as a single trapezoid to avoid some bugs in
 * Xrender.
 */
static void drawlineinfo1(struct lineinfo *u, struct traplist *tl)
{
    if (u->dx == 0) {
        if (u->p1.y < u->q1.y)
            add_rect(tl, &u->p1, &u->q2);
        else
            add_rect(tl, &u->q2, &u->p1);
    } else if (u->dy == 0) {
        if (u->p1.x < u->q1.x)
            add_rect(tl, &u->p2, &u->q1);
        else
            add_rect(tl, &u->q1, &u->p2);
    } else {
        add_tri(tl, &u->p2, &u->p1, &u->q2);
        add_tri(tl, &u->q1, &u->p1, &u->q2);
    }
}

static void drawlineend(wcp wc,
                        struct lineinfo *u,
                        int end,
                        struct traplist *tl)
{
    XPointDouble *A0, *A1, *A2, *C0, N;
    struct lineinfo li;

    if (wc->lineend->i == EndFlat)
        return;

    if (end) {
        A0 = &u->q0;
        C0 = &u->p0;
        A1 = &u->q1;
        A2 = &u->q2;
    } else {
        A0 = &u->p0;
        C0 = &u->q0;
        A1 = &u->p1;
        A2 = &u->p2;
    }

    if (wc->lineend->i == EndRound) {
        roundjoin(wc, A0, tl);
        return;
    }

    N = nudge(C0, A0, wc->linewidth / 2);
    switch (wc->lineend->i) {
        case EndPoint: {
            add_tri(tl, A1, A2, &N);
            break;
        }
        case EndSquare: {
            getlineinfo(wc, A0, &N, &li);
            drawlineinfo1(&li, tl);
            break;
        }
        default:
            syserr("Unexpected lineend");
    }
}

static void drawlineinfo(wcp wc,
                         struct lineinfo *prev,
                         struct lineinfo *curr,
                         struct lineinfo *next,
                         struct traplist *tl)
{
    /* Output the current segment. */
    drawlineinfo1(curr, tl);

    if (prev) {
        /*
         * dotprod() determines whether the segments are aligned
         * end-to-end rather than overlapping.
         */
        if (wc->linejoin->i != JoinRound || (almost_straight(prev, curr) && dotprod(prev, curr) > 0)) {
            XPointDouble *A1, *A2;

            /*
             *                  A2      A1
             *                  /\      /\
             *                 /   \   /   \
             *                /      \/P0    \ 
             *               /       / \       \
             *              /       /    \       \
             *             /       /     /         \
             *            /         \   /            \
             *           /  prev      \/     curr      \
             *                        / \
             *                       /   \ 
             *                               
             */

            if (curr->dx * prev->dy > curr->dy * prev->dx) {
                A1 = &curr->p1;
                A2 = &prev->q1;
            } else {
                A1 = &curr->p2;
                A2 = &prev->q2;
            }

            /*
             * The bevel triangle.
             */
            add_tri(tl, &curr->p0, A1, A2);

            /*
             * The miter triangle.
             */
            if (wc->linejoin->i == JoinMiter && !almost_straight(prev, curr)) {
                XPointDouble m = get_miter_point(prev, curr);
                add_tri(tl, &m, A1, A2);
            }
        } else
            roundjoin(wc, &curr->p0, tl);
    } else
        drawlineend(wc, curr, 0, tl);

    if (!next)
        drawlineend(wc, curr, 1, tl);
}

static void drawlineinfos_impl(wbp w, struct lineinfo *lis, int nlis, int closed, struct traplist *tl)
{
    wcp wc = w->context;
    int i;
    for (i = 0; i < nlis; ++i) {
        struct lineinfo *prev, *next;
        if (i > 0)
            prev = &lis[i - 1];
        else
            prev = closed ? &lis[nlis - 1] : 0;
        if (i < nlis - 1)
            next = &lis[i + 1];
        else
            next = closed ? &lis[0] : 0;
        drawlineinfo(wc, prev, &lis[i], next, tl);
    }
}

static XPointDouble adjustpoint(wcp wc, struct point *points, int npoints, int i, int closed)
{
    XPointDouble pd;
    pd.x = points[i].x;
    pd.y = points[i].y;
    /*
     * If the linewidth is odd, shift exactly horizontal and vertical
     * segments lying exact pixel lines by 0.5 pixel so that they are
     * not output with antialiased edges.
     */
    if (fmod(wc->linewidth, 2) == 1) {
        struct point *next, *prev;
        if (i > 0)
            prev = &points[i - 1];
        else
            prev = closed ? &points[npoints - 1] : 0;
        if (i < npoints - 1)
            next = &points[i + 1];
        else
            next = closed ? &points[0] : 0;
        if ((prev && prev->x == points[i].x && fmod(prev->x, 1.0) == 0) || (next && next->x == points[i].x && fmod(next->x, 1.0) == 0))
            pd.x += 0.5;
        if ((prev && prev->y == points[i].y && fmod(prev->y, 1.0) == 0) || (next && next->y == points[i].y && fmod(next->y, 1.0) == 0))
            pd.y += 0.5;
    }
    return pd;
}
 
static void drawlineinfos(wbp w, struct lineinfo *lis, int nlis, int closed)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    wcp wc = w->context;
    int i, x, y, width, height;
    struct traplist tl;

    if (nlis == 0)
        return;

    calc_extent(wc, lis, nlis, closed, &x, &y, &width, &height);

    if (x < 0)  { 
        width += x; 
        x = 0; 
    }
    if (y < 0)  { 
        height += y; 
        y = 0; 
    }
    if (x + width > ws->width)
        width = ws->width - x; 
    if (y + height > ws->height)
        height = ws->height - y; 

    init_traplist(&tl, nlis * 3);

    clip(w);
    if (needmask(wc, 1)) {
        Picture mask = getmask(wd, width, height);
        for (i = 0; i < nlis; ++i) {
            lis[i].p0.x -= x; lis[i].p0.y -= y;
            lis[i].p1.x -= x; lis[i].p1.y -= y;
            lis[i].p2.x -= x; lis[i].p2.y -= y;
            lis[i].q0.x -= x; lis[i].q0.y -= y;
            lis[i].q1.x -= x; lis[i].q1.y -= y;
            lis[i].q2.x -= x; lis[i].q2.y -= y;
        }
        drawlineinfos_impl(w, lis, nlis, closed, &tl);
        draw_traplist(&tl, wd->display, PictOpOver, wd->white->brush, mask);
        maskpic2(w, mask, x, y, width, height);
        XRenderFreePicture(wd->display, mask);
    } else {
        drawlineinfos_impl(w, lis, nlis, closed, &tl);
        draw_traplist(&tl, wd->display, wc->drawop->i, get_draw_picture(wc), ws->ppic);
        pix_to_win(ws, x, y, width, height);
    }

    free_traplist(&tl);
}

void drawlines(wbp w, struct point *points, int npoints)
{
    wcp wc = w->context;
    struct lineinfo *lis;
    int nlis, i, closed;
    XPointDouble pd1, pd2;

    if (npoints < 2)
        return;
    closed = points[npoints - 1].x == points[0].x && points[npoints - 1].y == points[0].y;

    lis = safe_malloc((npoints - 1) * sizeof(struct lineinfo));
    pd1 = adjustpoint(wc, points, npoints, 0, closed);
    nlis = 0;
    for (i = 1; i < npoints; ++i) {
        if (points[i - 1].x != points[i].x || points[i - 1].y != points[i].y) {
            pd2 = adjustpoint(wc, points, npoints, i, closed);
            getlineinfo(wc, &pd1, &pd2, &lis[nlis]);
            nlis++;
            pd1 = pd2;
        }
    }

    drawlineinfos(w, lis, nlis, closed);
    free(lis);
}

static int needmask(wcp wc, int overlap)
{
    /* ops where influence of source pixel is 0 (clear, dest) */
    if (wc->drawop->i == PictOpClear || wc->drawop->i == PictOpDst)
        return 0;
    if (wc->pattern)
        return 1;
    if (!overlap)
        return 0;
    /* overlap doesn't matter if influence of dest pixel is 0 */
    if (wc->drawop->i == PictOpSrc)
        return 0;
    if (wc->fg->color.alpha == 0xffff && wc->drawop->i == PictOpOver)
        return 0;
    return 1;
}

static Picture getmask(wdp wd, int width, int height)
{
    Pixmap pix;
    Picture pic;
    XRenderPictureAttributes attr;
    pix = XCreatePixmap(wd->display, GetRoot(wd),
                        width, height,
                        8);
    attr.poly_edge = PolyEdge;
    attr.poly_mode = PolyMode;
    pic = XRenderCreatePicture(wd->display, pix, wd->maskfmt, CPPolyEdge|CPPolyMode, &attr);
    XFreePixmap(wd->display, pix);
    XRenderFillRectangle(wd->display, PictOpSrc, pic, &wd->transparent->color, 0, 0, width ,height);
    return pic;
}

void drawrectangle(wbp w, int x, int y, int width, int height, int thick)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    wcp wc = w->context;
    /* If too small to give a gap in the middle, then simply fill a
     * rectangle, otherwise draw as four lines. */
    if (width <= 2 * thick || height <= 2 * thick)
        fillrectangle(w, x, y, width, height);
    else {
        clip(w);
        /* Note that we know the two vertical lines will be at least one pixel high, since
         * height > 2 * thick
         */
        if (wc->pattern) {
            pat1(w,
                 x, y,
                 width, thick);
            pat1(w,
                 x, y +  thick,
                 thick, height - 2 * thick);
            pat1(w,
                 x + width - thick, y + thick,
                 thick, height - 2 * thick);
            pat1(w,
                 x, y + height - thick,
                 width, thick);
        } else {
            XRectangle r[4];
            r[0].x = x;
            r[0].y = y;
            r[0].width = width;
            r[0].height = thick;
            r[1].x = x;
            r[1].y = y +  thick;
            r[1].width = thick;
            r[1].height = height - 2 * thick;
            r[2].x = x + width - thick;
            r[2].y = y + thick;
            r[2].width = thick;
            r[2].height = height - 2 * thick;
            r[3].x = x;
            r[3].y = y + height - thick;
            r[3].width = width;
            r[3].height = thick;
            XRenderFillRectangles(wd->display,
                                  wc->drawop->i,
                                  ws->ppic,
                                  &wc->fg->color,
                                  r, 4);
        }

        pix_to_win(ws, x, y, width, height);
    }
}

void fillpolygon(wbp w, struct point *points, int npoints)
{
    XPointDouble *xpoints;
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    int x, y, width, height, i;
    if (npoints < 3)
        return;
    points_extent(points, npoints, &x, &y, &width, &height);
    xpoints = safe_malloc(npoints * sizeof(XPointDouble));
    clip(w);
    if (needmask(wc, 0)) {
        Picture mask;
        for (i = 0; i < npoints; ++i) {
            xpoints[i].x = points[i].x - x;
            xpoints[i].y = points[i].y - y;
        }
        mask = getmask(wd, width, height);

        CompositeDoublePoly(wd->display, 
                            PictOpOver,
                            wd->white->brush,
                            mask, 
                            None, 0, 0, 0, 0,
                            xpoints, npoints, 0);

        maskpic2(w, mask, x, y, width, height);
        XRenderFreePicture(wd->display, mask);
    } else {
        for (i = 0; i < npoints; ++i) {
            xpoints[i].x = points[i].x;
            xpoints[i].y = points[i].y;
        }
        CompositeDoublePoly(wd->display, 
                            wc->drawop->i,
                            get_draw_picture(wc),
                            ws->ppic, 
                            None, 0, 0, 0, 0,
                            xpoints, npoints, 0);
        pix_to_win(ws, x, y, width, height);
    }
    free(xpoints);
}

void filltriangles(wbp w, struct triangle *tris, int ntris)
{
    struct traplist tl;
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    int x, y, width, height, i;

    triangles_extent(tris, ntris, &x, &y, &width, &height);
    init_traplist(&tl, 2 * ntris);
    clip(w);
    if (needmask(wc, 1)) {
        Picture mask;
        for (i = 0; i < ntris; ++i) {
            tris[i].p1.x -= x; tris[i].p1.y -= y;
            tris[i].p2.x -= x; tris[i].p2.y -= y;
            tris[i].p3.x -= x; tris[i].p3.y -= y;
            add_tri(&tl,
                    (XPointDouble *)&tris[i].p1,
                    (XPointDouble *)&tris[i].p2,
                    (XPointDouble *)&tris[i].p3);
        }
        mask = getmask(wd, width, height);
        draw_traplist(&tl,
                      wd->display, PictOpOver, wd->white->brush,  mask);
        maskpic2(w, mask, x, y, width, height);
        XRenderFreePicture(wd->display, mask);
    } else {
        for (i = 0; i < ntris; ++i)
            add_tri(&tl,
                    (XPointDouble *)&tris[i].p1,
                    (XPointDouble *)&tris[i].p2,
                    (XPointDouble *)&tris[i].p3);
        draw_traplist(&tl,
                      wd->display,
                      wc->drawop->i,
                      get_draw_picture(wc),
                      ws->ppic);
        pix_to_win(ws, x, y, width, height);
    }
    free_traplist(&tl);
}

static void maskpic2(wbp w, Picture mask, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    XRenderComposite(wd->display,
                     wc->drawop->i,
                     get_draw_picture(wc),          /* src */
                     mask,         /* mask */
                     ws->ppic,     /* dest */
                     x,y,          /* src x,y */
                     0,0,          /* mask x,y */
                     x, y,         /* dst x,y */
                     width, height);
    pix_to_win(ws, x, y, width, height);
}

static void pat1(wbp w, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    XRenderComposite(wd->display,
                     wc->drawop->i,
                     wc->pattern->i,  /* src */
                     None,         /* mask */
                     ws->ppic,     /* dest */
                     x,y,          /* src x,y */
                     0,0,          /* mask x,y */
                     x, y,         /* dst x,y */
                     width, height);
}

static void pat2(wbp w, int x, int y, int width, int height)
{
    pat1(w, x, y, width, height);
    pix_to_win(w->window, x, y, width, height);
}

static void fill2(wbp w, int op, XRenderColor *color, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    XRenderFillRectangle(wd->display,
                         op,
                         ws->ppic,
                         color,
                         x, y, width, height);
    pix_to_win(ws, x, y, width, height);
}

static Pixmap imgdata_to_Pixmap1(wdp wd, struct imgdata *imd)
{
    XImage *xi;
    Pixmap pix;
    GC gc;
    MemProtect(xi = XCreateImage(wd->display, 
                                 NULL,
                                 32,            /* depth */
                                 ZPixmap, 
                                 0, 
                                 (char *)imd->data, 
                                 imd->width, imd->height, 
                                 BitmapPad(wd->display),
                                 0));

    pix = XCreatePixmap(wd->display, GetRoot(wd),
                      imd->width, imd->height,
                      32);
    gc = XCreateGC(wd->display, pix, 0, NULL);
    XPutImage(wd->display, pix, gc, xi,
              0,0, 0,0, imd->width, imd->height);
    xi->data = 0;
    XDestroyImage(xi);
    XFreeGC(wd->display, gc);
    return pix;
}

Pixmap imgdata_to_Pixmap(wdp wd, struct imgdata *imd)
{
    struct imgdata *tmp;
    Pixmap pix;
    if (imd->format == wd->format)
        return imgdata_to_Pixmap1(wd, imd);
    tmp = initimgdata(imd->width, imd->height, wd->format);
    copyimgdata(tmp, imd);
    pix = imgdata_to_Pixmap1(wd, tmp);
    unlinkimgdata(tmp);
    return pix;
}

static Picture get_draw_picture(wcp wc)
{
    if (wc->pattern)
        return wc->pattern->i;
    else
        return wc->fg->brush;
}

/*
 * fill a rectangle
 */
void fillrectangle(wbp w, int x, int y, int width, int height)
{
    wcp wc = w->context;
    clip(w);
    /*
     * fill the rectangle with the pattern or foreground color
     */
    if (wc->pattern)
        pat2(w, 
             x, y, width, height);
    else
        fill2(w,
              wc->drawop->i,
              &wc->fg->color,
              x, y, width, height);
}

/*
 * erase an area
 */
void erasearea(wbp w, int x, int y, int width, int height)
{
    wcp wc = w->context;
    clip(w);
    /*
     * fill the rectangle with the background color
     */
    fill2(w,
          PictOpSrc,
          &wc->bg->color,
          x, y, width, height);
}

/*
 * copy an area
 */
int copyarea(wbp w, int x, int y, int width, int height, wbp w2, int x2, int y2, wbp w3, int x3, int y3)
{
    wsp ws1 = w->window;
    wsp ws2 = w2->window;
    wcp wc2 = w2->context;
    wdp wd1 = ws1->display;
    wdp wd2 = ws2->display;
    Picture mask;

    if (wd1->display != wd2->display) {
        LitWhy("Can't copy between different displays");
        return Failed;
    }

    if (w3) {
        wsp ws3 = w3->window;
        if (wd1->display != ws3->display->display) {
            LitWhy("Can't use a mask from a different display");
            return Failed;
        }
        no_clip(ws3, 0);
        mask = ws3->ppic;
    } else
        mask = None;

    /*
     * Copying is between windows on one display, perhaps the same window.
     */
    no_clip(ws1, 0);
    clip(w2);

    /*
     * Copy the area.
     */
    XRenderComposite(wd1->display,
                     wc2->drawop->i,
                     ws1->ppic,    /* src */
                     mask,         /* mask */
                     ws2->ppic,    /* dest */
                     x, y,         /* src_x,y */
                     x3, y3,       /* mask x,y */
                     x2, y2,       /* dst x,y */
                     width, height);
    pix_to_win(ws2, x2, y2, width, height);
    return Succeeded;
}

void captureimgdata(wbp w, int x, int y, struct imgdata *imd)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    XImage *xi;
    MemProtect(xi = XGetImage(wd->display, ws->pix,
                              x, y, imd->width, imd->height,
                              AllPlanes, ZPixmap));
    imd->format = wd->format;
    imd->data = (unsigned char *)xi->data;
    xi->data = 0;
    XDestroyImage(xi);
}

void drawimgdata(wbp w, int x, int y, struct imgdata *imd, int copy)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    Pixmap pix;
    Picture pic;
    pix = imgdata_to_Pixmap(wd, imd);
    pic = XRenderCreatePicture(wd->display, pix, wd->pixfmt, 0, 0);
    clip(w);

    XRenderComposite(wd->display,
                     copy ? PictOpSrc : wc->drawop->i,      /* op */
                     pic,          /* src */
                     None,         /* mask */
                     ws->ppic,     /* dest */
                     0,0,          /* src x,y */
                     0,0,          /* mask x,y */
                     x, y,         /* dst x,y */
                     imd->width, imd->height);
    pix_to_win(ws, x, y, imd->width, imd->height);

    XFreePixmap(wd->display, pix);
    XRenderFreePicture(wd->display, pic);
}

struct imgdataformat *getimgdataformat(wbp w)
{
    return w->window->display->format;
}

int querypointer(wbp w, int *x, int *y)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    Window garbage1, garbage2;
    int root_x, root_y;
    unsigned int key_buttons;
    CheckUnhidden(ws);
    /* XQueryPointer returns false if the pointer is not on the X11 Screen. */
    if (XQueryPointer(wd->display, ws->win, &garbage1, &garbage2,
                      &root_x, &root_y, x, y, &key_buttons) == False) {
        LitWhy("Pointer not on screen");
        return Failed;
    }
    return Succeeded;
}

int queryrootpointer(wbp w, int *x, int *y)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    Window garbage1, garbage2;
    int win_x, win_y;
    unsigned int key_buttons;
    /* XQueryPointer returns false if the pointer is not on the X11 Screen. */
    if (XQueryPointer(wd->display, GetRoot(wd), &garbage1, &garbage2,
                      x, y, &win_x, &win_y, &key_buttons) == False) {
        LitWhy("Pointer not on screen");
        return Failed;
    }
    return Succeeded;
}

int focuswindow(wbp w)
{
    XWindowAttributes attr;
    wsp ws = w->window;
    wdp wd = ws->display;
    CheckUnhidden(ws);
    /* From the manpage : The specified focus window must be viewable
     * at the time XSetInputFocus is called, or a BadMatch error
     * results. */
    XGetWindowAttributes(wd->display, ws->win, &attr);
    if (attr.map_state != IsViewable) {
        LitWhy("Can't focus window that is not viewable");
        return Failed;
    }
    XSetInputFocus(wd->display, ws->win, RevertToParent, CurrentTime);
    return Succeeded;
}

int raisewindow(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    XRaiseWindow(ws->display->display, ws->win);
    return Succeeded;
}

int lowerwindow(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    XLowerWindow(ws->display->display, ws->win);
    return Succeeded;
}

int getwindowid(wbp w, char **s)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    *s = buffprintf("0x%lx", (unsigned long)ws->win);
    return Succeeded;
}

int walert(wbp w, int volume)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    XBell(wd->display, volume);    
    XFlush(wd->display);
    return Succeeded;
}
/* Xft can't handle very long strings, and drawing very long ones can
 * cause an X error.  So the length of strings is limited when
 * calculating length or drawing. 
 */
static int limit_strlen(word n)
{
    return Min(n, 1500);
}

int textwidth(wbp w, dptr str)
{
    XGlyphInfo	extents; 
    if (is:string(*str))
        XftTextExtents8(w->window->display->display,
                        w->context->font->fsp,
                        (FcChar8 *)StrLoc(*str),
                        limit_strlen(StrLen(*str)),
                        &extents);
    else
        XftTextExtentsUtf8(w->window->display->display,
                           w->context->font->fsp,
                           (FcChar8 *)StrLoc(UcsBlk(*str).utf8),
                           limit_strlen(StrLen(UcsBlk(*str).utf8)),
                           &extents);
    
    /* xOff is a short; on long strings it wraps round at 32k, so
     * anding with 0xffff doubles the range of sensible result
     * values. */
    return extents.xOff & 0xffff;
}

static void prepare_xft(wbp w)
{
    XRectangle rec;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;

    if (!ws->pxft)
        MemProtect(ws->pxft = XftDrawCreateAlpha(wd->display, ws->pix, 32));

    if (wc->clipw >= 0) {
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XftDrawSetClipRectangles(ws->pxft, 0, 0, &rec, 1);
    } else
        XftDrawSetClip(ws->pxft, 0);
}

void drawstring(wbp w, int x, int y, dptr str)
{
    XftColor color;
    wcp wc = w->context;
    wsp ws = w->window;
    prepare_xft(w);
    color.pixel = 0;
    color.color = wc->fg->color;
    if (is:string(*str))
        XftDrawString8(ws->pxft,
                       &color,
                       wc->font->fsp,
                       x,
                       y,
                       (FcChar8 *)StrLoc(*str),
                       limit_strlen(StrLen(*str)));
    else
        XftDrawStringUtf8(ws->pxft,
                          &color,
                          wc->font->fsp,
                          x,
                          y,
                          (FcChar8 *)StrLoc(UcsBlk(*str).utf8),
                          limit_strlen(StrLen(UcsBlk(*str).utf8)));
    clip(w);
    pix_to_win(ws, 
               x, y - wc->font->ascent, 
               textwidth(w, str),
               wc->font->ascent + wc->font->descent);
}

/* This array must correspond with the NUMATOMS and ATOM_xxx constants defined in graphics.h. */
char *atom_names[NUMATOMS] = {
    "CHARACTER_POSITION",
    "CLIENT_WINDOW",
    "CLIPBOARD",
    "HOSTNAME",
    "HOST_NAME",
    "LENGTH",
    "LIST_LENGTH",
    "NAME",
    "OWNER_OS",
    "SPAN",
    "TARGETS",
    "TIMESTAMP",
    "USER",
    "WM_DELETE_WINDOW",
    "_NET_WM_STATE_MAXIMIZED_VERT",
    "_NET_WM_STATE_MAXIMIZED_HORZ",
    "_NET_WM_STATE_FULLSCREEN",
    "_NET_WM_STATE",
    "_NET_WM_ICON",
    "_NET_WM_NAME",
    "UTF8_STRING",
    "WM_STATE",
    "_OBJECTICON_PROP0",
    "_OBJECTICON_PROP1",
    "_OBJECTICON_PROP2",
    "_OBJECTICON_PROP3",
    "_OBJECTICON_PROP4",
    "_OBJECTICON_PROP5",
    "_OBJECTICON_PROP6",
    "_OBJECTICON_PROP7",
    "_NET_WM_STATE_SHADED",
};

/*
 * allocate a window binding structure
 */
wbp alcwbinding(wdp wd)
{
    wbp w;
    w = safe_zalloc(sizeof(struct _wbinding));
    GLink(w, wd->wbndngs);
    return w;
}

/*
 * free a window binding.
 */
void freewbinding(wbp w)
{
    wdp wd = w->window->display;
    freewindow(w->window);
    freecontext(w->context);
    GUnlink(w, wd->wbndngs);
    free(w);
}

wbp findwbp(wsp ws)
{
    wbp wb;
    for (wb = ws->display->wbndngs; wb; wb = wb->next)
        if (wb->window == ws)
            return wb;
    syserr("Couldn't find wbp for wsp");
    return 0;  /* not reached */
}

/*
 * allocate a display on machine s
 */
static wdp alcdisplay(char *s)
{
    static int inited = 0;
    wdp wd;
    int major_version, minor_version;

    if (!inited) {
        env_string("OI_RESOURCE_NAME", &resource_name);
        env_string("OI_RESOURCE_CLASS", &resource_class);
        env_string("DISPLAY", &display);
        inited = 1;
    }

    if (s == NULL) {
        s = display;
        if (s == NULL) {
            LitWhy("DISPLAY variable not set");
            return NULL;
        }
    }

    for(wd = wdsplys; wd; wd = wd->next)
        if (wd->program == curpstate && !strcmp(wd->name, s)) {
            return wd;
        }

    wd = safe_zalloc(sizeof(struct _wdisplay));

    wd->program = curpstate;
    wd->display = XOpenDisplay(s);
    if (wd->display == NULL) {
        LitWhy("Couldn't connect to display");
        free(wd);
        return NULL;
    }

    if (!XRenderQueryVersion(wd->display, &major_version, &minor_version)) {
        LitWhy("XRender extension not available on server");
        XCloseDisplay(wd->display);
        free(wd);
        return NULL;
    }

    wd->format = ImageByteOrder(wd->display) == LSBFirst ? &imgdataformat_X11BGRA32 : &imgdataformat_X11ARGB32;
    wd->maskfmt = XRenderFindStandardFormat(wd->display, PictStandardA8);
    wd->winfmt = XRenderFindVisualFormat(wd->display, GetVisual(wd));
    wd->defaultfont = loadfont(wd, defaultfont);
    if (wd->defaultfont == NULL) {
        LitWhy("Couldn't load default font");
        XCloseDisplay(wd->display);
        free(wd);
        return NULL;
    }
    wd->name = salloc(s);
    wd->pixfmt = XRenderFindStandardFormat(wd->display, PictStandardARGB32);
    wd->black = new_sharedcolor(wd, "black", 0, 0, 0, 65535);
    wd->white = new_sharedcolor(wd, "white", 65535, 65535, 65535, 65535);
    wd->transparent = new_sharedcolor(wd, "transparent", 0, 0, 0, 0);
    wd->recent = CurrentTime;
    XInternAtoms(wd->display, atom_names, NUMATOMS, False, wd->atoms);
    setup_cursors(wd);
    GLink(wd, wdsplys);
    return wd;
}

/*
 * Convert a given font spec, which may or may not be in icon font spec format,
 * into fontconfig (used by Xft) style format.
 * 
 * To avoid ambiguity, a spec can start with "fc:" to indicate it's in fontconfig
 * format; otherwise parsefont is called to decide the format.
 */
char *tofcpatternstr(char *s)
{
    static char *res;
    int flags;
    double size;
    char family[MAXFONTWORD];
    FcPattern *p;

    if (!strncmp(s, "fc:", 3))
        return s + 3;

    if (!parsefont(s, family, &flags, &size))
        return 0;

    p = FcPatternCreate();

    /*
     * Check first for special "standard" family names.
     */
    if (!strcmp(family, "fixed")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon fixed");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"mono");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "mono")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon mono");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"mono");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "typewriter")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon typewriter");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"courier");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "sans")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon sans");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"helvetica");
        flags |= FONTFLAG_PROPORTIONAL;
    }
    else if (!strcmp(family, "serif")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon serif");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"times");
        flags |= FONTFLAG_PROPORTIONAL;
    }
    else
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)family);

    FcPatternAddDouble(p, FC_SIZE, size);

    if (flags & FONTFLAG_THIN)
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_THIN);
    else if (flags & FONTFLAG_LIGHT)
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_LIGHT);
    else if (flags & FONTFLAG_MEDIUM)
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_MEDIUM);
    else if (flags & FONTFLAG_DEMIBOLD)
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_DEMIBOLD);
    else if (flags & FONTFLAG_BOLD)
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_BOLD);

    if (flags & FONTFLAG_ITALIC)
        FcPatternAddInteger(p, FC_SLANT, FC_SLANT_ITALIC);
    else if (flags & FONTFLAG_OBLIQUE)
        FcPatternAddInteger(p, FC_SLANT, FC_SLANT_OBLIQUE);
    else if (flags & FONTFLAG_ROMAN)
        FcPatternAddInteger(p, FC_SLANT, FC_SLANT_ROMAN);

    if (flags & FONTFLAG_PROPORTIONAL)
        FcPatternAddInteger(p, FC_SPACING, FC_PROPORTIONAL);
    if (flags & FONTFLAG_MONO)
        FcPatternAddInteger(p, FC_SPACING, FC_MONO);

    if (flags & FONTFLAG_CONDENSED)
        FcPatternAddInteger(p, FC_WIDTH, FC_WIDTH_CONDENSED);
    else if (flags & FONTFLAG_NARROW)
        FcPatternAddInteger(p, FC_WIDTH, FC_WIDTH_SEMICONDENSED);
    else if (flags & FONTFLAG_NORMAL)
        FcPatternAddInteger(p, FC_WIDTH, FC_WIDTH_NORMAL);
    else if (flags & FONTFLAG_WIDE)
        FcPatternAddInteger(p, FC_WIDTH, FC_WIDTH_SEMIEXPANDED);
    else if (flags & FONTFLAG_EXTENDED)
        FcPatternAddInteger(p, FC_WIDTH, FC_WIDTH_EXPANDED);

    free(res);
    res = (char *)FcNameUnparse(p);
    FcPatternDestroy(p);

    return res;
}

/*
 * load a font and return a font structure.
 */

wfp loadfont(wdp wd, char *s)
{
    wfp rv;
    int i;

    /*
     * Convert to a system font name (without the fc: prefix)
     */
    s = tofcpatternstr(s);
    if (!s)
        return 0;

    /*
     * see if the font is already loaded on this display
     */
    i = hasher(hashcstr(s), wd->fonts);
    for(rv = wd->fonts[i]; rv; rv = rv->next) {
        if (!strcmp(s, rv->name + 3))
            return rv;
    }

    /*
     * load a new font
     */
    rv = newfont(wd, s);
    if (!rv)
        return 0;

    /*
     * link the font into this display's fontlist
     */
    rv->next = wd->fonts[i];
    wd->fonts[i] = rv;

    return rv;
}

static wfp newfont(wdp wd, char *s)
{
    wfp rv;
    XGlyphInfo	extents; 

    rv = safe_zalloc(sizeof(struct _wfont));
    rv->fsp = XftFontOpenName(wd->display, DefaultScreen(wd->display), s);
    if (!rv->fsp){
        free(rv);
        return 0;
    }

    rv->name = safe_malloc(strlen(s) + 3 + 1);
    sprintf(rv->name, "fc:%s", s);

    /*
     * Xft seems to sometimes give too-small values in its font
     * ascent/descent fields; therefore calculate the GlyphInfo
     * for the first 256 chars and take the maximum ascent/descent
     * of the sample and the font's reported values.
     */
    XftTextExtents8 (wd->display,
                     rv->fsp,
                     (FcChar8 *)allchars,
                     256,
                     &extents);
    rv->ascent = Max(rv->fsp->ascent, extents.y);
    rv->descent = Max(rv->fsp->descent, extents.height - extents.y);
    rv->maxwidth = rv->fsp->max_advance_width;
    return rv;
}

/*
 * allocate a context, cloning attributes from an existing context
 */
static wcp clonecontext(wcp wc)
{
    wcp rv;
    GAlloc(rv, _wcontext);
    rv->display = wc->display;
    rv->dx = wc->dx;
    rv->dy = wc->dy;
    rv->leading = wc->leading;
    rv->clipx = wc->clipx;
    rv->clipy = wc->clipy;
    rv->clipw = wc->clipw;
    rv->cliph = wc->cliph;
    rv->fg = link_sharedcolor(wc->fg);
    rv->bg = link_sharedcolor(wc->bg);
    if (wc->pattern)
        rv->pattern = link_sharedpicture(wc->pattern);
    rv->font = wc->font;
    rv->lineend = wc->lineend;
    rv->linejoin = wc->linejoin;
    rv->linewidth = wc->linewidth;
    rv->drawop = wc->drawop;
    return rv;
}

/*
 * free a window state
 */
static void freewindow(wsp ws)
{
    ws->refcount--;
    if(ws->refcount == 0) {
        if (ws->win)
            close_screen_win(ws);
        if (ws->pxft)
            XftDrawDestroy(ws->pxft);
        XFreePixmap(ws->display->display, ws->pix);
        XRenderFreePicture(ws->display->display, ws->ppic);
        free(ws->icondata);
        del_gc_global(&ws->listp);
        del_gc_global(&ws->windowlabel);
        if (ws->transientfor)
            freewindow(ws->transientfor);
        free(ws);
    }
}

/*
 * free a window context
 */
static void freecontext(wcp wc)
{
    wc->refcount--;
    if(wc->refcount == 0) {
        unlink_sharedcolor(wc->fg);
        unlink_sharedcolor(wc->bg);
        if (wc->pattern)
            unlink_sharedpicture(wc->pattern);
        free(wc);
    }
}

int readimagefileimpl(char *filename, struct imgdata *imd) 
{
    return NoCvt;
}

int writeimagefileimpl(char *filename, struct imgdata *imd)
{
    return NoCvt;
}

int readimagedataimpl(dptr data, struct imgdata *imd)
{
    return NoCvt;
}

int settransientfor(wbp w, wbp other)
{
    wsp ws = w->window;
    if (ws->win) {
        LitWhy("Can't set transient_for on an open window");
        return Failed;
    }
    if (other) {
        if (w->window->display != other->window->display) {
            LitWhy("Can't set transient_for with windows on different displays");
            return Failed;
        }
        if (ws->transientfor)
            freewindow(ws->transientfor);
        ws->transientfor = linkwindow(other->window);
    } else {
        if (ws->transientfor)
            freewindow(ws->transientfor);
        ws->transientfor = 0;
    }
    return Succeeded;
}

static void set_X11ARGB32(struct imgdata *imd, int x, int y, int r, int g, int b, int a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    b = Mul16(b, a);
    g = Mul16(g, a);
    r = Mul16(r, a);
    *s++ = a / 256;
    *s++ = r / 256;
    *s++ = g / 256;
    *s++ = b / 256;
}
static void get_X11ARGB32(struct imgdata *imd, int x, int y, int *r, int *g, int *b, int *a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    *a = 257 * (*s++);
    *r = 257 * (*s++);
    *g = 257 * (*s++);
    *b = 257 * (*s++);
    if (*a > 0) {
        *b = Div16(*b, *a);
        *g = Div16(*g, *a);
        *r = Div16(*r, *a);
    }
}

static void set_X11BGRA32(struct imgdata *imd, int x, int y, int r, int g, int b, int a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    b = Mul16(b, a);
    g = Mul16(g, a);
    r = Mul16(r, a);
    *s++ = b / 256;
    *s++ = g / 256;
    *s++ = r / 256;
    *s++ = a / 256;
}

static void get_X11BGRA32(struct imgdata *imd, int x, int y, int *r, int *g, int *b, int *a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    *b = 257 * (*s++);
    *g = 257 * (*s++);
    *r = 257 * (*s++);
    *a = 257 * (*s++);
    if (*a > 0) {
        *b = Div16(*b, *a);
        *g = Div16(*g, *a);
        *r = Div16(*r, *a);
    }
}

struct imgdataformat imgdataformat_X11ARGB32 =   {set_X11ARGB32,get_X11ARGB32,0,0,getlength_32,8,24,0,"X11ARGB32"};
struct imgdataformat imgdataformat_X11BGRA32 =   {set_X11BGRA32,get_X11BGRA32,0,0,getlength_32,8,24,0,"X11BGRA32"};

void registerplatformimgdataformats()
{
    registerimgdataformat(&imgdataformat_X11ARGB32);
    registerimgdataformat(&imgdataformat_X11BGRA32);
}




/*
 * This is a modified version of the code in libXrender (Poly.c),
 * which contains an array overrun bug.  This code doesn't work very
 * well, but at least it doesn't crash.
 */


struct Edge {
    XLineFixed  edge;
    XFixed      current_x;
    struct Edge *next, *prev;
};

static int
CompareEdge (const void *o1, const void *o2)
{
    const struct Edge  *e1 = o1, *e2 = o2;

    return e1->edge.p1.y - e2->edge.p1.y;
}

static XFixed
ComputeX (XLineFixed *line, XFixed y)
{
    XFixed  dx = line->p2.x - line->p1.x;
    double  ex = (double) (y - line->p1.y) * (double) dx;
    XFixed  dy = line->p2.y - line->p1.y;

    return (XFixed) line->p1.x + (XFixed) (ex / dy);
}

static double
ComputeInverseSlope (XLineFixed *l)
{
    return (XFixedToDouble (l->p2.x - l->p1.x) /
            XFixedToDouble (l->p2.y - l->p1.y));
}

static double
ComputeXIntercept (XLineFixed *l, double inverse_slope)
{
    return XFixedToDouble (l->p1.x) - inverse_slope * XFixedToDouble (l->p1.y);
}

static XFixed
ComputeIntersect (XLineFixed *l1, XLineFixed *l2)
{
    /*
     * x = m1y + b1
     * x = m2y + b2
     * m1y + b1 = m2y + b2
     * y * (m1 - m2) = b2 - b1
     * y = (b2 - b1) / (m1 - m2)
     */
    double  m1 = ComputeInverseSlope (l1);
    double  b1 = ComputeXIntercept (l1, m1);
    double  m2 = ComputeInverseSlope (l2);
    double  b2 = ComputeXIntercept (l2, m2);

    return XDoubleToFixed ((b2 - b1) / (m1 - m2));
}

static int
ComputeTrapezoids (struct Edge   *edges,
                   int           nedges,
                   int           winding,
                   XTrapezoid    *traps,
                   int           maxtraps)
{
    int ntraps = 0;
    int inactive;
    struct Edge *active, *e, *en, *next;
    XFixed y, next_y, intersect;

    qsort (edges, nedges, sizeof (struct Edge), CompareEdge);

    y = edges[0].edge.p1.y;
    active = NULL;
    inactive = 0;
    while (active || inactive < nedges)
    {
        /* insert new active edges into list */
        while (inactive < nedges)
        {
            e = &edges[inactive];
            if (e->edge.p1.y > y)
                break;
            /* move this edge into the active list */
            inactive++;
            e->next = active;
            e->prev = NULL;
            if (active)
                active->prev = e;
            active = e;
        }
        /* compute x coordinates along this group */
        for (e = active; e; e = e->next)
            e->current_x = ComputeX (&e->edge, y);

        /* sort active list */
        for (e = active; e; e = next)
        {
            next = e->next;
            /*
             * Find one later in the list that belongs before the
             * current one
             */
            for (en = next; en; en = en->next)
            {
                if (en->current_x < e->current_x ||
                    (en->current_x == e->current_x &&
                     en->edge.p2.x < e->edge.p2.x))
                {
                    /*
                     * insert en before e
                     *
                     * extract en
                     */
                    en->prev->next = en->next;
                    if (en->next)
                        en->next->prev = en->prev;
                    /*
                     * insert en
                     */
                    if (e->prev)
                        e->prev->next = en;
                    else
                        active = en;
                    en->prev = e->prev;
                    e->prev = en;
                    en->next = e;
                    /*
                     * start over at en
                     */
                    next = en;
                    break;
                }
            }
        }

        /* find next inflection point */
        next_y = active->edge.p2.y;
        for (e = active; e; e = en)
        {
            if (e->edge.p2.y < next_y)
                next_y = e->edge.p2.y;
            en = e->next;
            /* check intersect */
            if (en && e->edge.p2.x > en->edge.p2.x)
            {
                intersect = ComputeIntersect (&e->edge, &e->next->edge);
                /* make sure this point is below the actual intersection */
                intersect = intersect + 1;
                if (intersect < next_y)
                    next_y = intersect;
            }
        }
        /* check next inactive point */
        if (inactive < nedges && edges[inactive].edge.p1.y < next_y)
            next_y = edges[inactive].edge.p1.y;

        /* walk the list generating trapezoids */
        for (e = active; e && (en = e->next); e = en->next)
        {
            /*
             * (RPP) This is the only consequential change - the
             * version in libXrender just goes sailing right out
             * there.
             */
            if (ntraps == maxtraps)
                return ntraps;
            traps->top = y;
            traps->bottom = next_y;
            traps->left = e->edge;
            traps->right = en->edge;
            traps++;
            ntraps++;
        }

        y = next_y;

        /* delete inactive edges from list */
        for (e = active; e; e = next)
        {
            next = e->next;
            if (e->edge.p2.y <= y)
            {
                if (e->prev)
                    e->prev->next = e->next;
                else
                    active = e->next;
                if (e->next)
                    e->next->prev = e->prev;
            }
        }
    }
    return ntraps;
}

static void
CompositeDoublePoly(Display             *dpy,
                    int                 op,
                    Picture             src,
                    Picture             dst,
                    XRenderPictFormat   *maskFormat,
                    int                 xSrc,
                    int                 ySrc,
                    int                 xDst,
                    int                 yDst,
                    XPointDouble        *fpoints,
                    int                 npoints,
                    int                 winding)
{
    struct Edge     *edges;
    XTrapezoid      *traps;
    int             i, nedges, ntraps, maxtraps;
    XFixed          x, y, prevx = 0, prevy = 0, firstx = 0, firsty = 0,
                    top = 0, bottom = 0;

    maxtraps = npoints * npoints;
    edges = safe_malloc(npoints * sizeof (struct Edge));
    traps = safe_malloc(maxtraps * sizeof (XTrapezoid));

    nedges = 0;
    for (i = 0; i <= npoints; i++)
    {
        if (i == npoints)
        {
            x = firstx;
            y = firsty;
        }
        else
        {
            x = XDoubleToFixed (fpoints[i].x);
            y = XDoubleToFixed (fpoints[i].y);
        }
        if (i)
        {
            if (y < top)
                top = y;
            else if (y > bottom)
                bottom = y;
            if (prevy < y)
            {
                edges[nedges].edge.p1.x = prevx;
                edges[nedges].edge.p1.y = prevy;
                edges[nedges].edge.p2.x = x;
                edges[nedges].edge.p2.y = y;
                nedges++;
            }
            else if (prevy > y)
            {
                edges[nedges].edge.p1.x = x;
                edges[nedges].edge.p1.y = y;
                edges[nedges].edge.p2.x = prevx;
                edges[nedges].edge.p2.y = prevy;
                nedges++;
            }
            /* drop horizontal edges */
        }
        else
        {
            top = y;
            bottom = y;
            firstx = x;
            firsty = y;
        }
        prevx = x;
        prevy = y;
    }
    ntraps = ComputeTrapezoids (edges, nedges, winding, traps, maxtraps);
    /* XXX adjust xSrc/xDst */
    XRenderCompositeTrapezoids (dpy, op, src, dst, maskFormat, xSrc, ySrc, traps, ntraps);
    free (edges);
    free (traps);
}
