#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

import lang, gui, io, util, graphics, ipl.pdco, xdg, ipl.filegui

$include "version.icn"

class Ivib()
   public static const
      TB_ICON_SIZE,
      V1_MARKER,
      V2_MARKER,
      V2i_MARKER,
      IVIB_COMPONENT_TARGET

   public static
      main,
      last_icon_dir,
      last_layout_dir,
      last_icn_dir

   private static init()
      TB_ICON_SIZE := scale(44)
      load_icons()
      V1_MARKER := "### Ivib layout ###"
      V2_MARKER := "### Ivib-v2 layout ##"
      V2i_MARKER := "### Ivib-v2 layout: "
      insert(Dialog.ROOT_WATTRIBS, "bg", "pale gray")
      insert(Dialog.ROOT_WATTRIBS, "resize", &yes)
      insert(Dialog.ROOT_WATTRIBS, "icon", ImageCache.get_named_image("ivib.logo"))
      IVIB_COMPONENT_TARGET := "IVIB_COMPONENT"
      last_icon_dir := last_layout_dir := last_icn_dir := Files.getcwd()
   end
end

#
# Class for storing preferences which are saved to a config file.
#
class Prefs(SelectiveObjectCodec)
   public 
      undo_size,                # Size of undo buffer
      plugin_directory,
      named_image_path

   public get_template()
      suspend ["Undo Size", "undo_size"] |
              ["Plugin Directory", "plugin_directory"] |
              ["Named Image Path", "named_image_path"]
   end

   protected post_decode()
      /named_image_path := ["images"]
   end

   #
   # Default values
   #
   public new()
      undo_size := 7
      plugin_directory := "plugins"
      named_image_path := ["images"]
      return
   end
end


#
# The main window's toolbar.
#
class CustomToolBar(Component)
   public
      x1,
      y1,
      bg

   public add_button(t)
      t.set_pos(x1, y1)
      t.set_accepts_focus(&no)
      t.set_border(NullBorder())
      bg.add(t)
      self.add(t)
      x1 +:= Ivib.TB_ICON_SIZE
      if *get_children() == 16 then {
         y1 +:= Ivib.TB_ICON_SIZE
         x1 := 0
      }
   end

   public new()
      Component.new()
      x1 := y1 := 0
      bg := ButtonGroup()
      set_size(16 * Ivib.TB_ICON_SIZE, 2 * Ivib.TB_ICON_SIZE)
      return
   end
end


#
# This listens for actions to either the menu/button object creation items.
#
class ObjectActionListener()
   public
      main, 
      object_ui

   public on_event(event)
      main.create_in_canvas(object_ui)
   end

   public new(main, object_ui)
      self.main := main
      self.object_ui := object_ui
      return
   end
end


############################################################################
#
# The Dialog window of the program.
#
#
class Main(Dialog)
   public 
      bg,                      # Button group of tool bar buttons
      canvas_zone,             # Panel on which canvas sits
      canvas_border,           # Border around canvas
      canvas,                  # The drawing canvas
      prefs,                   # Preferences structure
      save,                    # Save file function
      save_button,             # Save(as) button
      selections_menu,         # Selections menu
      button_name_label,       # Label for name of button under pointer
      filename_label,          # Label for current filename
      info_label,              # Label for other info
      pos_label,               # Label for positional info
      undo_list,               # List of canvases for undo command
      redo_list,               # List of canvases for redo command
      args,                    # Command line arguments
      reorder,                 # Reorder items command
      undo,                    # Undo
      redo,                    # Redo
      rescale,                 # Rescale 
      checkboxgroup_button,    # Toolbar buttons
      buttongroup_button,
      delete_button,
      undo_button,
      redo_button,
      move_selection_up_order_button,
      move_selection_down_order_button,
      component_tree_dialog,
      plugins,
      clipboard_selection_owner,
      clipboard,
      config_file_name

   #
   # Clear undo list
   #
   public clear_undo()
      self.undo_list := []
      update_grey()
   end

   # 
   # Get undo item
   #
   public get_undo()
      local res
      res := get(undo_list)
      update_grey()
      return res
   end 

   #
   # Push an undo item
   #
   public push_undo_list(d)
      push(undo_list, d)
      #
      # Reduce to correct size.
      #
      while *undo_list > self.prefs.undo_size do
         pull(undo_list)

      update_grey()
   end

   #
   # Clear redo list
   #
   public clear_redo()
      self.redo_list := []
      update_grey()
   end

   # 
   # Get redo item
   #
   public get_redo()
      local res
      res := get(redo_list)
      update_grey()
      return res
   end 

   #
   # Push an redo item
   #
   public push_redo_list(d)
      push(redo_list, d)
      update_grey()
   end

   #
   # Set filename_label to reflect current status of canvas.
   #
   public set_filename_label()
      local s
      s := \self.canvas.filename | "Untitled"
      if \self.canvas.modified then
         s ||:= " *"
      self.filename_label.set_label(FilePath(s).get(-1))
      return self
   end      

   public init_dialog()
      win.set_min_size(win.get_width(), win.get_height())
   end

   #
   # Special custom show to allow a popup during init
   #         
   public custom_show(a)
      local s, c
      self.args := a
      show()
      if *self.args > 0  then {
         s := ucs(self.args[1]) | return alert_error(self, "Invalid (non-utf8) filename")
         if Files.access(s, Access.R_OK) then {
            c := load_canvas(s) | fail
            c.set_pos(Canvas.SURROUND, Canvas.SURROUND)
            c.clear_selections()
            self.undo_to(c)
         } else {
            #
            # New file
            #
            info_label.set_label("New file")
            self.canvas.new_file_flag := 1
         }
         self.canvas.set_filename(s)
      } else
         #
         # Initialize the filename label.
         #
         canvas.set_filename()
      update_grey()
      Dispatcher.message_loop(self)
   end

   #
   # Load fname and show output to stdout.
   #         
   public test(fname)
      local s, c, code
      s := ucs(fname) | return alert_error(self, "Invalid (non-utf8) filename")
      Files.access(s, Access.R_OK) | return alert_error(self, "Couldn't open " || s)
      c := load_canvas(s) | fail
      code := c.gen_code()
      code.interpose_code(s, FileStream.stdout)
   end

   #
   # Load fname and save it again.
   #         
   public load_and_save(fname)
      local s, c, code
      s := ucs(fname) | return alert_error(self, "Invalid (non-utf8) filename")
      Files.access(s, Access.R_OK) | return alert_error(self, "Couldn't open " || s)
      c := load_canvas(s) | fail
      code := c.gen_code()
      code.interpose_code(s, s)
   end

   #
   # Load a layout.
   #
   public load_canvas(fname)
      local s, c, d, src, l

      l := Loader(fname)
      src := l.load() | return alert_error(self, &why)
      s := src.migrate() | return alert_error(self, "Couldn't migrate " || fname)
      c := lang.decode(s) | return alert_error(self, "Couldn't decode " || fname)
      c.layout_filename := l.lname
      if src.version = 1 then {
         d := InfoDialog(["Ivib v1 file successfully loaded.",
                          "",
                          "NB - some manual editing may be needed after",
                          "the file is next saved."],
                          "Ivib v1 import",
                          "Close",
                          "c")
         #
         # The canvas is set as modified - so that the v2 changes can
         # simply be saved.
         #
         c.modified := 1
         d.show_modal(self)
      }
      c.set_parent_dialog(self)
      # Ensure all canvas fields set (may not be for older versions).
      every c.gen_cos().change_canvas(c)
      # Ensure all names are unique
      c.ensure_all_names_unique()
      return c
   end

   #
   # Push copy of current canvas onto undo list.
   #
   public push_undo()
      self.push_onto_undo(self.canvas.dup())
   end

   #
   # Push a canvas onto undo list. 
   #
   public push_onto_undo(d)
      #
      # Reset redo list
      #
      self.clear_redo()
      self.push_undo_list(d)
   end

   #
   # Undo operation.
   #
   public op_undo()
      local c
      c := self.get_undo()
      self.push_redo_list(self.canvas.dup())
      self.undo_to(c)
      info_label.set_label("Undone")
      self.set_filename_label()
   end

   #
   # Redo operation.
   #
   public op_redo()
      local c
      c := self.get_redo()
      self.push_undo_list(self.canvas.dup())
      self.undo_to(c)
      info_label.set_label("Redone")
      self.set_filename_label()
   end

   #
   # Rescale.
   #
   public op_rescale()
      push_undo()
      canvas.rescale()
   end

   #
   # Replace current canvas with c
   #
   public undo_to(c)
      #
      # Dispose of current canvas
      #
      clear_focus()
      canvas_border.remove(self.canvas)
      self.canvas := c
      canvas_border.set_canvas(self.canvas)
      canvas_zone.invalidate()

      #
      # Setup rest of fields in new canvas.
      #
      self.canvas.synch_size()
      self.canvas.update_pos_label()
      update_grey()
      synch_tree()
      set_focus(c)
   end

   public copy_to_clipboard(cc)
      local c
      c := cc.dup()
      c.change_canvas(&null)
      self.clipboard := lang.encode(c)
      parent_dialog.own_selection(Selection.CLIPBOARD, self.clipboard_selection_owner)
   end

   public update_grey()
      every (selections_menu | checkboxgroup_button | buttongroup_button |
         delete_button | move_selection_up_order_button | move_selection_down_order_button).
         set_is_shaded(Yes{*canvas.selections = 0})

      every (undo | undo_button).set_is_shaded(Yes{*undo_list = 0})
      every (redo | redo_button).set_is_shaded(Yes{*redo_list = 0})

      rescale.set_is_shaded(Yes{Gui.SCALE = canvas.edit_scale})

      save.set_is_shaded(Yes{/canvas.modified | /canvas.filename})
      save_button.set_is_shaded(Yes{/canvas.modified & \canvas.filename})
   end

   #
   # Centre horizontally operation.
   #
   public op_centre_horiz_selections()
      canvas.centre_horiz_selections()
   end

   #
   # Centre vertically operation.
   #
   public op_centre_vert_selections()
      canvas.centre_vert_selections()
   end

   #
   # Align horizontally operation.
   #
   public op_align_horiz_selections()
      canvas.align_horiz_selections()
   end

   #
   # Align vertically operation.
   #
   public op_align_vert_selections()
      canvas.align_vert_selections()
   end

   #
   # Reorder operations
   #
   public op_reorder_selections()
      canvas.reorder_selections()
   end

   public op_move_selection_up_order_button()
      canvas.move_selection_up_order()
   end

   public op_move_selection_down_order_button()
      canvas.move_selection_down_order()
   end

   public op_set_tab_order_from_selections()
      canvas.set_tab_order_from_selections()
   end

   public op_set_z_order_from_selections()
      canvas.set_z_order_from_selections()
   end

   #
   # End-to-end horizontally
   #
   public op_end_to_end_selections_horizontally()
      canvas.end_to_end_selections_horizontally()
   end

   #
   # End-to-end vertically
   #
   public op_end_to_end_selections_vertically()
      canvas.end_to_end_selections_vertically()
   end

   #
   # Equalize widths
   #
   public op_equalize_width_selections()
      canvas.equalize_width_selections()
   end

   #
   # Equalize heights
   #
   public op_equalize_height_selections()
      canvas.equalize_height_selections()
   end

   #
   # Equalize heights
   #
   public op_copy_attribs()
      canvas.copy_attribs()
   end

   #
   # Dialog (Ctrl-d) function.
   #
   public op_dialog()
      if /self.canvas.selected then
         op_preferences()  
      else
         show_dialog(canvas.selected)
   end

   #
   # Show a dialog for the given CanvasComponent
   #
   public show_dialog(cc)
      local d, t
      t := canvas.dup()
      d := cc.dialog()
      d.show_modal(self)
      if \d.get_okay_result() then {
         self.push_onto_undo(t)
         cc.reset()
         canvas.set_modified()
         canvas.do_reset_all_layouts()
      } else
         self.undo_to(t)
   end
   
   #
   # Add a new CanvasComponent using the given CanvasComponentUI to
   # create it.
   #
   public create_in_canvas(object_ui)
      local t
      self.push_undo()
      t := object_ui.create_canvas_component(self.canvas)
      add_new_object(t)
   end

   #
   # Create a CheckBoxGroup
   #
   public op_selections_to_cbg()
      canvas.selections_to_cbg()
   end

   #
   # Create a ButtonGroup
   #
   public op_selections_to_bg()
      canvas.selections_to_bg()
   end

   #
   # Delete the selected objects.
   #
   public op_delete_selections()
      canvas.delete_selections()
   end

   #
   # Fix the selected objects
   #
   public op_fix_selections()
      canvas.fix_selections()
   end

   #
   # Unfix the selected objects
   #
   public op_unfix_selections()
      canvas.unfix_selections()
   end

   #
   # Canvas dialog preferences.
   #
   public op_preferences()
      local t, d
      t := self.canvas.dup()
      d := canvas.dialog()
      d.show_modal(self)
      if \d.get_okay_result() then {
         self.push_onto_undo(t)
         # Firstly, create a new buffer window based on the (possibly) new window attribs,
         # and apply the new window to all of the children.
         canvas.reset_windows()
         canvas.set_modified()
      } else
         self.undo_to(t)
   end

   #
   # Program preferences (see dialog below).
   #
   public op_prog_preferences()
      local d
      d := Preferences(self.prefs)
      d.show_modal(self)
      if \d.okay_result then {
         save_config_file()
         synch_named_images()
      }
   end

   #
   # Group dialog.
   #
   public op_groups()
      local t, d
      t := self.canvas.dup()
      d := GroupsDialog(canvas)
      d.show_modal(self)
      if \d.get_okay_result() then {
         self.push_onto_undo(t)
         canvas.set_modified()
         canvas.do_reset_all_layouts()
      } else
         self.undo_to(t)
   end

   #
   # Save as... operation 
   #
   public op_save_as()
      local fd, s, c
      fd := FileDialog().set_existing_file_mode(FileDialog.WARN)
      if /self.canvas.filename then {
         fd.set_directory(Ivib.last_icn_dir)
         fd.set_file("Untitled.icn")
      } else
         fd.set_path(self.canvas.filename)

      fd.show_modal(self)
      Ivib.last_icn_dir := fd.get_directory()
      s := fd.get_result() | fail

      c := self.canvas.gen_code()

      if /self.canvas.filename | \self.canvas.new_file_flag then
         c.output_code(s) | fail
      else
         c.interpose_code(self.canvas.filename, s) | fail

      self.canvas.clear_modified()
      self.canvas.set_filename(s)
      self.info_label.set_label("Wrote " || s)
      self.clear_undo()
      self.clear_redo()
      return
   end

   #
   # Save operation.
   #
   public op_save()
      local c
      if /self.canvas.new_file_flag then {
         if /self.canvas.modified then {
            self.info_label.set_label("No changes need to be saved")
            return
         }
         c := self.canvas.gen_code()
         c.interpose_code(self.canvas.filename, self.canvas.filename) | fail
         self.canvas.clear_modified()
         self.info_label.set_label("Wrote " || self.canvas.filename)
         #
         # Set modified flag of all in undo/redo buffer
         every (!self.undo_list | !self.redo_list).modified := 1
      } else {
         c := self.canvas.gen_code()
         c.output_code(self.canvas.filename) | fail
         self.canvas.clear_modified()
         self.info_label.set_label("Wrote " || self.canvas.filename)
         #
         # Set modified flag of all in undo/redo buffer
         every (!self.undo_list | !self.redo_list).modified := 1
         #
         # Clear new flag of all in undo/redo buffer
         every (!self.undo_list | !self.redo_list).new_file_flag := &null
         self.canvas.new_file_flag := &null
      }
      return
   end

   public op_save_button()
      if /self.canvas.filename then
         op_save_as()
      else
         op_save()
   end

   #
   # About operation.
   #
   public op_about()
      local d
      d := InfoDialog(["Ivib Version : " || version_number, 
                       "Date : " || version_date, 
                       "Author : " || version_author], "About ivib")
      d.show(self)

      return
   end

   #
   # Open file operation.
   #
   public op_open_file()
      local fd, s, c
      if \self.canvas.modified then
         self.save_if_wanted() | fail

      fd := FileDialog().set_existing_file_mode(FileDialog.REQUIRE)
      fd.set_directory(Ivib.last_icn_dir)
      fd.show_modal(self)
      Ivib.last_icn_dir := fd.get_directory()
      s := fd.get_result() | fail
      c := load_canvas(s) | fail
      self.clear_undo()
      self.clear_redo()
      c.set_pos(Canvas.SURROUND, Canvas.SURROUND)
      c.set_size(c.w, c.h)
      self.undo_to(c)
      self.canvas.set_filename(s)
      self.canvas.clear_modified()
      update_grey()
   end

   #
   # Ask whether changed file should be saved; if so save it by call
   # to appropriate operation.
   #
   public save_if_wanted()
      local d
      d := SaveChangesDialog()
      d.show_modal(self)
      case d.result() of {
         "cancel" : fail
         "no" : return
         "yes" : {
             return if \self.canvas.filename then
                self.op_save()
             else
                self.op_save_as()
         }
      }      
   end

   #
   # Quit program operation.
   #
   public op_quit()
      if \self.canvas.modified then
         self.save_if_wanted() | fail
      self.dispose()
   end

   public synch_tree()
      (\component_tree_dialog).synch()
   end

   public on_component_tree_dialog_close()
      self.component_tree_dialog := &null
   end

   public op_tree()
      if component_tree_dialog := gui.Dispatcher.find_dialog(ComponentTreeDialog) then {
         component_tree_dialog.restore_win()
      } else {
         component_tree_dialog := ComponentTreeDialog(self)
         component_tree_dialog.connect(self.on_component_tree_dialog_close, Event.DIALOG_DISPOSED)
         component_tree_dialog.show(self)
      }
   end

   public op_preview()
      local d, t, m, bg

      t := canvas.dup()
      every Seq{t.traverse_preorder()}.set_show_layout(&no)
      d := PureDialog()
      d.set_layout(t.layout_delegate)
      every d.add(!t.children)

      # Attribs - do the same as code.icn
      m := t.dialog_struct.wattribs
      if \ (t.dialog_iw | t.dialog_ih) then {
         if /t.dialog_iw then
            insert(m, "height", t.dialog_ih)
         else if /t.dialog_ih then
            insert(m, "width", t.dialog_iw)
         else
            insert(m, "size", [t.dialog_iw, t.dialog_ih])
      }
      d.set_all_wattribs(m)

      every bg := !t.button_groups do
         bg.buttons := bg.get_members()
      d.set_focus((\t.initial_focus).find_focus())
      d.connect(d.dispose, Event.WINDOW_CLOSE_BUTTON)
      d.show_modal(self)
   end

   #
   # New canvas operation.
   #
   public op_new()
      if \self.canvas.modified then
         self.save_if_wanted() | fail
      self.clear_undo()
      self.clear_redo()
      self.undo_to(Canvas())
      self.set_filename_label()
      update_grey()
   end

   #
   # Add a new object to the canvas at pos.
   #
   public add_new_object(c)
      static add_count
      initial
         add_count := 0
      c.change_canvas(self.canvas)
      if \canvas.layout_delegate then 
         c.x_spec := c.y_spec := &null
      else {
         #
         # Default x, y.  Try to avoid successive adds covering each other.
         #
         /c.x_spec := 10 + 7 * (add_count % 4)
         /c.y_spec := 10 + 7 * (add_count % 4)
      }
      add_count +:= 1
      c.set_align("l", "t")
      self.canvas.add(c)
      c.rename()
      self.canvas.do_reset_all_layouts()
      self.canvas.set_modified()
   end

   #
   # Handle dialog events.
   #
   public dialog_event(e)
      if member(Mouse.PRESS, e.code) then
         info_label.set_label("")

      case (not get_menu_mode()) & /e.release & e.code of {
         "\^q" : op_quit()
         "\^o" : op_open_file()
         "\^w" : op_save_as()
         "\^d" : op_dialog()
         "\^n" : op_new()
         "\^t" : op_tree()
         "\^a" : op_dump()
         "\^s" : if /save.is_shaded_flag then op_save()
         "\^z" : if /undo.is_shaded_flag then op_undo()
         "\^y" : if /redo.is_shaded_flag then op_redo()
      }
   end

   public op_dump()
      collect()
      write("CanvasObject tree dump:")
      write("-------------------")
      every dump(canvas.gen_cos(), 0)
      write("-------------------")

      write("Dup test:")
      test_dup()

      write("---------------")
      write("traverse")
      every write(image(Seq{canvas.gen_cos().traverse_tree()}))
   end

   public test_cbgs()
      local o,b,d
      write("CBGs ********")
      every b := !canvas.checkbox_groups do {
         write(b.get_name(), ": ", image(b),
               " which_one=", image(b.which_one))
      }
      write("..")
      every o := Seq{canvas.gen_cos().traverse_tree()} do {
         if is(o, gui.Toggle) then
            write(o.get_name(), ":", image(o), " ---> ", image(o.parent_check_box_group))
      }
      write("--------------")
      d := canvas.dup()
      every b := !d.checkbox_groups do {
         write(b.get_name(), ": ", image(b),
               " which_one=", image(b.which_one))
      }
      write("..")
      every o := Seq{d.gen_cos().traverse_tree()} do {
         if is(o, gui.Toggle) then
            write(o.get_name(), ":", image(o), " ---> ", image(o.parent_check_box_group))
      }
   end

   public test_dup()
      local e1, e2, x, y, d, i

      d := canvas.dup()

      e1 := create canvas.gen_cos().traverse_tree()
      e2 := create d.gen_cos().traverse_tree()

      # Selections
      *canvas.selections = *d.selections | failure("Different num of selections")
      every i := 1 to *canvas.selections do {
         test_same(canvas.selections[i], d.selections[i]) | failure("Selections differ",
                                                                 canvas.selections[i],
                                                                 d.selections[i])
      }
      test_same(canvas.selected, d.selected) | failure("Selected obj differs",
                                                    canvas.selected, d.selected)
      test_same(canvas.initial_focus, d.initial_focus) | failure("Initial_Focus obj differs",
                                                              canvas.initial_focus, d.initial_focus)

      # Checkbox groups
      every i := 1 to *canvas.checkbox_groups do {
         test_same(canvas.checkbox_groups[i].which_one,
                   d.checkbox_groups[i].which_one) | failure("CBG which_one different",
                                                          canvas.checkbox_groups[i].which_one,
                                                          d.checkbox_groups[i].which_one)
      }

      while x := @e1 do {
         y := @e2 | return failure("Not enough objects in dup")
         test_same(x, y) | failure("Objects differ",x,y)
         if /y.parent_Canvas then
            failure("Parent canvas not set on dup of:", x)
         else
            y.parent_Canvas ~=== x.parent_Canvas | failure("Parent canvas same", x)
         if is(x, gui.Toggle) then {
            test_same(x.parent_check_box_group,
                      y.parent_check_box_group) | failure("Parent CBGs different in",
                                                       x.parent_check_box_group,
                                                       y.parent_check_box_group)                     
         }
         if is(x, gui.Button) then {
            test_same(x.parent_button_group,
                      y.parent_button_group) | failure("Parent CBGs different in",
                                                       x.parent_button_group,
                                                       y.parent_button_group)                     
         }
      }
      not(@e2) | return failure("Too many objects in dup")
      return
   end

   public test_same(x, y)
      if /x & /y then
         return
      if /x | /y then
         fail
      # They shouldn't be identical....
      if x === y then
         fail
      return Class.get_name(x) == Class.get_name(y) &
         x.get_name() == y.get_name()
   end

   public failure(s, x[])
      write("*** FAILED :",s)
      every write("\t", image(!x))
   end

   public dump(obj, level)
      write(repl("    ", level), obj.get_name(),":",image(obj))
      if /obj.parent_Canvas then write("********PC NOT SET")
      every dump(obj.gen_cos(), level + 1)
   end

   public read_config_file()
      self.prefs := Prefs()
      Files.access(config_file_name) | return
      self.prefs := decode_from_file(config_file_name) |
         alert_error(self, ["Problem reading config file " || config_file_name || ":", &why])
   end

   public save_config_file()
      return encode_to_file(config_file_name, prefs) | 
         alert_error(self, ["Couldn't save to config file " || config_file_name || ":", &why])
   end

   public synch_named_images()
   end

   public get_plugin(id)
      return \plugins[id]
   end

   public add_ui_to_menu(m, ui)
      local menu_item

      menu_item := TextMenuItem()
      menu_item.set_label(ui.get_name())

      find_submenu(m, ui.get_category()).add(menu_item)

      return menu_item
   end

   public find_submenu(m, str)
      local s, n
      # Search for an existing one, bit of a hack
      every s := !m.children do
         if s.paint_mid.str == str then
            return s

      # Create a new one
      n := Menu()
      n.set_label(str)
      m.add(n)
      return n
   end

   public new()
      local mb, file, edit, alignment_sub_menu, copy_sub_menu, group_sub_menu,
         uis, objects_menu, tb, ui, listener, mi, ui_button, p,
         order_sub_menu, f, ce, plugin, pp, fn, i, fp, ext, k

      Dialog.new()
      config_file_name := FilePath(Xdg.ensure_data_home()).child("ivib").str() | stop("Couldn't access data dir: ", &why)
      set_layout(GridLayout().set_doi(0).set_dii(0))
      connect(self.dialog_event, Event.ICON)
      self.clipboard_selection_owner := IvibClipboardSelectionOwner(self)

      mb := MenuBar().set_constraint("eol", &yes).set_constraint("x_fill", &yes)
      self.add(mb)

      #
      # Set up the menu structure.
      #
      file := Menu().set_label("File").set_accel("f")
      mb.add(file)

      i := TextMenuItem().set_label("Open").set_label_right("Ctrl-o")
      i.connect(self.op_open_file, Event.ACTION)
      file.add(i)

      save := TextMenuItem().set_label("Save")
      save.set_label_right("Ctrl-s")
      save.connect(self.op_save, Event.ACTION)
      file.add(save)

      i := TextMenuItem().set_label("Save as").set_label_right("Ctrl-w")
      i.connect(self.op_save_as, Event.ACTION)
      file.add(i)

      i := TextMenuItem().set_label("New")
      i.set_label_right("Ctrl-n")
      i.connect(self.op_new, Event.ACTION)
      file.add(i)

      i := TextMenuItem().set_label("Preferences...")
      i.connect(self.op_prog_preferences, Event.ACTION)
      file.add(i)

      i := TextMenuItem().set_label("About ivib...")
      i.connect(self.op_about, Event.ACTION)
      file.add(i)

      i := TextMenuItem().set_label("Quit").set_label_right("Ctrl-q")
      i.connect(self.op_quit, Event.ACTION)
      file.add(i)

      edit := Menu().set_label("Canvas").set_accel("c")
      mb.add(edit)

      i := TextMenuItem().set_label("Tree...").set_label_right("Ctrl-t")
      i.connect(self.op_tree, Event.ACTION)
      edit.add(i)

      i := TextMenuItem().set_label("Preview...")
      i.connect(self.op_preview, Event.ACTION)
      edit.add(i)

      i := TextMenuItem().set_label("Dialog prefs...")
      i.connect(self.op_preferences, Event.ACTION)
      edit.add(i)

      i := TextMenuItem().set_label("Groups...")
      i.connect(self.op_groups, Event.ACTION)
      edit.add(i)

      undo := TextMenuItem().set_label("Undo").set_label_right("Ctrl-z")
      undo.connect(self.op_undo, Event.ACTION)
      edit.add(undo)

      redo := TextMenuItem().set_label("Redo").set_label_right("Ctrl-y")
      redo.connect(self.op_redo, Event.ACTION)
      edit.add(redo)

      rescale := TextMenuItem().set_label("Rescale")
      rescale.connect(self.op_rescale, Event.ACTION)
      edit.add(rescale)

      selections_menu := Menu().set_label("Selections").set_accel("s")
      mb.add(selections_menu)

      alignment_sub_menu := Menu().set_label("Alignment")
      selections_menu.add(alignment_sub_menu)

      copy_sub_menu := Menu().set_label("Copy")
      selections_menu.add(copy_sub_menu)

      order_sub_menu := Menu().set_label("Order")
      selections_menu.add(order_sub_menu)

      group_sub_menu := Menu().set_label("Group")
      selections_menu.add(group_sub_menu)

      i := TextMenuItem().set_label("Centre horizontally")
      i.connect(self.op_centre_horiz_selections, Event.ACTION)
      alignment_sub_menu.add(i)

      i := TextMenuItem().set_label("Centre vertically")
      i.connect(self.op_centre_vert_selections, Event.ACTION)
      alignment_sub_menu.add(i)

      i := TextMenuItem().set_label("Align horizontally")
      i.connect(self.op_align_horiz_selections, Event.ACTION)
      alignment_sub_menu.add(i)

      i := TextMenuItem().set_label("Align vertically")
      i.connect(self.op_align_vert_selections, Event.ACTION)
      alignment_sub_menu.add(i)

      i := TextMenuItem().set_label("End to end horizontally")
      i.connect(self.op_end_to_end_selections_horizontally, Event.ACTION)
      alignment_sub_menu.add(i)

      i := TextMenuItem().set_label("End to end vertically")
      i.connect(self.op_end_to_end_selections_vertically, Event.ACTION)
      alignment_sub_menu.add(i)

      i := TextMenuItem().set_label("Equalize widths")
      i.connect(self.op_equalize_width_selections, Event.ACTION)
      copy_sub_menu.add(i)

      i := TextMenuItem().set_label("Equalize heights")
      i.connect(self.op_equalize_height_selections, Event.ACTION)
      copy_sub_menu.add(i)

      i := TextMenuItem().set_label("Copy attribs")
      i.connect(self.op_copy_attribs, Event.ACTION)
      copy_sub_menu.add(i)

      i := TextMenuItem().set_label("Reorder in container")
      i.connect(self.op_reorder_selections, Event.ACTION)
      order_sub_menu.add(i)

      i := TextMenuItem().set_label("Set tab order")
      i.connect(self.op_set_tab_order_from_selections, Event.ACTION)
      order_sub_menu.add(i)

      i := TextMenuItem().set_label("Set Z order")
      i.connect(self.op_set_z_order_from_selections, Event.ACTION)
      order_sub_menu.add(i)

      i := TextMenuItem().set_label("CheckBoxGroup")
      i.connect(self.op_selections_to_cbg, Event.ACTION)
      group_sub_menu.add(i)

      i := TextMenuItem().set_label("ButtonGroup")
      i.connect(self.op_selections_to_bg, Event.ACTION)
      group_sub_menu.add(i)

      i := TextMenuItem().set_label("Fix")
      i.connect(self.op_fix_selections, Event.ACTION)
      selections_menu.add(i)

      i := TextMenuItem().set_label("Unfix")
      i.connect(self.op_unfix_selections, Event.ACTION)
      selections_menu.add(i)

      i := TextMenuItem().set_label("Delete")
      i.connect(self.op_delete_selections, Event.ACTION)
      selections_menu.add(i)

      read_config_file()
      synch_named_images()

      uis := [CanvasTextButtonUI(),
              CanvasLabelUI(),
              CanvasTextFieldUI(),
              CanvasBorderUI(),
              CanvasIconButtonUI(),
              CanvasIconUI(),
              CanvasImageUI(),
              CanvasCheckBoxUI(),
              CanvasMenuBarUI(),
              CanvasVScrollBarUI(),
              CanvasHScrollBarUI(),
              CanvasPanelUI(),
              CanvasPanelUI2(),
              CanvasTabSetUI(),
              CanvasMenuButtonUI(),
              CanvasOverlaySetUI(),
              CanvasTextListUI(),
              CanvasEditableTextListUI(),
              CanvasListUI(),
              CanvasEditListUI(),
              CanvasListSpinUI(),
              CanvasRangeSpinUI(),
              CanvasHSliderUI(),
              CanvasVSliderUI(),
              CanvasHLineUI(),
              CanvasVLineUI(),
              CanvasHSizerUI(),
              CanvasVSizerUI(),
              CanvasTableUI(),
              CanvasTreeUI(),
              CanvasProgressBarUI(),
              CanvasCustomUI(),
              CanvasTextDisplayUI(),
              CanvasHSplitUI(),
              CanvasVSplitUI()
              ]

      objects_menu := Menu().set_label("Objects").set_accel("o")
      mb.add(objects_menu)

      tb := CustomToolBar().set_constraint("eol", &yes).set_constraint("x_align", "l")

      every ui := !uis do {
         listener := ObjectActionListener(self, ui)
         mi := add_ui_to_menu(objects_menu, ui)
         mi.connect(listener.on_event, Event.ACTION)
         if ui_button := ui.get_button() then {
            tb.add_button(ui_button)
            ui_button.connect(listener.on_event, Event.ACTION)
         }
      }

      plugins := table()
      pp := FilePath(prefs.plugin_directory)
      every f := !Files.list(pp.str()) do {
         if f.stat.mode_str[1] == "-" & upto('x', f.stat.mode_str) then {
            fn := pp.child(f.name).str()
            ce := Prog.load(fn) | stop("Failed to load plugin:", fn)
            plugin := Prog.get_global("main", ce)(self) | stop("Plugin didn't return a Plugin from main")
            insert(plugins, plugin.get_unique_id(), plugin)
            ui := PluginUI(plugin)
            listener := ObjectActionListener(self, ui)
            mi := add_ui_to_menu(objects_menu, ui)
            mi.connect(listener.on_event, Event.ACTION)
         }
      }

      every fp := FilePath(!prefs.named_image_path) do {
         every f := !Files.list(fp.str()) do {
            if ext := is_image_file(f.name) then {
               k := f.name[1:-*ext - 1]
               ImageCache.get_named_image(k) |
                  ImageCache.name_image(k, Files.file_to_string(fp.child(f.name).str()))
            }
         }
      }

      save_button := IconButton().set_tooltip("Save")
      save_button.set_paint(ImagePaint().set_cache("ivib.icn35"))
      save_button.connect(self.op_save_button, Event.ACTION)
      tb.add_button(save_button)

      i := IconButton().set_tooltip("New")
      i.set_paint(ImagePaint().set_cache("ivib.icn40"))
      i.connect(self.op_new, Event.ACTION)
      tb.add_button(i)

      checkboxgroup_button := IconButton().set_tooltip("CheckBoxGroup")
      checkboxgroup_button.set_paint(ImagePaint().set_cache("ivib.icn22"))
      checkboxgroup_button.connect(self.op_selections_to_cbg, Event.ACTION)
      tb.add_button(checkboxgroup_button)

      buttongroup_button := IconButton().set_tooltip("ButtonGroup")
      buttongroup_button.set_paint(ImagePaint().set_cache("ivib.icn23"))
      buttongroup_button.connect(self.op_selections_to_bg, Event.ACTION)
      tb.add_button(buttongroup_button)

      delete_button := IconButton().set_tooltip("Delete")
      delete_button.set_paint(ImagePaint().set_cache("ivib.icn24"))
      delete_button.connect(self.op_delete_selections, Event.ACTION)
      tb.add_button(delete_button)

      undo_button := IconButton().set_tooltip("Undo")
      undo_button.set_paint(ImagePaint().set_cache("ivib.icn25"))
      undo_button.connect(self.op_undo, Event.ACTION)
      tb.add_button(undo_button)

      redo_button := IconButton().set_tooltip("Redo")
      redo_button.set_paint(ImagePaint().set_cache("ivib.icn26"))
      redo_button.connect(self.op_redo, Event.ACTION)
      tb.add_button(redo_button)

      move_selection_up_order_button := IconButton().set_tooltip("Order Up")
      move_selection_up_order_button.set_paint(ImagePaint().set_cache("ivib.icn33"))
      move_selection_up_order_button.connect(self.op_move_selection_up_order_button, Event.ACTION)
      tb.add_button(move_selection_up_order_button)

      move_selection_down_order_button := IconButton().set_tooltip("Order Down")
      move_selection_down_order_button.set_paint(ImagePaint().set_cache("ivib.icn34"))
      move_selection_down_order_button.connect(self.op_move_selection_down_order_button, Event.ACTION)
      tb.add_button(move_selection_down_order_button)

      i := IconButton().set_tooltip("Preview")
      i.set_paint(ImagePaint().set_cache("ivib.icn38"))
      i.connect(self.op_preview, Event.ACTION)
      tb.add_button(i)

      i := IconButton().set_tooltip("Tree view")
      i.set_paint(ImagePaint().set_cache("ivib.icn39"))
      i.connect(self.op_tree, Event.ACTION)
      tb.add_button(i)

      self.add(tb)

      #
      # Create the three text labels below the tool bar.
      #
      p := Component().set_constraint("eol", &yes).set_constraint("x_fill", &yes).set_layout(GridLayout().set_doi(0).set_dii(0))

      filename_label := Label().set_size(scale(200)).set_constraint("y_fill", &yes)
      filename_label.set_border(CompoundBorder().set_outer(SunkenBorder()).set_inner(EmptyBorder().set_l_inset(Gui.TEXT_INSET)).set_x_align("l"))
      filename_label.set_label("")
      p.add(filename_label)

      info_label := Label().set_constraint("x_weight", 1.0).set_constraint("x_fill", &yes).set_constraint("y_fill", &yes)
      info_label.set_border(CompoundBorder().set_outer(SunkenBorder()).set_inner(EmptyBorder().set_l_inset(Gui.TEXT_INSET)).set_x_align("l"))
      info_label.set_label("")
      p.add(info_label)

      pos_label := Label().set_size(scale(200)).set_constraint("y_fill", &yes).set_font("serif,-2")
      pos_label.set_border(CompoundBorder().set_outer(SunkenBorder()).set_inner(EmptyBorder().set_l_inset(Gui.TEXT_INSET)).set_x_align("l"))
      pos_label.set_label("")
      p.add(pos_label)

      self.add(p)

      self.connect(self.op_quit, Event.WINDOW_CLOSE_BUTTON)

      set_label("Ivib")
      canvas_zone := Panel().
         set_bg("blue").
         set_size(scale(50),
                  Canvas.DEFAULT_HEIGHT + 2 * (Canvas.SURROUND + Canvas.EDGE))
      self.add(canvas_zone)

      #
      # Set up the Canvas object.
      #
      canvas_border := BorderOfCanvas()
      canvas := Canvas()
      canvas_border.set_canvas(canvas)
      canvas_border.set_pos(Canvas.SURROUND, Canvas.SURROUND)
      canvas.dialog_iw := Canvas.DEFAULT_WIDTH
      canvas.dialog_ih := Canvas.DEFAULT_HEIGHT
      canvas.synch_size()
      self.canvas_zone.add(canvas_border)
      set_focus(canvas)

      #
      # Initialize the undo/redo lists.
      #
      self.undo_list := []
      self.redo_list := []

      update_grey()
      return
   end
end

#############################################################################
#
# Preferences for program
#     
class Preferences(Dialog)
   public 
      c, 
      undo_size, 
      plugin_dir_field,
      path_tab,
      okay_result

   public on_okay()
      integer(self.undo_size.get_contents()) | return alert_error(self, "Non-integer undo size")
      c.named_image_path := path_tab.get_contents()
      c.undo_size := integer(self.undo_size.get_contents())
      c.plugin_directory := plugin_dir_field.get_contents()
      okay_result := 1
      self.dispose()
   end

   public on_cancel()
      self.dispose()
   end

   public on_plugin_dir_browse()
      local d, s
      d := DirectoryDialog().set_existing_file_mode(DirectoryDialog.REQUIRE)
      d.set_directory(plugin_dir_field.get_contents())
      d.show_modal(self)
      if s := d.get_result() then
         plugin_dir_field.set_contents(s)
   end

   public new(c)
      local tabset, t, oc
      Dialog.new()
      self.c := c
      self.set_label("Program Preferences")

      set_layout(GridLayout())

      tabset := TabSet().set_constraint("eol", &yes)
      add(tabset)
      t := TabItem().set_label("General")
      tabset.add(t)

      t.set_layout(GridLayout())

      t.add(Label().set_label("Undo buffer size"))
      undo_size := TextField().set_constraint("eol", &yes).set_constraint("w", 2).set_size(scale(100))
      undo_size.set_contents(c.undo_size)
      t.add(undo_size)

      t.add(Label().set_label("Plugin directory"))
      plugin_dir_field := FileSuggestField().set_directories_only(&yes).set_size(scale(150))
      plugin_dir_field.set_contents(c.plugin_directory)
      t.add(plugin_dir_field)
      t.add(TextButton().set_label("...").set_constraint("eol", &yes).connect(on_plugin_dir_browse, Event.ACTION))

      path_tab := PathTab(c)
      tabset.add(path_tab)

      oc := OkCancel()
      oc.listen(self)
      self.add(oc)
      return
   end
end

class PathTab(TabItem)
   public 
      c,
      path_list,
      path,
      add_button,   # Buttons              
      delete,                         
      contents,
      browse,
      apply

   public update_grey()
      if *path_list.get_selections() > 0 then {
         path.set_is_shaded(&no)
         browse.set_is_shaded(&no)
         delete.set_is_shaded(&no)
         apply.set_is_shaded(&no)
      } else {
         path.set_is_shaded(&yes)
         browse.set_is_shaded(&yes)
         delete.set_is_shaded(&yes)
         apply.set_is_shaded(&yes)
      }
   end

   public on_add()
      put(contents, "Edit me")
      path_list.contents_changed()
      path_list.goto_first(*contents)
      path_list.set_selections([*contents])
      path_list.set_cursor(*contents)
      path.set_contents(contents[-1])
      update_grey()
      path.grab_focus()
      path.handle_select_all()
   end

   public on_delete()
      path_list.delete_lines(path_list.get_selections())
      update_grey()
   end

   public on_apply()
      local i
      #
      # Copy the edited item back to the table. 
      #
      i := path_list.get_selections()[1]
      contents[i] := path.get_contents()
      path_list.contents_changed()
      path_list.clear_selections()
      update_grey()
   end

   public on_list()
      #
      # Line in the table clicked - copy the line to the edit area.
      #
      path.set_contents(path_list.object_get_selections()[1])
      update_grey()
   end

   public on_browse()
      local d, s
      d := DirectoryDialog().set_existing_file_mode(DirectoryDialog.REQUIRE)
      d.set_directory("Edit me" ~== path.get_contents())
      d.show_modal(self.parent_dialog)
      if s := d.get_result() then {
         path.set_contents(s)
         on_apply()
      }
   end

   public get_contents()
      return contents
   end

   public new(c)
      local p
      TabItem.new()
      self.c := c
      contents := copy(c.named_image_path)
      set_layout(GridLayout())
      set_label("Named Image Paths")

      path_list := TextList().set_size(scale(250),scale(150)).set_constraint("eol", &yes).set_select_mode("one").set_contents(contents)
      path_list.connect(self.on_list, Event.SELECTION_CHANGED)
      add(path_list)

      p := Panel().set_constraint("eol", &yes).set_constraint("y_weight", 0.0).set_layout(GridLayout().set_doi(0))
      path := FileSuggestField().set_directories_only(&yes).set_size(scale(150))
      path.connect(self.on_apply, Event.ACTION)
      p.add(path)

      browse := TextButton().set_label("...").set_constraint("eol", &yes)
      browse.connect(self.on_browse, Event.ACTION)
      p.add(browse)

      add(p)
    
      p := Panel().set_constraint("eol", &yes).set_constraint("y_weight", 0.0).set_layout(GridLayout().set_doi(0))
      add_button := TextButton()
      add_button.connect(self.on_add, Event.ACTION)
      add_button.set_label("Add")
      p.add(add_button)

      delete := TextButton()
      delete.connect(self.on_delete, Event.ACTION)
      delete.set_label("Delete")
      p.add(delete)

      apply := TextButton()
      apply.connect(self.on_apply, Event.ACTION)
      apply.set_label("Apply")
      p.add(apply)

      add(p)

      update_grey()
      return
   end
end

class IvibClipboardSelectionOwner(SelectionOwner)
   public parent

   public get_content()
      return parent.clipboard
   end

   public lost_ownership()
   end

   public get_targets()
      return Ivib.IVIB_COMPONENT_TARGET
   end

   public new(parent)
      self.parent := parent
      return
   end
end

$load LOGO "icon/logo.gif"
$load ICN10 "icon/icn10.gif"
$load ICN11 "icon/icn11.gif"
$load ICN12 "icon/icn12.gif"
$load ICN13 "icon/icn13.gif"
$load ICN14 "icon/icn14.gif"
$load ICN15 "icon/icn15.gif"
$load ICN16 "icon/icn16.gif"
$load ICN17 "icon/icn17.gif"
$load ICN18 "icon/icn18.gif"
$load ICN19 "icon/icn19.gif"
$load ICN1 "icon/icn1.gif"
$load ICN20 "icon/icn20.gif"
$load ICN21 "icon/icn21.gif"
$load ICN22 "icon/icn22.gif"
$load ICN23 "icon/icn23.gif"
$load ICN24 "icon/icn24.gif"
$load ICN25 "icon/icn25.gif"
$load ICN26 "icon/icn26.gif"
$load ICN27 "icon/icn27.gif"
$load ICN28 "icon/icn28.gif"
$load ICN29 "icon/icn29.gif"
$load ICN2 "icon/icn2.gif"
$load ICN30 "icon/icn30.gif"
$load ICN31 "icon/icn31.gif"
$load ICN32 "icon/icn32.gif"
$load ICN33 "icon/icn33.gif"
$load ICN34 "icon/icn34.gif"
$load ICN35 "icon/icn35.gif"
$load ICN36 "icon/icn36.gif"
$load ICN37 "icon/icn37.gif"
$load ICN38 "icon/icn38.gif"
$load ICN39 "icon/icn39.gif"
$load ICN3 "icon/icn3.gif"
$load ICN40 "icon/icn40.gif"
$load ICN4 "icon/icn4.gif"
$load ICN5 "icon/icn5.gif"
$load ICN6 "icon/icn6.gif"
$load ICN7 "icon/icn7.gif"
$load ICN8 "icon/icn8.gif"
$load ICN9 "icon/icn9.gif"
$load ICON "icon/icon.gif"

procedure load_icon(key, data)
   local k
   k := key || ".raw"
   ImageCache.name_image(k, data)
   ImageCache.copy_key_with_resize(key, k)
end

procedure load_icons()
   load_icon("ivib.icn10", ICN10)
   load_icon("ivib.icn11", ICN11)
   load_icon("ivib.icn12", ICN12)
   load_icon("ivib.icn13", ICN13)
   load_icon("ivib.icn14", ICN14)
   load_icon("ivib.icn15", ICN15)
   load_icon("ivib.icn16", ICN16)
   load_icon("ivib.icn17", ICN17)
   load_icon("ivib.icn18", ICN18)
   load_icon("ivib.icn19", ICN19)
   load_icon("ivib.icn1", ICN1)
   load_icon("ivib.icn20", ICN20)
   load_icon("ivib.icn21", ICN21)
   load_icon("ivib.icn22", ICN22)
   load_icon("ivib.icn23", ICN23)
   load_icon("ivib.icn24", ICN24)
   load_icon("ivib.icn25", ICN25)
   load_icon("ivib.icn26", ICN26)
   load_icon("ivib.icn27", ICN27)
   load_icon("ivib.icn28", ICN28)
   load_icon("ivib.icn29", ICN29)
   load_icon("ivib.icn2", ICN2)
   load_icon("ivib.icn30", ICN30)
   load_icon("ivib.icn31", ICN31)
   load_icon("ivib.icn32", ICN32)
   load_icon("ivib.icn33", ICN33)
   load_icon("ivib.icn34", ICN34)
   load_icon("ivib.icn35", ICN35)
   load_icon("ivib.icn36", ICN36)
   load_icon("ivib.icn37", ICN37)
   load_icon("ivib.icn38", ICN38)
   load_icon("ivib.icn39", ICN39)
   load_icon("ivib.icn3", ICN3)
   load_icon("ivib.icn40", ICN40)
   load_icon("ivib.icn4", ICN4)
   load_icon("ivib.icn5", ICN5)
   load_icon("ivib.icn6", ICN6)
   load_icon("ivib.icn7", ICN7)
   load_icon("ivib.icn8", ICN8)
   load_icon("ivib.icn9", ICN9)
   load_icon("ivib.icon", ICON)
   ImageCache.name_image("ivib.logo", LOGO)
end
