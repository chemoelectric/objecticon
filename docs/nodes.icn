import io, util

class Node()
   public const data
   private l, r

   public insert(val)
      if val < data then
         (/l := Node(val)) | l.insert(val)
      else
         (/r := Node(val)) | r.insert(val)
   end

   public traverse()
      (\l).traverse()
      coact(self)
      (\r).traverse()
   end

   public traverse2()
      (\l).traverse2()
      self@&source
      (\r).traverse2()
   end

   public gen()
      suspend (\l).gen() | self | (\r).gen()
   end

   public depth()
      local dl, dr
      dl := (\l).depth() | 0
      dr := (\r).depth() | 0
      return 1 + max(dl, dr)
   end

   public new(i)
      self.data := i
      return
   end
end

procedure main(a)
   local root, e, r, n, i, v, nt

   # n is the number of elements to insert
   n := integer(a[1]) | 250000

   # v is the range of values to insert (1..v)
   v := integer(a[2]) | (n / 2)

   # nt is the number of times to run each traversal (larger obviously
   # gives more accuracy but takes longer).
   nt := max(2000000 / n, 1)

   # Make sure the procedure traversal doesn't exceed the call depth
   # limit.
   &maxlevel := n

   # Create the tree
   write("Creating tree with ", n, " entries in range 1..", v)
   r := create |?v
   root := Node(@r)
   every i := 1 to n do {
      root.insert(@r)
      if i % 1000 = 0 then
         writes("\e[K   ", (i * 100) / n, "% complete\r")
   }
   write("\e[KComplete")

   write("Tree depth = ", root.depth(), ", number of traversals = ", nt)

   note_time()
   every 1 to nt do
      every root.gen()
   note_time("procedure")

   note_time()
   every 1 to nt do {
      e := create root.traverse()
      while @e
   }
   note_time("coact()")

   note_time()
   every 1 to nt do {
      e := create root.traverse2()
      while @e
   }
   note_time("@&source")
end
