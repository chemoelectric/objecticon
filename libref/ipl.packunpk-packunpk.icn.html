<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>packunpk.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     packunpk.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures to pack and unpack decimal strings
<a name="6"/>#
<a name="7"/>#	Author:   C. Tenaglia (modified by Richard L. Goerwitz)
<a name="8"/>#
<a name="9"/>#	Date:     May 2, 2001
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#	Version:  1.2
<a name="18"/>#
<a name="19"/>############################################################################
<a name="20"/>#
<a name="21"/>#      Integers written directly as strings occupy much more space
<a name="22"/>#  than they need to.  One easy way to shrink them a bit is to "pack"
<a name="23"/>#  them, i.e.  convert each decimal digit into a four-byte binary
<a name="24"/>#  code, and pack these four-bit chunks into eight-bit characters,
<a name="25"/>#  which can be written to a file.
<a name="26"/>#
<a name="27"/>#      Interestingly, packing decimal strings in this manner lends
<a name="28"/>#  itself to unpacking by treating each character as a base-10
<a name="29"/>#  integer, and then converting it to base-16.  Say we have an input
<a name="30"/>#  string "99."  Pack() would convert it to an internal representation
<a name="31"/>#  of char(16*9 + 9), i.e. char(153).  Unpack would treat this
<a name="32"/>#  char(153) representation as a base-10 integer, and convert it to
<a name="33"/>#  base 16 (i.e. 10r153 -&gt; 16r99).  The 99 is, of course, what we
<a name="34"/>#  started with.
<a name="35"/>#
<a name="36"/>#      Note that two unpack routines are provided here:  The first, by
<a name="37"/>#  Tanaglia, utilizes convert.icn from the IPL.  The second, by
<a name="38"/>#  Goerwitz, does not.  They utilize very different methods, but both
<a name="39"/>#  amount to basically the same thing.  Goerwitz's routine returns an
<a name="40"/>#  integer, though, and has no "width" argument.
<a name="41"/>#
<a name="42"/>############################################################################
<a name="43"/>#
<a name="44"/>#  Links:  convert
<a name="45"/>#
<a name="46"/>############################################################################
<a name="47"/>
<a name="48"/>package ipl.packunpk
<a name="49"/>
<a name="50"/>import
<a name="51"/>   ipl.convert(radcon)
<a name="52"/>
<a name="53"/>procedure pack(num,width)     
<a name="54"/>
<a name="55"/>    local int, sign, prep, packed, word
<a name="56"/>
<a name="57"/>    int := integer(num) | fail
<a name="58"/>    # There's really no need to store the sign if it's positive, UNLESS
<a name="59"/>    # you are using this program to store packed decimal integers for
<a name="60"/>    # access by other programs on certain mainframes that always store
<a name="61"/>    # the sign.
<a name="62"/>    # if int &lt; 0 then sign := "=" else sign := "&lt;"
<a name="63"/>    if int &lt; 0 then sign := "=" else sign := ""
<a name="64"/>    prep   := string(abs(int)) || sign
<a name="65"/>    packed := ""
<a name="66"/>    if (*prep % 2) ~= 0 then prep := "0" || prep
<a name="67"/>
<a name="68"/>    prep ? {
<a name="69"/>	while word := move(2) do {
<a name="70"/>	    if pos(0)
<a name="71"/>	    then packed ||:= char(integer(word[1])*16 + ord(word[2])-48)
<a name="72"/>	    else packed ||:= char(integer(word[1])*16 + integer(word[2]))
<a name="73"/>	}
<a name="74"/>    }
<a name="75"/>
<a name="76"/>    /width := *packed
<a name="77"/>    return right(packed, width, "\0")
<a name="78"/>
<a name="79"/>end
<a name="80"/>
<a name="81"/>
<a name="82"/>
<a name="83"/>procedure unpack(val,width)   
<a name="84"/>
<a name="85"/>    # THIS PROCEDURE UNPACKS A VALUE INTO A STRING-INTEGER. USING THIS
<a name="86"/>    # CODE SEGMENT REQUIRES LINKING WITH RADCON FROM THE IPL.
<a name="87"/>
<a name="88"/>    local tmp, number,   sign
<a name="89"/>
<a name="90"/>    tmp  := ""
<a name="91"/>    sign := 1
<a name="92"/>
<a name="93"/>    every number := ord(!val) do
<a name="94"/>	tmp ||:= right(map(radcon(number,10,16),&amp;lcase,&amp;ucase),2,"0")
<a name="95"/>
<a name="96"/>    if tmp[-1] == ("B" | "D") then {
<a name="97"/>	sign := -1
<a name="98"/>	# In this configuration, the sign field is only present if the
<a name="99"/>	# integer is negative.  If you have set up pack to register posi-
<a name="100"/>	# tive values in the sign field, place the following line after
<a name="101"/>	# the "if-then" expression.
<a name="102"/>	tmp[-1] :=  ""
<a name="103"/>    }
<a name="104"/>    tmp    *:= sign
<a name="105"/>    /width  := *string(tmp)
<a name="106"/>
<a name="107"/>    return right(string(tmp), width)
<a name="108"/>
<a name="109"/>end
<a name="110"/>
<a name="111"/>
<a name="112"/>
<a name="113"/>procedure unpack2(val)
<a name="114"/>
<a name="115"/>    # THIS PROCEDURE UNPACKS A VALUE INTO AN STRING-INTEGER.
<a name="116"/>    # Note:  Unpack2 assumes that pack is not recording positive
<a name="117"/>    # sign values.
<a name="118"/>
<a name="119"/>    local unpacked, int
<a name="120"/>
<a name="121"/>    unpacked := ""
<a name="122"/>    val ? {
<a name="123"/>	while int := ord(move(1)) do {
<a name="124"/>	    unpacked ||:= string(iand(2r11110000,int) / 16)
<a name="125"/>	    if pos(0) then {
<a name="126"/>		if iand(2r00001111,int) = 13 then {
<a name="127"/>		    unpacked := "-" || unpacked
<a name="128"/>		    break
<a name="129"/>		}
<a name="130"/>	    }
<a name="131"/>	    unpacked ||:= string(iand(2r00001111,int))
<a name="132"/>	}
<a name="133"/>    }
<a name="134"/>
<a name="135"/>    return integer(unpacked)
<a name="136"/>
<a name="137"/>end
</pre></body></html>
