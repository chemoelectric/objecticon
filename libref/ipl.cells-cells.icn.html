<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>cells.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     cells.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures for creating and coloring panels of cells
<a name="6"/>#
<a name="7"/>#	Author:   Ralph E. Griswold
<a name="8"/>#
<a name="9"/>#	Date:     December 12, 1999
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#  This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#  These procedures create an manipulate panels of cells.
<a name="18"/>#
<a name="19"/>#	makepanel(n, m, size, fg, bg, pg)
<a name="20"/>#		makes a panel in a hidden window with nxm cells of the
<a name="21"/>#		given size, default 10.  fg, bg, and pg are the
<a name="22"/>#		colors for the window and panel backgrounds. fg
<a name="23"/>#		and bg default to black and white, respectively.
<a name="24"/>#		If pg is not given a patterned background is used.
<a name="25"/>#
<a name="26"/>#	matrixpanel(matrix, size, fg, bg, pg)
<a name="27"/>#		same as makepanel(), except matrix determines the
<a name="28"/>#		dimensions.
<a name="29"/>#
<a name="30"/>#	clearpanel(panel)
<a name="31"/>#		restores the panel to its original state as made by
<a name="32"/>#		makepanel.
<a name="33"/>#
<a name="34"/>#	colorcell(panel, n, m, color)
<a name="35"/>#		colors the cell (n,m) in panel with color.  The
<a name="36"/>#		size defaults to 10.
<a name="37"/>#
<a name="38"/>#	colorcells(panel, tier)
<a name="39"/>#		is like colorcell(), except it operates on a tie-up
<a name="40"/>#		record.
<a name="41"/>#
<a name="42"/>#	cell(panel, x, y)
<a name="43"/>#		returns Cell() record for the cell in which x,y
<a name="44"/>#		lies.  If fails if the point is out of bounds.
<a name="45"/>#
<a name="46"/>#	tiercells(panel, matrix)
<a name="47"/>#		is like colorcell(), except all cells are colored
<a name="48"/>#		using a matrix of colors.
<a name="49"/>#
<a name="50"/>############################################################################
<a name="51"/>#
<a name="52"/>#  Requires:  Version 9 graphics
<a name="53"/>#
<a name="54"/>############################################################################
<a name="55"/>#
<a name="56"/>#  Links:  wopen
<a name="57"/>#
<a name="58"/>############################################################################
<a name="59"/>
<a name="60"/>package ipl.cells
<a name="61"/>
<a name="62"/>import
<a name="63"/>   graphics(Window)
<a name="64"/>
<a name="65"/>record Cell(n, m, color)
<a name="66"/>record Panel(window, n, m, size, fg, bg, pg)
<a name="67"/>
<a name="68"/># make panel of cells
<a name="69"/>procedure makepanel(n, m, cellsize, fg, bg, pg)		
<a name="70"/>   local window,   width, height, panel
<a name="71"/>
<a name="72"/>   /fg := "black"
<a name="73"/>   /bg := "white"
<a name="74"/>
<a name="75"/>   /cellsize := 10
<a name="76"/>
<a name="77"/>   width := (n * cellsize + 1)
<a name="78"/>   height := (m * cellsize + 1)
<a name="79"/>
<a name="80"/>   window := Window().set_size(width, height).
<a name="81"/>      set_fg(fg).set_bg(bg)  | fail
<a name="82"/>
<a name="83"/>   panel := Panel(window, n, m, cellsize, fg, bg, pg)
<a name="84"/>
<a name="85"/>   clearpanel(panel)
<a name="86"/>
<a name="87"/>   return panel
<a name="88"/>
<a name="89"/>end
<a name="90"/>
<a name="91"/>procedure clearpanel(panel)
<a name="92"/>   local width, height, x, y
<a name="93"/>   
<a name="94"/>   if \panel.pg then {			# default is textured
<a name="95"/>      panel.window.set_bg("very dark gray")
<a name="96"/>      panel.window.set_textured_pattern("checkers")
<a name="97"/>      }
<a name="98"/>   else panel.window.set_fg(panel.fg)
<a name="99"/>
<a name="100"/>   width := panel.window.get_width()
<a name="101"/>   height := panel.window.get_height()
<a name="102"/>
<a name="103"/>   every x := 0 to width by panel.size do
<a name="104"/>      panel.window.draw_line(x, 0, x, height)
<a name="105"/>
<a name="106"/>   every y := 0 to height by panel.size do
<a name="107"/>      panel.window.draw_line(0, y, width, y)
<a name="108"/>
<a name="109"/>   panel.window.set_pattern()
<a name="110"/>
<a name="111"/>   return panel
<a name="112"/>
<a name="113"/>end
<a name="114"/>
<a name="115"/>procedure matrixpanel(matrix, cellsize, fg, bg, pg)
<a name="116"/>
<a name="117"/>   return makepanel(*matrix[1], *matrix, cellsize, fg, bg)
<a name="118"/>
<a name="119"/>end
<a name="120"/>
<a name="121"/># color cell in panel
<a name="122"/>procedure colorcell(panel, n, m, color)		
<a name="123"/>   local cellsize
<a name="124"/>
<a name="125"/>   n := integer(n) | runerr(101, n)
<a name="126"/>   m := integer(m) | runerr(101, m)
<a name="127"/>
<a name="128"/>   cellsize := panel.size
<a name="129"/>
<a name="130"/>   panel.window.set_fg( color)
<a name="131"/>
<a name="132"/>   panel.window.fill_rectangle((n - 1) * cellsize + 1, (m - 1) * cellsize + 1,
<a name="133"/>       cellsize - 1, cellsize - 1)
<a name="134"/>
<a name="135"/>   return panel
<a name="136"/> 
<a name="137"/>end
<a name="138"/>
<a name="139"/># color all cells in panel
<a name="140"/>procedure colorcells(panel, matrix)		
<a name="141"/>   local i, j, n, m, cellsize
<a name="142"/>
<a name="143"/>   cellsize := panel.size
<a name="144"/>
<a name="145"/>   m := *matrix
<a name="146"/>   n := *matrix[1]
<a name="147"/>
<a name="148"/>   every i := 1 to m do {
<a name="149"/>      every j := 1 to n do {
<a name="150"/>         # fudge 0/1 matrix
<a name="151"/>         if matrix[i, j] === "1" then matrix[i, j] := "white"
<a name="152"/>         else if matrix[i, j] === "0" then matrix[i, j] := "black"
<a name="153"/>         panel.window.set_fg(matrix[i, j]) |
<a name="154"/>            runerr("set_fg() failed in colorcells() with matrix[" ||
<a name="155"/>              i || "," || j || "]=" || matrix[i, j] || ".")
<a name="156"/>         panel.window.fill_rectangle((j - 1) * cellsize + 1, (i - 1) * cellsize + 1,
<a name="157"/>            cellsize - 1, cellsize - 1)
<a name="158"/>         }
<a name="159"/>      }
<a name="160"/>
<a name="161"/>   return panel
<a name="162"/> 
<a name="163"/>end
<a name="164"/>
<a name="165"/># color all cells in panel
<a name="166"/>procedure tiercells(panel, tier)		
<a name="167"/>   local i, j, n, m, cellsize, matrix
<a name="168"/>
<a name="169"/>   cellsize := panel.size
<a name="170"/>
<a name="171"/>   m := tier.shafts
<a name="172"/>   n := tier.treadles
<a name="173"/>   matrix := tier.matrix
<a name="174"/>
<a name="175"/>   every i := 1 to m do {
<a name="176"/>      every j := 1 to n do {
<a name="177"/>         if matrix[i, j] === "1" then panel.window.set_fg("white")
<a name="178"/>         else panel.window.set_fg("black")
<a name="179"/>         panel.window.fill_rectangle((j - 1) * cellsize + 1, (i - 1) * cellsize + 1,
<a name="180"/>            cellsize - 1, cellsize - 1)
<a name="181"/>         }
<a name="182"/>      }
<a name="183"/>
<a name="184"/>   return panel
<a name="185"/> 
<a name="186"/>end
<a name="187"/>
<a name="188"/>procedure cell(panel, x, y)
<a name="189"/>   local n, m, px, c
<a name="190"/>
<a name="191"/>   n := x / panel.size + 1
<a name="192"/>   m := y / panel.size + 1
<a name="193"/>
<a name="194"/>   if (n &gt; panel.n) | (m &gt; panel.m) then fail
<a name="195"/>
<a name="196"/>   px := panel.window.get_pixels(x, y, 1, 1)
<a name="197"/>   c := px.get(0, 0)
<a name="198"/>   px.close()
<a name="199"/>   return Cell(n, m, c)
<a name="200"/>
<a name="201"/>end
</pre></body></html>
