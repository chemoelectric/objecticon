<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>abkform.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     abkform.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures to process HP95LX appointment books
<a name="6"/>#
<a name="7"/>#	Author:   Robert J. Alexander
<a name="8"/>#
<a name="9"/>#	Date:     May 2, 2001
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#  Procedures set to read and write HP95LX appointment book (.abk) files.
<a name="18"/>#
<a name="19"/># 
<a name="20"/># Notes:
<a name="21"/># 
<a name="22"/># 1. Files created by the Appointment Book application may contain 
<a name="23"/># some padding following the last field of some data records.  Hence,
<a name="24"/># the RecordLength field must be used to determine the start of the
<a name="25"/># next record.  Appointment book files created by other programs need not
<a name="26"/># have any padding.
<a name="27"/># 
<a name="28"/># 2. ApptState has several bit fields.  Only bit 0 is meaningful to software
<a name="29"/># processing an appointment book file.  Bit 0 being set or cleared 
<a name="30"/># corresponds to the alarm being enabled or disabled, respectively.
<a name="31"/># Programs creating Appointment book files should clear all bits, except
<a name="32"/># perhaps bit 0.
<a name="33"/># 
<a name="34"/># 3. ToDoState has two one-bit bit fields.  Bit 0 being set or cleared
<a name="35"/># corresponds to carry forward being enabled or disabled for this todo
<a name="36"/># item, respectively.  Bit 1 being set or cleared corresponds to the doto 
<a name="37"/># being checked off or not checked off, respectively. 
<a name="38"/># 
<a name="39"/># 4. Appointment and ToDo texts are each limited to a maximum of 27
<a name="40"/># characters.
<a name="41"/># 
<a name="42"/># 5. Note text is limited to a maximum of 11 lines of 39 characters per line
<a name="43"/># (not counting the line terminator).
<a name="44"/># 
<a name="45"/>#
<a name="46"/>############################################################################
<a name="47"/>#
<a name="48"/>#  Links: bkutil, pbkform
<a name="49"/>#
<a name="50"/>############################################################################
<a name="51"/>#
<a name="52"/>#  See also: bkutil.icn, pbkform.icn
<a name="53"/>#
<a name="54"/>############################################################################
<a name="55"/>
<a name="56"/>package ipl.abkform
<a name="57"/>
<a name="58"/>import
<a name="59"/>   io(reads, writes),
<a name="60"/>   ipl.bkutil(bk_int, bk_read_int),
<a name="61"/>   ipl.pbkform(pbk_id)
<a name="62"/>
<a name="63"/># HP 95LX Appointment Book File Format
<a name="64"/># 
<a name="65"/># The HP 95LX Appointment Book file is structured as a file-identification
<a name="66"/># record, followed by a settings record, followed by a variable number of data
<a name="67"/># records, and terminated by an end-of-file record. There are multiple types of
<a name="68"/># data records corresponding to the different types of appointment book entries.
<a name="69"/># 
<a name="70"/># The formats of these appointment book records is described in the following
<a name="71"/># tables. In the descriptions, the type &lt;int&gt; refers to a two-byte integer
<a name="72"/># stored least significant byte first, the type &lt;swpint&gt; refers to a two-byte
<a name="73"/># integer stored most significant byte first, the type &lt;char&gt; refers to a
<a name="74"/># one-byte integer, and the type &lt;ASCII&gt; refers to a string of ASCII
<a name="75"/># characters.
<a name="76"/># 
<a name="77"/># HP 95LX Appointment Book File Identification Record:
<a name="78"/># 
<a name="79"/># Byte Offset      Name            Type     Contents
<a name="80"/># 
<a name="81"/># 0                ProductCode     int      -1 (FFh, FFh)
<a name="82"/># 2                ReleaseNum      int      1 (01h, 00h)
<a name="83"/># 4                FileType        char     1 (01h) 
<a name="84"/># 
<a name="85"/>procedure abk_write_id(f)
<a name="86"/>   return writes(f,"\xff\xff\x01\x00\x01")
<a name="87"/>end
<a name="88"/>
<a name="89"/>record abk_id(releaseNum,filetype)
<a name="90"/>
<a name="91"/>procedure abk_read_id(f)
<a name="92"/>   bk_read_int(f) = 16rffff | fail
<a name="93"/>   return pbk_id(bk_read_int(f),ord(reads(f)))
<a name="94"/>end
<a name="95"/>
<a name="96"/># 
<a name="97"/># HP 95LX Appointment Book Settings Record:  
<a name="98"/># 
<a name="99"/># Byte Offset      Name            Type     Contents
<a name="100"/># 
<a name="101"/># 0                StartTime       int      Daily display start time as the
<a name="102"/>#                                           number of minutes past midnight.
<a name="103"/># 2                Granularity     int      Daily display time line granularity
<a name="104"/>#                                           in minutes.
<a name="105"/># 4                AlarmEnable     char     1 = on, 0 = off
<a name="106"/># 5                LeadTime        char     Alarm default lead time in minutes.
<a name="107"/># 6                CarryForward    char     To do carry forward default,
<a name="108"/>#                                           1 = on, 0 = off.
<a name="109"/>#
<a name="110"/>record abk_settings(startTime,granularity,alarmEnable,leadTime,carryForward)
<a name="111"/>
<a name="112"/>procedure abk_write_settings(f,data)
<a name="113"/>   return writes(f,bk_int(data.startTime),bk_int(data.granularity),
<a name="114"/>      char(data.alarmEnable), char(data.leadTime),char(data.carryForward))
<a name="115"/>end
<a name="116"/>
<a name="117"/>procedure abk_read_settings(f)
<a name="118"/>   return abk_settings(bk_read_int(f),bk_read_int(f),ord(reads(f)),
<a name="119"/>	 ord(reads(f)),ord(reads(f)))
<a name="120"/>end
<a name="121"/>
<a name="122"/># 
<a name="123"/># 
<a name="124"/># HP 95LX Appointment Book Daily Data Record:
<a name="125"/># 
<a name="126"/># Byte Offset      Name            Type     Contents
<a name="127"/># 
<a name="128"/># 0                RecordType      char     1 (01h)
<a name="129"/># 1                RecordLength    int      Number of bytes in remainder
<a name="130"/>#                                           of this data record, see note 1
<a name="131"/>#                                           below.
<a name="132"/># 3                ApptState       char     See note 2 below.
<a name="133"/># 4                Year            char     Year counting from 1900.
<a name="134"/># 5                Month           char     Month, 1 - 12.
<a name="135"/># 6                Day             char     Day, 1 - 31.
<a name="136"/># 7                StartTime       swpint   Start time in minutes since midnight.
<a name="137"/># 9                EndTime         int      End time in minutes since midnight.
<a name="138"/># 11               LeadTime        char     Alarm lead time in minutes, 0 - 30.
<a name="139"/># 12               ApptLength      char     Length of appointment text in bytes.
<a name="140"/># 13               NoteLength      int      Length of note text in bytes.
<a name="141"/># 15               ApptText        ASCII    Appointment text - see note 4 below.
<a name="142"/># 15+ApptLength    NoteText        ASCII    Note text where the null character 
<a name="143"/>#                                           is used as the line terminator -
<a name="144"/>#                                           see note 5.
<a name="145"/>#
<a name="146"/>record abk_daily(alarmEnable,year,month,day,startTime,endTime,leadTime,
<a name="147"/>      apptText,noteText)
<a name="148"/>
<a name="149"/>procedure abk_write_daily(f,data)
<a name="150"/>      writes(char((\data.alarmEnable,1) | 0),
<a name="151"/>	    char(data.year),char(data.month),char(data.day),
<a name="152"/>	    bk_int(data.startTime),bk_int(data.endTime),bk_int(data.leadTime),
<a name="153"/>	    char(*data.apptText),char(*data.noteText),data.apptText,data.noteText)
<a name="154"/>      return data
<a name="155"/>end
<a name="156"/>
<a name="157"/>procedure abk_read_daily(f)
<a name="158"/>   local alarmEnable,year,month,day,startTime,endTime,leadTime,
<a name="159"/>	 apptText,noteText,apptLength,noteLength,next_rec
<a name="160"/>   (reads(f) == "\x01" | (f.seek(f.tell(f) - 1),&amp;fail) &amp;
<a name="161"/>   next_rec := bk_read_int(f) + f.tell() &amp;
<a name="162"/>   alarmEnable := iand(ord(reads(f)),1) = 1 | &amp;null &amp;
<a name="163"/>   year := ord(reads(f)) &amp;
<a name="164"/>   month := ord(reads(f)) &amp;
<a name="165"/>   day := ord(reads(f)) &amp;
<a name="166"/>   startTime := bk_read_int(f) &amp;
<a name="167"/>   endTime := bk_read_int(f) &amp;
<a name="168"/>   leadTime := ord(reads(f)) &amp;
<a name="169"/>   apptLength := ord(reads(f)) &amp;
<a name="170"/>   noteLength := bk_read_int(f) &amp;
<a name="171"/>   apptText := reads(f,apptLength) &amp;
<a name="172"/>   noteText := reads(f,noteLength)) | fail
<a name="173"/>   return abk_daily(alarmEnable,year,month,day,startTime,endTime,leadTime,
<a name="174"/>	 apptText,noteText)
<a name="175"/>end
<a name="176"/>
<a name="177"/># 
<a name="178"/># HP 95LX Appointment Book Weekly Data Record:
<a name="179"/># 
<a name="180"/># Byte Offset      Name            Type     Contents
<a name="181"/># 
<a name="182"/># 0                RecordType      char     2 (02h)
<a name="183"/># 1                RecordLength    int      Number of bytes in remainder
<a name="184"/>#                                           of this data record, see note 1
<a name="185"/>#                                           below.
<a name="186"/># 3                ApptState       char     See note 2 below.
<a name="187"/># 4                DayOfWeek       char     Day of week, 1=Sun, ..., 7=Sat.
<a name="188"/># 5                StartTime       swpint   Start time in minutes since midnight.
<a name="189"/># 7                StartYear       char     Start year counting from 1900.
<a name="190"/># 8                StartMonth      char     Start month, 1 - 12.
<a name="191"/># 9                StartDay        char     Start day, 1 - 31.
<a name="192"/># 10               EndTime         int      End time in minutes since midnight.
<a name="193"/># 12               EndYear         char     End year counting from 1900.
<a name="194"/># 13               EndMonth        char     End month, 1 - 12.
<a name="195"/># 14               EndDay          char     End day, 1 - 31.
<a name="196"/># 15               LeadTime        char     Alarm lead time in minutes, 0 - 30.
<a name="197"/># 16               ApptLength      char     Length of appointment text in bytes.
<a name="198"/># 17               NoteLength      int      Length of note text in bytes.
<a name="199"/># 19               ApptText        ASCII    Appointment text - see note 4 below.
<a name="200"/># 19+ApptLength    NoteText        ASCII    Note text where the null character 
<a name="201"/>#                                           is used as the line terminator -
<a name="202"/>#                                           see note 5 below.
<a name="203"/>#
<a name="204"/>record abk_weekly(alarmEnable,dayOfWeek,startTime,startYear,startMonth,startDay,
<a name="205"/>      endTime,endYear,endMonth,endDay,leadTime,apptText,noteText)
<a name="206"/>
<a name="207"/>procedure abk_write_weekly(f,data)
<a name="208"/>      writes(char((\data.alarmEnable,1) | 0),
<a name="209"/>	    char(data.dayOfWeek),
<a name="210"/>	    bk_int(data.startTime),char(data.startYear),
<a name="211"/>	    char(data.startMonth),char(data.startDay),
<a name="212"/>	    bk_int(data.endTime),char(data.endYear),
<a name="213"/>	    char(data.endMonth),char(data.endDay),
<a name="214"/>	    bk_int(data.leadTime),
<a name="215"/>	    char(*data.apptText),char(*data.noteText),data.apptText,data.noteText)
<a name="216"/>      return data
<a name="217"/>end
<a name="218"/>
<a name="219"/>procedure abk_read_weekly(f)
<a name="220"/>   local alarmEnable,dayOfWeek,startTime,startYear,startMonth,startDay,
<a name="221"/>	 endTime,endYear,endMonth,endDay,leadTime,apptLength,noteLength,
<a name="222"/>	 apptText,noteText,next_rec
<a name="223"/>   (reads(f) == "\x02" | (f.seek(f.tell() - 1),&amp;fail) &amp;
<a name="224"/>   next_rec := bk_read_int(f) + f.tell() &amp;
<a name="225"/>   alarmEnable := iand(ord(reads(f)),1) = 1 | &amp;null &amp;
<a name="226"/>   dayOfWeek := ord(reads(f)) &amp;
<a name="227"/>   startTime := bk_read_int(f) &amp;
<a name="228"/>   startYear := ord(reads(f)) &amp;
<a name="229"/>   startMonth := ord(reads(f)) &amp;
<a name="230"/>   startDay := ord(reads(f)) &amp;
<a name="231"/>   endTime := bk_read_int(f) &amp;
<a name="232"/>   endYear := ord(reads(f)) &amp;
<a name="233"/>   endMonth := ord(reads(f)) &amp;
<a name="234"/>   endDay := ord(reads(f)) &amp;
<a name="235"/>   leadTime := ord(reads(f)) &amp;
<a name="236"/>   apptLength := ord(reads(f)) &amp;
<a name="237"/>   noteLength := bk_read_int(f) &amp;
<a name="238"/>   apptText := reads(f,apptLength) &amp;
<a name="239"/>   noteText := reads(f,noteLength)) | fail
<a name="240"/>   return abk_daily(alarmEnable,dayOfWeek,startTime,startYear,startMonth,
<a name="241"/>	 startDay,endTime,endYear,endMonth,endDay,leadTime,apptText,noteText)
<a name="242"/>end
<a name="243"/>
<a name="244"/># 
<a name="245"/># 
<a name="246"/># HP 95LX Appointment Book Monthly by Date Data Record:
<a name="247"/># 
<a name="248"/># Byte Offset      Name            Type     Contents
<a name="249"/># 
<a name="250"/># 0                RecordType      char     3 (03h)
<a name="251"/># 1                RecordLength    int      Number of bytes in remainder
<a name="252"/>#                                           of this data record, see note 1
<a name="253"/>#                                           below.
<a name="254"/># 3                ApptState       char     See note 2 below.
<a name="255"/># 4                DayOfMonth      char     Day of month, 1 - 31.
<a name="256"/># 5                StartTime       swpint   Start time in minutes since midnight.
<a name="257"/># 7                StartYear       char     Start year counting from 1900.
<a name="258"/># 8                StartMonth      char     Start month, 1 - 12.
<a name="259"/># 9                StartDay        char     Start day, 1 - 31.
<a name="260"/># 10               EndTime         int      End time in minutes since midnight.
<a name="261"/># 12               EndYear         char     End year counting from 1900.
<a name="262"/># 13               EndMonth        char     End month, 1 - 12.
<a name="263"/># 14               EndDay          char     End day, 1 - 31.
<a name="264"/># 15               LeadTime        char     Alarm lead time in minutes, 0 - 30.
<a name="265"/># 16               ApptLength      char     Length of appointment text in bytes.
<a name="266"/># 17               NoteLength      int      Length of note text in bytes.
<a name="267"/># 19               ApptText        ASCII    Appointment text - see note 4 below.
<a name="268"/># 19+ApptLength    NoteText        ASCII    Note text where the null character 
<a name="269"/>#                                           is used as the line terminator -
<a name="270"/>#                                           see note 5 below.
<a name="271"/># 
<a name="272"/>record abk_monthly(alarmEnable,dayOfMonth,startTime,startYear,startMonth,
<a name="273"/>      startDay,endTime,endYear,endMonth,endDay,leadTime,apptText,noteText)
<a name="274"/>
<a name="275"/>procedure abk_write_monthly(f,data)
<a name="276"/>      writes(char((\data.alarmEnable,1) | 0),
<a name="277"/>	    char(data.dayOfMonth),
<a name="278"/>	    bk_int(data.startTime),char(data.startYear),
<a name="279"/>	    char(data.startMonth),char(data.startDay),
<a name="280"/>	    bk_int(data.endTime),char(data.endYear),
<a name="281"/>	    char(data.endMonth),char(data.endDay),
<a name="282"/>	    bk_int(data.leadTime),
<a name="283"/>	    char(*data.apptText),char(*data.noteText),data.apptText,data.noteText)
<a name="284"/>      return data
<a name="285"/>end
<a name="286"/>
<a name="287"/>procedure abk_read_monthly(f)
<a name="288"/>   local alarmEnable,dayOfMonth,startTime,startYear,startMonth,startDay,
<a name="289"/>	 endTime,endYear,endMonth,endDay,leadTime,apptLength,noteLength,
<a name="290"/>	 apptText,noteText,next_rec
<a name="291"/>   (reads(f) == "\x03" | (f.seek(f.tell() - 1),&amp;fail) &amp;
<a name="292"/>   next_rec := bk_read_int(f) + f.tell() &amp;
<a name="293"/>   alarmEnable := iand(ord(reads(f)),1) = 1 | &amp;null &amp;
<a name="294"/>   dayOfMonth := ord(reads(f)) &amp;
<a name="295"/>   startTime := bk_read_int(f) &amp;
<a name="296"/>   startYear := ord(reads(f)) &amp;
<a name="297"/>   startMonth := ord(reads(f)) &amp;
<a name="298"/>   startDay := ord(reads(f)) &amp;
<a name="299"/>   endTime := bk_read_int(f) &amp;
<a name="300"/>   endYear := ord(reads(f)) &amp;
<a name="301"/>   endMonth := ord(reads(f)) &amp;
<a name="302"/>   endDay := ord(reads(f)) &amp;
<a name="303"/>   leadTime := ord(reads(f)) &amp;
<a name="304"/>   apptLength := ord(reads(f)) &amp;
<a name="305"/>   noteLength := bk_read_int(f) &amp;
<a name="306"/>   apptText := reads(f,apptLength) &amp;
<a name="307"/>   noteText := reads(f,noteLength)) | fail
<a name="308"/>   return abk_daily(alarmEnable,dayOfMonth,startTime,startYear,startMonth,
<a name="309"/>	 startDay,endTime,endYear,endMonth,endDay,leadTime,apptText,noteText)
<a name="310"/>end
<a name="311"/>
<a name="312"/># 
<a name="313"/># HP 95LX Appointment Book Monthly by Position Data Record:
<a name="314"/># 
<a name="315"/># Byte Offset      Name            Type     Contents
<a name="316"/># 
<a name="317"/># 0                RecordType      char     4 (04h)
<a name="318"/># 1                RecordLength    int      Number of bytes in remainder
<a name="319"/>#                                           of this data record, see note 1
<a name="320"/>#                                           below.
<a name="321"/># 3                ApptState       char     See note 2 below.
<a name="322"/># 4                WeekOfMonth     char     Week of month, 1 - 5.
<a name="323"/># 5                DayOfWeek       char     Day of week, 1=Sun, ..., 7=Sat.
<a name="324"/># 6                StartTime       swpint   Start time in minutes since midnight.
<a name="325"/># 8                StartYear       char     Start year counting from 1900.
<a name="326"/># 9                StartMonth      char     Start month, 1 - 12.
<a name="327"/># 10               StartDay        char     Start day, 1 - 31.
<a name="328"/># 11               EndTime         int      End time in minutes since midnight.
<a name="329"/># 13               EndYear         char     End year counting from 1900.
<a name="330"/># 14               EndMonth        char     End month, 1 - 12.
<a name="331"/># 15               EndDay          char     End day, 1 - 31.
<a name="332"/># 16               LeadTime        char     Alarm lead time in minutes, 0 - 30.
<a name="333"/># 17               ApptLength      char     Length of appointment text in bytes.
<a name="334"/># 18               NoteLength      int      Length of note text in bytes.
<a name="335"/># 20               ApptText        ASCII    Appointment text - see note 4 below.
<a name="336"/># 20+ApptLength    NoteText        ASCII    Note text where the null character 
<a name="337"/>#                                           is used as the line terminator -
<a name="338"/>#                                           see note 5 below.
<a name="339"/># 
<a name="340"/>record abk_monthly_pos(alarmEnable,weekOfMonth,dayOfWeek,startTime,startYear,
<a name="341"/>      startMonth,startDay,endTime,endYear,endMonth,endDay,leadTime,
<a name="342"/>      apptText,noteText)
<a name="343"/>
<a name="344"/>procedure abk_write_monthly_pos(f,data)
<a name="345"/>      writes(char((\data.alarmEnable,1) | 0),
<a name="346"/>	    char(data.weekOfMonth),
<a name="347"/>	    char(data.dayOfWeek),
<a name="348"/>	    bk_int(data.startTime),char(data.startYear),
<a name="349"/>	    char(data.startMonth),char(data.startDay),
<a name="350"/>	    bk_int(data.endTime),char(data.endYear),
<a name="351"/>	    char(data.endMonth),char(data.endDay),
<a name="352"/>	    bk_int(data.leadTime),
<a name="353"/>	    char(*data.apptText),char(*data.noteText),data.apptText,data.noteText)
<a name="354"/>      return data
<a name="355"/>end
<a name="356"/>
<a name="357"/>procedure abk_read_monthly_pos(f)
<a name="358"/>   local alarmEnable,weekOfMonth,dayOfWeek,startTime,startYear,startMonth,
<a name="359"/>	 startDay,endTime,endYear,endMonth,endDay,leadTime,apptLength,noteLength,
<a name="360"/>	 apptText,noteText,next_rec
<a name="361"/>   (reads(f) == "\x04" | (f.seek(f.tell() - 1),&amp;fail) &amp;
<a name="362"/>   next_rec := bk_read_int(f) + f.tell() &amp;
<a name="363"/>   alarmEnable := iand(ord(reads(f)),1) = 1 | &amp;null &amp;
<a name="364"/>   weekOfMonth := ord(reads(f)) &amp;
<a name="365"/>   dayOfWeek := ord(reads(f)) &amp;
<a name="366"/>   startTime := bk_read_int(f) &amp;
<a name="367"/>   startYear := ord(reads(f)) &amp;
<a name="368"/>   startMonth := ord(reads(f)) &amp;
<a name="369"/>   startDay := ord(reads(f)) &amp;
<a name="370"/>   endTime := bk_read_int(f) &amp;
<a name="371"/>   endYear := ord(reads(f)) &amp;
<a name="372"/>   endMonth := ord(reads(f)) &amp;
<a name="373"/>   endDay := ord(reads(f)) &amp;
<a name="374"/>   leadTime := ord(reads(f)) &amp;
<a name="375"/>   apptLength := ord(reads(f)) &amp;
<a name="376"/>   noteLength := bk_read_int(f) &amp;
<a name="377"/>   apptText := reads(f,apptLength) &amp;
<a name="378"/>   noteText := reads(f,noteLength)) | fail
<a name="379"/>   return abk_daily(alarmEnable,weekOfMonth,dayOfWeek,startTime,startYear,
<a name="380"/>	 startMonth,startDay,endTime,endYear,endMonth,endDay,leadTime,apptText,
<a name="381"/>	 noteText)
<a name="382"/>end
<a name="383"/>
<a name="384"/># 
<a name="385"/># HP 95LX Appointment Book Yearly Data Record:
<a name="386"/># 
<a name="387"/># Byte Offset      Name            Type     Contents
<a name="388"/># 
<a name="389"/># 0                RecordType      char     5 (05h) 
<a name="390"/># 1                RecordLength    int      Number of bytes in remainder
<a name="391"/>#                                           of this data record, see note 1
<a name="392"/>#                                           below.
<a name="393"/># 3                ApptState       char     See note 2 below.
<a name="394"/># 4                MonthOfYear     char     Month of year, 1=Jan, ... 12=Dec.
<a name="395"/># 5                DayOfMonth      char     Day of month, 1 - 31.
<a name="396"/># 6                StartTime       swpint   Start time in minutes since midnight.
<a name="397"/># 8                StartYear       char     Start year counting from 1900.
<a name="398"/># 9                StartMonth      char     Start month, 1 - 12.
<a name="399"/># 10               StartDay        char     Start day, 1 - 31.
<a name="400"/># 11               EndTime         int      End time in minutes since midnight.
<a name="401"/># 13               EndYear         char     End year counting from 1900.
<a name="402"/># 14               EndMonth        char     End month, 1 - 12.
<a name="403"/># 15               EndDay          char     End day, 1 - 31.
<a name="404"/># 16               LeadTime        char     Alarm lead time in minutes, 0 - 30.
<a name="405"/># 17               ApptLength      char     Length of appointment text in bytes.
<a name="406"/># 18               NoteLength      int      Length of note text in bytes.
<a name="407"/># 20               ApptText        ASCII    Appointment text - see note 4 below.
<a name="408"/># 20+ApptLength    NoteText        ASCII    Note text where the null character 
<a name="409"/>#                                           is used as the line terminator -
<a name="410"/>#                                           see note 5 below.
<a name="411"/># 
<a name="412"/>record abk_yearly(alarmEnable,monthOfYear,dayOfMonth,startTime,startYear,
<a name="413"/>      startMonth,startDay,endTime,endYear,endMonth,endDay,leadTime,
<a name="414"/>      apptText,noteText)
<a name="415"/>
<a name="416"/>procedure abk_write_yearly(f,data)
<a name="417"/>      writes(char((\data.alarmEnable,1) | 0),
<a name="418"/>	    char(data.monthOfYear),
<a name="419"/>	    char(data.dayOfMonth),
<a name="420"/>	    bk_int(data.startTime),char(data.startYear),
<a name="421"/>	    char(data.startMonth),char(data.startDay),
<a name="422"/>	    bk_int(data.endTime),char(data.endYear),
<a name="423"/>	    char(data.endMonth),char(data.endDay),
<a name="424"/>	    bk_int(data.leadTime),
<a name="425"/>	    char(*data.apptText),char(*data.noteText),data.apptText,data.noteText)
<a name="426"/>      return data
<a name="427"/>end
<a name="428"/>
<a name="429"/>procedure abk_read_yearly(f)
<a name="430"/>   local alarmEnable,monthOfYear,dayOfMonth,startTime,startYear,startMonth,
<a name="431"/>	 startDay,endTime,endYear,endMonth,endDay,leadTime,apptLength,noteLength,
<a name="432"/>	 apptText,noteText,next_rec
<a name="433"/>   (reads(f) == "\x05" | (f.seek(f.tell() - 1),&amp;fail) &amp;
<a name="434"/>   next_rec := bk_read_int(f) + f.tell() &amp;
<a name="435"/>   alarmEnable := iand(ord(reads(f)),1) = 1 | &amp;null &amp;
<a name="436"/>   monthOfYear := ord(reads(f)) &amp;
<a name="437"/>   dayOfMonth := ord(reads(f)) &amp;
<a name="438"/>   startTime := bk_read_int(f) &amp;
<a name="439"/>   startYear := ord(reads(f)) &amp;
<a name="440"/>   startMonth := ord(reads(f)) &amp;
<a name="441"/>   startDay := ord(reads(f)) &amp;
<a name="442"/>   endTime := bk_read_int(f) &amp;
<a name="443"/>   endYear := ord(reads(f)) &amp;
<a name="444"/>   endMonth := ord(reads(f)) &amp;
<a name="445"/>   endDay := ord(reads(f)) &amp;
<a name="446"/>   leadTime := ord(reads(f)) &amp;
<a name="447"/>   apptLength := ord(reads(f)) &amp;
<a name="448"/>   noteLength := bk_read_int(f) &amp;
<a name="449"/>   apptText := reads(f,apptLength) &amp;
<a name="450"/>   noteText := reads(f,noteLength)) | fail
<a name="451"/>   return abk_daily(alarmEnable,monthOfYear,dayOfMonth,startTime,startYear,
<a name="452"/>	 startMonth,startDay,endTime,endYear,endMonth,endDay,leadTime,apptText,
<a name="453"/>	 noteText)
<a name="454"/>end
<a name="455"/>
<a name="456"/>#
<a name="457"/># HP 95LX Appointment Book To Do Data Record:
<a name="458"/># 
<a name="459"/># Byte Offset      Name            Type     Contents
<a name="460"/># 
<a name="461"/># 0                RecordType      char     6 (06h)
<a name="462"/># 1                RecordLength    int      Number of bytes in remainder
<a name="463"/>#                                           of this data record, see note 1
<a name="464"/>#                                           below.
<a name="465"/># 3                ToDoState       char     See note 3 below.
<a name="466"/># 4                Priority        char     Priority, 1 - 9.
<a name="467"/># 5                StartYear       char     Start year counting from 1900.
<a name="468"/># 6                StartMonth      char     Start month, 1 - 12.
<a name="469"/># 7                StartDay        char     Start day, 1 - 31.
<a name="470"/># 8                CheckOffYear    char     Check off year counting from 1900,
<a name="471"/>#                                           0 indicates not checked off.
<a name="472"/># 9                CheckOffMonth   char     Check off month, 1 - 12,
<a name="473"/>#                                           0 indicates not checked off.
<a name="474"/># 10               CheckOffDay     char     Check off day, 1 - 31,
<a name="475"/>#                                           0 indicates not checked off.
<a name="476"/># 11               ToDoLength      char     Length of to do text in bytes.
<a name="477"/># 12               NoteLength      int      Length of note text in bytes.
<a name="478"/># 14               ToDoText        ASCII    To do text - see note 4 below.
<a name="479"/># 14+ToDoLength    NoteText        ASCII    Note text where the null character 
<a name="480"/>#                                           is used as the line terminator -
<a name="481"/>#                                           see note 5 below.
<a name="482"/># 
<a name="483"/>record abk_todo(carryForward,checkOff,priority,startYear,startMonth,
<a name="484"/>      startDay,CheckOffYear,CheckOffMonth,CheckOffDay,toDoText,toDoNote)
<a name="485"/>
<a name="486"/>procedure abk_write_todo(f,data)
<a name="487"/>      writes(char(ior((\data.carryForward,1) | 0,(\data.checkOff,2) | 0)),
<a name="488"/>	    char(data.priority),
<a name="489"/>	    char(data.startYear),
<a name="490"/>	    char(data.startMonth),char(data.startDay),
<a name="491"/>	    char(data.checkOffYear),
<a name="492"/>	    char(data.checkOffMonth),char(data.checkOffDay),
<a name="493"/>	    char(*data.toDoText),char(*data.noteText),data.toDoText,data.noteText)
<a name="494"/>      return data
<a name="495"/>end
<a name="496"/>
<a name="497"/>procedure abk_read_todo(f)
<a name="498"/>   local carryForward,checkOff,priority,startYear,startMonth,
<a name="499"/>	 startDay,CheckOffYear,CheckOffMonth,CheckOffDay,toDoLength,noteLength,
<a name="500"/>	 toDoText,toDoNote,toDoState,next_rec
<a name="501"/>   (reads(f) == "\x06" | (f.seek(f.tell() - 1),&amp;fail) &amp;
<a name="502"/>   next_rec := bk_read_int(f) + f.tell() &amp;
<a name="503"/>   toDoState := ord(reads(f)) &amp;
<a name="504"/>   carryForward := iand(toDoState,1) = 1 | &amp;null &amp;
<a name="505"/>   checkOff := iand(toDoState,2) = 1 | &amp;null &amp;
<a name="506"/>   priority := ord(reads(f)) &amp;
<a name="507"/>   startYear := ord(reads(f)) &amp;
<a name="508"/>   startMonth := ord(reads(f)) &amp;
<a name="509"/>   startDay := ord(reads(f)) &amp;
<a name="510"/>   CheckOffYear := ord(reads(f)) &amp;
<a name="511"/>   CheckOffMonth := ord(reads(f)) &amp;
<a name="512"/>   CheckOffDay := ord(reads(f)) &amp;
<a name="513"/>   toDoLength := ord(reads(f)) &amp;
<a name="514"/>   noteLength := bk_read_int(f) &amp;
<a name="515"/>   toDoText := reads(f,toDoLength) &amp;
<a name="516"/>   toDoNote := reads(f,noteLength)) | fail
<a name="517"/>   return abk_daily(carryForward,checkOff,priority,startYear,startMonth,
<a name="518"/>	 startDay,CheckOffYear,CheckOffMonth,CheckOffDay,toDoText,toDoNote)
<a name="519"/>end
<a name="520"/>
<a name="521"/># 
<a name="522"/># HP 95LX Appointment Book End of File Record:
<a name="523"/># 
<a name="524"/># Byte Offset      Name            Type     Contents
<a name="525"/># 
<a name="526"/># 0                RecordType      char     50 (32h)
<a name="527"/># 1                RecordLength    int      0 (00h, 00h)
<a name="528"/>#
<a name="529"/>procedure abk_write_end(f)
<a name="530"/>   writes(f,"\x32\x00\x00")
<a name="531"/>   return
<a name="532"/>end
<a name="533"/>
<a name="534"/>procedure abk_read_end(f,id)
<a name="535"/>   (reads(f) == "\x32" &amp; reads(f,2)) | fail
<a name="536"/>   return
<a name="537"/>end
</pre></body></html>
