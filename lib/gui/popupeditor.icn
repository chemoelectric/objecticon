package gui

import graphics, ipl.pdco

#
# A class for wrapping a transient popup editor.
#
class PopupEditor(Component, MenuMode)
   private old_focus, editor, comp

   public popup(comp, ev)
      self.comp := comp
      # Copy attribs of the parent component
      set_all_wattribs(comp.get_effective_wattribs())
      set_z(comp.parent_dialog.get_top_z())
      comp.parent_dialog.add(self)
      resize()
      old_focus := parent_dialog.focus
      parent_dialog.set_focus(editor.find_focus())
      parent_dialog.enter_menu_mode(self)
      invalidate()
      return self
   end

   public layout()
      editor.x := self.x
      editor.y := self.y
      editor.w := self.w
      editor.h := self.h
      editor.layout()
   end

   public should_close(e)
      if member(Mouse.PRESS, e.code) & not(editor.in_region(e)) then 
         return
   end

   public allow_nested(c)
   end

   public get_nesting_component()
      return comp
   end

   public gen_popup_components()
      return editor
   end

   protected forward_key(ev, src, type)
      # In menu mode key events are forwarded to this component,
      # rather than the editor, regardless of the focus.  So we
      # must forward them ourselves.
      if /ev.release & ev.code === "\e" then
         close_all()
      else
         (\editor.parent_dialog.focus).fire(type, ev)
   end

   public close_all()
      if \parent_dialog.focus === Seq{traverse_postorder()} then
         parent_dialog.set_focus(old_focus)
      invalidate()
      parent_dialog.exit_menu_mode(self)
      parent.remove(self)
   end

   public dialog_event(e)
      # Close on escape being pressed.
      if /e.release & (e.code === "\e") then 
         close_all()
   end

   public new(editor)
      Component.new()
      self.editor := editor
      editor.connect(close_all, Event.ACTION)
      self.add(editor)
      set_inherit_wattribs(&no)
      every connect(self.forward_key, Event.KEY_PRESS | Event.KEY_RELEASE)
      return
   end
end
