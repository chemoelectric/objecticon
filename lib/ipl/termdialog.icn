package ipl.termdialog

import
   gui, io, graphics, util, undo

class TermTextField(CompleteField)
   protected do_request()
      return (\parent.complete_function)(contents, cursor)
   end
end

class TermEditableTextList(EditableTextList)
   private on_word_wrap(ev, src)
      set_wrap_mode(if src.is_checked() then "width" else "off")
   end

   public create_context_menu(e)
      local m
      m := TextContextMenu(self)
      m.add(MenuSeparator()).
         add(CheckBoxMenuItem().
             set_label("Word wrap").
             set_is_checked(Yes{ wrap_mode === "width" }).
             connect(on_word_wrap, Event.ACTION)).
         add(TextMenuItem().
               set_label("Clear").
               connect(create parent_dialog.clear_text(), Event.ACTION)).
         add(TextMenuItem().
             set_label("Quit").
             set_label_right("^Q").
             connect(create parent_dialog.dispose(), Event.ACTION))
      return m.tidy()
   end
end

package record Save(text, undo)

class TermDialog(Dialog, LineBasedOutputStream)
   private
      input,
      log_limit,
      history_limit,
      history,
      history_start_no,
      hpos,
      hmod,
      text
   private readable
      complete_function,
      line

   public close()
      return self
   end

   # Clear the log area.
   #
   public clear_text()
      text.set_contents([u""])
      return self
   end

   protected write_line_impl(s)
      text.log([ucs(s)], log_limit)
      return
   end

   # Set the limit in lines for the text area log.
   #
   public set_log_limit(n)
      self.log_limit := n
      return self
   end

   # Set a function to generate completions when the tab key is
   # pressed.  The function is given subject and cursor position, and
   # should return a list of `gui.CompleteElement` instances.
   #
   public set_complete_function(f)
      self.complete_function := f
      return self
   end

   # Set the limit in lines for the command history.
   #
   public set_history_limit(n)
      self.history_limit := n
      limit_history()
      reset_term()
      return self
   end

   # Set the history list.
   #
   public set_history(l)
      self.history := l
      self.history_start_no := 1
      limit_history()
      reset_term()
      return self
   end

   # Return the history list.
   #
   public get_history()
      return .history
   end

   # Return the given history number line.
   #
   public get_history_item(n)
      return .history[0 < n - history_start_no + 1]
   end

   # Get the history number of the first entry in the history.
   #
   public get_history_start_no()
      return .history_start_no
   end

   private goto_hist(n)
      local d
      (1 <= n <= *history + 1) | fail
      if input.undo_manager.get_last() then {
         insert(hmod, hpos, Save(input.get_contents(), input.undo_manager))
         # Set a new instance since set_contents will clear the manager
         input.set_undo_manager(UndoManager())
      }
      hpos := n
      if d := member(hmod, hpos) then {
         input.
            set_contents(d.text).
            set_undo_manager(d.undo)
      } else
         input.set_contents(history[hpos] | u"")
   end

   private get_mod_hist(n)
      return member(hmod, n).text | history[n]
   end

   private move_hist(n)
      goto_hist(hpos + n)
   end

   private limit_history()
      while *history > \history_limit do {
         pop(history)
         history_start_no +:= 1
      }
   end

   public component_setup()
      reset_term()
   end

   public end_dialog()
   end

   public init_dialog()
   end

   public get_term_width()
      return (text.predict_view_width(text.w, &yes) - 2 * Gui.TEXT_INSET) / text.cbwin.text_width("m")
   end

   public new()
      Dialog.new()
      LineBasedOutputStream.new()
      hmod := table()
      history := []
      history_start_no := 1
      log_limit := 600
      self.setup()
      return
   end

   private reset_term()
      hpos := *history + 1
      clear(hmod)
      input.set_contents(u"")
   end

   private on_input(ev)
      line := input.get_contents()
      if *line > 0 then {
         put(history, line)
         limit_history()
      }
      reset_term()
      fire(Event.ACTION, ev)
   end
   
   private handle_key_up()
      move_hist(-1)
   end

   private handle_key_down()
      move_hist(1)
   end

   private handle_history_recall()
      goto_hist(integer(input.get_contents()) - history_start_no + 1)
   end

   private handle_history_search(dir)
      local i, s, c, curr
      c := input.cursor
      curr := input.get_contents()
      s := curr[1:c]
      every i := if dir > 0 then (hpos + 1 to *history) | (1 to hpos - 1)
                            else (hpos - 1 to 1 by -1) | (*history to hpos + 1 by -1) do {
         if match(s, curr ~== get_mod_hist(i)) then {
            goto_hist(i)
            input.set_cursor(c)
            return
         }
      }
   end

   private on_input_key(ev)
      case ev.code of {
         Key.UP : handle_key_up()
         Key.DOWN : handle_key_down()
         "\^p": handle_history_recall()
         "\^r": handle_history_search(-1)
         "\^t": handle_history_search(1)
         "\^g": reset_term()
      }
   end

   private on_close_button(ev)
      dispose()
   end

   private on_icon_event(ev)
      if ev.code === "\^q" then 
         dispose()
   end

   private setup()
      local layout_1
      self.set_resize(&yes)
      self.set_size(scale(735), scale(510))
      text := TermEditableTextList().
         set_size(scale(465), scale(256)).
         set_font("fixed").
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("y_fill", &yes).
         set_constraint("y_weight", 1.0).
         set_contents([u""]).
         set_is_editable(&no)
      self.add(text)
      input := TermTextField().
         set_size(scale(458)).
         clear_constraints().
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         connect(self.on_input, Event.ACTION).
         connect(self.on_input_key, Event.KEY_PRESS).
         set_contents(u"")
      self.add(input)
      self.connect(self.on_close_button, Event.WINDOW_CLOSE_BUTTON)
      self.connect(self.on_icon_event, Event.ICON)
      layout_1 := GridLayout().
         set_extra("cells")
      self.set_layout(layout_1)
      self.set_focus(input.find_focus())
   end
end

### Ivib-v2 layout: layouts/$.layout
