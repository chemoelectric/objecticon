<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>inbits.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     inbits.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedure to read variable-length characters
<a name="6"/>#
<a name="7"/>#	Author:   Richard L. Goerwitz
<a name="8"/>#
<a name="9"/>#	Date:     November 3, 1991
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#	Version:  1.2
<a name="18"/>#
<a name="19"/>############################################################################
<a name="20"/>#  
<a name="21"/>#  This procedure, inbits(), re-imports data converted into writable
<a name="22"/>#  form by outbits().  See the file outbits.icn for all the whys and
<a name="23"/>#  hows.
<a name="24"/>#
<a name="25"/>############################################################################
<a name="26"/>#
<a name="27"/>#  See also: outbits.icn
<a name="28"/>#
<a name="29"/>############################################################################
<a name="30"/>
<a name="31"/>package ipl.inbits
<a name="32"/>
<a name="33"/>import
<a name="34"/>   io(reads)
<a name="35"/>
<a name="36"/>procedure inbits(f, len)
<a name="37"/>
<a name="38"/>    local i, byte, old_byte_mask
<a name="39"/>    static old_byte, old_len, byte_length
<a name="40"/>    initial {
<a name="41"/>	old_byte := old_len := 0
<a name="42"/>	byte_length := 8
<a name="43"/>    }
<a name="44"/>
<a name="45"/>    old_byte_mask := (0 &lt; 2^old_len - 1) | 0
<a name="46"/>    old_byte := iand(old_byte, old_byte_mask)
<a name="47"/>    i := ishift(old_byte, len-old_len)
<a name="48"/>
<a name="49"/>    unless len -:= (len &gt; old_len) then {
<a name="50"/>	old_len -:= len
<a name="51"/>	return i
<a name="52"/>    }
<a name="53"/>    
<a name="54"/>    while byte := ord(reads(f)) do {
<a name="55"/>	i := ior(i, ishift(byte, len-byte_length))
<a name="56"/>	unless len -:= (len &gt; byte_length) then {
<a name="57"/>	    old_len := byte_length-len
<a name="58"/>	    old_byte := byte
<a name="59"/>	    return i
<a name="60"/>	}
<a name="61"/>    }
<a name="62"/>
<a name="63"/>end
</pre></body></html>
