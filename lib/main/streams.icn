package io

import
   util(error, check_flag, save_why),
   lang(NoCopy,Prog),
$ifdef _PLAN9
   posix(System)
$else
   posix(ExitInfo, System),
   ipl.strings(replace)
$endif
#
# This is the top-level stream class.  It is not instantiated
# directly.
#
class Stream()
   public static const
      # Constant indicating read capability
      READ,
      # Constant indicating write capability
      WRITE,
      # Constant indicating seek (and tell) capability
      SEEK,
      # Constant indicating truncate capability
      TRUNCATE,
      # Constant indicating read and write capability
      READ_WRITE,
      # Constant representing all capabilities (read, write, seek and
      # truncate).
      ALL

   private static init()
      READ := 8r01
      WRITE := 8r02
      SEEK := 8r04
      TRUNCATE := 8r010
      READ_WRITE := READ + WRITE
      ALL := READ + WRITE + SEEK + TRUNCATE
   end

   #
   # Return at least one, and up to n characters from the stream.  On
   # end-of-file, return {&null}.  On error, fail and set {&why}.
   #
   # @param n the maximum number of chars to read; n must be > 0.
   #
   public defer in(n)

   #
   # Output the given string to the stream.  The number of characters
   # output is returned, which will always be greater than zero, but may
   # be less than {*s}.  Fails on an error, setting {&why}.
   #
   # @param s the string to write
   #
   public defer out(s)

   #
   # Seek to the given offset.  Icon-style offsets are used, so 1 is
   # the beginning of the stream, and 0 the end.  Not all types of stream
   # support {seek} - see {get_mode}.
   #
   # @param offset the position to seek to
   # @return the new position.
   #
   public defer seek(offset)

   #
   # Return the current position of the stream.
   #
   public defer tell()

   #
   # Truncate this stream to the given length, and set the position to the
   # new end of the stream (ie, len + 1).
   #
   public defer truncate(len)

   #
   # Return an integer indicating which functions the stream supports.
   # The possible bits which can be set are listed as constants above.
   # If the integer has the {READ} bit set, the stream is readable;
   # {WRITE} indicates the stream is writable, {SEEK} indicates that
   # it is seekable (and supports {tell} too), and {TRUNCATE} that it
   # is truncatable.
   #
   public defer get_mode()

   #
   # Close the stream.  After being closed, any further calls on the
   # stream may stop with a runtime error.
   #
   public defer close()

   #
   # Succeed iff the stream's mode has all the flags in {c}
   #
   public can(c)
      return iand(get_mode(), c) = c
   end

   #
   # Output the string {s}, by calling {out} several times until it is
   # fully output.
   #
   public fully_out(s)
      local n
      s := string(s) | runerr(103, s)
      while *s > 0 do {
         n := out(s) | fail
         s := s[n + 1:0]
      }
      return
   end

   #
   # Read a complete line from the stream, reading up to the next "\n"
   # or end-of-file.  In the former case, the "\n" and also any "\r"
   # immediately before it is stripped from the result.
   #
   # Returns {&null} on end-of-file
   #
   public read_line()
      local s, c
      s := ""
      repeat {
         c := in(1) | fail
         if /c then {
            if *s > 0 then
               return s
            else
               return
         }
         if c == "\n" then {
            if s[-1] == "\r" then
               s[-1] := ""
            return s
         } else
            s ||:= c
      }
   end

   #
   # Read {n} chars from the stream.  This method will try and return
   # exactly {n} characters, and will only return less because of
   # reaching the end-of-file.
   #
   # Returns {&null} on end-of-file
   #
   public read_exactly(n)
      local s, t
      s := ""
      while n > 0 do {
         t := in(n) | fail
         if /t then {
            if *s > 0 then
               return s
            else
               return
         }
         s ||:= t
         n -:= *t
      }
      return s
   end

   #
   # Generate all the remaining lines in the file
   #
   public gen()
      suspend |\read_line()
   end

   #
   # This method is the same as {read_line}, except that on end of
   # file it fails, setting {&why} to "End of file", rather than
   # returning {&null}.
   #
   public read()
      local s
      s := read_line() | fail
      return \s | error("End of file")
   end

   #
   # This method is the same as {read_exactly}, except that on end of
   # file it fails, setting {&why} to "End of file", rather than
   # returning {&null}.
   #
   public reads(n)
      local s
      s := read_exactly(n) | fail
      return \s | error("End of file")
   end

   #
   # This writes each parameter to the stream.  Each parameter is
   # guaranteed to be completely output, except on error, in which
   # case the method fails and sets &why.
   #
   public writes(a[])
      local e
      every e := !a do
         fully_out(e) | fail
      return
   end

   #
   # This behaves just like {writes}, except that a newline is
   # appended after all the parameters are output.
   #
   public write(a[])
      local e
      every e := !a | Files.EOL do
         fully_out(e) | fail
      return
   end

   #
   # Read from this stream until end-of-file, collecting the result as
   # a string.
   #
   public read_all()
      local s, t
      s := ""
      repeat {
         t := in(1048576) | fail
         if /t then
            return s
         s ||:= t
      }
   end

   #
   # Read from this stream until end-of-file, copying the result to the
   # given stream {f}.
   #
   public copy_to(f)
      local s
      repeat {
         s := in(1048576) | fail
         if /s then
            return
         f.writes(s) | fail
      }
   end
end

#
# This class simply adds the close_underlying_flag to a {Stream}.
#
class HasUnderlyingStream()
   protected
      close_underlying_flag

   #
   # If set, the stream will close any underlying {Stream}s when it is closed.
   #
   public set_close_underlying(s)
      self.close_underlying_flag := check_flag(s)
      return self
   end
end

#
# This is a stream based on an Icon string.  An initial string can be
# provided to the constructor.  Reading from the stream will be quite
# efficient, but writing will be relatively slow, particularly if the
# string is long.  For a much faster alternative, see {RamStream}.
#
class StringStream(Stream)
   private 
      subj,
      pos

   public in(n)
      local t, e
      if pos > *subj then
         return
      e := min(pos + n, *subj + 1)
      t := subj[pos:e]
      pos := e
      return t
   end

   public out(s)
      local e
      s := string(s) | runerr(103, s)
      if pos > *subj then {
         subj ||:= repl("\0", pos - *subj - 1) || s
         pos := *subj + 1
      } else {
         e := min(pos + *s, *subj + 1)
         subj[pos:e] := s
         pos +:= *s
      }
      return *s
   end

   public seek(offset)
      return .if offset > 0 then
         pos := offset
      else if -offset <= *subj then
         pos := *subj + 1 + offset
      else
         error("Seek out of range")
   end

   public tell()
      return .pos
   end

   public close()
      return
   end

   public get_mode()
      return ALL
   end

   public truncate(len)
      if len > *subj then
         subj ||:= repl("\0", len - *subj)
      else
         subj := subj[1:len + 1]
      pos := *subj + 1
      return
   end

   public str()
      return .subj
   end

   #
   # Create a new {StringStream}, with initial value of {subj}.
   #
   # @param subj the initial value of the stream; defaults to empty 
   # @      string.
   #
   public new(subj)
      /subj := ""
      self.subj := string(subj) | runerr(103, subj)
      self.pos := 1
      return
   end
end

#
# This is a stream that mimics /dev/null.  Writes always succeed with
# no effect, and reads always fail with end of file.
#
class NullStream(Stream)
   public in(n)
      return
   end

   public out(s)
      s := string(s) | runerr(103, s)
      return *s
   end

   public seek(offset)
      return 1
   end

   public tell()
      return 1
   end

   public close()
      return
   end

   public get_mode()
      return ALL
   end

   public truncate(len)
      return
   end
end

#
# This is a stream that mimics /dev/zero.  Writes always succeed with
# no effect, and reads return however many zero bytes were requested.
#
class ZeroStream(Stream)
   public in(n)
      return repl("\0", n)
   end

   public out(s)
      s := string(s) | runerr(103, s)
      return *s
   end

   public seek(offset)
      return 1
   end

   public tell()
      return 1
   end

   public close()
      return
   end

   public get_mode()
      return ALL
   end

   public truncate(len)
      return
   end
end

#
# This class takes another stream and provides read/write buffers so
# that input/output to the inner stream tends to take place in larger
# chunks.
#
class BufferStream(Stream, HasUnderlyingStream)
   private
      other,
      rpos,
      wbuff,
      wbuff_len,
      rbuff,
      flush_on_nl_flag,
      buff_size

   #
   # If set, the stream is flushed whenever a newline is written.
   #
   public set_flush_on_nl(s)
      self.flush_on_nl_flag := check_flag(s)
      return self
   end

   #
   # Set the buffer size to use.
   #
   public set_buff_size(n)
      self.buff_size := n
      return self
   end

   #
   # Push the string s onto the read buffer, so that it is read next.
   #
   public push(s)
      s := string(s) | runerr(103, s)
      unbuff() | fail
      rbuff := s || rbuff
      return
   end

   #
   # Push the string s followed by an end-of-line.
   #
   public push_line(s)
      return push(s || Files.EOL)
   end

   public read_line()
      local t
      flush() | fail
      repeat {
         rbuff ? {
            if t := tab(upto('\n')) then {
               move(1)
               rbuff := tab(0)
               \rpos +:= *t + 1
               if t[-1] == "\r" then
                  t[-1] := ""
               return t
            }
         }
         if *rbuff = 0 & other.can(SEEK) then
            rpos := other.tell() | fail
         t := other.in(buff_size) | fail
         if /t then {
            rpos := &null
            if *rbuff = 0 then
               return
            t := rbuff
            rbuff := ""
            return t
         }
         rbuff ||:= t
      }
   end

   public in(n)
      local t
      flush() | fail
      if *rbuff > 0 then {
         rbuff ? {
            t := move(n) | tab(0)
            rbuff := tab(0)
            \rpos +:= *t
         }
      } else if n < buff_size then {
         if other.can(SEEK) then
            rpos := other.tell() | fail
         t := other.in(buff_size) | fail
         if /t then
            return
         t ? {
            t := move(n) | tab(0)
            rbuff := tab(0)
            \rpos +:= *t
         }
      } else {
         t := other.in(n) | fail
         if /t then
            return
      }
      return t
   end

   public out(s)
      s := string(s) | runerr(103, s)
      unbuff() | fail
      put(wbuff, s)
      wbuff_len +:= *s
      if wbuff_len > buff_size | (\flush_on_nl_flag & upto('\n', s)) then
         flush() | fail
      return *s
   end

   #
   # Flush the write buffer.
   #
   public flush()
      local s
      \wbuff | runerr(219, self)
      if *wbuff = 0 then
         return
      s := ""
      every s ||:= !wbuff
      wbuff := []
      wbuff_len := 0
      return other.fully_out(s)
   end

   #
   # Un-buffer the read buffer.  For a seekable stream this involves
   # discarding the read buffer and seeking to the position
   # corresponding to the start of the buffer.  For a non-seekable
   # stream, this call has no effect.
   #
   public unbuff()
      \rbuff | runerr(219, self)
      if *rbuff > 0 & \rpos & other.can(SEEK) then {
         other.seek(rpos) | fail
         rbuff := ""
         rpos := &null
      }
      return
   end

   #
   # Calls {unbuff} and {flush}
   #
   public synch()
      unbuff() | fail
      flush() | fail
      return
   end

   public close()
      local f
      flush() | (f := 1)
      if \close_underlying_flag then
         other.close() | (f := 1)
      rbuff := wbuff := &null
      return /f
   end

   public seek(offset)
      synch() | fail
      return other.seek(offset)
   end

   public tell()
      synch() | fail
      return other.tell()
   end

   public truncate(len)
      synch() | fail
      return other.truncate(len)
   end

   public get_mode()
      return other.get_mode()
   end

   public new(other)
      self.other := other
      self.rbuff := ""
      self.wbuff := []
      self.wbuff_len := 0
      self.buff_size := 1024
      self.close_underlying_flag := &yes
      return
   end
end

#
# This is the parent class of streams based on a posix-style
# integer-based file descriptor.
#
class DescStream(Stream, NoCopy)
   protected 
      fd,
      mode

   #
   # Return the integer file descriptor.
   #
   public get_fd()
      return .fd
   end

   public get_mode()
      return .mode
   end

   #
   # Performs a select on the given lists of streams, each of which
   # must be a {DescStream}.  The lists are changed by the method,
   # and the modified lists indicate which streams are ready to read,
   # write or have an error.
   # 
   # On an error this method fails and sets {&why}.  On a timeout it
   # returns 0, with all lists empty.
   #
   # @param rl the read list of streams
   # @param wl the write list of streams
   # @param el the error list of streams
   # @param timeout the timeout; if omitted waits indefinitely
   # @return the number of items in the three lists, always >= 0.
   #
   public static defer select(rl, wl, el, timeout)

   #
   # Performs a poll on one or more streams, each of which must be a
   # {DescStream}.  The parameter {l} is a list of pairs.  Each pair
   # is a {Stream} followed by flags, which should be selected from
   # those constants in the {Poll} class.  The last argument is the
   # optional timeout. The result is a list of the flags corresponding
   # to each {Stream} provided.  This method fails on error, setting
   # {&why} accordingly.  On a timeout, it succeeds and returns
   # {&null}.
   #
$ifdef _PLAN9
   public static poll(l, timeout)
      local loop_until, f, ev, r, done, i, res, snooze
      if *l % 2 ~= 0 then
         runerr(130)
      r := list(*l / 2)
      loop_until := Prog.get_runtime_millis() + \timeout
      snooze := 1
      repeat {
         clear(r)
         every i := 1 to *l by 2 do {
            f := l[i]
            ev := l[i + 1]
            is(f, Pollable) | runerr(205, f)
            res := f.get_poll(ev)
            put(r, res)
            if res ~= 0 then
               done := 1
         }
         if \done then
            return r

         if \loop_until <= Prog.get_runtime_millis() then
            return

         delay(snooze)
         snooze := min(snooze + 5, 100)
      }
   end
$else
   public static defer poll(l, timeout)
$endif

   #
   # Turn the specified flags on or off, and return the new set of
   # flags.  The flags should be selected from the constants in
   # {FileOpt}.
   # @param on the flags to turn on
   # @param off the flags to turn off
   # @return the new flags
   #
   public defer flag(on, off)

   #
   # Turn the specified descriptor flags on or off, and return the new
   # set of flags.  The flags should be selected from the constants in
   # {DescOpt}.
   # @param on the flags to turn on
   # @param off the flags to turn off
   # @return the new flags
   #
   public defer dflag(on, off)

   #
   # Invokes the system function dup2(oldfd, newfd), with oldfd set to
   # this instance's {fd}, and newfd set to the given parameter's {fd}.
   #
   # On error this method fails and sets {&why}.  On success, it sets
   # the mode of the target to this instances's mode (since they both
   # now point to the same file), and returns {&null}.
   #
   # @param other - a {DescStream}
   # @example
   # @ f := FileStream.open("/tmp/xyz", 
   # @     ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT)) | stop(&why)
   # @ f.dup2(FileStream.stdout) | stop(&why)
   # @ f.close()
   # @ write("hello world")  # writes to /tmp/xyz
   #
   public dup2(other)
      dup2_impl(other) | fail
      other.mode := self.mode
      return
   end

   private defer dup2_impl()

   #
   # Return a {Stat} object with info about this file.
   #
   public stat()
      return Stat!stat_impl()
   end

   private defer stat_impl()

$ifdef _PLAN9
   #
   # Write selected attributes about a file.  If any of the parameters
   # are {&null}, they are left unchanged.
   #
   # @param mode the mode (an integer)
   # @param uid the owner name
   # @param gid the group name
   # @param atime the access time (an integer)
   # @param mtime the modification time (an integer)
   # @param length the file length
   # @param name the file name
   #
   public defer wstat(mode, uid, gid, atime, mtime, length, name)

   #
   # Return the length of the file
   #
   public defer length()
$else
   #
   # Write selected attributes about a file.  If any of the parameters
   # are {&null}, they are left unchanged.
   #
   # @param mode the mode (an integer)
   # @param uid the owner name
   # @param gid the group name
   #
   public defer wstat(mode, uid, gid)
$endif

   protected new(fd, mode)
      self.fd := fd
      self.mode := mode
      return
   end
end

#
# This procedure emulates the old Icon builtin function of the same
# name.  It always returns a {BufferStream} or fails and sets {&why}.
# 
# @param name The file name
# @param mode The mode; possible values are :-
# @    "r" - {FileStream.open} with {FileOpt.RDONLY}
# @    "w" - {FileStream.open} with {FileOpt.WRONLY}, {FileOpt.TRUNC}, {FileOpt.CREAT}
# @    "b"|"rw"|"r+" - {FileStream.open} with {FileOpt.RDWR}
# @    "crw"|"w+" - {FileStream.open} with {FileOpt.RDWR}, {FileOpt.TRUNC}, {FileOpt.CREAT}
# @    "a" - {FileStream.open} with {FileOpt.WRONLY}, {FileOpt.APPEND}, {FileOpt.CREAT}
# @    "a+" - {FileStream.open} with {FileOpt.RDWR}, {FileOpt.APPEND}, {FileOpt.CREAT}
# @    "p"|"pr" - {ProgInputStream}, using shell interpreter
# @    "pw" - {ProgOutputStream}, using shell interpreter
#
procedure open(name, mode)
   return BufferStream(case mode of {
      &null | "r" : FileStream.open(name, FileOpt.RDONLY)
      "w" : FileStream.open(name, ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT))
      "b"|"rw"|"r+" : FileStream.open(name, FileOpt.RDWR)
      "crw"|"w+" : FileStream.open(name, ior(FileOpt.RDWR, FileOpt.TRUNC, FileOpt.CREAT))
      "a" : FileStream.open(name, ior(FileOpt.WRONLY, FileOpt.APPEND, FileOpt.CREAT))
      "a+" : FileStream.open(name, ior(FileOpt.RDWR, FileOpt.APPEND, FileOpt.CREAT))
$ifdef _UNIX
      "p"|"pr" : ProgInputStream("/bin/sh", ["-c", name])
      "pw" : ProgOutputStream("/bin/sh", ["-c", name])
$elsifdef _PLAN9
      "p"|"pr" : ProgInputStream("/bin/rc", ["-c", name])
      "pw" : ProgOutputStream("/bin/rc", ["-c", name])
$else
      "p"|"pr"|"pw" : error("Mode not supported")
$endif
      default: runerr("Invalid mode flag: " || mode)
   })
end

#
# Convenient method to call {write} with standard error as output.
#
procedure ewrite(a[])
   return write!push(a, FileStream.stderr)
end

#
# Convenient method to call {writes} with standard error as output.
#
procedure ewrites(a[])
   return writes!push(a, FileStream.stderr)
end

#
# This procedure emulates the old Icon builtin {write} function.
#
procedure write(a[])
   local e, f, r
   r := a[-1]
   if is(a[1], Stream) then
      f := pop(a)
   else
      f := FileStream.stdout
   every e := \!a | Files.EOL do {
      if is(e, Stream) then {
         f.fully_out(Files.EOL) | fail
         f := e
      } else
         f.fully_out(e) | fail
   }
   return r
end

#
# This procedure emulates the old Icon builtin {writes} function.
#
procedure writes(a[])
   local e, f, r
   r := a[-1]
   if is(a[1], Stream) then
      f := pop(a)
   else
      f := FileStream.stdout
   every e := \!a do {
      if is(e, Stream) then
         f := e
      else
         f.fully_out(e) | fail
   }
   return r
end

#
# This procedure emulates the old Icon builtin {stop} function.
#
procedure stop(a[])
   write!push(a, FileStream.stderr)
   exit(1)
end

#
# This procedure emulates the old Icon builtin {read} function.
#
procedure read(f)
   /f := FileStream.stdin
   return f.read()
end

#
# This procedure emulates the old Icon builtin {reads} function.
#
procedure reads(f, n)
   /f := FileStream.stdin
   /n := 1
   return f.reads(n)
end

#
# This procedure emulates the old Icon builtin {close} function.
#
procedure close(f)
   f.close() | fail
   return f
end

#
# This procedure is used to automatically close a {Stream} or other
# resource.  The first expression {e1} produces the resource, the
# second {e2} uses it, and the third expression {e3} then closes it.
# The result of {e2} is returned, if all three expressions succeed,
# otherwise the procedure fails.
#
# {e3} is optional and defaults to calling {close} on the resource.
#
# @example
# @   s := use { f := open("some.txt"),
# @              do_something_with(f) }
procedure use(e1, e2, e3)
   local f, r
   f := @e1 | fail
   /e3 := create f.close()
   /e2 | (r := @e2) | {
      @e3
      fail
   }
   @e3 | fail
   return r
end

#
# Utility to check whether the result of a {poll} for {Poll.IN} indicates
# a call to {in}.
#
procedure poll_in_test(v)
   local x
   # Ignore OUT
   v := iand(v, icom(Poll.OUT))
   # Succeed if either IN or HUP is set, but no other.
   x := iand(v, ior(Poll.IN,Poll.HUP))
   return x ~= 0 & x = v
end

#
# Utility to check whether the result of a {poll} for {Poll.OUT} indicates
# a call to {out}.
#
procedure poll_out_test(v)
   # Ignore IN
   v := iand(v, icom(Poll.IN))
   # Succeed if OUT is set, but no other.
   return v = Poll.OUT
end

#
# This class represents a stream based on a local file.
#
class FileStream(DescStream)
   public static const
      # A {FileStream} representing standard input
      stdin, 
      # A {FileStream} representing standard output
      stdout,
      # A {FileStream} representing standard error
      stderr

$ifdef _PLAN9
   #
   # Open a new {FileStream} using the underlying system open
   # function.
   # @param name the file name
   # @param flags the flags, selected from {FileOpt}
   # @param perm the create permissions to use if a file is
   # @      created, selected from {Mode}.
   # @param mode the resulting {Stream}'s mode; if omitted
   # @      this is deduced from {flags} parameter and the
   # @      type of file being opened.
   #
   public static open(name, flags, perm, mode)
      local C, f, flags2

      # If we have no mode then we need to test for SEEK after
      # the file is opened.
      C := if /mode then create_and_set_mode else FileStream

      case iand(flags, 3) of {
         FileOpt.RDONLY: {
            flags2 := FileOpt9.OREAD
            /mode := READ
         }
         FileOpt.WRONLY: {
            flags2 := FileOpt9.OWRITE
            /mode := WRITE
         }
         FileOpt.RDWR: {
            flags2 := FileOpt9.ORDWR
            /mode := READ_WRITE
         }
         default:
            runerr("Invalid flags combination")
      }
      if iand(flags, FileOpt.TRUNC) ~= 0 then
         flags2 := ior(flags2, FileOpt9.OTRUNC)
      if iand(flags, FileOpt.EXCL) ~= 0 then
         flags2 := ior(flags2, FileOpt9.OEXCL)

      if iand(flags, FileOpt.CREAT) ~= 0 then {
         if Files.access(name, 0) then {
            if iand(flags, FileOpt.EXCL) ~= 0 then
               return error("File exists")
            f := C(open_impl(name, flags2), mode) | fail
            if iand(flags, FileOpt.APPEND) ~= 0 then
               f.seek(0) | fail
            return f
         } else
            return C(create_impl(name, flags2, perm), mode)
      }

      if iand(flags, FileOpt.APPEND) ~= 0 then {
         f := C(open_impl(name, flags2), mode) | fail
         f.seek(0) | fail
         return f
      }
      return C(open_impl(name, flags2), mode)
   end

   public static open9(name, flags, mode)
      if \mode then
         return FileStream(open_impl(name, flags), mode)

      #
      # Set the READ/WRITE mode flags based on the FileOpt flags.
      #
      if iand(flags, FileOpt.WRONLY) ~= 0 then
         mode := WRITE
      else if iand(flags, FileOpt.RDWR) ~= 0 then
         mode := READ_WRITE
      else
         mode := READ

      return create_and_set_mode(open_impl(name, flags), mode)
   end

   public static create9(name, flags, perm, mode)
      if \mode then
         return FileStream(create_impl(name, flags, perm), mode)

      #
      # Set the READ/WRITE mode flags based on the FileOpt flags.
      #
      if iand(flags, FileOpt.WRONLY) ~= 0 then
         mode := WRITE
      else if iand(flags, FileOpt.RDWR) ~= 0 then
         mode := READ_WRITE
      else
         mode := READ

      return create_and_set_mode(create_impl(name, flags, perm), mode)
   end

   #
   # Create a new FileStream instance, and then adjust its mode based
   # on whether we think it is seekable or not.
   #
   private static create_and_set_mode(fd, mode)
      local f
      f := FileStream(fd, mode)
      if save_why{f.tell()} then {
         if f.can(WRITE) then
            f.mode := ior(f.mode, TRUNCATE)
         f.mode := ior(f.mode, SEEK)
      }
      return f
   end

   #
   # Create a pair of {FileStream}s using the pipe system call.
   # @param m1 additional flags from {FileOpt9}, in addition to ORDWR to apply
   # @      to the first end of the pipe
   # @param m2 the same for the other end of the pipe.
   #
   public static pipe(m1, m2)
      local t, p1, p2, dir
      static ser
      initial ser := 0
      if /m1 & /m2 then {
         t := pipe_impl() | fail
         return [FileStream(t[1], READ_WRITE), FileStream(t[2], READ_WRITE)]
      } else {
         /m1 := 0
         /m2 := 0
         dir := "/n/pipe." || System.getpid() || "." || (ser +:= 1)
         Files.bind("#|", dir, MountOpt.MREPL) | fail
         p1 := open9(dir || "/data", ior(m1, FileOpt9.ORDWR), READ_WRITE)  | stop(&why)
         p2 := open9(dir || "/data1", ior(m2, FileOpt9.ORDWR), READ_WRITE)  | stop(&why)
         Files.unmount(, dir)
         if /p1 | /p2 then {
            (\p1).close()
            (\p2).close()
            fail
         }
         return [p1, p2]
      }
   end

   private static defer open_impl(path, flags)
   private static defer create_impl(path, flags, perm)

$else
   #
   # Open a new {FileStream} using the underlying system open
   # function.
   # @param name the file name
   # @param flags the flags, selected from {FileOpt}
   # @param perm the create permissions to use if a file is
   # @      created, selected from {Mode}.
   # @param mode the resulting {Stream}'s mode; if omitted
   # @      this is deduced from {flags} parameter and the
   # @      type of file being opened.
   #
   public static open(name, flags, perm, mode)
      if \mode then
         return FileStream(open_impl(name, flags, perm), mode)

      #
      # Set the READ/WRITE mode flags based on the FileOpt flags.
      #
      if iand(flags, FileOpt.WRONLY) ~= 0 then
         mode := WRITE
      else if iand(flags, FileOpt.RDWR) ~= 0 then
         mode := READ_WRITE
      else
         mode := READ

      return create_and_set_mode(open_impl(name, flags, perm), mode)
   end

   #
   # Create a new FileStream instance, and then adjust its mode based
   # on the file type returned by stat().  If it is a regular file,
   # add SEEK capability, and TRUNCATE too for a writable file.
   #
   private static create_and_set_mode(fd, mode)
      local f
      f := FileStream(fd, mode)
      if f.stat().mode_str[1] == "-" then {
         if f.can(WRITE) then
            f.mode := ior(f.mode, TRUNCATE)
         f.mode := ior(f.mode, SEEK)
      } else {
         if save_why{f.tell()} then
            f.mode := ior(f.mode, SEEK)
      }
      return f
   end

   #
   # Create a pair of {FileStream}s using the pipe system call.
   #
   public static pipe()
      local t
      t := pipe_impl() | fail
      return [FileStream(t[1], READ), FileStream(t[2], WRITE)]
   end

   private static defer open_impl(path, flags, perm)
$endif

   private static init()
      stdin := create_and_set_mode(0, READ)
      stdout := create_and_set_mode(1, WRITE)
      stderr := create_and_set_mode(2, WRITE)
   end

   private static defer pipe_impl()

   public defer in(n)

   public defer out(s)

   public defer seek(offset)

   public defer tell()

   public defer truncate(len)

   public defer chdir()

   public defer close()
end

#
# This class represents a stream based on a socket.
#
class SocketStream(DescStream)
   #
   # Create a socket with the given domain and type.
   #
   # @param domain from {ProtocolFormat}.  The default is
   # @    {ProtocolFormat.INET} 
   # @param typ the type from {SocketType}.  The default is
   # @    {SocketType.STREAM}.
   #
   public static socket(domain, typ)
      return SocketStream(socket_impl(domain, typ), READ_WRITE)
   end

   #
   # Create a pair of sockets of the given type
   #
   # @param typ the type from {SocketType}.  The default is
   # {SocketType.STREAM}.
   #
   public static socketpair(typ)
      local t
      t := socketpair_impl(typ) | fail
      return [SocketStream(t[1], READ_WRITE), SocketStream(t[2], READ_WRITE)]
   end

   public defer in(n)

   #
   # Connect a socket previously created with {Socket} to the given
   # address.  The address is a string in the form "unix:<filename>"
   # for an {AF_UNIX} address, or "inet:<host>:<port>" for an
   # {AF_INET} address.  The host can be "INADDR_ANY" if desired.
   #
   public defer connect(addr)

   #
   # Bind a socket to the given address, which is in the same form as
   # for {connect}.
   #
   public defer bind(addr)

   #
   # Listen for connections with the given backlog.
   #
   public defer listen(backlog)

   #
   # Accept a new connection, returning a new {SocketStream}.
   #
   public accept()
      return SocketStream(accept_impl(), READ_WRITE)
   end

   #
   # Perform a shutdown on the socket.
   # @param how one of the constants in {Shut}
   #
   public defer shutdown(how)

   #
   # Return a list of numerical addresses for the given host.
   #
   public static defer dns_query(host)

   private defer accept_impl()

   public defer out(s)

   public defer close()

   private static defer socketpair_impl(typ)

   private static defer socket_impl(domain, typ)
end

#
# Parent class for classes which wish to define in() in terms of
# reading one line at time, rather than the other way round.
#
class LineBasedInputStream(Stream)
   private
      line

   public read_line()
      local t
      if *line > 0 then {
         t := line[1:-*Files.EOL]
         line := ""
         return t
      }
      return read_line_impl()
   end

   public in(n)
      local t
      if *line = 0 then {
         t := read_line_impl() | fail
         if /t then
            return
         line := t || Files.EOL
      }
      line ? {
         t := move(n) | tab(0)
         line := tab(0)
      }
      return t
   end

   public get_mode()
      return READ
   end

   #
   # Implemented to read a single line.  The EOL should not be
   # included.  Fails on error and returns {&null} on end-of-file
   #
   protected defer read_line_impl()

   protected new()
      self.line := ""
      return
   end
end

#
# Parent class for classes which wish to define out() in terms of
# writing one line at time, rather than the other way round.
#
class LineBasedOutputStream(Stream)
   private
      buff

   public out(s)
      local t
      buff ||:= s
      repeat {
         buff ? {
            t := tab(upto('\n')) | break
            buff := (move(1), tab(0))
            write_line_impl(t) | fail
         }
      }
      return *s
   end

   #
   # Implemented to output a single line.  The EOL is not included in
   # {s}.
   #
   protected defer write_line_impl(s)
   
   public get_mode()
      return WRITE
   end

   protected new()
      self.buff := ""
      return
   end
end

#
# This class is used to read directory contents.
#
class DirStream(LineBasedInputStream, NoCopy)
   private 
      dd

   protected defer read_line_impl()

   public defer close()

   private static defer new_impl(path)

   public new(path)
      cast(self,LineBasedInputStream).new()
$ifdef _MS_WIN32
      if *path = 0 then
         path := "*"
      else if any('\\/:', path[-1]) then
         path ||:= "*"
      else if not upto('*?', path) then
         path ||:= "\\*"
$endif
      self.dd := new_impl(path) | fail
      return
   end
end

# Convenient superclass of classes which use a background process.
#
class HasBgProc()
   protected
      pid,
      exit_info

   #
   # Wait for the child to exit, setting {exit_info}.
   #
   protected do_wait()
      \pid | runerr("do_wait() called out of sequence", self)
      exit_info := System.wait(pid) | fail
      pid := &null
      return
   end

   #
   # Return {ExitInfo} of the child process
   #
   public get_exit_info()
      return .\exit_info
   end

   #
   # Return process id of the child process
   #
   public get_pid()
      return .\pid
   end
end

# Convenient superclass of classes which have an optional {Task} to
# use for polling.
#
class HasTask()
   protected
      task

   #
   # Set a {Task} to use when polling
   #
   public set_task(t)
      self.task := t
      return self
   end

   #
   # Poll, either using the task's poll, or {DescStream.poll} if task
   # is unset.
   #
   protected choose_poll(l, timeout)
      return (if /task then DescStream else task).poll(l, timeout)
   end
end

$ifdef _PLAN9
#
# This stream represents a pipe to a command running in a forked child
# process.
#
class ProgInputStream(FileStream, HasBgProc)
   #
   # Close the stream.  This waits for the child process to terminate.
   #
   public close()
      cast(self,FileStream).close()
      do_wait()
      return
   end

   # Open a new readable {Stream} based on the given command.  The
   # first three parameters are the same as for the method
   # {posix.System.exec};  the last two optionally give the standard
   # input and standard error of the command; by default the command
   # inherits these from the parent.  If the stderr param is the string
   # "pipe", then stderr is sent to the pipe along with stdout.
   # @example
   # @   g := FileStream.open("/tmp/data",FileOpt.RDONLY) | stop(&why)
   # @   f := ProgInputStream("wc", ["-l"],,g) | stop(&why)
   # @   g.close()
   # @   while write(f.read())   # writes the number of lines in /tmp/data
   # @   f.close()
   #
   public new(cmd, args, env, stdin, stderr)
      local l
      l := pipe() | fail
      pid := System.fork() | {
         l[1].close()
         l[2].close()
         fail
      }
      if pid > 0 then {
         # Parent
         l[2].close()
         return cast(self,FileStream).new(l[1].get_fd(), READ)
      } else {
         # Child
         if \stdin then
            stdin.dup2(FileStream.stdin) | stop(&why)
         if \stderr then {
            if stderr === "pipe" then
               l[2].dup2(FileStream.stderr) | stop(&why)
            else
               stderr.dup2(FileStream.stderr) | stop(&why)
         }
         l[2].dup2(FileStream.stdout) | stop(&why)
         l[1].close()
         l[2].close()
         System.exec(cmd, args, env) | stop(&why)
         syserr("Not reached")
      }
   end
end

#
# This stream represents a pipe from a command running in a forked child
# process.
#
class ProgOutputStream(FileStream, HasBgProc)
   #
   # Close the stream.  This waits for the child process to terminate.
   #
   public close()
      cast(self,FileStream).close()
      do_wait()
      return
   end

   # Open a new writeable {Stream} based on the given command. The
   # first three parameters are the same as for the method
   # {posix.System.exec}; the last two optionally give the standard
   # output and standard error of the command; by default the command
   # inherits these from the parent.
   # @example
   # @    g := FileStream.open("/tmp/result",ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT)) | stop(&why)
   # @    f := ProgOutputStream("wc", ["-l"],,g) | stop(&why)
   # @    g.close()
   # @    f.write("data")
   # @    f.close()
   # @    # Now /tmp/result contains "1" (ie, the output of wc -l applied to the data written to f)
   #
   public new(cmd, args, env, stdout, stderr)
      local l
      l := pipe(, FileOpt9.OCEXEC) | fail
      pid := System.fork() | {
         l[1].close()
         l[2].close()
         fail
      }
      if pid > 0 then {
         # Parent
         l[1].close()
         return cast(self,FileStream).new(l[2].get_fd(), WRITE)
      } else {
         if \stdout then
            stdout.dup2(FileStream.stdout) | stop(&why)
         if \stderr then
            stderr.dup2(FileStream.stderr) | stop(&why)
         l[1].dup2(FileStream.stdin) | stop(&why)
         l[1].close()
         l[2].close()
         System.exec(cmd, args, env) | stop(&why)
         syserr("Not reached")
      }
   end
end

#
# Base class for FilterOutputStream and FilterInputStream
#
class FilterStreamBase(Stream, HasBgProc, HasUnderlyingStream, HasTask, NoCopy)
   protected
      cmd,
      err_sink,
      cin,
      cout,
      cerr

   # Convenient function to check that the command exited
   # successfully.  If it did, this function returns, otherwise it
   # fails and sets {&why} appropriately, based on the exit code and
   # stderr output.  The error sink must be set to a {StringStream} to
   # use this function.
   #
   public succeeded()
      local x
      is(err_sink, StringStream) | runerr("Must use a StringStream as error sink with succeeded()", err_sink)
      x := get_exit_info() | runerr("You can only call succeeded() after close()", self)
      case x.reason of {
         "exited normally" : return
         "exited" : return error("exited with status " || x.param)
         default : return error("finished for unknown reason " || x.reason || " with status " || x.param)
      }
   end

   protected do_poll()
      local x, l, t
      l := []
      t := table()
      if l |||:= [\cin, Poll.IN] then
         t[cin] := 1
      if l |||:= [\cerr, Poll.IN] then
         t[cerr] := *l/2
      if l |||:= [\cout, Poll.OUT] then
         t[cout] := *l/2
      if *l = 0 then
         runerr(219, self)
      x := choose_poll(l) | fail
      if poll_in_test(x[t[\cin]]) then
         return cin
      if poll_in_test(x[t[\cerr]]) then
         return cerr
      if poll_out_test(x[t[\cout]]) then
         return cout
      return error("child command i/o failed")
   end

   protected close_cin()
      if \cin then {
         cin.close()
         cin := &null
      }
   end

   protected close_cerr()
      if \cerr then {
         cerr.close()
         cerr := &null
      }
   end

   protected close_cout()
      if \cout then {
         cout.close()
         cout := &null
      }
   end

   protected setup(cmd, args, env, err_sink)
      local l
      self.cmd := cmd
      /err_sink := StringStream()
      self.err_sink := err_sink
      l := FileStream.pipe() | fail
      (l |||:= FileStream.pipe(, FileOpt9.OCEXEC) &
       l |||:= FileStream.pipe() &
       pid := System.fork()) | {
          every (!l).close()
          fail
       }
      if pid > 0 then {
         # Parent
         cin := NonBlockStream(l[1], Stream.READ, 65536)
         cout := NonBlockStream(l[4], Stream.WRITE,, 65536).
            set_write_on_close(NonBlockStream.BACKGROUND_FLUSH)
         cerr := NonBlockStream(l[5], Stream.READ, 65536)
         l[2].close()
         l[3].close()
         l[6].close()
         return
      } else {
         # Child
         l[2].dup2(FileStream.stdout) | stop(&why)
         l[3].dup2(FileStream.stdin) | stop(&why)
         l[6].dup2(FileStream.stderr) | stop(&why)
         every (!l).close()
         System.exec(cmd, args, env) | stop(&why)
         syserr("Not reached")
      }
   end
end

$else

#
# This stream represents a pipe to a command running in a forked child
# process.
#
class ProgInputStream(SocketStream, HasBgProc)
   #
   # Close the stream.  This waits for the child process to terminate.
   #
   public close()
      shutdown(Shut.RD)
      cast(self,SocketStream).close()
      do_wait()
      return
   end

   # Open a new readable {Stream} based on the given command.  The
   # first three parameters are the same as for the method
   # {posix.System.exec};  the last two optionally give the standard
   # input and standard error of the command; by default the command
   # inherits these from the parent.  If the stderr param is the string
   # "pipe", then stderr is sent to the pipe along with stdout.
   # @example
   # @   g := FileStream.open("/tmp/data",FileOpt.RDONLY) | stop(&why)
   # @   f := ProgInputStream("wc", ["-l"],,g) | stop(&why)
   # @   g.close()
   # @   while write(f.read())   # writes the number of lines in /tmp/data
   # @   f.close()
   #
   public new(cmd, args, env, stdin, stderr)
      local l
      l := socketpair() | fail
      (l[1].shutdown(Shut.WR) &
       pid := System.fork()) | {
         l[1].close()
         l[2].close()
         fail
      }
      if pid > 0 then {
         # Parent
         l[2].close()
         return cast(self,SocketStream).new(l[1].get_fd(), READ)
      } else {
         # Child
         if \stdin then
            stdin.dup2(FileStream.stdin) | stop(&why)
         if \stderr then {
            if stderr === "pipe" then
               l[2].dup2(FileStream.stderr) | stop(&why)
            else
               stderr.dup2(FileStream.stderr) | stop(&why)
         }
         l[2].dup2(FileStream.stdout) | stop(&why)
         l[1].close()
         l[2].close()
         System.exec(cmd, args, env) | stop(&why)
         syserr("Not reached")
      }
   end
end

#
# This stream represents a pipe from a command running in a forked child
# process.
#
class ProgOutputStream(SocketStream, HasBgProc)
   #
   # Close the stream.  This waits for the child process to terminate.
   #
   public close()
      shutdown(Shut.WR)
      cast(self,SocketStream).close()
      do_wait()
      return
   end

   # Open a new writeable {Stream} based on the given command. The
   # first three parameters are the same as for the method
   # {posix.System.exec}; the last two optionally give the standard
   # output and standard error of the command; by default the command
   # inherits these from the parent.
   # @example
   # @    g := FileStream.open("/tmp/result",ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT)) | stop(&why)
   # @    f := ProgOutputStream("wc", ["-l"],,g) | stop(&why)
   # @    g.close()
   # @    f.write("data")
   # @    f.close()
   # @    # Now /tmp/result contains "1" (ie, the output of wc -l applied to the data written to f)
   #
   public new(cmd, args, env, stdout, stderr)
      local l
      l := socketpair() | fail
      (l[2].dflag(DescOpt.CLOEXEC) &
       l[2].shutdown(Shut.RD) &
       pid := System.fork()) | {
          l[1].close()
          l[2].close()
          fail
       }
      if pid > 0 then {
         # Parent
         l[1].close()
         return cast(self,SocketStream).new(l[2].get_fd(), WRITE)
      } else {
         # Child
         if \stdout then
            stdout.dup2(FileStream.stdout) | stop(&why)
         if \stderr then
            stderr.dup2(FileStream.stderr) | stop(&why)
         l[1].dup2(FileStream.stdin) | stop(&why)
         l[1].close()
         l[2].close()
         System.exec(cmd, args, env) | stop(&why)
         syserr("Not reached")
      }
   end
end

#
# Base class for FilterOutputStream and FilterInputStream
#
class FilterStreamBase(Stream, HasBgProc, HasUnderlyingStream, HasTask, NoCopy)
   protected
      cmd,
      err_sink,
      cin,
      cout,
      cerr

   # Convenient function to check that the command exited
   # successfully.  If it did, this function returns, otherwise it
   # fails and sets {&why} appropriately, based on the exit code and
   # stderr output.  The error sink must be set to a {StringStream} to
   # use this function.
   #
   public succeeded()
      local x
      is(err_sink, StringStream) | runerr("Must use a StringStream as error sink with succeeded()", err_sink)
      x := get_exit_info() | runerr("You can only call succeeded() after close()", self)
      case x.reason of {
         ExitInfo.EXITED: {
            if x.param = 0 then
               return
            return error(cmd || " exited with status " || x.param || ": " || trim(replace(err_sink.str(), "\n", " ")))
         }
         ExitInfo.STOPPED:
            return error(cmd || " stopped with signal " || x.param)
         ExitInfo.TERMINATED:
            return error(cmd || " terminated with signal " || x.param)
         ExitInfo.COREDUMP:
            return error(cmd || " dumped core with signal " || x.param)
         default:
            return error(cmd || " finished for unknown reason " || x.reason || "; param " || x.param)
      }
   end

   protected do_poll()
      local x, l, t
      l := []
      t := table()
      if l |||:= [\cin, Poll.IN] then
         t[cin] := 1
      if l |||:= [\cerr, Poll.IN] then
         t[cerr] := *l/2
      if l |||:= [\cout, Poll.OUT] then
         t[cout] := *l/2
      if *l = 0 then
         runerr(219, self)
      x := choose_poll(l) | fail
      if poll_in_test(x[t[\cin]]) then
         return cin
      if poll_in_test(x[t[\cerr]]) then
         return cerr
      if poll_out_test(x[t[\cout]]) then
         return cout
      return error("child command i/o failed")
   end

   protected close_cin()
      if \cin then {
         cin.shutdown(Shut.RD)
         cin.close()
         cin := &null
      }
   end

   protected close_cerr()
      if \cerr then {
         cerr.shutdown(Shut.RD)
         cerr.close()
         cerr := &null
      }
   end

   protected close_cout()
      if \cout then {
         cout.shutdown(Shut.WR)
         cout.close()
         cout := &null
      }
   end

   protected setup(cmd, args, env, err_sink)
      local l
      self.cmd := cmd
      /err_sink := StringStream()
      self.err_sink := err_sink
      l := SocketStream.socketpair() | fail
      (l |||:= SocketStream.socketpair() &
       l |||:= SocketStream.socketpair() &
       l[1].flag(FileOpt.NONBLOCK) & 
       l[4].dflag(DescOpt.CLOEXEC) &
       l[4].flag(FileOpt.NONBLOCK) & 
       l[5].flag(FileOpt.NONBLOCK) &
       l[1].shutdown(Shut.WR) &
       l[3].shutdown(Shut.WR) &
       l[5].shutdown(Shut.WR) &
       l[2].shutdown(Shut.RD) &
       l[4].shutdown(Shut.RD) &
       l[6].shutdown(Shut.RD) &
       pid := System.fork()) | {
          every (!l).close()
          fail
       }
      if pid > 0 then {
         # Parent
         cin := l[1]
         cout := l[4]
         cerr := l[5]
         l[2].close()
         l[3].close()
         l[6].close()
         return
      } else {
         # Child
         l[2].dup2(FileStream.stdout) | stop(&why)
         l[3].dup2(FileStream.stdin) | stop(&why)
         l[6].dup2(FileStream.stderr) | stop(&why)
         every (!l).close()
         System.exec(cmd, args, env) | stop(&why)
         syserr("Not reached")
      }
   end
end

$endif

#
# This stream filters output written to it through a background
# process and outputs the results to an arbitrary sink {Stream}.
#
# @example
# @ # Encode s, putting the result in a RamStream
# @ r := RamStream()
# @ g := FilterOutputStream(r, "gzip", ["-c"])
# @ g.write(s)
#
class FilterOutputStream(FilterStreamBase)
   private 
      sink
   
   public out(s)
      local x, t
      s := string(s) | runerr(103, s)
      repeat {
         x := do_poll() | fail
         case x of {
            cin: {
               t := cin.in(1048576) | fail
               if /t then
                  close_cin()
               else
                  sink.fully_out(t) | fail
            }
            cerr: {
               t := cerr.in(1048576) | fail
               if /t then
                  close_cerr()
               else
                  err_sink.fully_out(t) | fail
            }
            cout:
               return cout.out(s)
         }
      }
   end

   private flush_remaining()
      local x, t
      while \cin | \cerr do {
         x := do_poll() | fail
         case x of {
            cin: {
               t := cin.in(1048576) | fail
               if /t then
                  close_cin()
               else
                  sink.fully_out(t) | fail
            }
            cerr: {
               t := cerr.in(1048576) | fail
               if /t then
                  close_cerr()
               else
                  err_sink.fully_out(t) | fail
            }
         }
      }
      return
   end

   # Close the stream.  This waits for the child process to terminate,
   # flushing any remaining output to {sink}.  NB: {sink} and
   # {err_sink} are not closed unless the {set_close_underlying} has
   # been set to {&yes}.
   #
   public close()
      local f
      \pid | runerr(219, self)
      close_cout()
      flush_remaining() | (f := 1)
      close_cin()
      close_cerr()
      if \close_underlying_flag then {
         sink.close() | (f := 1)
         (err_sink === sink) | err_sink.close() | (f := 1)
      }
      do_wait()
      return /f
   end

   public get_mode()
      return WRITE
   end

   #
   # Create a new instance.
   #
   # @param sink the {Stream} to which data is output from the command.
   # @      Defaults to a {NullStream}.
   # @param cmd the name of the command                                    
   # @param args the arg list                                              
   # @param env the env list                                               
   # @param err_sink optional stream to send standard error to.  If omitted,
   # @      defaults to a {StringStream}, which can then be used together
   # @      with {succeeded()} to check the command's exit status.
   public new(sink, cmd, args, env, err_sink)
      /sink := NullStream()
      self.sink := sink
      setup(cmd, args, env, err_sink) | fail
      return
   end
end

#
# This stream filters data taken from an arbitrary source {Stream}
# through a background process.  The output from that process can then
# be read as this {Stream}'s output.
#
# @example
# @ g := FilterInputStream(StringStream(s), "gzip", ["-c"])
# @ # Reading from g will give the compressed value of the string s.
# @ res := g.read_all()
#
class FilterInputStream(FilterStreamBase)
   private 
      source,
      buff

   public in(n)
      local x, i, t
      repeat {
         x := do_poll() | {
            if \cout then {
               # The child has exited, but the data has yet to reach
               # the input pipes; close cout and go round again to
               # wait for input or hup on cin/cerr.
               close_cout()
               next
            }
            fail
         }
         case x of {
            cin: {
               t := cin.in(n) | fail
               if /t then
                  close_cout()
               return t
            }
            cerr: {
               t := cerr.in(1048576) | fail
               if /t then {
                  close_cout()
                  close_cerr()
               } else
                  err_sink.fully_out(t) | fail
            }
            cout: {
               if *buff = 0 then {
                  buff := source.in(1048576) | fail
                  if /buff then {
                     close_cout()
                     next
                  }
               }
               i := cout.out(buff) | {
                  # Broken pipe; this is caused by the command exiting
                  # between the do_poll() and the out() call.
                  close_cout()
                  next
               }
               buff := buff[i + 1:0]
            }
         }
      }
   end

   #
   # Exchange the handling of the command's stdout and stderr, so that
   # stdout goes to the stderr sink and stderr is read by calling
   # {in()}
   #
   public swap_outputs()
      cin :=: cerr
      return self
   end

   private flush_cerr()
      local x, t
      while \cerr do {
         x := do_poll() | fail
         case x of {
            cerr: {
               t := cerr.in(1048576) | fail
               if /t then
                  close_cerr()
               else
                  err_sink.fully_out(t) | fail
            }
            default:
               syserr("Unexpected result from do_poll")
         }
      }
      return
   end

   #
   # Close the stream.  This waits for the child process to terminate.
   # NB: {source} and {err_sink} are not closed unless the
   # {set_close_underlying} has been set to {&yes}.
   #
   public close()
      local f
      \pid | runerr(219, self)
      close_cout()
      close_cin()
      flush_cerr() | (f := 1)
      close_cerr()
      if \close_underlying_flag then {
         source.close() | (f := 1)
         err_sink.close() | (f := 1)
      }
      do_wait()
      self.buff := &null
      return /f
   end

   public get_mode()
      return READ
   end
   
   #
   # Create a new instance.
   #
   # @param source the {Stream} from which data is given to the command.
   # @      Defaults to a {NullStream}.
   # @param cmd the name of the command                                    
   # @param args the arg list                                              
   # @param env the env list                                               
   # @param err_sink optional stream to send standard error to.  If omitted,
   # @      defaults to a {StringStream}, which can then be used together
   # @      with {succeeded()} to check the command's exit status.
   public new(source, cmd, args, env, err_sink)
      /source := NullStream()
      self.source := source
      self.buff := ""
      setup(cmd, args, env, err_sink) | fail
      return
   end
end

#
# This class provides a {Stream} which stores its data in memory.  It
# can be used to efficiently concatenate together many strings, or as
# a convenient temporary stream.
#
class RamStream(Stream, NoCopy)
   private
      ptr

   public defer in(n)

   public defer out(s)

   public defer seek(offset)

   public defer tell()

   public defer truncate(len)

   #
   # Return the current content of the {RamStream} as a string.
   #
   public defer str()

   public defer close()

   #
   # Close the stream and return the finished content as a string.
   #
   public done()
      local s
      s := str()
      close()
      return s
   end

   private static defer new_impl(s, wiggle)

   public get_mode()
      return ALL
   end

   #
   # Create a new {RamStream}, with initial value of {s}.
   #
   # @param s the initial value of the stream; defaults to empty 
   # @      string.
   # @param wiggle the extra space to reserve for growth of the buffer,
   # @      default is 512 bytes.
   #
   public new(s, wiggle)
      ptr := new_impl(s, wiggle)
      return
   end
end

$ifdef _PLAN9
class CtrlStream(FileStream)
   package new(cfd)
      cast(self,FileStream).new(cfd, READ_WRITE)
      return
   end
end

#
# A stream for network connections.
#
class NetStream(FileStream)
   private dir, ctrl

   private static cs_query1(q, task, f)
      local l, nb
      if /task then
         # May block for a few seconds during dns
         f.out(q) | fail
      else {
         # Use a non-blocking stream and poll so that other work can be
         # done whilst waiting for dns.
         use {
            nb := NonBlockStream(f, Stream.WRITE).
               set_close_underlying(&no),
            {
               nb.out(q)
               # Poll with no timeout.  The close() of nb will flush
               # and hence any error from the out() will percolate out
               # to the use.
               task.poll([nb, Poll.OUT])
            }
         } | fail
      }
      # Read the results
      l := []
      f.seek(1)
      while put(l, \f.in(1024))
      # Hack for 9vx
      if *l = 1 & find("0.0.0.0", l[1]) then
         return error("No such dns entry")
      return l
   end

   # Query the connection server (/net/cs)
   # @param the address to query
   # @param the optional task to use to poll the server, allowing other work to take place
   # @      during the query.
   #
   public static cs_query(addr, task)
      local f
      return use {
         f := FileStream.open("/net/cs", FileOpt.RDWR),
         cs_query1(addr, task, f)
      }
   end

   # Write to the control file.
   # @param msg the message to write
   # @param timeout an optional timeout
   # @param the optional task to use to poll the server, allowing other work to take place
   # @      whilst waiting for a response (eg on a connect).
   #
   public write_ctrl(msg, timeout, task)
      local nb, r
      return if /timeout & /task then
         ctrl.out(msg)
      else {
         use {
            nb := NonBlockStream(ctrl, Stream.WRITE).
               set_close_underlying(&no).
               set_write_on_close(NonBlockStream.DISCARD),     # Needed since on a timeout the writer will still be writing
            {                               # and would thus hang on a flush from close()
               nb.out(msg)
               r := (if /task then DescStream else task).poll([nb, Poll.OUT], timeout)
               # Any error here percolates out to the outer use.
               if /r then
                  error("Timeout")
               else
                  # Test the error status of the writer process - this won't hang since we
                  # didn't timeout, but it may fail (eg connection refused).
                  nb.flush_out()
            }
         }
      }
   end

   # Open a file under the stream's directory with the given mode.
   #
   public open_subfile(s, mode)
      return FileStream.open(dir || "/" || s, mode)
   end

   # Open the data stream file
   #
   public open_data()
      if self.fd ~= -1 then
         return error("data stream already open")
      self.fd := open_subfile("data", FileOpt.RDWR).get_fd() |
         return error("Couldn't open data stream: " || &why)
      return
   end

   # Connect to the given address, which should be in the form returned by cs_query, eg
   # "/net/tcp/clone 173.194.78.103!80".
   # @param s the entry from cs_query
   # @param timeout an optional timeout
   # @param the optional task to use to poll the server, allowing other work to take place
   # @      whilst waiting.
   #
   public static connect(s, timeout, task)
      local clone_file, dest, res

      s ? {
         clone_file := tab(upto(' '))
         move(1)
         dest := tab(0)
      }

      res := clone(clone_file) | fail

      # Try to connect
      res.write_ctrl("connect " || dest, timeout, task) | {
         res.close()
         # &why should be set appropriately by the response to the connect
         fail
      }
      
      res.open_data() | {
         res.close()
         fail
      }
      return res
   end

   # Dial the given address.
   #
   # @param addr the address, eg "tcp!www.google.com!80"
   # @param timeout an optional timeout
   # @param the optional task to use to poll the server, allowing other work to take place
   # @      whilst waiting.
   #
   public static dial(addr, timeout, task)
      local l
      l := cs_query(addr, task) | fail
      return connect(!l, timeout, task)
   end

   # Dial the given address.  As per {dial}, but just use the first
   # result from cs_query, then give up.
   #
   public static dial_first(addr, timeout, task)
      local l
      l := cs_query(addr, task) | fail
      return connect(l[1], timeout, task)
   end

   # Create a new {NetStream}, by opening the given clone file, which
   # becomes the control file of the new instance.
   #
   public static clone(fn)
      local cf, name, dir, i
      cf := FileStream.open(fn, FileOpt.RDWR) | return error("Couldn't open clone file: " || &why)
      # Get the id number of the connection clone created
      name := cf.in(1024)
      every i := upto('/', fn)
      dir := fn[1:i + 1] || name
      return NetStream(cf, dir)
   end

   # Return a new {NetStream} which can be used to listen on the given address.
   #
   public static announce(addr)
      local l, res, clone_file, arg
      l := cs_query(addr) | fail
      # will be in the form "/net/tcp/clone 1234"      
      l[1] ? {
         clone_file := tab(upto(' '))
         move(1)
         arg := tab(0)
      }
      res := clone(clone_file) | fail
      res.write_ctrl("announce " || arg) | {
         res.close()
         # &why should be set appropriately by the response to the announce
         fail
      }
      return res
   end

   # After an {announce}, listen for an incoming connection.
   # @param timeout an optional timeout
   # @param the optional task to use with poll(), allowing other work to take place
   # @      whilst waiting.
   #
   public listen(timeout, task)
      local cf, name, new_dir, i, cw, r, fd
      if /timeout & /task then
         cf := open_subfile("listen", FileOpt.RDWR) | return error("Couldn't open listen file: " || &why)
      else {
         fd := use {
            cw := FileWorker(),
            {
               cw.op_open(dir || "/listen", FileOpt9.ORDWR)
               r := (if /task then DescStream else task).poll([cw, Poll.IN], timeout)
               if /r then
                  error("Timeout")
               else
                  (cw.await(), cw.dup_fd()) | error("Couldn't open listen file: " || &why)
            }
         } | fail
         cf := CtrlStream(fd)
      }
      name := cf.in(1024)
      every i := upto('/',dir)
      new_dir := dir[1:i + 1] || name
      return NetStream(cf, new_dir)
   end

   # Accept an incoming connection
   #
   public accept()
      local i
      every i := upto('/',dir)
      # May fail, so ignore errors
      save_why{write_ctrl("accept " || dir[i + 1:0])}
      # Open data stream
      return open_data()
   end

   # Reject an incoming connection
   #
   public reject(cause)
      local i
      every i := upto('/',dir)
      # May fail, so ignore errors
      save_why{write_ctrl("reject " || dir[i + 1:0] || " " || cause)}
      return
   end

   # Return the directory of the stream, eg "/net/tcp/6".
   #
   public get_dir()
      return .dir
   end

   # Return the control file, which will be a {FileStream}.
   #
   public get_ctrl()
      return .ctrl
   end

   public close()
      if self.fd ~= -1 then
         cast(self,FileStream).close()
      ctrl.close()
      return
   end

   private new(ctrl, dir)
      cast(self,FileStream).new(-1, READ_WRITE)
      self.ctrl := ctrl
      self.dir := dir
      return
   end
end

class Pollable()
   public defer get_poll(ev)
end

# This stream provides non-blocking i/o by using background processes.
# The methods {get_in_status} and {get_out_status} indicate what the
# background processes are doing, and whether the {in} and {out}
# methods may block.  Instances can be used with {DescStream.poll}.
#
class NonBlockStream(Stream, Pollable, HasUnderlyingStream, NoCopy)
   public static const
      INVALID, 
      READING, 
      WRITING, 
      COMPLETE, 
      ERROR,
      EOF

   public static const
      DISCARD,
      FOREGROUND_FLUSH,
      BACKGROUND_FLUSH

   private
      mode,
      reader,
      rbuff,
      writer,
      other,
      write_on_close

   private static init()
      INVALID := 0
      READING := 1
      WRITING := 2
      COMPLETE := 3
      ERROR := 4
      EOF := 5

      DISCARD := 1
      FOREGROUND_FLUSH := 2
      BACKGROUND_FLUSH := 3
   end

   public get_poll(ev)
      local res, in, out
      res := 0  
      in := get_in_status()
      if iand(ev, Poll.IN) ~= 0 & in ~= READING then
         res := ior(res, Poll.IN)
      if in = ERROR then
         res := ior(res, Poll.ERR)
      else if in = EOF then
         res := ior(res, Poll.HUP)
      
      out := get_out_status()
      if iand(ev, Poll.OUT) ~= 0 & out ~= WRITING then
         res := ior(res, Poll.OUT)
      if out = ERROR then
         res := ior(res, Poll.ERR)
      return res
   end

   public in(n)
      local t, rc
      \reader | return error("stream not open for reading")
      rc := reader.await() | fail
      if rc = 0 then
         return      # eof

      # Now rc > 0
      if *rbuff = 0 then
         rbuff := reader.get_buffer(rc)

      # Now *rbuff > 0
      rbuff ? {
         t := move(n) | tab(0)
         rbuff := tab(0)
      }

      if *rbuff = 0 then
         reader.op_read()
      return t
   end

   public out(s)
      local n
      s := string(s) | runerr(103, s)
      flush_out() | fail
      n := min(*s, writer.get_buff_size())
      writer.op_fully_write(s[1+:n])
      return n
   end

   # This behaves just like the {out} method, except that it does not
   # trigger a new write in the writer process.  So after it has been
   # called, the write status will not be WRITING, and so the next
   # call to {out} will not block.
   #
   public flush_out()
      \writer | return error("stream not open for writing")
      writer.await() | fail
      return
   end

   # This setting configures what happens to data remaining in the
   # write buffer when {close()} is invoked.  There are three possible
   # settings :-
   #
   # DISCARD - the data is discarded, and {close()} does not block.
   #
   # FOREGROUND_FLUSH - the data is flushed, and {close()} blocks
   # whilst this is done.  This is the default setting.
   #
   # BACKGROUND_FLUSH - the data is flushed in the background (by
   # leaving the writer process running until the data is written),
   # and {close()} does not block.  The writer process will continue,
   # if necessary, even after the program exits.
   #
   public set_write_on_close(x)
      self.write_on_close := x
      return self
   end

   public get_mode()
      return .mode
   end

   public close()
      local f
      if \writer then {
         case write_on_close of {
            DISCARD: 
               writer.close()
            FOREGROUND_FLUSH : {
               flush_out() | (f := 1)
               writer.close()
            }
            BACKGROUND_FLUSH:
               writer.close_when_complete()
            default:
               runerr("Invalid write_on_close setting: " || image(write_on_close))
         }
      }
      if \reader then
         reader.close()
      if \close_underlying_flag then
         other.close() | (f := 1)
      return /f
   end

   #
   # Return the status of the input side of the stream.  Possible values are :-
   #
   # INVALID -  the stream is not open for input; a call to in() would fail.
   # READING -  the background process is reading; a call to in() may block
   # COMPLETE - the stream has data ready; a call to in() would return  some
   #            data immediately.
   # ERROR -    the stream has received an error; a call to in() would fail
   #            immediately.
   # EOF -      the stream is at end of file; a call to in() would return &null
   #            immediately
   #
   # Note that only the status READING implies a call to in() would block.
   #
   public get_in_status()
      local rc
      if /reader then
         return INVALID
      if reader.is_running() then
         return READING
      rc := reader.get_result()
      if rc < 0 then
         return ERROR
      if rc = 0 then
         return EOF
      return COMPLETE
   end

   #
   # Return the status of the output side of the stream.  Possible values are :-
   #
   # INVALID -  the stream is not open for output; a call to out() would fail.
   # WRITING -  the background process is writing; a call to out() may block
   # COMPLETE - the stream is ready for another output; a call to out() would
   #            output some data and not block.
   # ERROR -    the stream has received an error; a call to out() would fail
   #            immediately.
   #
   # Note that only the status WRITING implies a call to out() would block.
   #
   public get_out_status()
      local rc
      if /writer then
         return INVALID
      if writer.is_running() then
         return WRITING
      rc := writer.get_result()
      if rc < 0 then
         return ERROR
      return COMPLETE
   end

   #
   # Create a new instance
   # @param other - the {DescStream} to wrap
   # @param mode - either {READ} and/or {WRITE}.  Using only one of the two
   #               possible modes allows the creation of only one subprocess.
   # @param rbuff_size - the read buffer size; default 1KB
   # @param wbuff_size - the write buffer size; default 1KB
   #
   public new(other, mode, rbuff_size, wbuff_size)
      /mode := other.get_mode()
      mode := iand(mode, READ_WRITE)
      self.mode := mode
      if can(READ) then {
         self.rbuff := ""
         self.reader := FileWorker(rbuff_size, other)
         reader.op_read()
      }
      if can(WRITE) then
         self.writer := FileWorker(wbuff_size, other)
      self.other := other
      self.close_underlying_flag := &yes
      self.write_on_close := FOREGROUND_FLUSH
      return
   end
end

# This is a class for performing basic blocking i/o system calls in a
# background process, on a particular file.
#
class FileWorker(Pollable)
   private
      ptr

   public get_poll(ev)
      local res
      if is_running() then
         return 0
      res := iand(ev, ior(Poll.IN, Poll.OUT))
      if get_result() < 0 then
         res := ior(res, Poll.ERR)
      return res
   end

   private static defer new_impl(buff_size, other)

   public defer op_read(n)
   public defer op_write(s)
   public defer op_fully_write(s)
   public defer op_open(path, mode)
   public defer op_create(path, mode, perm)
   public defer op_close()
   public defer is_running()
   public defer get_buff_size()
   public defer get_buffer(n)
   public defer get_result()
   public defer await()
   public defer close()
   public defer close_when_complete()
   public defer dup_fd()

   public is_complete()
      return not is_running()
   end

   # Create a new instance.
   # @param buff_size the i/o buffer size for reads and writes; defaults to 1024
   # @param other an optional {DescStream}, whose file descriptor is dup'ed, and then
   #       used for subsequent operations.  If not given, then {op_open} or {op_create} must be
   #       called to initialize a file.
   #
   public new(buff_size, other)
      ptr := new_impl(buff_size, other)
      return
   end
end

$endif

#
# A very simple SSL stream, using the openssl library.
#
class SslStream(Stream, HasUnderlyingStream, NoCopy)
   private
      ptr,
      other

   public defer in(n)

   public defer out(s)

   public close()
      local f
      close_impl() | (f := 1)
      if \close_underlying_flag then
         other.close() | (f := 1)
      return /f
   end

   private defer close_impl()

   public get_mode()
      return other.get_mode()
   end

   private static defer new_impl(other, verify_host)

   #
   # Create a new SslStream.
   #
   # @param other an already connected {SocketStream} over which the connection
   #              will operate
   # @param verify_host if set, the remote host's certificate will be verified
   #              and its hostname checked against this value.
   public new(other, verify_host)
      ptr := new_impl(other, verify_host) | fail
      self.other := other
      return
   end
end

#
# This stream takes a list of other streams.  Its output is the concatenation of
# the output of those streams.
#
class SequenceStream(Stream, HasUnderlyingStream)
   private
      a, ac

   public in(n)
      local s
      repeat {
         if *a = 0 then
            return
         s := a[1].in(n) | fail
         if \s then
            return s
         pop(a)
      }
   end

   public get_mode()
      return READ
   end

   public close()
      local e, f
      if \close_underlying_flag then {
         every e := !ac do
            e.close() | (f := 1)
      }
      return /f
   end

   public new(a[])
      self.a := a
      self.ac := copy(a)
      return
   end
end

#
# Subclasses of this stream implement the {gen} method.  The results
# sequence of that method represent the output of the stream, with
# each result being one line.
#
class GeneratorStream(LineBasedInputStream, NoCopy)
   private
      coex

   protected read_line_impl()
      local t
      if /coex then
         return
      t := @coex | fail
      if /t then
         coex := &null
      else
         t := string(t) | runerr(103, t)
      return t
   end

   public close()
      return
   end

   #
   # Generates the lines of the stream.  End-of-file is signalled by
   # returning {&null} and errors are signalled by failing and setting
   # {&why}.
   #
   protected defer gen()

   public new()
      cast(self,LineBasedInputStream).new()
      self.coex := create gen()
      return
   end
end

#
# A {Stream} which takes its data from a co-expression.  Each result provides
# one line of output.
#
# @example
# @   # A stream with 10 lines
# @   e := ExprStream{1 to 10}
#
class ExprStream(LineBasedInputStream)
   private
      coex

   protected read_line_impl()
      local t
      if t := @coex then
         t := string(t) | runerr(103, t)
      return t
   end

   public close()
      return
   end

   public new(coex)
      self.coex := coex
      return cast(self,LineBasedInputStream).new()
   end
end

#
# Useful parent class for filtering the lines from a particular
# {Stream}.
#
class LineFilterStream(GeneratorStream, HasUnderlyingStream)
   protected
      other

   public close()
      if \close_underlying_flag then
         other.close() | fail
      return
   end

   protected next_line()
      return other.read_line()
   end

   protected expect_line()
      local s
      s := other.read_line() | fail
      return \s | error("Unexpected eof")
   end

   public new(other)
      self.other := other
      self.close_underlying_flag := &yes
      return cast(self,GeneratorStream).new()
   end
end
