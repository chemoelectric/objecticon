package ipl.functional

import util(State, save_state)

global _a, _l

#
# Implementation class for {lambda}
#
package class Lambda()
   private e

   public call(a[])
      suspend save_state(^e, LambdaState(a))
   end

   public new(e)
      self.e := e
      return
   end
end

#
# This is a procedure for making lambda-style functions.  For example:
# ~~~
#   f := lambda{ _a[1] + 100 }
# ~~~
# sets `f` to be a function returning its first argument plus 100.  Note
# that args are passed to the function via a global variable `_a`, since
# icon syntax allows no other way.  Further, although the function can
# use any variables in scope, it cannot declare any itself.  To simulate
# local variables, another global, `_l`, can be used.  It can be set
# to any value.
# 
# Other examples:-
# ~~~
#   # Return the sum of the arguments, eg f(1,2,3) -> 6
#   # - note that _l must be dereferenced, otherwise the caller sees the
#   #   value before the function is called.
#   f := lambda{{ _l := 0; every _l +:= !_a ; ._l }}
# ~~~
#
procedure lambda(e)
   return Lambda(e).call
end

# Evaluates coexpression {e}, saving the value of {_a} and {_l}.  This
# can be necessary if a lambda calls another lambda which exits via an
# exception or a runtime error.
#
# @example
# @   f := lambda{
# @      throw("Something bad")
# @   }
# @
# @   g := lambda{{
# @      write("a[1]=",_a[1])
# @      save_lambda{try{ f(102) }}
# @      # Without save_lambda, _a[1] would now still be 102 (ie the arg given to f)
# @      write("a[1]=",_a[1])
# @   }}
#
procedure save_lambda(e)
   suspend save_state(e, LambdaState())
end

# A `State` class for saving the two global state variables.  An
# initial value for `_a` may be optionally specified.
#
class LambdaState(State)
   private ta, tl, i

   public begin()
      ta := _a
      tl := _l
      _a := i
      _l := &null
   end

   public swap()
      _a :=: ta
      _l :=: tl
   end

   public finish()
      _a := ta
      _l := tl
   end

   public new(i)
      self.i := i
      return
   end
end
