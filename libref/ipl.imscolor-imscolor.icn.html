<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>imscolor.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     imscolor.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures for manipulating images
<a name="6"/>#
<a name="7"/>#	Author:   Gregg M. Townsend
<a name="8"/>#
<a name="9"/>#	Date:     December 25, 1999
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#	These procedures manipulate image strings.
<a name="18"/>#
<a name="19"/>#	imswidth(im)		returns the width of an image.
<a name="20"/>#	imsheight(im)		returns the height of an image.
<a name="21"/>#	imspalette(im)		returns the palette used by an image.
<a name="22"/>#
<a name="23"/>#	imsmap(s1, s2, s3)	applies map() to the image data.
<a name="24"/>#
<a name="25"/>#	imswrite(f, s, n)	writes an image string to a file.
<a name="26"/>#
<a name="27"/>#	drawpalette(W, p, x, y, w, h, f, n)	draws the color palette p.
<a name="28"/>#
<a name="29"/>#	pickpalette(W, p, dx, dy, w, h, n)      maps window coordinates
<a name="30"/>#				to a palette drawn by drawpalette().
<a name="31"/>#
<a name="32"/>#	XPMImage(f, p)	reads an XPM file, returning an image string.
<a name="33"/>#
<a name="34"/>############################################################################
<a name="35"/>#
<a name="36"/>#  imswidth(im) returns the width of an image.
<a name="37"/>#  imsheight(im) returns the height of an image.
<a name="38"/>#  imspalette(im) returns the palette used by an image.
<a name="39"/>#
<a name="40"/>#  imsmap(s1, s2, s3) returns an image produced by mapping the data (only)
<a name="41"/>#  of image s1 and replacing characters found in s2 with corresponding
<a name="42"/>#  characters from s3.
<a name="43"/>#
<a name="44"/>#  imswrite(f, s, n) writes image string s to file f, limiting the line
<a name="45"/>#  length to n characters.  Defaults are f = &amp;output, n = 79.  Extra
<a name="46"/>#  punctuation in s makes the lines break at nonsensical places, but
<a name="47"/>#  the output is still legal.
<a name="48"/>#
<a name="49"/>#  drawpalette([win,] p, x, y, w, h, f, n) draws the colors of palette
<a name="50"/>#  p in the given rectangular region.  n columns are used;  if n is
<a name="51"/>#  omitted, a layout is chosen based on the palette name and size. The
<a name="52"/>#  layout algorithm works best when the height is two to four times
<a name="53"/>#  the width.  Characters in the flag string f have these meanings:
<a name="54"/>#	l	label each color with its key
<a name="55"/>#	o	outline each color in black
<a name="56"/>#	u	unframed use: don't hash unused cells at end
<a name="57"/>#
<a name="58"/>#  pickpalette([win,] p, dx, dy, w, h, n) returns the character at (dx,dy)
<a name="59"/>#  within a region drawn by drawpalette(win, p, x, y, w, h, f, n).
<a name="60"/>#
<a name="61"/>#  XPMImage(f, palette) reads an XPM (X Pixmap) format image from
<a name="62"/>#  the open file f and returns an Icon image specification that uses the
<a name="63"/>#  specified palette.  XPMImage() fails if it cannot decode the file.
<a name="64"/>#   if palette is omitted, "c1" is used.
<a name="65"/>#  Not all variants of XPM format are handled; in particular, images that
<a name="66"/>#  use more than one significant input character per pixel, or that use
<a name="67"/>#  the old XPM Version 1 format, cause XPMImage() to fail.  No window
<a name="68"/>#  is required, but X-specific color names like "papayawhip" will not
<a name="69"/>#  be recognized without a window.
<a name="70"/>#
<a name="71"/>############################################################################
<a name="72"/>#
<a name="73"/>#  Links: graphics
<a name="74"/>#
<a name="75"/>############################################################################
<a name="76"/>#
<a name="77"/>#  Requires:  Version 9 graphics
<a name="78"/>#
<a name="79"/>############################################################################
<a name="80"/>
<a name="81"/>package ipl.imscolor
<a name="82"/>
<a name="83"/>import
<a name="84"/>   graphics(Window),
<a name="85"/>   io(read, write, need_Stream),
<a name="86"/>   ipl.graphics(CenterString, Contrast),
<a name="87"/>   util(Math)
<a name="88"/>
<a name="89"/>
<a name="90"/>#  imspalette(im) -- return palette used by image
<a name="91"/>
<a name="92"/># palette for image
<a name="93"/>procedure imspalette(im)			
<a name="94"/>   im ? {tab(upto(',') + 1) &amp; return ((="#" &amp; &amp;null) | tab(upto(',')))}
<a name="95"/>end
<a name="96"/>
<a name="97"/>
<a name="98"/>#  imswidth(im) -- return width of image
<a name="99"/>
<a name="100"/># width of image
<a name="101"/>procedure imswidth(im)				
<a name="102"/>   im ? return integer(tab(upto(',')))
<a name="103"/>end
<a name="104"/>
<a name="105"/>
<a name="106"/>#  imsheight(im) -- return height of image
<a name="107"/>
<a name="108"/># height of image
<a name="109"/>procedure imsheight(im)				
<a name="110"/>   local pal, w, n, d, c
<a name="111"/>
<a name="112"/>   im ? {
<a name="113"/>      w := integer(tab(upto(','))) | fail
<a name="114"/>      move(1)
<a name="115"/>      if ="#" then {
<a name="116"/>         n := IMH_Count('0123456789ABCDEFabcdef')
<a name="117"/>         d := (w + 3) / 4
<a name="118"/>         return (n + d - 1) / d
<a name="119"/>         }
<a name="120"/>      pal := tab(upto(',')) | fail
<a name="121"/>      move(1)
<a name="122"/>      c := cset(Window.palette_chars(pal)) | fail
<a name="123"/>      n := IMH_Count(c ++ '~\xFF')
<a name="124"/>      return (n + w - 1) / w
<a name="125"/>      }
<a name="126"/>end
<a name="127"/>
<a name="128"/># count remaining chars that are in cset c
<a name="129"/>procedure IMH_Count(c)		
<a name="130"/>   local n
<a name="131"/>
<a name="132"/>   n := 0
<a name="133"/>   while tab(upto(c)) do
<a name="134"/>      n +:= *tab(many(c))
<a name="135"/>   return n
<a name="136"/>end
<a name="137"/>
<a name="138"/>
<a name="139"/>#  imsmap(s1, s2, s3) -- map the data (only) of an image string
<a name="140"/>
<a name="141"/># map data of image string
<a name="142"/>procedure imsmap(s1, s2, s3)			
<a name="143"/>   s1 ? return tab(upto(',')+1) || tab(upto(',')+1) || map(tab(0), s2, s3)
<a name="144"/>end
<a name="145"/>
<a name="146"/>
<a name="147"/>#  imswrite(f, s, n) -- write image string s to file f, max linelength of n.
<a name="148"/>
<a name="149"/># write image string
<a name="150"/>procedure imswrite(f, s, n)			
<a name="151"/>   local w, h, p, d, ll
<a name="152"/>
<a name="153"/>   w := imswidth(s) | fail
<a name="154"/>   h := imsheight(s) | fail
<a name="155"/>   p := imspalette(s) | fail
<a name="156"/>
<a name="157"/>   if /p then				# if bilevel image
<a name="158"/>      d := (w + 3) / 4			# number of digits per row
<a name="159"/>   else
<a name="160"/>      d := w
<a name="161"/>
<a name="162"/>   /n := 79
<a name="163"/>
<a name="164"/>   # Figure out a reasonable line length for output, with n as maximum
<a name="165"/>   n -:= 1				# allow for underscore
<a name="166"/>   if upto('\0', Window.palette_chars(\p)) then
<a name="167"/>      n /:= 4				# allow for escapes
<a name="168"/>   ll := 1 + (n &gt; (d - 1) / seq(1))	# divide line as equally as possible
<a name="169"/>
<a name="170"/>   # Write the image as a multiline string constant.
<a name="171"/>   s ? {
<a name="172"/>      tab(upto(',') + 1)
<a name="173"/>      ="#" | tab(upto(',') + 1)
<a name="174"/>      write(f, "\"", w, ",", (\p || ",") | "#", "_")
<a name="175"/>      until pos(0) do IWR_Row(f, move(d) | tab(0), ll)
<a name="176"/>      write(f, "\"")
<a name="177"/>      }
<a name="178"/>   return
<a name="179"/>end
<a name="180"/>
<a name="181"/># write one row, max n bytes per line
<a name="182"/>procedure IWR_Row(f, s, n)	
<a name="183"/>   s ? until pos(0) do
<a name="184"/>      write(f, image(move(n) | tab(0)) [2:-1], "_")
<a name="185"/>   return
<a name="186"/>end
<a name="187"/>
<a name="188"/>
<a name="189"/>#  drawpalette(win, p, x, y, w, h, f, n) -- draw palette in region
<a name="190"/>
<a name="191"/># draw palette
<a name="192"/>procedure drawpalette(win, p, x, y, w, h, f, n)	
<a name="193"/>   local nh, c, s, colr, x1, x2, y1, y2, i, j, ret, r
<a name="194"/>   static cs
<a name="195"/>   initial cs := &amp;ascii[33+:95] -- '\\'
<a name="196"/>
<a name="197"/>   ret := win
<a name="198"/>   win := win.clone().set_fg("black")
<a name="199"/>
<a name="200"/>   /p := "c1"
<a name="201"/>   /f := ""
<a name="202"/>
<a name="203"/>   r := win.canonical(x, y, w, h)
<a name="204"/>   x := r.x; y := r.y; w := r.width; h := r.height
<a name="205"/>
<a name="206"/>   s := PAL_Order(p) | fail
<a name="207"/>   /n := PAL_Columns(p, s, w, h)
<a name="208"/>   nh := (*s + n - 1) / n
<a name="209"/>
<a name="210"/>   win.erase_area(x, y, w, h)
<a name="211"/>   if f ? upto('o') then {
<a name="212"/>      w -:= 1
<a name="213"/>      h -:= 1
<a name="214"/>      }
<a name="215"/>
<a name="216"/>   i := j := 0
<a name="217"/>   every c := !s do {
<a name="218"/>      x1 := x + j * w / n
<a name="219"/>      x2 := x + (j + 1) * w / n
<a name="220"/>      y1 := y + i * h / nh
<a name="221"/>      y2 := y + (i + 1) * h / nh
<a name="222"/>      win.set_fg(colr := Window.palette_color(p, c)) | (ret := &amp;null)
<a name="223"/>      win.fill_rectangle(x1, y1, x2 - x1, y2 - y1)
<a name="224"/>      if upto('l', f) then {
<a name="225"/>         win.set_fg(Contrast(win, colr))
<a name="226"/>         unless upto(cs, c) then
<a name="227"/>            c := image(c)[-3:-1]
<a name="228"/>         CenterString(win, (x1 + x2) / 2, (y1 + y2) / 2, c)
<a name="229"/>         }
<a name="230"/>      if upto('o', f) then {
<a name="231"/>         win.set_fg("black")
<a name="232"/>         win.draw_rectangle(x1, y1, x2 - x1, y2 - y1)
<a name="233"/>         }
<a name="234"/>      if (j +:= 1) &gt;= n then {
<a name="235"/>         j := 0
<a name="236"/>         i +:= 1
<a name="237"/>         }
<a name="238"/>      }
<a name="239"/>
<a name="240"/>   # if some cells are unfilled, and the 'u' flag is not given,
<a name="241"/>   # hash the unfilled cells with a diagonal pattern.
<a name="242"/>   if j &gt; 0 &amp; not upto('u', f) then {
<a name="243"/>      x1 := x + j * w / n
<a name="244"/>      y1 := y + i * h / nh
<a name="245"/>      x2 := x + w
<a name="246"/>      y2 := y + h
<a name="247"/>      win.set_fg("black").set_textured_pattern("diagonal")
<a name="248"/>      win.fill_rectangle(x1, y1, x2 - x1, y2 - y1)
<a name="249"/>      if upto('o', f) then {
<a name="250"/>         win.set_pattern()
<a name="251"/>         win.draw_rectangle(x1, y1, x2 - x1, y2 - y1)
<a name="252"/>         }
<a name="253"/>      }
<a name="254"/>
<a name="255"/>   win.close()
<a name="256"/>   return \ret
<a name="257"/>end
<a name="258"/>
<a name="259"/>
<a name="260"/>#  pickpalette(win, p, dx, dy, w, h, n) -- return key picked from drawn palette
<a name="261"/>
<a name="262"/># key from drawn palette
<a name="263"/>procedure pickpalette(win, p, dx, dy, w, h, n)	
<a name="264"/>   local s, nh
<a name="265"/>
<a name="266"/>   /w := win.get_width()
<a name="267"/>   /h := win.get_height()
<a name="268"/>   if dx &lt; 0 | dy &lt; 0 | dx &gt;= w | dy &gt;= h then
<a name="269"/>      fail
<a name="270"/>
<a name="271"/>   s := PAL_Order(p) | fail
<a name="272"/>   /n := PAL_Columns(p, s, w, h)
<a name="273"/>   nh := (*s + n - 1) / n
<a name="274"/>
<a name="275"/>   dx := ((dx + 1) * n - 1) / w
<a name="276"/>   dy := ((dy + 1) * nh - 1) / h
<a name="277"/>   return s[1 + n * dy + dx]
<a name="278"/>end
<a name="279"/>
<a name="280"/>
<a name="281"/>#  PAL_Columns(p, s, w, h) -- calc columns for auto-layout (internal routine)
<a name="282"/>#
<a name="283"/>#  p is palette name; s is character string; w,h are available dimensions
<a name="284"/>
<a name="285"/>procedure PAL_Columns(p, s, w, h)
<a name="286"/>   local nw, nh
<a name="287"/>
<a name="288"/>   return case p of {
<a name="289"/>      "c1":	return 6
<a name="290"/>      "c2":	return 2
<a name="291"/>      "c3":	return 3
<a name="292"/>      "c4":	return 4
<a name="293"/>      "c5":	return 5
<a name="294"/>      "c6":	return 6
<a name="295"/>      default: {
<a name="296"/>	 nw := integer(w / Math.sqrt(w * h / *s))
<a name="297"/>         nw &lt;:= 1
<a name="298"/>         nh := (*s + nw - 1) / nw
<a name="299"/>         nh &lt;:= 1
<a name="300"/>         return (*s + nh - 1) / nh
<a name="301"/>	 }
<a name="302"/>      }
<a name="303"/>end
<a name="304"/>
<a name="305"/>
<a name="306"/>#  PAL_Order(p) -- return reordered palette chars (internal routine)
<a name="307"/>#
<a name="308"/>#  Normal order for color cube is sorted r/g/b, then extra grays.
<a name="309"/>#  Reorder by g/r/b followed by full set of grays, including duplicates,
<a name="310"/>#  back to black.  Returns unmodified list of characters for c1 and
<a name="311"/>#  grayscale palettes.
<a name="312"/>
<a name="313"/>procedure PAL_Order(p)
<a name="314"/>   local palchars, s, t, n, n3, i, l
<a name="315"/>
<a name="316"/>   palchars := Window.palette_chars(p) | fail
<a name="317"/>
<a name="318"/>   p ? {
<a name="319"/>      unless ="c" &amp; any('23456') then return palchars
<a name="320"/>      n := integer(move(1))
<a name="321"/>      }
<a name="322"/>
<a name="323"/>   palchars ? {
<a name="324"/>
<a name="325"/>      l := list(n, "")
<a name="326"/>      n3 := n * n * n
<a name="327"/>      while &amp;pos &lt;= n3 do
<a name="328"/>         every !l ||:= (move(n) \ 1)
<a name="329"/>      s := ""
<a name="330"/>      every s ||:= !l		# build g/r/b cube portion
<a name="331"/>
<a name="332"/>      t := ""
<a name="333"/>      every i := 1 to (n3 - 1) by (n * (n + 1) + 1) do
<a name="334"/>         t ||:= palchars[i] || move(n - 1)
<a name="335"/>      }
<a name="336"/>
<a name="337"/>   return s || reverse(t)
<a name="338"/>end
<a name="339"/>
<a name="340"/>
<a name="341"/>#  XPMImage(win, f, palette) -- read XPM file and return Icon image spec
<a name="342"/>
<a name="343"/># image string for XPM file
<a name="344"/>procedure XPMImage(f, pal)			
<a name="345"/>   local w, h, nc, cpp, i, im, c, k, s1, s2
<a name="346"/>
<a name="347"/>   /pal := "c1"
<a name="348"/>   need_Stream(f)
<a name="349"/>   Window.palette_chars(pal) | runerr(205, f)
<a name="350"/>
<a name="351"/>   (read(f) ? find("XPM")) | fail
<a name="352"/>   (XPM_RdStr(f) | fail) ? {
<a name="353"/>      tab(many(' \t'));  w := tab(many(&amp;digits)) | fail
<a name="354"/>      tab(many(' \t'));  h := tab(many(&amp;digits)) | fail
<a name="355"/>      tab(many(' \t'));  nc := tab(many(&amp;digits)) | fail
<a name="356"/>      tab(many(' \t'));  cpp := tab(many(&amp;digits)) | fail
<a name="357"/>   }
<a name="358"/>   if w = 0 | h = 0 then
<a name="359"/>      fail
<a name="360"/>
<a name="361"/>   # read colors and figure out translation
<a name="362"/>   s1 := s2 := ""
<a name="363"/>   every i := 1 to nc do (XPM_RdStr(f) | fail) ? {
<a name="364"/>      s1 ||:= move(1)
<a name="365"/>      if cpp &gt; 1 then
<a name="366"/>         =" " | fail			# if not blank, we can't handle it
<a name="367"/>      k := &amp;null
<a name="368"/>      # find a color key we can decipher; try color, then grayscale, then mono
<a name="369"/>      (c := !"cgm") &amp; tab(upto(' \t') + 1) &amp; =c &amp; tab(many(' \t')) &amp;
<a name="370"/>         (k := XPM_Key(pal, (tab(upto(' \t') | 0))))
<a name="371"/>      # use first color found, or default if none
<a name="372"/>      s2 ||:= \k | Window.palette_key(pal, "gray")
<a name="373"/>      }
<a name="374"/>
<a name="375"/>   # construct image
<a name="376"/>   im := w || "," || pal || ","
<a name="377"/>   if cpp = 1 then
<a name="378"/>      while im ||:= map(XPM_RdStr(f), s1, s2)
<a name="379"/>   else
<a name="380"/>      while im ||:= map(XPM_Nth(XPM_RdStr(f), cpp), s1, s2)
<a name="381"/>   return im
<a name="382"/>end
<a name="383"/>
<a name="384"/># return key corresponding to color s
<a name="385"/>procedure XPM_Key(pal, s)	
<a name="386"/>
<a name="387"/>   if s == "None" then {		# if transparent
<a name="388"/>      if Window.palette_color(pal, "~") then	# if "~" is in palette
<a name="389"/>         return "\xFF"			# then use "\xFF" for transparent
<a name="390"/>      else
<a name="391"/>         return "~"			# but use "~" if possible
<a name="392"/>      }
<a name="393"/>
<a name="394"/>   return Window.palette_key(pal, s)	# return key from palette, or fail
<a name="395"/>end
<a name="396"/>
<a name="397"/># read next C string from file f
<a name="398"/>procedure XPM_RdStr(f)		
<a name="399"/>   local line, s
<a name="400"/>
<a name="401"/>   while line := read(f) do line ? {
<a name="402"/>      tab(many(' \t'))
<a name="403"/>      ="\"" | next
<a name="404"/>      if s := tab(upto('"')) then
<a name="405"/>         return s
<a name="406"/>      }
<a name="407"/>   fail
<a name="408"/>end
<a name="409"/>
<a name="410"/># concatenate every nth character from s
<a name="411"/>procedure XPM_Nth(s, n)		
<a name="412"/>   local t
<a name="413"/>   n -:= 1
<a name="414"/>   t := ""
<a name="415"/>   s ? while t ||:= move(1) do
<a name="416"/>      move(n)
<a name="417"/>   return t
<a name="418"/>end
</pre></body></html>
