package ipl.server9p

import io, posix, ipl.options, util, gui

global opts, mountpt

# Return the standard list of options for a file server.  These may be
# added to as desired by a particular program.
#
procedure get_optl()
   return [Opt("v",, "Verbose mode"),
           Opt("q",, "Don't output messages about mount points, etc."),
           Opt("m",string, "PATH#Use PATH as the mount point, rather than the default, " || get_mountpt()),
           Opt("s",string, "FILE#Don't mount, instead post the pipe in /srv/FILE"),
           Opt("S",string, "FILE#Like -s, but mount in addition to posting"),
           Opt("a",, "Use the MAFTER flag when mounting"),
           Opt("b",, "Use the MBEFORE flag when mounting"),
           Opt("c",, "Use the MCREATE flag when mounting"),
           Opt("C",, "Use the MCACHE flag when mounting")]
end

# Return the default mountpoint, based on the server program name.
# This default may be changed by assigning to the global variable
# `mountpt`.
#
procedure get_mountpt()
   local s
   if /mountpt then {
      s :=  Files.get_program_name()
      if s[-2:0] == "fs" then
         s[-2:0] := ""
      mountpt := "/n/" || s
   }
   return mountpt
end

# Output a message to stdout, unless the -q option was given.
#
procedure server_msg(a[])
   if /opts["q"] then {
      push(a, Files.get_program_name() || ": ")
      write!a
   }
end

# Main helper procedure for a server which doesn't use an attach
# parameter.
#
# :Parameters :
# :  `a` - the command line arguments list
# :  `sess` - the `plan9.Session9P` instance to use
# :  `sched` - an optional `io.Scheduler` to use for asynchronous servers
# :  `optl` - the options list
# :  `ff` - optional extra flags to give to `fork` when creating the child
#           process.
#
procedure server_main_0(a, sess, sched, optl, ff)
   /optl := get_optl()
   opts := options(a, optl, 
                   "Usage: " || Files.get_program_name() || " [OPTIONS]")
   server_main(, sess, sched, ff)
end

# Main helper procedure for a server which uses an optional attach
# parameter.
#
# :Parameters :
# :  `a` - the command line arguments list
# :  `sess` - the `plan9.Session9P` instance to use
# :  `sched` - an optional `io.Scheduler` to use for asynchronous servers
# :  `optl` - the options list
# :  `ff` - optional extra flags to give to `fork` when creating the child
#           process.
#
procedure server_main_1(a, sess, sched, optl, ff)
   local attach
   /optl := get_optl()
   opts := options(a, optl,
                   "Usage: " || Files.get_program_name() || " [OPTIONS] [ATTACH]")
   if /opts["s"] then {
      if *a = 0 then
         help_stop("Use the -s option or provide an attach parameter.")
      attach := a[1]
   }
   server_main(attach, sess, sched, ff)
end

# Main helper procedure.  This is called by `server_main_0` and
# `server_main_1` after options processing.  Servers which wish to do
# their own custom options processing and other initializations may
# wish to call this procedure directly.
#
# :Parameters :
# :  `attach` - the optional attach parameter; ignored if the `s` options
#           is set in `opts`.
# :  `sess` - the `plan9.Session9P` instance to use
# :  `sched` - an optional `io.Scheduler` to use for asynchronous servers.  If
#           given the `asynch_sched_loop()` below is used.
# :  `ff` - optional extra flags to give to `fork` when creating the child
#           process.
#
procedure server_main(attach, sess, sched, ff)
   local p, pid, fl, s, mp
   p := FileStream.pipe() | stop(&why)
   /ff := 0
   ff := ior(ff, ForkOpt.RFPROC, ForkOpt.RFFDG, ForkOpt.RFNOTEG, ForkOpt.RFREND)
   pid := System.fork(ff) | stop(&why)
   if pid = 0 then {
      p[1].close()
      if \opts["v"] then 
         sess.set_verbose(&yes)
      if /sched then
         sess.io(p[2])
      else
         async_sched_loop(sess, sched, p[2])
      p[2].close()
      if \opts["v"] then {
         sess.dump()
         system("cat /proc/" || System.getpid() || "/fd")
      }
      server_msg("Exit")
   } else {
      sess := &null
      p[2].close()
      if s := "/srv/" || \opts["s" | "S"] then {
         Files.string_to_file(s, p[1].get_fd()) | stop(&why)
         server_msg("Serving on ", s)
      }
      if /opts["s"] then {
         mp := \opts["m"] | get_mountpt()
         fl := if \opts["a"] then
            MountOpt.MAFTER
         else if \opts["b"] then
            MountOpt.MBEFORE
         else
            MountOpt.MREPL
         if \opts["c"] then
            fl := ior(fl, MountOpt.MCREATE)
         if \opts["C"] then
            fl := ior(fl, MountOpt.MCACHE)
         Files.mount(p[1], &null, mp, fl, attach) | stop(&why)
         server_msg("Mounted on ", mp)
      }
      p[1].close()
   }
   exit()
end

# A helper method to loop repeatedly, processing messages using the
# given session's `async_io` method.
#
# :Parameters :
# :  `sess` - the `plan9.Session9P`
# :  `sched` - the `io.Scheduler` 
# :  `f` - the pipe from which to process messages.  This is not
#          closed by this procedure.
#
procedure async_sched_loop(sess, sched, f)
   local nb
   use {
      nb := NonBlockStream(f).set_close_underlying(&no),
      {
         sess.async_io(sched, nb)
         # Main loop
         until sched.empty() do
            sched.work_or_sleep()
      }
   }
end

# Main helper procedure for a gui program that also acts as a file server.
#
# :Parameters :
# :  `attach` - the optional attach parameter; ignored if the `s` options
#           is set in `opts`.
# :  `sess` - the `plan9.Session9P` instance to use
# :  `async_flag` - a flag indicating whether the session should process
# :         each message in a background `Task`.
# :  `sched` - an optional `io.Scheduler` to use for asynchronous servers
# :  `body` - a co-expression giving the main body of the program
# :  `ff` - optional extra flags to give to `fork` when creating the child
#           process.
#
procedure gui_main(attach, sess, async_flag, body, ff)
   local p, pid, nb, fl, s, mp
   p := FileStream.pipe() | stop(&why)
   /ff := 0
   ff := ior(ff, ForkOpt.RFPROC, ForkOpt.RFFDG)
   pid := System.fork(ff) | stop(&why)
   if pid = 0 then {
      # child
      p[1].close()
      if \opts["v"] then 
         sess.set_verbose(&yes)
      use {
         nb := NonBlockStream(p[2]),
         {
            if /async_flag then
               sess.io_task(Dispatcher.scheduler, nb)
            else
               sess.async_io(Dispatcher.scheduler, nb)
            @body
         }
      }
      if \opts["v"] then {
         sess.dump()
         system("cat /proc/" || System.getpid() || "/fd")
      }
   } else {
      # parent
      p[2].close()
      if s := "/srv/" || \opts["s" | "S"] then {
         Files.string_to_file(s, p[1].get_fd()) | stop(&why)
         server_msg("Serving on ", s)
      }
      if /opts["s"] then {
         mp := \opts["m"] | get_mountpt()
         fl := if \opts["a"] then
            MountOpt.MAFTER
         else if \opts["b"] then
            MountOpt.MBEFORE
         else
            MountOpt.MREPL
         if \opts["c"] then
            fl := ior(fl, MountOpt.MCREATE)
         if \opts["C"] then
            fl := ior(fl, MountOpt.MCACHE)
         Files.mount(p[1], &null, mp, fl, attach) | stop(&why)
         server_msg("Mounted on ", mp)
      }
      System.wait(pid)
      if \s then {
         Files.remove(s)
         server_msg("Removed ", s)
      }
      if \mp then {
         Files.unmount(&null, mp)
         server_msg("Unmounted ", mp)
      }
      p[1].close()
      server_msg("Exit")
   }
   exit()
end
