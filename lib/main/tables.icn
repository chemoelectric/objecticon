#
# $Id$
#

package datastruct

import
   lang,
   util,
   ipl.tables(tbldflt),
   ipl.pdco(Index),
   ipl.sort(need_callable_def)

record Entry(key, val)

#
# This is a common superclass for several table-like data structures.
#
# A subclass must implement different optional methods depending on
# its capability mode, as follows :-
#
#  * `ORDER` - `back_key()`, `rank()` and `select()`
#  * `INSERT` - `insert()`, `add()`
#  * `DELETE` - `delete()`
#
# There are several other abstract methods which all classes must of
# course implement, and others which may be overridden to provide more
# efficient implementations than the default.
#
# Note that the behaviour of the various generator methods should the
# table be concurrently modified during the course of generation,
# depends upon the particular table implementation.
#
abstract class Table(HasMode, ObjectOutput, ObjectHash, ObjectEquals)
   public const
      # The table's default value.
      def

   public static const
      # Empty table implementation
      EMPTY_TABLE,
      # Constant indicating modifiable capability
      MODIFY,
      # Constant indicating insert capability
      INSERT,
      # Constant indicating delete capability
      DELETE,
      # Constant indicating keys are stored in order
      ORDER

   private static init()
      EMPTY_TABLE := EmptyTable()
      MODIFY := 1
      INSERT := 2
      DELETE := 4
      ORDER := 8
   end
   
   #
   # Insert a new entry, or change an existing one.  Always succeeds
   # and returns `self`.  Only implemented with INSERT capability.
   #
   public optional insert(key, val)

   #
   # Return the value for the given key if it is in the table, or fail
   # if it is not present.  If the table has MODIFY capability, a
   # variable is returned; otherwise the value.
   #
   public abstract member(key)
   
   #
   # Delete the entry with the given key.  Fails if the key was not
   # present, otherwise succeeds and returns `self`.  Only implemented
   # with DELETE capability.
   #
   public optional delete(key)

   #
   # Return the value with the given key, or the default value if
   # the key is not present.  Equivalent to `.t[k]` for a table.
   #
   public get(key)
      return .member(key) | def
   end

   #
   # Like `member`, but if the key is not present a new entry is added
   # (with the default value).  If the table has MODIFY capability, a
   # variable for the new entry is returned, otherwise a value is
   # returned.  Only implemented with INSERT capability.
   #
   # Example :-
   # ~
   #    # Word counting
   #    t := SortTable(0)
   #    every w := words() do
   #       t.add(w) +:= 1
   # ~
   public optional add(key)

   #
   # Return a sorted list of key-value pairs.
   #
   public sort()
      local l
      l := entry_list()
      return if can(ORDER) then l else sortf(l, 1)
   end

   #
   # Return a sorted list of keys.
   #
   public key_sort()
      # This is defined in terms of sort() above rather than just
      # sorting key_list(), so that classes with a custom sort()
      # ordering don't need to override both sort methods.
      return if can(ORDER) then key_list() else ipl.pdco.List{ (!sort())[1] }
   end

   #
   # Generate the keys (cf the builtin key() function).  With ORDER
   # capability, the keys are generated in sorted order, starting with
   # the key at index `i` (default 1).
   #
   public abstract key(i)

   #
   # Generate alternating key/value pairs (cf the builtin keyval()
   # function.)  If the table has MODIFY capability, the entry values
   # will be generated as variables, otherwise as values.  With ORDER
   # capability, the pairs are generated in sorted key order, starting
   # with the key at index `i` (default 1).
   #
   public keyval(i)
      suspend key_member(key(i))
   end

   #
   # Generate the keys in reverse order, starting with the key before
   # index `i` (thus generating the elements in the range 1:i); `i`
   # defaults to 0.  Only implemented with ORDER capability.
   #
   public optional back_key(i)

   #
   # Helper method to suspend the key `k` and its corresponding entry.
   #
   public key_member(k)
      suspend k | member(k)
   end

   #
   # Generate alternating key/value pairs, starting with the key
   # before index `i` (thus generating the elements in the range 1:i);
   # `i` defaults to 0.  If the table has MODIFY capability, the entry
   # values will be generated as variables, otherwise as values.  Only
   # implemented with ORDER capability.
   #
    public back_keyval(i)
      suspend key_member(back_key(i))
   end

   #
   # Return the rank of the given key, ie its order number in the
   # table; fails if there is no matching key in the table.  Only
   # implemented for tables with ORDER capability.
   #
   public optional rank(key)

   #
   # Return the `i`th key, in order, in the table.  Fails if `i` is
   # out of range, using standard icon indexing semantics.  Only
   # implemented for tables with ORDER capability.
   #
   public optional select(i)

   #
   # Generate the values (cf !t for a table).  If the table has MODIFY
   # capability, variables are generated, otherwise values are
   # generated.  With ORDER capability, the values are generated in
   # the order corresponding to the sorted key order, starting with
   # the key at index `i` (default 1).
   #
   public gen(i)
      suspend member(key(i))
   end

   #
   # Generate the values in reverse order, starting with the value
   # corresponding to the key before index `i` (thus generating the
   # values in the range 1:i); `i` defaults to 0.  Only implemented
   # with ORDER capability.  If the table has MODIFY capability,
   # variables are generated, otherwise values are generated.
   #
   public back(i)
      suspend member(back_key(i))
   end

   #
   # Return the size of the table.
   #
   public abstract size()
      
   #
   # Succeed iff the size is zero.
   #
   public empty()
      succeed size() = 0
   end

   #
   # Return a random value (cf ?t for a table).  If the table has MODIFY
   # capability, a variable is returned, otherwise a value is returned.
   #
   public random()
      return member(random_key())
   end

   #
   # Return a random key.
   #
   public random_key()
      local r
      if r := ?(0 < size()) then
         return if can(ORDER) then select(r) else Index{ key(), r }
   end

   #
   # Clear the table of all elements. Always succeeds and returns
   # `self`.  Only implemented with DELETE capability.
   #
   public clear()
      while delete(key())
      link
   end

   #
   # Generate key-value pairs as a sequence of `Entry` records.  NB -
   # for each invocation, the same record is returned every time, with
   # the values replaced.
   #
   public entries()
      suspend Entries{ keyval() }
   end

   #
   # Return a flat list, with alternating key-value entries.
   #
   public flatten()
      return ipl.pdco.List{ keyval() }
   end

   #
   # Return a list of the keys; it will be sorted if the table has
   # ORDER capability.
   #
   public key_list()
      return ipl.pdco.List{ key() }
   end

   #
   # Return a list of pairs of key-values; it will be sorted by key if
   # the table has ORDER capability.
   #
   public entry_list()
      return EntryList{ keyval() }
   end

   #
   # Custom equals mirrors the `equals()` behaviour for builtin tables.
   #
   private override object_equals(other, seen)
      other.size() = self.size() | fail
      equals(other.def, self.def, seen) | fail
      return hash_and_check(other.entry_list(), self.entry_list(), seen)
   end

   #
   # Custom hash mirrors the `hash()` behaviour for builtin tables.
   #
   private override object_hash(depth)
      local n
      n := size()
      if depth > 1 then {
         n +:= hash(def, depth - 1)
         every n +:= hash(key(), depth - 1)
      }
      return n
   end

   #
   # Output object
   #
   private override object_output(oo)
      local pairs, e, sep
      pairs := sort()
      if oo.simple{!!pairs | def} then {
         oo.object_start(self)
         if \def then {
            oo.writes1("default=").
               traverse(def)
            sep := &yes
         }
         every e := !pairs do {
            if \sep then
               oo.writes1(";")
            oo.traverse(e.key).
               writes1("->").
               traverse(e.val)
            sep := &yes
         }
         oo.object_end(self)
      } else {
         oo.nl().
            object_start(self).
            iplus()
         if \def then {
            oo.nl().
               writes1("default=").
               iplus().
               traverse(def).
               iminus()
         }
         every e := !pairs do {
            oo.nl().
               traverse(e.key).
               writes1("->").
               iplus().
               traverse(e.val).
               iminus()
         }
         oo.iminus().
            nl().
            object_end(self)
      }
   end

   protected init_entries(entries)
      if *entries % 2 ~= 0 then
          runerr(168)
      while *entries > 0 do
         insert(default.get(entries), default.get(entries))
   end
end

#
# Given a co-expression `e` generating successive key and value pairs,
# generate a corresponding sequence of `Entry` records.  NB - for each
# invocation, the same record is returned every time, with the values
# replaced.
#
procedure Entries(e)
   local r, x, f
   r := Entry()
   while x := @e do {
      if /f then {
         r.key := x
         f := &yes
      } else {
         r.val := x
         suspend r
         f := &null
      }
   }
end

#
# Given a co-expression `e` generating successive key and value pairs,
# return a corresponding list of `Entry` records.
#
procedure EntryList(e)
   return ipl.pdco.List{ |Entry(@e, @e) }
end

#
# A helpful abstract class for a table with `ORDER` capability, which
# wishes to implement the generator methods `key()` and `back_key()`
# in terms of `select()`.
#
# In the case of changes to the table during generation, the methods
# behave like the builtin `forward()` and `back()` functions.
#
abstract class OrderTableImpl1(Table)
   public override key(i)
      if i := first_forward(i, size()) then
         suspend |1(select(i), i +:= 1)
   end

   public override back_key(i)
      if i := first_back(i, size()) then
         suspend |1(select(i), i -:= 1)
   end
end

#
# A helpful abstract class for a table with `ORDER` capability, which
# wishes to implement `select()` in terms of `key()`.
#
abstract class OrderTableImpl2(Table)
   public override select(i)
      return Index{ key(), cvpos_item(i, size()) }
   end
end

#
# A helpful abstract class for a table with `INSERT` capability, which
# wishes to implement `insert()` in terms of `add()`.
#
abstract class InsertTableImpl1(Table)
   public override insert(key, val)
      add(key) := val
      link
   end
end

#
# A helpful abstract class for a table with `INSERT` capability, which
# wishes to implement `add()` in terms of `member()` and `insert()`.
#
abstract class InsertTableImpl2(Table)
   public override add(key)
      return member(key) | (insert(key, def) & member(key))
   end
end

#
# A class to provide an unmodifiable view of another table.
#
class UnmodifiableTable(Table)
   protected const
      t

   public override member(key)
      return .t.member(key)
   end

   public override key(i)
      suspend t.key(i)
   end

   public override keyval(i)
      suspend .t.keyval(i)
   end

   public override back_key(i)
      suspend t.back_key(i)
   end

   public override back_keyval(i)
      suspend .t.back_keyval(i)
   end

   public override rank(key)
      return t.rank(key)
   end

   public override select(i)
      return t.select(i)
   end

   public override gen(i)
      suspend .t.gen(i)
   end

   public override back(i)
      suspend .t.back(i)
   end

   public override size()
      return t.size()
   end

   public override empty()
      return t.empty()
   end

   public override random()
      return .t.random()
   end

   public override get_mode()
      return iand(ORDER, t.get_mode())
   end

   public new(t)
      self.t := need_instance(t, Table)
      self.def := t.def
      return
   end
end

#
# A list-view of the keys of a table with ORDER capability.  Note that
# this implementation uses the table's generator methods to generate
# the list elements; these may behave differently from the
# corresponding builtin list generators if the underlying table is
# concurrently modified.
#
class TableKeyList(List)
   protected const
      t

   public override at(i)
      return t.select(i)
   end

   public override gen(i)
      suspend t.key(i)
   end

   public override back(i)
      suspend t.back_key(i)
   end

   public override delete(i)
      link t.delete(t.select(i))
   end

   public override size()
      return t.size()
   end

   public override clear()
      t.clear()
      link
   end

   public override get_mode()
      return iand(DELETE, t.get_mode())
   end

   public new(t)
      self.t := need_instance(t, Table)
      t.can(Table.ORDER) | runerr("Table doesn't have ORDER capability", t)
      return
   end
end

#
# A node in a `SortTable` tree.
#
final class SortTableNode()
   public const
      key
   public
      val
   package
      l, r, p, is_red_flag, N

   #
   # Return the next node by sorted order within the enclosing tree,
   # or fail if there is none.
   #
   public get_next()
      local t, c
      need_linked()
      if t := \r then {
         while t := \t.l
         return t
      } else {
         c := self
         while t := c.p.real() do {
            if c === t.l then
               return t
            c := t
         }
      }
   end

   #
   # Return the previous node by sorted order within the enclosing
   # tree, or fail if there is none.
   #
   public get_prev()
      local t, c
      need_linked()
      if t := \l then {
         while t := \t.r
         return t
      } else {
         c := self
         while t := c.p.real() do {
            if c === t.r then
               return t
            c := t
         }
      }
   end

   #
   # Move along the ordered sequence of nodes `i` places; positive
   # means increasing key order, negative means decreasing.  Returns
   # the node at that position, or fail if either end of the sequence
   # is encountered.
   #
   public move(i)
      local n
      i := need_integer(i)
      need_linked()
      n := self
      if i > 0 then {
         every 1 to i do
            n := n.get_next() | fail
      } else {
         every 1 to -i do
            n := n.get_prev() | fail
      }
      return n
   end

   #
   # Check if this node is "linked" (hasn't been unlinked), signalling
   # a runtime error otherwise.
   #
   public need_linked()
      \N | runerr("Node has been unlinked", self)
      link
   end

   #
   # Succeed iff this node is "linked" (meaning it hasn't been
   # deleted from its tree).
   #
   public is_linked()
      succeed \N
   end

   #
   # Generate this node and all subsequent nodes in the sort order in
   # the enclosing tree.
   #
   # Changes to the tree structure are permitted during iteration,
   # with the exception that the last node generated may not be
   # removed from the tree ("unlinked") before the next result is
   # generated; if it is then a runtime error is immediately raised.
   #
   # In order to iterate over the tree and remove selected nodes, a
   # loop using `move_unlink` may be used instead.
   #
   public gen()
      local n
      need_linked()
      n := self
      repeat {
         suspend n
         n := n.get_next() | fail
      }
   end

   #
   # Generate this node and all prior nodes in the sort order in the
   # enclosing tree.
   #
   # See also `gen()` for a tree modification limitation (the same
   # applies to this method).
   #
   public back()
      local n
      need_linked()
      n := self
      repeat {
         suspend n
         n := n.get_prev() | fail
      }
   end

   #
   # Return the `SortTable` associated with this node, which
   # must be "linked".
   #
   # This method works by moving up the tree to the root node, whose
   # "parent" is a special object which contains a link to the
   # enclosing tree.
   #
   # If this tree of nodes was orphaned because the parent tree
   # performed a `clear()`, then this method fails.
   #
   public get_tree()
      local n
      need_linked()
      n := p
      while n := n.real().p
      return \n.tree
   end

   #
   # Remove this node from its tree.
   #
   # After a node has been unlinked it cannot be used for further
   # operations, and any attempt to do so will cause a runtime error.
   # (See also `is_linked`).
   #
   # Example :-
   # ~
   #   t := SortTable(,, "Cat", 12, "Mouse", 2, "Gerbil", 1)
   #   n := t.node(2)     # SortTableNode(key="Gerbil";val=1)
   #   n.unlink()
   #   # t is now SortTable("Cat"->12;"Mouse"->2)
   #   n.gen()            # runtime error
   # ~
   #
   public unlink()
      need_linked()
      SortTable.unlink(self)
      link
   end

   #
   # This method combines a `move` and an `unlink`.  First, `move(i)`
   # is performed, and the result is noted.  Then the `unlink` is
   # peformed.  The result of the `move` is returned; if the `move`
   # failed, then this method fails, but the `unlink` is carried out
   # regardless.
   #
   # This gives a convenient way to iterate over the tree and delete
   # selected nodes.
   #
   # Example :-
   # ~
   #    # Delete all entries with even-numbered keys.
   #    n := t.node(1)
   #    while
   #       n := if n.key % 2 = 0 then
   #          n.move_unlink(1)
   #       else
   #          n.get_next()
   # ~
   #
   public move_unlink(i)
      local t
      t := move(i)
      unlink()
      return \t
   end

   #
   # Return the rank of this node, ie its index in the sorted order of
   # nodes in the enclosing tree, with 1 being the rank of the
   # "smallest" key.
   #
   public rank()
      need_linked()
      return SortTable.rank_of(self)
   end

   package keyval()
      suspend key | val
   end

   package real()
      link
   end

   package new(k, v, p)
      self.key := k
      self.val := v
      self.p := p
      self.N := 1
      return
   end
end

#
# A sentinel which is the parent of the root node of a tree.
#
package class SortTableSentinel()
   public
      tree,    # Parent SortTable, or null if cleared
      root     # Root node, or null if table empty.

   package real()
   end

   package new(t)
      self.tree := t
      return
   end
end

#
# A `Table` which uses a red-black binary tree so that its members are
# always in sorted order.
#
class SortTable(InsertTableImpl1)
   private
      sentinel
   public const
      cmp

   public override add(key)
      return add_node(key).val
   end

   #
   # This is like `add_node()`, but sets the value of the node to
   # `val` before returning it.
   #
   public new_node(key, val)
      local n
      n := add_node(key)
      n.val := val
      return n
   end

   #
   # Add a new node into the tree with the given key (and the default
   # value), or return an existing node if one with a matching key is
   # already present.
   #
   public add_node(key)
      local n, p, i
      if /sentinel.root then {
         sentinel.root := n := SortTableNode(key, def, sentinel)
         return n
      }
      n := sentinel.root
      repeat {
         i := cmp(key, n.key)
         if i = 0 then
            return n
         p := n
         n := if i < 0 then
            n.l
         else
            n.r
         if /n then {
            n := SortTableNode(key, def, p)
            if i < 0 then
               p.l := n
            else
               p.r := n
            fix_sizes(p, 1)
            fix_after_insertion(n)
            return n
         }
      }
   end

   private static fix_sizes(n, d)
      repeat {
         n.N +:= d
         n := n.p.real() | fail
      }
   end

   public override delete(key)
      return unlink(find_node(key))
   end

   package static unlink(n)
      local x
      # If n has 2 children, swap its position with its successor
      # (which has at most one child).
      if \n.l & \n.r then
         swap_nodes(n, n.get_next())
      if x := \n.l | \n.r then {
         # One child
         x.p := n.p
         down_var(n) := x
         fix_sizes(x.p.real(), -1)
         n.l := n.r := n.p := n.N := &null
         fix_after_deletion(x)
      } else {
         # No children
         fix_after_deletion(n)
         down_var(n) := &null
         fix_sizes(n.p.real(), -1)
         n.p := n.N := &null
      }
      link
   end

   private static fix_after_deletion(x)
      local sib, xp
      while /x.is_red_flag & xp := x.p.real() do {
         if x === xp.l then {
            sib := xp.r
            if is_red(sib) then {
               sib.is_red_flag := &no
               xp.is_red_flag := &yes
               rotate_left(xp)
               # Since x is xp.l and rotate_left(n) doesn't change
               # n.l, xp is still valid.
               sib := xp.r
            }
            if /sib | (is_black(sib.l) & is_black(sib.r)) then {
               (\sib).is_red_flag := &yes
               x := xp
            } else {
               if is_black(sib.r) then {
                  (\sib.l).is_red_flag := &no
                  sib.is_red_flag := &yes
                  rotate_right(sib)
                  # xp is still the same
                  sib := xp.r
               }
               sib.is_red_flag := xp.is_red_flag
               xp.is_red_flag := &no
               (\sib.r).is_red_flag := &no
               rotate_left(xp)
               return
            }
         } else {       # Symmetric
            sib := xp.l
            if is_red(sib) then {
               sib.is_red_flag := &no
               xp.is_red_flag := &yes
               rotate_right(xp)
               sib := xp.l
            }
            if /sib | (is_black(sib.l) & is_black(sib.r)) then {
                (\sib).is_red_flag := &yes
                x := xp
            } else {
               if is_black(sib.l) then {
                  (\sib.r).is_red_flag := &no
                  sib.is_red_flag := &yes
                  rotate_left(sib)
                  sib := xp.l
               }
               sib.is_red_flag := xp.is_red_flag
               xp.is_red_flag := &no
               (\sib.l).is_red_flag := &no
               rotate_right(xp)
               return
            }
         }
      }
      x.is_red_flag := &no 
   end

   private static swap_nodes(x, y)
      down_var(x) := y
      down_var(y) := x
      x.p :=: y.p
      x.l :=: y.l
      x.r :=: y.r
      x.N :=: y.N
      x.is_red_flag :=: y.is_red_flag
      (\x.l).p := x
      (\x.r).p := x
      (\y.l).p := y
      (\y.r).p := y
   end

   private static down_var(n)
      local t
      return if t := n.p.real() then {
         if t.l === n then
            t.l
         else
            t.r
      } else
         n.p.root
   end

   private static is_black(p)
      succeed /p | /p.is_red_flag
   end

   private static is_red(n)
      succeed \ (\n).is_red_flag
   end

   private fix_after_insertion(x)
      local y, xp, xpp
      x.is_red_flag := &yes
      while xp := x.p.real() & \xp.is_red_flag do {
         if xpp := xp.p.real() & xp === xpp.l then {
            if y := \xpp.r & \y.is_red_flag then {
               xp.is_red_flag := &no
               y.is_red_flag := &no
               xpp.is_red_flag := &yes
               x := xpp
            } else {
               if x === xp.r then {
                  x := xp
                  rotate_left(x)
               }
               if xp := x.p.real() then {
                  xp.is_red_flag := &no
                  if xpp := xp.p.real() then {
                     xpp.is_red_flag := &yes
                     rotate_right(xpp)
                  }
               }
            }
         } else {
            if xpp := xp.p.real() & y := \xpp.l & \y.is_red_flag then {
               xp.is_red_flag := &no
               y.is_red_flag := &no
               xpp.is_red_flag := &yes
               x := xpp
            } else {
               if x === xp.l then {
                  x := xp
                  rotate_right(x)
               }
               if xp := x.p.real() then {
                  xp.is_red_flag := &no
                  if xpp := xp.p.real() then {
                     xpp.is_red_flag := &yes
                     rotate_left(xpp)
                  }
               }
            }
         }
      }
      sentinel.root.is_red_flag := &no
   end

   private static rotate_left(n)
      local x
      x := n.r
      n.r := x.l
      (\x.l).p := n
      x.p := n.p
      down_var(n) := x
      x.l := n
      n.p := x
      x.N := n.N
      n.N := size1(n.l) + size1(n.r) + 1
   end

   private static rotate_right(n)
      local x
      x := n.l
      n.l := x.r
      (\x.r).p := n
      x.p := n.p
      down_var(n) := x
      x.r := n
      n.p := x
      x.N := n.N
      n.N := size1(n.l) + size1(n.r) + 1
   end

   #
   # Return the node with the smallest key greater than `key`, or fail
   # there is no such node.
   #
   public find_node_gt(key)
      local n, i
      n := sentinel.root
      while \n do {
         i := cmp(key, n.key)
         if i < 0 then {
            if /n.l then
               return n
            n := n.l
         } else {
            if /n.r then
               return n.get_next()
            n := n.r
         }
      }
   end

   #
   # Return the node with the largest key less than `key`, or fail
   # there is no such node.
   #
   public find_node_lt(key)
      local n, i
      n := sentinel.root
      while \n do {
         i := cmp(key, n.key)
         if i > 0 then {
            if /n.r then
               return n
            n := n.r
         } else {
            if /n.l then
               return n.get_prev()
            n := n.l
         }
      }
   end

   #
   # Return the node with the smallest key greater than or equal to
   # `key`, or fail there is no such node.
   #
   public find_node_ge(key)
      local n, i
      n := sentinel.root
      while \n do {
         i := cmp(key, n.key)
         if i < 0 then {
            if /n.l then
               return n
            n := n.l
         } else if i > 0 then {
            if /n.r then
               return n.get_next()
            n := n.r
         } else
            return n
      }
   end

   #
   # Return the node with the largest key less than or equal to `key`,
   # or fail there is no such node.
   #
   public find_node_le(key)
      local n, i
      n := sentinel.root
      while \n do {
         i := cmp(key, n.key)
         if i > 0 then {
            if /n.r then
               return n
            n := n.r
         } else if i < 0 then {
            if /n.l then
               return n.get_prev()
            n := n.l
         } else
            return n
      }
   end

   #
   # Return the node corresponding to `key`, or fail if it is not
   # found.
   #
   public find_node(key)
      local n, i
      n := sentinel.root
      while \n do {
         i := cmp(key, n.key)
         if i = 0 then
            return n
         n := if i < 0 then
            n.l
         else
            n.r
      }
   end

   #
   # Return the smallest key greater than `key`, or fail there is no
   # such key.
   #
   public find_key_gt(key)
      return find_node_gt(key).key
   end

   #
   # Return the largest key less than `key`, or fail there is no such
   # key.
   #
   public find_key_lt(key)
      return find_node_lt(key).key
   end

   #
   # Return the smallest key greater than or equal to `key`, or fail
   # there is no such key.
   #
   public find_key_ge(key)
      return find_node_ge(key).key
   end

   #
   # Return the largest key less than or equal to `key`, or fail there
   # is no such key.
   #
   public find_key_le(key)
      return find_node_le(key).key
   end

   public override member(key)
      return find_node(key).val
   end

   #
   # Generate the nodes in the table, in sorted key order, starting at
   # index `i` (default 1).  Each node represents one entry in the
   # table, and contains key and val members; the former is read-only,
   # the latter may be changed if desired, to edit the value in the
   # table.  The nodes are generated in sorted key order.
   #
   # See also `SortTableNode.gen()`.
   #
   public nodes(i)
      /i := 1
      suspend node(i).gen()
   end

   #
   # Generate the nodes in reverse order, starting with the node
   # before index `i` in the sorted order (thus generating the
   # elements in the range 1:i); `i` defaults to 0. (see `nodes()`).
   #
   public back_nodes(i)
      i := need_integer(\i) | 0
      suspend node(i - 1).back()
   end

   package static rank_of(n)
      local i, t
      i := size1(n.l) + 1
      while t := n.p.real() do {
         if n === t.r then
            i +:= size1(t.l) + 1
         n := t
      }
      return i
   end

   private static size1(n)
      return if /n then 0 else n.N
   end

   public override key(i)
      suspend nodes(i).key
   end

   public override keyval(i)
      suspend nodes(i).keyval()
   end

   public override back_key(i)
      suspend back_nodes(i).key
   end

   public override back_keyval(i)
      suspend back_nodes(i).keyval()
   end

   public override gen(i)
      suspend nodes(i).val
   end

   public override back(i)
      suspend back_nodes(i).val
   end

   private new_sentinel()
      self.sentinel := SortTableSentinel(self)
   end

   #
   # This is a constant-time operation that leaves the former tree of
   # nodes intact, but entirely divorced from this table.  The old
   # nodes will remain "linked" to one another, and can still be
   # operated upon, but without affecting this list.
   #
   public override clear()
      sentinel.tree := &null
      new_sentinel()
      link
   end

   public override random()
      return node(?(0 < size())).val
   end

   public override size()
      return size1(sentinel.root)
   end

   public override select(i)
      return node(i).key
   end

   #
   # Return the `i`th node in the sorted order (see `nodes()`).
   #
   public node(i)
      i := cvpos_item(i, size()) | fail
      return select1(sentinel.root, i)
   end

   public override rank(k)
      return rank1(sentinel.root, k)
   end

   private select1(n, i)
      local t
      t := size1(n.l) + 1
      return if t > i then
         select1(n.l, i)
      else if t < i then
         select1(n.r, i - t)
      else
         n
   end
   
   private rank1(n, k)
      local t
      \n | fail
      t := cmp(k, n.key)
      return if t < 0 then
         rank1(n.l, k)
      else if t > 0 then 
         1 + size1(n.l) + rank1(n.r, k)
      else 
         1 + size1(n.l)
   end

   #
   # Check the table for internal consistency.
   #
   public check()
      is_bst(sentinel.root) | return error("Not in symmetric order")
      is_size_consistent(sentinel.root)  | return error("Subtree counts not consistent")
      is_rank_consistent(sentinel.root)  | return error("Ranks not consistent")
      is_balanced() | return error("Not balanced")
      is_correctly_linked(sentinel.root) | return error("Not correctly linked")
      if (\sentinel.root).p.real() then return error("Root has a parent")
      return
   end

   #
   # Return the height of the tree; useful for testing purposes.
   #
   public height()
      return height1(sentinel.root)
   end

   private height1(n)
      return if /n then 0 else 1 + max(height1(n.l), height1(n.r))
   end

   private is_correctly_linked(n)
      if /n then return
      if (\n.l | \n.r).p ~=== n then fail
      succeed is_correctly_linked(n.l) & is_correctly_linked(n.r)
   end

   private is_balanced()
      local b, n
      b := 0
      n := sentinel.root
      while \n do {
         is_red(n) | (b +:= 1)
         n := n.l
      }
      succeed is_balanced1(sentinel.root, b)
   end

   private is_balanced1(n, b)
      if /n then succeed b = 0
      is_red(n) | (b -:= 1)
      succeed is_balanced1(n.l, b) & is_balanced1(n.r, b)
   end

   private is_bst(n, min, max)
      if /n then return
      if cmp(n.key, \min) <= 0 then fail
      if cmp(n.key, \max) >= 0 then fail
      succeed is_bst(n.l, min, n.key) & is_bst(n.r, n.key, max)
   end

   private is_size_consistent(n)
      if /n then return
      (n.N = size1(n.l) + size1(n.r) + 1) | fail
      succeed is_size_consistent(n.l) & is_size_consistent(n.r)
   end

   private is_rank_consistent()
      local i, k
      every i := 1 to size() do
         (i = rank(select(i))) | fail
      every k := key() do
         (cmp(k, select(rank(k))) = 0) | fail
      return
   end

   public override get_mode()
      return MODIFY + INSERT + DELETE + ORDER
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `def` - the default value
   # :  `cmp` - a comparator function taking two arbitrary values and
   #     returning `<0`, `0` or `>0` by way of comparison.  The default
   #     value is `Internal.compare`.  The function must satisfy
   #     *  `sign(cmp(a,b)) = -sign(cmp(b,a))` for all `a,b`
   #     *  `cmp(a,b)>0 & cmp(b,c)>0 => cmp(a,c)>0`
   #     *  `cmp(a,b)=0 <=> sign(cmp(a,x))=sign(cmp(b,x))` for all other `x'.
   # :  `entries` - initial key-value entries.
   #
   public new(def, cmp, entries[])
      new_sentinel()
      self.def := def
      self.cmp := need_callable_def(cmp)
      init_entries(entries)
      return
   end
end

#
# A `Table` which uses the `lang.equals` procedure for key comparison,
# rather than the builtin `===` operator.
#
class EqTable(InsertTableImpl1)
   private const
      t
   private
      sz

   public override add(key)
      local h, l, e, n
      h := hash(key)
      if l := default.member(t, h) then {
         every e := !l do {
            if equals(e.key, key) then
               return e.val
         }
      }
      n := Entry(key, def)
      if \l then
         put(l, n)
      else
         default.insert(t, h, [n])
      sz +:= 1
      return n.val
   end

   public override member(key)
      local e
      every e := !default.member(t, hash(key)) do {
         if equals(e.key, key) then
            return e.val
      }
   end

   public override delete(key)
      local h, l, e, i
      h := hash(key)
      l := default.member(t, h) | fail
      i := 1
      every e := !l do {
         if equals(e.key, key) then {
            default.delete(l, i)
            if *l = 0 then
               default.delete(t, h)
            sz -:= 1
            link
         }
         i +:= 1
      }
   end

   public override key()
      suspend .(!!t).key
   end

   public override keyval()
      local e
      every e := !!t do
         suspend .e.key | e.val
   end

   public override gen()
      suspend (!!t).val
   end

   public override size()
      return .sz
   end

   public override clear()
      default.clear(t)
      sz := 0
      link
   end

   public override get_mode()
      return MODIFY + INSERT + DELETE
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `def` - the default value
   # :  `entries` - initial key-value entries.
   #
   public new(def, entries[])
      self.def := def
      t := table()
      sz := 0
      init_entries(entries)
      return
   end
end

#
# A `Table` which is just a wrapper around a builtin table.
#
class BuiltinTable(InsertTableImpl2)
   private const
      t

   public override insert(key, val)
      default.insert(t, key, val)
      link
   end

   public override member(key)
      return default.member(t, key)
   end

   public override delete(key)
      link default.delete(t, key)
   end

   public override key()
      suspend default.key(t)
   end

   public override keyval()
      suspend default.keyval(t)
   end

   public override gen()
      suspend !t
   end

   public override clear()
      default.clear(t)
      link
   end

   public override size()
      return *t
   end

   public override random()
      return ?t
   end

   public override get_mode()
      return MODIFY + INSERT + DELETE
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `t` - the table to wrap; if omitted then a new table is
   #       created.
   #
   public new(t)
      if /t then
         self.t := table()
      else {
         self.t := need_table(t)
         self.def := tbldflt(t)
      }
      return
   end
end

#
# An empty table.  An instance of this class is `Table.EMPTY_TABLE`.
#
class EmptyTable(OrderTableImpl1)
   public override member(x)
   end

   public override select(i)
   end

   public override rank(x)
   end

   public override size()
      return 0
   end

   public override get_mode()
      return ORDER
   end
end

#
# A `Table` which uses weak references
#
class WeakrefTable(InsertTableImpl1)
   private const
      t
   private
      sz,
      last_purge,
      repeat_collect_flag

   #
   # This flag can be set to force repeated collections during a
   # purge, whilst this reduces the size of the table.  This can be
   # useful in the case that the values in the table hold references
   # to objects that are also referenced as keys.  Unlike those keys,
   # these references count as non-weak.  What happens therefore is
   # that a single collect (and purge) will delete just those keys
   # that don't have references via values.  As those keys and values
   # are purged, the next level of references can be removed with
   # another collect and purge, and so on.  This flag causes such a
   # loop to be executed by each purge.
   #
   public set_repeat_collect(s)
      self.repeat_collect_flag := need_flag(s)
      link
   end

   public override add(key)
      local h, l, e, n
      maybe_purge()
      h := Internal.hash(key)
      if l := default.member(t, h) then {
         every e := !l do {
            if weakrefval(e.key) === key then
               return e.val
         }
      }
      n := Entry(weakref(key), def) | runerr("Type of key cannot be used with weakref")
      if \l then
         put(l, n)
      else
         default.insert(t, h, [n])
      sz +:= 1
      return n.val
   end

   public override member(key)
      local e
      maybe_purge()
      every e := !default.member(t, Internal.hash(key)) do {
         if weakrefval(e.key) === key then
            return e.val
      }
   end

   public override delete(key)
      local h, l, e, i
      maybe_purge()
      h := Internal.hash(key)
      l := default.member(t, h) | fail
      i := 1
      every e := !l do {
         if weakrefval(e.key) === key then {
            default.delete(l, i)
            if *l = 0 then
               default.delete(t, h)
            sz -:= 1
            link
         }
         i +:= 1
      }
   end

   public override key()
      maybe_purge()
      suspend weakrefval((!!t).key)
   end

   public override keyval()
      local e
      maybe_purge()
      every e := !!t do
         suspend weakrefval(e.key) | e.val
   end

   public override gen()
      maybe_purge()
      suspend (!!t).val
   end

   public override clear()
      default.clear(t)
      sz := 0
      link
   end

   public override size()
      maybe_purge()
      return .sz
   end

   public maybe_purge()
      local old_sz
      if last_purge ~=== Prog.get_global_collection_count() then {
         repeat {
            old_sz := sz
            last_purge := Prog.get_global_collection_count()
            purge()
            if /repeat_collect_flag | (old_sz = sz) then
               break
            collect()
         }
      }
      link
   end

   private purge()
      local h, l, i
      every h := default.key(t) do {
         l := t[h]
         i := 1
         while i <= *l do {
            if weakrefval(l[i].key) then
               i +:= 1
            else {
               default.delete(l, i)
               sz -:= 1
            }
         }
         if *l = 0 then
            default.delete(t, h)
      }
   end

   public override get_mode()
      return MODIFY + INSERT + DELETE
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `def` - the default value
   # :  `entries` - initial key-value entries.
   #
   public new(def, entries[])
      self.def := def
      self.t := table()
      self.sz := 0
      init_entries(entries)
      return
   end
end

#
# A convenient equivalent to wrapping a BuiltinTable in an
# UnmodifiableTable.
#
class UnmodifiableBuiltinTable(Table)
   private const
      t

   public override member(key)
      return .default.member(t, key)
   end

   public override key()
      suspend default.key(t)
   end

   public override keyval()
      suspend .default.keyval(t)
   end

   public override gen()
      suspend .!t
   end

   public override size()
      return *t
   end

   public override random()
      return .?t
   end

   public override get_mode()
      return 0
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `t` - the table to wrap
   #
   public new(t)
      self.t := need_table(t)
      self.def := tbldflt(t)
      return
   end
end
