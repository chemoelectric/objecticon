package io

import undo, util, lang

class LineEditorStream(LineBasedStream)
   package
      subj,
      pos
   private
      history_limit,
      history,
      hpos,
      hmod,
      prompt,
      undo_manager,
      line_no,
      nlines,
      ctrl_d_flag,
      tty,
      isatty,
      nul,
      dim,
      utf8_flag

   public set_history_limit(n)
      self.history_limit := n
      return self
   end

   public set_history(l)
      self.history := l
      return self
   end

   public set_prompt(s)
      self.prompt := s
      return self
   end

   public set_utf8(f)
      utf8_flag := check_flag(f)
      return self
   end

   public get_history()
      return .history
   end

   public close()
      nul.close()
      return
   end

   public get_mode()
      return READ
   end

   private move_hist(n)
      if \utf8_flag then {
         (subj == ucs(history[hpos])) | (hmod[hpos] := subj)
         hpos +:= n
         subj := \hmod[hpos] | ucs(history[hpos]) | u"?? bad utf8 in history"
      } else {
         (subj == string(history[hpos])) | (hmod[hpos] := subj)
         hpos +:= n
         subj := \hmod[hpos] | string(history[hpos])
      }
      pos := *subj + 1
      undo_manager.clear()
   end

   private get_console_size()
      local w, h
      # Could also use tput cols and tput lines to do this.
      return run_stty("size") ? {
         if h := integer(tab(many(&digits))) &
            tab(upto(&digits)) &
            w := integer(tab(many(&digits))) then [w, h]
         else error("Couldn't interpret stty size output")
      }
   end

   private run_stty(params[])
      local f, ss
      ss := StringStream()
      use {
         f := ProgInputStream("stty", params,,, nul),
         f.copy_to(ss)
      } | fail
      return if f.get_exit_info().param = 0 then
         ss.str()
      else
         error("stty returned non-zero status")
   end

   protected read_line_impl()
      \isatty | return tty.read()
      if \ctrl_d_flag then
         return
      return use {
         run_stty("-icanon",  "-echo"),
         read_line_impl2(),
         run_stty("icanon",  "echo")
      }
   end

   private read_line_impl2()
      local ch, p, n, ed, un
      subj := if \utf8_flag then u"" else ""
      pos := 1
      hpos := *history + 1
      hmod := table()
      undo_manager.clear()
      line_no := nlines := &null
      dim := get_console_size() | fail
      # Request line_no
      tty.writes("\e[6n")
      repeat {
         if \line_no then 
            show()
         ch := tty.reads(1) | fail
         if \utf8_flag then {
            # Read a utf8 sequence into ch.  On gibberish, just go round and try again.
            un := Text.get_utf8_seq_len(ch) | next
            every 2 to un do
               ch ||:= tty.reads(1) | fail
            ch := ucs(ch) | next
         }

         if ch == "\e" then {
            ch := tty.reads(1) | fail
            if ch == "[" then {
               p := []
               repeat {
                  ch := tty.reads(1) | fail
                  n := integer(ch) | break
                  repeat {
                     ch := tty.reads(1) | fail
                     n := 10 * n + integer(ch) | break
                  }
                  put(p, n)
                  ch == ";" | break
               }

               case string(ch) of {
                  "A": if hpos > 1 then move_hist(-1)
                  "B": if hpos <= *history then move_hist(1)
                  "C": pos := (*subj + 1 >= pos + 1)
                  "D": pos := (1 <= pos - 1)
                  "H": pos := 1
                  "F": pos := *subj + 1
                  "R": line_no := p[1]
                  "~": if p[1] = 3 & *p = 1 then {
                     if pos <= *subj then {
                        ed := LineEditorDeleteRightEdit(self)
                        ed.doit()
                        undo_manager.add_edit(ed)
                     }
                  }
               }
            }
         } else case string(ch) of {
            "\^_": {
               if undo_manager.can_undo() then
                  undo_manager.undo()
            }
            "\^y": {
               if undo_manager.can_redo() then
                  undo_manager.redo()
            }
            "\^d": {
               ctrl_d_flag := 1
               tty.write()
               if *subj > 0 then {
                  put(history, subj)
                  if *history > \history_limit then
                     pop(history)
                  return string(subj)
               } else
                  return
            }
            "\^a": pos := 1
            "\^e": pos := *subj + 1
            "\^k": {
               if pos < *subj + 1 then {
                  ed := LineEditorDeleteToEndOfLineEdit(self)
                  ed.doit()
                  undo_manager.add_edit(ed)
               }
            }
            "\d": {
               if pos > 1 then {
                  ed := LineEditorDeleteLeftEdit(self)
                  ed.doit()
                  undo_manager.add_edit(ed)
               }
            }
            "\n": {
               tty.write()
               if *subj > 0 then {
                  put(history, subj)
                  if *history > \history_limit then
                     pop(history)
               }
               return string(subj)
            }
            default: {
               if any('\x20-\x7e\x80-\U10ffff', ch) then {
                  ed := LineEditorDefaultEdit(self, ch)
                  ed.doit()
                  undo_manager.add_edit(ed)
               }
            }
         }
      }
   end

   private show()
      local n, cursor_line, cursor_col
      if \nlines then {
         # Clear the lines written the previous time show() was called
         every tty.writes("\e[",
                          line_no to line_no + nlines - 1,
                          "H", "\e[2K")
      }

      # The number of lines needed to display this line.
      nlines := 1 + (*prompt + *subj) / dim[1]

      # Check if we need to scroll some lines
      n := nlines + line_no - dim[2] - 1

      if n > 0 then {
         # Scroll n lines
         tty.writes("\e[", n ,"S")
         line_no -:= n
      }
      # Calculate position of cursor
      cursor_line := line_no + (*prompt + pos - 1) / dim[1]
      cursor_col := (*prompt + pos - 1) % dim[1] + 1

      # First, goto line line_no, col 1, and write prompt, subj
      # Then put cursor at correct position.
      tty.writes("\e[", line_no, "H", prompt, subj,
                 "\e[", cursor_line, ";", cursor_col, "H")
   end

   public new()
      cast(self,LineBasedStream).new()
      nul := FileStream.open("/dev/null", FileOpt.WRONLY) | 
         return error("Couldn't open /dev/null: " || &why)
      tty := FileStream.stdin
      if run_stty() then
         isatty := &yes
      utf8_flag := &yes
      undo_manager := UndoManager()
      history := []
      prompt := ""
      return
   end
end

class LineEditorEdit(UndoableEdit)
   protected
      parent,
      pos

   public doit()
      save()
      self.redo_impl()
   end

   public redo()
      restore()
      self.redo_impl()
   end

   public undo()
      self.undo_impl()
      restore()
   end

   protected defer redo_impl()
   protected defer undo_impl()

   private save()
      self.pos := parent.pos
   end

   private restore()
      parent.pos := self.pos
   end

   protected new(parent)
      self.parent := parent
      return
   end
end

class LineEditorDefaultEdit(LineEditorEdit)
   private s

   public add_edit(other)
      if is(other, LineEditorDefaultEdit) &
         (other.pos = self.pos + *s) then {
            s ||:= other.s
            return
      }
   end

   protected redo_impl()
      parent.subj := parent.subj[1:parent.pos] || s || parent.subj[parent.pos:0]
      parent.pos +:= *s
   end

   protected undo_impl()
      parent.subj[self.pos +: *s] := ""
   end

   public new(parent, e)
      cast(self,LineEditorEdit).new(parent)
      s := e
      return
   end
end

class LineEditorDeleteLeftEdit(LineEditorEdit)
   private ch

   protected redo_impl()
      ch := parent.subj[parent.pos - 1]
      parent.subj[parent.pos - 1] := ""
      parent.pos -:= 1
   end

   protected undo_impl()
      if self.pos - 1 > *parent.subj then
         parent.subj ||:= ch
      else
         parent.subj[self.pos - 1] := ch || parent.subj[self.pos - 1]
   end

   public new(parent)
      cast(self,LineEditorEdit).new(parent)
      return
   end
end

class LineEditorDeleteRightEdit(LineEditorEdit)
   private ch

   protected redo_impl()
      ch := parent.subj[parent.pos]
      parent.subj[parent.pos] := ""
   end

   protected undo_impl()
      if self.pos > *parent.subj then
         parent.subj ||:= ch
      else
         parent.subj[self.pos] := ch || parent.subj[self.pos]
   end

   public new(parent)
      cast(self,LineEditorEdit).new(parent)
      return
   end
end

class LineEditorDeleteToEndOfLineEdit(LineEditorEdit)
   private del

   protected redo_impl()
      del := parent.subj[parent.pos:0]
      parent.subj[parent.pos:0] := ""
   end

   protected undo_impl()
      parent.subj[self.pos:0] := del
   end

   public new(parent)
      cast(self,LineEditorEdit).new(parent)
      return
   end
end
