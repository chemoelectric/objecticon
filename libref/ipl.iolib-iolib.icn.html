<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>iolib.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#    
<a name="3"/>#	File:     iolib.icn
<a name="4"/>#	
<a name="5"/>#	Subject:  Procedures for termlib support
<a name="6"/>#	
<a name="7"/>#	Author:   Richard L. Goerwitz (with help from Norman Azadian)
<a name="8"/>#
<a name="9"/>#	Date:     August 14, 1996
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#	Version:  1.13
<a name="18"/>#
<a name="19"/>############################################################################
<a name="20"/>#
<a name="21"/>#  The following library represents a series of rough functional
<a name="22"/>#  equivalents to the standard UNIX low-level termcap routines.  It is
<a name="23"/>#  not meant as an exact termlib clone.  Nor is it enhanced to take
<a name="24"/>#  care of magic cookie terminals, terminals that use \D in their
<a name="25"/>#  termcap entries, or archaic terminals that require padding.  This
<a name="26"/>#  library is geared mainly for use with ANSI and VT-100 devices.
<a name="27"/>#  Note that this file may, in most instances, be used in place of the
<a name="28"/>#  older UNIX-only itlib.icn file.  It essentially replaces the DOS-
<a name="29"/>#  only itlibdos routines.  For DOS users not familiar with the whole
<a name="30"/>#  notion of generalized screen I/O, I've included extra documentation
<a name="31"/>#  below.  Please read it.
<a name="32"/>#
<a name="33"/>#  The sole disadvantage of this over the old itlib routines is that
<a name="34"/>#  iolib.icn cannot deal with archaic or arcane UNIX terminals and/or
<a name="35"/>#  odd system file arrangements.  Note that because these routines
<a name="36"/>#  ignore padding, they can (unlike itlib.icn) be run on the NeXT and
<a name="37"/>#  other systems which fail to implement the -g option of the stty
<a name="38"/>#  command.  Iolib.icn is also simpler and faster than itlib.icn.
<a name="39"/>#
<a name="40"/>#  I want to thank Norman Azadian for suggesting the whole idea of
<a name="41"/>#  combining itlib.icn and itlibdos.icn into one distribution, for
<a name="42"/>#  suggesting things like letting drive specifications appear in DOS
<a name="43"/>#  TERMCAP environment variables, and for finding several bugs (e.g.
<a name="44"/>#  the lack of support for %2 and %3 in cm).  Although he is loathe
<a name="45"/>#  to accept this credit, I think he deserves it.
<a name="46"/>#
<a name="47"/>############################################################################
<a name="48"/>#
<a name="49"/>#  Contents:
<a name="50"/>#
<a name="51"/>#  setname(term)
<a name="52"/>#	Use only if you wish to initialize itermlib for a terminal
<a name="53"/>#  other than what your current environment specifies.  "Term" is the
<a name="54"/>#  name of the termcap entry to use.  Normally this initialization is
<a name="55"/>#  done automatically, and need not concern the user.
<a name="56"/>#
<a name="57"/>#  getval(id)
<a name="58"/>#	Works something like tgetnum, tgetflag, and tgetstr.  In the
<a name="59"/>#  spirit of Icon, all three have been collapsed into one routine.
<a name="60"/>#  Integer valued caps are returned as integers, strings as strings,
<a name="61"/>#  and flags as records (if a flag is set, then type(flag) will return
<a name="62"/>#  "true").  Absence of a given capability is signalled by procedure
<a name="63"/>#  failure.
<a name="64"/>#
<a name="65"/>#  igoto(cm,destcol,destline) - NB:  default 1 offset (*not* zero)!
<a name="66"/>#	Analogous to tgoto.  "Cm" is the cursor movement command for
<a name="67"/>#  the current terminal, as obtained via getval("cm").  Igoto()
<a name="68"/>#  returns a string which, when output via iputs, will cause the
<a name="69"/>#  cursor to move to column "destcol" and line "destline."  Column and
<a name="70"/>#  line are always calculated using a *one* offset.  This is far more
<a name="71"/>#  Iconish than the normal zero offset used by tgoto.  If you want to
<a name="72"/>#  go to the first square on your screen, then include in your program
<a name="73"/>#  "iputs(igoto(getval("cm"),1,1))."
<a name="74"/>#
<a name="75"/>#  iputs(cp,affcnt)
<a name="76"/>#	Equivalent to tputs.  "Cp" is a string obtained via getval(),
<a name="77"/>#  or, in the case of "cm," via igoto(getval("cm"),x,y).  Affcnt is a
<a name="78"/>#  count of affected lines.  It is completely irrelevant for most
<a name="79"/>#  modern terminals, and is supplied here merely for the sake of
<a name="80"/>#  backward compatibility with itlib, a UNIX-only version of these
<a name="81"/>#  routines (one which handles padding on archaic terminals).
<a name="82"/>#
<a name="83"/>############################################################################
<a name="84"/>#
<a name="85"/>#  Notes for MS-DOS users:
<a name="86"/>#
<a name="87"/>#	There are two basic reasons for using the I/O routines
<a name="88"/>#  contained in this package.  First, by using a set of generalized
<a name="89"/>#  routines, your code will become much more readable.  Secondly, by
<a name="90"/>#  using a high level interface, you can avoid the cardinal
<a name="91"/>#  programming error of hard coding things like screen length and
<a name="92"/>#  escape codes into your programs.
<a name="93"/>#
<a name="94"/>#	To use this collection of programs, you must do two things.
<a name="95"/>#  First, you must add the line "device=ansi.sys" (or the name of some
<a name="96"/>#  other driver, like zansi.sys, nansi.sys, or nnansi.sys [=new
<a name="97"/>#  nansi.sys]) to your config.sys file.  Secondly, you must add two
<a name="98"/>#  lines to your autoexec.bat file: 1) "set TERM=ansi-mono" and 2)
<a name="99"/>#  "set TERMCAP=\location\termcap."  The purpose of setting the TERM
<a name="100"/>#  variable is to tell this program what driver you are using.  If you
<a name="101"/>#  have a color system, you could use "ansi-color" instead of
<a name="102"/>#  "ansi-mono," although for compatibility with a broader range of
<a name="103"/>#  users, it would perhaps be better to stick with mono.  The purpose
<a name="104"/>#  of setting TERMCAP is to make it possible to determine where the
<a name="105"/>#  termcap database file is located.  The termcap file (which should
<a name="106"/>#  have been packed with this library as termcap.dos) is a short
<a name="107"/>#  database of all the escape sequences used by the various terminal
<a name="108"/>#  drivers.  Set TERMCAP so that it reflects the location of this file
<a name="109"/>#  (which should be renamed as termcap, for the sake of consistency
<a name="110"/>#  across UNIX and MS-DOS spectra).  If desired, you can also try
<a name="111"/>#  using termcap2.dos.  Certain games work a lot better using this
<a name="112"/>#  alternate file.  To try it out, rename it to termcap, and set
<a name="113"/>#  the environment variable TERMCAP to its location.
<a name="114"/>#
<a name="115"/>#	Although the authors make no pretense of providing here a
<a name="116"/>#  complete introduction to the format of the termcap database file,
<a name="117"/>#  it will be useful, we believe, to explain a few basic facts about
<a name="118"/>#  how to use this program in conjunction with it.  If, say, you want
<a name="119"/>#  to clear the screen, add the line,
<a name="120"/>#
<a name="121"/>#	iputs(getval("cl"))
<a name="122"/>#
<a name="123"/>#  to your program.  The function iputs() outputs screen control
<a name="124"/>#  sequences.  Getval retrieves a specific sequence from the termcap
<a name="125"/>#  file.  The string "cl" is the symbol used in the termcap file to
<a name="126"/>#  mark the code used to clear the screen.  By executing the
<a name="127"/>#  expression "iputs(getval("cl"))," you are 1) looking up the "cl"
<a name="128"/>#  (clear) code in the termcap database entry for your terminal, and
<a name="129"/>#  the 2) outputting that sequence to the screen.
<a name="130"/>#
<a name="131"/>#	Some other useful termcap symbols are "ce" (clear to end of
<a name="132"/>#  line), "ho" (go to the top left square on the screen), "so" (begin
<a name="133"/>#  standout mode), and "se" (end standout mode).  To output a
<a name="134"/>#  boldfaced string, str, to the screen, you would write -
<a name="135"/>#
<a name="136"/>#	iputs(getval("so"))
<a name="137"/>#	writes(str)
<a name="138"/>#	iputs(getval("se"))
<a name="139"/>#
<a name="140"/>#  You can also write "writes(getval("so") || str || getval("se")),
<a name="141"/>#  but this would make reimplementation for UNIX terminals that
<a name="142"/>#  require padding rather difficult.
<a name="143"/>#
<a name="144"/>#	It is also heartily to be recommended that MS-DOS programmers
<a name="145"/>#  try not to assume that everyone will be using a 25-line screen.
<a name="146"/>#  Most terminals are 24-line.  Some 43.  Some have variable window
<a name="147"/>#  sizes.  If you want to put a status line on, say, the 2nd-to-last
<a name="148"/>#  line of the screen, then determine what that line is by executing
<a name="149"/>#  "getval("li")."  The termcap database holds not only string-valued
<a name="150"/>#  sequences, but numeric ones as well.  The value of "li" tells you
<a name="151"/>#  how many lines the terminal has (compare "co," which will tell you
<a name="152"/>#  how many columns).  To go to the beginning of the second-to-last
<a name="153"/>#  line on the screen, type in:
<a name="154"/>#
<a name="155"/>#	iputs(igoto(getval("cm"), 1, getval("li")-1))
<a name="156"/>#
<a name="157"/>#  The "cm" capability is a special capability, and needs to be output
<a name="158"/>#  via igoto(cm,x,y), where cm is the sequence telling your computer
<a name="159"/>#  to move the cursor to a specified spot, x is the column, and y is
<a name="160"/>#  the row.  The expression "getval("li")-1" will return the number of
<a name="161"/>#  the second-to-last line on your screen.
<a name="162"/>#
<a name="163"/>############################################################################
<a name="164"/>#
<a name="165"/>#  Requires: UNIX or MS-DOS, co-expressions
<a name="166"/>#
<a name="167"/>############################################################################
<a name="168"/>#
<a name="169"/>#  See also: itlib.icn, iscreen.icn
<a name="170"/>#
<a name="171"/>############################################################################
<a name="172"/>
<a name="173"/>
<a name="174"/>package ipl.iolib
<a name="175"/>
<a name="176"/>import
<a name="177"/>   io(close, ewrite, open, read,
<a name="178"/>      stop, writes, Files),
<a name="179"/>   posix(System)
<a name="180"/>
<a name="181"/>global tc_table, isDOS
<a name="182"/>record true()
<a name="183"/>
<a name="184"/>
<a name="185"/>procedure check_features()
<a name="186"/>
<a name="187"/>    initial {
<a name="188"/>
<a name="189"/>	if find("UNIX",&amp;features) then
<a name="190"/>	    isDOS := &amp;null
<a name="191"/>	else if find("MS-DOS", &amp;features) then
<a name="192"/>	    isDOS := 1
<a name="193"/>	else stop("check_features:  OS not (yet?) supported.")
<a name="194"/>
<a name="195"/>	find("expressi",&amp;features) |
<a name="196"/>	    er("check_features","co-expressions not implemented - &amp;$#!",1)
<a name="197"/>    }
<a name="198"/>
<a name="199"/>    return
<a name="200"/>
<a name="201"/>end
<a name="202"/>
<a name="203"/>
<a name="204"/>
<a name="205"/>procedure setname(name)
<a name="206"/>
<a name="207"/>    # Sets current terminal type to "name" and builds a new termcap
<a name="208"/>    # capability database (residing in tc_table).  Fails if unable to
<a name="209"/>    # find a termcap entry for terminal type "name."  If you want it
<a name="210"/>    # to terminate with an error message under these circumstances,
<a name="211"/>    # comment out "| fail" below, and uncomment the er() line.
<a name="212"/>
<a name="213"/>    #tc_table is global
<a name="214"/>    
<a name="215"/>    check_features()
<a name="216"/>
<a name="217"/>    tc_table := table()
<a name="218"/>    tc_table := maketc_table(getentry(name)) | fail
<a name="219"/>    # er("setname","no termcap entry found for "||name,3)
<a name="220"/>    return "successfully reset for terminal " || name
<a name="221"/>
<a name="222"/>end
<a name="223"/>
<a name="224"/>
<a name="225"/>
<a name="226"/>procedure getname()
<a name="227"/>
<a name="228"/>    # Getname() first checks to be sure we're running under DOS or
<a name="229"/>    # UNIX, and, if so, tries to figure out what the current terminal
<a name="230"/>    # type is, checking successively the value of the environment
<a name="231"/>    # variable TERM, and then (under UNIX) the output of "tset -".
<a name="232"/>    # Terminates with an error message if the terminal type cannot be
<a name="233"/>    # ascertained.  DOS defaults to "mono."
<a name="234"/>
<a name="235"/>    local term, tset_output
<a name="236"/>
<a name="237"/>    check_features()
<a name="238"/>
<a name="239"/>    if \isDOS then {
<a name="240"/>        term := System.getenv("TERM") | "mono"
<a name="241"/>    }
<a name="242"/>    else {
<a name="243"/>	unless term := System.getenv("TERM") then {
<a name="244"/>	    tset_output := open("tset -","pr") |
<a name="245"/>		er("getname","can't find tset command",1)
<a name="246"/>	    term := tset_output.read()
<a name="247"/>	    close(tset_output)
<a name="248"/>	}
<a name="249"/>    }
<a name="250"/>
<a name="251"/>    return \term |
<a name="252"/>	er("getname","can't seem to determine your terminal type",1)
<a name="253"/>
<a name="254"/>end
<a name="255"/>
<a name="256"/>
<a name="257"/>
<a name="258"/>procedure er(func,msg,errnum)
<a name="259"/>
<a name="260"/>    # short error processing utility
<a name="261"/>    ewrite(func,":  ",msg)
<a name="262"/>    exit(errnum)
<a name="263"/>
<a name="264"/>end
<a name="265"/>
<a name="266"/>
<a name="267"/>
<a name="268"/>procedure getentry(name, termcap_string)
<a name="269"/>
<a name="270"/>    # "Name" designates the current terminal type.  Getentry() scans
<a name="271"/>    # the current environment for the variable TERMCAP.  If the
<a name="272"/>    # TERMCAP string represents a termcap entry for a terminal of type
<a name="273"/>    # "name," then getentry() returns the TERMCAP string.  Otherwise,
<a name="274"/>    # getentry() will check to see if TERMCAP is a file name.  If so,
<a name="275"/>    # getentry() will scan that file for an entry corresponding to
<a name="276"/>    # "name."  If the TERMCAP string does not designate a filename,
<a name="277"/>    # getentry() will scan the termcap file for the correct entry.
<a name="278"/>    # Whatever the input file, if an entry for terminal "name" is
<a name="279"/>    # found, getentry() returns that entry.  Otherwise, getentry()
<a name="280"/>    # fails.
<a name="281"/>
<a name="282"/>    local isFILE, f, getline, line,    entry
<a name="283"/>    static slash, termcap_names
<a name="284"/>    initial {
<a name="285"/>	if \isDOS then {
<a name="286"/>	    slash := "\\"
<a name="287"/>	    termcap_names := ["termcap","termcap.dos","termcap2.dos"]
<a name="288"/>	}
<a name="289"/>	else {
<a name="290"/>	    slash := "/"
<a name="291"/>	    termcap_names := ["/etc/termcap"]
<a name="292"/>	}
<a name="293"/>    }
<a name="294"/>
<a name="295"/>
<a name="296"/>    # You can force getentry() to use a specific termcap file by cal-
<a name="297"/>    # ling it with a second argument - the name of the termcap file
<a name="298"/>    # to use instead of the regular one, or the one specified in the
<a name="299"/>    # termcap environment variable.
<a name="300"/>    /termcap_string := System.getenv("TERMCAP")
<a name="301"/>
<a name="302"/>    if \isDOS then {
<a name="303"/>	if \termcap_string then {
<a name="304"/>	    if termcap_string ? (
<a name="305"/>		 not ((tab(any(&amp;letters)), match(":")) | match(slash)),
<a name="306"/>		 pos(1) | tab(find("|")+1), =name)
<a name="307"/>	    then {
<a name="308"/>		# if entry ends in tc= then add in the named tc entry
<a name="309"/>		termcap_string ?:= tab(find("tc=")) ||
<a name="310"/>		    # Recursively fetch the new termcap entry w/ name trimmed.
<a name="311"/>		    # Note that on the next time through name won't match the
<a name="312"/>		    # termcap environment variable, so getentry() will look for
<a name="313"/>		    # a termcap file.
<a name="314"/>		    (move(3), getentry(tab(find(":"))) ?
<a name="315"/>		     (tab(find(":")+1), tab(0)))
<a name="316"/>		return termcap_string
<a name="317"/>	    }
<a name="318"/>	    else isFILE := 1
<a name="319"/>	}
<a name="320"/>    }
<a name="321"/>    else {
<a name="322"/>	if \termcap_string then {
<a name="323"/>	    if termcap_string ? (
<a name="324"/>	        not match(slash), pos(1) | tab(find("|")+1), =name)
<a name="325"/>	    then {
<a name="326"/>		# if entry ends in tc= then add in the named tc entry
<a name="327"/>		termcap_string ?:= tab(find("tc=")) ||
<a name="328"/>		    # Recursively fetch the new termcap entry w/ name trimmed.
<a name="329"/>		    (move(3), getentry(tab(find(":")), "/etc/termcap") ?
<a name="330"/>		     (tab(find(":")+1), tab(0)))
<a name="331"/>		return termcap_string
<a name="332"/>	    }
<a name="333"/>	    else isFILE := 1
<a name="334"/>	}
<a name="335"/>    }
<a name="336"/>
<a name="337"/>    # The logic here probably isn't clear.  The idea is to try to use
<a name="338"/>    # the termcap environment variable successively as 1) a termcap en-
<a name="339"/>    # try and then 2) as a termcap file.  If neither works, 3) go to
<a name="340"/>    # the /etc/termcap file.  The else clause here does 2 and, if ne-
<a name="341"/>    # cessary, 3.  The "\termcap_string ? (not match..." expression
<a name="342"/>    # handles 1.
<a name="343"/>
<a name="344"/>    if \isFILE			# if find(slash, \termcap_string)
<a name="345"/>    then f := open(\termcap_string)
<a name="346"/>    /f := open(!termcap_names) |
<a name="347"/>        open(Files.find_exe("infocmp") || " -C " || name, "pr") |
<a name="348"/>	er("getentry","I can't access your termcap file.  Read iolib.icn.",1)
<a name="349"/>    
<a name="350"/>    getline := create read_file(f)
<a name="351"/>    
<a name="352"/>    while line := @getline do {
<a name="353"/>	if line ? (pos(1) | tab(find("|")+1), =name, any(':|')) then {
<a name="354"/>	    entry := ""
<a name="355"/>	    while (\line | @getline) ? {
<a name="356"/>		if entry ||:= 1(tab(find(":")+1), pos(0))
<a name="357"/>		then {
<a name="358"/>		    close(f)
<a name="359"/>		    # if entry ends in tc= then add in the named tc entry
<a name="360"/>		    entry ?:= tab(find("tc=")) ||
<a name="361"/>		    # recursively fetch the new termcap entry
<a name="362"/>			(move(3), getentry(tab(find(":"))) ?
<a name="363"/>			 # remove the name field from the new entry
<a name="364"/>			 (tab(find(":")+1), tab(0)))
<a name="365"/>		    return entry
<a name="366"/>		}
<a name="367"/>		else {
<a name="368"/>		    \line := &amp;null # must precede the next line
<a name="369"/>		    entry ||:= trim(tab(0),'\\')
<a name="370"/>		}
<a name="371"/>	    }
<a name="372"/>	}
<a name="373"/>    }
<a name="374"/>
<a name="375"/>    close(f)
<a name="376"/>    er("getentry","can't find and/or process your termcap entry",3)
<a name="377"/> 
<a name="378"/>end
<a name="379"/>
<a name="380"/>
<a name="381"/>
<a name="382"/>procedure read_file(f)
<a name="383"/>
<a name="384"/>    # Suspends all non #-initial lines in the file f.
<a name="385"/>    # Removes leading tabs and spaces from lines before suspending
<a name="386"/>    # them.
<a name="387"/>
<a name="388"/>    local line
<a name="389"/>
<a name="390"/>    \f | er("read_tcap_file","no valid termcap file found",3)
<a name="391"/>    while line := read(f) do {
<a name="392"/>	match("#",line) &amp; next
<a name="393"/>	line ?:= (tab(many('\t ')) | &amp;null, tab(0))
<a name="394"/>	suspend line
<a name="395"/>    }
<a name="396"/>
<a name="397"/>    fail
<a name="398"/>
<a name="399"/>end
<a name="400"/>
<a name="401"/>
<a name="402"/>
<a name="403"/>procedure maketc_table(entry)
<a name="404"/>
<a name="405"/>    # Maketc_table(s) (where s is a valid termcap entry for some
<a name="406"/>    # terminal-type): Returns a table in which the keys are termcap
<a name="407"/>    # capability designators, and the values are the entries in
<a name="408"/>    # "entry" for those designators.
<a name="409"/>
<a name="410"/>    local k,  str, decoded_value
<a name="411"/>
<a name="412"/>    /entry &amp; er("maketc_table","no entry given",8)
<a name="413"/>    if entry[-1] ~== ":" then entry ||:= ":"
<a name="414"/>    
<a name="415"/>    /tc_table := table()
<a name="416"/>
<a name="417"/>    entry ? {
<a name="418"/>
<a name="419"/>	tab(find(":")+1)	# tab past initial (name) field
<a name="420"/>
<a name="421"/>	while tab((find(":")+1) \ 1) ? {
<a name="422"/>	    &amp;subject == "" &amp; next
<a name="423"/>	    if k := 1(move(2), ="=") then {
<a name="424"/>		# Get rid of null padding information.  Iolib can't
<a name="425"/>		# handle it (unlike itlib.icn).  Leave star in.  It
<a name="426"/>		# indicates a real dinosaur terminal, and will later
<a name="427"/>		# prompt an abort.
<a name="428"/>		str := ="*" | ""; tab(many(&amp;digits))
<a name="429"/>		decoded_value := Decode(str || tab(find(":")))
<a name="430"/>	    }
<a name="431"/>	    else if k := 1(move(2), ="#")
<a name="432"/>	    then decoded_value := integer(tab(find(":")))
<a name="433"/>	    else if k := 1(tab(find(":")), pos(-1))
<a name="434"/>	    then decoded_value := true()
<a name="435"/>	    else er("maketc_table", "your termcap file has a bad entry",3)
<a name="436"/>	    /tc_table[k] := decoded_value
<a name="437"/>	    &amp;null
<a name="438"/>	}
<a name="439"/>    }
<a name="440"/>
<a name="441"/>    return tc_table
<a name="442"/>
<a name="443"/>end
<a name="444"/>
<a name="445"/>
<a name="446"/>
<a name="447"/>procedure getval(id)
<a name="448"/>
<a name="449"/>    /tc_table := maketc_table(getentry(getname())) |
<a name="450"/>	er("getval","can't make a table for your terminal",4)
<a name="451"/>
<a name="452"/>    return \tc_table[id] | fail
<a name="453"/>	# er("getval","the current terminal doesn't support "||id,7)
<a name="454"/>
<a name="455"/>end
<a name="456"/>
<a name="457"/>
<a name="458"/>
<a name="459"/>procedure Decode(s)
<a name="460"/>
<a name="461"/>    # Does things like turn ^ plus a letter into a genuine control
<a name="462"/>    # character.
<a name="463"/>
<a name="464"/>    local new_s, chr, chr2
<a name="465"/>
<a name="466"/>    new_s := ""
<a name="467"/>
<a name="468"/>    s ? {
<a name="469"/>
<a name="470"/>	while new_s ||:= tab(upto('\\^')) do {
<a name="471"/>	    chr := move(1)
<a name="472"/>	    if chr == "\\" then {
<a name="473"/>		new_s ||:= {
<a name="474"/>		    case chr2 := move(1) of {
<a name="475"/>			"\\" : "\\"
<a name="476"/>			"^"  : "^"
<a name="477"/>			"E"  : "\e"
<a name="478"/>			"b"  : "\b"
<a name="479"/>			"f"  : "\f"
<a name="480"/>			"n"  : "\n"
<a name="481"/>			"r"  : "\r"
<a name="482"/>			"t"  : "\t"
<a name="483"/>			default : {
<a name="484"/>			    if any(&amp;digits,chr2) then {
<a name="485"/>				char(integer("8r"||chr2||move(2 to 0 by -1))) |
<a name="486"/>				    er("Decode","bad termcap entry",3)
<a name="487"/>			    }
<a name="488"/>			   else chr2
<a name="489"/>			}
<a name="490"/>		    }
<a name="491"/>		}
<a name="492"/>	    }
<a name="493"/>	    else new_s ||:= char(ord(map(move(1),&amp;lcase,&amp;ucase)) - 64)
<a name="494"/>	}
<a name="495"/>	new_s ||:= tab(0)
<a name="496"/>    }
<a name="497"/>
<a name="498"/>    return new_s
<a name="499"/>
<a name="500"/>end
<a name="501"/>
<a name="502"/>
<a name="503"/>
<a name="504"/>procedure igoto(cm,col,line)
<a name="505"/>
<a name="506"/>    local colline, range, increment, padding, str, outstr, chr, x, y
<a name="507"/>
<a name="508"/>    if \col &gt; (tc_table["co"]) | \line &gt; (tc_table["li"]) then {
<a name="509"/>	colline := string(\col) || "," || string(\line) | string(\col|line)
<a name="510"/>	range := "(" || tc_table["co"]-1 || "," || tc_table["li"]-1 || ")"
<a name="511"/>	er("igoto",colline || " out of range " || (\range|""),9)
<a name="512"/>    } 
<a name="513"/>
<a name="514"/>    # Use the Iconish 1;1 upper left corner &amp; not the C-ish 0 offsets
<a name="515"/>    increment := -1
<a name="516"/>    outstr := ""
<a name="517"/>    
<a name="518"/>    cm ? {
<a name="519"/>	while outstr ||:= tab(find("%")) do {
<a name="520"/>	    tab(match("%"))
<a name="521"/>	    if padding := integer(tab(any('23')))
<a name="522"/>	    then chr := (="d" | "d")
<a name="523"/>	    else chr := move(1)
<a name="524"/>	    if case \chr of {
<a name="525"/>		"." :  outstr ||:= char(line + increment)
<a name="526"/>		"+" :  outstr ||:= char(line + ord(move(1)) + increment)
<a name="527"/>		"d" :  {
<a name="528"/>		    str := string(line + increment)
<a name="529"/>		    outstr ||:= right(str, \padding, "0") | str
<a name="530"/>		}
<a name="531"/>	    }
<a name="532"/>	    then line :=: col
<a name="533"/>	    else {
<a name="534"/>		case chr of {
<a name="535"/>		    "n" :  line := ixor(line,96) &amp; col := ixor(col,96)
<a name="536"/>		    "i" :  increment := 0
<a name="537"/>		    "r" :  line :=: col
<a name="538"/>		    "%" :  outstr ||:= "%"
<a name="539"/>		    "B" :  line := ior(ishift(line / 10, 4), line % 10)
<a name="540"/>		    "&gt;" :  {
<a name="541"/>			x := move(1); y := move(1)
<a name="542"/>			line &gt; ord(x) &amp; line +:= ord(y)
<a name="543"/>			&amp;null
<a name="544"/>		    }
<a name="545"/>		} | er("goto","bad termcap entry",5)
<a name="546"/>	    }
<a name="547"/>	}
<a name="548"/>    return outstr || tab(0)
<a name="549"/>    }
<a name="550"/>
<a name="551"/>end
<a name="552"/>
<a name="553"/>
<a name="554"/>
<a name="555"/>procedure iputs(cp, affcnt)
<a name="556"/>
<a name="557"/>    # Writes cp to the screen.  Use this instead of writes() for
<a name="558"/>    # compatibility with itlib (a UNIX-only version which can handle
<a name="559"/>    # albeit inelegantly) terminals that need padding.
<a name="560"/>
<a name="561"/>    static num_chars
<a name="562"/>    initial num_chars := &amp;digits ++ '.'
<a name="563"/>
<a name="564"/>    type(cp) == "string" |
<a name="565"/>	er("iputs","you can't iputs() a non-string value!",10)
<a name="566"/>
<a name="567"/>    cp ? {
<a name="568"/>	if tab(many(num_chars)) &amp; ="*" then
<a name="569"/>	    stop("iputs:  iolib can't use terminals that require padding.")
<a name="570"/>	writes(tab(0))
<a name="571"/>    }
<a name="572"/>
<a name="573"/>    return
<a name="574"/>
<a name="575"/>end
</pre></body></html>
