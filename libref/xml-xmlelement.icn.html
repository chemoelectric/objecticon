<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>xmlelement.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: xmlelement.icn 7415 2019-01-25 16:51:58Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package xml
<a name="10"/>
<a name="11"/>import lang, io, ipl.pdco
<a name="12"/>
<a name="13"/>#
<a name="14"/># This class represents an element in an XML document.  It has extra
<a name="15"/># attributes and methods to deal with XML namespaces.
<a name="16"/>#
<a name="17"/># For example, given the document
<a name="18"/># ~~
<a name="19"/>#   &lt;?xml version="1.0" ?&gt;
<a name="20"/>#   &lt;top xmlns:nsid="http://an.url.com"&gt;
<a name="21"/>#     &lt;nsid:inner nsid:attr="val"/&gt;
<a name="22"/>#   &lt;/top&gt;
<a name="23"/># ~~
<a name="24"/>#
<a name="25"/># If n is the `XmlElement` representing the ~~&lt;top&gt;~~ element, then its
<a name="26"/># global name is ~~GlobalName("top")~~ (ie the same as its local name).  The inner
<a name="27"/># `XmlElement` however, has a global name of 
<a name="28"/># ~~
<a name="29"/>#    GlobalName("inner", "http://an.url.com"),
<a name="30"/># ~~
<a name="31"/># and a single attribute with key 
<a name="32"/># ~~
<a name="33"/>#    GlobalName("attr", "http://an.url.com").
<a name="34"/># ~~
<a name="35"/>#
<a name="36"/># The original parsed name and attribute table are still available
<a name="37"/># via the methods in the superclass `Element`.  For example, `get_name()`
<a name="38"/># for the inner `XmlElement` returns "nsid:inner".   
<a name="39"/>#
<a name="40"/>class XmlElement(Element)
<a name="41"/>   public 
<a name="42"/>      whitespace_children,
<a name="43"/>      global_name, 
<a name="44"/>      attributes_global_name, 
<a name="45"/>      namespace_declarations, 
<a name="46"/>      xml_space_preserve
<a name="47"/>
<a name="48"/>   #
<a name="49"/>   # Set the global (namespace-aware) name.  The global
<a name="50"/>   # name should be a `GlobalName` instance.
<a name="51"/>   #
<a name="52"/>   # :Parameters :
<a name="53"/>   # :  `s` - a `GlobalName` instance representing the global name.
<a name="54"/>   #
<a name="55"/>   public set_global_name(s)
<a name="56"/>      global_name := s
<a name="57"/>      link
<a name="58"/>   end
<a name="59"/>
<a name="60"/>   #
<a name="61"/>   # Succeed iff the parser applied the xml:space="preserve" feature
<a name="62"/>   # when parsing this element.
<a name="63"/>   #
<a name="64"/>   public xml_space_preserved()
<a name="65"/>      return \self.xml_space_preserve
<a name="66"/>   end
<a name="67"/>
<a name="68"/>   #
<a name="69"/>   # Get whitespace children.  During validation, the parser may remove insignificant
<a name="70"/>   # whitespace from the children list.  This method will always give the original list
<a name="71"/>   # including whitespace.  If no whitespace was removed, this list will be identical
<a name="72"/>   # to the children list.
<a name="73"/>   #
<a name="74"/>   public get_whitespace_children()
<a name="75"/>      return whitespace_children
<a name="76"/>   end
<a name="77"/>
<a name="78"/>   #
<a name="79"/>   #
<a name="80"/>   # Return the table of namespace declarations for this element.  The table
<a name="81"/>   # will be a map of prefixes to URI's.
<a name="82"/>   #
<a name="83"/>   public get_namespace_declarations()
<a name="84"/>      return namespace_declarations
<a name="85"/>   end
<a name="86"/>
<a name="87"/>   #
<a name="88"/>   # Get the global name, which will be a `GlobalName` instance.
<a name="89"/>   #
<a name="90"/>   # :Returns :
<a name="91"/>   # :  a `GlobalName` instance representing the global name.
<a name="92"/>   #
<a name="93"/>   public get_global_name()
<a name="94"/>      return global_name
<a name="95"/>   end
<a name="96"/>
<a name="97"/>   #
<a name="98"/>   # Return the global name attributes map for this tag.  This will
<a name="99"/>   # be a table of `GlobalName` instances to values.
<a name="100"/>   #
<a name="101"/>   public get_attributes_global_name()
<a name="102"/>      return attributes_global_name
<a name="103"/>   end
<a name="104"/>
<a name="105"/>   #
<a name="106"/>   # Return the attribute for this tag, or fail if none found, based on
<a name="107"/>   # the given `GlobalName`.
<a name="108"/>   #
<a name="109"/>   # :Parameters :
<a name="110"/>   # :  `gn` - the `GlobalName` instance representing the global name
<a name="111"/>   #
<a name="112"/>   public get_attribute_global_name(gn)
<a name="113"/>      local e
<a name="114"/>      #
<a name="115"/>      # Unfortunately we have to iterate through because the GlobalNames
<a name="116"/>      # are stored in the map by identity.
<a name="117"/>      #
<a name="118"/>      every e := key(attributes_global_name) do {
<a name="119"/>         if equals(e, gn) then
<a name="120"/>            return attributes_global_name[e]
<a name="121"/>      }
<a name="122"/>   end
<a name="123"/>
<a name="124"/>   #
<a name="125"/>   # Search for all the `Element`s with the given tag name, recursively
<a name="126"/>   # traversing the entire tree based at this node.
<a name="127"/>   #
<a name="128"/>   # :Parameters :
<a name="129"/>   # :  `s` - a `GlobalName`, being the name of the sub-elements
<a name="130"/>   #
<a name="131"/>   public search_tree_global_name(s)
<a name="132"/>      local n
<a name="133"/>      every n := Seq{traverse_nodes_preorder()} do
<a name="134"/>         if is(n, Element) &amp; (/s | equals(n.get_global_name(), s)) then
<a name="135"/>            suspend n
<a name="136"/>   end
<a name="137"/>
<a name="138"/>   #
<a name="139"/>   # Generate the elements under this element, with the given name.  If name
<a name="140"/>   # is omitted, generate all the elements.
<a name="141"/>   #
<a name="142"/>   # :Parameters :
<a name="143"/>   # :  `s` - a `GlobalName`, being the name of the sub-elements
<a name="144"/>   #
<a name="145"/>   public search_children_global_name(s)
<a name="146"/>      local n
<a name="147"/>      every n := !children do
<a name="148"/>         if not(text(n)) &amp; is(n, Element) &amp; (/s | equals(n.get_global_name(), s)) then
<a name="149"/>            suspend n
<a name="150"/>   end
<a name="151"/>
<a name="152"/>   public override print_structure(f, indent, flags)
<a name="153"/>      local s, x, i, e, j
<a name="154"/>
<a name="155"/>      if /flags then {
<a name="156"/>         Element.print_structure(f, indent, flags)
<a name="157"/>         return
<a name="158"/>      }
<a name="159"/>
<a name="160"/>      /indent := 0
<a name="161"/>      i := repl(" ", indent * 5)
<a name="162"/>      write(f, i || "Tag : &lt;" || to_string(self.global_name) || "&gt;")
<a name="163"/>      s := ""
<a name="164"/>      every x := !sort(self.attributes_global_name) do {
<a name="165"/>         s ||:= to_string(x[1]) || "=" || image(x[2]) || " "
<a name="166"/>      }
<a name="167"/>      write(f, i || "Attributes : " || s)
<a name="168"/>      write(f, i || "Contents :")
<a name="169"/>      every j := 1 to *children do {
<a name="170"/>         writes(i || j || ":")
<a name="171"/>         e := children[j]
<a name="172"/>         if text(e) then
<a name="173"/>            write(f, image(e))
<a name="174"/>         else {
<a name="175"/>            write(f)
<a name="176"/>            e.print_structure(f, indent + 1, flags)
<a name="177"/>         }
<a name="178"/>      }
<a name="179"/>      write(f, i, "End of tag : &lt;/", to_string(self.global_name), "&gt;")
<a name="180"/>   end
<a name="181"/>
<a name="182"/>   public override new(n)
<a name="183"/>      Element.new(n)
<a name="184"/>      attributes_global_name := table()
<a name="185"/>      namespace_declarations := table()
<a name="186"/>      return
<a name="187"/>   end
<a name="188"/>end
<a name="189"/>
</pre></body></html>
