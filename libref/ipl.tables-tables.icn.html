<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>tables.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     tables.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures for table manipulation
<a name="6"/>#
<a name="7"/>#	Author:   Ralph E. Griswold
<a name="8"/>#
<a name="9"/>#	Date:     August 20, 1996
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#	Contributor:  Alan Beale
<a name="18"/>#
<a name="19"/>############################################################################
<a name="20"/>#
<a name="21"/>#  For the operations on tables that mimic set operations, the
<a name="22"/>#  correspondences are only approximate and do not have the mathematical
<a name="23"/>#  properties of the corresponding operations on  sets.  For example, table
<a name="24"/>#  "union" is not symmetric or transitive.
<a name="25"/>#
<a name="26"/>#  Where there is potential asymmetry, the procedures "favor" their
<a name="27"/>#  first argument.
<a name="28"/>#
<a name="29"/>#  All the procedures that return tables return new tables and do not
<a name="30"/>#  modify their arguments.
<a name="31"/>#
<a name="32"/>############################################################################
<a name="33"/>
<a name="34"/>package ipl.tables
<a name="35"/>
<a name="36"/>import
<a name="37"/>   ipl.pdco(List,Set,Index),
<a name="38"/>   datastruct(Entries, EntryList)
<a name="39"/>
<a name="40"/># Table union, approximates `T1 ++ T2`.
<a name="41"/>procedure tblunion(T1, T2)			
<a name="42"/>   local T3, x
<a name="43"/>
<a name="44"/>   T3 := copy(T1)
<a name="45"/>
<a name="46"/>   every x := key(T2) do
<a name="47"/>      insert(T3, x, T2[x])
<a name="48"/>
<a name="49"/>   return T3
<a name="50"/>
<a name="51"/>end
<a name="52"/>
<a name="53"/># Table intersection, approximates `T1 ** T2`.
<a name="54"/>procedure tblinter(T1, T2)			
<a name="55"/>   local T3, x
<a name="56"/>
<a name="57"/>   T3 := table(tbldflt(T1))
<a name="58"/>
<a name="59"/>   every x := key(T1) do
<a name="60"/>      if member(T2, x) then insert(T3, x, T1[x])
<a name="61"/>   
<a name="62"/>   return T3
<a name="63"/>
<a name="64"/>end
<a name="65"/>
<a name="66"/># Table difference, approximates `T1 -- T2`.
<a name="67"/>procedure tbldiff(T1, T2)			
<a name="68"/>   local T3, x
<a name="69"/>
<a name="70"/>   T3 := copy(T1)
<a name="71"/>
<a name="72"/>   every x := key(T2) do
<a name="73"/>      delete(T3, x)
<a name="74"/>
<a name="75"/>   return T3
<a name="76"/>
<a name="77"/>end
<a name="78"/>
<a name="79"/># Table inversion; produces a table whose keys are `T`'s values and
<a name="80"/># whose values are `T`'s keys.
<a name="81"/>#
<a name="82"/>procedure tblinvrt(T)				
<a name="83"/>   local T1, x
<a name="84"/>
<a name="85"/>   T1 := table(tbldflt(T))
<a name="86"/>
<a name="87"/>   every x := key(T) do
<a name="88"/>      insert(T1, T[x], x)
<a name="89"/>
<a name="90"/>   return T1
<a name="91"/>
<a name="92"/>end
<a name="93"/>
<a name="94"/># Produces the default value for `T`.
<a name="95"/>procedure tbldflt(T)				
<a name="96"/>   static probe
<a name="97"/>
<a name="98"/>   initial probe := []			# only need one
<a name="99"/>
<a name="100"/>   return T[probe]
<a name="101"/>
<a name="102"/>end
<a name="103"/>
<a name="104"/># Produces a two-way table based on `T`.
<a name="105"/>procedure twt(T)				
<a name="106"/>   local T1, x
<a name="107"/>
<a name="108"/>   T1 := copy(T)
<a name="109"/>
<a name="110"/>   every x := key(T) do
<a name="111"/>      insert(T1, T[x], x)
<a name="112"/>
<a name="113"/>   return T1
<a name="114"/>
<a name="115"/>end
<a name="116"/>
<a name="117"/># Produces sorted list of keys in table `T`.
<a name="118"/>procedure keylist(tbl)			
<a name="119"/>   return sort(List{ key(tbl) })
<a name="120"/>end
<a name="121"/>
<a name="122"/># Produces values in `T` ordered by sorted order of keys.
<a name="123"/>procedure kvallist(T)
<a name="124"/>   return List{ T[!keylist(T)] }
<a name="125"/>end
<a name="126"/>
<a name="127"/># Tests equivalences of tables `T1` and `T2`.
<a name="128"/>procedure tbleq(tbl1, tbl2)		
<a name="129"/>   local x
<a name="130"/>   static prod
<a name="131"/>
<a name="132"/>   initial prod := []
<a name="133"/>
<a name="134"/>   if *tbl1 ~= *tbl2 then fail
<a name="135"/>   if tbl1[prod] ~=== tbl2[prod] then fail
<a name="136"/>   else every x := key(tbl1) do
<a name="137"/>      if not(member(tbl2, x)) |
<a name="138"/>         (tbl2[x] ~=== tbl1[x]) then fail
<a name="139"/>   return tbl2
<a name="140"/>
<a name="141"/>end
<a name="142"/>
<a name="143"/># Produces sorted list of values in table `T`.
<a name="144"/>procedure vallist(tbl)		
<a name="145"/>   return sort(List{ !tbl })
<a name="146"/>end
<a name="147"/>
<a name="148"/># Produces set of values in table `T`.
<a name="149"/>procedure valset(tbl)		
<a name="150"/>   return Set{ !tbl }
<a name="151"/>end
<a name="152"/>
<a name="153"/>#
<a name="154"/># Generate key-value pairs as a sequence of `Entry` records.  NB -
<a name="155"/># for each invocation, the same record is returned every time, with
<a name="156"/># the values replaced.
<a name="157"/>#
<a name="158"/>procedure entries(t)
<a name="159"/>   suspend Entries{ keyval(t) }
<a name="160"/>end
<a name="161"/>
<a name="162"/># Return a flat list, with alternating key-value entries.
<a name="163"/>procedure flatten(t)
<a name="164"/>   return List{ keyval(t) }
<a name="165"/>end
<a name="166"/>
<a name="167"/># Return an (unsorted) list of pairs of key-values.  Apply `sortf(l,
<a name="168"/># 1)` to the result to get a sorted list.
<a name="169"/>procedure entrylist(t)
<a name="170"/>   return EntryList{ keyval(t) }
<a name="171"/>end
<a name="172"/>
<a name="173"/># Return a random key from table t
<a name="174"/>procedure randomkey(t)
<a name="175"/>   return Index{ key(t), ?(0 &lt; *t) }
<a name="176"/>end
<a name="177"/>
<a name="178"/>#  inserts() -- Inserts values into a table in which the same key can
<a name="179"/>#  have more than one value (i.e., duplicate keys).  The value of each
<a name="180"/>#  element is a list of inserted values.
<a name="181"/>#
<a name="182"/>procedure inserts(t, k, v)
<a name="183"/>   put(member(t, k), v) | insert(t, k, [v])
<a name="184"/>   return t
<a name="185"/>end
<a name="186"/>
<a name="187"/>#
<a name="188"/># This is like `inserts()` above, but the values of the given table are
<a name="189"/># sets rather than lists.
<a name="190"/>#
<a name="191"/>procedure inserts_set(t, k, v)
<a name="192"/>   insert(member(t, k), v) | insert(t, k, set(v))
<a name="193"/>   return t
<a name="194"/>end
<a name="195"/>
</pre></body></html>
