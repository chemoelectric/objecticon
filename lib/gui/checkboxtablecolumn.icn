package gui

import util

#
# A table column that provides on/off checkbox-like behaviour for
# each of its lines.   The corresponding data items are "y" or "n"
# strings, representing on or off button states respectively.
#
# @field images=s1,s2 : see {set_images}
# @field single_selection=flag : see {set_single_selection}
# @field see also {TableColumn}
#
class CheckBoxTableColumn(TableColumn)
   public 
      single_selection_flag,
      img_up, 
      img_down,
      img_w,
      img_h

   public calculate_line_height()
      return img_h + 8
   end

   #
   # Set whether or not we select one item in the column; the behaviour
   # is then like a column of radio buttons rather than a column of
   # checkboxes.
   #
   public set_single_selection(s)
      self.single_selection_flag := to_flag(s)
   end

   #
   # Set the up and down images to x and y respectively.  The
   # default is boxes, or diamonds depending on the single_selection flag.
   #
   public set_images(x, y)
      self.img_up := x
      self.img_down := y
      self.img_w := image_width(x) = image_width(y) | runerr("Image widths differ")
      self.img_h := image_height(x) = image_height(y) | runerr("Image heights differ")
   end

   public mouse_down(e)
      local line, col
      self.x <= e.x < self.x + self.w | fail
      line := get_table_content().get_line_under_pointer(e) | fail
      col := get_column_index()
      if \self.single_selection_flag then {
         every get_table_content().slice(col) := "n"
         get_table_content().get_cell(line, col) := "y"
      } else
         get_table_content().get_cell(line, col) := 
                if get_table_content().get_cell(line, col) == "y" then "n" else "y"
      get_table_content().contents_changed()
      fire(Event.VALUE_CHANGED, line)
   end

   public initially()
      #
      # Set the icons if necessary
      #
      if /self.img_up then {
         if /self.single_selection_flag then
            self.set_images(Icon.BOX_UP, Icon.BOX_DOWN)
         else
            self.set_images(Icon.DIAMOND_UP, Icon.DIAMOND_DOWN)
      }
      get_table_content().connect(self.mouse_down, Event.MOUSE_LEFT_PRESS)
      cast(self,TableColumn).initially()
   end

   public finally()
      cast(self,TableColumn).finally()
      get_table_content().disconnect_object(self)
   end

   public draw_cell(W, data, line, col, cy, ch)
      local x1, y1
      x1 := case border.x_align of {
         Align.R : self.tx + self.tw - img_w
         Align.C : self.tx + (self.tw - img_w)/2
         Align.L : self.tx
         default : runerr("Bad column alignment", border.x_align)
      }
      y1 := cy + (ch - img_h) / 2
      draw_image_ex(W, x1, y1, 
                  if data == "y" then img_down else img_up)
   end

   public set_one(f)
      case f.attr of {
         "images" : set_images!(f.string_list_val(2))
         "single_selection" : set_single_selection(f.flag_val())
         default: return cast(self,TableColumn).set_one(f)
      }
      return
   end
end



