package numbers

import lang, ipl.numbers(gcd), ipl.types, util, ipl.functional

# This class encapsulates options for rounding a decimal number.
#
final class Round()
   public const
      # Set if rounding is to decimal places rather than a precision.
      dp_flag,
      # The number of digits to round to.
      digits,
      # The mode, indicating which direction to round
      mode

   public static const
      # Rounding mode to round away from zero.
      UP,
      # Rounding mode to round towards zero (ie, simple truncation).
      DOWN,
      # Rounding mode to round towards positive infinity.
      CEILING,
      # Rounding mode to round towards negative infinity.
      FLOOR,
      # Rounding mode to round towards "nearest neighbour" unless both
      # neighbours are equidistant, in which case round up.  This is
      # conventional rounding.
      HALF_UP,
      # Rounding mode to round towards "nearest neighbour" unless both
      # neighbours are equidistant, in which case round down.
      HALF_DOWN

   private static init()
      UP := "up"
      DOWN := "down"
      CEILING := "ceiling"
      FLOOR := "floor"
      HALF_UP := "half-up"
      HALF_DOWN := "half-down"
   end

   # Return another instance with the same settings, but with digits
   # set to `n`.
   #
   public with_digits(n)
      return need_Round(need_integer(n) || 
         (if \dp_flag then "dp " else " ") || mode)
   end

   # Convenient method to call `with_digits` with this instance's
   # digits setting plus n.
   public add(n)
      return with_digits(digits + n)
   end

   # Succeed if this mode's rounding is influenced by digits truncated
   # beyond the first truncated digit.  For example `HALF_UP` isn't
   # influenced; if we are rounding 6.5xxx to one digit then we don't
   # care what the digits xxx are; it will round to 7 regardless.  But for
   # `HALF_DOWN` it does matter; if xxx is zero then we get 6,
   # otherwise we get 7.
   #
   # In fact, only `HALF_UP` and `DOWN` don't care about these extra
   # truncated digits;
   #
   public uses_all_digits()
      return not( mode == (HALF_UP | DOWN) )
   end

   # Given a digit `n`, which is in the range -9 to +9, return -1, 0,
   # or 1 indicating how the associated number should be rounded.  `d`
   # indicates whether any digits beyond `n` have been truncated.  If
   # it is 0, then they haven't, otherwise it will have the sign of
   # the number being rounded.  For example, if rounding 1.235 to two
   # decimal places, n would be 5 and d would be 0; if we were
   # rounding 1.2350001, then n would be 5, and d would be >0, to
   # indicate that digits existed to the right of 5.
   #
   public round_dig(n, d)
      return case mode of {
         HALF_UP :  {
            if n <= -5 then -1
            else if n >= 5 then 1
            else 0
         }
         HALF_DOWN :  {
            if n = 5 then if d = 0 then 0 else 1
            else if n = -5 then if d = 0 then 0 else -1
            else if n < -5 then -1
            else if n > 5 then 1
            else 0
         }
         UP : {
            if (n|d) > 0 then 1
            else if (n|d) < 0 then -1
            else 0
         }
         DOWN: 0
         CEILING: if (n|d) > 0 then 1 else 0
         FLOOR: if (n|d) < 0 then -1 else 0
         default: syserr("Invalid rounding mode")
      }
   end

   private parse(x)
      local t
      x ? {
         tab_ws()
         digits := integer(tab(many(&digits ++ '+\-'))) | fail
         if ="dp" then
            dp_flag := &yes
         tab_ws()
         if pos(0) then
            mode := HALF_UP
         else {
            t := Text.lower(tab(many(&letters ++ '\-'))) | fail
            mode := case t of {
               UP | "u" : UP
               DOWN | "d" | "t" | "trunc" | "truncate" : DOWN
               CEILING | "ceil" | "c": CEILING
               FLOOR | "f" : FLOOR
               HALF_UP | "hu" : HALF_UP
               HALF_DOWN | "hd" : HALF_DOWN
               default : fail
            }
            # Check at end
            tab_ws()
            pos(0) | fail
         }
      }
      return
   end

   # Create a new instance from string `s`, which is in the format
   #
   # ~
   #    <digits>["dp"] [mode]
   # ~
   #
   # Digits provides the digit setting; if followed immediately by
   # "dp", then this sets the dp_flag.  The mode follows after one or
   # more spaces, and defaults to `HALF_UP`.
   #
   # Possible modes are :-
   #
   # ~
   #     "up" or "u" : UP
   #     "down", "d", "t" or "trunc" : DOWN
   #     "ceiling" or "c" : CEILING
   #     "floor" or "f" : FLOOR
   #     "half-up" or "hu" : HALF_UP
   #     "half-down" or "hd" : HALF_DOWN
   # ~
   #
   # Examples :
   #
   # ~
   #      "8dp trunc"    -  truncate to 8 decimal places.
   #      "10 hd"        -  precision 10, with half down
   #                        rounding.
   #      10             -  precision 10, half up.
   # ~
   public new(s)
      s := need_string(s)
      parse(s) | return error("Couldn't parse string to a Round")
      if /dp_flag & digits < 1 then
         return error("Number of rounding digits outside valid range (>= 1)")
      return
   end
end

# Abstract parent class for the three number types, `Cpx`, `Rat` and
# `Dec`.  The latter two are in fact subclasses via `RealNumber`.
#
protected abstract class Number(ObjectOutput)
   public static const
      # Precision used in converting to icon real type
      REAL_DIGS

   private static init()
      REAL_DIGS := 20
   end

   # Add this instance to another instance of the same type.
   public abstract add(x, rnd)

   # Multiply this instance by another instance of the same type.
   public abstract mul(x, rnd)

   # Divide this instance by another instance of the same type, with
   # optional rounding `rnd`, if applicable to the type concerned.
   public abstract div(x, rnd)

   # Return this instance negated.
   public abstract neg()

   # Return a simplified equivalent to this instance; for example a
   # `Rat` with denominator 1 returns its numerator (as a `Dec`).  If
   # no simplification is possible, `self` is returned.
   public abstract reduce()

   # Produce formatted string output.
   public abstract str(fmt, dp)

   # Subtract the other instance of the same type from this instance.
   public abstract sub(x, rnd)

   protected override object_output(oo)
      oo.object_string(self, str())
   end
end

# A class representing complex numbers.
#
# Instances are immutable and the real and imaginary parts are either
# `Rat` or `Dec` instances.
#
class Cpx(Number)
   public const
      # The real part of this number
      r,
      # The imaginary part of this number
      i

   #
   # Convert to a string.
   #
   # :Parameters :
   # :  `f` -  A cset of flags, passed to the `str` method of the
   #           real and imaginary parts.
   # :  `dp`   The number of decimal places to produce (if either
   #           part is a `Dec`).
   #
   public override str(f, dp)
      return "r=" || r.str(f, dp) || " i=" || i.str(f, dp)
   end

   #
   # Add this complex to another.
   #
   # :Parameters :
   # :  `x` - a `Cpx`.
   # :  `rnd` - null, or something convertible to a `Round`.
   #
   public override add(x, rnd)
      x := need_Cpx(x)
      return Cpx(numbers.add(r, x.r, rnd), numbers.add(i, x.i, rnd))
   end

   # Subtract another complex from this one.
   #
   # :Parameters :
   # :  `x` - a `Cpx`.
   # :  `rnd` - null, or something convertible to a `Round`.
   #
   public override sub(x, rnd)
      return add(need_Cpx(x).neg(), rnd)
   end

   #
   # Multiply this complex by another.
   #
   # :Parameters :
   # :  `x` - a `Cpx`.
   # :  `rnd` - null, or something convertible to a `Round`.
   #
   public override mul(x, rnd)
      x := need_Cpx(x)
      return Cpx(numbers.sub(numbers.mul(r, x.r), numbers.mul(i, x.i), rnd),
                 numbers.add(numbers.mul(r, x.i), numbers.mul(i, x.r), rnd))
   end

   # Divide this complex by another, using the specified rounding.
   #
   # :Parameters :
   # :  `x` - a `Cpx`.
   # :  `rnd` - null, or something convertible to a `Round`.
   #
   public override div(x, rnd)
      local denom
      x := need_Cpx(x)
      denom := numbers.add(numbers.mul(x.r,x.r), numbers.mul(x.i,x.i))
      return Cpx(numbers.div(numbers.add(numbers.mul(r, x.r), numbers.mul(i, x.i)), denom, rnd),
                 numbers.div(numbers.sub(numbers.mul(i, x.r), numbers.mul(r, x.i)), denom, rnd))
   end

   # Return this complex negated.
   #
   public override neg()
      return Cpx(r.neg(), i.neg())
   end

   public override reduce()
      return real_number() | self
   end

   # Convert to a `RealNumber`, returning the real part if and only if
   # the imaginary part is zero.
   public real_number()
      if i.sign() = 0 then
         return r
   end

   # Create a new `Cpx` instance with real part `x` and imaginary part
   # `y`.  Both parameters must be convertible to `Rat` or `Dec`.
   #
   # :Parameters :
   # :  `x` - something convertible to `Dec` or `Rat`
   # :  `y` - something convertible to `Dec` or `Rat`
   #
   public new(x, y)
      r := need_RealNumber(x)
      i := need_RealNumber(y)
      return
   end
end

# This class just lists operations common to its two subclasses, `Dec` and `Rat`.
#
abstract class RealNumber(Number)
   # Compare this instance to another of the same type using the
   # relational operator `f`.  For example,
   # ~
   #   x.cmp("<", y)
   # ~
   # succeeds iff `x < y`.
   #
   public cmp(f, x)
      succeed f(sub(x).sign(), 0)
   end

   # Return the absolute value of this number.
   public abs()
      return if sign() >= 0 then self else neg()
   end

   # Return the sign of this number (-1, 0 or 1, depending on whether
   # it is less than, equal to, or greater than zero).
   public abstract sign()

   # Subtract x from this instance and return the sign of the result.
   # This is useful for sorting; see `number_comparator()` below.
   #
   public sub_sign(x)
      return sub(x).sign()
   end

   # Convert to `Dec`, or fail if no rounding is specified and an
   # exact conversion is not possible.
   #
   public abstract decimal(rnd)

   # Convert to `Rat`
   #
   public abstract rational()

   # Convert to integer
   #
   public abstract integer()

   # Convert to real, or fail if that is not possible.
   #
   public abstract real()
end

# A class representing rational numbers.
#
# All instances are immutable and are stored in a normalized form, so
# that two instances representing the same number always have the same
# numerator and denominator.
#
class Rat(RealNumber)
   public const
      # The integer numerator
      n,
      # The integer denominator, which is always positive.
      d

   private static commas(n, f)
      n := string(n)
      if any(f, ",") then
         every n[*n - 3 to 1 by -3] ||:= Format.THOUSANDS_SEPARATOR
      return n
   end

   #
   # Convert to a string.
   #
   # :Parameters :
   # :  `f` -  A cset of flags.  If c contains ',' then commas
   #           are introduced into the non-fractional part of the number;
   #           if c contains '+' then a leading + is added to positive
   #           numbers.  If c contains 't' then no whole number is output
   #           before the fractional part (eg 4/3 rather than 1 1/3).
   #
   public override str(f)
      local i, s, n1
      n1 := default.abs(n)
      f := need_cset(\f) | ''
      if d = 1 then
         s := commas(n1, f)
      else {
         s := if any(f, "t") | (i := n1 / d) = 0 then
            commas(n1, f) || "/" || commas(d, f)
         else
            commas(i, f) || " " || commas(n1 % d, f) || "/" || commas(d, f)
      }         
      if n < 0 then s := "-" || s
      else if any(f, "+") then s := "+" || s
      return s
   end

   # If the numerator is 0 or 1, then return the numerator as a `Dec`;
   # otherwise return self.
   #
   public override reduce()
      return if n = 0 | d = 1 then
         Dec(n)
      else
         self
   end

   # Try to convert to an equivalent `Dec` instance.  If `rnd` is
   # omitted, then this method only succeeds if this rational number
   # can be precisely expressed as a decimal.  If so, that a `Dec` is
   # returned, otherwise this method fails.  If `rnd` is given, then
   # this method always succeeds and returns a `Dec` with the division
   # calculated with that rounding.
   #
   # :Parameters :
   # :  `rnd` - something convertible to a `Round`.
   #
   public override decimal(rnd)
      return Dec(n).div(Dec(d), rnd)
   end

   # Returns self
   public override rational()
      link
   end

   # Returns the integer whole number part of this rational.
   #
   public override integer()
      return n / d
   end

   # Returns a real number approximating this rational, or fails if
   # the result would be outside real's expressible range.
   #
   public override real()
      return decimal(REAL_DIGS).real()
   end

   # Add this rational to another.
   #
   # :Parameters :
   # :  `x` - something convertible to a `Rat`.
   #
   public override add(x)
      x := need_Rat(x)
      return Rat(n * x.d + x.n * d, d * x.d)
   end

   # Subtract another rational from this one.
   #
   # :Parameters :
   # :  `x` - something convertible to a `Rat`.
   #
   public override sub(x)
      return add(need_Rat(x).neg())
   end

   # Multiply this rational by another.
   #
   # :Parameters :
   # :  `x` - something convertible to a `Rat`.
   #
   public override mul(x)
      x := need_Rat(x)
      return Rat(n * x.n, d * x.d)
   end

   # Divide this rational by another.
   #
   # :Parameters :
   # :  `x` - something convertible to a `Rat`.
   #
   public override div(x)
      x := need_Rat(x)
      return Rat(n * x.d, d * x.n)
   end

   # Return this rational negated.
   #
   public override neg()
      return Rat(-n, d)
   end

   # Return the inverse of this rational.
   #
   public inv()
      return Rat(d, n)
   end

   # Return the sign of this rational.
   #
   public override sign()
      return ipl.numbers.sign(n)
   end

   # Return the reciprocal of this rational.
   public reciprocal()
      return Rat(d, n)
   end

   private parse(x)
      local i, j
      x ? {
         tab_ws()
         # The first integer may be either the whole number ("1 2/3")
         # or the numerator ("2/3").
         i := default.integer(tab(many(&digits ++ '+\-'))) | fail
         tab_ws()
         if any(&digits) then {
            # It was the whole number, get the numerator
            j := default.integer(tab(many(&digits)))
            tab_ws()
         }
         if ="/" then {
            tab_ws()
            d := 0 ~= default.integer(tab(many(&digits))) | fail
            if /j then
               n := i
            else {
               if i < 0 then
                  j := -j
               n := j + i * d
            }
         } else {
            # Can't have a whole number and no /, eg "1 3" is rejected.
            /j | fail
            n := i
            d := 1
         }

         # Check at end
         tab_ws()
         pos(0) | fail
      }
      return
   end

   private normalize()
      local g
      if d = 0 then
         runerr(201)
      if d < 0 then {
         d := -d
         n := -n
      }
      g := gcd(n, d)
      n /:= g
      d /:= g
   end

   # Create a new instance.  If `x` and `y` are given, then they must
   # both be integers representing the numerator and denominator
   # respectively.  Otherwise, if only `x` is given, then `x` may be :-
   #
   # * an integer, which produces a `Rat` of corresponding value,
   #   with denominator 1.
   # * another `Rat`, which gives a copy of it
   # * a `Dec` instance, which produces the corresponding exact
   #   rational value.
   # * a string, which is parsed.  If it contains a ".", or an "e" or
   #   an "E" then it represents a decimal, which is parsed and then
   #   converted to a rational equivalent.  Otherwise it is parsed as
   #   a rational number, with a "/" separating numerator and
   #   denominator. If the string cannot be parsed, the constructor
   #   fails.
   #
   # On failure, `&why` is set indicating the reason.
   #
   public new(x, y)
      local other
      if \y then {
         n := need_integer(x)
         d := need_integer(y)
      } else case typeof(x) of {
         "integer" : {
            n := x
            d := 1
         }
         Cpx: {
            other := x.real_number().rational() | return error("Couldn't convert complex to a rational")
         }
         Rat: {
            other := x
         }
         Dec: {
            other := x.rational()
         }
         default: {
            x := string(x) | runerr("Type not convertible to Rational", x)
            # The two tests are needed to stop the Rat and Dec
            # constructors calling one another endlessly.
            if probably_decimal(x) & not probably_rational(x) then
               other := Dec(x).rational() | fail
            else
               parse(x) | return error("Couldn't parse string as a rational")
         }
      }
      if /other then
         normalize()
      else {
         n := other.n
         d := other.d
      }
      return
   end
end

# A class representing arbitrary precision decimal numbers.  A decimal
# is stored as an integer `i` and an exponent `e`, so that the number
# represented is :-
# ~
#     i * 10^e
# ~
#
# All instances are immutable and are stored in a normalized form, so
# that two instances representing the same number always have the same
# integer and exponent.
#
class Dec(RealNumber, ObjectHash, ObjectEquals)
   public const
      # The integer part of the decimal
      i,
      # The exponent part of the decimal
      e

   # Cached calculation of precision
   private cp

   private static const p10, p10p2

   private static init()
      p10p2 := memoize1(calc_p10p2)
      p10 := memoize1(calc_p10)
   end

   protected override object_equals(x)
      succeed i = x.i & e = x.e
   end

   protected override object_hash()
      return iand(i, 16rffff) + 37 * default.abs(e)
   end

   # Return 10^(2^n) for integer n.
   #
   private static calc_p10p2(n)
      return 10^(2^n)
   end

   # Return 10^n for integer n.  This is rather faster than evaluating
   # 10^n, especially for larger n.
   #
   private static calc_p10(n)
      local res, j
      j := 0
      res := 1
      while n > 0 do {
         if n % 2 = 1 then
            res *:= p10p2(j)
         n /:= 2
         j +:= 1
      }
      return res
   end

   # Return the number of decimal digits in integer n (returns the same
   # value as *abs(n), but faster for large n).
   #
   private static ndig(n)
      static p
      local res, j, d, x
      # p contains a list of p10p2 values, such that p[i] = 10^(2^(i-1))
      initial 
         p := [10]
      n := default.abs(n)
      # Find the lowest j (>= 1) such that n < p[j+1] ( = 10^(2^j))
      j := 1
      repeat {
         # Get the next highest element, creating a new one if needed.
         (d := p[j + 1]) | put(p, d := p10p2(j))
         if n < d then
            break
         j +:= 1
      }
      # Now go back through the powers list reducing n and adding e to
      # the result as we go.
      #
      # Set x so that p[j] = 10^x
      x := 2^(j - 1)
      res := 0
      repeat {
         d := p[j]
         if n >= d then {
            n /:= d
            res +:= x
         }
         if j = 1 then
            break
         j -:= 1
         x /:= 2
      }
      # We now have one digit left, ie n < 10.
      return res + 1
   end

   #
   # Convert to a string.
   #
   # :Parameters :
   # :  `f` -  A cset of flags.  If c contains 'e' then the output is
   #           in scientific notation.  'E' is the same, but uses a
   #           a capital "E" in the result. If c contains ',' then commas
   #           are introduced into the non-fractional part of the number;
   #           if c contains '+' then a leading + is added to positive
   #           numbers.  If c contains 's' then trailing fractional
   #           zeroes are replaced with spaces, whilst 'z' means drop
   #           such zeroes altogether.
   # :  `dp`   The number of decimal places to produce (default all
   #           significant places).
   #
   public override str(f, dp)
      local s, i1, e1, t, zch, tp, ec
      f := need_cset(\f) | ''
      if \dp then {
         dp := need_integer(dp, 0)
         unless any(f, "z") then
            zch := if any(f, "s") then " " else "0"
      }

      if any(f, ec := "e"|"E") then {
         if \dp then {
            # One place to the left of the point and dp to the right.
            t := round(dp + 1)
            i1 := t.i; e1 := t.e
            # Now *s below will be <= dp+1
         } else {
            i1 := i; e1 := e
         }
         s := string(default.abs(i1))
         e1 +:= *s - 1
         # Unless dp is > 0, express something like "3000" as "3e+3" rather
         # than "3.0e3".
         if *s > 1 | \dp > 0 then {
            s[1] ||:= Format.DECIMAL_POINT
            if *s = 2 then s ||:= "0"
            # Since to start with *s <= dp+1, we added a ".", so *s <= dp+2,
            # so dp + 2 - *s >= 0
            s ||:= repl(\zch, dp + 2 -*s)
         }
         s ||:= ec
         if e1 >= 0 then s ||:= "+"
         s ||:= e1
      } else {
         if \dp then {
            t := round_dp(dp)
            i1 := t.i; e1 := t.e
            # Now e1 >= -dp
         } else {
            i1 := i; e1 := e
         }
         s := string(default.abs(i1))
         if e1 >= 0 then {
            # Case 1, point to right of digits, eg 12340000
            s ||:= repl("0", e1)
            tp := *s + 1
            if \dp > 0 then {
               s ||:= Format.DECIMAL_POINT || "0"
               s ||:= repl(\zch, dp - 1)
            }
         } else if -e1 < *s then {
            # Case 2, point in middle of digits, eg 1234.5678
            s[e1 - 1] ||:= Format.DECIMAL_POINT
            tp := *s + e1
            # Since e1 >= -dp (by round_dp), dp + e1 >= 0
            s ||:= repl(\zch, dp + e1)
         } else {
            # Case 3, point to left of digits, eg 0.00001234
            s := "0" || Format.DECIMAL_POINT || repl("0", -e1 - *s) || s
            s ||:= repl(\zch, dp + e1)
         }
         if \tp & any(f, ",") then
            every s[tp - 4 to 1 by -3] ||:= Format.THOUSANDS_SEPARATOR
      }
      if i < 0 then s := "-" || s
      else if any(f, "+") then s := "+" || s
      return s
   end

   # Add this decimal to another.  If `rnd` is omitted, then the
   # result is exact, otherwise it is rounded so that result is the
   # same as calling `add` and then `round` separately (combining the
   # two operations is more efficient for numbers that differ greatly).
   #
   # :Parameters :
   # :  `x` - something convertible to a `Dec`.
   # :  `rnd` - null, or something convertible to a `Round`.
   #
   public override add(x, rnd)
      x := need_Dec(x)
      return if /rnd then
         add_exact(x)
      else
         add_round(x, need_Round(rnd))
   end

   private add_exact(x)
      local i1, e1, i2, e2
      i1 := self.i
      e1 := self.e
      i2 := x.i
      e2 := x.e
      # Checks for 0 are important to avoid creating huge integers to
      # be normalized (eg Dec("1e6000").add(0) would give Dec(10^6000,
      # 0).
      return if i1 = 0 then
         x
      else if i2 = 0 then
         self
      else if e1 < e2 then
         Dec(i1 + i2 * p10(e2 - e1), e1)
      else
         Dec(i1 * p10(e1 - e2) + i2, e2)
   end

   private add_round(big, rnd)
      local small, dp, hd

      # Based on the preAlign method in BigDecimal.java

      small := self
      if big.e < small.e then
         big :=: small

      # Number of digits of precision in big to the right of the dp.
      dp := if /rnd.dp_flag then
         rnd.digits - (big.e + big.precision())
      else
         rnd.digits

      # High digit pos in small, with positions denoted as follows :-
      #        d  d  d  d . d  d  d  d
      #   ... -3 -2 -1  0   1  2  3  4 ...
      hd := 1 - (small.e + small.precision())

      # On the above position scale, -big.e is the least significant
      # digit in big, and dp is the least significant digit of
      # requested precision.

      if hd > -big.e + 2 &             # big and small disjoint
         hd > dp + 2 then              # small digits not visible
         small := Dec(small.sign(), -(max(-big.e, dp) + 3))

      return big.add_exact(small).round_impl(rnd)
   end

   # Subtract another decimal from this one.  This negates `x` and
   # calls `add()`.
   #
   # :Parameters :
   # :  `x` - something convertible to a `Dec`.
   # :  `rnd` - null, or something convertible to a `Round`.
   #
   public override sub(x, rnd)
      return add(need_Dec(x).neg(), rnd)
   end

   # Return this decimal negated.
   #
   public override neg()
      return Dec(-i, e)
   end

   # Return the sign of this decimal.
   #
   public override sign()
      return ipl.numbers.sign(i)
   end

   # Multiply this decimal by another.  The optional `rnd` is just for
   # consistency with the other binary arithmetic methods; it just has
   # the same effect as calling `round` separately on the result.
   #
   # :Parameters :
   # :  `x` - something convertible to a `Dec`.
   # :  `rnd` - null, or something convertible to a `Round`.
   #
   public override mul(x, rnd)
      local res
      x := need_Dec(x)
      res := Dec(i * x.i, e + x.e)
      if \rnd then
         res := res.round(need_Round(rnd))
      return res
   end

   # Return the precision of this number, which is the number of
   # digits in the integer part of the number.
   #
   public precision()
      /cp := ndig(i)
      return .cp
   end

   # Round to the given number of decimal places; for example 123.456
   # rounded to 1 decimal place would be 123.5
   #
   # :Parameters :
   # :  `dp` - an integer
   #
   public round_dp(dp)
      return round(need_integer(dp) || "dp")
   end

   # Truncate to the given precision.
   #
   # :Parameters :
   # :  `prec` - an integer
   #
   public trunc(prec)
      return round(need_integer(prec) || " t")
   end

   # Truncate to the given number of decimal places.
   #
   # :Parameters :
   # :  `dp` - an integer
   #
   public trunc_dp(dp)
      return round(need_integer(dp) || "dp t")
   end

   # Round this decimal
   #
   # :Parameters :
   # :  `rnd` - something convertible to a `Round`.
   #
   public round(rnd)
      return round_impl(need_Round(rnd))
   end

   private round_impl(rnd, chop)
      local n, i1, j
      # Calculate the number of digits to shift right
      n := if /rnd.dp_flag then
         precision() - rnd.digits
      else
         -e - rnd.digits
      if n <= 0 then {
         # No shift needed, ie the number has less digits than the
         # round indicates.
         if /chop then
            link
         # We chopped off some digits (in a previous division), so
         # adjustment may be necessary.  For example, dividing
         # 23267.7217 by 79727.39 (=0.2918410059579...), would give
         # m=291841,e=-6 with chop set.  We may need to adjust m and
         # e; if rounding to "6 up", n=0, we want m=291842; if "7 up"
         # then n = -1, we want m=291411.  In general we shift m left
         # by -n places and add any rounding digit.
         j := rnd.round_dig(0, i)
         # Nothing to add, so result stays the same
         if j = 0 then
            link
         i1 := i * p10(-n) + j
      } else {
         # We need to shift right n places.  Firstly shift right n-1
         # places; the last shift place is needed for rounding.
         i1 := i / p10(n - 1)
         # If we have shifted right by one or more digits then, since
         # the integer is normalized, we must have chopped off some
         # digits.  (Unless m=0, in which case chop makes no
         # difference).
         if /chop & n > 1 then
            chop := &yes
         # Now do the last shift of one place, and add any rounding.
         i1 := i1 / 10 + rnd.round_dig(i1 % 10,
                                       if /chop then 0 else i)
      }
      return Dec(i1, e + n)
   end

   # Divide this decimal by another.
   #
   # If `Round` `rnd` is given, then the result is rounded accordingly.
   # 
   # If `rnd` is omitted, and the division can be expressed exactly
   # without rounding, then the result is exact; otherwise this method
   # fails.
   # 
   # For example, `Dec(1234).div(Dec(1024))` can be expressed
   # precisely and results in `Dec(1.205078125)`, whereas
   # `Dec(1234).div(Dec(6))` cannot, and fails.  With a rounding
   # parameter of 5 however, it will succeed with `Dec(205.67)`.
   #
   # :Parameters :
   # :  `x` - something convertible to a `Dec`.
   # :  `rnd` - null, or something convertible to a `Round`.
   #
   public override div(x, rnd)
      x := need_Dec(x)
      if x.i = 0 then
         runerr(201, x)
      return if /rnd then
         div_exact(x)
      else
         div_round(x, need_Round(rnd))
   end

   # Return this number divided by `x` if it can be divided exactly,
   # or fail if it cannot.
   #
   private div_exact(x)
      local i1, i2, g, p, d
      # Firstly reduce the integer part of numerator and denominator
      # by their gcd.  This may remove a factor from the denominator
      # which would stop it being a finite decimal (eg: 12/3).
      i1 := self.i
      i2 := x.i
      g := gcd(i1, i2)
      i1 /:= g
      i2 /:= g

      # Work out if 1 / i2 is expressible as a decimal with finite
      # digits; it will be so if i2's only factors are 2 and 5.
      # Each factor adds at most 1 to the number of decimal digits
      # in the answer.  We count this with p, and then know that
      # (10^p)/i2 does not lose any digits.
      d := default.abs(i2)
      p := 0
      while d > 1 do {
         if d % 2 = 0 then
            d /:= 2
         else if d % 5 = 0 then
            d /:= 5
         else
            fail
         p +:= 1
      }
      return Dec((i1 * p10(p)) / i2, e - x.e - p)
   end

   # Return this number divided by `x`, with rounding `rnd`.
   #
   private div_round(x, rnd)
      local i1, e1, i2, e2, n, chop
      i1 := self.i
      e1 := self.e
      i2 := x.i
      e2 := x.e
      # Calculate the number of places to shift left to have
      # sufficient precision in the integer before the division.
      n := if /rnd.dp_flag then
         x.precision() - precision() + rnd.digits + 1
      else
         # The rhs here just ensures that i1>i2 in the division below.
         # This preserves the sign of i1/i2, which is needed for
         # round_impl().  If we didn't do this, then, eg, 1/20 rounded
         # to "0dp up" would give n=0, i1/i2=0, and would round to 0, not 1.
         max(e1 - e2 + rnd.digits + 1, x.precision() - precision() + 1)

      # Shift if necessary
      if n > 0 then {
         i1 *:= p10(n)
         e1 -:= n
      }
      # Note (if needed by the round mode) whether digits have been
      # chopped from the result.
      if rnd.uses_all_digits() & i1 % i2 ~= 0 then
         chop := &yes
      # Divide and round result.
      return Dec(i1 / i2, e1 - e2).round_impl(rnd, chop)
   end

   # Convert to a `Rat`.
   public override rational()
      return if e >= 0 then
         Rat(i * p10(e))
      else
         Rat(i, p10(-e))
   end

   # Convert to a real, or fail if the number is out of the allowable
   # range of that type.
   public override real()
      return default.real(round(REAL_DIGS).str('e'))
   end

   # If `rnd` is given return this instance so rounded, otherwise
   # return self.
   #
   # :Parameters :
   # :  `rnd` - null, or something convertible to a `Round`.
   #
   public override decimal(rnd)
      return if /rnd then self else round(rnd)
   end

   # Convert to an integer, truncating any fractional part.
   public override integer()
      return if e >= 0 then
         i * p10(e)
      else
         i / p10(-e)
   end

   # Returns self
   public override reduce()
      link
   end

   private parse(x)
      local l, r, s
      x ? {
         tab_ws()
         s := tab(any('+\-'))
         if ="." then {
            l := 0
            # Note we don't convert to integer, since we use *r below and need any preceding "0"s.
            r := tab(many(&digits)) | fail
         } else {
            l := tab(many(&digits)) | fail
            r := if ="." then
               # Allow a trailing "." on its own
               tab(many(&digits)) | 0
            else
               0
         }
         i := l * p10(*r) + r
         if \s == "-" then
            i := -i
         e := -*r
         if tab(any('eE')) then
            e +:= default.integer(tab(many(&digits ++ '+\-'))) | fail
         # Check at end
         tab_ws()
         pos(0) | fail
      }
      return
   end

   private normalize()
      if i = 0 then
         e := 0
      else while i % 10 = 0 do {
         i /:= 10
         e +:= 1
      }
   end

   # Create a new instance.  If `x` and `y` are given, then they must
   # both be integers representing the integer and exponent
   # respectively.  Otherwise, if only `x` is given, then `x` may be :-
   #
   # * an integer, which produces a `Dec` of corresponding value, with
   #   a zero exponent.
   # * another `Dec`, which gives a copy of it
   # * a `Rat` instance, which produces the corresponding exact
   #   decimal value if the `Rat` is so expressible, but fails if it
   #   is not.
   # * a string, which is parsed.  If it contains a "/" then it
   #   represents a rational, which must be expressible as an exact
   #   decimal, or the constructor fails.  Otherwise it is parsed as a
   #   decimal number, possibly in scientific notation.  If the string
   #   cannot be parsed, the constructor fails.
   #
   # On failure, `&why` is set indicating the reason.
   #
   # Examples :-
   # ~~~
   #   Dec("1/4")      # ok, Dec(0.25)
   #   Dec("1/3")      # fails
   #   Dec("123e100")  # ok  1.23e+102
   #   Dec(123)        # ok
   #   Dec("rubbish")  # fails
   # ~~~
   #
   public new(x, y)
      local other
      if \y then {
         i := need_integer(x)
         e := need_integer(y)
      } else case typeof(x) of {
         "integer" : {
            i := x
            e := 0
         }
         Cpx: {
            other := x.real_number().decimal() | return error("Couldn't convert complex to an exact decimal")
         }
         Dec: {
            other := x
         }
         Rat: {
            other := x.decimal() | return error("Couldn't convert rational to an exact decimal")
         }
         default: {
            x := string(x) | runerr("Type not convertible to Decimal", x)
            # The two tests are needed to stop the Rat and Dec
            # constructors calling one another endlessly.
            if probably_rational(x) & not probably_decimal(x) then {
               x := Rat(x) | fail
               other := x.decimal() | return error("Couldn't convert rational to an exact decimal")
            }
            else 
               parse(x) | return error("Couldn't parse string as a decimal")
         }
      }
      if /other then
         normalize()
      else {
         i := other.i
         e := other.e
      }
      return
   end
end

package procedure probably_decimal(s)
   return upto('.eE', s)
end

package procedure probably_rational(s)
   return upto('/', s)
end

package procedure tab_ws()
   return tab(many(' \t\n\r'))
end

# Convert an arbitrary value x into a `Rat`, `Dec` or `Cpx` instance,
# or fail if that can't be done.  Existing instances are just
# returned; integers and reals are converted to `Dec`.
#
# Other values are converted to string for parsing, and a runerr is produced
# if that conversion is not possible.
#
# The resulting string is parsed to a `Dec` if it contains a ".", "e"
# or "E", and a `Rat` otherwise.  If the parsing fails, this procedure
# fails.
#
# :Parameters :
# :  `x` - something convertible to `Dec`, `Rat` or `Cpx`
#
procedure to_Number(x)
   x := case typeof(x) of {
      Rat|Dec|Cpx: x
      "integer"|"real": Dec(x)
      default: {
         x := string(x) | runerr("Type not convertible to Number", x)
         if probably_decimal(x) then
            Dec(x)
         else
            Rat(x)
      }
   } | fail
   return x.reduce()
end

#
# Helper procedure to signal a runerr if `to_Number` fails.
#
# :Parameters :
# :  `x` - something convertible to `Dec`, `Rat` or `Cpx`
#
procedure need_Number(x)
   return to_Number(x) | runerr("Number expected: " || &why, x)
end

#
# Helper procedure to signal a runerr if `to_Number` fails, or results
# in a `Cpx`.
#
# :Parameters :
# :  `x` - something convertible to `Dec` or `Rat`
#
procedure need_RealNumber(x)
   x := need_Number(x)
   is(x, RealNumber) | runerr("Complex number not allowed", x)
   return x
end

# Helper procedure to convert x to a `Dec` (using its constructor),
# and signal a runerr if that is not possible.
#
# :Parameters :
# :  `x` - something convertible to a `Dec`.
#
procedure need_Dec(x)
   return if is(x,Dec) then x else Dec(x) | runerr("Decimal expected: " || &why, x)
end

# Helper procedure to convert x to a `Rat` (using its constructor),
# and signal a runerr if that is not possible.
#
# :Parameters :
# :  `x` - something convertible to a `Rat`.
#
procedure need_Rat(x)
   return if is(x,Rat) then x else Rat(x) | runerr("Rational expected: " || &why, x)
end

# Helper procedure to convert x to a `Cpx`, or raise a runerr.
#
# :Parameters :
# :  `x` - a `Cpx`.
#
procedure need_Cpx(x)
   return if is(x,Cpx) then x else Cpx(x, 0)
end

# Helper procedure to convert x to a `Round`, or raise a runerr.
#
# :Parameters :
# :  `x` - something convertible to a `Round`.
#
procedure need_Round(x)
   return if is(x,Round) then x else Round(x) | runerr("Round expected: " || &why, x)
end

# Structure used to return values by `align()`.
record Align(x, y)

# Take two arbitrary values and returns two equivalent values which are
# of the same class.  An `Align` record is returned.
#
# First `need` is used to convert `x` and `y` from simple types
# (integer and real) and strings into a `Dec`, `Rat` or `Cpx`.  Then,
# if the `x` and `y` aren't of the same resulting type, one of them is
# converted so their types are the same.  Any conversion made will be
# exact.
# 
# :Parameters :
# :  `x` - something convertible to `Dec`, `Rat` or `Cpx`
# :  `y` - something convertible to `Dec`, `Rat` or `Cpx`
#
procedure align(x, y)
   return align_impl(need_Number(x), need_Number(y))
end

# Like `align`, but accepts only real numbers (`Dec` or `Rat`), but not `Cpx`.
#
# :Parameters :
# :  `x` - something convertible to `Dec`, or `Rat`
# :  `y` - something convertible to `Dec`, or `Rat`
#
procedure align_real_numbers(x, y)
   return align_impl(need_RealNumber(x), need_RealNumber(y))
end

package procedure align_impl(x, y)
   if classof(x) === classof(y) then
      return Align(x, y)
   if is(x, Cpx) then
      return Align(x, Cpx(y, 0))
   if is(y, Cpx) then
      return Align(Cpx(x, 0), y)
   # Now x, y are both Rat or Dec, but different
   if is(x, Dec) then {
      # Dec, Rat; if x is not fractional prefer Rat, else prefer Dec if possible
      return if x.e >= 0 then
         Align(x.rational(), y)
      else
         Align(x, y.decimal()) | Align(x.rational(), y)
   }
   if is(y, Dec) then {
      # Rat, Dec; as above
      return if y.e >= 0 then
         Align(x, y.rational())
      else
         Align(x.decimal(), y) | Align(x, y.rational())
   }
   # Should never get here
   syserr("Unexpected arrival in align")
end

package procedure arith_finish(res, rnd)
   if \rnd & is(res, Rat) then
      res := res.decimal(rnd)
   return res.reduce()
end

# Return the sum of `x` and `y`.  The two values are first converted
# and made the same type by `align()`.
#
# :Parameters :
# :  `x` - something convertible to `Dec`, `Rat` or `Cpx`
# :  `y` - something convertible to `Dec`, `Rat` or `Cpx`
# :  `rnd` - null, or something convertible to a `Round`.
#
procedure add(x, y, rnd)
   local c
   c := align(x, y)
   return arith_finish(c.x.add(c.y, rnd), rnd)
end

# Return 'y' subtracted from `x`.  The two values are first converted
# and made the same type by `align()`.
#
# :Parameters :
# :  `x` - something convertible to `Dec`, `Rat` or `Cpx`
# :  `y` - something convertible to `Dec`, `Rat` or `Cpx`
# :  `rnd` - null, or something convertible to a `Round`.
#
procedure sub(x, y, rnd)
   local c
   c := align(x, y)
   return arith_finish(c.x.sub(c.y, rnd), rnd)
end

# Return the product of `x` and `y`.  The two values are first converted
# and made the same type by `align()`.
#
# :Parameters :
# :  `x` - something convertible to `Dec`, `Rat` or `Cpx`
# :  `y` - something convertible to `Dec`, `Rat` or `Cpx`
# :  `rnd` - null, or something convertible to a `Round`.
#
procedure mul(x, y, rnd)
   local c
   c := align(x, y)
   return arith_finish(c.x.mul(c.y, rnd), rnd)
end

# Return `x` divided by `y` with optional rounding `rnd`.  The two
# values are first converted and made the same type by `align()`.
#
# If no rounding is given, and both are `Dec`, then an exact `Dec`
# division is tried first.  If that is not possible, an exact `Rat`
# division is used instead.  For example, div(1,1024) gives a `Dec`
# but div(1,1023) gives a `Rat`.  If a rounding were given to the
# latter division, a rounded `Dec` would result.
#
# :Parameters :
# :  `x` - something convertible to `Dec`, `Rat` or `Cpx`
# :  `y` - something convertible to `Dec`, `Rat` or `Cpx`
# :  `rnd` - null, or something convertible to a `Round`.
#
procedure div(x, y, rnd)
   local c, res
   c := align(x, y)
   res := if /rnd & is(c.x, Dec) then
      c.x.div(c.y) | c.x.rational().div(c.y.rational())
   else
      c.x.div(c.y, rnd)
   return arith_finish(res, rnd)
end

#
# Compare `x` and `y` using the binary operator `f`.  The two values
# are first converted and made the same type by `align_real_numbers()`.
#
# For example :-
# ~
#      x := Dec("0.4") ; y := Rat("1/3")
#      if cmp(x, ">", y) then write("x is greater than y")
# ~
#
# :Parameters :
# :  `x` - something convertible to `Dec` or `Rat`
# :  `f` - something convertible to a comparison operator.
# :  `y` - something convertible to `Dec` or `Rat`
#
procedure cmp(x, f, y)
   local c
   c := align_real_numbers(x, y)
   succeed c.x.cmp(f, c.y)
end

# This procedure takes two `Rat` or `Dec` instances and returns -1, 0
# or 1 depending on whether `x` is less than, equal to, or greater
# than `y`, respectively.
#
# This procedure can also be used with sorting functions such as
# `ipl.sort.qsort()`.  For example :-
#
# ~
#     l := [Dec(100), Dec(2.3), Rat(1,3), Dec(99), Rat(32,7),
#           Dec(13),Rat(11,4) ]
#
#     qsort(l, number_comparator)
#
#     # Now l is [ Rat5(1/3), Dec(2.3), Rat(2 3/4), Rat(4 4/7),
#                  Dec4(13), Dec(99), Dec(100) ]
# ~
#
# :Parameters :
# :  `x` - something convertible to `Dec` or `Rat`
# :  `y` - something convertible to `Dec` or `Rat`
#
procedure number_comparator(x, y)
   local c
   c := align_real_numbers(x, y)
   return c.x.sub_sign(c.y)
end
