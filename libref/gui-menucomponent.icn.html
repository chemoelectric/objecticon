<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>menucomponent.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: menucomponent.icn 8604 2020-10-21 15:54:02Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package gui
<a name="10"/>
<a name="11"/>import util, graphics, ipl.lists
<a name="12"/>
<a name="13"/>#
<a name="14"/># This is the superclass of all the objects that make up the
<a name="15"/># menu system (other than the top level `Component`s of course).
<a name="16"/>#
<a name="17"/># It encapsulates the position and space of labels in the parent
<a name="18"/># menu, as well as methods which allow this item to be a popup
<a name="19"/># submenu. A submenu need not necessarily contain other
<a name="20"/># `MenuComponent`s; see for example the `Palette` class.  A
<a name="21"/># conventional submenu, which does contain children, is in the
<a name="22"/># `Menu` class.
<a name="23"/>#
<a name="24"/>abstract class MenuComponent(Rect,Connectable)
<a name="25"/>   public 
<a name="26"/>      label_x,                                
<a name="27"/>      label_y,                                
<a name="28"/>      label_w,  
<a name="29"/>      label_h,                                
<a name="30"/>      is_sub_menu_flag,                                
<a name="31"/>      is_decorative_flag,                                
<a name="32"/>      keep_open_on_shift_flag,
<a name="33"/>      component_link,
<a name="34"/>      parent_component,                               
<a name="35"/>      is_shaded_flag,                                
<a name="36"/>      parent,                  
<a name="37"/>      tooltip,         
<a name="38"/>      accel,
<a name="39"/>      children,
<a name="40"/>      border,
<a name="41"/>      temp_win,
<a name="42"/>      accel_skip
<a name="43"/>
<a name="44"/>   public initially()
<a name="45"/>      self.parent_component := (\parent).parent_component | component_link
<a name="46"/>      (\self.border).initially(self.parent_component)
<a name="47"/>      every (!self.children).initially()
<a name="48"/>   end
<a name="49"/>
<a name="50"/>   public finally()
<a name="51"/>      (\self.border).finally()
<a name="52"/>      every (!self.children).finally()
<a name="53"/>      self.parent_component := &amp;null
<a name="54"/>   end
<a name="55"/>
<a name="56"/>   #
<a name="57"/>   # Add the given `MenuComponent` to the Menu.
<a name="58"/>   #
<a name="59"/>   # :Parameters :
<a name="60"/>   # :  `c` - The `MenuComponent` to add.
<a name="61"/>   # :  `i` - The index to add at; if omitted then the new component
<a name="62"/>   #            is appended to the end.
<a name="63"/>   # :Fails :
<a name="64"/>   # :  If i is out of range
<a name="65"/>   #
<a name="66"/>   public add(c, i)
<a name="67"/>      /i := 0
<a name="68"/>      insert(self.children, i, c) | fail
<a name="69"/>      c.set_parent(self)
<a name="70"/>      if is_initialized() then
<a name="71"/>         c.initially()
<a name="72"/>      link
<a name="73"/>   end
<a name="74"/>
<a name="75"/>   #
<a name="76"/>   # Get the index of the given child component
<a name="77"/>   #
<a name="78"/>   public get_index(c)
<a name="79"/>      return keyof(self.children, c)
<a name="80"/>   end
<a name="81"/>
<a name="82"/>   #
<a name="83"/>   # Remove the `MenuComponent` from the menu.
<a name="84"/>   # :Parameters :
<a name="85"/>   # :  `c` - The `MenuComponent` to remove.
<a name="86"/>   # :Fails :
<a name="87"/>   # :  If c is not a child of this instance.
<a name="88"/>   #
<a name="89"/>   public remove(c)
<a name="90"/>      return remove_index(get_index(c))
<a name="91"/>   end
<a name="92"/>
<a name="93"/>   #
<a name="94"/>   # Remove the `MenuComponent` at the given index from the list of children.
<a name="95"/>   # :Parameters :
<a name="96"/>   # :  `i` - The index
<a name="97"/>   # :Fails :
<a name="98"/>   # :  If i is out of range
<a name="99"/>   #
<a name="100"/>   public remove_index(i)
<a name="101"/>      local c
<a name="102"/>      c := self.children[i] | fail
<a name="103"/>      delete(self.children, i)
<a name="104"/>      c.set_parent(&amp;null)
<a name="105"/>      if is_initialized() then
<a name="106"/>         c.finally()
<a name="107"/>      link
<a name="108"/>   end
<a name="109"/>
<a name="110"/>   #
<a name="111"/>   # Remove all the children.
<a name="112"/>   #
<a name="113"/>   public remove_all()
<a name="114"/>      link remove_list()
<a name="115"/>   end
<a name="116"/>
<a name="117"/>   #
<a name="118"/>   # Move the `MenuComponent` to the given index position.
<a name="119"/>   # :Parameters :
<a name="120"/>   # :  `c` - The `MenuComponent` to move.
<a name="121"/>   # :  `j` - The new position.
<a name="122"/>   # :Fails :
<a name="123"/>   # :  If c is not a child of this instance, 
<a name="124"/>   #             or j is out of range.
<a name="125"/>   #
<a name="126"/>   public reposition(c, j)
<a name="127"/>      return reposition_index(get_index(c), j)
<a name="128"/>   end
<a name="129"/>
<a name="130"/>   #
<a name="131"/>   # Move the `MenuComponent` at position `i` to `j`.
<a name="132"/>   # :Parameters :
<a name="133"/>   # :  `i` - The old position.
<a name="134"/>   # :  `j` - The new position.
<a name="135"/>   # :Fails :
<a name="136"/>   # :  If either index is out of range.
<a name="137"/>   #
<a name="138"/>   public reposition_index(i, j)
<a name="139"/>      link lmove(children, i, j)
<a name="140"/>   end
<a name="141"/>
<a name="142"/>   # Remove the children in the range `i:j`, returning the
<a name="143"/>   # removed children in a list.
<a name="144"/>   # :Parameters :
<a name="145"/>   # :  `i` - The start slice index, default 1
<a name="146"/>   # :  `j` - The end slice index, default 0
<a name="147"/>   # :Fails :
<a name="148"/>   # :  If the range is invalid.
<a name="149"/>   #
<a name="150"/>   #
<a name="151"/>   public remove_list(i, j)
<a name="152"/>      local l
<a name="153"/>      l := lextract(children, i, j) | fail
<a name="154"/>      every (!l).set_parent(&amp;null)
<a name="155"/>      if is_initialized() then
<a name="156"/>         every (!l).finally()
<a name="157"/>      return l
<a name="158"/>   end
<a name="159"/>
<a name="160"/>   # Add all the `MenuComponent`s contained in list `l` at index `i`.
<a name="161"/>   #
<a name="162"/>   # :Parameters :
<a name="163"/>   # :  `l` - The list to add
<a name="164"/>   # :  `i` - The index
<a name="165"/>   # :Fails :
<a name="166"/>   # :  If i is out of range
<a name="167"/>   #
<a name="168"/>   public add_list(l, i)
<a name="169"/>      linsert(children, l, i) | fail
<a name="170"/>      every (!l).set_parent(self)
<a name="171"/>      if is_initialized() then
<a name="172"/>         every (!l).initially()
<a name="173"/>      link
<a name="174"/>   end
<a name="175"/>
<a name="176"/>   # Move all the children of `MenuComponent` `other`, to this
<a name="177"/>   # `MenuComponent`, adding them at index `i`.  `other` will be left empty.
<a name="178"/>   #
<a name="179"/>   # :Parameters :
<a name="180"/>   # :  `other` - The source `MenuComponent`.
<a name="181"/>   # :  `i` - The index to add at; if omitted then the new components
<a name="182"/>   #              are appended to the end.
<a name="183"/>   # :Fails :
<a name="184"/>   # :  If i is out of range
<a name="185"/>   #
<a name="186"/>   public move_all(other, i)
<a name="187"/>      return add_list(other.remove_list(), i)
<a name="188"/>   end
<a name="189"/>
<a name="190"/>   #
<a name="191"/>   # Traverse all the components, including subcomponents, with a
<a name="192"/>   # post-order traversal.
<a name="193"/>   #
<a name="194"/>   public traverse_postorder()
<a name="195"/>      every (!self.children).traverse_postorder()
<a name="196"/>      coact(self)
<a name="197"/>   end
<a name="198"/>
<a name="199"/>   #
<a name="200"/>   # Traverse all the components, including subcomponents, with a
<a name="201"/>   # pre-order traversal.
<a name="202"/>   #
<a name="203"/>   public traverse_preorder()
<a name="204"/>      coact(self)
<a name="205"/>      every (!self.children).traverse_preorder()
<a name="206"/>   end
<a name="207"/>
<a name="208"/>   #
<a name="209"/>   # Succeed iff the component has been initialized with `init()`, but
<a name="210"/>   # not yet cleaned up with `finally()`.
<a name="211"/>   #
<a name="212"/>   public is_initialized()
<a name="213"/>      succeed \self.parent_component
<a name="214"/>   end
<a name="215"/>
<a name="216"/>   public set_parent(x)
<a name="217"/>      self.parent := x
<a name="218"/>      link
<a name="219"/>   end
<a name="220"/>
<a name="221"/>   #
<a name="222"/>   # Get the parent `MenuComponent`, or fail if there is none.
<a name="223"/>   #
<a name="224"/>   public get_parent()
<a name="225"/>      return \self.parent
<a name="226"/>   end
<a name="227"/>
<a name="228"/>   #
<a name="229"/>   # Succeed iff the component is shaded
<a name="230"/>   #
<a name="231"/>   public is_shaded()
<a name="232"/>      succeed \self.is_shaded_flag
<a name="233"/>   end
<a name="234"/>
<a name="235"/>   #
<a name="236"/>   # Succeed if the component is not shaded.
<a name="237"/>   #
<a name="238"/>   public is_unshaded()
<a name="239"/>      succeed /self.is_shaded_flag
<a name="240"/>   end
<a name="241"/>
<a name="242"/>   #
<a name="243"/>   # Toggle whether or not the item is shaded.  If it is, it is
<a name="244"/>   # displayed in a filtered way and will not accept input.
<a name="245"/>   #
<a name="246"/>   public toggle_is_shaded()
<a name="247"/>      return set_is_shaded(toggle_flag(is_shaded_flag))
<a name="248"/>   end
<a name="249"/>
<a name="250"/>   #
<a name="251"/>   # Set the shaded status of the component.
<a name="252"/>   #
<a name="253"/>   public set_is_shaded(s)
<a name="254"/>      if is_shaded_flag ~===:= need_flag(s) then
<a name="255"/>         possibly_invalidate()
<a name="256"/>      link
<a name="257"/>   end
<a name="258"/>
<a name="259"/>   #
<a name="260"/>   # Invalidate the parent `Component` if this is the root of the menu hierarchy, or
<a name="261"/>   # the parent menu if it is open.
<a name="262"/>   #
<a name="263"/>   public possibly_invalidate()
<a name="264"/>      if /self.parent then
<a name="265"/>         (\self.parent_component).invalidate()
<a name="266"/>      else
<a name="267"/>         (\parent.temp_win).invalidate(get_label_rect())
<a name="268"/>      link
<a name="269"/>   end
<a name="270"/>
<a name="271"/>   #
<a name="272"/>   # The label's area as a `Rect`
<a name="273"/>   #
<a name="274"/>   public get_label_rect()
<a name="275"/>      return Rect(label_x, label_y, label_w, label_h)
<a name="276"/>   end
<a name="277"/>
<a name="278"/>   #
<a name="279"/>   # Return the parent `Component`, for example a `MenuBar`.
<a name="280"/>   #
<a name="281"/>   public get_parent_component()
<a name="282"/>      return \self.parent_component
<a name="283"/>   end
<a name="284"/>
<a name="285"/>   public set_parent_component(x)
<a name="286"/>      self.parent_component := x
<a name="287"/>      link
<a name="288"/>   end
<a name="289"/>
<a name="290"/>   #
<a name="291"/>   # Set the link to the parent component for the root of a tree of
<a name="292"/>   # `MenuComponent`s.  The tree's `parent_component` links will then
<a name="293"/>   # be set in the `initially` method.
<a name="294"/>   #
<a name="295"/>   public set_component_link(x)
<a name="296"/>      self.component_link := x
<a name="297"/>      link
<a name="298"/>   end
<a name="299"/>
<a name="300"/>   public is_sub_menu()
<a name="301"/>      succeed \self.is_sub_menu_flag
<a name="302"/>   end
<a name="303"/>
<a name="304"/>   public set_is_decorative(s)
<a name="305"/>      self.is_decorative_flag := need_flag(s)
<a name="306"/>      link
<a name="307"/>   end
<a name="308"/>
<a name="309"/>   public is_decorative()
<a name="310"/>      succeed \self.is_decorative_flag
<a name="311"/>   end
<a name="312"/>
<a name="313"/>   public in_label_region(e)
<a name="314"/>      succeed (self.label_y &lt;= e.y &lt; self.label_y + self.label_h) &amp; 
<a name="315"/>         (self.label_x &lt;= e.x &lt; self.label_x + self.label_w)
<a name="316"/>   end
<a name="317"/>
<a name="318"/>   #
<a name="319"/>   # Set the tooltip.
<a name="320"/>   #
<a name="321"/>   public set_tooltip(x)
<a name="322"/>      self.tooltip := x
<a name="323"/>      link
<a name="324"/>   end
<a name="325"/>
<a name="326"/>   #
<a name="327"/>   # Return the tooltip, if any.
<a name="328"/>   #
<a name="329"/>   public get_tooltip()
<a name="330"/>      return \self.tooltip
<a name="331"/>   end
<a name="332"/>
<a name="333"/>   #
<a name="334"/>   # Set the mnemonic key, which will be used with the Alt key to provide keyboard
<a name="335"/>   # shortcuts.
<a name="336"/>   #
<a name="337"/>   public set_accel(k)
<a name="338"/>      self.accel := need_text(k)
<a name="339"/>      link
<a name="340"/>   end
<a name="341"/>
<a name="342"/>   #
<a name="343"/>   # Get the mnemonic key, if present, or fail otherwise.
<a name="344"/>   #
<a name="345"/>   public get_accel()
<a name="346"/>      return \self.accel
<a name="347"/>   end
<a name="348"/>
<a name="349"/>   #
<a name="350"/>   # Invoked by the menu system to set the component's label position.
<a name="351"/>   #
<a name="352"/>   public set_label_pos(x, y)
<a name="353"/>      self.label_x := x
<a name="354"/>      self.label_y := y
<a name="355"/>      link
<a name="356"/>   end
<a name="357"/>
<a name="358"/>   #
<a name="359"/>   # Close the menu system.
<a name="360"/>   #
<a name="361"/>   public close_all()
<a name="362"/>      parent_component.close_all()
<a name="363"/>   end
<a name="364"/>
<a name="365"/>   #
<a name="366"/>   # If this flag is set, then the menu system is not closed when this
<a name="367"/>   # item is selected via mouse or return key, if the shift key is
<a name="368"/>   # down.
<a name="369"/>   #
<a name="370"/>   public set_keep_open_on_shift(s)
<a name="371"/>      self.keep_open_on_shift_flag := need_flag(s)
<a name="372"/>      link
<a name="373"/>   end
<a name="374"/>
<a name="375"/>   #
<a name="376"/>   # Called when the menu component is selected
<a name="377"/>   #
<a name="378"/>   public selected(ev)
<a name="379"/>      if /keep_open_on_shift_flag | /ev | 
<a name="380"/>         /ev.shift | not(member(Mouse.RELEASE, ev.code) | ev.code === ("\r" | "\l")) then
<a name="381"/>         parent_component.close_all(self)
<a name="382"/>      fire(Event.ACTION, ev)
<a name="383"/>      link
<a name="384"/>   end
<a name="385"/>
<a name="386"/>   #
<a name="387"/>   # Called on each child after the proxy window has been created.
<a name="388"/>   #
<a name="389"/>   public prepare_parent_proxy()
<a name="390"/>   end
<a name="391"/>
<a name="392"/>   #
<a name="393"/>   # Abstract methods for the label sizes.
<a name="394"/>   #
<a name="395"/>   public abstract get_label_left_width()
<a name="396"/>   public abstract get_label_left_height()
<a name="397"/>   public abstract get_label_mid_width()
<a name="398"/>   public abstract get_label_mid_height()
<a name="399"/>   public abstract get_label_right_width()
<a name="400"/>   public abstract get_label_right_height()
<a name="401"/>
<a name="402"/>   #
<a name="403"/>   # Abstract method for the display of the labels.
<a name="404"/>   #
<a name="405"/>   public abstract draw_label(W, lw, mw, rw)
<a name="406"/>
<a name="407"/>   #
<a name="408"/>   # The following methods are only called for a MenuComponent which pops up
<a name="409"/>   # a sub-menu, ie is_sub_menu_flag is non-null.
<a name="410"/>   #
<a name="411"/>
<a name="412"/>   #
<a name="413"/>   # Deduce which child label is under pointer, if any, given we're in the region.
<a name="414"/>   #
<a name="415"/>   public which_item(e)
<a name="416"/>      local m
<a name="417"/>      every m := !self.children do {
<a name="418"/>         if /m.is_shaded_flag &amp; /m.is_decorative_flag &amp; m.in_label_region(e) then
<a name="419"/>            return m
<a name="420"/>      }
<a name="421"/>   end
<a name="422"/>
<a name="423"/>   #
<a name="424"/>   # Invoked after the x,y co-ordinates are set, this method should be implemented
<a name="425"/>   # so that the submenu may initialize its size.  The method should leave the
<a name="426"/>   # instance variables w and h initialized.
<a name="427"/>   #
<a name="428"/>   public optional resize()
<a name="429"/>
<a name="430"/>   #
<a name="431"/>   # Invoked by the parent menu when the right cursor key is pressed.
<a name="432"/>   #
<a name="433"/>   public cursor_on()
<a name="434"/>   end
<a name="435"/>
<a name="436"/>   #
<a name="437"/>   # Display the submenu
<a name="438"/>   #
<a name="439"/>   public optional display(w)
<a name="440"/>
<a name="441"/>   #
<a name="442"/>   # Handle the given key event.
<a name="443"/>   #
<a name="444"/>   public optional handle_key(e)
<a name="445"/>
<a name="446"/>   #
<a name="447"/>   # Is the cursor over us?
<a name="448"/>   # 
<a name="449"/>   public in_region(e)
<a name="450"/>      succeed temp_win.in_region(e)
<a name="451"/>   end
<a name="452"/>
<a name="453"/>   #
<a name="454"/>   # Set the border to use - this relates to the popup submenu, 
<a name="455"/>   # not the label.
<a name="456"/>   #
<a name="457"/>   public set_border(b)
<a name="458"/>      if is_initialized() then {
<a name="459"/>         (\self.border).finally()
<a name="460"/>         self.border := b
<a name="461"/>         self.border.initially(self.parent_component)
<a name="462"/>      } else
<a name="463"/>         self.border := b
<a name="464"/>      link
<a name="465"/>   end
<a name="466"/>
<a name="467"/>   protected create_proxy()
<a name="468"/>      return SubMenuProxyComponent(self)
<a name="469"/>   end
<a name="470"/>
<a name="471"/>   #
<a name="472"/>   # Display the submenu. The preferred position is x, y.  If that is
<a name="473"/>   # not possible, then xa, ya give another position to try, but this
<a name="474"/>   # time the values are right-adjusted.  These params default to the
<a name="475"/>   # right and bottom of the screen respectively.
<a name="476"/>   #
<a name="477"/>   public show(x, y, xa, ya)
<a name="478"/>      local d, win, x1, y1, pd, dim, rs
<a name="479"/>      /self.temp_win | fail
<a name="480"/>
<a name="481"/>      pd := self.parent_component.parent_dialog
<a name="482"/>      win := pd.win
<a name="483"/>
<a name="484"/>      dim := win.get_display_size()
<a name="485"/>      # Screen rectangle, in adjusted co-ordinates
<a name="486"/>      rs := Rect(-win.get_x() - win.get_dx(), -win.get_y() - win.get_dy(), dim.width, dim.height)
<a name="487"/>      self.x := x
<a name="488"/>      self.y := y
<a name="489"/>      self.resize()
<a name="490"/>
<a name="491"/>      /xa := rs.x + rs.w
<a name="492"/>      /ya := rs.y + rs.h
<a name="493"/>      if self.x &lt; rs.x then
<a name="494"/>         x1 := rs.x
<a name="495"/>      else if self.x + self.w &gt; rs.x + rs.w then
<a name="496"/>         x1 := max(rs.x, xa - self.w)
<a name="497"/>      if self.y &lt; rs.y then
<a name="498"/>         y1 := rs.y
<a name="499"/>      else if self.y + self.h &gt; rs.y + rs.h then
<a name="500"/>         y1 := max(rs.y, ya - self.h)
<a name="501"/>      if \x1 | \y1 then {
<a name="502"/>         /x1 := self.x
<a name="503"/>         /y1 := self.y
<a name="504"/>         self.x := x1
<a name="505"/>         self.y := y1
<a name="506"/>         self.resize()
<a name="507"/>      }
<a name="508"/>
<a name="509"/>      temp_win := create_proxy().
<a name="510"/>         set_size(self.w, self.h).
<a name="511"/>         # Copy attribs of the parent component
<a name="512"/>         set_wattrib_ancestor(parent_component)
<a name="513"/>      every (!children).prepare_parent_proxy()
<a name="514"/>
<a name="515"/>      pd.enter_menu_mode(temp_win)
<a name="516"/>
<a name="517"/>      # Note the test that we must use a popup for the menu if
<a name="518"/>      # the parent's menu is a popup; otherwise it may appear below
<a name="519"/>      # one of the parent popups.
<a name="520"/>      if Gui.allow_internal_popups() &amp; 
<a name="521"/>         pd.contains(self) &amp;
<a name="522"/>         not (\parent).temp_win.parent_dialog.is_popup() then
<a name="523"/>      {
<a name="524"/>         temp_win.
<a name="525"/>            set_pos(self.x + win.get_dx(), 
<a name="526"/>                    self.y + win.get_dy()).
<a name="527"/>            set_z(pd.get_top_z())
<a name="528"/>         pd.add(self.temp_win)
<a name="529"/>         self.temp_win.resize().invalidate()
<a name="530"/>      } else {
<a name="531"/>         temp_win.set_pos(0, 0)
<a name="532"/>         d := PureDialog().
<a name="533"/>            set_canvas(Canvas.POPUP).
<a name="534"/>            set_width(self.w).
<a name="535"/>            set_height(self.h).
<a name="536"/>            copy_wattrib(WAttrib.DISPLAY, parent_component.parent_dialog).
<a name="537"/>            add(self.temp_win).
<a name="538"/>            set_dx(-self.x).
<a name="539"/>            set_dy(-self.y).
<a name="540"/>            set_x(win.get_x() + win.get_dx() + self.x).
<a name="541"/>            set_y(win.get_y() + win.get_dy() + self.y)
<a name="542"/>         pd.add_popup(d)
<a name="543"/>         d.show()
<a name="544"/>      }
<a name="545"/>   end
<a name="546"/>
<a name="547"/>   #
<a name="548"/>   # Hide the submenu.
<a name="549"/>   #
<a name="550"/>   public hide()
<a name="551"/>      \self.temp_win | fail
<a name="552"/>      if temp_win.parent_dialog === parent_component.parent_dialog then {
<a name="553"/>         self.temp_win.invalidate()
<a name="554"/>         self.parent_component.parent_dialog.remove(self.temp_win)
<a name="555"/>      } else {
<a name="556"/>         parent_component.parent_dialog.remove_popup(self.temp_win.parent_dialog)
<a name="557"/>         self.temp_win.parent_dialog.dispose()
<a name="558"/>      }
<a name="559"/>      parent_component.parent_dialog.exit_menu_mode(temp_win)
<a name="560"/>      self.temp_win := &amp;null
<a name="561"/>   end
<a name="562"/>
<a name="563"/>   public override new()
<a name="564"/>      Connectable.new()
<a name="565"/>      self.children := []
<a name="566"/>      return
<a name="567"/>   end
<a name="568"/>end
<a name="569"/>
<a name="570"/>
<a name="571"/>class SubMenuProxyComponent(Component, MenuMode)
<a name="572"/>   public menu
<a name="573"/>
<a name="574"/>   public override display()
<a name="575"/>      menu.display(self.cbwin)
<a name="576"/>      display_children()
<a name="577"/>   end
<a name="578"/>
<a name="579"/>   public override get_tooltip(e)
<a name="580"/>      local m
<a name="581"/>      every m := !menu.children do {
<a name="582"/>         if m.in_label_region(e) then
<a name="583"/>            return m.get_tooltip(e)
<a name="584"/>      }
<a name="585"/>   end
<a name="586"/>
<a name="587"/>   public override should_close(e)
<a name="588"/>      succeed member(Mouse.PRESS, e.code) &amp; not(in_region(e))
<a name="589"/>   end
<a name="590"/>
<a name="591"/>   public override close_all()
<a name="592"/>      menu.hide()
<a name="593"/>   end
<a name="594"/>
<a name="595"/>   public override gen_popup_components()
<a name="596"/>      link
<a name="597"/>   end
<a name="598"/>
<a name="599"/>   public override get_nesting_component()
<a name="600"/>      link
<a name="601"/>   end
<a name="602"/>
<a name="603"/>   public override allow_nested(c) 
<a name="604"/>      local t
<a name="605"/>      if is(c, SubMenuProxyComponent) then
<a name="606"/>         succeed c.menu.parent === menu
<a name="607"/>      c := c.get_nesting_component()
<a name="608"/>      every t := c.gen_parents() do {
<a name="609"/>         if is(t, SubMenuProxyComponent) then
<a name="610"/>            succeed t === self
<a name="611"/>      }
<a name="612"/>   end
<a name="613"/>
<a name="614"/>   public override new(m)
<a name="615"/>      Component.new()
<a name="616"/>      self.menu := m
<a name="617"/>      return
<a name="618"/>   end
<a name="619"/>end
<a name="620"/>
<a name="621"/>abstract class MenuSystem(MenuMode)
<a name="622"/>   public abstract go_right()
<a name="623"/>   public abstract go_left()
<a name="624"/>   public abstract make_partial()
<a name="625"/>end
</pre></body></html>
