#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

import graphics,io,lang

#
# This is similar to {MenuBar}, but holds just a single
# drop-down menu, rather than several.  It may be placed anywhere on
# the dialog, whereas a {MenuBar} would invariably be placed along the top.
#
class MenuButton(Component, BorderWhilstEntered, MenuMode)
   public 
      menu, 
      which_open,
      accel_skip

   #
   # Set the menu to be displayed when the component is clicked.
   # @param c   The {Menu}.
   #
   public set_menu(c)
      if is_initialized() then {
         (\self.menu).finally()
         self.menu := c
         c.set_component_link(self)         
         self.menu.initially()
      } else {
         self.menu := c
         c.set_component_link(self)         
      }
      return self
   end

   public initially()
      \self.menu | runerr("no menu set")
      cast(self,Component).initially()
      self.menu.initially()
   end

   public finally()
      if \self.which_open then
         self.close_menu()
      self.menu.finally()
      cast(self,Component).finally()
   end

   public display()
      menu.draw_label(self.cbwin, 0, menu.label_w, 0)
      if menu.is_shaded() then
         Gui.style.shade_rectangle(self.cbwin,
                                    self.x, self.y, self.w, self.h)
      if /border_whilst_entered_flag | (is_unshaded() & \entered) then
         border.draw_rect(self.cbwin, self)
   end

   public open_menu()
      self.parent_dialog.enter_menu_mode(self)
      self.which_open := self.menu
      self.menu.show(self.x,
                     self.y + self.h,, self.y)
   end

   public close_menu()
      self.menu.hide()
      self.which_open := &null
      self.parent_dialog.exit_menu_mode(self)
   end

   public close_all()
      close_menu()
   end

   public make_partial()
      close_menu()
   end

   public go_right()
   end

   public go_left()
   end

   public handle_press(e)
      if /self.which_open then {
         if menu.is_unshaded() then
            self.open_menu()
      } else
         self.close_menu()
   end

   public handle_accel(e)
      if /self.which_open then
         self.open_menu()
      self.menu.cursor_on()
      # See comment in MenuBar.handle_accel
      accel_skip := e
   end

   public match_accel(e)
      return self.menu.accel === e & menu.is_unshaded()
   end

   public should_close(e)
      if member(Mouse.PRESS, e.code) &
         not(in_region(e) | (\which_open).which_region(e)) then
         return
   end

   public allow_nested(c)
      local t
      every t := c.gen_parents() do {
         if is(t, SubMenuProxyComponent) then
            return t.menu.parent_component === self
      }
   end

   public get_tooltip(e)
      return \self.tooltip | 
         (menu.in_label_region(e) & menu.get_tooltip(e))
   end

   public handle_key(e)
      write("mb key event:",to_string(e))
      if e === accel_skip then {
         accel_skip := &null
         return
      }
      if \self.which_open then {
         self.which_open.handle_key(e)
         return
      }
   end

   public get_default_width()
      return self.menu.get_label_mid_width() + border.get_total_width()
   end

   public get_default_height()
      return self.menu.get_label_mid_height() + border.get_total_height()
   end

   public layout()
      self.menu.label_x := self.x + border.get_l_inset()
      self.menu.label_y := self.y + border.get_t_inset()
      self.menu.label_w := self.w - border.get_total_width()
      self.menu.label_h := self.h - border.get_total_height()
   end

   public shift(dx, dy)
      cast(self,Component).shift(dx, dy)
      self.menu.label_x +:= dx
      self.menu.label_y +:= dy
   end

   public new()
      cast(self,Component).new()
      cast(self,BorderWhilstEntered).new()
      self.set_border(RaisedBorder())
      every connect(handle_press, Event.MOUSE_LEFT_PRESS | Event.MOUSE_MIDDLE_PRESS | Event.MOUSE_RIGHT_PRESS)
      connect(handle_key, Event.KEY_PRESS)
      return
   end
end
