<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>sem.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: sem.icn 8645 2020-11-05 22:37:50Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package ipc
<a name="10"/>
<a name="11"/>import lang, util
<a name="12"/>
<a name="13"/>#
<a name="14"/># This class provides a semaphore facility.  The implementation
<a name="15"/># requires the accompanying native library to be on the library path.
<a name="16"/>#
<a name="17"/># Instances of this class should not be created directly, but rather
<a name="18"/># using the static methods `open_public`, `create_public` and
<a name="19"/># `create_private`
<a name="20"/>#
<a name="21"/>final class Sem(NoCopy, HasClose)
<a name="22"/>   private 
<a name="23"/>      id
<a name="24"/>   private readable
<a name="25"/>      undo_flag
<a name="26"/>
<a name="27"/>   #
<a name="28"/>   # If this flag is set then `semop()` and `semop_nowait()` will use
<a name="29"/>   # the `SEM_UNDO` flag.  By default this flag is off.  Note that this
<a name="30"/>   # flag is an attribute of this instance, rather than the underlying
<a name="31"/>   # semaphore.
<a name="32"/>   #
<a name="33"/>   public set_undo(s)
<a name="34"/>      self.undo_flag := need_flag(s)
<a name="35"/>      link
<a name="36"/>   end
<a name="37"/>
<a name="38"/>   #
<a name="39"/>   # Set the value of the semaphore to `x`.
<a name="40"/>   #
<a name="41"/>   public native set_value(x)
<a name="42"/>
<a name="43"/>   #
<a name="44"/>   # Get the current semaphore value.
<a name="45"/>   #
<a name="46"/>   public native get_value()
<a name="47"/>
<a name="48"/>   #
<a name="49"/>   # Perform the wait operation, defined as `semop(-1)`.
<a name="50"/>   #
<a name="51"/>   public wait()
<a name="52"/>      return semop(-1)
<a name="53"/>   end
<a name="54"/>
<a name="55"/>   #
<a name="56"/>   # Attempt a wait, defined as `semop_nowait(-1)`.
<a name="57"/>   #
<a name="58"/>   public attempt()
<a name="59"/>      return semop_nowait(-1)
<a name="60"/>   end
<a name="61"/>
<a name="62"/>   #
<a name="63"/>   # Perform the signal operation, defined as `semop(1)`.
<a name="64"/>   #
<a name="65"/>   public signal()
<a name="66"/>      return semop(1)
<a name="67"/>   end
<a name="68"/>
<a name="69"/>   #
<a name="70"/>   # Perform a semop on the underlying sempahore.  If n is &gt;0 then n
<a name="71"/>   # is added to the value.  If it is &lt;0 then the process is suspended
<a name="72"/>   # until the value is &gt;= `abs(n)`, then `abs(n)` is subtracted.  If
<a name="73"/>   # n is zero, then the process suspends until the semaphore value is
<a name="74"/>   # zero.  This call always succeeds with `self`.
<a name="75"/>   #
<a name="76"/>   public semop(n)
<a name="77"/>      return semop_impl(n, undo_flag)
<a name="78"/>   end
<a name="79"/>
<a name="80"/>   # 
<a name="81"/>   # Peform a semop with the `IPC_NOWAIT` flag set.  This is like
<a name="82"/>   # `semop()`, but instead of suspending the process, the call will
<a name="83"/>   # fail, otherwise it succeeds with `&amp;null`.
<a name="84"/>   #
<a name="85"/>   public semop_nowait(n)
<a name="86"/>      return semop_nowait_impl(n, undo_flag)
<a name="87"/>   end
<a name="88"/>
<a name="89"/>   # 
<a name="90"/>   # Repeatedly peform `semop_nowait()`, sleeping for a short period
<a name="91"/>   # between each try until t milliseconds or `semop_nowait()`
<a name="92"/>   # succeeds.  Fails on a timeout; otherwise succeeds with `&amp;null`.
<a name="93"/>   #
<a name="94"/>   # :Parameters :
<a name="95"/>   # :  `n` - the parameter to semop_nowait
<a name="96"/>   # :  `t` - the timeout in milliseconds
<a name="97"/>   #
<a name="98"/>   public semop_poll(n, t)
<a name="99"/>      local i
<a name="100"/>      t := Prog.get_runtime_millis() + need_integer(t, 0)
<a name="101"/>      repeat {
<a name="102"/>         if semop_nowait(n) then
<a name="103"/>            return
<a name="104"/>         i := t - Prog.get_runtime_millis()
<a name="105"/>         if i &lt;= 0 then
<a name="106"/>            fail
<a name="107"/>         i &gt;:= 50
<a name="108"/>         delay(i)
<a name="109"/>      }
<a name="110"/>   end
<a name="111"/>
<a name="112"/>   #
<a name="113"/>   # Clean up the resources used by the semaphore.  This should be called by
<a name="114"/>   # the parent process after the semaphore is no longer needed.
<a name="115"/>   #
<a name="116"/>   public override native close()
<a name="117"/>
<a name="118"/>   #
<a name="119"/>   # Return the underlying id of the semaphore, failing if it is closed.
<a name="120"/>   #
<a name="121"/>   public get_id()
<a name="122"/>      return .\id
<a name="123"/>   end
<a name="124"/>
<a name="125"/>   private native semop_impl(n, f)
<a name="126"/>   private native semop_nowait_impl(n, f)
<a name="127"/>   private static native open_public_impl()
<a name="128"/>   private static native create_public_impl()
<a name="129"/>   private static native create_private_impl()
<a name="130"/>
<a name="131"/>   private static init() 
<a name="132"/>      Class.load_library(\Ipc.LOADED)
<a name="133"/>   end
<a name="134"/>
<a name="135"/>   private new(id)
<a name="136"/>      self.id := id
<a name="137"/>      return
<a name="138"/>   end
<a name="139"/>
<a name="140"/>   #
<a name="141"/>   # Get an existing public semaphore with the given key, or fail
<a name="142"/>   # if no such semaphore exists.
<a name="143"/>   #
<a name="144"/>   public static open_public(key)
<a name="145"/>      ipc_available() | fail
<a name="146"/>      return Sem(open_public_impl(key))
<a name="147"/>   end
<a name="148"/>
<a name="149"/>   #
<a name="150"/>   # Create a new public semaphore with the given key and initial value
<a name="151"/>   #
<a name="152"/>   public static create_public(key, val)
<a name="153"/>      ipc_available() | fail
<a name="154"/>      /val := 1
<a name="155"/>      return Sem(create_public_impl(key, val))
<a name="156"/>   end
<a name="157"/>
<a name="158"/>   #
<a name="159"/>   # Create a new private semaphore with the given initial value
<a name="160"/>   #
<a name="161"/>   public static create_private(val)
<a name="162"/>      ipc_available() | fail
<a name="163"/>      /val := 1
<a name="164"/>      return Sem(create_private_impl(val))
<a name="165"/>   end
<a name="166"/>end
</pre></body></html>
