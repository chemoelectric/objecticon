package ipl.browser

import 
   gui,
   util,
   net,
   graphics(Key),
   ipl.strings,
   ipl.tables(inserts),
   ipl.pdco()

abstract class HasAscent()
   public abstract get_ascent(dw, dh)
end

abstract class HasMaxWidth()
   public abstract get_max_width()
end

abstract class TextFlowCmd()
   public const attr
   package blob_width

   public new(attr)
      self.attr := attr
      return
   end
end

class ComponentCmd(TextFlowCmd)
   public const c, align

   public override new(c, attr, align)
      self.c := c
      self.attr := attr
      self.align := align
      return
   end
end

class TextCmd(TextFlowCmd)
   public const s

   public override new(s, attr)
      self.s := s
      self.attr := attr
      return
   end
end

class WbrCmd(TextFlowCmd)
end

class NamedAnchorCmd(TextFlowCmd)
   public const
      name

   public override new(name, attr)
      self.name := name
      self.attr := attr
      return
   end
end

class NewRowCmd(TextFlowCmd) end
class ParaCmd(TextFlowCmd) end
class SupStartCmd(TextFlowCmd) end
class SupEndCmd(TextFlowCmd) end
class SubStartCmd(TextFlowCmd) end
class SubEndCmd(TextFlowCmd) end

class BreakCmd(TextFlowCmd)
   public const clear

   public override new(clear, attr)
      self.clear := clear
      self.attr := attr
      return
   end
end

class TextOut(Rect)
   public const s, attr, ascent, descent
   package l_s     # Cached value of map(s)

   public override new(attr, s, ascent, descent, w, h)
      self.attr := attr
      self.s := s
      self.ascent := ascent
      self.descent := descent
      self.w := w
      self.h := h
      return
   end
end

class CompOut(Rect)
   public const c, align, attr, pw, maxw
   public ascent, descent

   public set_height_from_width()
      h := c.get_preferred_height(w)
      h <:= integer(c.get_constraint("fix_h"))
      link
   end

   public override new(attr, c, align, pw, maxw)
      self.attr := attr
      self.c := c
      self.align := align
      self.pw := pw
      self.maxw := maxw
      return
   end
end

class TextSelection()
   public const textout, textflow, i, j, w_off, w_sub

   public get_bounds()
      return Rect(textflow.x + textflow.border.get_l_inset() + textout.x + w_off,
                  textflow.y + textflow.border.get_t_inset() + textflow.y_off + textout.y,
                  w_sub,
                  textout.h)
   end

   public new(textout, textflow, i, j, w_off, w_sub)
      self.textout := textout
      self.textflow := textflow
      self.i := i
      self.j := j
      self.w_off := w_off
      self.w_sub := w_sub
      return
   end
end

#
# Intermediate results during a search
#
class SearchAhead()
   public const textout, i, j

   public new(textout, i, j)
      self.textout := textout
      self.i := i
      self.j := j
      return
   end
end

#
# Represents one result of a search.  The Point element is for sorting
# the results into order.  The `memb` member is the set of
# `TextSelection`s, one for each word (or part of word) in the search.
#
class SearchMatch(Point)
   public const
      textflow,  # owning TextFlow; all members are also in the same TextFlow.
      memb       # set of TextSelection

   # Get the bounds of all the elements in the result.
   public get_bounds()
      local e, t, r
      every e := !memb do {
         t := e.get_bounds()
         r := (\r).union(t) | t
      }
      return r
   end

   public override new(textflow, x, y, memb)
      self.textflow := textflow
      self.x := x
      self.y := y
      self.memb := memb
      return
   end
end

class OutputRow(Rect)
   public const l

   public override new()
      l := []
      return
   end
end

# A point and a string, used for sorting the text selection.
#
class PointResult(Point)
   public const val

   public override new(x, y, val)
      self.x := x
      self.y := y
      self.val := val
      return
   end
end

class TextFlow(Component, HasLastHighlight)
   public const
      input

   package
      ascent_adj

   private readable
      v_align,
      y_off

   private const
      browser

   private
      left_comps,
      right_comps,
      output_comps,
      output_rows,
      computed_output_rows,
      row,
      row_x,
      row_y,
      row_bottom,
      row_width,
      row_ascent,
      first_row_ascent,
      row_descent,
      baseline_off,
      row_abs_middle_height,
      row_abs_top_height,
      row_abs_bottom_height,
      max_word_w,
      max_ll,
      calculating,
      calculated,
      need_spc,
      right_margin,
      compute_w,
      deferred,
      at_new_para,
      trim_flag,
      def_width,
      max_width,
      held,               # URL held during mouse press
      over,               # URL the mouse is over; also written to the browser's msg area
      highlight,          # URL highlighted with alink colour.
      last_highlight,
      dominant_width,
      computed_named_anchors,
      named_anchors,
      blob_start,
      row_blob

   public static const 
      WHITESPACE,
      WHITESPACE_NB,
      PREFERRED_WIDTH,
      MAX_WIDTH,
      SEARCHED_CURR_COLOR,
      SEARCHED_OTHER_COLOR,
      MARKED_COLOR

   private static init()
      WHITESPACE := ' \t\r\n\v\f'
      WHITESPACE_NB := ' \t\r\n\v\f\xA0'
      PREFERRED_WIDTH := 1
      MAX_WIDTH := 2
      SEARCHED_CURR_COLOR := env_color("OI_TEXTFLOW_SEARCHED_CURR_COLOR") | "red 33%"
      SEARCHED_OTHER_COLOR := env_color("OI_TEXTFLOW_SEARCHED_OTHER_COLOR") | "purple 33%"
      MARKED_COLOR := env_color("OI_TEXTFLOW_MARKED_COLOR") | "yellow"
   end

   private compute(width)
      local c
      # We must compute in calculating mode before computing with a particular width, in order to set the row blobs.
      if \width & /calculated then
         compute()
      /width := 16r7fffffff
      if width === compute_w then 
         return
      compute_w := width
      calculating := Yes{ width = 16r7fffffff }
      output_comps := []
      output_rows := []
      left_comps := []
      right_comps := []
      named_anchors := table()
      row := []
      deferred := []
      at_new_para := &yes
      row_width := row_y := row_bottom := row_x := max_word_w := max_ll :=
         baseline_off := row_abs_middle_height := row_abs_top_height :=
         row_abs_bottom_height := row_ascent := row_descent := row_blob := 0
      right_margin := compute_w
      need_spc := first_row_ascent := blob_start := &null
      compute1()
      while *(row | deferred) > 0 do
         new_row()
      if \calculating then {
         # Ensure that we have cleared any left/right images, so that
         # we calculate max_ll correctly (which we only need if
         # calculating).
         until have_max() do 
            new_row()

         # Calculate default (=minimum) and max widths.
         def_width := 0
         every c := !input do
            def_width <:= \c.blob_width
         every c := !output_comps do
            def_width <:= c.pw
         def_width <:= max_word_w
         def_width +:= border.get_total_width()
         max_width := max_ll + border.get_total_width()

         calculated := &yes
      }
   end

   public set_trim(s)
      self.trim_flag := need_flag(s)
      link
   end

   public set_v_align(v)
      self.v_align := v
      link
   end

   public override reset_layout()
      max_width := def_width := output_rows := output_comps := left_comps :=
         calculated := named_anchors := right_comps := compute_w := &null
      every (!input).blob_width := &null
   end

   public set_dominant_width(x)
      self.dominant_width := x
      link
   end

   public override get_default_width()
      if dominant_width === MAX_WIDTH then
         return get_max_width()
      if /calculated then
         compute()
      return def_width
   end

   public get_max_width()
      if dominant_width === PREFERRED_WIDTH then
         return get_preferred_width()
      if /calculated then
         compute()
      return max_width
   end

   public override get_default_height(dw)
      local mh, co
      dw -:= border.get_total_width()
      compute(dw)
      mh := if /trim_flag then row_y else row_bottom
      every co := !left_comps | !right_comps do
        mh <:= co.y + co.h
      return mh + border.get_total_height()
   end

   public get_ascent(dw)
      return get_first_row_ascent(dw) + border.t_inset
   end

   public get_first_row_ascent(dw)
      dw -:= border.get_total_width()
      compute(dw)
      return \first_row_ascent | 0
   end

   private compute1()
      local cmd, font, W
      use {
         W := cbwin.clone(),
         {
            every cmd := !input do {
               W.set_font(font ~===:= cmd.attr.font)
               case classof(cmd) of {
                  ComponentCmd: 
                     compute_component(W, cmd)
                  NewRowCmd: {
                     # Avoid 1-pixel gap, which would be added if *row=0
                     if *row > 0 then
                        new_row()
                  }
                  ParaCmd: {
                     if /at_new_para then {
                        new_row(W.get_line_height() / 2)
                        at_new_para := &yes
                     }
                  }

                  SupStartCmd: baseline_off +:= W.get_font_ascent() / 2
                  SupEndCmd: baseline_off -:= W.get_font_ascent() / 2
                  SubStartCmd: baseline_off -:= W.get_font_ascent() / 3
                  SubEndCmd: baseline_off +:= W.get_font_ascent() / 3

                  BreakCmd: {
                     if *row > 0 then
                        new_row()
                     else
                        new_row(W.get_line_height())
                     case \cmd.clear of {
                        Align.L: 
                           until row_x = 0 do new_row()
                        Align.R:
                           until right_margin = compute_w do new_row()
                        "all":
                           until have_max() do new_row()
                     }
                  }
                  NamedAnchorCmd: {
                     if /calculating then
                        insert(named_anchors, string(cmd.name), row_y)
                  }
                  WbrCmd: {
                     if /cmd.attr.nowrap & /cmd.attr.pre then
                        blob_start := &null
                  }
                  TextCmd: {
                     if /cmd.attr.pre then {
                        if /cmd.attr.nowrap then
                           compute_txt(W, cmd)
                        else
                           compute_nowrap_txt(W, cmd)
                     } else
                        compute_pre_txt(W, cmd)
                  }
               }
            }
         }
      }
   end

   public lookup_named_anchor(name)
      local yp
      if yp := member(computed_named_anchors, string(name)) then
         return yp + y + border.get_t_inset() + y_off
   end

   private rows_in_range(ry, rh)
      local i, j, m, or
      # Shortcut for very common case
      if *computed_output_rows = 1 then {
         or := computed_output_rows[1]
         return if or.y + or.h > ry  &  or.y < ry + rh then or
      }
      i := 1
      j := *computed_output_rows
      while i <= j do {
         m := (i + j) / 2
         or := computed_output_rows[m]
         if or.y + or.h <= ry then
            i := m + 1
         else if or.y >= ry + rh then
            j := m - 1
         else
            break
      }
      if i > j then
         fail

      # Now row m is in the sought range; but rows before may be too,
      # so tab back as far as needed.
      while or := computed_output_rows[m - 1] &
         or.y + or.h > ry  &  or.y < ry + rh do
         m -:= 1

      # Now suspend all the rows in range from row m forwards.
      while or := computed_output_rows[m] &
         or.y + or.h > ry  &  or.y < ry + rh do
      {
         suspend or
         m +:= 1
      }
   end

   public override display()
      local o, W, font, fg, x1, y1, r, t, ts, or, want_fg
      border.draw(self.cbwin, x, y, w, h)
      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      use { 
         W := cbwin.clone(),
         {
            r := get_cbwin_clip()
            every or := rows_in_range(r.y - y1, r.h) do {
               every o := !or.l do {
                  if is(o, TextOut) then {
                     t := Rect(x1 + o.x, y1 + o.y, o.w, o.h)
                     if r.intersect(t) then {
                        want_fg := if o.attr.url === \highlight then
                           browser.page_alink_color
                        else
                           o.attr.fg
                        W.set_font(font ~===:= o.attr.font)
                        W.set_fg(fg ~===:= want_fg)
                        if \o.attr.mark then
                           text_bg(W, MARKED_COLOR, x1 + o.x, y1 + o.y, o.w, o.h)
                        W.draw_string(x1 + o.x, y1 + o.y + W.get_line_ascent(), o.s)

                        every ts := browser.is_searched(o) do {
                           # Note that browser.highlighted_searched may be &null, if we've done a redo_search and
                           # cannot reset the highlight; a different split of WBR tags may have this effect.
                           text_bg(W, 
                                   if member((\browser.highlighted_searched).memb, ts) then SEARCHED_CURR_COLOR else SEARCHED_OTHER_COLOR,
                                   x1 + o.x + ts.w_off,
                                   y1 + o.y, 
                                   ts.w_sub,
                                   o.h)
                        }

                        if ts := browser.is_banded(o) then
                           # NB - the rectangle used should be the same as that returned by ts.get_bounds()
                           Gui.style.fill_selection_rectangle(W,
                                                              x1 + o.x + ts.w_off,
                                                              y1 + o.y, 
                                                              ts.w_sub,
                                                              o.h)
                        if \o.attr.underline then
                           text_line(W,
                                     o.s, 
                                     x1 + o.x, 
                                     y1 + o.y + W.get_line_ascent() + Gui.UNIT)
                        else if \o.attr.underdash | (o.attr.url === \last_highlight) then
                           text_dash(W,
                                     o.s, 
                                     x1 + o.x, 
                                     y1 + o.y + W.get_line_ascent() + Gui.UNIT)
                        if \o.attr.strike then
                           text_line(W,
                                     o.s, 
                                     x1 + o.x,
                                     y1 + o.y + W.get_absolute_leading() + (2 * W.get_font_ascent()) / 3)
                        if o.attr.url === \over then
                           Gui.style.fill_over_rectangle(W, x1 + o.x, y1 + o.y, o.w, o.h)
                     }
                  }
               }
            }
         }
      }
      Component.display()
   end

   private static text_bg(W, c, x, y, w, h)
      local W2
      use {
         W2 := W.clone(),
         {
            W2.set_fg(c)
            W2.fill_rectangle(x, y, w, h)
         }
      }
   end

   private static text_dash(W, s, x, y)
      local W2
      use {
         W2 := W.clone(),
         {
            W2.set_masked_pattern("gray")
            text_line(W2, s, x, y)
         }
      }
   end

   private static text_line(W, s, x, y)
      local t, w1
      s ? repeat {
         if t := tab(many(WHITESPACE)) then
            x +:= W.text_width(t)
         if pos(0) then
            break
         t := tab(upto(WHITESPACE) | 0)
         w1 := W.text_width(t)
         W.fill_rectangle(x, y, w1, Gui.FINE_WIDTH)
         x +:= w1
      }
   end

   private static find_text_pos(W, o, d)
      local s, l, r, m, t1, t2, t3

      s := o.s
      l := 1
      r := *s + 1

      while l <= r do {
         m := (l + r) / 2
         t2 := W.text_width(s[1:m])
         if m > 1 &
            t1 := W.text_width(s[1:m - 1]) &
            d <= (t1 + t2) / 2
         then
            r := m - 1
         else if m < *s + 1 &
            t3 := W.text_width(s[1:m + 1]) &
            d > (t2 + t3) / 2
         then
            l := m + 1
         else
            return m
      }
      syserr("Loop exit in find_text_pos()")
   end

   package calculate_banded(br, bs)
      local i, j, or, o, W, font, x1, y1, t, first, last, first_r, last_r, l, ts
      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      l := []
      every or := rows_in_range(br.y - y1, br.h) do {
         every o := !or.l do {
            t := Rect(x1 + o.x, y1 + o.y, o.w, o.h)
            if t := br.intersect(t) then {
               if /first := o then
                  first_r := t
               last := o
               last_r := t
            }
            if \first then
               put(l, o)
         }
      }
      if /first then
         fail
      until l[-1] === last do
         pull(l)

      use { 
         W := cbwin.clone(),
         every o := !l do {
            case classof(o) of {
               TextOut: {
                  W.set_font(font ~===:= o.attr.font)
                  i := if o === first then
                     find_text_pos(W, o, first_r.x - x1 - o.x)
                  else
                     1
                  j := if o === last then
                     find_text_pos(W, o, last_r.x - x1 - o.x + last_r.w)
                  else
                     *o.s + 1

                  if i < j then {
                     ts := TextSelection(o, self, 
                                         i, j, 
                                         W.text_width(o.s[1:i]), W.text_width(o.s[i:j]))
                     insert(bs, o, ts)
                  }
               }
               CompOut: {
                  # An image; add the Img to the banded map.  (It may be
                  # inserted again by Browser.calculate_banded() if the
                  # image actually intersects the band).
                  insert(bs, o.c, o.c)
               }
            }
         }
      }
   end

   package search(sl, searched, sorted)
      local or, o, o1, ts, i, j, k, sp, s, W, x1, y1, sal, font, e, w
      s := sl[1]
      use {
         W := cbwin.clone(),
         {
            x1 := x + border.get_l_inset()
            y1 := y + border.get_t_inset() + y_off
            i := 1
            every or := !computed_output_rows do {
               j := 1
               every o := !or.l do {
                  if is(o, TextOut) then {
                     /o.l_s := map(o.s)
                     o.l_s ? every k := find(s[1]) do {
                        # Get the word (or first part thereof) starting at k
                        tab(k)
                        w := tab(upto(WHITESPACE_NB) | 0)
                        # Check for a simple one-word search match.
                        # Otherwise, we do a quick check if w can be
                        # the start of a match; if so we search ahead.
                        if *sl = 1 & match(s, w) then {
                           W.set_font(font ~===:= o.attr.font)
                           ts := TextSelection(o, self, 
                                               k, k + *s,
                                               W.text_width(o.s[1:k]),
                                               W.text_width(o.s[k+:*s]))

                           inserts(searched, o, ts)
                           # Note we use or.y as the y sort co-ordinate so that all matches in the same row             
                           # compare on their x position.                                                               
                           sp := SearchMatch(self, x1 + o.x + ts.w_off, y1 + or.y, set(ts))
                           put(sorted, sp)
                        } else if match(w, s) & sal := search_ahead(or, o, i, j, k, sl) then {
                           sp := &null
                           every e := !sal do {
                              o1 := e.textout
                              W.set_font(font ~===:= o1.attr.font)
                              ts := TextSelection(o1, self, 
                                                  e.i, e.j,
                                                  W.text_width(o1.s[1:e.i]),
                                                  W.text_width(o1.s[e.i:e.j]))
                              inserts(searched, o1, ts)
                              /sp := SearchMatch(self, x1 + o.x + ts.w_off, y1 + or.y, set())
                              insert(sp.memb, ts)
                           }
                           put(sorted, sp)
                        }
                     }
                  }
                  j +:= 1
               }
               i +:= 1
            }
         }
      }
   end

   # Search forward from the given position, (OutputRow or, TextOut o,
   # and position k in o.s).  The indices i, j are given such that :-
   #     i = keyof(computed_output_rows, or)
   #     j = keyof(or.l, o)
   #
   private search_ahead(or, o, i, j, k, sl)
      local word, i1, i2, res, n, s
      n := 1
      res := []
      while or := computed_output_rows[i] do {
         while o := or.l[j] do {
            # Don't allow any component to be a word separator.
            is(o, TextOut) | fail
            /o.l_s := map(o.s)
            o.l_s ? {
               tab(k)
               repeat {
                  if tab(many(WHITESPACE_NB)) then {
                     # End of word, so any accumulated word must match
                     # the current search word.
                     if \word then {
                        word == sl[n] | fail
                        word := &null
                        n +:= 1
                     }
                  }
                  if pos(0) then
                     break
                  i1 := &pos
                  s := tab(upto(WHITESPACE_NB) | 0)
                  i2 := &pos
                  /word := ""
                  word ||:= s
                  # The last word just has to start with the sought
                  # text; the others have to match exactly (the first
                  # one starts at the given offset k, so can be in the
                  # middle of a word).
                  if n = *sl & match(sl[n], word) then {
                     # We have matched the last word, so succeed.  The
                     # final SearchAhead is rather complicated; an
                     # example :-
                     #    sl[n] = "compute"  (the last search word)
                     #    s = "uters"
                     #    word =  "computers" (ie word was "comp" before)
                     #    i1 = 1, i2 = 6 (o.l_s = "uters ....")
                     # so the end index is 1 + 7 - 9 + 5 = 4
                     # ie the first 3 chars of o.l_s, "ute".
                     #
                     put(res, SearchAhead(o, i1, i1 + *sl[n] - *word + *s))
                     return res
                  }
                  # We do a quick check to ensure that word can
                  # eventually match sl[n].  For example, if we are
                  # looking for "compute" and we've got word = "comp"
                  # so far, we're okay.
                  match(word, sl[n]) | fail
                  put(res, SearchAhead(o, i1, i2))
               }
            }
            k := 1
            j +:= 1
         }
         # End of row, which is the same as end of word above.
         if \word then {
            word == sl[n] | fail
            word := &null
            n +:= 1
         }
         k := j := 1
         i +:= 1
      }
   end

   package get_selected_text(br, sorted)
      local o, x1, y1, t, or, sr, x2
      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      every or := rows_in_range(br.y - y1, br.h) do {
         sr := u""     # The selected text on this row
         x2 := &null   # The x position of the start of the selected text on this row
         every o := !or.l do {
            case classof(o) of {
               TextOut: {
                  if t := browser.is_banded(o) then {
                     sr ||:= o.s[t.i:t.j]
                     /x2 := x1 + o.x + t.w_off 
                  }
               }
               CompOut: {
                  if browser.is_banded(o.c) then {
                     sr ||:= \o.c.alt
                     /x2 := o.c.x  # o.c.x = x1 + o.x
                  }
               }
            }
         }
         if *sr > 0 then
            put(sorted, PointResult(x2, y1 + or.y, sr))
      }
   end

   private invalidate_url(u)
      local o, or, x1, y1, r
      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      r := get_clip_rect() | fail
      every or := rows_in_range(r.y - y1, r.h) do {
         every o := !or.l do {
            if is(o, TextOut) & (u === \o.attr.url) then
               invalidate(Rect(x1 + o.x, y1 + o.y, o.w, o.h))
         }
      }
   end

   package calculate_link_text(t)
      local o, or, u, u2, or2
      every or := !computed_output_rows do {
         every o := !or.l do {
            if is(o, TextOut) & (u := \o.attr.url) then {
               if u === u2 & or ~=== or2 then
                  t[u] ||:= u" "
               t[u] ||:= o.s
               u2 := u
               or2 := or
            }
         }
      }
   end

   public override layout()
      local co, c, x1, y1
      compute(self.w - border.get_total_width())
      y_off := case v_align of {
         "baseline": ascent_adj
         Align.T: 0
         Align.C: (h - get_default_height(w)) / 2
         Align.B: h - get_default_height(w)
         default: runerr("Invalid v_align", v_align)
      }

      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      every co := !output_comps do {
         c := co.c
         c.x := co.x + x1
         c.y := co.y + y1
         c.w := co.w
         c.h := co.h
         c.layout()
      }
      computed_output_rows := output_rows
      computed_named_anchors := named_anchors 
   end

   private new_row(gap)
      local x1, r, g, need, or, row_height
      if *row > 0 then {
         x1 := row_x

         # Expand space for comps relative to absolute top
         row_descent <:= row_abs_top_height - row_ascent

         # and to absolute bottom
         row_ascent <:= row_abs_bottom_height - row_descent

         # finally absolute middle
         need := row_abs_middle_height - (row_ascent + row_descent)
         if need > 0 then {
            row_ascent +:= need / 2
            row_descent +:= need / 2 + need % 2
         }

         row_height := row_ascent + row_descent

         if /calculating then {
            put(output_rows, or := OutputRow())
            or.x := row_x
            or.y := row_y
            or.h := row_height
            or.w := row_width
         }

         row_bottom := row_y + row_height

         /first_row_ascent := row_ascent      
         while r := get(row) do {
            if /calculating & x1 = row_x then {
               case r.attr.align of {
                  Align.C:
                     x1 +:= (right_margin - row_width - row_x) / 2
                  Align.R:
                     x1 +:= right_margin - row_width - row_x
               }
            }
            case classof(r) of {
               CompOut: {
                  r.x := x1
                  r.y := case r.align of {
                     Align.C: row_y + row_ascent - r.h / 2
                     Align.B: row_y + row_ascent - r.ascent
                     Align.T: row_y
                     "absbottom": row_y + row_height - r.h
                     "absmiddle": row_y + (row_height - r.h) / 2
                     default: runerr("Invalid alignment", r.align)
                  }
                  x1 +:= r.w
                  # Save images in the row for banded selection.
                  if is(r.c, Img) then
                     put((\or).l, r)
               }
               TextOut: {
                  r.x := x1
                  r.y := row_y + row_ascent - r.ascent
                  x1 +:= r.w
                  put((\or).l, r)
               }
               default: syserr("Invalid type in row")
            }
         }
         /gap := 0
         row_y +:= row_height + gap
      } else {
         /gap := 1
         row_y +:= gap
      }

      if \calculating then
         max_ll <:= compute_w - (right_margin - row_width - row_x)

      row_blob := row_width := row_abs_middle_height := row_abs_top_height := row_abs_bottom_height := row_ascent := row_descent := 0

      row_x := 0
      every g := !left_comps do
         if g.y <= row_y < g.y + g.h then
            row_x <:= g.x + g.w

      right_margin := compute_w
      every g := !right_comps do
         if g.y <= row_y < g.y + g.h then
            right_margin >:= g.x

      while do_deferred(deferred[1]) do
         pop(deferred)
   end

   # A special version of fits_in_row, used for determining if a
   # left/right aligned component will fit in the row.  The problem
   # arises in a case like :-
   #
   #    FIRST<img src="j3.jpeg" align="right"/>SECOND
   #
   # FIRST and SECOND form a blob, but row_width only includes
   # FIRST after it has been output.  Therefore fits_in_row may
   # wrongly indicate that the img would fit in the row, rather than
   # be deferred.  The solution is to set row_blob to the end of the
   # blob when FIRST is output, and use row_blob to see if the img
   # would fit.
   #
   private fits_in_row_lr(w)
      succeed have_max() | (row_x + w + max(row_blob, row_width) <= right_margin)
   end

   private fits_in_row(w)
      succeed have_max() | (row_x + w + row_width <= right_margin)
   end

   private do_deferred(co)
      # Note fits_in_row can be used since row_blob = 0.
      case co.align of {
         Align.L: {
            if fits_in_row(co.maxw) then {
               left_comp_out(co)
               return
            }
         }
         Align.R: {
            if fits_in_row(co.maxw) then {
               right_comp_out(co)
               return
            }
         }
      }
   end

   private left_comp_out(co)
      co.x := row_x
      co.y := row_y
      # Since we only do left/right_comp_out if co.maxw
      # fits_in_row_lr, we only need to reduce its width from maxw if
      # it fit because of have_max, and the available width is less
      # than maxw.
      co.w := min(co.maxw, compute_w)
      co.set_height_from_width()
      row_x +:= co.w
      put(left_comps, co)
   end

   private right_comp_out(co)
      co.w := min(co.maxw, compute_w)
      co.x := right_margin - co.w
      co.y := row_y
      co.set_height_from_width()
      right_margin -:= co.w
      put(right_comps, co)
   end

   package is_top_level()
      succeed self === browser.view.inner
   end

   private compute_component(W, cmd)
      local co, prefw, maxw, i
      prefw := cmd.c.get_preferred_width()
      maxw := if is(cmd.c, HasMaxWidth) then cmd.c.get_max_width() else prefw

      # Apply constraints
      if i := cmd.c.get_constraint("fix_w") then
         prefw := maxw := max(i, prefw)
      else if i := integer(cmd.c.get_constraint("pct_w")) then {
         case classof(cmd.c) of {
            Line: {
               if /calculating then
                  prefw := maxw := max(((right_margin - row_x - row_width) * i) / 100, prefw)
            }
            Img: {
               # For Img, specified widths refer to image width, excluding any border.
               if /calculating then
                  prefw := maxw := max((compute_w * i) / 100 + cmd.c.border.get_total_width(), prefw)
               else {
                  # Since prefw/maxw is set to 1 + the border width
                  # (see Img), we set it to the actual image size +
                  # the border, so the max width is calculated on that
                  # basis.
                  unless is_top_level() then
                     maxw := (\cmd.c.win).get_width() + cmd.c.border.get_total_width()
               }
            }
            Tbl: {
               if /calculating then
                  prefw := maxw := max((compute_w * i) / 100, prefw)
            }
            default: syserr("Invalid type with pct_w")
         }
      }
      co := CompOut(cmd.attr, cmd.c, cmd.align, prefw, maxw)
      put(output_comps, co)
      case cmd.align of {
         Align.L: {
            # If already have deferred, then defer this too, otherwise they will be out of order. 
            if *deferred = 0 & fits_in_row_lr(co.maxw) then
               left_comp_out(co)
            else
               put(deferred, co)
         }
         Align.R: {
            if *deferred = 0 & fits_in_row_lr(co.maxw) then 
               right_comp_out(co)
            else
               put(deferred, co)
         }
         Align.B: {
            comp_out(cmd, co)
            row_ascent <:= co.ascent
            row_descent <:= co.descent
         }
         Align.T: {
            comp_out(cmd, co)
            row_abs_top_height <:= co.h
         }
         Align.C: {
            comp_out(cmd, co)
            row_ascent <:= co.h / 2
            row_descent <:= co.h / 2 + co.h % 2
         }
         "absbottom": {
            comp_out(cmd, co)
            row_abs_bottom_height <:= co.h
         }
         "absmiddle": {
            comp_out(cmd, co)
            row_abs_middle_height <:= co.h
         }
         default: runerr("Invalid alignment", cmd.align)
      }
   end

   private comp_out(cmd, co)
      local c, tw, rb
      c := co.c
      if \co.attr.pre | *row = 0 then
         need_spc := &null
      if \co.attr.nowrap | \co.attr.pre then {
         if \calculating then {
            # In nowrap/pre mode we always either start a new blob, or
            # add to the existing one.
            if (*row = 0) | /blob_start then {
               blob_start := cmd
               cmd.blob_width := co.maxw
            } else
               blob_start.blob_width +:= co.maxw + get_pad()
         } else {
            if tw := \cmd.blob_width then {
               until fits_in_row(tw + get_pad()) do {
                  new_row()
                  need_spc := &null
               }
               rb := row_width + tw + get_pad()
            }
         }
      } else {
         if \calculating then {
            # Outside of nowrap/pre mode; a component always cancels a
            # blob (so a break may occur to the left or right of an
            # image).
            blob_start := &null
         } else {
            tw := co.maxw
            until fits_in_row(tw + get_pad()) do {
               new_row()
               need_spc := &null
            }
         }
      }

      if \need_spc then {
         put(row, need_spc)
         row_width +:= need_spc.w
         row_ascent <:= need_spc.ascent
         row_descent <:= need_spc.descent
      }
      co.w := min(co.maxw, right_margin - row_x - row_width)
      co.set_height_from_width()
      co.ascent := (if is(co.c, HasAscent) then co.c.get_ascent(co.w, co.h) else co.h) + baseline_off
      co.descent := co.h - co.ascent
      put(row,  co)
      row_width +:= co.w
      row_blob := \rb
      need_spc := at_new_para := &null
   end

   private txt_out(W, attr, s, rb)
      local xo
      if \need_spc then {
         put(row, need_spc)
         row_width +:= need_spc.w
         row_ascent <:= need_spc.ascent
         row_descent <:= need_spc.descent
      }
      xo := TextOut(attr, s, 
                    W.get_line_ascent() + baseline_off, 
                    W.get_line_descent() - baseline_off, 
                    W.text_width(s), W.get_line_height())
      put(row,  xo)
      row_width +:= xo.w
      row_ascent <:= xo.ascent
      row_descent <:= xo.descent
      row_blob := \rb
      at_new_para := &null
   end

   private have_max()
      succeed *row = 0 & row_x = 0 & right_margin = compute_w
   end

   private make_pad(W, attr)
      return TextOut(attr, u" ",
                     W.get_line_ascent() + baseline_off, 
                     W.get_line_descent() - baseline_off, 
                     W.text_width(" "), W.get_line_height())
   end

   private get_pad()
      return (\need_spc).w | 0
   end

   private compute_txt(W, cmd)
      local ds, ds2, tw, attr, wd, l, i, rb
      attr := cmd.attr

      l := []
      every put(l, words(cmd.s, WHITESPACE))

      if *row = 0 | *l = 0 then
         need_spc := &null
      else if any(WHITESPACE, cmd.s) then 
         /need_spc := make_pad(W, attr)

      if \calculating then {
         # If we are at the start of a row, or start with whitespace,
         # then we cancel any existing blob; otherwise the first word
         # must be added to any existing blob.
         if (*row = 0) | any(WHITESPACE, cmd.s) then
            blob_start := &null
         else if \blob_start then
            # We might have need_spc here if we've just left a nobr
            # section, for example :- "<nobr>Some text </nobr>after"
            blob_start.blob_width +:= W.text_width(l[1]) + get_pad()

         # If the input ends with whitespace, then we have no blob
         # since that can give a break.  Otherwise, the last word may
         # start a new blob.  If we have >1 words, then it must since
         # that implies a space in the input.
         if any(WHITESPACE, cmd.s[-1]) then
            blob_start := &null
         else if (*l > 1) | /blob_start then {
            blob_start := cmd
            cmd.blob_width := W.text_width(l[-1])
         }
         every max_word_w <:= W.text_width(!l)
      }

      ds := u""
      i := 1
      while wd := l[i] do {
         if *ds = 0 then
            ds2 := wd
         else
            ds2 := ds || u" " || wd
         if \calculating then {
            ds := ds2
            i +:= 1
         } else {
            tw := W.text_width(ds2) + get_pad()
            #
            # The width of the last word is given by the blob width, if any.  For example, if we have
            # <u>Fred Smith</u><i>Hello</i>
            # and wd = Smith, then blob_width = len(Smith) + len(hello), tw = len(Fred Smith), and we
            # will adjust tw to = len(Fred Smith) - len(Smith) + bw = len(Fred Smith) + len(hello).
            # Thus, this corresponds to the sum of the strings we will output.
            #
            if (i = *l) & \cmd.blob_width then {
               tw -:= W.text_width(wd) - cmd.blob_width
               rb := row_width + tw
            }
            if row_x + row_width + tw > right_margin then {
               if *ds = 0 then {
                  if have_max() then {
                     txt_out(W, attr, wd)
                     i +:= 1
                  }
               } else {
                  txt_out(W, attr, ds)
                  ds := u""
               }
               new_row()
               need_spc := &null
            } else {
               ds := ds2
               i +:= 1
            }
         }
      }
      if *ds > 0 then
         txt_out(W, attr, ds, rb)

      need_spc := if any(WHITESPACE, cmd.s[-1]) then
         make_pad(W, attr)
      else
         &null
   end

    private compute_nowrap_txt(W, cmd)
      local ds, wd, tw, attr, rb
      attr := cmd.attr

      # Calculate ds being the catenation without leading space
      ds := u""
      every wd := words(cmd.s, WHITESPACE) do {
         if *ds = 0 then
            ds := wd
         else
            ds ||:= u" " || wd
      }

      if *row = 0 | *ds = 0 then
         need_spc := &null
      else if any(WHITESPACE, cmd.s) then 
         /need_spc := make_pad(W, attr)

      if \calculating then {
         # If we are starting a new blob, then the width is ds, since
         # potentially we can break to a new row.  If adding to a
         # blob, then add any pad space, since we can't break and must
         # show the space.
         if (*row = 0) | /blob_start then {
            blob_start := cmd
            cmd.blob_width := W.text_width(ds)
         } else
            blob_start.blob_width +:= W.text_width(ds) + get_pad()
      } else {
         if tw := \cmd.blob_width then {
            # The blob width gives us the width excluding any leading
            # space, so unless at start of row we must ensure we have
            # the space too.
            until fits_in_row(tw + get_pad()) do {
               new_row()
               need_spc := &null
            }
            rb := row_width + tw + get_pad()
         }
      }

      if *ds > 0 then
         txt_out(W, attr, ds, rb)

      need_spc := if any(WHITESPACE, cmd.s[-1]) then
         make_pad(W, attr)
      else
         &null
   end

   private compute_pre_txt(W, cmd)
      local s, l, i, tw, rb
      l := ipl.pdco.List{ detab(separate_lines(cmd.s)) }
      need_spc := &null

      if \calculating then {
         # This follows similar logic to compute_txt above.  First,
         # cancel the current blob if we are starting a new line;
         # otherwise add the first line to any current blob.
         if *row = 0 then
            blob_start := &null
         else
            (\blob_start).blob_width +:= W.text_width(l[1])

         # Now see if we start a new blob.  If we end with a nl, then
         # no, since that starts a new row.  Otherwise start a new
         # blob, unless we have just one line and an existing blob (to
         # which the single line will have just been added).
         if cmd.s[-1] == "\n" then
            blob_start := &null
         else if (*l > 1) | /blob_start then {
            blob_start := cmd
            cmd.blob_width := W.text_width(l[-1])
         }
         every max_word_w <:= W.text_width(!l)
      }
      every i := 1 to *l do {
         s := l[i]
         if /calculating then {
            if (i = *l) & tw := \cmd.blob_width then {
               until fits_in_row(tw) do
                  new_row()
               rb := row_width + tw 
            } else {
               tw := W.text_width(s)
               until fits_in_row(tw) do
                  new_row()
            }
         }

         txt_out(W, cmd.attr, s, rb)
         # Every element of l except the last ends in a new line
         # (recall that "abc\ndef\n" -> l=["abc","def",""])
         if i < *l then
            new_row()
      }
   end

   private which_text_out(e)
      local or, o, x1, y1
      in_region(e) | fail
      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      every or := rows_in_range(e.y - y1, 1) do {
         every o := !or.l do {
            if is(o, TextOut) & o.inside(e.x - x1, e.y - y1) then
               return o
         }
      }
   end

   private handle_lrelease(e)
      \held | fail
      if \over then {
         set_highlight()
         self.browser.link_left_clicked(over)
      }
      held := &null
   end

   private handle_mrelease(e)
      \held | fail
      if \over then {
         set_highlight()
         self.browser.link_middle_clicked(over)
      }
      held := &null
   end

   private handle_lpress(e)
      local c, t
      parent_dialog.get_held_count() = 1 | fail
      if \over then {
         set_highlight(over)
         held := over
      } else if t := which_text_out(e) then {
         if c := \ ( \ (t.attr.form_label)).comp & not c.is_shaded() then {
            parent_dialog.set_focus(c.gen_focusable(e))
            if is(c, Toggle) then
               c.on_action(e)
         }
      }
   end

   private handle_mpress(e)
      parent_dialog.get_held_count() = 1 | fail
      if \over then {
         set_highlight(over)
         held := over
      }
   end

   package wants_rpress(e)
      # Also check highlight since we may have just opened a menu,
      # clearing over and setting highlight.
      return \over | \highlight
   end

   package wants_lpress(e)
      return \over
   end

   private handle_rpress(e)
      local pm, pm_menu
      parent_dialog.get_held_count() = 1 | fail
      if pm_menu := browser.create_link_menu(\over) then {
         set_highlight(over)
         set_over()
         pm := PopupMenu()
         pm.connect(on_popup_closed, Event.POPUP_CLOSED)
         pm.popup(self, pm_menu, e.x, e.y)
      }
   end

   private on_popup_closed()
      set_highlight()
   end

   package handle_in_chain(e)
      local u, t, a, f
      parent_dialog.get_held_count() = 0 | fail
      if e.code === (Key.CONTROL_L | Key.CONTROL_R) then {
         if /e.release then
            f := &yes
      } else f := \e.ctrl
      t := which_text_out(e)
      a := (\t).attr.title
      set_tooltip(a)
      if /f & (u := \ (\t).attr.url) then
         set_over(u)
      else {
         set_over()
         if \t then
            set_pointer("xterm")
         else
            set_pointer()
      }
   end

   private handle_lmdrag(e)
      \held | fail
      if \which_text_out(e).attr.url === held then {
         set_over(held)
         set_highlight(held)
      } else {
         set_over()
         set_highlight()
      }
   end

   private handle_exit(e)
      parent_dialog.get_held_count() = 0 | fail
      set_over()
   end

   private handle_interrupted(e)
      set_highlight()
      set_over()
      held := &null
   end

   private set_over(u)
      if u ~=== over then {
         invalidate_url(\over)
         over := u
         invalidate_url(\over)
         if /over then {
            browser.msg()
            set_pointer()
         } else {
            browser.msg(over.str())
            set_pointer("hand1")
         }
      }
      link
   end

   package override save_last_highlight(he)
      local or, o, n, u
      n := 0
      every or := !computed_output_rows do {
         every o := !or.l do {
            if u := \o.attr.url then {
               n +:= 1
               if last_highlight === u then {
                  he.last_highlight_index := n
                  he.last_highlight := u
                  link
               }
            }
         }
      }
   end

   package override restore_last_highlight(n, url)
      local or, o, u
      every or := !computed_output_rows do {
         every o := !or.l do {
            if u := \o.attr.url then {
               n -:= 1
               if n = 0 then {
                  URL.equiv(url, u) | fail
                  last_highlight := u
                  link
               }
            }
         }
      }
   end

   public override set_last_highlight(u)
      if u ~=== last_highlight then {
         invalidate_url(\last_highlight)
         last_highlight := u
         invalidate_url(\last_highlight)
      }
      link
   end

   private set_highlight(u)
      if u ~=== highlight then {
         browser.set_last_highlight(self, \u)
         invalidate_url(\highlight)
         highlight := u
         invalidate_url(\highlight)
      }
      link
   end

   public override new(browser)
      Component.new()
      self.browser := browser
      set_border(NullBorder())
      input := []
      ascent_adj := 0
      v_align := Align.T
      trim_flag := &yes
      set_constraint("x_fill", &yes)
      set_constraint("y_fill", &yes)
      connect(handle_lmdrag, Event.MOUSE_LEFT_DRAG)
      connect(handle_lmdrag, Event.MOUSE_MIDDLE_DRAG)
      connect(handle_mpress, Event.MOUSE_MIDDLE_PRESS)
      connect(handle_lpress, Event.MOUSE_LEFT_PRESS)
      connect(handle_lrelease, Event.MOUSE_LEFT_RELEASE)
      connect(handle_exit, Event.MOUSE_EXIT)
      connect(handle_interrupted, Event.INTERRUPTED)
      connect(handle_rpress, Event.MOUSE_RIGHT_PRESS)
      connect(handle_mrelease, Event.MOUSE_MIDDLE_RELEASE)
      return
    end
end
