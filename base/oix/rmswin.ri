/*
 * rmswin.ri - Microsoft Windows-specific graphics interface code.
 *
 */

#define FONTHASH_SIZE 64
#define CURSORHASH_SIZE 128

static struct SharedCursor *null_cursor;
static wcp alccontext(wbp w);
static void init_window_system(void);
static void setup_cursors(void);
static int inited;
static void pix_to_win(wsp ws);
static void open_screen_win(wsp ws);
static void close_screen_win(wsp ws);
static wfp fonts[FONTHASH_SIZE], default_font;
static struct wcursor *cursors[CURSORHASH_SIZE];
static wfp load_font(char *s);
static int font_maxcharwidth(HFONT f);
static char *convert_spec(char *s);
static HFONT findfont(char *family, double size, int flags, int ansi);
static HFONT mkfont(char *s);
static HWND dummy_win;
static HDC dummy_hdc;
static wsp wsp_for_hwnd(HWND hwnd);
static wcp clonecontext(wcp src);
static void freecontext(wcp wc);
static void freewindow(wsp ws);
static HDC get_win_dc(wbp);
static HDC get_pix_dc(wbp);
static void resizepixmap(wbp w);
static int devicecaps(wbp w, int i);
static struct imgdataformat imgdataformat_MSBGRX32;
static POINT *convert_points(struct point *points0, int npoints);
static COLORREF mscolor(int r, int g, int b);
static struct SharedColor *new_sharedcolor(char *name, COLORREF color, int a);
static struct SharedColor *link_sharedcolor(struct SharedColor *i);
static void unlink_sharedcolor(struct SharedColor *i);
static struct SharedBitmap *new_sharedbitmap(struct imgdata *imd);
static struct SharedBitmap *link_sharedbitmap(struct SharedBitmap *x);
static void unlink_sharedbitmap(struct SharedBitmap *x);
static struct SharedCursor *new_sharedcursor(HCURSOR cursor);
static struct SharedCursor *link_sharedcursor(struct SharedCursor *x);
static void unlink_sharedcursor(struct SharedCursor *x);
static struct wcursor *lookup_wcursor(char *name);
static struct wcursor *ensure_wcursor(char *name);
static void synch_cursor(wsp ws);
static HBITMAP imgdata_to_bitmap(struct imgdata *imd);
static void bitmap_to_imgdata(HBITMAP bitmap, struct imgdata *imd);
static HBRUSH get_fg_brush(wcp wc);
static HPEN get_fg_pen(wcp wc);
static HBRUSH get_bg_brush(wcp wc);
static wbp findwbp(wsp ws);
static void handle_mouse(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse_enter(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse_leave(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse_move(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse_wheel(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_capture_changed(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_keypress(wsp ws, UINT msg, WPARAM wp, LPARAM lp, int meta);
static void handle_config(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void rectanglehelper(wcp wc, HDC stddc, HDC pixdc, int x, int y, int width, int height);
static void capture_mouse(wsp ws);
static void uncapture_mouse(wsp ws);
static void track_mouse(wsp ws);
static WCHAR *ucs_to_wchars(dptr str, int nullterm);
static void apply_windowlabel(wsp ws);

static void dbg(char *fmt, ...);

static int mouse_debug = 0;

static struct SharedColor *black, *white;

#begdef CheckUnhidden(ws)
do {
   if (!ws->win) {
      LitWhy("Window is hidden");
      return Failed;
   }
} while(0)
#enddef

/* List of windows with win non-null */
static wsp vwstates;

/* List of bindings */
static wbp wbndngs;

#define PALCLR(c) (c | 0x2000000L)

static int BORDHEIGHT;
static int BORDWIDTH;
static int CLIENT_XOFF;
static int CLIENT_YOFF;

/*
 * check for double-byte character set versions of Windows
 */
CPINFO cpinfo;
int MAXBYTESPERCHAR;

/*
 * draw ops
 */
stringint drawops[] = {
    { 0, 16},
    {"and",              R2_MASKPEN},
    {"andInverted",      R2_MASKPENNOT},
    {"andReverse",       R2_MASKNOTPEN},
    {"clear",            R2_BLACK},
    {"copy",             R2_COPYPEN},
    {"copyInverted",     R2_NOTCOPYPEN},
    {"equiv",            R2_NOTXORPEN},
    {"invert",           R2_NOT},
    {"nand",             R2_NOTMASKPEN},
    {"noop",             R2_NOP},
    {"nor",              R2_NOTMERGEPEN},
    {"or",               R2_MERGEPEN},
    {"orInverted",       R2_MERGEPENNOT},
    {"orReverse",        R2_MERGENOTPEN},
    {"set",              R2_WHITE},
    {"xor",              R2_XORPEN},
};

/*
 * line types
 */
stringint linestyles[] = {
    {0, 6},
    {"dashdotdotted",     PS_DASHDOTDOT},
    {"dashdotted",        PS_DASHDOT},
    {"dashed",            PS_DOT},
    {"longdashed",        PS_DASH},
    {"solid",             PS_SOLID},
    {"striped",           PS_DOT}
};

#define NormalCanvas 1
#define HiddenCanvas 2
#define IconicCanvas 3
#define PopupCanvas  4
#define MaximizedCanvas  5

static stringint canvastypes[] = {
    {0, 5},
    {"hidden",      HiddenCanvas},
    {"iconic",      IconicCanvas},
    {"maximized",   MaximizedCanvas},
    {"normal",      NormalCanvas},
    {"popup",       PopupCanvas},
};

#if 0
static void dump_all(void)
{
    int i,j,k;
    wsp x;
    wbp y;
    i = 0;
    for (y = wbndngs; y; y = y->next) {
        printf("Binding %p\n",y);
        printf("\tcanvas %p\n",y->window);
        printf("\tcontext %p\n",y->context);
        ++i;
    }
    printf("============\n");
    j = 0;
    for (x = wstates; x; x = x->next) {
        printf("Canvas %p\n",x);
        printf("\trefcount=%d\n", x->refcount);
        printf("\tlabel=%s\n", x->windowlabel);
        printf("\tgeometry=%d,%d %dx%d\n", x->x,x->y,x->width,x->height);
        printf("\twin=%d\n", (int)x->win);
        ++j; 
    }
    printf("============\n");
    k = 0;
    for (x = vwstates; x; x = x->vnext) {
        printf("Non-hidden Canvas %p\n",x);
        printf("\trefcount=%d\n", x->refcount);
        printf("\tlabel=%s\n", x->windowlabel);
        printf("\tgeometry=%d,%d %dx%d\n", x->x,x->y,x->width,x->height);
        printf("\twin=%d\n", (int)x->win);
        ++k; 
    }

    printf("Total %d bindings %d canvases (%d non-hidden)\n",i,j,k);
    fflush(stdout);
}
#endif

static POINT *convert_points(struct point *points0, int npoints)
{
    POINT *points;
    int i;
    MemProtect(points = malloc(npoints * sizeof(POINT)));
    for (i = 0; i < npoints; ++i) {
        points[i].x = (LONG)points0[i].x;
        points[i].y = (LONG)points0[i].y;
    }
    return points;
}

/*
 * allocate a window binding structure
 */
static wbp alcwbinding(void)
{
    wbp w;
    MemProtect(w = calloc(1, sizeof(struct _wbinding)));
    GLink(w, wbndngs);
    return w;
}

/*
 * free a window binding.
 */
void freewbinding(wbp w)
{
    freewindow(w->window);
    freecontext(w->context);
    GUnlink(w, wbndngs);
    free(w);
}

wbp wopen(char *display)
{
    wbp w;
    wsp ws;
    RECT rec;
    HDC hdc2;
    HBRUSH brush;
    HBITMAP oldpix;

    if (!inited) {
        init_window_system();
        inited = 1;
    }

    /*
     * allocate a binding, a window state, and a context
     */
    w = alcwbinding();

    GAlloc(ws, _wstate);
    ws->listp = nulldesc;
    ws->windowlabel = nulldesc;
    add_gc_global(&ws->windowlabel);
    add_gc_global(&ws->listp);
    ws->cursor = lookup_wcursor("arrow");
    ws->minwidth = ws->minheight = 1;
    ws->maxwidth = ws->maxheight = INT_MAX;
    w->window = ws;
    defaultwindowlabel(&ws->windowlabel);
    ws = w->window;
    create_list(64, &ws->listp);
    ws->width = ws->height = 1;

    w->context = alccontext(w);

    if (ws->x < 0) ws->x = 0;
    if (ws->y < 0) ws->y = 0;

    ws->pix = CreateCompatibleBitmap(dummy_hdc, ws->width, ws->height);
    ws->pixwidth = ws->width;
    ws->pixheight = ws->height;
    ws->win = 0;

    /*
     * initialize the image with the background color
     */
    hdc2 = CreateCompatibleDC(dummy_hdc);
    oldpix = SelectObject(hdc2, ws->pix);
    rec.left = rec.top = 0;
    rec.right = ws->width;
    rec.bottom = ws->height;
    brush = get_bg_brush(w->context);
    FillRect(hdc2, &rec, brush);
    DeleteObject(brush);
    SelectObject(hdc2, oldpix);
    DeleteDC(hdc2);
    return w;
}

static void apply_windowlabel(wsp ws)
{
    WCHAR *mbs = ucs_to_wchars(&ws->windowlabel, 1);
    SetWindowTextW(ws->win, mbs);
    free(mbs);
}

static void handle_config(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    int neww, newh;

    switch (wp) {
        case SIZE_MINIMIZED: {
            ws->state = IconicCanvas;
            return;
        }
        case SIZE_MAXIMIZED: {
            ws->state = MaximizedCanvas;
            break;
        }
        case SIZE_RESTORED: {
            ws->state = NormalCanvas;
            break;
        }
    }

    neww = LOWORD(lp);
    newh = HIWORD(lp);

    /*
     * if it was not a resize, drop it
     */
    if ((ws->width == neww) && (ws->height == newh))
        return;

    ws->width = neww;
    ws->height = newh;
    resizepixmap(findwbp(ws));
    qeventcode(ws, WINDOWRESIZED);
}

static void handle_keypress(wsp ws, UINT msg, WPARAM wp, LPARAM lp, int meta)
{
    DWORD dw;
    int t;
    WORD x, y;
    struct descrip d;
    int fl = 0;
    static struct descrip curr_down;

    if (msg == WM_KEYUP)
        d = curr_down;     
    else if (msg == WM_CHAR || msg == WM_SYSCHAR) {
        StrLen(d) = 1;
        StrLoc(d) = &allchars[wp & 0xFF];
        curr_down = d;
    }
    else { /* WM_KEYDOWN or WM_SYSKEYDOWN */
        MakeInt(wp, &d);
        curr_down = d;
    }
    dw = GetMessagePos(); /* mouse location in SCREEN coordinates */
    x = LOWORD(dw) - ws->x - FRAMEWIDTH;
    y = HIWORD(dw) - ws->y - TITLEHEIGHT - (FRAMEHEIGHT-1);

    t = GetMessageTime();

    if (GetKeyState(VK_CONTROL) < 0)
        fl |= MOD_CTRL;
    if (GetKeyState(VK_SHIFT) < 0)
        fl |= MOD_SHIFT;
    if (meta)
        fl |= MOD_META;
    if (msg == WM_KEYUP)
        fl |= MOD_RELEASE;
    qevent(ws, &d, x, y, t, fl);
}

static void handle_mouse_wheel(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    int t;
    WORD x, y;
    RECT r;
    int state = 0;
    int fl = 0;

    if (MK_LBUTTON & wp) state |= 1;
    if (MK_MBUTTON & wp) state |= 2;
    if (MK_RBUTTON & wp) state |= 4;

    /* Unlike normal mouse events, the co-ordinates are absolute, so
     * convert to relative.
     */
    GetWindowRect(ws->win, &r);
    x = LOWORD(lp) - (r.left + CLIENT_XOFF);
    y = HIWORD(lp) - (r.top + CLIENT_YOFF);

    t = GetMessageTime();

    if (MK_CONTROL & wp)
        fl |= MOD_CTRL;
    if (MK_SHIFT & wp)
        fl |= MOD_SHIFT;

    /*
     * We only get one MS event for a wheel movement, so call
     * qmouseevents twice, once with the button 4 or 5 going down and
     * again with it coming up.  This generates one icon event, on the
     * second qmouseevents call.
     */
    if ((long)wp > 0)
        qmouseevents(ws, state|8, x, y, t, fl);
    else
        qmouseevents(ws, state|16, x, y, t, fl);
    
    qmouseevents(ws, state, x, y, t, fl);
}

static void handle_mouse_enter(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    int t;
    WORD x, y;
    struct descrip d;
    x = LOWORD(lp);
    y = HIWORD(lp);
    t = GetMessageTime();
    MakeInt(MOUSEENTERED, &d);
    qevent(ws, &d, x, y, t, 0);
}

static void dbg(char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    fflush(stderr);
}

static void capture_mouse(wsp ws)
{
    if (mouse_debug) dbg("capture_mouse grabbingmouse=%d\n", ws->grabbingmouse);
    if (ws->grabbingmouse == 0) {
        ws->savedgrab = SetCapture(ws->win);
        if (mouse_debug) dbg("SetCapture, saved grab=%x ourselves=%x\n",ws->savedgrab, ws->win);
    }
    ++ws->grabbingmouse;
    if (mouse_debug) dbg("now grabbingmouse=%d\n", ws->grabbingmouse);
}

static void uncapture_mouse(wsp ws)
{
    if (mouse_debug) dbg("uncapture_mouse grabbingmouse=%d\n", ws->grabbingmouse);
    if (ws->grabbingmouse > 0) {
        --ws->grabbingmouse;
        if (ws->grabbingmouse == 0) {
            if (mouse_debug) dbg("SetCapture to %x\n",ws->savedgrab);
            /* This will in fact now call handle_capture_changed() */
            SetCapture(ws->savedgrab);
            ws->savedgrab = 0;
        }
    }
    if (mouse_debug) dbg("now grabbingmouse=%d\n", ws->grabbingmouse);
}

/*
 * This may be called either when we release in uncapture_mouse above,
 * or externally.  In either case, set the count and grab to zero.
 * Some calls to uncapture_mouse() may follow, and do nothing.
 */
static void handle_capture_changed(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    if (mouse_debug) dbg("handle_capture_changed, resetting grabbingmouse to 0\n");
    ws->savedgrab = 0;
    ws->grabbingmouse = 0;
}

static void track_mouse(wsp ws)
{
    TRACKMOUSEEVENT tme;
    tme.cbSize = sizeof(TRACKMOUSEEVENT);
    tme.dwFlags = TME_LEAVE;
    tme.hwndTrack = ws->win;
    TrackMouseEvent(&tme);
    ws->trackingmouse = 1;
}

static void handle_mouse_leave(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    int t;
    struct descrip d;
    t = GetMessageTime();
    MakeInt(MOUSEEXITED, &d);
    qevent(ws, &d, 0, 0, t, 0);
    ws->trackingmouse = 0;
}

static void handle_mouse_move(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    synch_cursor(ws);
    if (!ws->trackingmouse) {
        handle_mouse_enter(ws, msg, wp, lp);
        track_mouse(ws);
    }
    handle_mouse(ws, msg, wp, lp);
}

static void handle_mouse(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    int t;
    WORD x, y;
    int state = 0;
    int fl = 0;
    if (MK_LBUTTON & wp) state |= 1;
    if (MK_MBUTTON & wp) state |= 2;
    if (MK_RBUTTON & wp) state |= 4;

    x = LOWORD(lp);
    y = HIWORD(lp);
    t = GetMessageTime();

    if (MK_CONTROL & wp)
        fl |= MOD_CTRL;
    if (MK_SHIFT & wp)
        fl |= MOD_SHIFT;

    qmouseevents(ws, state, x, y, t, fl);
}

LRESULT_CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    HDC hdc, hdc2;
    PAINTSTRUCT ps;
    RECT rect;
    wsp ws;
    ws = wsp_for_hwnd(hwnd);
    if (ws) 
        switch(msg) {
            case WM_PAINT: {
                HBITMAP oldpix;
                hdc = BeginPaint(hwnd, &ps);
                GetClientRect(hwnd, &rect);
                hdc2 = CreateCompatibleDC(hdc);
                oldpix = SelectObject(hdc2, ws->pix);
                BitBlt(hdc, rect.left, rect.top,
                       rect.right - rect.left + 1, rect.bottom - rect.top + 1,
                       hdc2, rect.left, rect.top, SRCCOPY);
                SelectObject(hdc2, oldpix);
                DeleteDC(hdc2);
                EndPaint(hwnd, &ps);
                return 0;
            }
            case WM_MOUSEMOVE:
                handle_mouse_move(ws, msg, wp, lp);
                return 0;
            case WM_MOUSELEAVE:
                handle_mouse_leave(ws, msg, wp, lp);
                return 0;
            case WM_MOUSEWHEEL:
                handle_mouse_wheel(ws, msg, wp, lp);
                return 0;
            case WM_CAPTURECHANGED:
                handle_capture_changed(ws, msg, wp, lp);
                return 0;
            case WM_LBUTTONDOWN: case WM_RBUTTONDOWN: case WM_MBUTTONDOWN:
                capture_mouse(ws);
                handle_mouse(ws, msg, wp, lp);
                return 0;
            case WM_LBUTTONUP:   case WM_RBUTTONUP:   case WM_MBUTTONUP:
                uncapture_mouse(ws);
                handle_mouse(ws, msg, wp, lp);
                return 0;
            case WM_KEYUP:
                if (ws->inputmask & IM_KEY_RELEASE)
                    handle_keypress(ws, msg, wp, lp, 0);
                return 0;
            case WM_KEYDOWN:
                switch (wp) { /* VK defn's from <winuser.h> */
                    case VK_F1: case VK_F2: case VK_F3: case VK_F4:
                    case VK_F5: case VK_F6: case VK_F7: case VK_F8:
                    case VK_F9: case VK_F10: case VK_F11: case VK_F12:
                    case VK_HOME: case VK_END: case VK_PRIOR: case VK_NEXT:
                    case VK_LEFT: case VK_RIGHT: case VK_UP: case VK_DOWN:
                    case VK_INSERT: case VK_SELECT: case VK_PRINT:
                    case VK_EXECUTE: case VK_SNAPSHOT: case VK_HELP: case VK_SEPARATOR:
                    case VK_CLEAR: case VK_PAUSE: case VK_SCROLL:
                        handle_keypress(ws, msg, wp, lp, 0);
                        return 0;
                    case VK_DELETE:
                        handle_keypress(ws, WM_CHAR, '\177', lp, 0);
                        return 0;
                    default:
                        if (ws->inputmask & IM_KEY_RELEASE) {
                            handle_keypress(ws, msg, wp, lp, 0);
                            return 0;
                        }
                }
                break;
            case WM_SYSKEYDOWN:
                switch (wp) {
                    case VK_F1: case VK_F2: case VK_F3: /* alt-F4 terminates */
                    case VK_F5: case VK_F6: case VK_F7: case VK_F8:
                    case VK_F9: case VK_F10: case VK_F11: case VK_F12:
                    case VK_HOME: case VK_END: case VK_PRIOR: case VK_NEXT:
                    case VK_LEFT: case VK_RIGHT: case VK_UP: case VK_DOWN:
                    case VK_INSERT: case VK_DELETE: case VK_SELECT: case VK_PRINT:
                    case VK_EXECUTE: case VK_SNAPSHOT: case VK_HELP: case VK_SEPARATOR:
                    case VK_CLEAR: case VK_PAUSE:
                        handle_keypress(ws, msg, wp, lp, 1);
                        return 0;
                    default:
                        if (ws->inputmask & IM_KEY_RELEASE) {
                            handle_keypress(ws, msg, wp, lp, 0);
                            return 0;
                        }
                }
                break;
            case WM_CHAR:
                handle_keypress(ws, msg, wp, lp, 0);
                return 0;
            case WM_SYSCHAR:
                handle_keypress(ws, msg, wp, lp, 1);
                break;
            case WM_HSCROLL:
            case WM_VSCROLL:
                break;
            case WM_COMMAND:
                break;
            case WM_SIZE:
                handle_config(ws, msg, wp, lp);
                break;
            case WM_MOVE:
                /* x,y represents the position of the drawable area. Casting to
                   short ensures -ve values are handle correctly */
                ws->x = (short)LOWORD(lp);
                ws->y = (short)HIWORD(lp); 
                break;
            case WM_ACTIVATE:
                break;
            case WM_GETMINMAXINFO: {
                MINMAXINFO *mmi = (MINMAXINFO *)lp;
                if (!ws->resizable) {
                    mmi->ptMinTrackSize.x = mmi->ptMaxTrackSize.x =
                        ws->width + BORDWIDTH;
                    mmi->ptMinTrackSize.y = mmi->ptMaxTrackSize.y =
                        ws->height + BORDHEIGHT;
                }
                return 0;
            }
            case WM_KILLFOCUS:
                break;
            case WM_SETFOCUS:
                break;
            case WM_CLOSE: {
                qeventcode(ws, WINDOWCLOSED);
                return 0;
            }
            case WM_DESTROY:
                break;
        }

    return DefWindowProc(hwnd, msg, wp, lp);
}

void pollevent(wbp w)
{
    MSG m;
    /* some while PeekMessage loops here, maybe one per window ? */
    while (PeekMessage(&m, NULL, 0, 0, PM_NOREMOVE)) {
        if (GetMessage(&m, NULL, 0, 0) <= 0)
            return;
        TranslateMessage(&m);
        DispatchMessage(&m);
    }
}

int ownselection(wbp w, char *selname)
{
    return Succeeded;
}

int requestselection(wbp w, char *selname, char *targetname)
{
    return Succeeded;
}

int sendselectionresponse(wbp w, word requestor, char *property, char *target, char *selection, word time, dptr data)
{
    return Succeeded;
}

static void close_screen_win(wsp ws)
{
    if (ws->win) {
        DestroyWindow(ws->win);
        ws->win = 0;
        ws->state = HiddenCanvas;
        GUnlink4(ws, vwstates, vnext, vprevious);
    }
}

static wsp wsp_for_hwnd(HWND hwnd)
{
    wsp ws;
    for (ws = vwstates; ws; ws = ws->vnext) {
        if (ws->win == hwnd) 
            return ws;
    }
    return 0;
}

static void open_screen_win(wsp ws)
{
    switch (ws->state) {
        case PopupCanvas: {
            ws->win = CreateWindowEx(WS_EX_TOPMOST | WS_EX_TOOLWINDOW,
                                     "oix", 
                                     NULL,
                                     WS_CHILD,
                                     ws->x, 
                                     ws->y,
                                     ws->width,
                                     ws->height,
                                     GetDesktopWindow(),
                                     NULL, NULL, NULL); 
            SetWindowPos(ws->win, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
            break;
        } 
        default: {
            HWND parent;
            if (ws->transientfor)
                parent = ws->transientfor->win;
            else
                parent = NULL;
            ws->win = CreateWindowEx(0,
                                     "oix", 
                                     NULL,
                                     WS_OVERLAPPEDWINDOW,
                                     ws->x, 
                                     ws->y,
                                     ws->width + BORDWIDTH,
                                     ws->height + BORDHEIGHT,
                                     parent,
                                     NULL, NULL, NULL);
            apply_windowlabel(ws);
        }
    }
    GLink4(ws, vwstates, vnext, vprevious);
}

int setcanvas(wbp w, char *s)
{
    wsp ws = w->window;
    HWND stdwin = ws->win;
    stringint *e;

    e = stringint_lookup(canvastypes, s);
    if (!e)
        return Failed;

    if (e->i == ws->state)
        return Succeeded;

    /*
     * If we're presently hidden, just open the visible window.
     */
    if (!ws->win) {
        if (e->i != HiddenCanvas) {
            ws->state = e->i;
            open_screen_win(ws);
            pix_to_win(ws);
            ShowWindow(ws->win, SW_RESTORE);
        }
        return Succeeded;
    }

    /*
     * More complex cases, with the window already unhidden.
     */
    switch (e->i) {
        case HiddenCanvas: {
            close_screen_win(ws);
            break;
        }

        case IconicCanvas: {
            if (ws->state == PopupCanvas)
                return Failed;
            ShowWindow(ws->win, SW_MINIMIZE);
            break;
        }

        case NormalCanvas: {
            if (ws->state == PopupCanvas)
                return Failed;
            ShowWindow(ws->win, SW_RESTORE);
            break;
        }

        case PopupCanvas:
            return Failed;
    }
    return Succeeded;
}

int setwindowlabel(wbp w, dptr val)
{
    wsp ws = w->window;
    ws->windowlabel = *val;
    if (ws->win)
        apply_windowlabel(ws);
    return Succeeded;
}

static HFONT findfont(char *family, double size, int flags, int ansi)
{
    int charset, weight, nHeight;
    char slant, spacing;

    if (size < 0)
        size = defaultfontsize;

    if (flags & FONTFLAG_MEDIUM)
        weight = FW_MEDIUM;
    else if ((flags & FONTFLAG_DEMI) && (flags & FONTFLAG_BOLD))
        weight = FW_DEMIBOLD;
    else if (flags & FONTFLAG_BOLD)
        weight = FW_BOLD;
    else if (flags & FONTFLAG_DEMI)
        weight = FW_SEMIBOLD;
    else if (flags & FONTFLAG_LIGHT)
        weight = FW_LIGHT;
    else
        weight = FW_DONTCARE;

    if (flags & FONTFLAG_ITALIC)
        slant = 1;
    else
        slant = 0;

    charset = (ansi && (MAXBYTESPERCHAR==1)) ? ANSI_CHARSET:DEFAULT_CHARSET;

    if (flags & FONTFLAG_PROPORTIONAL)
        spacing = VARIABLE_PITCH;
    else if (flags & FONTFLAG_MONO)
        spacing = FIXED_PITCH;
    else spacing = DEFAULT_PITCH;
    /* Convert from point size to device units - see msdn manual page */
    nHeight = -MulDiv(size, GetDeviceCaps(dummy_hdc, LOGPIXELSY), 72);
    return CreateFont(nHeight, 0, 0, 0, weight, slant, 0, 0, charset,
                      OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                      spacing, family);
}

static HFONT mkfont(char *s)
{
    int flags;
    double size;
    char family[MAXFONTWORD];
    char *stdfam = NULL;
    HFONT hf = 0;

    if (parsefont(s, family, &flags, &size)) {
        /*
         * This is a legal Icon font spec.
         * Check first for special "standard" family names.
         */
        if (!strcmp(family, "mono") || !strcmp(family, "fixed")) {
            stdfam = "Lucida Sans"; /* Lucida Console? */
            flags |= FONTFLAG_MONO + FONTFLAG_SANS;
        }
        else if (!strcmp(family, "typewriter")) {
            stdfam = "Courier New"; /* was "courier" */
            flags |= FONTFLAG_MONO + FONTFLAG_SERIF;
        }
        else if (!strcmp(family, "sans")) {
            stdfam = "Arial"; /* was "swiss" */
            flags |= FONTFLAG_PROPORTIONAL + FONTFLAG_SANS;
        }
        else if (!strcmp(family, "serif")) {
            stdfam = "Times New Roman";
            flags |= FONTFLAG_PROPORTIONAL + FONTFLAG_SERIF;
        }
        else stdfam = NULL;
   
        if (stdfam) {
            /*
             * Standard name: first try preferred family, then generalize.
             * ICONFONT can be NULL, in which case Windows chooses.
             */
            hf = findfont(stdfam, size, flags, 1);
            if (hf == NULL)
                hf = findfont(getenv("ICONFONT"), size, flags, 1);
        }
        else {
            /*
             * Any other name: must match as specified.
             */
            hf = findfont(family, size, flags, 0);
        }
    }
    return hf;
}

/*
 * Set the window's font by name.
 */
int setfont(wbp w, char *s)
{
    wfp f = load_font(s);
    if (!f)
        return Failed;
    w->context->font = f;
    return Succeeded;
}

int lowerwindow(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    SetWindowPos(ws->win, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
    return Succeeded;
}

int raisewindow(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    SetWindowPos(ws->win, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
    return Succeeded;
}

/*
 * convert an Icon linear color into an MS Windows color value
 */
static COLORREF mscolor(int r, int g, int b)
{
    return RGB(r >> 8, g >> 8, b >> 8);
}

int setlinestyle(wbp w, char *val)
{
    stringint *e;
    wcp wc = w->context;
    e = stringint_lookup(linestyles, val);
    if (!e)
        return Failed;
    wc->linestyle = e;
    return Succeeded;
}

int setlinewidth(wbp w, double linewid)
{
    wcp wc = w->context;
    wc->linewidth = linewid;
    return Succeeded;
}

double getlinewidth(wbp w)
{
    return w->context->linewidth;
}

int getdepth(wbp w, int *res)
{
    int i, j;
    STDLOCALS(w);
    i = GetDeviceCaps(pixdc, BITSPIXEL);
    j = GetDeviceCaps(pixdc, PLANES);
    FREE_STDLOCALS(w);
    *res = i * j;
    return Succeeded;
}

static int devicecaps(wbp w, int i)
{
    int rv;
    STDLOCALS(w);
    rv = GetDeviceCaps(pixdc, i);
    FREE_STDLOCALS(w);
    return rv;
}

/*
 * Set the context's foreground color
 */
int setfg(wbp w, char *val)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(val, &r, &g, &b, &a))
        return Failed;
    unlink_sharedcolor(wc->fg);
    wc->fg = new_sharedcolor(val, mscolor(r, g, b), a);
    return Succeeded;
}

char *getfg(wbp w)
{
    return w->context->fg->name;
}

/*
 * Set the window context's background color
 */
int setbg(wbp w, char *val)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(val, &r, &g, &b, &a))
        return Failed;
    unlink_sharedcolor(wc->bg);
    wc->bg = new_sharedcolor(val, mscolor(r, g, b), a);
    return Succeeded;
}

char *getbg(wbp w)
{
    return w->context->bg->name;
}

int setpointer(wbp w, char *val)
{
    struct wcursor *c;
    wsp ws = w->window;
    c = lookup_wcursor(val);
    if (!c)
        return Failed;
    ws->cursor = c;
    return Succeeded;
}

int setdrawop(wbp w, char *val)
{
    wcp wc = w->context;
    stringint *e = stringint_lookup(drawops, val);
    if (!e)
        return Failed;
    wc->drawop = e;
    return Succeeded;
}

int getpos(wbp w)
{
    return Succeeded;
}

int getpattern(wbp w, struct imgdata *imd)
{
    wcp wc = w->context;
    if (!wc->pattern)
        return Failed;
    bitmap_to_imgdata(wc->pattern->bitmap, imd);
    return Succeeded;
}

char *getlinestyle(wbp w)
{
    return w->context->linestyle->s;
}

char *getpointer(wbp w)
{
    return w->window->cursor->name;
}

char *getdisplay(wbp w)
{
    return "MS Windows";
}

char *getdrawop(wbp w)
{
    return w->context->drawop->s;
}

char *getcanvas(wbp w)
{
    char *v = stringint_int2str(canvastypes, w->window->state);
    if (!v)
        syserr("Invalid value of state");
    return v;
}

/*
 * erase an area
 */
void erasearea(wbp w, int x, int y, int width, int height)
{
    HBRUSH hb, oldbrush, oldbrush2;
    RECT rect;
    STDLOCALS(w);

    hb = get_bg_brush(wc);
    if (stdwin) oldbrush = SelectObject(stddc, hb);
    oldbrush2 = SelectObject(pixdc, hb);
    rect.left = x; rect.right = x + width;
    rect.top = y; rect.bottom = y + height;

    if (stdwin) FillRect(stddc, &rect, hb);
    FillRect(pixdc, &rect, hb);
    if (stdwin) SelectObject(stddc, oldbrush);
    SelectObject(pixdc, oldbrush2);
    DeleteObject(hb);
    FREE_STDLOCALS(w);
}

/*
 * copy an area
 */
int copyarea(wbp w, int x, int y, int width, int height, wbp w2, int x2, int y2)
{
    int lpad, rpad, tpad, bpad;
    RECT r;
    HDC srcpixdc;
    HBRUSH hb;
    wsp ws1 = w->window;
    HBITMAP oldpix;
    STDLOCALS(w2);

    /*
     * setup device contexts for area copy
     */
    SetROP2(pixdc, R2_COPYPEN);
    hb = get_bg_brush(wc);
    if (stdwin)
        SetROP2(stddc, R2_COPYPEN);
    if (w2->window == w->window) {
        srcpixdc = pixdc;
    }
    else {
        srcpixdc = CreateCompatibleDC(dummy_hdc);
        SetROP2(srcpixdc, R2_COPYPEN);
    }
    oldpix = SelectObject(srcpixdc, w->window->pix);

    /*
     * copy area, write unavailable areas with bg color
     */
    if (x + width < 0 || y + height < 0 || x >= ws1->pixwidth || y >= ws1->pixheight) {
        /* source is entirely offscreen, just fill with background */
        r.left = x2; r.top = y2;
        r.right = x2 + width; r.bottom = y2 + height;
        if (stdwin)
            FillRect(stddc, &r, hb);
        FillRect(pixdc, &r, hb);
    }
    else {
        /*
         * Check for source partially offscreen, but copy first and
         * fill later in case the source and destination overlap.
         */
        lpad = rpad = tpad = bpad = 0;
        if (x < 0) {			/* source extends past left edge */
	    lpad = -x;
            width -= lpad;
            x2 += lpad;
            x = 0;
        }
        if (x + width > ws1->pixwidth) {  /* source extends past right edge */
            rpad = x + width - ws1->pixwidth;
            width -= rpad;
        }
        if (y < 0) {			/* source extends above top edge */
	    tpad = -y;
            height -= tpad;
            y2 += tpad;
            y = 0;
        }
        if (y + height > ws1->pixheight) {  /* source extends below bottom */
            bpad = y + height - ws1->pixheight;
            height -= bpad;
        }
        if (stdwin)
            BitBlt(stddc, x2, y2, width, height, srcpixdc, x, y, SRCCOPY);
        BitBlt(pixdc, x2, y2, width, height, srcpixdc, x, y, SRCCOPY);

        if (lpad > 0) {
            r.left = x2-lpad;
	    r.top = y2-tpad;
	    r.right = r.left + lpad;
	    r.bottom = r.top + tpad+height+bpad;
            if (stdwin)
                FillRect(stddc, &r, hb);
            FillRect(pixdc, &r, hb);
        }
        if (rpad > 0) {
            r.left = x2+width;
	    r.top = y2-tpad;
	    r.right = r.left + rpad;
	    r.bottom = r.top + tpad+height+bpad;
            if (stdwin)
                FillRect(stddc, &r, hb);
            FillRect(pixdc, &r, hb);
        }
        if (tpad > 0) {
	    r.left = x2;
	    r.top = y2-tpad;
	    r.right = r.left + width;
	    r.bottom = r.top + tpad;
            if (stdwin)
                FillRect(stddc, &r, hb);
            FillRect(pixdc, &r, hb);
        }
        if (bpad > 0) {
	    r.left = x2;
	    r.top = y2+height;
	    r.right = r.left + width;
	    r.bottom = r.top + bpad;
            if (stdwin)
                FillRect(stddc, &r, hb);
            FillRect(pixdc, &r, hb);
        }
    }

    /*
     * free resources
     */
    SelectObject(srcpixdc, oldpix);
    if (w2->window != w->window) {
        DeleteDC(srcpixdc);
    }
    DeleteObject(hb);
    FREE_STDLOCALS(w2);
    return Succeeded;
}

void captureimgdata(wbp w, int x, int y, struct imgdata *imd)
{
    wsp ws = w->window;
    int i, j;
    COLORREF *p;
    HDC pixdc = CreateCompatibleDC(dummy_hdc);
    HBITMAP oldpix;
    oldpix = SelectObject(pixdc, ws->pix);
    MemProtect(imd->data = malloc(imd->width * imd->height * sizeof(COLORREF)));
    p = (COLORREF *)imd->data;
    for(i = y; i < y + imd->height; i++)
        for(j = x; j < x + imd->width; j++)
            *p++ = GetPixel(pixdc, j, i);
    imd->format = &imgdataformat_MSBGRX32;
    SelectObject(pixdc, oldpix);
    DeleteDC(pixdc);
}

static void pix_to_win(wsp ws)
{
    HDC windc = GetDC(ws->win);
    HDC pixdc = CreateCompatibleDC(dummy_hdc);
    HBITMAP oldpix;
    oldpix = SelectObject(pixdc, ws->pix);
    BitBlt(windc, 0, 0, ws->width, ws->height, 
           pixdc, 0, 0, SRCCOPY);
    ReleaseDC(ws->win, windc);
    SelectObject(pixdc, oldpix);
    DeleteDC(pixdc);
}

void drawimgdata(wbp w, int x, int y, struct imgdata *imd)
{
    int i, j;
    STDLOCALS(w);
    for(j = 0; j < imd->height; j++) {
        for(i = 0; i < imd->width; i++) {
            int r, g, b, a;
            imd->format->getpixel(imd, i, j, &r, &g, &b, &a);
            if (a == 0xffff)
                SetPixel(pixdc, i + x, j + y, mscolor(r, g, b));
        }
    }
    /*
     * Copy it from the pixmap onto the screen.
     */
    if (stdwin){
        BitBlt(stddc, x, y, imd->width, imd->height, 
               pixdc, x, y, SRCCOPY);
    }

    FREE_STDLOCALS(w);
}

struct imgdataformat *getimgdataformat(wbp w)
{
    return &imgdataformat_MSBGRX32;
}

int getdisplaysize(wbp w, int *width, int *height)
{
    *width = devicecaps(w, HORZRES);
    *height = devicecaps(w, VERTRES);
    return Succeeded;
}

int querypointer(wbp w, int *x, int *y)
{
    wsp ws = w->window;
    RECT r;
    POINT pp;
    CheckUnhidden(ws);
    GetCursorPos(&pp);
    GetWindowRect(ws->win, &r);
    pp.x -= r.left + CLIENT_XOFF;
    pp.y -= r.top + CLIENT_YOFF;
    *x = pp.x;
    *y = pp.y;
    return Succeeded;
}

int queryrootpointer(wbp w, int *x, int *y)
{
    POINT pp;
    GetCursorPos(&pp);
    *x = pp.x;
    *y = pp.y;
    return Succeeded;
}

void drawarc(wbp wb, double cx, double cy, double rx, double ry, double angle1, double angle2)
{
    int x1, y1, x2, y2, right, bottom;
    double a1_a2;
    HPEN hp, oldpen, oldpen2;
    STDLOCALS(wb);
    hp = get_fg_pen(wc);
    if (stdwin) oldpen = SelectObject(stddc, hp);
    oldpen2 = SelectObject(pixdc, hp);
    angle1 = -angle1 - angle2;
    a1_a2 = angle1 + angle2;
    x1 = cx + rx * cos(angle1);
    y1 = cy - ry * sin(angle1);
    x2 = cx + rx * cos(a1_a2);
    y2 = cy - ry * sin(a1_a2);
    right = cx + rx + 1;
    bottom = cy + ry + 1;
    if (ws->win)
        Arc(stddc, cx - rx, cy - ry, right, bottom, x1, y1, x2, y2);
    Arc(pixdc, cx - rx, cy - ry, right, bottom, x1, y1, x2, y2);
    if (stdwin) SelectObject(stddc, oldpen);
    SelectObject(pixdc, oldpen2);
    DeleteObject(hp);
    FREE_STDLOCALS(wb);
}

void drawlines(wbp w, struct point *points, int npoints)
{
    HPEN hp, oldpen, oldpen2;
    POINT *p2;
    STDLOCALS(w);
    p2 = convert_points(points, npoints);
    hp = get_fg_pen(wc);
    if (stdwin) {
        oldpen = SelectObject(stddc, hp);
        Polyline(stddc, p2, npoints);
        SelectObject(stddc, oldpen);
    }
    oldpen2 = SelectObject(pixdc, hp);
    Polyline(pixdc, p2, npoints);
    SelectObject(pixdc, oldpen2);
    DeleteObject(hp);
    FREE_STDLOCALS(w);
    free(p2);
}

void drawpoint(wbp wb, int x, int y)
{
    COLORREF palfg;
    STDLOCALS(wb);
    palfg = PALCLR(wc->fg->color);
    if (stdwin)
        SetPixel(stddc, x, y, palfg);
    SetPixel(pixdc, x, y, palfg);
    FREE_STDLOCALS(wb);
}

void drawstring(wbp wb, int x, int y, dptr str)
{
    HFONT oldfont;
    STDLOCALS(wb);
    if (is:string(*str)) {
        if (stdwin) {
            oldfont = SelectObject(stddc, wc->font->font);
            SetBkMode(stddc, TRANSPARENT);
            SetTextColor(stddc, PALCLR(wc->fg->color));
            SetBkColor(stddc, PALCLR(wc->bg->color));
            TextOutA(stddc, x, y - wc->font->ascent, StrLoc(*str), StrLen(*str));
            SelectObject(stddc, oldfont);
        }
        oldfont = SelectObject(pixdc,wc->font->font);
        SetBkMode(pixdc, TRANSPARENT);
        SetTextColor(pixdc, PALCLR(wc->fg->color));
        SetBkColor(pixdc, PALCLR(wc->bg->color));
        TextOutA(pixdc, x, y - wc->font->ascent, StrLoc(*str), StrLen(*str));
        SelectObject(pixdc, oldfont);
    } else {
        WCHAR *mbs = ucs_to_wchars(str, 0);
        if (stdwin) {
            oldfont = SelectObject(stddc, wc->font->font);
            SetBkMode(stddc, TRANSPARENT);
            SetTextColor(stddc, PALCLR(wc->fg->color));
            SetBkColor(stddc, PALCLR(wc->bg->color));
            TextOutW(stddc, x, y - wc->font->ascent, mbs, UcsBlk(*str).length);
            SelectObject(stddc, oldfont);
        }
        oldfont = SelectObject(pixdc,wc->font->font);
        SetBkMode(pixdc, TRANSPARENT);
        SetTextColor(pixdc, PALCLR(wc->fg->color));
        SetBkColor(pixdc, PALCLR(wc->bg->color));
        TextOutW(pixdc, x, y - wc->font->ascent, mbs, UcsBlk(*str).length);
        SelectObject(pixdc, oldfont);
        free(mbs);
    }
    FREE_STDLOCALS(wb);
}

void fillarc(wbp wb, double cx, double cy, double rx, double ry, double angle1, double angle2)
{
    HBRUSH hb, oldbrush, oldbrush2;
    POINT pts[3];
    HPEN hp, oldpen, oldpen2;
    STDLOCALS(wb);
    hp = GetStockObject(NULL_PEN);
    if (stdwin) oldpen = SelectObject(stddc, hp);
    oldpen2 = SelectObject(pixdc, hp);
    hb = get_fg_brush(wc);
    if (stdwin) oldbrush = SelectObject(stddc, hb);
    oldbrush2 = SelectObject(pixdc, hb);
 
    angle1 = -angle1 - angle2;
    pts[0].x = cx;
    pts[0].y = cy;
    pts[1].x = cx + rx * cos(angle1);
    pts[1].y = cy - ry * sin(angle1);
    pts[2].x = cx + rx * cos(angle1+angle2);
    pts[2].y = cy - ry * sin(angle1+angle2);
    if (stdwin) {
        Pie(stddc, cx - rx, cy - ry,
            cx + rx + 1, cy + ry + 1,
            pts[1].x, pts[1].y, pts[2].x, pts[2].y);
    }
    Pie(pixdc, cx - rx, cy - ry,
        cx + rx + 1, cy + ry + 1,
        pts[1].x, pts[1].y, pts[2].x, pts[2].y);

    if (stdwin) SelectObject(stddc, oldpen);
    SelectObject(pixdc, oldpen2);
    DeleteObject(hp);
    if (stdwin) SelectObject(stddc, oldbrush);
    SelectObject(pixdc, oldbrush2);
    DeleteObject(hb);
    FREE_STDLOCALS(wb);
}

static HBRUSH get_fg_brush(wcp wc)
{
    if (wc->pattern)
        return CreatePatternBrush(wc->pattern->bitmap);
    else
        return CreateSolidBrush(wc->fg->color);
}

static HPEN get_fg_pen(wcp wc)
{
    LOGBRUSH lb;
    if (wc->pattern) {
        lb.lbStyle = BS_PATTERN;
        lb.lbColor = (COLORREF)0;
        lb.lbHatch = (ULONG_PTR)wc->pattern->bitmap;
    } else {    
        lb.lbStyle = BS_SOLID;
        lb.lbColor = wc->fg->color;
        lb.lbHatch = (ULONG_PTR)0;
    }
    return ExtCreatePen(PS_GEOMETRIC | wc->linestyle->i, wc->linewidth, &lb, 0, 0);
}

static HBRUSH get_bg_brush(wcp wc)
{
    return CreateSolidBrush(wc->bg->color);
}

static void rectanglehelper(wcp wc, HDC stddc, HDC pixdc, int x, int y, int width, int height)
{
    HBRUSH hb;
    hb = get_fg_brush(wc);
    if (wc->fg->alpha < 255) {
        HBITMAP bm, oldbm;
        BLENDFUNCTION bf;
        HDC bm_hdc;
        RECT r;
        bm = CreateCompatibleBitmap(dummy_hdc, width, height);
        bm_hdc = CreateCompatibleDC(dummy_hdc);
        oldbm = SelectObject(bm_hdc, bm);
        r.left = 0;
        r.top = 0;
        r.right = width;
        r.bottom = height;
        FillRect(bm_hdc, &r, hb);
        bf.BlendOp = AC_SRC_OVER;
        bf.BlendFlags = 0;
        bf.SourceConstantAlpha = wc->fg->alpha;
        bf.AlphaFormat = 0;
        AlphaBlend(pixdc, x, y, width, height, bm_hdc, 0, 0, width, height, bf);
        if (stddc)
            AlphaBlend(stddc, x, y, width, height, bm_hdc, 0, 0, width, height, bf);
        SelectObject(bm_hdc, oldbm);
        DeleteDC(bm_hdc);
        DeleteObject(bm);
    } else {
        RECT r;
        r.left = x;
        r.top = y;
        r.right = x + width;
        r.bottom = y + height;
        if (stddc) FillRect(stddc, &r, hb);
        FillRect(pixdc, &r, hb);
    }
    DeleteObject(hb);
}

void fillrectangle(wbp wb, int x, int y, int width, int height)
{
    STDLOCALS(wb);
    rectanglehelper(wc, stddc, pixdc, x, y, width, height);
    FREE_STDLOCALS(wb);
}

void drawrectangle(wbp wb, int x, int y, int width, int height, int thick)
{
    STDLOCALS(wb);
    /* If too small to give a gap in the middle, then simply fill a
     * rectangle, otherwise draw as four lines. */
    if (width <= 2 * thick || height <= 2 * thick)
        rectanglehelper(wc, stddc, pixdc, x, y, width, height);
    else {
        rectanglehelper(wc, stddc, pixdc, x, y, width, thick);
        rectanglehelper(wc, stddc, pixdc,
                        x, y +  thick,
                        thick, height - 2 * thick);
        rectanglehelper(wc, stddc, pixdc,
                        x + width - thick, y + thick,
                        thick, height - 2 * thick);
        rectanglehelper(wc, stddc, pixdc,
                        x, y + height - thick,
                        width, thick);
    }
    FREE_STDLOCALS(wb);
}

void fillpolygon(wbp w, struct point *points, int npts)
{
    HBRUSH hb, oldbrush;
    HPEN hp, oldpen, oldpen2;
    POINT *pts;
    STDLOCALS(w);
    pts = convert_points(points, npts);
    hp = GetStockObject(NULL_PEN);
    if (stdwin) oldpen = SelectObject(stddc, hp);
    oldpen2 = SelectObject(pixdc, hp);
    hb = get_fg_brush(wc);
    if (stdwin) {
        oldbrush = SelectObject(stddc, hb);
        Polygon(stddc, pts, npts);
        SelectObject(stddc, oldbrush);
    }
    oldbrush = SelectObject(pixdc, hb);
    Polygon(pixdc, pts, npts);
    SelectObject(pixdc, oldbrush);
    DeleteObject(hb);
    if (stdwin) SelectObject(stddc, oldpen);
    SelectObject(pixdc, oldpen2);
    DeleteObject(hp);
    FREE_STDLOCALS(w);
    free(pts);
}

static wcp alccontext(wbp w)
{
    wcp wc;
    GAlloc(wc, _wcontext);
    wc->fg = link_sharedcolor(black);
    wc->bg = link_sharedcolor(white);
    wc->drawop = stringint_lookup(drawops, "copy");
    wc->linestyle = stringint_lookup(linestyles, "solid");
    wc->linewidth = 1;
    wc->font = default_font;
    wc->leading = defaultleading;
    wc->clipx = wc->clipy = 0;
    wc->clipw = wc->cliph = -1;
    return wc;
}

/*
 * allocate a context, cloning attributes from an existing context
 */
static wcp clonecontext(wcp src)
{
    wcp wc;

    GAlloc(wc, _wcontext);

    wc->clipx = src->clipx;
    wc->clipy = src->clipy;
    wc->clipw = src->clipw;
    wc->cliph = src->cliph;
    wc->dx = src->dx;
    wc->dy = src->dy;
    wc->fg = link_sharedcolor(src->fg);
    wc->bg = link_sharedcolor(src->bg);
    if (src->pattern)
        wc->pattern = link_sharedbitmap(src->pattern);
    wc->drawop = src->drawop;
    wc->linewidth = src->linewidth;
    wc->linestyle = src->linestyle;
    wc->font = src->font;
    return wc;
}

/*
 * free a window state
 */
static void freewindow(wsp ws)
{
    ws->refcount--;
    if(ws->refcount == 0) {
        close_screen_win(ws);
        DeleteObject(ws->pix);
        del_gc_global(&ws->listp);
        del_gc_global(&ws->windowlabel);
        if (ws->transientfor)
            freewindow(ws->transientfor);
        free(ws);
    }
}

/*
 * free a window context
 */
static void freecontext(wcp wc)
{
    wc->refcount--;
    if(wc->refcount == 0) {
        if (wc->pattern)
            unlink_sharedbitmap(wc->pattern);
        unlink_sharedcolor(wc->fg);
        unlink_sharedcolor(wc->bg);
        free(wc);
    }
}

int walert(wbp w, int volume)
{
    MessageBeep(0);
    return Succeeded;
}

int setpattern(wbp w, struct imgdata *imd)
{
    wcp wc = w->context;
    if (wc->pattern)
        unlink_sharedbitmap(wc->pattern);
    if (imd)
        wc->pattern = new_sharedbitmap(imd);
    else
        wc->pattern = 0;
    return Succeeded;
}

void doconfig(wbp w, int status)
{
    wsp ws = w->window;
    wcp wc = w->context;
    if (status & (C_POS | C_SIZE | C_MINSIZE | C_MAXSIZE | C_RESIZE)) {
        if (ws->win) {
            pollevent(w);
            switch (status & (C_POS|C_SIZE)) {
                case C_POS|C_SIZE: {
                    SetWindowPos(ws->win, ws->win, ws->x, ws->y,
                                 ws->width + BORDWIDTH, ws->height + BORDHEIGHT,
                                 SWP_NOZORDER|SWP_NOACTIVATE);
                    break;
                }
                case C_SIZE: {
                    SetWindowPos(ws->win, ws->win, 0, 0,
                                 ws->width + BORDWIDTH, ws->height + BORDHEIGHT,
                                 SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
                    break;
                }
                case C_POS: {
                    SetWindowPos(ws->win, ws->win,
                                 ws->x,
                                 ws->y,
                                 0, 0, SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
                    break;
                }
            }
        }
    }
    if (status & C_SIZE)
        resizepixmap(w);
}

int grabpointer(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    capture_mouse(ws);
    return Succeeded;
}

int ungrabpointer(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    uncapture_mouse(ws);
    return Succeeded;
}

static void resizepixmap(wbp w)
{
    HDC hdc2, hdc3;
    HBITMAP newpix, oldpix, oldpix2;
    HBRUSH hb;
    RECT rect;
    wsp ws = w->window;
    wcp wc = w->context;
    if (ws->pixwidth == ws->width && ws->pixheight == ws->height)
        return;
    ws->pixwidth = ws->width;
    ws->pixheight = ws->height;

    newpix = CreateCompatibleBitmap(dummy_hdc, ws->pixwidth, ws->pixheight);
    if (ws->pix) {
        hdc2 = CreateCompatibleDC(dummy_hdc);
        oldpix = SelectObject(hdc2, ws->pix);
    }
    hdc3 = CreateCompatibleDC(dummy_hdc);
    oldpix2 = SelectObject(hdc3, newpix);
    hb = get_bg_brush(wc);
    /*
     * initialize the new pixmap, including areas not in the old pixmap.
     */
    rect.left = 0; rect.right = ws->pixwidth;
    rect.top = 0; rect.bottom = ws->pixheight;
    FillRect(hdc3, &rect, hb);
    BitBlt(hdc3, 0, 0, ws->pixwidth, ws->pixheight, hdc2, 0, 0, SRCCOPY);
    if (ws->win) {
        HDC hdc = GetDC(ws->win);
        FillRect(hdc, &rect, hb);
        BitBlt(hdc, 0, 0, ws->pixwidth, ws->pixheight, hdc2, 0, 0, SRCCOPY);
        ReleaseDC(ws->win, hdc);
    }

    SelectObject(hdc3, oldpix2);
    DeleteDC(hdc3);
    if (ws->pix) {
        SelectObject(hdc2, oldpix);
        DeleteDC(hdc2);
    }
    if (ws->pix) DeleteObject(ws->pix);
    DeleteObject(hb);
    ws->pix = newpix;
}

/*
 * get_win_dc - create a device context for drawing on the window
 *  In addition, select objects specified by flags.
 */
static HDC get_win_dc(wbp w)
{
    wsp ws = w->window;
    wcp wc = w->context;
    HDC hdc;
    if (!ws->win)
        return 0;
    hdc = GetDC(ws->win);
    SetROP2(hdc, wc->drawop->i);
    if (wc->clipw >= 0) {
        HRGN r = CreateRectRgn(wc->clipx, wc->clipy,
                               wc->clipx + wc->clipw,
                               wc->clipy + wc->cliph);
        SelectClipRgn(hdc, r);
        DeleteObject(r);
    }
    return hdc;
}

static HDC get_pix_dc(wbp w)
{
    wsp ws = w->window;
    wcp wc = w->context;
    HDC hdc = CreateCompatibleDC(dummy_hdc);
    ws->savedpix = SelectObject(hdc, ws->pix);
    SetROP2(hdc, wc->drawop->i);
    if (wc->clipw >= 0){
        HRGN r = CreateRectRgn(wc->clipx, wc->clipy,
                               wc->clipx + wc->clipw,
                               wc->clipy + wc->cliph);
        SelectClipRgn(hdc, r);
        DeleteObject(r);
    }
    return hdc;
}

static int font_maxcharwidth(HFONT f)
{
    int i, m = -1, x;
    char s[2];
    HFONT oldfont = SelectObject(dummy_hdc, f);
    s[1] = '\0';
    for (i = 0; i < 256; i++) {
        SIZE sz;
        int x;
        s[0] = i;
        GetTextExtentPoint(dummy_hdc, s, 1, &sz);
        x = (int)sz.cx;
        if (x > m)
            m = x;
    }
    SelectObject(dummy_hdc, oldfont);
    return m;
}

static WCHAR *ucs_to_wchars(dptr str, int nullterm)
{
    WCHAR *mbs;
    MemProtect(mbs = malloc((UcsBlk(*str).length + nullterm) * sizeof(WCHAR)));
    MultiByteToWideChar(CP_UTF8,
                        MB_ERR_INVALID_CHARS,
                        StrLoc(UcsBlk(*str).utf8),
                        StrLen(UcsBlk(*str).utf8),
                        mbs,
                        UcsBlk(*str).length);
    if (nullterm)
        mbs[UcsBlk(*str).length] = 0;
    return mbs;
}

int textwidth(wbp w, dptr str)
{
    int rv;
    SIZE sz;
    HFONT oldfont = SelectObject(dummy_hdc, w->context->font->font);
    if (is:string(*str))
        GetTextExtentPointA(dummy_hdc, StrLoc(*str), StrLen(*str), &sz);
    else {
        WCHAR *mbs = ucs_to_wchars(str, 0);
        GetTextExtentPointW(dummy_hdc, mbs, UcsBlk(*str).length, &sz);
        free(mbs);
    }
    SelectObject(dummy_hdc, oldfont);
    return (int)sz.cx;
}

int warppointer(wbp w, int x, int y)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    SetCursorPos(ws->x + x, ws->y + y);
    return Succeeded;
}

int readimagefileimpl(char *filename, struct imgdata *imd) 
{
    return NoCvt;
}

int writeimagefileimpl(char *filename, struct imgdata *imd)
{
    return NoCvt;
}

int readimagedataimpl(dptr data, struct imgdata *imd)
{
    return NoCvt;
}

int settransientfor(wbp w, wbp other)
{
    wsp ws = w->window;
    if (ws->win) {
        LitWhy("Can't set transient_for on an open window");
        return Failed;
    }
    if (other) {
        if (ws->transientfor)
            freewindow(ws->transientfor);
        ws->transientfor = linkwindow(other->window);
    } else {
        if (ws->transientfor)
            freewindow(ws->transientfor);
        ws->transientfor = 0;
    }
    return Succeeded;
}

int setwindowicon(wbp w, struct imgdata *imd)
{
    return Failed;
}

int getwindowicon(wbp w, struct imgdata *imd)
{
    return Failed;
}

int grabkeyboard(wbp w)
{
    return Succeeded;
}

int ungrabkeyboard(wbp w)
{
    return Succeeded;
}

wbp clonewindow(wbp w)
{
    wbp w2;
    w2 = alcwbinding();
    w2->window = linkwindow(w->window);
    w2->context = clonecontext(w->context);
    return w2;
}

wbp couplewindows(wbp w1, wbp w2)
{
    wbp w3;
    w3 = alcwbinding();
    w3->window = linkwindow(w1->window);
    w3->context = linkcontext(w2->context);
    return w3;
}

static struct SharedColor *new_sharedcolor(char *name, COLORREF color, int a)
{
    struct SharedColor *res;
    GAlloc(res, SharedColor);
    res->name = salloc(name);
    res->color = color;
    res->alpha = a >> 8;
    return res;
}

static struct SharedColor *link_sharedcolor(struct SharedColor *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedcolor(struct SharedColor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        free(x->name);
        free(x);
    }
}

static struct SharedCursor *new_sharedcursor(HCURSOR cursor)
{
    struct SharedCursor *res;
    GAlloc(res, SharedCursor);
    res->cursor = cursor;
    return res;
}

static struct SharedCursor *link_sharedcursor(struct SharedCursor *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedcursor(struct SharedCursor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        free(x->cursor);
        free(x);
    }
}

static struct wcursor *lookup_wcursor(char *name)
{
    struct wcursor *rv;
    int i;
    i = hasher(hashcstr(name), cursors);
    for(rv = cursors[i]; rv; rv = rv->next) {
        if (!strcmp(name, rv->name))
            return rv;
    }
    return 0;
}

static struct wcursor *ensure_wcursor(char *name)
{
    struct wcursor *rv;
    int i;
    i = hasher(hashcstr(name), cursors);
    for(rv = cursors[i]; rv; rv = rv->next) {
        if (!strcmp(name, rv->name))
            return rv;
    }
    MemProtect(rv = calloc(1, sizeof(struct wcursor)));
    rv->name = salloc(name);
    rv->next = cursors[i];
    cursors[i] = rv;
    return rv;
}

static void bitmap_to_imgdata(HBITMAP bitmap, struct imgdata *imd)
{
    HBITMAP oldbitmap;
    HDC hdc;
    int i, j;
    BITMAP info;
    COLORREF *p;
    GetObject(bitmap, sizeof(info), &info);
    imd->format = &imgdataformat_MSBGRX32;
    imd->width = info.bmWidth;
    imd->height = info.bmHeight;
    MemProtect(imd->data = malloc(imd->width * imd->height * sizeof(COLORREF)));
    hdc = CreateCompatibleDC(dummy_hdc);
    oldbitmap = SelectObject(hdc, bitmap);
    p = (COLORREF *)imd->data;
    for(j = 0; j < imd->height; j++) {
        for(i = 0; i < imd->width; i++)
            *p++ = GetPixel(hdc, j, i);
    }
    SelectObject(hdc, oldbitmap);
    DeleteDC(hdc);
}

static HBITMAP imgdata_to_bitmap(struct imgdata *imd)
{
    HBITMAP oldbitmap, bitmap;
    HDC hdc;
    int i, j;
    hdc = CreateCompatibleDC(dummy_hdc);
    bitmap = CreateCompatibleBitmap(dummy_hdc, imd->width, imd->height);
    oldbitmap = SelectObject(hdc, bitmap);
    for(j = 0; j < imd->height; j++) {
        for(i = 0; i < imd->width; i++) {
            int r, g, b, a;
            imd->format->getpixel(imd, i, j, &r, &g, &b, &a);
            SetPixel(hdc, i, j, mscolor(r, g, b));
        }
    }
    SelectObject(hdc, oldbitmap);
    DeleteDC(hdc);
    return bitmap;
}

static struct SharedBitmap *new_sharedbitmap(struct imgdata *imd)
{
    struct SharedBitmap *res;
    GAlloc(res, SharedBitmap);
    res->bitmap = imgdata_to_bitmap(imd);
    return res;
}

static struct SharedBitmap *link_sharedbitmap(struct SharedBitmap *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedbitmap(struct SharedBitmap *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        DeleteObject(x->bitmap);
        free(x);
    }
}

static char *convert_spec(char *s)
{
    return s;
}

static wfp load_font(char *s)
{
    wfp rv;
    int i;
    HFONT f;
    TEXTMETRIC metrics;

    /*
     * Normalize font name.
     */
    s = convert_spec(s);
    if (!s)
        return 0;

    /*
     * See if the font is already loaded.
     */
    i = hasher(hashcstr(s), fonts);
    for(rv = fonts[i]; rv; rv = rv->next) {
        if (!strcmp(s, rv->name))
            return rv;
    }

    f = mkfont(s);
    if (!f)
        return 0;

    MemProtect(rv = calloc(1, sizeof(struct _wfont)));
    rv->name = salloc(s);
    SelectObject(dummy_hdc, f);
    GetTextMetrics(dummy_hdc, &metrics);
    rv->ascent = metrics.tmAscent;
    rv->descent = metrics.tmDescent;
    rv->maxwidth = font_maxcharwidth(f);
    rv->font = f;
    rv->next = fonts[i];
    fonts[i] = rv;
    return rv;
}

void filltrapezoids(wbp w, struct trapezoid *traps, int ntraps)
{
    HBRUSH hb, oldbrush, oldbrush2;
    HPEN hp, oldpen, oldpen2;
    int i;
    STDLOCALS(w);
    hp = GetStockObject(NULL_PEN);
    if (stdwin) oldpen = SelectObject(stddc, hp);
    oldpen2 = SelectObject(pixdc, hp);
    hb = get_fg_brush(wc);
    if (stdwin) oldbrush = SelectObject(stddc, hb);
    oldbrush2 = SelectObject(pixdc, hb);
    for (i = 0; i < ntraps; ++i) {
        POINT p[4];
        p[0].x = traps[i].x1; p[0].y = traps[i].top;
        p[1].x = traps[i].x2; p[1].y = traps[i].top;
        p[2].x = traps[i].x4; p[2].y = traps[i].bottom;
        p[3].x = traps[i].x3; p[3].y = traps[i].bottom;
        if (stdwin)
            Polygon(stddc, p, 4);
        Polygon(pixdc, p, 4);
    }
    if (stdwin) SelectObject(stddc, oldbrush);
    SelectObject(pixdc, oldbrush2);
    DeleteObject(hb);
    if (stdwin) SelectObject(stddc, oldpen);
    SelectObject(pixdc, oldpen2);
    DeleteObject(hp);
    FREE_STDLOCALS(w);
}

void filltriangles(wbp w, struct triangle *tris, int ntris)
{
    HBRUSH hb, oldbrush, oldbrush2;
    HPEN hp, oldpen, oldpen2;
    int i;
    STDLOCALS(w);
    hp = GetStockObject(NULL_PEN);
    if (stdwin) oldpen = SelectObject(stddc, hp);
    oldpen2 = SelectObject(pixdc, hp);
    hb = get_fg_brush(wc);
    if (stdwin) oldbrush = SelectObject(stddc, hb);
    oldbrush2 = SelectObject(pixdc, hb);
    for (i = 0; i < ntris; ++i) {
        POINT p[3];
        p[0].x = tris[i].p1.x; p[0].y = tris[i].p1.y;
        p[1].x = tris[i].p2.x; p[1].y = tris[i].p2.y;
        p[2].x = tris[i].p3.x; p[2].y = tris[i].p3.y;
        if (stdwin)
            Polygon(stddc, p, 3);
        Polygon(pixdc, p, 3);
    }
    if (stdwin) SelectObject(stddc, oldbrush);
    SelectObject(pixdc, oldbrush2);
    DeleteObject(hb);
    if (stdwin) SelectObject(stddc, oldpen);
    SelectObject(pixdc, oldpen2);
    DeleteObject(hp);
    FREE_STDLOCALS(w);
}

int focuswindow(wbp w)
{
    return Succeeded;
}

static void synch_cursor(wsp ws)
{
    ws->savedcursor = SetCursor(ws->cursor->shared_cursor->cursor);
}

int definepointer(wbp w, char *name, int x, int y)
{
    struct wcursor *rv;
    rv = ensure_wcursor(name);
    if (rv->shared_cursor) {
        unlink_sharedcursor(rv->shared_cursor);
        rv->shared_cursor = link_sharedcursor(null_cursor);
    } else
        rv->shared_cursor = link_sharedcursor(null_cursor);
    return Succeeded;
}

int copypointer(wbp w, char *dest, char *src)
{
    struct wcursor *sc, *dc;
    sc = lookup_wcursor(src);
    if (!sc)
        return Failed;
    dc = ensure_wcursor(dest);
    if (sc != dc) {
        if (dc->shared_cursor) {
            unlink_sharedcursor(dc->shared_cursor);
            dc->shared_cursor = link_sharedcursor(sc->shared_cursor);
        } else
            dc->shared_cursor = link_sharedcursor(sc->shared_cursor);
    }
    return Succeeded;
}

static wbp findwbp(wsp ws)
{
    wbp wb;
    for (wb = wbndngs; wb; wb = wb->next)
        if (wb->window == ws)
            return wb;
    syserr("Couldn't find wbp for wsp");
    return 0;  /* not reached */
}

static void setup_cursor(char *name, LPCTSTR cid)
{
    int i;
    struct wcursor *rv;
    i = hasher(hashcstr(name), cursors);
    MemProtect(rv = calloc(1, sizeof(struct wcursor)));
    rv->name = name;
    if (cid)
        rv->shared_cursor = new_sharedcursor(LoadCursor(NULL, cid));
    else
        rv->shared_cursor = link_sharedcursor(null_cursor);
    rv->next = cursors[i];
    cursors[i] = rv;
}

static void init_window_system(void)
{
    WNDCLASSEX wc;
    wc.cbSize =         sizeof(WNDCLASSEX); 
    wc.style =          CS_DBLCLKS;
    wc.lpfnWndProc =    WndProc;
    wc.cbClsExtra =     0;
    wc.cbWndExtra =     0;
    wc.hInstance =      GetModuleHandle(0);
    wc.hIcon =          LoadIcon(0, IDI_APPLICATION);
    wc.hCursor =        LoadCursor(0, IDC_ARROW);
    wc.hbrBackground =  GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =   0;
    wc.lpszClassName =  "oix";
    wc.hIconSm =        LoadIcon(0, IDI_APPLICATION);
    RegisterClassEx(&wc);
    BORDWIDTH = FRAMEWIDTH * 2;
    BORDHEIGHT = TITLEHEIGHT + FRAMEHEIGHT * 2;
    CLIENT_XOFF = FRAMEWIDTH;
    CLIENT_YOFF = TITLEHEIGHT + FRAMEHEIGHT;
    GetCPInfo(CP_ACP, &cpinfo);
    MAXBYTESPERCHAR = cpinfo.MaxCharSize;

    dummy_win = CreateWindow( "oix", "oix",
                              WS_OVERLAPPEDWINDOW,
                              0, 0,
                              10, 10,
                              NULL, NULL, NULL, NULL);
    dummy_hdc = GetDC(dummy_win);
    black = new_sharedcolor("black", mscolor(0,0,0), 0xffff);
    white = new_sharedcolor("white", mscolor(0xffff,0xffff,0xffff), 0xffff);
    default_font = load_font(defaultfont);
    if (!default_font)
        ffatalerr("Couldn't load default font");

    setup_cursors();
}

static void setup_cursors()
{
    null_cursor = new_sharedcursor(LoadCursor(NULL, IDC_ARROW));

    /* Windows ones */
    setup_cursor("help", IDC_HELP);
    setup_cursor("hand", IDC_HAND);
    setup_cursor("ibeam", IDC_IBEAM);
    setup_cursor("uparrow", IDC_UPARROW);
    setup_cursor("wait", IDC_WAIT);
    setup_cursor("starting", IDC_APPSTARTING);
    setup_cursor("sizeall", IDC_SIZEALL);
    setup_cursor("sizenesw", IDC_SIZENESW);
    setup_cursor("sizens", IDC_SIZENS);
    setup_cursor("sizenwse", IDC_SIZENWSE);
    setup_cursor("sizewe", IDC_SIZEWE);
    setup_cursor("no", IDC_NO);

    setup_cursor("X cursor", 0);
    setup_cursor("arrow", IDC_ARROW);
    setup_cursor("based arrow down", 0);
    setup_cursor("based arrow up", 0);
    setup_cursor("boat", 0);
    setup_cursor("bogosity", 0);
    copypointer(0, "bottom left corner", "sizenesw");
    copypointer(0, "bottom right corner", "sizenwse");
    setup_cursor("bottom side", 0);
    setup_cursor("bottom tee", 0);
    setup_cursor("box spiral", 0);
    setup_cursor("center ptr", 0);
    copypointer(0, "circle", "no");
    setup_cursor("clock", 0);
    setup_cursor("coffee mug", 0);
    setup_cursor("cross", IDC_CROSS);
    setup_cursor("cross reverse", 0);
    setup_cursor("crosshair", 0);
    setup_cursor("diamond cross", 0);
    setup_cursor("dot", 0);
    setup_cursor("dotbox", 0);
    copypointer(0, "double arrow", "sizens");
    setup_cursor("draft large", 0);
    setup_cursor("draft small", 0);
    setup_cursor("draped box", 0);
    setup_cursor("exchange", 0);
    copypointer(0, "fleur", "sizeall");
    setup_cursor("gobbler", 0);
    setup_cursor("gumby", IDC_SIZENESW);
    copypointer(0, "hand1", "hand");
    copypointer(0, "hand2", "hand");
    setup_cursor("heart", 0);
    setup_cursor("icon", 0);
    setup_cursor("iron cross", 0);
    setup_cursor("left ptr", 0);
    setup_cursor("left side", 0);
    setup_cursor("left tee", 0);
    setup_cursor("leftbutton", 0);
    setup_cursor("ll angle", 0);
    setup_cursor("lr angle", 0);
    setup_cursor("man", 0);
    setup_cursor("middlebutton", 0);
    setup_cursor("mouse", 0);
    setup_cursor("pencil", 0);
    setup_cursor("pirate", 0);
    setup_cursor("plus", 0);
    copypointer(0, "question arrow", "help");
    setup_cursor("right ptr", 0);
    setup_cursor("right side", 0);
    setup_cursor("right tee", 0);
    setup_cursor("rightbutton", 0);
    setup_cursor("rtl logo", 0);
    setup_cursor("sailboat", 0);
    setup_cursor("sb down arrow", 0);
    copypointer(0, "sb h double arrow", "sizewe");
    setup_cursor("sb left arrow", 0);
    setup_cursor("sb right arrow", 0);
    copypointer(0, "sb up arrow", "uparrow");
    copypointer(0, "sb v double arrow", "sizens");
    setup_cursor("shuttle", 0);
    setup_cursor("sizing", 0);
    setup_cursor("spider", 0);
    setup_cursor("spraycan", 0);
    setup_cursor("star", 0);
    setup_cursor("target", 0);
    setup_cursor("tcross", 0);
    setup_cursor("top left arrow", 0);
    copypointer(0, "top left corner", "sizenwse");
    copypointer(0, "top right corner", "sizenesw");
    setup_cursor("top side", 0);
    setup_cursor("top tee", 0);
    setup_cursor("trek", 0);
    setup_cursor("ul angle", 0);
    setup_cursor("umbrella", 0);
    setup_cursor("ur angle", 0);
    copypointer(0, "watch", "wait");
    copypointer(0, "xterm", "ibeam");
}

static void set_MSBGRX32(struct imgdata *imd, int x, int y, int r, int g, int b, int a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    *s++ = b / 256;
    *s++ = g / 256;
    *s++ = r / 256;
    *s++ = 0;
}

static void get_MSBGRX32(struct imgdata *imd, int x, int y, int *r, int *g, int *b, int *a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    *b = 257 * (*s++);
    *g = 257 * (*s++);
    *r = 257 * (*s++);
    *a = 65535;
}

static struct imgdataformat imgdataformat_MSBGRX32 = {set_MSBGRX32,get_MSBGRX32,0,0,getlength_32,0,24,0,"MSBGRX32"};

void registerplatformimgdataformats()
{
    registerimgdataformat(&imgdataformat_MSBGRX32);
}
