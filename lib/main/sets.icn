#
# $Id$
#

package datastruct

import ipl.pdco(Length,Index), lang, util

#
# This is a common superclass for a set-like data structure.
#
abstract class Set(HasMode, ObjectOutput, ObjectHash, ObjectEquals)
   public static const
      # An empty set instance
      EMPTY_SET,
      # Constant indicating insert capability
      INSERT,
      # Constant indicating delete capability
      DELETE,
      # Constant indicating entries are stored in order
      ORDER

   private static init()
      EMPTY_SET := EmptySet()
      INSERT := 2
      DELETE := 4
      ORDER := 8
   end

   #
   # Insert a new member.  Always succeeds and returns `self`.  Only
   # implemented with INSERT capability.
   #
   public defer insert(x)

   #
   # Succeed with `x` if it is a member of the set.
   #
   public abstract member(x)

   #
   # Delete `x` from the set.  Fails if the key was not present,
   # otherwise succeeds and returns `self`.  Only implemented with
   # DELETE capability.
   #
   public defer delete(x)

   #
   # Return a sorted list of members.
   #
   public sort()
      local l
      l := member_list()
      return if can(ORDER) then l else default.sort(member_list())
   end

   #
   # Generate the members.
   #
   public abstract gen()

   #
   # Generate the entries in reverse order.  Only implemented with
   # ORDER capability.
   #
   public defer back()

   #
   # Return the rank of the given entry, ie its order number in the
   # set; fails if there is no matching entry in the set.  Only
   # implemented for sets with ORDER capability.
   #
   public defer rank(x)

   #
   # Return the `i`th entry, in order, in the set.  Fails if `i` is
   # out of range, using standard icon indexing semantics.  Only
   # implemented for sets with ORDER capability.
   #
   public select(i)
      can(ORDER) | runerr("Set doesn't have ORDER capability: ", self)
      return Index{gen(), cvpos_item(i, size())}
   end

   #
   # Return the size of the set.
   #
   public size()
      return Length{gen()}
   end

   #
   # Succeed iff the size is zero.
   #
   public empty()
      if size() = 0 then
         return
   end

   #
   # Clear the set of all elements. Always succeeds and returns
   # `self`.  Only implemented with DELETE capability.
   #
   public clear()
      while size() > 0 do
         delete(gen())
      return self
   end

   #
   # Return a list of the members, in the order produced by `gen()`.
   #
   public member_list()
      return ipl.pdco.List{gen()}
   end

   #
   # Custom equals mirrors the `equals()` behaviour for builtin sets.
   #
   private object_equals(other, seen)
      other.size() = self.size() | fail
      return hash_and_check(other.member_list(), self.member_list(), seen)
   end

   #
   # Custom hash mirrors the `hash()` behaviour for builtin sets.
   #
   private object_hash(depth)
      local n
      n := size()
      if depth > 1 then
         every n +:= hash(gen(), depth - 1)
      return n
   end

   #
   # Output object
   #
   private object_output(oo)
      local elements, e, sep
      elements := sort()
      if oo.simple{!elements} then {
         oo.object_start(self)
         every e := !elements do {
            if \sep then
               oo.writes1(",")
            oo.traverse(e)
            sep := 1
         }
         oo.object_end(self)
      } else {
         oo.nl().
            object_start(self).
            iplus()
         every e := !elements do {
            if \sep then
               oo.writes1(",")
            oo.nl().
               traverse(e)
            sep := 1
         }
         oo.iminus().
            nl().
            object_end(self)
      }
   end
end

#
# A class to provide an unmodifiable view of another set.
#
class UnmodifiableSet(Set)
   private const s

   public member(x)
      return s.member(x)
   end

   public sort()
      return s.sort()
   end

   public gen()
      suspend s.gen()
   end

   public back()
      suspend s.back()
   end

   public rank(x)
      return s.rank(x)
   end

   public select(i)
      return s.select(i)
   end

   public size()
      return s.size()
   end

   public get_mode()
      return iand(ORDER, s.get_mode())
   end

   public new(s)
      self.s := s
      return
   end
end

#
# A Set which is a view of the keys of a `Table`.
#
class TableSet(Set)
   private const t

   public insert(x)
      t.insert(x, t.def)
      return self
   end

   public member(x)
      if t.member(x) then
         return x
   end

   public delete(x)
      return t.delete(x) & self
   end

   public sort()
      return t.key_sort()
   end

   public gen()
      suspend t.key()
   end

   public back()
      suspend t.back_key()
   end

   public rank(x)
      return t.rank(x)
   end

   public select(i)
      return t.select(i)
   end

   public size()
      return t.size()
   end

   public clear()
      t.clear()
      return self
   end

   public get_mode()
      return iand(INSERT + DELETE + ORDER, t.get_mode())
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `t` - either the `Table` to wrap, or a class indicating the class of
   #     a new `Table`, which will be instantiated by calling its
   #     constructor with no parameters.
   # :  `entries` - initial entries to insert.
   #
   public new(t, entries[])
      if type(t) == "class" then
         t := t()
      self.t := t
      every insert(!entries)
      return
   end
end

package class EmptySet(Set, SelfClone)
   public member(x)
   end

   public gen()
   end

   public size()
      return 0
   end

   public get_mode()
      return 0
   end

   package new()
      return
   end
end

#
# A `Set` that is just a wrapper around a builtin set
#
class BuiltinSet(Set)
   private const s

   public insert(x)
      default.insert(s, x)
      return self
   end

   public member(x)
      return default.member(s, x)
   end

   public delete(x)
      return default.delete(s, x) & self
   end

   public sort()
      return default.sort(s)
   end

   public gen()
      suspend !s
   end

   public size()
      return *s
   end

   public clear()
      default.clear(s)
      return self
   end

   public get_mode()
      return INSERT + DELETE
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `s` - the set to wrap; if omitted a new set is created.
   #
   public new(s)
      /s := set()
      self.s := s
      return
   end
end

# A convenient equivalent to wrapping a BuiltinSet in an
# UnmodifiableSet.
#
class UnmodifiableBuiltinSet(Set)
   private const s

   public member(x)
      return default.member(s, x)
   end

   public sort()
      return default.sort(s)
   end

   public gen()
      suspend !s
   end

   public size()
      return *s
   end

   public get_mode()
      return 0
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `s` - the set to wrap
   #
   public new(s)
      self.s := s
      return
   end
end
