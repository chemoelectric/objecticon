package ipl.lambda

import
   ipl.callable(callable)

global _a, _l

#
# Implementation class for {lambda}
#
class Lambda()
   private e

   package call(a[])
      local ta, tl
      ta := _a
      _a := a
      tl := _l
      _l := &null
      suspend 1(!e, _a :=: ta, _l :=: tl) do {
         _a :=: ta
         _l :=: tl
      }
      _a := ta
      _l := tl
   end

   package new(e)
      self.e := e
      return
   end
end

#
# This is a procedure for making lambda-style functions.  For example:
#   f := lambda{ _a[1] + 100 }
# sets f to be a function returning its first argument plus 100.  Note
# that args are passed to the function via a global variable _a, since
# icon syntax allows no other way.  Further, although the function can
# use any variables in scope, it cannot declare any itself.  To simulate
# local variables, another global, _l, can be used.  It can be set
# to any value.
# 
# Other examples:-
#   # Return the sum of the arguments, eg f(1,2,3) -> 6
#   # - note that _l must be dereferenced, otherwise the caller sees the
#   #   value before the function is called.
#   f := lambda{{ _l := 0; every _l +:= !_a ; ._l }}
#
procedure lambda(e)
   return Lambda(e).call
end

#
# Implementation class for {lpartial}
#
class LPartial()
   private
      f, l

   package call(a[])
      suspend f!(l ||| a)
   end

   package new(f, l)
      self.f := f
      self.l := l
      return
   end
end

#
# Partial application to function f, prepending l to the arguments.
#
procedure lpartial(f, l[])
   return LPartial(f, l).call
end

#
# Implementation class for {rpartial}
#
class RPartial()
   private
      f, l

   package call(a[])
      suspend f!(a ||| l)
   end

   package new(f, l)
      self.f := f
      self.l := l
      return
   end
end

#
# Partial application to function f, appending l to the arguments.
#
procedure rpartial(f, l[])
   return RPartial(f, l).call
end

#
# Implementation class for {compose}
#
class Compose()
   private
      f, g

   package call(a[])
      suspend f(g!a)
   end

   package new(f, g)
      self.f := f
      self.g := g
      return
   end
end

#
# Compose functions f and g
#
procedure compose(f, g)
   return Compose(f, g).call
end

# Convenient function to get the named binary operator, partially
# applied with x, using lpartial.  For example lpb("*", 2) returns a
# function which doubles its argument.
#
procedure lpb(s, x)
   return lpartial(callable(s, 2), x)
end

# Convenient function to get the named binary operator, partially
# applied with x, using rpartial.  For example rpb("/", 2) returns a
# function which halves its argument.
#
procedure rpb(s, x)
   return rpartial(callable(s, 2), x)
end

#
# Implementation class for {coexf}
#
class Coexf()
   private e

   package call()
      return @e
   end

   package new(e)
      self.e := e
      return
   end
end

#
# Given a co-expression {e}, this returns a function which produces @e
# on each evaluation.  Arguments to the function are discarded.
#
procedure coexf(e)
   return Coexf(e).call
end

# Evaluates coexpression {e}, saving the value of {_a} and {_l}.  This
# can be necessary if a lambda calls another lambda which exits via an
# exception or a runtime error.
#
# @example
# @   f := lambda{
# @      throw("Something bad")
# @   }
# @
# @   g := lambda{{
# @      write("a[1]=",_a[1])
# @      save_lambda{try{ f(102) }}
# @      # Without save_lambda, _a[1] would now still be 102 (ie the arg given to f)
# @      write("a[1]=",_a[1])
# @   }}
#
procedure save_lambda(e)
   local ta, tl
   ta := _a
   tl := _l
   suspend 1(|@e, _a :=: ta, _l :=: tl) do {
      _a :=: ta
      _l :=: tl
   }
   _a := ta
   _l := tl
end
