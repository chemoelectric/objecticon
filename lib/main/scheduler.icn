package io

import lang, util

# This stream wraps another stream (normally a {SocketStream}).  The
# {in} and {out} methods are invoked from the co-expression of the
# owning {Task}.  Those methods activate the {Task}'s {Scheduler}'s
# co-expression.  The stream's co-expression is re-activated only when
# the {Scheduler} determines the socket is ready for i/o (or has timed
# out).
#
class TaskStream(Stream)
   private readable
      timeout,
      other,
      task

   # Use the owning {Task} to poll for some i/o.  The given parameter
   # should be {Poll.IN} or {Poll.OUT} depending on whether we want to
   # be resumed on ready input or output respectively.  Fails on
   # timeout or error.
   #
   public poll(x)
      local r
      r := task.poll([other, x], timeout) | fail
      if /r then return error("Timeout")
      r[1] = x | return error("Socket error")
      return
   end

   public in(n)
      poll(Poll.IN) | fail
      return other.in(n)
   end

   public out(s)
      poll(Poll.OUT) | fail
      return other.out(s)
   end

   public close()
      return other.close()
   end

   public eof()
      return other.eof()
   end

   public get_mode()
      return other.get_mode()
   end

   public seek(offset)
      return other.seek(offset)
   end

   public tell()
      return other.tell()
   end

   public truncate(len)
      return other.truncate(len)
   end

   public new(other, task, timeout)
      self.other := other
      self.task := task
      self.timeout := timeout
      return
   end
end

class Task()
   public const
      scheduler
   private readable
      coex,
      sleep_until,
      last_sleep,
      poll_until,
      poll_req,
      interrupt_flag
   package readable
      state,
      active,
      poll_err,
      poll_res

   # If a task is currently sleeping, then this alters the time it
   # will sleep for, behaving as though the original call to {sleep}
   # had given {n} as its parameter.
   #
   public change_sleep(n)
      sleep_until := \last_sleep + n
   end

   # Succeed iff the task is currently active.
   #
   public is_active()
      return .\active
   end

   # Succeed iff the task is the current task.  Note that a task may
   # be active, but not the current task, since a task may itself
   # invoke {Scheduler.work} in order to activate another task, in a
   # nested fashion.  This may happen for example when a task shows a
   # modal dialog, and hence calls {Scheduler.work} via the dispatcher
   # event loop.
   #
   public is_current()
      return self === scheduler.curr_task
   end

   # Suspend this task, which must be the currently scheduled task, in
   # order to carry out a {DescStream.poll}.  The parameters and
   # result are in the same form as for {DescStream.poll}.  The
   # difference between this and {DescStream.poll} is that the
   # scheduler will suspend this task whilst the poll is taking place,
   # whereas {DescStream.poll} will block.  If {timeout} is zero, then
   # there is no advantage in using this method, and {DescStream.poll}
   # is preferable.
   #
   # @param l A list of alternating {DescStream}, flag (from {Poll})
   # @        pairs.
   # @param timeout The optional timeout
   #
   public poll(l, timeout)
      self === scheduler.curr_task | runerr("poll called on task which is not current")
      self.coex := &current
      self.poll_until := (Prog.get_runtime_millis() + \timeout) | &null
      self.poll_req := l
      self.interrupt_flag := &null
      scheduler.now_poll(self)
      return if \poll_err then
         error(poll_err)
      else if \interrupt_flag then
         error("Interrupted")
      else
         .self.poll_res
   end

   # Suspend this task, which must be the currently scheduled task,
   # for {n} milliseconds.
   #
   # @param n The time to wait for.
   #
   public sleep(n)
      self === scheduler.curr_task | runerr("sleep called on task which is not current")
      self.coex := &current
      last_sleep := Prog.get_runtime_millis()
      sleep_until := last_sleep + n
      self.interrupt_flag := &null
      scheduler.now_sleep(self)
   end

   # Interrupt the task, which may not be currently active.  If the
   # task is currently sleeping or polling, then it is placed back in
   # the ready state by the scheduler at the next opportunity.  The
   # flag causes the original {poll} call to fail, setting {&why}.
   #
   public interrupt()
      /active | runerr("interrupt called on a currently active task")
      self.interrupt_flag := 1
   end

   # Suspend this task, which must be the currently scheduled task,
   # placing it immediately into the ready state in the scheduler.
   #
   public yield()
      self === scheduler.curr_task | runerr("yield called on task which is not current")
      self.coex := &current
      scheduler.now_yield(self)
   end

   # Suspend this task, which must be the currently scheduled task,
   # but do not resume it.  Control reverts to the scheduler.  The
   # task may be subsequently restarted with {start}.  Note that to
   # end a task, it is normally simply sufficient to fall off the end
   # of the task's co-expression.  Using {revert} would only be
   # necessary if the task were to be re-started, or its
   # co-expression's activator was not the scheduler co-expression.
   #
   public revert()
      self === scheduler.curr_task | runerr("revert called on task which is not current")
      self.coex := &current
      scheduler.now_revert()
   end

   # Start the task, which may not be currently active.  If the task
   # was previously stopped in a particular state (eg sleeping), then
   # it continues from that same state.
   #
   public start()
      /active | runerr("start called on a currently active task")
      scheduler.start(self)
   end

   # Stop the task, which may not be currently active.  This prevents
   # the scheduler from activating it.  Its present state is
   # remembered, and it may be started again in that state using
   # {start}.
   #
   public stop()
      /active | runerr("stop called on a currently active task")
      scheduler.stop(self)
   end

   #
   # Create a new {Task}.
   #
   # @param scheduler The {Scheduler} to use to activate the task.
   # @param coex The co-expression body of the task.
   #
   public new(scheduler, coex)
      self.coex := coex
      self.scheduler := scheduler
      return
   end
end

class Scheduler()
   public const
      poll_timeout
   private readable 
      coex,
      curr_task

   private
      ready,
      sleeping,
      polling
   
   public new(n)
      poll_timeout := \n | 0
      ready := set()
      sleeping := set()
      polling := set()
      return
   end

   package start(t)
      /t.state := ready
      insert(t.state, t)
   end

   package stop(t)
      delete(\t.state, t)
   end

   private set_state(t, x)
      delete(\t.state, t)
      t.state := x
      insert(t.state, t)
   end

   package now_sleep(t)
      \coex | syserr("now_sleep with null coex")
      set_state(t, sleeping)
      coact(, coex)
   end

   package now_poll(t)
      \coex | syserr("now_poll with null coex")
      set_state(t, polling)
      coact(, coex)
   end

   package now_yield(t)
      \coex | syserr("now_yield with null coex")
      set_state(t, ready)
      coact(, coex)
   end

   package now_revert()
      \coex | syserr("now_revert with null coex")
      coact(, coex)
   end

   #
   # Test whether there are any tasks in the internal lists.
   #
   public empty()
      return not(*(ready | sleeping | polling) > 0)
   end

   private run(t)
      local sc, st
      delete(t.state, t)
      t.state := &null
      sc := coex
      st := curr_task
      coex := &current
      curr_task := t
      t.active := 1
      # Don't specify an activator unless we have to (ie if this is a
      # new co-expression).
      if Coexpression.get_activator(t.coex) then
         coact(, t.coex)
      else
         @t.coex
      t.active := &null
      coex := sc
      curr_task := st
    end

   public work()
      local t, r, curr_time, poll_l, x
      repeat {
         if t := ?ready then {
            run(t)
            return
         }

         if *sleeping > 0 then {
            curr_time := Prog.get_runtime_millis()
            every t := !sleeping do {
               if \t.interrupt_flag | (curr_time >= t.sleep_until) then
                  set_state(t, ready)
            }
            if *ready > 0 then
               next
         }

         if *polling > 0 then {
            poll_l := []
            every t := !polling do
               every put(poll_l, !t.poll_req)
            curr_time := Prog.get_runtime_millis() + poll_timeout
            if r := DescStream.poll(poll_l, poll_timeout) then {
               if /r then {
                  # Process timeout for each task.
                  every t := !polling do {
                     if \t.interrupt_flag | (curr_time > \t.poll_until) then {
                        set_state(t, ready)
                        t.poll_err := t.poll_res := &null
                     }
                  }
               } else {
                  every t := !polling do {
                     # Extract relevant part of result
                     x := []
                     every 1 to *t.poll_req / 2 do
                        put(x, pop(r))
                     # If all zeros, it's the same as a timeout.
                     if !x ~= 0 then {
                        set_state(t, ready)
                        t.poll_res := x
                        t.poll_err := &null
                     } else if \t.interrupt_flag | (curr_time > \t.poll_until) then {
                        set_state(t, ready)
                        t.poll_err := t.poll_res := &null
                     }
                  }
               }
            } else {
               # poll error; forward error to each Task
               every t := !polling do {
                  set_state(t, ready)
                  t.poll_err := &why
                  t.poll_res := &null
               }
            }
            # If we have a poll_timeout, the poll counts as work; otherwise it does not
            if poll_timeout > 0 then
               return
            if *ready > 0 then
               next
         }

         fail
      }
   end
end
