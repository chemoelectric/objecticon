############################################################################
#
#	File:     caseless.icn
#
#	Subject:  Procedures to perform caseless scanning
#
#	Author:   Nevin J. Liber
#
#	Date:     August 19, 1996
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#	These procedures are analogous to the standard string-analysis
#	functions except that uppercase letters are considered equivalent to
#	lowercase letters.
#
#	anycl(c, s, i1, i2)	succeeds and produces i1 + 1, provided
#				map(s[i1]) is in cset(map(c)) and i2 is
#				greater than i1.  It fails otherwise.
#
#	balcl(c1, c2, c3, s, i1, i2)	generates the sequence of integer
#					positions in s preceding a
#					character of cset(map(c1)) in
#					map(s[i1:i2]) that is balanced with
#					respect to characters in cset(map(c2))
#					and cset(map(c3)), but fails if there
#					is no such position.
#
#	findcl(s1, s2, i1, i2)	generates the sequence of integer positions in
#				s2 at which map(s1) occurs as a substring
#				in map(s2[i1:i2]), but fails if there is no
#				such position.
#
#	manycl(c, s, i1, i2)	succeeds and produces the position in s
#				after the longest initial sequence of
#				characters in cset(map(c)) within
#				map(s[i1:i2]).  It fails if map(s[i1]) is not
#				in cset(map(c)).
#
#	matchcl(s1, s2, i1, i2)	produces i1 + *s1 if
#				map(s1) == map(s2[i1+:=*s1]) but fails
#				otherwise.
#
#	uptocl(c, s, i1, i2)	generates the sequence of integer positions in
#				s preceding a character of cset(map(c)) in
#				map(s[i1:i2]).  It fails if there is no such
#				position.
#
#	Defaults:	s, s2	&subject
#			i1	&pos if s or s2 is defaulted; otherwise 1
#			i2	0
#			c1	&cset
#			c2	'('
#			c3	')'
#
#	Errors:	101	i1 or i2 not integer
#		103	s or s1 or s2 not string
#		104	c or c1 or c2 or c3 not cset
#
################################################################################


package ipl.caseless

# Expand the given cset so that all letters appear in the result both in lowercase
# and uppercase, eg mod_cset('Cat123') -> 'catCAT123'
procedure mod_cset(c)
   local ls
   ls := map(string(c ** &letters))
   return c ++ cset(ls || map(ls, &lcase, &ucase))
end

# Caseless version of bal()
procedure balcl(c1, c2, c3, s, i, j)
   suspend bal(mod_cset(c1), mod_cset(c2), mod_cset(c3), s, i, j)
end

# Caseless version of upto()
procedure uptocl(c, s, i, j)
   suspend upto(mod_cset(c), s, i, j)
end

# Caseless version of many()
procedure manycl(c, s, i, j)
   return many(mod_cset(c), s, i, j)
end

# Caseless version of any()
procedure anycl(c, s, i, j)
   return any(mod_cset(c), s, i, j)
end

# Caseless version of match()
procedure matchcl(s1, s2, i, j)
   if /s2 := &subject then {
      (/i := &pos) | (i := match("", s2, i)) | fail
   } else {
      s2 := text(s2) | runerr(129, s2)
      (/i := 1) | (i := match("", s2, i)) | fail
   }
   (/j := *s2 + 1) | (j := match("", s2, j)) | fail

   if type(s2) == "string" then
      s1 := string(s1) | runerr(103, s1)
   else
      s1 := ucs(s1) | runerr(128, s1)

   if i > j then
      i :=: j

   if map(s1) == map(s2[i:j][1+:*s1]) then
      return i + *s1
end

# Caseless version of find()
procedure findcl(s1, s2, i, j)
   local c, t
   if /s2 := &subject then {
      (/i := &pos) | (i := match("", s2, i)) | fail
   } else {
      s2 := text(s2) | runerr(129, s2)
      (/i := 1) | (i := match("", s2, i)) | fail
   }
   (/j := *s2 + 1) | (j := match("", s2, j)) | fail

   if type(s2) == "string" then
      s1 := string(s1) | runerr(103, s1)
   else
      s1 := ucs(s1) | runerr(128, s1)

   if i > j then
      i :=: j

   if *s1 = 0 then {
      suspend i to j
      fail
   }
   s1 := map(s1)
   # Cset of first char in upper and lower case; eg if searching for
   # "cat", c = 'cC'.
   c := cset(s1[1] || map(s1[1], &lcase, &ucase))
   every t := upto(c, s2, i, j) do {
      if t > j - *s1 then
         break
      if s1 == map(s2[t+:*s1]) then
         suspend t
   }
end

