<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>preprocessor.icn</title></head><body><pre>
<a name="1"/>package parser
<a name="2"/>
<a name="3"/>import io, util, ipl.scan, datastruct(Entry, SortTable)
<a name="4"/>
<a name="5"/>class Preprocessor(Connectable)
<a name="6"/>   private
<a name="7"/>      sym_table,if_stack,file_stack,if_state,
<a name="8"/>      file,filename,line,
<a name="9"/>      nest_level,include_name,
<a name="10"/>      include_set,print_filename,
<a name="11"/>      encoding,print_encoding
<a name="12"/>
<a name="13"/>   private static const 
<a name="14"/>      DEFAULT_SYMBOLS
<a name="15"/>
<a name="16"/>   private static init()
<a name="17"/>      local s
<a name="18"/>      DEFAULT_SYMBOLS := table()
<a name="19"/>      # reverse engineer the predefined symbols list from our predefined symbols
<a name="20"/>      every s := &amp;features do {
<a name="21"/>         DEFAULT_SYMBOLS[case s of {
<a name="22"/>            "Object Icon": "_OBJECT_ICON"
<a name="23"/>            "V2": "_V2"
<a name="24"/>            "keyboard functions": "_KEYBOARD_FUNCTIONS"
<a name="25"/>            "JPEG images": "_JPEG"
<a name="26"/>            "PNG images": "_PNG"
<a name="27"/>            "SSL networking": "_SSL"
<a name="28"/>            "MS Win32":"_MS_WIN32"
<a name="29"/>            "UNIX":"_UNIX"
<a name="30"/>            "POSIX":"_POSIX"
<a name="31"/>            "ASCII":"_ASCII"
<a name="32"/>            "co-expressions":"_CO_EXPRESSIONS"
<a name="33"/>            "dynamic loading":"_DYNAMIC_LOADING"
<a name="34"/>            "event monitoring":"_EVENT_MONITOR"
<a name="35"/>            "large integers":"_LARGE_INTEGERS"
<a name="36"/>            "multiple programs":"_MULTITASKING"
<a name="37"/>            "pipes":"_PIPES"
<a name="38"/>            "system function":"_SYSTEM_FUNCTION"
<a name="39"/>            "graphics":"_GRAPHICS"
<a name="40"/>            "X Windows":"_X_WINDOW_SYSTEM"
<a name="41"/>            "Linux": "_LINUX"
<a name="42"/>            "Solaris": "_SOLARIS"
<a name="43"/>            "AIX": "_AIX"
<a name="44"/>            "BSD": "_BSD"
<a name="45"/>            "Darwin": "_DARWIN"
<a name="46"/>            "Cygwin": "_CYGWIN"
<a name="47"/>         }] := "1"
<a name="48"/>      }
<a name="49"/>   end
<a name="50"/>
<a name="51"/>   #
<a name="52"/>   # Preprocess a file to a string.
<a name="53"/>   #
<a name="54"/>   public preprocess(fname, predefined_syms)
<a name="55"/>      local rs
<a name="56"/>      return use {
<a name="57"/>         rs := RamStream(),
<a name="58"/>         {
<a name="59"/>            every rs.write1(preprocess_gen(fname, predefined_syms))
<a name="60"/>            rs.str()
<a name="61"/>         }
<a name="62"/>      }
<a name="63"/>   end
<a name="64"/>
<a name="65"/>   #
<a name="66"/>   # Preprocesses a file, generating output lines.
<a name="67"/>   #
<a name="68"/>   public preprocess_gen(fname, predefined_syms)
<a name="69"/>      local s
<a name="70"/>      preproc_new(fname, predefined_syms) | fail
<a name="71"/>      suspend sync_lines()      
<a name="72"/>      while s := read_line() do {
<a name="73"/>         # s will be &amp;null if we have just come back from an include.  If so,
<a name="74"/>         # produce a #line directive.
<a name="75"/>         if /s then
<a name="76"/>            suspend sync_lines()      
<a name="77"/>         else s ? {
<a name="78"/>            if match("#line ") then {
<a name="79"/>               move(1)
<a name="80"/>               suspend scan_directive(&amp;yes)
<a name="81"/>            } else {
<a name="82"/>               scan_space()
<a name="83"/>               if ="$" &amp; any(&amp;letters ++ &amp;digits ++ ' \t\f\r') then {
<a name="84"/>                  suspend scan_directive()
<a name="85"/>               } else {
<a name="86"/>                  move(1)
<a name="87"/>                  suspend scan_text()
<a name="88"/>               }
<a name="89"/>            }
<a name="90"/>         }
<a name="91"/>      }
<a name="92"/>      close(\file)
<a name="93"/>      done()
<a name="94"/>   end
<a name="95"/>
<a name="96"/>   #
<a name="97"/>   # a_Initializes the preprocessor "object".
<a name="98"/>   #
<a name="99"/>   private preproc_new(fname,predefined_syms)
<a name="100"/>      local k, v
<a name="101"/>      sym_table := copy(DEFAULT_SYMBOLS)
<a name="102"/>      every k := key(\predefined_syms) do {
<a name="103"/>         v := predefined_syms[k]
<a name="104"/>         if /v then
<a name="105"/>            delete(sym_table, k)
<a name="106"/>         else
<a name="107"/>            insert(sym_table, k, need_string(v))
<a name="108"/>      }
<a name="109"/>      if_stack := []
<a name="110"/>      file_stack := []
<a name="111"/>      include_set := SortTable(, Files.standard_case_cmp, fname, )
<a name="112"/>      if_state := &amp;null
<a name="113"/>      filename := include_name := fname
<a name="114"/>      line := 0
<a name="115"/>      print_filename := &amp;null
<a name="116"/>      print_encoding := &amp;null
<a name="117"/>      nest_level := 0
<a name="118"/>      encoding := "ASCII"
<a name="119"/>      unless file := open(fname) then {
<a name="120"/>         err("Cannot open " || image(fname) || ": " || &amp;why)
<a name="121"/>         fail
<a name="122"/>      }
<a name="123"/>      return
<a name="124"/>   end
<a name="125"/>
<a name="126"/>   #
<a name="127"/>   # Clears the values of certain space-consuming variables.
<a name="128"/>   #
<a name="129"/>   private done()
<a name="130"/>      sym_table := if_stack := file_stack :=
<a name="131"/>         filename := print_filename := print_encoding :=
<a name="132"/>         encoding := file := include_set := &amp;null
<a name="133"/>      return
<a name="134"/>   end
<a name="135"/>
<a name="136"/>   #
<a name="137"/>   # a_Scans an encoding identifier.
<a name="138"/>   #
<a name="139"/>   private get_encoding()
<a name="140"/>      suspend any(&amp;letters) &amp; tab(many(&amp;letters ++ &amp;digits ++ '-'))
<a name="141"/>   end
<a name="142"/>
<a name="143"/>   #
<a name="144"/>   # a_Scans a preprocessor directive.  This method fails or returns
<a name="145"/>   # either a blank line or a #line directive.
<a name="146"/>   #
<a name="147"/>   private scan_directive(no_err)
<a name="148"/>      local sym,value,new_file,new_filename,new_line,new_encoding,old,preproc_command,old_if_state,fname,t
<a name="149"/>      scan_space()
<a name="150"/>      preproc_command := scan_word()
<a name="151"/>      if \if_state then {
<a name="152"/>         if match("if",preproc_command) then {
<a name="153"/>            preproc_command := "$if"
<a name="154"/>         }
<a name="155"/>      }
<a name="156"/>      scan_space()
<a name="157"/>      case preproc_command of {
<a name="158"/>         "define": {
<a name="159"/>            if /if_state then {
<a name="160"/>               if sym := scan_word() &amp;
<a name="161"/>                  value := scan_define_value() then 
<a name="162"/>               {
<a name="163"/>                  if (old := member(sym_table, sym)) ~=== value then {
<a name="164"/>                     err("Redefinition of " || sym || " = " ||
<a name="165"/>                                   old)
<a name="166"/>                  } else {
<a name="167"/>                     sym_table[sym] := value
<a name="168"/>                  }
<a name="169"/>               } else {
<a name="170"/>                  err()
<a name="171"/>               }
<a name="172"/>               return ""
<a name="173"/>            }
<a name="174"/>         }
<a name="175"/>         "undef": {
<a name="176"/>            if /if_state then {
<a name="177"/>               if sym := scan_word() &amp; at_end() then {
<a name="178"/>                  delete(sym_table,sym)
<a name="179"/>               } else {
<a name="180"/>                  err()
<a name="181"/>               }
<a name="182"/>               return ""
<a name="183"/>            }
<a name="184"/>         }
<a name="185"/>         "load": {
<a name="186"/>            if /if_state then {
<a name="187"/>               if sym := scan_word() &amp;
<a name="188"/>                  scan_opt_space() &amp;
<a name="189"/>                  fname := scan_qword() &amp; *fname &gt; 0 &amp; at_end() then 
<a name="190"/>               {
<a name="191"/>                  if t := Files.path_find(fname, 
<a name="192"/>                                          "OI_INCL",
<a name="193"/>                                          FilePath(filename).parent().str()) then
<a name="194"/>                  {
<a name="195"/>                     if value := image(Files.file_to_string(t)) then {
<a name="196"/>                        if (old := member(sym_table, sym)) ~=== value then {
<a name="197"/>                           err("Redefinition of " || sym || " = " ||
<a name="198"/>                               old)
<a name="199"/>                        } else {
<a name="200"/>                           sym_table[sym] := value
<a name="201"/>                        }
<a name="202"/>                     } else
<a name="203"/>                        err("Cannot load " || image(t) || ": " || &amp;why)
<a name="204"/>                  } else
<a name="205"/>                     err("Cannot find " || image(fname) || " on path")
<a name="206"/>               } else
<a name="207"/>                  err()
<a name="208"/>               return ""
<a name="209"/>            }
<a name="210"/>         }
<a name="211"/>         "uload": {
<a name="212"/>            if /if_state then {
<a name="213"/>               if sym := scan_word() &amp;
<a name="214"/>                  scan_opt_space() &amp;
<a name="215"/>                  fname := scan_qword() &amp; *fname &gt; 0 &amp; at_end() then 
<a name="216"/>               {
<a name="217"/>                  if t := Files.path_find(fname, 
<a name="218"/>                                          "OI_INCL",
<a name="219"/>                                          FilePath(filename).parent().str()) then
<a name="220"/>                  {
<a name="221"/>                     if value := "u" || image(Files.file_to_string(t)) then {
<a name="222"/>                        if (old := member(sym_table, sym)) ~=== value then {
<a name="223"/>                           err("Redefinition of " || sym || " = " ||
<a name="224"/>                               old)
<a name="225"/>                        } else {
<a name="226"/>                           sym_table[sym] := value
<a name="227"/>                        }
<a name="228"/>                     } else
<a name="229"/>                        err("Cannot load " || image(t) || ": " || &amp;why)
<a name="230"/>                  } else
<a name="231"/>                     err("Cannot find " || image(fname) || " on path")
<a name="232"/>               } else
<a name="233"/>                  err()
<a name="234"/>               return ""
<a name="235"/>            }
<a name="236"/>         }
<a name="237"/>         "if": {
<a name="238"/>            push(if_stack,if_state)
<a name="239"/>            if value := scan_expr() then {
<a name="240"/>               if /if_state then
<a name="241"/>                  if_state := if \value then &amp;null else "false"
<a name="242"/>               else
<a name="243"/>                  if_state := "off"
<a name="244"/>            } else {
<a name="245"/>               # if_state stays the same
<a name="246"/>               return ""
<a name="247"/>            }
<a name="248"/>
<a name="249"/>            if /if_state then
<a name="250"/>               return ""
<a name="251"/>            else
<a name="252"/>               fail
<a name="253"/>         }
<a name="254"/>         "$if": {    # handles if... command in "if'd-out" code
<a name="255"/>            push(if_stack,if_state)
<a name="256"/>            if_state := "off"
<a name="257"/>            fail
<a name="258"/>         }
<a name="259"/>         "elsif" : {
<a name="260"/>            if \if_state == "off" then
<a name="261"/>               fail
<a name="262"/>            if *if_stack &lt;= nest_level then {
<a name="263"/>               err("No corresponding $if...")
<a name="264"/>               return ""
<a name="265"/>            }
<a name="266"/>            if value := scan_expr() then {
<a name="267"/>               if \if_state then
<a name="268"/>                  if_state := if \value then &amp;null else "false"
<a name="269"/>               else
<a name="270"/>                  if_state := "off"
<a name="271"/>            } else {
<a name="272"/>               if_state := if \if_state then &amp;null else "off"
<a name="273"/>            }
<a name="274"/>            if /if_state then
<a name="275"/>               return sync_lines()
<a name="276"/>            else
<a name="277"/>               fail
<a name="278"/>         }
<a name="279"/>         "else": {
<a name="280"/>            if \if_state == "off" then
<a name="281"/>               fail
<a name="282"/>            if *if_stack &lt;= nest_level then {
<a name="283"/>               err("No corresponding $if...")
<a name="284"/>               return ""
<a name="285"/>            }
<a name="286"/>            unless at_end() then
<a name="287"/>               err()      # extraneous stuff is reported, but the else is processed as if it were OK.
<a name="288"/>            if_state := if \if_state then &amp;null else "false"
<a name="289"/>            if /if_state then
<a name="290"/>               return sync_lines()
<a name="291"/>            else
<a name="292"/>               fail
<a name="293"/>         }
<a name="294"/>         "endif": {
<a name="295"/>            old_if_state := if_state
<a name="296"/>            if at_end() then {
<a name="297"/>               (*if_stack &gt;= nest_level &amp;
<a name="298"/>                if_state := pop(if_stack)) |
<a name="299"/>                  err("No corresponding $if...")
<a name="300"/>            } else {
<a name="301"/>               *if_stack &gt;= nest_level &amp;
<a name="302"/>                  if_state := pop(if_stack)
<a name="303"/>               err()
<a name="304"/>            }
<a name="305"/>            if /if_state then {
<a name="306"/>               if /old_if_state then
<a name="307"/>                  return ""
<a name="308"/>               else
<a name="309"/>                  return sync_lines()
<a name="310"/>            } else
<a name="311"/>               fail
<a name="312"/>         }
<a name="313"/>         "include": {
<a name="314"/>            if /if_state then {
<a name="315"/>               if sym := scan_qword() &amp; *sym &gt; 0 &amp; at_end() then {
<a name="316"/>                  if new_filename := Files.path_find(sym, 
<a name="317"/>                                                     "OI_INCL",
<a name="318"/>                                                     FilePath(filename).parent().str()) then
<a name="319"/>                  {
<a name="320"/>                     if include_set.member(new_filename) then {
<a name="321"/>                        err("Circular reference to " || image(new_filename))
<a name="322"/>                     } else {
<a name="323"/>                        if new_file := open(new_filename) then {
<a name="324"/>                           every push(file_stack,
<a name="325"/>                                      encoding|file|filename|
<a name="326"/>                                      include_name|line|
<a name="327"/>                                      nest_level)
<a name="328"/>                           filename := new_filename
<a name="329"/>                           include_name := sym
<a name="330"/>                           file := new_file
<a name="331"/>                           line := 0
<a name="332"/>                           encoding := "ASCII"
<a name="333"/>                           nest_level := *if_stack
<a name="334"/>                           include_set.insert(new_filename)
<a name="335"/>                           return sync_lines()
<a name="336"/>                        } else
<a name="337"/>                           err("Cannot open " || image(new_filename) || ": " || &amp;why)
<a name="338"/>                     }
<a name="339"/>                  } else
<a name="340"/>                     err("Cannot find " || image(sym) || " on path")
<a name="341"/>               } else {
<a name="342"/>                  err()
<a name="343"/>               }
<a name="344"/>               return ""
<a name="345"/>            }
<a name="346"/>         }
<a name="347"/>         "line": {
<a name="348"/>            if new_line := integer(tab(many(&amp;digits))) &amp;
<a name="349"/>               scan_opt_space() &amp;
<a name="350"/>               (new_filename := scan_qword() | &amp;null) \ 1 &amp;
<a name="351"/>               (/new_filename | *new_filename &gt; 0) \ 1 &amp;
<a name="352"/>               scan_opt_space() &amp;
<a name="353"/>               (new_encoding := get_encoding() | &amp;null) \ 1 &amp;
<a name="354"/>               at_end() then 
<a name="355"/>            {
<a name="356"/>               filename := Files.path_find(\new_filename, 
<a name="357"/>                                           &amp;null,
<a name="358"/>                                           FilePath(filename).parent().str()) | \new_filename
<a name="359"/>               encoding := \new_encoding
<a name="360"/>               line := new_line - 1
<a name="361"/>               if /if_state then
<a name="362"/>                  return sync_lines()
<a name="363"/>            } else {
<a name="364"/>               # if no_err is set, then we have a "#line" directive, for which errors are ignored.
<a name="365"/>               if /no_err then
<a name="366"/>                  err()
<a name="367"/>               if /if_state then    
<a name="368"/>                  return ""
<a name="369"/>            }
<a name="370"/>         }
<a name="371"/>         "error": {
<a name="372"/>            if /if_state then {
<a name="373"/>               scan_space()
<a name="374"/>               t := "Explicit $error: " || trim(tab(find("#") | 0),' \t\f\r')
<a name="375"/>               err(t)
<a name="376"/>               return ""
<a name="377"/>            }
<a name="378"/>         }
<a name="379"/>         "encoding": {
<a name="380"/>            if /if_state then {
<a name="381"/>               if sym := get_encoding() &amp;
<a name="382"/>                  at_end() then
<a name="383"/>                  encoding := sym
<a name="384"/>               else
<a name="385"/>                  err()
<a name="386"/>               return sync_lines()
<a name="387"/>            }
<a name="388"/>         }
<a name="389"/>         "ITRACE": {
<a name="390"/>            if /if_state then {
<a name="391"/>               if value := integer(tab(many(&amp;digits ++ '-'))) &amp;
<a name="392"/>                  at_end() then 
<a name="393"/>               {
<a name="394"/>                  &amp;trace := value
<a name="395"/>               } else {
<a name="396"/>                  err()
<a name="397"/>               }
<a name="398"/>               return ""
<a name="399"/>            }
<a name="400"/>         }
<a name="401"/>         default: {
<a name="402"/>            if /if_state then {
<a name="403"/>               err("Unknown preprocessor directive:" || preproc_command)
<a name="404"/>               return ""
<a name="405"/>            }
<a name="406"/>         }
<a name="407"/>      }
<a name="408"/>   end
<a name="409"/>
<a name="410"/>   #
<a name="411"/>   # Scans and make substitutions in a text line.
<a name="412"/>   #
<a name="413"/>   private scan_text(done_set)
<a name="414"/>      local q,result,p,ident,value,t,c
<a name="415"/>      if /if_state then {
<a name="416"/>         if *sym_table &gt; 0 then {
<a name="417"/>            &amp;pos := q := 1
<a name="418"/>            result := ""
<a name="419"/>            while tab(upto('#"\'_' ++ &amp;letters ++ &amp;digits)) do {
<a name="420"/>               case c := move(1) of {
<a name="421"/>                  "#": {
<a name="422"/>                     tab(0)
<a name="423"/>                  }
<a name="424"/>                  !&amp;digits: {
<a name="425"/>                     # Reproduces the logic in nskip() in ipp.c
<a name="426"/>                     tab(many(&amp;digits))
<a name="427"/>                     if =("r"|"R") then
<a name="428"/>                        tab(many(&amp;digits ++ &amp;letters))
<a name="429"/>                     else {
<a name="430"/>                        if ="." then
<a name="431"/>                           tab(many(&amp;digits))
<a name="432"/>                        if =("e"|"E") then {
<a name="433"/>                           =("+"|"-")
<a name="434"/>                           tab(many(&amp;digits))
<a name="435"/>                        }                           
<a name="436"/>                     }
<a name="437"/>                  }
<a name="438"/>                  "\"" | "'": {
<a name="439"/>                     repeat {
<a name="440"/>                        # Look for end of literal; if found continue scannning
<a name="441"/>                        if skip_string(c) then
<a name="442"/>                           break
<a name="443"/>
<a name="444"/>                        # Multi-line literal.  Suspend line and read more.
<a name="445"/>                        suspend result || &amp;subject[q:0]
<a name="446"/>
<a name="447"/>                        t := read_line() | fail
<a name="448"/>                        # If we've just come back from a $include, t will be &amp;null, so return
<a name="449"/>                        # "#line ..." (this is bound to be a nonsense result anyway, since we're in
<a name="450"/>                        # the middle of a multi-line string).
<a name="451"/>                        if /t then
<a name="452"/>                           return sync_lines()
<a name="453"/>                        &amp;subject := t
<a name="454"/>                        q := 1
<a name="455"/>                        result := ""
<a name="456"/>                     }
<a name="457"/>                  }
<a name="458"/>                  default: {
<a name="459"/>                     move(-1)
<a name="460"/>                     # Check for ucs literal
<a name="461"/>                     if ="u" &amp; any('"') then
<a name="462"/>                        next
<a name="463"/>                     p := &amp;pos
<a name="464"/>                     ident := tab(many(&amp;letters ++ &amp;digits ++ '_'))
<a name="465"/>                     if value := member(sym_table, ident) then {
<a name="466"/>                        if /done_set |
<a name="467"/>                        {type(done_set) == "string" &amp;
<a name="468"/>                            done_set := set(done_set)
<a name="469"/>                         not member(done_set,ident)} then {
<a name="470"/>                            value ? value :=
<a name="471"/>                               scan_text(insert(copy(\done_set),
<a name="472"/>                                                ident) | ident)
<a name="473"/>                            result ||:= &amp;subject[q:p] || value
<a name="474"/>                            q := &amp;pos
<a name="475"/>                         }
<a name="476"/>                     }
<a name="477"/>                  }
<a name="478"/>               }
<a name="479"/>            }
<a name="480"/>            return result || &amp;subject[q:0]
<a name="481"/>         }
<a name="482"/>         else {
<a name="483"/>            return .&amp;subject
<a name="484"/>         }
<a name="485"/>      } else {
<a name="486"/>         # We're skipping an $if section, so skip over any multi-line
<a name="487"/>         # string literals.
<a name="488"/>         if c := multi_line_start() then {
<a name="489"/>            repeat {
<a name="490"/>               t := read_line() | fail
<a name="491"/>               if /t then {
<a name="492"/>                  if /if_state then
<a name="493"/>                     return sync_lines()
<a name="494"/>                  else
<a name="495"/>                     fail
<a name="496"/>               }
<a name="497"/>               &amp;subject := t
<a name="498"/>               if skip_string(c) then
<a name="499"/>                  c := multi_line_start() | break
<a name="500"/>            }
<a name="501"/>         }
<a name="502"/>      }
<a name="503"/>   end
<a name="504"/>
<a name="505"/>   # If this line ends on a multi-line literal, succeed and return the
<a name="506"/>   # relevant opening quote char.
<a name="507"/>   # Eg :-
<a name="508"/>   #    abc 'def' "xyz_
<a name="509"/>   # would succeed and return "
<a name="510"/>   #
<a name="511"/>   private static multi_line_start()
<a name="512"/>      local c
<a name="513"/>      while tab(upto('\"\'')) do {
<a name="514"/>         c := move(1)
<a name="515"/>         skip_string(c) | return c
<a name="516"/>      }
<a name="517"/>   end
<a name="518"/>
<a name="519"/>   # Skip a string/cset literal. q is " or ', and &amp;pos should be just
<a name="520"/>   # after the opening quote.  Succeeds and leaves &amp;pos just after the
<a name="521"/>   # closing quote, or at end of line if not closing quote was found.
<a name="522"/>   # Fails iff the literal is a multi-line.
<a name="523"/>   #
<a name="524"/>   # Examples (q=") :-
<a name="525"/>   #  one"blah -&gt; succeeds leaving &amp;pos after the "
<a name="526"/>   #  noquote -&gt; succeeds leaving &amp;pos at the end
<a name="527"/>   #  noend_ -&gt; fails, also leaving &amp;pos at the end
<a name="528"/>   #
<a name="529"/>   private static skip_string(q)
<a name="530"/>      local c
<a name="531"/>      q ++:= '\\_'
<a name="532"/>      while tab(upto(q) | 0) do {
<a name="533"/>         c := move(1) | return
<a name="534"/>         case c of {
<a name="535"/>            "_" : {
<a name="536"/>               if pos(0) then
<a name="537"/>                  fail
<a name="538"/>            }
<a name="539"/>            "\\" : move(1)
<a name="540"/>            default: return    # Closing quote found
<a name="541"/>         }
<a name="542"/>      }
<a name="543"/>   end
<a name="544"/>
<a name="545"/>   #
<a name="546"/>   # Reads an input line.  Manages end-of-file and reverting to including
<a name="547"/>   # file if appropriate, failing at end-of-input.
<a name="548"/>   #
<a name="549"/>   private read_line()
<a name="550"/>      local result
<a name="551"/>      \file | fail
<a name="552"/>      repeat {
<a name="553"/>         if result := file.read_line() then {
<a name="554"/>            if \result then
<a name="555"/>               break
<a name="556"/>            # else EOF, fall through
<a name="557"/>         } else
<a name="558"/>            err("Error reading: " || &amp;why)
<a name="559"/>         
<a name="560"/>         if *if_stack ~= nest_level then {
<a name="561"/>            err("$if(s) without $endif(s): " ||
<a name="562"/>                          *if_stack - nest_level)
<a name="563"/>            until *if_stack &lt;= nest_level do
<a name="564"/>               if_state := pop(if_stack)
<a name="565"/>         }
<a name="566"/>         close(file)
<a name="567"/>         file := &amp;null
<a name="568"/>         include_set.delete(include_name)
<a name="569"/>         (nest_level := pop(file_stack) &amp;
<a name="570"/>          line := pop(file_stack) &amp;
<a name="571"/>          include_name := pop(file_stack) &amp;
<a name="572"/>          filename := pop(file_stack) &amp;
<a name="573"/>          file := pop(file_stack) &amp;
<a name="574"/>          encoding := pop(file_stack)) | fail
<a name="575"/>         return &amp;null
<a name="576"/>      }
<a name="577"/>      line +:= 1
<a name="578"/>      return result
<a name="579"/>   end
<a name="580"/>
<a name="581"/>   #
<a name="582"/>   # Scans an identifier.
<a name="583"/>   #
<a name="584"/>   private static scan_word()
<a name="585"/>      suspend any(&amp;letters ++ '_') &amp; tab(many(&amp;letters ++ &amp;digits ++ '_'))
<a name="586"/>   end
<a name="587"/>
<a name="588"/>   #
<a name="589"/>   # Scans a possibly-quoted word (e.g. a file name).
<a name="590"/>   #
<a name="591"/>   private static scan_qword()
<a name="592"/>      suspend 2(="\"",
<a name="593"/>                tab(find("\"")),
<a name="594"/>                move(1)) |
<a name="595"/>         scan_word()
<a name="596"/>   end
<a name="597"/>
<a name="598"/>   #
<a name="599"/>   # Scans the value of a $define.
<a name="600"/>   #
<a name="601"/>   private static scan_define_value()
<a name="602"/>      local q,interesting_in_quotes
<a name="603"/>
<a name="604"/>      if ="(" then {
<a name="605"/>         fail      # "$define name(" is specifically prohibited; needs whitespace
<a name="606"/>      }
<a name="607"/>      scan_space()
<a name="608"/>      q := &amp;pos
<a name="609"/>      (while tab(upto('#"\'')) do {
<a name="610"/>         case move(1) of {
<a name="611"/>            "#": {
<a name="612"/>               move(-1)
<a name="613"/>               break
<a name="614"/>            }
<a name="615"/>            default: {
<a name="616"/>               interesting_in_quotes := '\\' ++ &amp;subject[&amp;pos - 1]
<a name="617"/>               repeat {
<a name="618"/>                  while tab(upto(interesting_in_quotes)) do {
<a name="619"/>                     case move(1) of {
<a name="620"/>                        "\\": move(1)
<a name="621"/>                        default: {
<a name="622"/>                           break break
<a name="623"/>                        }
<a name="624"/>                     }
<a name="625"/>                  }
<a name="626"/>                  fail # end of line inside quotes!!
<a name="627"/>               }
<a name="628"/>            }
<a name="629"/>         }
<a name="630"/>      }) | tab(0)
<a name="631"/>      return trim(&amp;subject[q:&amp;pos],' \t\f\r')
<a name="632"/>   end
<a name="633"/>
<a name="634"/>   #
<a name="635"/>   # Scans white space.
<a name="636"/>   #
<a name="637"/>   private static scan_space()
<a name="638"/>      suspend tab(many(' \t\f\r'))
<a name="639"/>   end
<a name="640"/>
<a name="641"/>   #
<a name="642"/>   # Scans optional white space.
<a name="643"/>   #
<a name="644"/>   private static scan_opt_space()
<a name="645"/>      suspend tab(many0(' \t\f\r'))
<a name="646"/>   end
<a name="647"/>
<a name="648"/>   #
<a name="649"/>   # Tests for &amp;pos at the logical end of a preprocessor directive.
<a name="650"/>   #
<a name="651"/>   private static at_end()
<a name="652"/>      scan_space()
<a name="653"/>      succeed pos(0) | match("#")
<a name="654"/>   end
<a name="655"/>
<a name="656"/>   #
<a name="657"/>   # Scan a boolean expression in a $if or $elsif line.  Returns the
<a name="658"/>   # resulting flag value, or fails on an error, having output an
<a name="659"/>   # appropriate message.
<a name="660"/>   #
<a name="661"/>   private scan_expr()
<a name="662"/>      local r
<a name="663"/>      r := expr1() | fail
<a name="664"/>      if at_end() then
<a name="665"/>         return r
<a name="666"/>      err("$if/$elsif: Extraneous characters")
<a name="667"/>   end
<a name="668"/>
<a name="669"/>   private expr1()
<a name="670"/>      local r, x
<a name="671"/>      r := expr2() | fail
<a name="672"/>      repeat {
<a name="673"/>         scan_space()
<a name="674"/>         ="|" | break
<a name="675"/>         x := expr2() | fail
<a name="676"/>         /r := x
<a name="677"/>      }
<a name="678"/>      return r
<a name="679"/>   end
<a name="680"/>
<a name="681"/>   private expr2()
<a name="682"/>      local r, x
<a name="683"/>      r := expr3() | fail
<a name="684"/>      repeat {
<a name="685"/>         scan_space()
<a name="686"/>         ="&amp;" | break
<a name="687"/>         x := expr3() | fail
<a name="688"/>         \r := x
<a name="689"/>      }
<a name="690"/>      return r
<a name="691"/>   end
<a name="692"/>
<a name="693"/>   private expr3()
<a name="694"/>      local c, x
<a name="695"/>      scan_space()
<a name="696"/>      if x := scan_word() then
<a name="697"/>         return Yes{ member(sym_table, x) }
<a name="698"/>      if c := move(1) then {
<a name="699"/>         case c of {
<a name="700"/>            "~" : return toggle_flag(expr3())
<a name="701"/>            "(" : {
<a name="702"/>               x := expr1() | fail
<a name="703"/>               scan_space()
<a name="704"/>               if =")" then
<a name="705"/>                  return x
<a name="706"/>               else
<a name="707"/>                  err("$if/$elsif: ) expected")
<a name="708"/>            }
<a name="709"/>            default:
<a name="710"/>               err("$if/$elsif: Unexpected character")
<a name="711"/>         } 
<a name="712"/>      } else
<a name="713"/>         err("$if/$elsif: Identifier expected")
<a name="714"/>   end
<a name="715"/>
<a name="716"/>
<a name="717"/>   #
<a name="718"/>   # Determines if a "#lines" is called for and generates one if so.
<a name="719"/>   #
<a name="720"/>   private sync_lines()
<a name="721"/>      if (encoding ~=== print_encoding) |
<a name="722"/>         (filename ~=== print_filename) then 
<a name="723"/>      {
<a name="724"/>         print_encoding := encoding
<a name="725"/>         print_filename := filename
<a name="726"/>         return "#line " || (line + 1) || " \"" || filename || "\" " || encoding
<a name="727"/>      }
<a name="728"/>      return "#line " || (line + 1)
<a name="729"/>   end
<a name="730"/>
<a name="731"/>   private err(msg)
<a name="732"/>      /msg := "Invalid preprocessor line"
<a name="733"/>      fire("error", ErrorDetail(FilePath(filename).canonical().str(), line, msg))
<a name="734"/>   end
<a name="735"/>
<a name="736"/>   #
<a name="737"/>   # options() converter function for a KEY[=VALUE] argument.  A
<a name="738"/>   # `datastruct.Entry` record is returned.
<a name="739"/>   #
<a name="740"/>   public static pp_def_opt(s)
<a name="741"/>      local k, v
<a name="742"/>      s ? {
<a name="743"/>         if k := tab(upto('=')) then {
<a name="744"/>            move(1)
<a name="745"/>            v := tab(0)
<a name="746"/>         } else
<a name="747"/>            # v will be &amp;null, meaning this key is to be deleted (see above).
<a name="748"/>            k := s
<a name="749"/>      }
<a name="750"/>      return if *k = 0 then
<a name="751"/>         error("Missing key")
<a name="752"/>      else
<a name="753"/>         Entry(k, v)
<a name="754"/>   end
<a name="755"/>end
</pre></body></html>
