<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>graphpak.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     graphpak.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures for manipulating directed graphs
<a name="6"/>#
<a name="7"/>#	Author:   Ralph E. Griswold
<a name="8"/>#
<a name="9"/>#	Date:     May 2, 2001
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#  The procedures here use sets to represent directed graphs.  See
<a name="18"/>#  The Icon Programming Language, second edition, pp. 195-198.
<a name="19"/>#
<a name="20"/>#  A value of type "graph" has two components: a list of nodes and
<a name="21"/>#  a two-way lookup table.  The nodes in turn contain pointers to
<a name="22"/>#  other nodes.  The two-way table maps a node to its name and
<a name="23"/>#  vice-versa.
<a name="24"/>#
<a name="25"/>#  Graph specifications are give in files in which the first line
<a name="26"/>#  is a white-space separated list of node names and subsequent lines
<a name="27"/>#  give the arcs, as in
<a name="28"/>#
<a name="29"/>#	Tucson Phoenix Bisbee Douglas Flagstaff
<a name="30"/>#	Tucson-&gt;Phoenix
<a name="31"/>#	Tucson-&gt;Bisbee
<a name="32"/>#	Bisbee-&gt;Bisbee
<a name="33"/>#	Bisbee-&gt;Douglas
<a name="34"/>#	Douglas-&gt;Phoenix
<a name="35"/>#	Douglas-&gt;Tucson
<a name="36"/>#
<a name="37"/>############################################################################
<a name="38"/>
<a name="39"/>package ipl.graphpak
<a name="40"/>
<a name="41"/>import
<a name="42"/>   io(read, write),
<a name="43"/>   util(error)
<a name="44"/>
<a name="45"/>record graph(nodes, lookup)
<a name="46"/>
<a name="47"/>#  Construct a graph from the specification given in file f.  Error checking
<a name="48"/>#  is minimal.
<a name="49"/>
<a name="50"/># read graph
<a name="51"/>procedure read_graph(f)		
<a name="52"/>   local node, nodes, node_list, lookup, arc, from_name, to_name, name
<a name="53"/>
<a name="54"/>   nodes := []				# list of the graph nodes
<a name="55"/>   lookup := table()			# two-way table of names and nodes
<a name="56"/>
<a name="57"/>   node_list := read(f) | return error("*** empty specification file")
<a name="58"/>
<a name="59"/>   node_list ? {			# process list of node names
<a name="60"/>      while name := tab(upto('\t ') | 0) do {
<a name="61"/>         node := set()			# create a new node
<a name="62"/>         put(nodes, node)		# add node to the list
<a name="63"/>         lookup[name] := node		# name to node
<a name="64"/>         lookup[node] := name		# node to name
<a name="65"/>         tab(many(' \t')) | break
<a name="66"/>         }
<a name="67"/>      }
<a name="68"/>
<a name="69"/>   while arc := read(f) do {		# process arcs
<a name="70"/>      arc ? {
<a name="71"/>         from_name := tab(find("-&gt;")) | return error("*** bad arc specification")
<a name="72"/>         move(2)
<a name="73"/>         to_name := tab(0)
<a name="74"/>         insert(\lookup[from_name], \lookup[to_name]) |
<a name="75"/>            return error("*** non-existent node")
<a name="76"/>         }
<a name="77"/>      }
<a name="78"/>         
<a name="79"/>
<a name="80"/>   return graph(nodes, lookup)		# now put the pieces together
<a name="81"/>
<a name="82"/>end
<a name="83"/>
<a name="84"/>#  Write graph g to file f.
<a name="85"/>
<a name="86"/># write graph
<a name="87"/>procedure write_graph(g, f)	
<a name="88"/>   local name_list, node
<a name="89"/>
<a name="90"/>   name_list := ""			# initialize
<a name="91"/>
<a name="92"/>   every node := !g.nodes do		# construct the list of names
<a name="93"/>      name_list ||:= g.lookup[node] || " "
<a name="94"/>
<a name="95"/>   write(f, name_list[1:-1])
<a name="96"/>   
<a name="97"/>   every node := !g.nodes do		# write the arc specifications
<a name="98"/>      every write(f, g.lookup[node], "-&gt;", g.lookup[!node])
<a name="99"/>
<a name="100"/>   return
<a name="101"/>
<a name="102"/>end
<a name="103"/>
<a name="104"/>#  Transitive closure of node.  Called as closure(node) without second argument
<a name="105"/>
<a name="106"/># transitive closure of graph
<a name="107"/>procedure closure(node, close)	
<a name="108"/>   local n
<a name="109"/>
<a name="110"/>   /close := set()			# initialize closure
<a name="111"/>
<a name="112"/>   insert(close, node)			# add the node itself
<a name="113"/>
<a name="114"/>   every n := !node do			# process all the arcs
<a name="115"/>					# if not member, recurse
<a name="116"/>      member(close, n) | closure(n, close)
<a name="117"/>
<a name="118"/>   return close
<a name="119"/>
<a name="120"/>end
</pre></body></html>
