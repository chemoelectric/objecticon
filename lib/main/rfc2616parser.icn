#
# $Id: rfc822parser.icn 3894 2013-02-06 16:02:46Z r.parlett $
#

package mail

import 
   lang,
   exception,
   ipl.caseless

class RFC2616Parser()
   public static const 
      CTL_CHAR,
      SEPARATORS,
      ATOM_CHAR,
      QTEXT_CHAR,
      LWSP_CHAR,
      MIME_CHARSET_CHAR,
      LANGUAGE_CHAR,
      ATTR_CHAR

   private static init()
      CTL_CHAR := &ascii[1:33] ++ &ascii[128]
      SEPARATORS := '()<>@,;:\\\"/[]?={} \t'
      ATOM_CHAR := &ascii -- CTL_CHAR -- SEPARATORS
      QTEXT_CHAR := &cset -- '\"\\\r'
      LWSP_CHAR := ' \t'
      MIME_CHARSET_CHAR := &letters ++ &digits ++ '!#$%&+\-^_/`{}/~'
      LANGUAGE_CHAR := &letters ++ &digits ++ '\-'
      ATTR_CHAR := ATOM_CHAR -- '*\'%'
   end

   #
   # The first four parse objects are the fundamental lexical components, other
   # than inidividual special characters (see rfc822).  Therefore, they must
   # be preceded by a call to next_token, to move the position to the correct
   # point to parse them.
   #

   #
   # qtext = <any CHAR excepting <">, "\" & CR, and including 
   #         linear-white-space>
   # quoted-pair =  "\" CHAR
   # quoted-string = <"> *(qtext/quoted-pair) <">
   #
   # Must be preceded by a call to next_token()
   #
   private parse_quoted_string()
      local res

      res := move(1)

      repeat {
         if any('\\') then {
            res ||:= move(2) | throw("Unterminated quoted string")
         } else if any(QTEXT_CHAR) then
            res ||:= tab(many(QTEXT_CHAR))
         else if any('\"') then {
            res ||:= move(1)
            return res
         } else
            # Missing closing quote or illegal char
            throw("Missing closing quote or illegal char")
      }
   end

   #
   # As above, but returns the string without the surrounding quotes, and any
   # escape sequences converted.
   #
   private parse_and_convert_quoted_string()
      local res

      res := move(0)  # Empty string, same type as &subject
      move(1)

      repeat {
         if any('\\') then {
            move(1)
            res ||:= move(1) | throw("Unterminated quoted string")
         } else if any(QTEXT_CHAR) then
            res ||:= tab(many(QTEXT_CHAR))
         else if any('\"') then {
            move(1)
            return res
         } else
            # Missing closing quote or illegal char
            throw("Missing closing quote or illegal char")
      }
   end

   #
   # atom        =  1*<any CHAR except specials, SPACE and CTLs>
   # ie one or more atom_char
   #
   # Must be preceded by a call to next_token()
   #
   private parse_atom()
      return tab(many(ATOM_CHAR)) | throw("Atom char expected")
   end

   private next_token()
      tab(many(LWSP_CHAR))
   end

   #
   # word =  atom / quoted-string
   #
   private parse_word() 
      next_token()
      if any('\"') then
         return parse_quoted_string()
      else
         return parse_atom()
   end

   #
   #  value := token / quoted-string
   #
   private parse_value()
      if any('\"') then
         return parse_and_convert_quoted_string()
      else
         return parse_atom()
   end

   #
   # disposition-type    = "inline" | "attachment" | disp-ext-type
   #                      ; case-insensitive
   # disp-ext-type       = token
   #
   private parse_disposition_type()
      local s

      if s := tab(matchcl("inline"|"attachment")) then
         return s

      return parse_atom()
   end

   # ext-value     = charset  "'" [ language ] "'" value-chars
   #               ; like RFC 2231's <extended-initial-value>
   #               ; (see [RFC2231], Section 7)
   # 
   # language      = <Language-Tag, defined in [RFC5646], Section 2.1>
   # 
   private parse_ext_value()
      local s, cs
      cs := parse_charset()
      next_token()
      ="'" | throw("' expected")
      next_token()
      tab(many(LANGUAGE_CHAR))
      next_token()
      ="'" | throw("' expected")
      next_token()
      s := parse_value_chars()
      return if cs == "UTF-8" then
         Text.liberal_ucs(s)
      else
         s
   end

   # value-chars   = *( pct-encoded / attr-char )
   # 
   # pct-encoded   = "%" HEXDIG HEXDIG
   #               ; see [RFC3986], Section 2.1
   # 
   # attr-char     = ALPHA / DIGIT
   #               / "!" / "#" / "$" / "&" / "+" / "-" / "."
   #               / "^" / "_" / "`" / "|" / "~"
   #               ; token except ( "*" / "'" / "%" )
   # 
   private parse_value_chars()
      local s
      # Always returns a string, not ucs.
      s := ""
      repeat {
         if any(ATTR_CHAR) then
            s ||:= string(tab(many(ATTR_CHAR)))
         else if any('%') then {
            move(1)
            s ||:= char(integer("16r" || move(2))) | throw("Invalid % encoding")
         } else
            return s
      }
   end

   #
   # charset       = "UTF-8" / "ISO-8859-1" / mime-charset
   # mime-charset  = 1*mime-charsetc
   # mime-charsetc = ALPHA / DIGIT
   #               / "!" / "#" / "$" / "%" / "&"
   #               / "+" / "-" / "^" / "_" / "`"
   #               / "{" / "}" / "~"
   #               ; as <mime-charset> in Section 2.3 of [RFC2978]
   #               ; except that the single quote is not included
   #               ; SHOULD be registered in the IANA charset registry
   #
   private parse_charset()
      return tab(many(MIME_CHARSET_CHAR)) | throw("Mime charset char expected")
   end

   #  disposition-parm    = filename-parm | disp-ext-parm
   #
   #  filename-parm       = "filename" "=" value
   #                      | "filename*" "=" ext-value
   #
   #  disp-ext-parm       = token "=" value
   #                      | ext-token "=" ext-value
   #  ext-token           = <the characters in token, followed by "*">
   #
   private parse_disposition_parm(cd)
      local key, val
      key := parse_atom()
      if key[-1] == "*" then {
         next_token()
         ="=" | throw("= expected")
         next_token()
         val := parse_ext_value()
      } else {
         next_token()
         ="=" | throw("= expected")
         next_token()
         val := parse_value()
      }
      cd.set_parameter(key, val)
   end

   #
   # content-disposition = "Content-Disposition" ":"
   #                         disposition-type *( ";" disposition-parm )
   #
   private parse_content_disposition_impl()
      local ty, cd

      next_token()
      ty := parse_disposition_type()
      cd := ContentDisposition(ty)

      repeat {
         next_token()
         =";" | break
         next_token()
         parse_disposition_parm(cd)
      }

      return cd
   end

   private end_check(o)
      next_token()
      pos(0) | throw("Extraneous input:" || tab(0))
      return o
   end

   public parse_content_disposition(s)
      return s ? simple_try{ end_check(parse_content_disposition_impl()) }
   end
end
