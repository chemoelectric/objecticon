#summary Co-expressions
<wiki:toc max_depth="3" />
= Introduction =
The implementation and semantics of co-expressions is rather different in V2 of Object Icon, compared to V1, and indeed to traditional Icon.

The first and most significant difference to mention is that co-expressions in V2 are cheap.  Each co-expression has an interpreter stack, but it grows and shrinks dynamically in chunks called "frames", with one frame corresponding to each procedure call.  Each frame is quite small, typically about 100 bytes.  This is in sharp contrast to the traditional Icon interpreter's allocation for a co-expression - a fixed size region sufficient for the predicted maximum required for both C and interpreter stack.

The implementation of co-expressions in V2 of Object Icon is also highly portable.  The conventional Icon implementation requires a low-level context switch to swap between C stacks.  This is inherently non-portable, and raises a number of other issues.  The new non-recursive design of the interpreter loop in V2 of Object Icon means that no context-switch is required to implement co-expressions, and the new implementation is written entirely in standard C.

== Co-expressions and local variables ==
In contrast to conventional Icon, V2 of Object Icon implements co-expressions in such a way that they share the local variables of the procedure in which they were created (in Icon each co-expression gets a copy of the local variables).

For example, the following program
{{{
import io

procedure main()
   local i, e
   i := 1
   e := create i := 2
   write(i)
   @e
   write(i)
end
}}}
outputs
{{{
1
2
}}}
whereas in Icon the result would be
{{{
1
1
}}}
Refreshing a co-expression creates a new co-expression, which also shares the same local variables.  Thus the program
{{{
import io

procedure main()
   local i, e
   i := 1
   e := create i +:= 1
   write(i)
   @e
   write(i)
   e := ^e
   @e
   write(i)
end
}}}
outputs
{{{
1
2
3
}}}
== The cocopy() function ==
Sometimes the way co-expressions share local variables is prohibitive.

Consider for example the problem of creating a list of ten co-expressions, each of which will generate a squared integer; 1 for the first, 4 for the second, 9 for the third and so on.  The following obvious attempt (which would work in Icon), unfortunately doesn't work in Object Icon :-
{{{
import io

procedure main()
   local x, i, e

   x := []
   every i := 1 to 10 do
      put(x, create i * i)

   every e := !x do
      write(@e)
end
}}}
The problem with this is that each `create i` references the same `i`, which eventually reaches the value `10`.  So the output is ten `100`s.

One way to solve this problem is to use a procedure to create the co-expressions :-
{{{
import io

procedure p(i)
   return create i * i
end

procedure main()
   local x, i, e

   x := []
   every i := 1 to 10 do
      put(x, p(i))

   every e := !x do
      write(@e)
end
}}}
Now each co-expression has its own copy of `i`, since each of the 10 calls to `p` creates its own set of local variables for that procedure.

This is rather awkward however, and to provide a tidier solution, a builtin function `cocopy` is provided.  This does exactly the same as the refresh operator `^`, but instead of returning a new co-expression which also shares the local variables, a new set of local variables is allocated with values copied from the original.  Here is another version of the above program :-
{{{
import io

procedure main()
   local x, i, e

   x := []
   every i := 1 to 10 do
      put(x, cocopy{i * i})

   every e := !x do
      write(@e)
end
}}}
Note we have used `cocopy{i * i}`, which is just syntactic shorthand for `cocopy(create i * i)`.

== Refreshing ==
In Icon, refreshing a co-expression reset the local variables to their values when the co-expression was created.   This doesn't happen in the V2 Object Icon implementation of co-expressions.  Refreshing a co-expression simply creates a new co-expression which shares the local variables of the co-expression being refreshed.  `cocopy` does the same, but creates copies of the local variables instead.

== The ! operator ==
V2 of Object Icon lets the unary ! operator be applied to co-expressions.  The effect is to generate the sequence of results from a refreshed copy of the given co-expression.  In other words, the result sequence of `!e` is the same as for `p(e)`, if `p` were defined as the following procedure :-
{{{
procedure p(e)
   local t
   e := ^e
   while t := @e do
      suspend t
end
}}}
Note that evaluating `!e` does not affect `e`, nor generate any results from it.
== Uses of co-expressions ==

=== As an expression type ===
The `!` operator, together with a co-expression's ability to alter local variables lets us conveniently use co-expressions as a way of replaying an arbitrary expression almost as though it were a macro.  For example :-
{{{
import io

procedure main()
   local e, i
   e := create i +:= 1
   i := 1
   !e
   !e
   !e
   write(i)
end
}}}
Outputs `4`.

As another example, consider the problem of printing the hexadecimal numbers in the range `0000` to `FFFF`.  The following program does this concisely :-
{{{
import io

procedure main()
   local e
   e := create !"0123456789ABCDEF"
   every write(!e || !e || !e || !e)
end
}}}

This use of co-expressions is inspired by the following paper.

[http://www.cs.arizona.edu/icon/ftp/doc/tr86_20.pdf]

=== Co-routines ===
Co-expressions provide a complete co-routine capability.  One particularly useful feature of co-routines is to generate the elements of a deeply nested structure.  For example, consider the following binary tree class :-
{{{
class Node()
   public const data
   private l, r

   public insert(val)
      if val < data then
         (/l := Node(val)) | l.insert(val)
      else
         (/r := Node(val)) | r.insert(val)
   end

   public traverse()
      (\l).traverse()
      self@&source
      (\r).traverse()
   end

   public new(i)
      self.data := i
      return
   end
end
}}}
The following `main` procedure populates a tree with random data and then uses `the traverse` method to print all the elements:-
{{{
import io

procedure main()
   local root, e, r
   r := create |?1000
   root := Node(@r)
   every 1 to 15 do
      root.insert(@r)
   e := create root.traverse()
   while write((@e).data)
end
}}}
Instead of using a `while` loop to print the elements we could also use an every loop as follows :-
{{{
   e := create root.traverse()
   every write((!e).data)
}}}
or, even more concisely
{{{
   every write(Seq{root.traverse()}.data)
}}}
`Seq` is a procedure which can be found in the `ipl.pdco` package.  It simply takes a co-expression as a parameter and suspends each of its results.  Note that `Seq{root.traverse()}` is just syntactic shorthand for `Seq(create root.traverse())`.
=== PDCOs ===
These are control structures whose elements are expressed as co-expressions.  For example, here is Dijkstra's non-deterministic "do..od" loop structure, which can be found in the `ipl.pdco` package.
{{{
procedure Do(a[])
   local x, i
   repeat {
      x := []
      every i := 1 to *a by 2 do
         if @^a[i] then 
            put(x, i)

      if *x = 0 then
         break

      @^a[?x + 1]
   }
end
}}}
Here is a program to multiply using two number using the above.
{{{
import io, ipl.pdco

procedure main(a)
   local e, p, q, r

   e := create integer(pop(a)) | stop("Integer expected")
   p := !e
   q := !e

   writes(p, " * ", q, " = ")
   r := 0
   Do {
      q < 0, {
         q := -q
         p := -p
      },

      q > 0 & q % 2 = 0, {
         q /:= 2
         p *:= 2
      },

      q > 0 & q % 2 = 1, {
         q -:= 1
         r +:= p
      }
   }
   write(r)
end
}}}
Note that the `Do { ... }` construct above is actually just an ordinary procedure call with six parameters, since
{{{
P{ e1, e2, ..., en }
}}}
is just syntactic shorthand for
{{{
P(create e1, create e2, ... create en)
}}}
The ability of V2 co-expressions to refer to local variables (rather than copies of them) is a big advantage here.  In conventional Icon, the above code would require that `p`, `q` and `r` be global or static variables in order that their values could be changed by the co-expressions.
 