package util

import lang(Class, Prog),
   ipl.lists(ldel1)


#
# Succeed iff the sequence generated by {&features} contains the given
# string.
#
procedure has_feature(x)
   static s
   initial {
      s := set()
      every insert(s, &features)
   }
   return member(s, x)
end

#
# Convenient procedure to set {&why} to the given string and fail.
#
procedure error(s)
   &why := s
end

# This class just provides a simple constructor which initializes the
# instance fields in the order they were defined in the class, from
# the given parameters.  In other words, rather like a record
# constructor.  The fields in the subclass must of course be
# accessible to this class's constructor.
#
# @example
# @  class Abc(SimpleConstructor) public const a, b, c end
# @  ...
# @  x := Abc(1,2,3)  # Sets a,b,c to 1,2,3 respectively
#  
class SimpleConstructor()
   public new(a[])
      every Class.get(self, 1 to Class.get_n_instance_fields(self)) := pop(a)
      return
   end
end

# Given a co-expression generating one or more variables, and a list
# of corresponding values, this values swaps the variables values
# and the values in the list.
#
procedure swap_vars(e, l)
   if *l = 1 then
      # Simple case
      !e :=: l[1]
   else {
      # Complex case.  Done in two stages (as opposed to swapping with
      # existing elements of l), so that it works okay with &subject
      # and &pos (swapping to &subject would change &pos).
      every put(l, !e)
      every !e := pop(l)
   }
   return
end

# Helper function for {init_vars}.  It generates initial values for
# global variables, which are normally &null, except for certain
# keyword variables.
#
package procedure init_val(e)
   local t
   every t := Prog.get_variable_name(!e) do
      suspend case t of {
         "&subject" | "&why" | "&progname": ""
         "&pos": 1
         "&trace" | "&random" | "&dump": 0
         "&maxlevel": 500
         default: &null
      }
end

# Given a co-expression generating one or more variables, this returns
# a list of the present values of the variables.  At the same time, it
# also sets the variables to default values, independent of their
# old values.  For example, if e generated g1 and g2, and their values
# were 100 and 200 respectively, this would return [100,200], and set
# both variables to null.
#
procedure init_vars(e)
   local l, f
   l := []
   every put(l, !e)
   f := create init_val(e)
   every !e := @f
   return l
end

# Invoke co-expression {e}, generating its results, in such a way that
# changes to {vars} made by {e} will not be seen by the caller, and
# vice versa.
#
# @param vars a coexpression generating one or more variables.
#
# @example
# @ # Cleanup some io stuff, without affecting global vars g1 and g2.
# @ save_vars{ io_cleanup(), g1 | g2 }
#
procedure save_vars(e, vars)
   local t
   t := init_vars(vars)
   suspend 1(|@e, swap_vars(vars, t)) do
      swap_vars(vars, t)
   every !vars := pop(t)
end

# A single-variable case of {save_vars}.
#
# @param vars a coexpression generating exactly one variable.
#
procedure save_var(e, var)
   local t
   t := !var
   !var := init_val(var)
   suspend 1(|@e, !var :=: t) do
      !var :=: t
   !var := t
end

#
# A common case, having the same effect as `save_var{..., &why}`.
#
procedure save_why(e)
   local t
   t := &why
   &why := ""
   suspend 1(|@e, &why :=: t) do
      &why :=: t
   &why := t
end

# This function saves {&why} before evaluating {e}.  If {e} succeeds,
# {&why} is restored, and the result returned; otherwise {&why} is not
# restored and the procedure fails.
#
procedure protect_why(e)
   local t
   t := &why
   return 1(@e, &why := t)
end

#
# Utility to check for a positive integer
#
procedure check_positive_int(n)
   return (0 < integer(n)) | runerr("Positive integer expected", n)
end

# Stores a list of cleanup expressions to be run.  See {use} and {clean}.
#
package global cleanup

#
# This procedure is used to automatically close a {Stream} or other
# resource.  The first expression {e1} produces the resource, the
# second {e2} uses it, and the third expression {e3} then closes it.
# The result of {e2} is returned, if all three expressions succeed,
# otherwise the procedure fails.
#
# {e3} is optional and defaults to calling {close} on the resource.
#
# @example
# @   s := use { f := open("some.txt"),
# @              do_something_with(f) }
procedure use(e1, e2, e3)
   local x, v, f
   x := @e1 | fail
   /e3 := create x.close()
   push(\cleanup, e3)
   /e2 | (v := @e2) | (f := 1)
   ldel1(\cleanup, e3)
   @e3 | (f := 1)
   return /f & v
end

# This procedure can be used in conjunction with {use} to ensure that
# all cleanup expressions are performed.  {e} is evaluated for its
# first result only.  Then any outstanding cleanup expressions are
# performed.  If {e} failed, or any of the cleanup expressions failed,
# then the procedure fails; otherwise the first result of {e} is
# returned.
#
# See also {exception.clean_try}.
#
procedure clean(e)
   local t, v, f
   t := cleanup
   cleanup := []
   (v := @e) | (f := 1)
   do_cleanups() | (f := 1)
   cleanup := t
   return /f & v
end

# Perform any outstanding cleanups in the {cleanup} list.  Fails if any of the
# expressions fail, succeeds otherwise.
#
procedure do_cleanups()
   local f, x
   while x := pop(cleanup) do
      @x | (f := 1)
   return /f
end

# Convert an index position based on a length, to an absolute index,
# using Icon semantics of indices <= 0.  Fails if pos is out of range.
#
procedure cvpos(pos, len)
   if pos < -len | pos > len + 1 then
      fail
   if pos > 0 then
      return pos
   return pos + len + 1
end

