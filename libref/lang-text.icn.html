<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>text.icn</title></head><body><pre>
<a name="1"/>package lang
<a name="2"/>
<a name="3"/>import util(need_string, need_cset, need_ucs)
<a name="4"/>
<a name="5"/>final abstract class Text()
<a name="6"/>   #
<a name="7"/>   # Generate the ranges in a cset, as a sequence of from-to pairs.
<a name="8"/>   #
<a name="9"/>   public static native get_ord_range(c)
<a name="10"/>
<a name="11"/>   #
<a name="12"/>   # Produce a cset consisting of characters in the range x[1]-x[2],
<a name="13"/>   # x[3]-x[4] etc.  A list of ranges may also be passed as a
<a name="14"/>   # parameter.
<a name="15"/>   #
<a name="16"/>   # Fails and sets &amp;why if any of the code point numbers is invalid.
<a name="17"/>   #
<a name="18"/>   public static native create_cset(x[])
<a name="19"/>   
<a name="20"/>   #
<a name="21"/>   # Succeed if the cset c contains the code point x, returning its
<a name="22"/>   # index in the cset
<a name="23"/>   #
<a name="24"/>   public static native has_ord(c, x)
<a name="25"/>
<a name="26"/>   #
<a name="27"/>   # Produce a string containing the utf-8 sequence of chars for
<a name="28"/>   # character i.
<a name="29"/>   #
<a name="30"/>   public static native utf8_seq(i)
<a name="31"/>
<a name="32"/>   #
<a name="33"/>   # Caseless string comparator function.  This works just like
<a name="34"/>   # Internal.compare (so no conversions are done), but uses caseless
<a name="35"/>   # text comparison.  For ucs, a unicode mapping is used to compare
<a name="36"/>   # letters, whilst for strings only the ASCII letters are
<a name="37"/>   # considered.
<a name="38"/>   #
<a name="39"/>   public static native caseless_compare(s1, s2)
<a name="40"/>
<a name="41"/>   #
<a name="42"/>   # A caseless string comparator function with consistent ordering
<a name="43"/>   # amongst items which compare caselessly equal, so that for example
<a name="44"/>   # abc, aBc, ABC are always sorted in the same order.  No
<a name="45"/>   # conversions are done, so different types are never mixed.
<a name="46"/>   #
<a name="47"/>   public static native consistent_compare(s1, s2)
<a name="48"/>
<a name="49"/>   # Succeed if all the chars in x are in cset y.
<a name="50"/>   #
<a name="51"/>   public static subset(x, y)
<a name="52"/>      local c
<a name="53"/>      y := need_cset(y)
<a name="54"/>      every c := ord(x) do
<a name="55"/>         Text.has_ord(y, c) | fail
<a name="56"/>      return
<a name="57"/>   end
<a name="58"/>
<a name="59"/>   #
<a name="60"/>   # Given an initial character, return the number of characters
<a name="61"/>   # making up a valid utf8 sequence beginning with that character, or
<a name="62"/>   # fail if it is not a valid initial character.
<a name="63"/>   #
<a name="64"/>   public static get_utf8_seq_len(ch)
<a name="65"/>      static utf8_seq_len_arr
<a name="66"/>      initial utf8_seq_len_arr := [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<a name="67"/>                                   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<a name="68"/>                                   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<a name="69"/>                                   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
<a name="70"/>                                   1,1,1,1,1,1,1,,,,,,,,,,,,,,,,,,
<a name="71"/>                                   ,,,,,,,,,,,,,,,,,,,,,
<a name="72"/>                                   ,,,,,,,,,,,,,,,,,,,,,
<a name="73"/>                                   ,,,,,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
<a name="74"/>                                   2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,
<a name="75"/>                                   5,5,5,5,6,6,,]
<a name="76"/>      return \utf8_seq_len_arr[ord(ch)\1 + 1]
<a name="77"/>   end
<a name="78"/>
<a name="79"/>   #
<a name="80"/>   # A more liberal way of parsing a utf-8 string than the builtin
<a name="81"/>   # `ucs` function.  Any errors in the input result in the substitute
<a name="82"/>   # character (by default U+FFFD) being put into the resulting
<a name="83"/>   # string.
<a name="84"/>   # :Parameters :
<a name="85"/>   # :  `s` - the string to parse into a ucs
<a name="86"/>   # :  `subst` - the substitute character
<a name="87"/>   public static liberal_ucs(s, subst)
<a name="88"/>      local t, n
<a name="89"/>      if s := ucs(s) then
<a name="90"/>         return s
<a name="91"/>      s := need_string(s)
<a name="92"/>      subst := need_string(\subst) | "\uFFFD"
<a name="93"/>      t := ""
<a name="94"/>      s ? repeat {
<a name="95"/>         t ||:= tab(many(&amp;ascii))
<a name="96"/>         if pos(0) then
<a name="97"/>            return ucs(t)
<a name="98"/>         unless n := get_utf8_seq_len(&amp;subject[&amp;pos]) &amp; t ||:= string(ucs(move(n))) then {
<a name="99"/>            t ||:= subst
<a name="100"/>            move(1)
<a name="101"/>         }
<a name="102"/>      }
<a name="103"/>   end
<a name="104"/>
<a name="105"/>   #
<a name="106"/>   # Convert an ISO-8859-1 string to ucs
<a name="107"/>   #
<a name="108"/>   public static iso_8859_1_to_ucs(s)
<a name="109"/>      local t, ch
<a name="110"/>      s := need_string(s)
<a name="111"/>      t := ""
<a name="112"/>      s ? repeat {
<a name="113"/>         t ||:= tab(many(&amp;ascii))
<a name="114"/>         ch := ord(move(1)) | return ucs(t)
<a name="115"/>         t ||:= Text.utf8_seq(ch)
<a name="116"/>      }
<a name="117"/>   end
<a name="118"/>
<a name="119"/>   #
<a name="120"/>   # Convert a ucs to ISO-8859-1 string; characters out of range are
<a name="121"/>   # represented by the subst string (default "?").
<a name="122"/>   #
<a name="123"/>   public static ucs_to_iso_8859_1(s, subst)
<a name="124"/>      local t, ch
<a name="125"/>      s := need_ucs(s)
<a name="126"/>      /subst := "?"
<a name="127"/>      t := ""
<a name="128"/>      s ? repeat {
<a name="129"/>         t ||:= string(tab(many(&amp;ascii)))
<a name="130"/>         ch := ord(move(1)) | return t
<a name="131"/>         t ||:= char(ch) | subst
<a name="132"/>      }
<a name="133"/>   end
<a name="134"/>
<a name="135"/>   #
<a name="136"/>   # Given a cset `c`, produce another cset containing those characters in 
<a name="137"/>   # positions `i`:`j`.
<a name="138"/>   #
<a name="139"/>   public static native slice(c, i, j)
<a name="140"/>
<a name="141"/>   #
<a name="142"/>   # Succeed iff `s` is a string composed of ascii characters.  No
<a name="143"/>   # conversions are performed.
<a name="144"/>   #
<a name="145"/>   public static native is_ascii_string(s)
<a name="146"/>
<a name="147"/>   #
<a name="148"/>   # Convert the given string or ucs `s` to lower case.  If `s` is
<a name="149"/>   # ucs, then a unicode mapping is used; it is a string then only the
<a name="150"/>   # characters in `&amp;ucase` are converted.
<a name="151"/>   #
<a name="152"/>   public static native lower(s)
<a name="153"/>
<a name="154"/>   #
<a name="155"/>   # Convert the given string or ucs `s` to upper case.  If `s` is
<a name="156"/>   # ucs, then a unicode mapping is used; it is a string then only the
<a name="157"/>   # characters in `&amp;lcase` are converted.
<a name="158"/>   #
<a name="159"/>   public static native upper(s)
<a name="160"/>
<a name="161"/>   #
<a name="162"/>   # Expand the given cset so that all letters appear in the result
<a name="163"/>   # both in lowercase and uppercase, eg
<a name="164"/>   # ~
<a name="165"/>   #   Text.caseless_cset('Cat123') -&gt; 'catCAT123'
<a name="166"/>   # ~
<a name="167"/>   # The result can then be used, for example to do a caseless upto
<a name="168"/>   # search.
<a name="169"/>   #
<a name="170"/>   # The optional parameter `t` can be used to indicate the type the
<a name="171"/>   # result will be used with; if `t` is a string, then non-ascii
<a name="172"/>   # characters won't be expanded to upper and lower case alternatives
<a name="173"/>   # (using a unicode mapping); otherwise they will.  This allows
<a name="174"/>   # convenient interaction with the behaviour of `upper` and `lower`.
<a name="175"/>   #
<a name="176"/>   public static native caseless_cset(c, t)
<a name="177"/>end
</pre></body></html>
