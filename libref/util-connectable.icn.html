<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>connectable.icn</title></head><body><pre>
<a name="1"/>package util
<a name="2"/>
<a name="3"/>import ipl.functional, ipl.pdco
<a name="4"/>
<a name="5"/>#
<a name="6"/># This simply holds information about a single listener.
<a name="7"/>#
<a name="8"/>final class Listener()
<a name="9"/>   private readable 
<a name="10"/>      obj,
<a name="11"/>      proc
<a name="12"/>   public const
<a name="13"/>      type
<a name="14"/>
<a name="15"/>   #
<a name="16"/>   # Remove this `Listener` from the object it's listening to; fails and does
<a name="17"/>   # nothing if the `Listener` is already disconnected.
<a name="18"/>   #
<a name="19"/>   # :Returns :
<a name="20"/>   # :  self
<a name="21"/>   #
<a name="22"/>   public disconnect()
<a name="23"/>      \obj | fail
<a name="24"/>      obj.disconnect_impl(self)
<a name="25"/>      obj := &amp;null
<a name="26"/>      proc := 1
<a name="27"/>      link
<a name="28"/>   end
<a name="29"/>
<a name="30"/>   package new(obj, proc, type)
<a name="31"/>      self.obj := obj
<a name="32"/>      self.proc := proc
<a name="33"/>      self.type := type
<a name="34"/>      return
<a name="35"/>   end
<a name="36"/>end
<a name="37"/>
<a name="38"/>#
<a name="39"/># Helper class for `Connectable.connect_n`
<a name="40"/>#
<a name="41"/>package class ConnectN()
<a name="42"/>   private
<a name="43"/>      n
<a name="44"/>   private const
<a name="45"/>      proc
<a name="46"/>   public
<a name="47"/>      x
<a name="48"/>
<a name="49"/>   public call(a[])
<a name="50"/>      proc!a
<a name="51"/>      n -:= 1
<a name="52"/>      if n = 0 then
<a name="53"/>         x.disconnect()
<a name="54"/>   end
<a name="55"/>
<a name="56"/>   public new(proc, n)
<a name="57"/>      self.proc := proc
<a name="58"/>      self.n := n
<a name="59"/>      return
<a name="60"/>   end
<a name="61"/>end
<a name="62"/>
<a name="63"/>#
<a name="64"/># A class which provides a listener list facility.
<a name="65"/>#
<a name="66"/>class Connectable()
<a name="67"/>   private const
<a name="68"/>      listeners
<a name="69"/>
<a name="70"/>   # This variable contains the last `Listener` added with `connect()`.
<a name="71"/>   private readable
<a name="72"/>      last_listener
<a name="73"/>
<a name="74"/>   #
<a name="75"/>   # Fire an event to listeners of the given type.
<a name="76"/>   #
<a name="77"/>   # :Parameters :
<a name="78"/>   # :  `type` - The particular event type to fire.
<a name="79"/>   # :  `param` - The arbitrary parameter to pass to listeners
<a name="80"/>   # :Returns :
<a name="81"/>   # :  self
<a name="82"/>   #
<a name="83"/>   public fire(type, param)
<a name="84"/>      local e
<a name="85"/>      \type | runerr("Null type to fire")
<a name="86"/>      every e := !member(listeners, type | &amp;null) do
<a name="87"/>         e.proc(param, self, type)
<a name="88"/>      link
<a name="89"/>   end
<a name="90"/>
<a name="91"/>   #
<a name="92"/>   # Create and connect a `Listener` to this object.  To get the actual `Listener`
<a name="93"/>   # instance added, use the variable `last_listener`.
<a name="94"/>   #
<a name="95"/>   # :Parameters :
<a name="96"/>   # :  `proc` - The procedure or other invocable to call on an event.
<a name="97"/>   # :  `type` - The particular event to listen for; `&amp;null` means all events
<a name="98"/>   # :  `pos` - The position in the listener list for the type, default 0.
<a name="99"/>   # :Returns :
<a name="100"/>   # :  self
<a name="101"/>   #
<a name="102"/>   public connect(proc, type, pos)
<a name="103"/>      local l
<a name="104"/>      proc := need_callable_alt_exprf(proc)
<a name="105"/>      /pos := 0
<a name="106"/>      l := copy(member(listeners, type)) | []
<a name="107"/>      insert(l, pos, last_listener &lt;- Listener(self, proc, type)) | fail
<a name="108"/>      insert(listeners, type, l)
<a name="109"/>      link
<a name="110"/>   end
<a name="111"/>
<a name="112"/>   #
<a name="113"/>   # This is like `connect`, but the listener is automatically disconnected
<a name="114"/>   # after it is fired `n` times.  `n` defaults to 1.
<a name="115"/>   # :Returns :
<a name="116"/>   # :  self
<a name="117"/>   #
<a name="118"/>   public connect_n(proc, type, pos, n)
<a name="119"/>      local i
<a name="120"/>      /n := 1
<a name="121"/>      proc := need_callable_alt_exprf(proc)
<a name="122"/>      i := ConnectN(proc, n)
<a name="123"/>      connect(i.call, type, pos) | fail
<a name="124"/>      i.x := last_listener
<a name="125"/>      link
<a name="126"/>   end
<a name="127"/>
<a name="128"/>   #
<a name="129"/>   # This returns the last `Listener` instance added with `connect`.
<a name="130"/>   #
<a name="131"/>   public get_last_listener()
<a name="132"/>      return .\last_listener
<a name="133"/>   end
<a name="134"/>
<a name="135"/>   package disconnect_impl(e)
<a name="136"/>      local l, t
<a name="137"/>      l := member(listeners, e.type) | fail
<a name="138"/>      t := List{ e ~=== !l }
<a name="139"/>      if *t &gt; 0 then
<a name="140"/>         insert(listeners, e.type, t)
<a name="141"/>      else
<a name="142"/>         delete(listeners, e.type)
<a name="143"/>      link
<a name="144"/>   end
<a name="145"/>
<a name="146"/>   #
<a name="147"/>   # Generate the listeners for the given event type
<a name="148"/>   #
<a name="149"/>   public gen_listeners(type)
<a name="150"/>      suspend .!member(listeners, type)
<a name="151"/>   end
<a name="152"/>
<a name="153"/>   #
<a name="154"/>   # Generate the event types currently being listened for.
<a name="155"/>   #
<a name="156"/>   public gen_listener_types()
<a name="157"/>      suspend key(listeners)
<a name="158"/>   end
<a name="159"/>
<a name="160"/>   public new()
<a name="161"/>      listeners := table()
<a name="162"/>      return
<a name="163"/>   end
<a name="164"/>end
</pre></body></html>
