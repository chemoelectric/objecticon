package graphics

import 
   lang(Class, NoCopy, ObjectClone, ObjectOutput, Unencodable),
   util(use, error, HasClose)

record Size(width, height)
record Point(x, y)
record Rectangle(x, y, width, height)
record Vector(dx, dy)
record Color(red, green, blue, alpha)
record XYColor(x, y, red, green, blue, alpha)
record XYPixel(x, y, pixel)
record References(canvas, context)

# This object contains pixel data either read from a file, extracted
# from a Window, or created from scratch.  The data is stored in
# various underlying formats depending on the source.
#
final class Pixels(ObjectClone, ObjectOutput, Unencodable, HasClose)
   private
      ptr

   public static const
      A8,
      A16,
      RGB24,
      BGR24,
      RGBA32,
      ABGR32,
      RGB48,
      RGBA64,
      G8,
      GA16,
      AG16,
      G16,
      GA32,
      PALETTE1,
      PALETTE2,
      PALETTE4,
      PALETTE8

   private static init()
      A8        :=  "A8"
      A16       :=  "A16"
      RGB24     :=  "RGB24"
      BGR24     :=  "BGR24"
      RGBA32    :=  "RGBA32"
      ABGR32    :=  "ABGR32"
      RGB48     :=  "RGB48"
      RGBA64    :=  "RGBA64"
      G8        :=  "G8"
      GA16      :=  "GA16"
      AG16      :=  "AG16"
      G16       :=  "G16"
      GA32      :=  "GA32"
      PALETTE1  :=  "PALETTE1"
      PALETTE2  :=  "PALETTE2"
      PALETTE4  :=  "PALETTE4"
      PALETTE8  :=  "PALETTE8"
   end

   # Get the width of the block
   #
   public native get_width()

   # Get the height of the block
   #
   public native get_height()

   # Get the size, as a `Size` record.
   #
   public get_size()
      return Size(get_width(), get_height())
   end

   # Get the pixel at the given position as an Icon colour string;
   # indices run from 0 to width-1 and 0 to height-1 respectively.
   #
   public native get(x, y)

   # Set the pixel to the given Icon colour string value.  Note that
   # the value actually stored may only be an approximation of the
   # value given, depending on the underlying data format.
   #
   public native set(x, y, v)

   # Get the given pixel as an `Color` record, giving the rgba values.
   #
   public get_rgba(x, y)
      return Color!get_rgba_impl(x, y)
   end

   private native get_rgba_impl(x, y)

   # Set the given pixel to the given rgba integer values.
   #
   public native set_rgba(x, y, r, g, b, a)

   # Dispose of the object, freeing the memory used by the block
   #
   public override native close()

   # Get the format of the underlying data, which will be one of the constant values listed above.
   #
   public native get_format()

   # Get the raw underlying data as a string.
   #
   public native get_data()

   # Set the raw underlying data from a string, padding with zeroes if
   # the string is too short.
   #
   public native set_data(s)

   # Convenient method to generate 0 to get_width() - 1
   #
   public x_range()
      suspend 0 to get_width() - 1
   end

   # Convenient method to generate 0 to get_height() - 1
   #
   public y_range()
      suspend 0 to get_height() - 1
   end

   #
   # Generate all the pixels in the given rectangle, which defaults to
   # the whole image.  The pixels are generated left to right and from
   # top to bottom, as `XYColor` records, which give the x, y position
   # and rgba color values of each pixel.  NB - the same record is
   # suspended each time.
   #
   public gen_rgba(x, y, width, height)
      suspend gen_rgba_impl(x, y, width, height, XYColor())
   end

   private native gen_rgba_impl(x, y, width, height, rec)

   #
   # Generate all the pixels in the given rectangle, which defaults to
   # the whole image.  The pixels are generated left to right and from
   # top to bottom, as `XYPixel` records, which give the x, y position
   # and color string of each pixel.  NB - the same record is
   # suspended each time.
   #
   public gen(x, y, width, height)
      suspend gen_impl(x, y, width, height, XYPixel())
   end

   private native gen_impl(x, y, width, height, rec)

   # Copy a single pixel from this instance to another.
   #
   public native copy_pixel(x1, y1, dest, x2, y2)

   # Copy a rectangular area from this instance to another.
   #
   public native copy_to(x1, y1, width, height, dest, x2, y2)

   #
   # Encode the image to a file.
   #
   public native to_file(fname)

   # Return the number of bits of alpha depth (zero if the format
   # doesn't support storage of an alpha channel).
   #
   public native get_alpha_depth()

   # Return the number of bits of color depth.
   #
   public native get_color_depth()

   # Get the palette size, or fail if this is not a PALETTE format.
   #
   public native get_palette_size()

   # Get the palette entry at index i, as a `Color` record.  This and
   # similar methods give a runerr unless the format is PALETTEx.  The
   # number of palette entries depends on the format; eg PALETTE4 has
   # 2^4=16 possible entries, indexed 0..15.
   #
   public get_palette_rgba(i)
      return Color!get_palette_rgba_impl(i)
   end

   private native get_palette_rgba_impl(i)

   # Set the palette entry at index i to the given rgba values.
   #
   public native set_palette_rgba(i, r, g, b, a)

   # Get the palette entry at index i as an icon colour value.
   #
   public native get_palette(i)

   # Set the palette entry at index i to the given icon colour value.
   #
   public native set_palette(i, v)

   # Get the palette index contained at the given pixel location.
   #
   public native get_palette_index(x, y)

   # Set the palette index contained at the given pixel location.
   #
   public native set_palette_index(x, y, i)

   # Return a new instance which is an exact copy of this instance.
   # No data is shared.
   #
   public clone()
      return create_for_ptr(clone_impl())
   end

   # Convert this instance to one of the same dimensions in the given
   # format.  The format may not be a paletted format (since no
   # palette would have been set up).
   #
   public convert(format)
      return create_for_ptr(convert_impl(format))
   end

   # Return a new `Pixels` instance which shares the data of this
   # instance.  The underlying data is freed when the last enclosing
   # `Pixels` is closed.
   #
   public shared_copy()
      return create_for_ptr(shared_copy_impl())
   end

   # Return the number of references to the underlying data.
   #
   public native get_references()

   private override object_clone()
      return clone()
   end

   private native convert_impl(format)
   private native shared_copy_impl()
   private native clone_impl()

   # Set entries in the palette according to one of the standard
   # palettes (c1,c2 etc).  Only allowed for PALETTE8 format.
   #
   public native load_palette(pal)

   package static create_for_ptr(ptr)
      local i
      i := Class.create_instance()
      i.ptr := ptr
      return i
   end

   private static native new_open_impl(s)
   private static native new_blank_impl(width, height, format)

   #
   # Output object
   #
   private override object_output(oo)
      local s
      s := if /ptr then "closed" else
         get_width() || "x" || get_height() || " " || get_format()
      oo.object_string(self, s)
   end

   # The constructor for Pixels takes two formats.  With one parameter
   # a new instance is created based on the given image string, which
   # can be raw image data, or a filename.
   #
   # With two parameters, a blank instance is created of the given
   # width and height; an optional third parameter provides the
   # format.  The underlying data is allocated and set to zero.
   #
   public new(a[])
      (ptr := if *a = 1 then
         new_open_impl(a[1])
      else
         new_blank_impl!a) | fail
      return
   end
end

final class Window(NoCopy, ObjectOutput, HasClose)
   private
      ptr

   public static const
      RESIZE,
      MOVE,
      STATE,
      FOCUS_IN,
      FOCUS_OUT,
      CLOSE_BUTTON,
      INVOKE_LATER

   private static const
      PATTERNS

   private static init()
      STATE :=         -8
      MOVE :=          -9
      RESIZE :=       -10
      CLOSE_BUTTON := -11
      INVOKE_LATER := -40
      FOCUS_IN :=     -25
      FOCUS_OUT :=    -26
      PATTERNS := table(,
                        Pattern.BLACK, Pixels(8, 8, Pixels.PALETTE1).set_data("\xff\xff\xff\xff\xff\xff\xff\xff\x00"),
                        Pattern.VERY_DARK, Pixels(8, 8, Pixels.PALETTE1).set_data("\xfe\xff\xef\xff\xfe\xff\xef\xff\x00"),
                        Pattern.DARK_GRAY, Pixels(8, 8, Pixels.PALETTE1).set_data("w\xddw\xddw\xddw\xdd\x00"),
                        Pattern.GRAY, Pixels(8, 8, Pixels.PALETTE1).set_data("U\xaaU\xaaU\xaaU\xaa\x00"),
                        Pattern.LIGHT_GRAY, Pixels(8, 8, Pixels.PALETTE1).set_data("\x11D\x11D\x11D\x11D\x00"),
                        Pattern.VERY_LIGHT, Pixels(8, 8, Pixels.PALETTE1).set_data("\x01\x00\x10\x00\x01\x00\x10\x00\x00"),
                        Pattern.WHITE, Pixels(8, 8, Pixels.PALETTE1).set_data("\x00\x00\x00\x00\x00\x00\x00\x00\x00"),
                        Pattern.VERTICAL, Pixels(8, 8, Pixels.PALETTE1).set_data("\x10\x10\x10\x10\x10\x10\x10\x10\x00"),
                        Pattern.DIAGONAL, Pixels(8, 8, Pixels.PALETTE1).set_data("\x80@ \x10\b\x04\x02\x01\x00"),
                        Pattern.HORIZONTAL, Pixels(8, 8, Pixels.PALETTE1).set_data("\x00\x00\x00\xff\x00\x00\x00\x00\x00"),
                        Pattern.GRID, Pixels(8, 8, Pixels.PALETTE1).set_data("\x10\x10\x10\xff\x10\x10\x10\x10\x00"),
                        Pattern.TRELLIS, Pixels(8, 8, Pixels.PALETTE1).set_data("\x82D(\x10(D\x82\x01\x00"),
                        Pattern.CHECKERS, Pixels(8, 8, Pixels.PALETTE1).set_data("\x0f\x0f\x0f\x0f\xf0\xf0\xf0\xf0\x00"),
                        Pattern.GRAINS, Pixels(8, 8, Pixels.PALETTE1).set_data("\e\x18\x81\xb16\x06`c\x00"),
                        Pattern.SCALES, Pixels(8, 8, Pixels.PALETTE1).set_data("\x02\x02\x05\xf8  P\x8f\x00"),
                        Pattern.WAVES, Pixels(8, 8, Pixels.PALETTE1).set_data("\x03\x84H0\x03\x84H0\x00"))
   end

   private static create_for_ptr(ptr)
      local i
      i := Class.create_instance()
      i.ptr := ptr
      return i
   end

   # Open a new window.  The meaning of the optional parameter
   # `display` (a string) is system dependent; on X11 it specifies the
   # display to connect to.
   #
   public new(display)
      self.ptr := new_impl(display) | fail
      return
   end

   private override object_output(oo)
      local s
      s := if /ptr then "closed" else
         get_width() || "x" || get_height() || " " || get_canvas()
      oo.object_string(self, s)
   end

   # Produces a new window value that combines the canvas of `self`
   # with a new graphics context. The new graphics attributes are
   # copied from `self`.
   #
   public clone()
      return create_for_ptr(clone_impl())
   end

   # Return a new instance which shares both canvas and context of
   # `self`.
   #
   public shared_copy()
      return couple(self)
   end

   # Produces a new window value that binds the canvas of `self` with
   # the graphics context of `other`.
   #
   public couple(other)
      return create_for_ptr(couple_impl(other))
   end

   private static native new_impl(display)
   private native clone_impl()
   private native couple_impl(other)

   # Grab the pointer so that all mouse events are directed to this
   # window.
   #
   public native grab_pointer()

   # Undoes the effect of `grab_pointer()`.
   #
   public native ungrab_pointer()

   # Grab the keyboard so that all key events are directed to this
   # window.
   #
   public native grab_keyboard()

   # Undoes the effect of `grab_keyboard()`.
   #
   public native ungrab_keyboard()

   # Return the ascent height of the font in pixels.
   #
   public native get_font_ascent()

   # Return the background colour as set by `set_bg()`
   #
   public native get_bg()

   # Return the canvas type as set by `set_canvas()`
   #
   public native get_canvas()

   # Return the depth in bits used by the window system for this window.
   public native get_depth()

   # Return the descent height of the font in pixels.
   #
   public native get_font_descent()

   # Return the display value used when this window was constructed,
   # or the default setting if no display parameter was used.
   #
   public native get_display()

   # Return a system-dependent string which can identify the visible
   # window to external programs.  Fails if the window is hidden.
   #
   public native get_id()

   # Return the drawing operator as set by `set_draw_op()`.
   #
   public native get_draw_op()

   # Return the x offset, as set by `set_dx()`.
   #
   public native get_dx()

   # Return the y offset, as set by `set_dy()`.
   #
   public native get_dy()

   # Return the font leading value, as set by `set_leading()`.
   #
   public native get_leading()

   # Return the foreground colour as set by `set_fg()`
   #
   public native get_fg()

   # Return the font as set by `set_font()`.  Note that the system's
   # identifier of the font will be returned, rather than the exact
   # value passed to `set_font()`.
   #
   public native get_font()

   # Return the font width in pixels of the current font; for a
   # proportional font this is the maximum width of one character.
   #
   public native get_font_width()

   # Return the height of this window; see `get_size()`.
   #
   public native get_height()

   # Return the window label as set by `set_label()`.
   #
   public native get_label()

   # Return the line style setting as set by `set_line_end()`.
   #
   public native get_line_end()

   # Return the line style setting as set by `set_line_join()`.
   #
   public native get_line_join()

   # Return the line width (a real), as set by `set_line_width()`.
   #
   public native get_line_width()

   # Return the maximum allowed height of this window, see `get_max_size()`.
   #
   public native get_max_height()

   # Return the maximum allowed width of this window, see `get_max_size()`.
   #
   public native get_max_width()

   # Return the minimum allowed height of this window; see `get_min_size()`.
   #
   public native get_min_height()

   # Return the minimum allowed width of this window; see `get_min_size()`.
   #
   public native get_min_width()

   # Return the mouse pointer as set by `set_pointer()`.
   #
   public native get_pointer()

   # Return the window's x position on the screen; see `get_pos()`.
   #
   public native get_x()

   # Return the window's y position on the screen; see `get_pos()`.
   #
   public native get_y()

   # Succeed iff the window is resizable, according to the flag set
   # with `set_resize()`.
   public native can_resize()

   # Return the width of this window; see `get_size()`.
   #
   public native get_width()

   # Return the `dx, dy` offset as a `Vector` record.
   #
   public get_offset()
      return Vector(get_dx(), get_dy())
   end

   # Set the `dx, dy` offset; see `set_dx()` and `set_dy()`.
   #
   public set_offset(dx, dy)
      return set_dx(dx).set_dy(dy)
   end

   # Return the current clip as a `Rectangle` record, or fail if there
   # is no clip set.
   #
   public get_clip()
      return Rectangle!get_clip_impl()
   end

   private native get_clip_impl()

   # Temporarily stop copying graphic operations from the backing
   # image to the visible window.  This call must be followed by a
   # call to `restore()`.
   #
   public native hold()

   # After a call to `hold()`, update the visible window with the
   # drawing that has taken place since `hold()`, by copying the given
   # region from the off-screen buffer to the visible window.  This
   # can be used as a form of double-buffering, with several drawing
   # operations taking place off-screen, and being updated in one go.
   #
   public native restore(x, y, width, height)

   # Return the size of the window as a `Size` record.
   #
   public get_size()
      return Size(get_width(), get_height())
   end

   # Return the maximum size of the window as a `Size` record.
   #
   public get_max_size()
      return Size(get_max_width(), get_max_height())
   end

   # Return the minimum size of the window as a `Size` record.
   #
   public get_min_size()
      return Size(get_min_width(), get_min_height())
   end

   # Return the position of this window as a `Size` record.  If the
   # window is hidden, or the position is unavailable, this method
   # fails.
   #
   # Note that, for a bordered window, this method always returns the
   # location of the inner client area.  This is distinct from the
   # corresponding `set_pos()` method.
   #
   public get_pos()
      return Point(get_x(), get_y())
   end

   # Return the geometry of this window as a `Rectangle` record; see
   # `get_pos()` and `get_size()`.
   #
   public get_geometry()
      return Rectangle(get_x(), get_y(), get_width(), get_height())
   end

   # Return the number of references to this window's canvas and
   # context, as a `References` record.
   #
   public get_references()
      return References!get_references_impl()
   end

   private native get_references_impl()

   # Set the current background color.
   #
   public native set_bg(v)

   # The canvas attribute canvas specifies the window visibility.
   # Possible values are system dependent, but include "hidden",
   # "normal", and "popup".  The X11 implementation also provides
   # "iconic", "fullscreen", "maximized", "root", "withdrawn".  (See
   # `Canvas` for symbolic constants).
   #
   public native set_canvas(v)

   # Set the drawing operator, which specifies the way in which newly
   # drawn pixels are combined with the pixels that are already in a
   # window.  Possible values are system dependent, but include "over"
   # and "source".  The X11 implementation also allows "atop",
   # "clear", "dest", "dest atop", "dest in", "dest out", "dest over",
   # "in", "out", and "xor".  (See `DrawOp` for symbolic constants).
   #
   public native set_draw_op(v)

   # Set the line leading, which specifies extra space to add to font
   # ascent, descent and height, to calculate line ascent, descent and
   # height.  It is specified as a real number, being the proportion
   # of font height.  The default leading value is `0.075`, and this
   # can be changed by setting the environment variable `OI_LEADING`.
   #
   public native set_leading(v)

   # Set `dx`, a horizontal offset that is added to the x value of
   # every coordinate pair before interpretation.
   #
   public native set_dx(v)

   # Set `dy`, a vertical offset that is added to the y value of every
   # coordinate pair before interpretation.
   #
   public native set_dy(v)

   # Set the current foreground color.
   #
   public native set_fg(v)

   # Set the current text font.
   #
   public native set_font(v)

   # Specifies the position and size of the window; see `set_pos()`
   # and `set_size()`.
   #
   public native set_geometry(x, y, width, height)

   # Set the height of the window in pixels; see `set_size()`.
   #
   public native set_height(height)

   # Specifies an image to load into the window.  On success, the
   # window is resized to the size of the image.  The given parameter
   # `v` may be raw binary image data (eg a gif file), or the name of
   # a file containing an image, or a `Pixels` instance.
   #
   public set_image(v)
      return if is(v, Pixels) then {
         set_size(v.get_width(), v.get_height())
         draw_image(,, v)
      } else use {
         v := Pixels(v),
         {
            set_size(v.get_width(), v.get_height())
            draw_image(,, v)
         }
      }
   end

   # Specify an image used to identify the window.  If null, then the
   # setting is cleared.  The parameter takes the same format as
   # `set_image()`.
   #
   public set_icon(v)
      return if /v | is(v, Pixels) then
         set_icon_impl(v)
      else use {
         v := Pixels(v),
         set_icon_impl(v)
      }
   end

   private native set_icon_impl(id)

   # The canvas attribute label specifies a title used to identify the
   # window.
   #
   public native set_label(v)

   # Set the line style, which specifies how `draw_line()` draws the
   # ends of a line.  Possible values are "flat", "point", "round",
   # and "square".  (See `LineEnd` for symbolic constants).
   #
   public native set_line_end(v)

   # Set the line style, which specifies how `draw_line()` draws the
   # joins of a line.  Possible values are "bevel", "miter" "round".  (See
   # `LineJoin` for symbolic constants).
   #
   public native set_line_join(v)

   # Set the width of drawn lines.
   #
   public native set_line_width(v)

   # Set the maximum height of the window in pixels.  This only
   # affects visible windows, not hidden windows.
   #
   public native set_max_height(height)

   # Set the maximum size of the window in pixels.  This only affects
   # visible windows, not hidden windows.
   #
   public native set_max_size(width, height)

   # Set the maximum width of the window in pixels.  This only affects
   # visible windows, not hidden windows.
   #
   public native set_max_width(width)

   # Set the minimum height of the window in pixels.  This only
   # affects visible windows, not hidden windows.
   #
   public native set_min_height(height)

   # Set the minimum size of the window in pixels.  This only affects
   # visible windows, not hidden windows.
   #
   public native set_min_size(width, height)

   # Set the minimum width of the window in pixels.  This only affects
   # visible windows, not hidden windows.
   #
   public native set_min_width(width)

   # Set the base height to use in aspect ratio and resize increment
   # calculations.
   # 
   # This value is currently only effective on X11.
   #
   public native set_base_height(height)

   # Set the base width to use in aspect ratio and resize increment
   # calculations.
   # 
   # This value is currently only effective on X11.
   #
   public native set_base_width(width)

   # Set the base size to use in aspect ratio and resize increment
   # calculations.
   # 
   # This value is currently only effective on X11.
   #
   public native set_base_size(width, height)

   # Return the base height; see `set_base_height()`.
   #
   public native get_base_height()

   # Return the base width; see `set_base_width()`.
   #
   public native get_base_width()

   # Return the base size as a `Size` record; see `set_base_size()`.
   #
   public get_base_size()
      return Size(get_base_width(), get_base_height())
   end

   # Set the resize increment height to use during resizing.
   # 
   # This value is currently only effective on X11.
   #
   public native set_increment_height(height)

   # Set the resize increment width to use during resizing.
   # 
   # This value is currently only effective on X11.
   #
   public native set_increment_width(width)

   # Set the resize increment size to use during resizing.
   # 
   # This value is currently only effective on X11.
   #
   public native set_increment_size(width, height)

   # Get the resize increment height; see `set_increment_height()`.
   #
   public native get_increment_height()

   # Get the resize increment width; see `set_increment_width()`.
   #
   public native get_increment_width()

   # Return the increment size as a `Size` record; see `set_increment_size()`.
   #
   public get_increment_size()
      return Size(get_increment_width(), get_increment_height())
   end

   # Set the maximum aspect ratio allowed during resizing.
   # 
   # This value is currently only effective on X11.
   #
   public native set_max_aspect_ratio(r)

   # Return the maximum aspect ratio allowed during resizing, or fail
   # if no value is set; see `set_max_aspect_ratio()`.
   #
   public native get_max_aspect_ratio()

   # Set the minimum aspect ratio allowed during resizing.
   # 
   # This value is currently only effective on X11.
   #
   public native set_min_aspect_ratio(r)

   # Return the minimum aspect ratio allowed during resizing, or fail
   # if no value is set; see `set_min_aspect_ratio()`.
   #
   public native get_min_aspect_ratio()

   # A helpful method to set the pattern to something equivalent to
   # the old Icon pattern of the same name using a textured fill
   # style.  (See `Pattern` for symbolic constant pattern names).
   #
   public set_textured_pattern(s)
      local p
      return use {
         p := get_fill_pattern(s, get_fg(), get_bg()),
         set_pattern(p)
      }
   end

   # A helpful method to set the pattern to something equivalent to
   # the old Icon pattern of the same name using a masked fill
   # style.  (See `Pattern` for symbolic constant pattern names).
   #
   public set_masked_pattern(s)
      local p
      return use {
         p := get_fill_pattern(s, get_fg(), "transparent"),
         set_pattern(p)
      }
   end

   # Return a new `Pixels` instance with a paletted image which
   # represents the classic Icon pattern of the given name, with the
   # given foreground and background colours.
   #
   public static get_fill_pattern(s, fg, bg)
      local p
      p := member(PATTERNS, s) | return error("Unknown pattern name")
      return p.clone().
         set_palette(0, fg).
         set_palette(1, bg)
   end

   # Set the fill pattern (texture) to fill shapes (instead of the
   # foreground colour).  If no parameter is given, the setting is
   # cleared and the foreground colour is used again.  Otherwise, the
   # parameter should be a `Pixels` instance or raw image data, or an
   # image filename.
   #
   public set_pattern(v)
      return if /v | is(v, Pixels) then
         set_pattern_impl(v)
      else use {
         v := Pixels(v),
         set_pattern_impl(v)
      }
   end

   private native set_pattern_impl(v)

   # Set a mask to use with certain drawing operations.
   #
   # If no parameter is given, the setting is cleared and the
   # foreground colour is used again.  Otherwise, the parameter should
   # be a `Pixels` instance or raw image data, or an image filename.
   #
   public set_mask(v)
      return if /v | is(v, Pixels) then
         set_mask_impl(v)
      else use {
         v := Pixels(v),
         set_mask_impl(v)
      }
   end

   private native set_mask_impl(v)

   # Set the shape of the figure that represents the mouse position.
   # The recognised values for string `v` are system dependent; see
   # the `cursors` example program for the available pointer shapes.
   #
   public native set_pointer(v)

   # Set the position of the window on the screen.  If the window is
   # currently hidden, then either `x` or `y` may be null, meaning
   # that the underlying window system will place the window at a
   # default position when it is unhidden.
   #
   # For a bordered window, the position normally refers to the
   # positon of the border rather than the client area.  However, this
   # is system dependent.
   #
   # After a call to `set_pos()` on an unhidden window, the value of
   # `get_pos()` will normally only be updated after a window system
   # event.
   #
   public native set_pos(x, y)

   # Set the x position of the window on the screen; see `set_pos()`.
   #
   public native set_x(v)

   # Set the y position of the window on the screen; see `set_pos()`.
   #
   public native set_y(v)

   # Configure whether the window can or cannot be resized by the
   # user.  The parameter should be a flag value.
   #
   public native set_resize(v)

   # Set the size of the window in pixels.
   #
   public native set_size(width, height)

   # Set the width of the window in pixels; see `set_size()`.
   #
   public native set_width(width)

   # Configure this window so that it is transient in respect of the
   # given window `w`.  This generally means that the transient window
   # stays on top of the other window, although the exact behaviour
   # depends on the window system.
   # 
   # When calling this method, this window must not be visible, and
   # the other window must be visible; if that is not the case this
   # method fails.
   #
   public native set_transient_for(w)

   # Produces a beep or other signal to attract attention.
   #
   public native alert(volume)

   # Sets the clipping region to the specified rectangle; subsequent
   # output extending outside its bounds is discarded. To disable
   # clipping, use `unclip()`.
   #
   public native clip(x, y, width, height)

   # Clear the clip settings
   #
   public native unclip()

   # Return the r,g,b values (plus possibly a if not opaque) of the
   # given color, as a color string
   #
   public static native color_value(k)

   # Return the r,g,b,a values of the given color string, as a `Color`
   # record.
   #
   public static parse_color(k)
      return Color!parse_color_impl(k)
   end

   private static native parse_color_impl(k)

   # Draw the given arc of an ellipse (centre `x`, `y`, major radius
   # `rx`, minor radius `ry`), starting at `angle1` radians (default
   # `0`), and going round clockwise `angle2` radians (default
   # `2*pi`).
   #
   public native draw_arc(x, y, rx, ry, angle1, angle2)

   # Return an event from this window, failing if none is available.
   #
   public native event()

   # Draw the given circle (centre `x`, `y` with radius `r`) between
   # the given angles `angle1` and `angle2`.
   #
   public draw_circle(x, y, r, angle1, angle2)
      return draw_arc(x, y, r, r, angle1, angle2)
   end

   # Draw a smooth curve through the given points `(x1,y1,...xN,yN)`.
   # At least 3 points (6 parameters) must be given.
   #
   public native draw_curve(a[])

   # Draw an image at `x`, `y`.  The image `v` can be raw image data,
   # a filename, or a `Pixels` instance.
   #
   public draw_image(x, y, v)
      return if is(v, Pixels) then
         draw_image_impl(x, y, v)
      else use {
         v := Pixels(v),
         draw_image_impl(x, y, v)
      }
   end

   private native draw_image_impl(x, y, pix)

   # Copy a rectangular area from this window to another window, `dest`, at `x2`.
   # `y2`.
   #
   public native copy_to(x1, y1, width, height, dest, x2, y2)

   # Draw a line through the points `(x1,y1,...xN,yN)`.  At least 2
   # points (4 parameters) must be given.
   #
   public native draw_line(a[])

   # Fill a single pixel at x, y
   #
   public draw_point(x, y)
      return fill_rectangle(x, y, 1, 1)
   end

   # Draw a polygon defined by the points `(x1,y1,...xN,yN)`.
   #
   public draw_polygon(a[])
      if *a > 1 then
         every put(a, a[1 | 2])
      return draw_line!a
   end

   # A boundary of the given thickness (default 1 pixel) is filled
   # inside the given rectangle, so that the area drawn is always
   # bounded by exactly that rectangle.  If the thickness is too wide
   # to leave a gap inside the rectangle, then the rectangle is simply
   # filled.
   #
   public native draw_rectangle(x, y, width, height, thickness)

   # Draw a string (or ucs) `s` at `x`, `y`.
   #
   public native draw_string(x, y, s)

   # Clear an area of the window by filling with the background
   # colour.
   #
   public native erase_area(x, y, width, height)

   # Return the window's event queue (a list) after bringing it
   # up-to-date with any events from the window system.
   #
   # The list may be edited to add events to the queue; in this case
   # the caller must ensure the addition makes sense, or a fatal error
   # will occur when `event` is called (see the function wgetevent in
   # rwindow.r for details).
   #
   public native pending()

   # Return the event code of the next event (without removing it), or
   # fail if there is no event available.  It will give the same
   # result as
   # ~
   #     pending()[1]
   # ~
   #
   public native peek()

   # Fill the given arc of an ellipse; the parameters are as for
   # `draw_arc()`.
   #
   public native fill_arc(x, y, rx, ry, angle1, angle2)

   # Fill the given circle (centre `x`, `y` with radius `r`) between
   # the given angles `angle1` and `angle2`.
   #
   public fill_circle(x, y, r, angle1, angle2)
      return fill_arc(x, y, r, r, angle1, angle2)
   end

   # Fill a polygon given by the points `(x1, y1, ...xN, yN)`.  At
   # least 3 points (6 parameters) must be given.
   #
   public native fill_polygon(a[])

   # Fill triangles defined by `(topx1, topy1, leftx1, lefty1,
   # rightx1, righty1, ...)`.
   #
   public native fill_triangles(a[])

   # Fill the given rectangle.
   #
   public native fill_rectangle(x, y, width, height)

   # Lower this window to the bottom of the window stack
   #
   public native lower()

   # Return the characters forming keys to palette p
   #
   public static native palette_chars(p)

   # Return color of key s2 in palette s1
   #
   public static native palette_color(s1, s2)

   # Return key of closest color to s2 in palette s1
   #
   public static native palette_key(s1, s2)

   # Get the default font for a window, as optionally specified with
   # the OI_FONT environment variable.
   #
   public static native get_default_font()

   # Get the default font size for a font, as optionally specified
   # with the OI_FONT_SIZE environment variable.
   #
   public static native get_default_font_size()

   # Return the `Pixels` format this window uses internally.
   #
   public native get_format()

   # Get the contents of some pixels as a `Pixels` object.
   #
   public get_pixels(x, y, width, height)
      return Pixels.create_for_ptr(get_pixels_impl(x, y, width, height))
   end

   private native get_pixels_impl(x, y, width, height)

   # Filter the given pixels according to the given filter spec.
   #
   public native filter(x, y, width, height, filter)

   # Return a `Rectangle` record, representing that part of the given
   # rectangle which would be drawable on the canvas; ie the
   # intersection of the rectangle, the window and the clip area if
   # set.  If the result would be an empty area, the method fails.
   #
   public drawable(x, y, width, height)
      return Rectangle!drawable_impl(x, y, width, height)
   end

   private native drawable_impl(x, y, width, height)

   # This is the same as `drawable`, but ignores the clip region.
   #
   public viewable(x, y, width, height)
      return Rectangle!viewable_impl(x, y, width, height)
   end

   private native viewable_impl(x, y, width, height)

   # Return the current root pointer position as a `Point` record.
   #
   public query_root_pointer()
      return Point!query_root_pointer_impl()
   end

   private native query_root_pointer_impl()

   # Return the current display size in pixels, as a `Size` record.
   #
   public get_display_size()
      return Size!get_display_size_impl()
   end

   private native get_display_size_impl()

   # Return the current display size in millimeters, as a `Size`
   # record.
   #
   public get_display_size_mm()
      return Size!get_display_size_mm_impl()
   end

   private native get_display_size_mm_impl()

   # Return the pointer's current position as a `Point` record,
   # relative to this window.
   #
   public query_pointer()
      return Point!query_pointer_impl()
   end

   private native query_pointer_impl()

   # Warp the pointer to the given location, relative to this window.
   #
   public native warp_pointer(x, y)

   # Raise window to the top of the window stack
   #
   public native raise()

   # Give the window the input focus
   #
   public native focus()

   #
   # Returns the width of string s, in pixels, as drawn using the
   # current font.
   #
   public native text_width(s)

   #
   # Set the window system's selection.  The value returned is an
   # integer, which should be the result of any future selection of
   # the TIMESTAMP property (this is relevant to X11 only).
   #
   public native own_selection(selection)

   #
   # Send a response to a selection request event.
   #
   public native send_selection_response(requestor, property, target, selection, data)

   #
   # Get the window system's selection
   #
   public native request_selection(selection, target_type)

   #
   # Define a custom pointer.  `name` is the name of the pointer, to
   # be used subsequently with `set_pointer()`.  `v` may be a `Pixels`
   # instance, a raw binary image data (eg a gif file), or the name of
   # a file containing an image.  `x` and `y` specify the pointer's
   # hotspot (such as the exact tip of an arrow cursor) and default to
   # zero.
   #
   public define_pointer(name, v, x, y)
      return if is(v, Pixels) then
         define_pointer_impl(name, v, x, y)
      else use {
         v := Pixels(v),
         define_pointer_impl(name, v, x, y)
      }
   end

   private native define_pointer_impl(name, v, x, y)

   # Make the destination pointer be the same as the src.
   # :Parameters :
   # :  `dest` - the destination name, which need not currently be defined
   # :  `src` - the current name.
   #
   public native copy_pointer(dest, src)

   # Close this binding to the window.  If no other bindings to the
   # same canvas exist, the underlying window is closed.
   #
   public override native close()

   # Return the absolute leading, which is the pixels equivalent of
   # the leading attribute.  It is the rounded value of the current
   # font height multiplied by the leading attribute.
   #
   public native get_absolute_leading()

   # Return the font height, which is always the sum of the font
   # ascent and the descent.
   #
   public get_font_height()
      return get_font_ascent() + get_font_descent()
   end

   # Return the line height, which is always the sum of the font
   # ascent, the font descent, and two amounts of the absolute leading
   # (notionally one for the top and one for the bottom of the line).
   # This sum is also equal to the line ascent plus the line descent.
   #
   public get_line_height()
      return get_font_ascent() + get_font_descent() + 2 * get_absolute_leading()
   end

   # Return the line ascent, which is the font ascent plus the
   # absolute leading.
   #
   public get_line_ascent()
      return get_font_ascent() + get_absolute_leading()
   end

   # Return the line descent, which is the font descent plus the
   # absolute leading.
   #
   public get_line_descent()
      return get_font_descent() + get_absolute_leading()
   end

   # Convenient method to open an image and return a hidden window with
   # its contents.
   # :Parameters :
   # :  `img` - the image
   #
   public static open_image(img)
      local w
      w := Window() | fail
      w.set_draw_op("source")
      w.set_image(img) | {
         w.close()
         fail
      }
      return w
   end
end

# Check that x is a `Window`, signalling a runtime error otherwise.
#
procedure need_Window(x)
   is(x, Window) | runerr("Window expected", x)
   return x
end

# Check that x is a `Pixels`, signalling a runtime error otherwise.
#
procedure need_Pixels(x)
   is(x, Pixels) | runerr("Pixels expected", x)
   return x
end

#
# Event codes for selection events.
#
final abstract class Selection()
   public static const
      # Selection request event
      REQUEST,     
      # Selection response event
      RESPONSE,
      # Selection clear event
      CLEAR,
      # Set of any of the three event types
      EVENTS,
      PRIMARY,
      SECONDARY,
      CLIPBOARD,
      UTF8_STRING_TARGET,
      STRING_TARGET,
      TIMESTAMP_TARGET,
      URI_LIST_TARGET,
      TARGETS_TARGET

   private static init()
      REQUEST := -30
      CLEAR := -31
      RESPONSE := -32
      EVENTS := set(REQUEST, CLEAR, RESPONSE)
      PRIMARY := "PRIMARY"      # These 3 must correspond to X Atom names.
      SECONDARY := "SECONDARY"
      CLIPBOARD := "CLIPBOARD"
      STRING_TARGET := "STRING"
      UTF8_STRING_TARGET := "UTF8_STRING"
      URI_LIST_TARGET := "text/uri-list"
      TIMESTAMP_TARGET := "TIMESTAMP"
      TARGETS_TARGET := "TARGETS"
   end
end

#
# Event codes for mouse events.
#
final abstract class Mouse()
   public static const
      LEFT_PRESS,
      MIDDLE_PRESS,
      RIGHT_PRESS,
      PRESS,
      LEFT_RELEASE,
      MIDDLE_RELEASE,
      RIGHT_RELEASE,
      RELEASE,
      DRAG,
      MOVEMENT,
      WHEEL_UP,
      WHEEL_DOWN,
      WHEEL_LEFT,
      WHEEL_RIGHT,
      WHEEL,
      DRAG_OR_MOVEMENT,
      ENTER,
      EXIT,
      CROSSING

   private static init()
      LEFT_PRESS :=           -1
      MIDDLE_PRESS :=         -2
      RIGHT_PRESS :=          -3
      PRESS := set(LEFT_PRESS, MIDDLE_PRESS, RIGHT_PRESS)
      LEFT_RELEASE :=         -4
      MIDDLE_RELEASE :=       -5
      RIGHT_RELEASE :=        -6
      RELEASE := set(LEFT_RELEASE, MIDDLE_RELEASE, RIGHT_RELEASE)
      MOVEMENT :=            -12
      WHEEL_UP :=            -16
      WHEEL_DOWN :=          -17
      WHEEL_LEFT :=          -21
      WHEEL_RIGHT :=         -22
      WHEEL := set(WHEEL_UP, WHEEL_DOWN, WHEEL_LEFT, WHEEL_RIGHT)
      ENTER :=               -18
      EXIT :=                -19
      CROSSING := set(ENTER, EXIT)
      DRAG :=                -20
      DRAG_OR_MOVEMENT := set(DRAG, MOVEMENT)
   end
end

#
# Event codes for key events.
#
final abstract class Key()
   public static const
      # Modifier flags
      MOD_SHIFT,
      MOD_LOCK,
      MOD_CTRL,
      MOD_META,
      MOD_META2,
      MOD_META3,
      MOD_META4,
      MOD_META5,
      MOD_RELEASE,
      # Key event codes
      SHIFT_TAB,
      COMPOSE,
      DO,
      DOWN,
      END,
      F1,
      F2,
      F3,
      F4,
      F5,
      F6,
      F7,
      F8,
      F9,
      F10,
      F11,
      F12,
      F13,
      F14,
      F15,
      F16,
      F17,
      F18,
      F19,
      F20,
      F21,
      F22,
      F23,
      F24,
      FIND,
      HELP,
      HOME,
      INSERT,
      KP_DOWN,
      KP_LEFT,
      KP_RIGHT,
      KP_UP,
      KP_HOME,
      KP_PRIOR,
      KP_BEGIN,
      KP_END,
      KP_NEXT,
      KP_INSERT,
      KP_DELETE,
      L1,
      L2,
      L3,
      L4,
      L5,
      L6,
      L7,
      L8,
      L9,
      L10,
      LEFT,
      PF1,
      PF2,
      PF3,
      PF4,
      PAUSE,
      PGDN,
      PGUP,
      PRSC,
      R1,
      R2,
      R3,
      R4,
      R5,
      R6,
      R7,
      R8,
      R9,
      R10,
      R11,
      R12,
      R13,
      R14,
      R15,
      RIGHT,
      SCROLL_LOCK,
      SELECT,
      UP,
      CURSOR,
      CURSOR_V,
      CURSOR_H,
      SUPER_L,
      SUPER_R,
      MENU,
      NAVIGATE,
      SHIFT_L,
      SHIFT_R,
      CONTROL_L,
      CONTROL_R,
      CAPS_LOCK,
      SHIFT_LOCK,
      NUM_LOCK,
      META_L,
      META_R,
      ALT_L,
      ALT_R,
      HYPER_L,
      HYPER_R,
      BROWSER_BACK,
      BROWSER_FORWARD,
      BROWSER_STOP,
      BROWSER_REFRESH,
      BROWSER_SEARCH,
      BROWSER_FAVORITES,
      BROWSER_HOME,
      LAUNCH_MAIL,
      VOLUME_MUTE,
      VOLUME_DOWN,
      VOLUME_UP,
      MEDIA_PLAY_PAUSE,
      MEDIA_STOP,
      MEDIA_PREV_TRACK,
      MEDIA_NEXT_TRACK,
      LAUNCH_MEDIA_SELECT,
      LAUNCH_APP1,
      LAUNCH_APP2,
      SLEEP

   private static init()
      MOD_SHIFT :=    1
      MOD_LOCK :=     2
      MOD_CTRL :=     4
      MOD_META :=     8 
      MOD_META2 :=   16
      MOD_META3 :=   32
      MOD_META4 :=   64
      MOD_META5 :=   128
      MOD_RELEASE := 256
$if _X_WINDOW_SYSTEM
      SHIFT_TAB :=           65056
      COMPOSE :=             65312
      DO :=                  65383
      DOWN :=                65364
      END :=                 65367
      F1 :=                  65470
      F2 :=                  65471
      F3 :=                  65472
      F4 :=                  65473
      F5 :=                  65474
      F6 :=                  65475
      F7 :=                  65476
      F8 :=                  65477
      F9 :=                  65478
      F10 :=                 65479
      F11 :=                 65480
      F12 :=                 65481
      F13 :=                 65482
      F14 :=                 65483
      F15 :=                 65484
      F16 :=                 65485
      F17 :=                 65486
      F18 :=                 65487
      F19 :=                 65488
      F20 :=                 65489
      F21 :=                 65490
      F22 :=                 65491
      F23 :=                 65492
      F24 :=                 65493
      FIND :=                65384
      HELP :=                65386
      HOME :=                65360
      INSERT :=              65379
      KP_DOWN :=             65433
      KP_LEFT :=             65430
      KP_RIGHT :=            65432
      KP_UP :=               65431
      KP_HOME :=             65429
      KP_PRIOR :=            65434
      KP_BEGIN :=            65437
      KP_END :=              65436
      KP_NEXT :=             65435
      KP_INSERT :=           65438
      KP_DELETE :=           65439
      L1 :=                  65480  # clash with f11
      L2 :=                  65481  # clash with f12
      L3 :=                  65482
      L4 :=                  65483
      L5 :=                  65484
      L6 :=                  65485
      L7 :=                  65486
      L8 :=                  65487
      L9 :=                  65488
      L10 :=                 65489
      LEFT :=                65361
      PF1 :=                 65425
      PF2 :=                 65426
      PF3 :=                 65427
      PF4 :=                 65428
      PAUSE :=               65299
      PGDN :=                65366
      PGUP :=                65365
      PRSC :=                65377
      R1 :=                  65490
      R2 :=                  65491
      R3 :=                  65492
      R4 :=                  65493
      R5 :=                  65494
      R6 :=                  65495
      R7 :=                  65496
      R8 :=                  65497
      R9 :=                  65498
      R10 :=                 65499
      R11 :=                 65500
      R12 :=                 65501
      R13 :=                 65502
      R14 :=                 65503
      R15 :=                 65504
      RIGHT :=               65363
      SCROLL_LOCK :=         65300
      SELECT :=              65376
      UP :=                  65362
      SUPER_L :=             65515
      SUPER_R :=             65516
      MENU :=                65383
      SHIFT_L :=             65505
      SHIFT_R :=             65506
      CONTROL_L :=           65507
      CONTROL_R :=           65508
      CAPS_LOCK :=           65509
      SHIFT_LOCK :=          65510
      META_L :=              65511
      META_R :=              65512
      ALT_L :=               65513
      ALT_R :=               65514
      HYPER_L :=             65517
      HYPER_R :=             65518
      NUM_LOCK :=            65407
      BROWSER_BACK :=        269025062
      BROWSER_FORWARD :=     269025063
      BROWSER_STOP :=        65385
      BROWSER_REFRESH :=     269025139
      BROWSER_SEARCH :=      269025051
      BROWSER_FAVORITES :=   269025072
      BROWSER_HOME :=        269025048
      LAUNCH_MAIL :=         269025049
      VOLUME_MUTE :=         269025042
      VOLUME_DOWN :=         269025041
      VOLUME_UP :=           269025043
      MEDIA_PLAY_PAUSE :=    269025044
      MEDIA_STOP :=          269025045
      MEDIA_PREV_TRACK :=    269025046
      MEDIA_NEXT_TRACK :=    269025047
      LAUNCH_MEDIA_SELECT := 269025153
      LAUNCH_APP1 :=         269025117
      LAUNCH_APP2 :=         269025053
      SLEEP :=               269025071

$elsif _MS_WIN32
      DOWN :=               40
      END :=                35
      SCROLL_LOCK :=        145
      F1 :=                 112
      F2 :=                 113
      F3 :=                 114
      F4 :=                 115
      F5 :=                 116
      F6 :=                 117
      F7 :=                 118
      F8 :=                 119
      F9 :=                 120
      F10 :=                121
      F11 :=                122
      F12 :=                123
      F13 :=                124
      F14 :=                125
      F15 :=                126
      F16 :=                127
      F17 :=                128
      F18 :=                129
      F19 :=                130
      F20 :=                131
      F21 :=                132
      F22 :=                133
      F23 :=                134
      F24 :=                135
      HELP :=               47
      HOME :=               36
      INSERT :=             45
      LEFT :=               37
      PAUSE :=              19
      PGDN :=               34
      PGUP :=               33
      PRSC :=               44
      RIGHT :=              39
      SELECT :=             41
      UP :=                 38
      SHIFT_TAB :=          0
      COMPOSE :=            0
      DO :=                 93
      FIND :=               0
      KP_DOWN :=            0
      KP_LEFT :=            0
      KP_RIGHT :=           0
      KP_UP :=              0
      L1 :=                 0
      L2 :=                 0
      L3 :=                 0
      L4 :=                 0
      L5 :=                 0
      L6 :=                 0
      L7 :=                 0
      L8 :=                 0
      L9 :=                 0
      L10 :=                0
      PF1 :=                0
      PF2 :=                0
      PF3 :=                0
      PF4 :=                0
      R1 :=                 0
      R2 :=                 0
      R3 :=                 0
      R4 :=                 0
      R5 :=                 0
      R6 :=                 0
      R7 :=                 0
      R8 :=                 0
      R9 :=                 0
      R10 :=                0
      R11 :=                0
      R12 :=                0
      R13 :=                0
      R14 :=                0
      R15 :=                0
      HYPER_L :=            0
      HYPER_R :=            0
      KP_BEGIN :=           0
      KP_END :=             0
      KP_HOME :=            0
      KP_NEXT :=            0
      KP_PRIOR :=           0
      KP_INSERT :=          0
      KP_DELETE :=          0
      META_L :=             0
      META_R :=             0
      SHIFT_LOCK :=         0
      CAPS_LOCK :=          20
      SHIFT_L :=            16
      SHIFT_R :=            16
      SUPER_L :=            91
      SUPER_R :=            92
      MENU :=               93
      CONTROL_L :=          17
      CONTROL_R :=          17
      ALT_L :=              18
      ALT_R :=              0
      NUM_LOCK :=           144
      BROWSER_BACK :=       166
      BROWSER_FORWARD :=    167
      BROWSER_STOP :=       169
      BROWSER_REFRESH :=    168
      BROWSER_SEARCH :=     170
      BROWSER_FAVORITES :=  171
      BROWSER_HOME :=       172
      LAUNCH_MAIL :=        180
      VOLUME_MUTE :=        173
      VOLUME_DOWN :=        174
      VOLUME_UP :=          175
      MEDIA_PLAY_PAUSE :=   179
      MEDIA_STOP :=         178
      MEDIA_PREV_TRACK :=   177
      MEDIA_NEXT_TRACK :=   176
      LAUNCH_MEDIA_SELECT := 181
      LAUNCH_APP1 :=        182
      LAUNCH_APP2 :=        183
      SLEEP :=               95

$endif
      NAVIGATE := set(UP, DOWN, LEFT, RIGHT, PGUP, PGDN, HOME, END)
      CURSOR := set(UP, DOWN, LEFT, RIGHT)
      CURSOR_V := set(UP, DOWN)
      CURSOR_H := set(LEFT, RIGHT)
   end
end

#
# This class provides symbolic names for the drawing operations
# supported by `Window.set_draw_op()`.
#
final abstract class DrawOp()
   public static const
      ATOP,
      CLEAR,
      DEST,
      DEST_ATOP,
      DEST_IN,
      DEST_OUT,
      DEST_OVER,
      IN,
      OUT,
      OVER,
      SOURCE,
      XOR

   private static init()
      ATOP := "atop"
      CLEAR := "clear"
      DEST := "dest"
      DEST_ATOP := "dest atop"
      DEST_IN := "dest in"
      DEST_OUT := "dest out"
      DEST_OVER := "dest over"
      IN := "in"
      OUT := "out"
      OVER := "over"
      SOURCE := "source"
      XOR := "xor"
   end
end

#
# This class provides symbolic names for the styles supported by
# `Window.set_line_end()`.
#
final abstract class LineEnd()
   public static const
      FLAT,
      ROUND,
      SQUARE,
      POINT

   private static init()
      FLAT := "flat"
      ROUND := "round"
      SQUARE := "square"
      POINT := "point"
   end
end

#
# This class provides symbolic names for the styles supported by
# `Window.set_line_join()`.
#
final abstract class LineJoin()
   public static const
      BEVEL,
      MITER,
      ROUND

   private static init()
      BEVEL := "bevel"
      MITER := "miter"
      ROUND := "round"
   end
end

#
# This class provides symbolic names for the canvas types supported by
# `Window.set_canvas()`.
#
final abstract class Canvas()
   public static const
      FULLSCREEN,
      HIDDEN,
      ICONIC,
      MAXIMIZED,
      NORMAL,
      POPUP,
      ROOT,
      WITHDRAWN

   private static init()
      FULLSCREEN := "fullscreen"
      HIDDEN := "hidden"
      ICONIC := "iconic"
      MAXIMIZED := "maximized"
      NORMAL := "normal"
      POPUP := "popup"
      ROOT := "root"
      WITHDRAWN := "withdrawn"
   end
end

#
# This class provides symbolic names for the pattern names supported
# by `Window.set_textured_pattern()` and  `Window.set_masked_pattern()`.
#
final abstract class Pattern()
   public static const
      BLACK,
      VERY_DARK,
      DARK_GRAY,
      GRAY,
      LIGHT_GRAY,
      VERY_LIGHT,
      WHITE,
      VERTICAL,
      DIAGONAL,
      HORIZONTAL,
      GRID,
      TRELLIS,
      CHECKERS,
      GRAINS,
      SCALES,
      WAVES

   private static init()
      BLACK := "black"
      VERY_DARK := "verydark"
      DARK_GRAY := "darkgray"
      GRAY := "gray"
      LIGHT_GRAY := "lightgray"
      VERY_LIGHT := "verylight"
      WHITE := "white"
      VERTICAL := "vertical"
      DIAGONAL := "diagonal"
      HORIZONTAL := "horizontal"
      GRID := "grid"
      TRELLIS := "trellis"
      CHECKERS := "checkers"
      GRAINS := "grains"
      SCALES := "scales"
      WAVES := "waves"
   end
end
