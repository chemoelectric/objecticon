package io

import 
   lang,
   util,
   posix,
   ipl.random

#
# This class has several static methods which provide
# system-independent access to the file system.
#
final abstract class Files()
   private static const 
      FS

   public static const 
      # The end-of-line sequence
      EOL,
      # The separator for elements of a path
      PATH_SEPARATOR,
      # A cset, being the non-filename characters which may appear in a path
      PATH_SPECIALS,
      # The separator for individual paths in a list of paths (such as the PATH
      # environment variable).
      PATHS_SEPARATOR

   private static init()
$ifdef _UNIX
      EOL := "\n"
      PATH_SEPARATOR := "/"
      PATH_SPECIALS := '/'
      PATHS_SEPARATOR := ":"
      FS := UnixFileSystem()
$elsifdef _MS_WIN32
      EOL := "\r\n"
      PATH_SEPARATOR := "\\"
      PATH_SPECIALS := ':\\/'
      PATHS_SEPARATOR := ";"
      FS := WindowsFileSystem()
$else
      runerr("Can't init_file_system: unknown o/s type")
$endif
   end

   #
   # Read the given directory returning a list of [name, {Stat}] pairs.
   #
   public static list(s)
      local p
      return use {
         p := DirStream(s),
         list1(get_path(s), p)
      }
   end

   private static list1(path, p)
      local l, s, cpath
      l := []
      repeat {
         s := p.read_line() | fail
         if /s then
            return l
         cpath := path.child(s)
         put(l, [s, lstat(cpath.str())]) |
            return error("Couldn't lstat " || cpath.str() || ": " || &why)
      }
   end

   #
   # Return a {FilePath} corresponding to the given path in string
   # form.
   #
   public static get_path(s)
      return FS.get_path(s)
   end

   #
   # Return a {FilePath} corresponding to the elements in the given
   # list.
   #
   public static get_path_from_list(l)
      return FS.get_path_from_list(default.copy(l))
   end

   #
   # Return the home directory.
   #
   public static get_home()
      return FS.get_home()
   end

   #
   # Return the temporary directory.
   #
   public static get_temp()
      return FS.get_temp()
   end

   #
   # Succeed iff the given file is hidden.
   #
   public static is_hidden(s)
      return FS.is_hidden(s)
   end

   #
   # Succeed iff the given file is a relative directory name (on Unix,
   # "." or "..").
   #
   public static is_relative_dir(s)
      return FS.is_relative_dir(s)
   end

   #
   # Get the roots of the file system.
   #
   public static get_roots()
      suspend FS.get_roots()
   end

   #
   # Split a list of paths (such as the $PATH variable) into its
   # constituent elements.
   #
   public static split_paths(s)
      suspend FS.split_paths(s)
   end

   #
   # Load a file into a string
   #
   public static file_to_string(fn)
      local f
      return use {
         f := FileStream(fn, FileOpt.RDONLY),
         f.read_all()
      }
   end

   #
   # Write a string to a file.
   #
   public static string_to_file(fn, s)
      local f
      return use {
         f := FileStream(fn, ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT)),
         f.writes(s)
      }
   end

   #
   # Make a temporary filename.
   # @param prefix, by default empty
   # @param suffix, by default empty
   # @param path, the directory, by default {get_temp()}
   # @param len, the number of digits in the result, default 8
   #
   public static make_temp_filename(prefix, suffix, path, len)
      local p, name, f

      /prefix := ""
      /suffix := ""
      /path := get_temp()
      /len := 8

      randomize()

      p := get_path(path)
      repeat {
         ?1                                # change &random
         name := p.child(prefix || left(&random, len, "0") || suffix).str()
         if not access(name) then {
            # Touch the filename to stop anyone else using it.
            f := FileStream(name, ior(FileOpt.WRONLY, FileOpt.CREAT)) | fail
            f.close()
            return name
         }
      }
   end

   #
   # Succeed iff the two given files have the same content.
   #
   public static equal_files(s1, s2)
      local f1, f2
      stat(s1).size = stat(s2).size | fail
      return use {
         f1 := FileStream(s1, FileOpt.RDONLY),
         use {
            f2 := FileStream(s2, FileOpt.RDONLY),
            equal_files1(f1, f2)
         }
      }
   end

   private static equal_files1(f1, f2)
      local b1, b2
      repeat {
         b1 := f1.in(1048576) | fail
         if /b1 then 
            break
         b2 := f2.read_exactly(*b1) | fail
         b1 === b2 | fail
      }
      # f1 is at eof, and a further read of f2 should be at eof.
      return /f2.in(1)
   end

   #
   # Succeed iff the given file is a directory.
   #
   public static is_directory(s)
      return stat(s).mode_str[1] == "d"
   end

   #
   # Move a file.  First, try to move it by renaming it.  If that
   # fails, try to copy the file then delete the original, or if that
   # fails, fail.
   #
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static move(s1, s2)
      if rename(s1, s2) then
         return
      copy(s1, s2) | fail
      return remove(s1)
   end

   #
   # Rename a file.
   #
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static native rename(s1, s2)

   #
   # Create a (hard) link to a file.
   #
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static native hardlink(s1, s2)

   #
   # Create a symlink to a file.
   #
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static native symlink(s1, s2)

   #
   # Read a symbolic link
   #
   # @param s the source filename
   #
   public static native readlink(s)

   #
   # Return the canonicalized absolute pathname as produced by the
   # POSIX realpath function.
   #
   # @param s a filename
   #
   public static native realpath(s)

   #
   # Changes the current directory to that specified in s.
   #
   # @param s the directory
   #
   public static native chdir(s)

   #
   # Get current working directory
   #
   public static native getcwd()

   #
   # Remove a regular file
   #
   # @param s the file
   #
   public static native remove(s)

   #
   # Remove an empty directory
   #
   # @param s the empty directory
   #
   public static native rmdir(s)

   #
   # Make a new directory
   #
   # @param s the directory path
   # @param perm the permission bits, defaults to rwxr-xr-x
   #
   public static native mkdir(s, perm)

   #
   # Truncate the given file to {len} bytes.
   #
   # @param s1 the source filename
   # @param len the desired length
   #
   public static native truncate(s, len)

   #
   # Obtain information about the given file
   #
   # @param s the file
   # @return a {Stat} object
   #
   public static stat(s)
      return Stat!stat_impl(s)
   end

   private static native stat_impl(s)

   #
   # Obtain information about the given file without following
   # symlinks.
   #
   # @param s the file
   # @return a {Stat} object
   #
   public static lstat(s)
      return Stat!lstat_impl(s)
   end

   private static native lstat_impl(s)

   #
   # Write selected attributes about a file.  If any of the parameters
   # are {&null}, they are left unchanged.
   #
   # @param s the file
   # @param mode the mode (an integer)
   # @param uid the owner id
   # @param gid the group id
   # @param atime the access time (an integer)
   # @param mtime the modification time (an integer)
   #
   public static native wstat(s, mode, uid, gid, atime, mtime)

   #
   # Check whether the given file can be accessed in the given mode.
   #
   public static native access(s, mode)

   #
   # Copy a file.
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static copy(s1, s2)
      local f1, f2
      return use {
         f1 := FileStream(s1, FileOpt.RDONLY),
         use {
            f2 := FileStream(s2, ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT)),
            f1.copy_to(f2)
         }
      }
   end

   #
   # Append file {s1} onto {s2}.
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static append(s1, s2)
      local f1, f2
      return use {
         f1 := FileStream(s1, FileOpt.RDONLY),
         use {
            f2 := FileStream(s2, ior(FileOpt.WRONLY, FileOpt.APPEND, FileOpt.CREAT)),
            f1.copy_to(f2)
         }
      }
   end

   #
   # Given a stem filename, return another unique filename based upon it.
   #
   public static ensure_unique_filename(stem)
      local i, p, s
      access(stem) | return stem
      i := 1
      every p := find(".", stem)
      repeat {
         s := stem
         if /p then
            s ||:= "_" || i
         else
            s[p] := "_" || i || s[p]
         access(s) | return s
         i +:= 1
      }
   end

   #
   # This procedure searches for a file on a environment-defined path.
   # It follows the same logic as the C function pathfind() in
   # mlocal.c
   #
   # @param f the file to look for
   # @param n the name of the environment variable holding the path
   # @param cd the current directory; if &null then the "real" cd
   # @param mode the access mode to check for; by default {Access.F_OK}
   #
   public static path_find(f, n, cd, mode)
      local p, s
      /mode := Access.F_OK
      p := get_path(f)

      # Don't search the path if we have an absolute file
      if p.is_absolute() then {
         s := p.str()
         if access(s, mode) then
            return s
         else
            fail
      }

      # Also don't search if we have a relative name; it is relative to
      # the cd
      if p.size() > 1 then {
         # Prepend cd if given
         s := get_path(\cd).append(p).str() | p.str()
         if access(s, mode) then
            return s
         else
            fail
      }

      # Neither absolute nor relative.  Try current directory first
      s := get_path(\cd).append(p).str() | p.str()
      if access(s, mode) then
         return s

      # Search all the elements in the path
      every s := get_path(split_paths(System.getenv(\n))).append(p).str() do {
         if access(s, mode) then
            return s
      }
   end

   # Find absolute executable, searching $PATH (using POSIX 1003.2
   # rules) for executable name.  The method is similar to path_find above,
   # but a little more strict.  In particular, the cd isn't tried before
   # the directories on $PATH.
   #
   # @param n the name of the environment variable holding the path,
   # @        by default "PATH"
   # @param mode the access mode to check for; by default {Access.X_OK}
   public static find_exe(f, n, mode)
      local p, s, path

      /n := "PATH"
      /mode := Access.X_OK
      p := get_path(f)

      # Anything with separators in, we just look up and ignore the
      # path.
      if p.is_absolute() | (p.size() > 1) then {
         s := p.str()
         if access(s, mode) then
            return s
         else
            fail
      }

      # Search all the elements in the path
      path := System.getenv(n) | ""
      every s := get_path(split_paths(path)).append(p).str() do {
         if access(s, mode) then
            return s
      }
   end

   #
   # Search for a native (.so) library on the OINATIVE path.
   #
   public static find_native_lib(f)
      static seen
      local t
      initial
         seen := table()
      if t := member(seen, f) then
         return t
      if t := find_exe(f, "OINATIVE") then {
         insert(seen, f, t)
         return t
      }
      &why := f || " not found on OINATIVE path"
   end
end

#
# This class provides implementations of some of the methods in
# {Files}.  It is not used directly by clients.
#
abstract class FileSystem()
   public abstract get_path(s)

   public abstract get_path_from_list(l)

   public abstract get_home()

   public abstract get_temp()

   public abstract is_hidden(s)

   public abstract is_relative_dir(s)

   public abstract get_roots()

   public abstract split_paths(s)
end

#
# This class manipulates file paths by treating them as a list of
# elements.  Instances are not created directly by the client, rather
# they are created initially via {Files.get_path()} and then via other
# methods in this class.
#
# Instances of this class are immutable.
#
abstract class FilePath(ObjectOutput)
   protected l

   #
   # Return the number of elements in the path.
   #
   public size()
      return *l
   end

   #
   # Return the {i}th element in the path.
   #
   public get(i)
      return .l[i]
   end

   #
   # Generate the elements in the path.
   #
   public gen()
      suspend .!l
   end

   #
   # Return the path formed by appending the elements of this path to
   # the other path.
   #
   public append(other)
      return classof(self)(l ||| other.l)
   end

   #
   # Return the parent path, ie a path with everything but the last
   # element.  Fails if the path has no elements.
   #
   public parent()
      return classof(self)(l[1:-1])
   end

   private object_output(oo)
      oo.object_string(self, str())
   end

   #
   # Return the child path, ie a path with the same elements plus the
   # element {s}.
   #
   public child(s)
      return classof(self)(l ||| [s])
   end

   #
   # Return the sibling path, ie a path with the same elements, except the
   # last one, which is replaced by {s}.  Fails if the path has no elements.
   #
   public sibling(s)
      local t
      t := copy(l)
      t[-1] := s | fail
      return classof(self)(t)
   end

   #
   # Return a path which represents the absolute path of this
   # path.
   #
   public abstract absolute()

   #
   # Convert the path back into a string.
   #
   public abstract str()

   #
   # Succeed iff this path represents an absolute path.
   #
   public abstract is_absolute()

   #
   # Canonicalize a path, which means trying to turn it into a
   # standard form.  This involves (at least) getting the absolute
   # path and removing any redundant path elements.
   #
   public abstract canonical()

   package new(l)
      self.l := l
      return
   end
end

#
# This class represents file stat information.
#
class Stat()
   public const 
      dev,
      ino,
      mode,
      mode_str,
      nlink,
      uid,
      gid,
      rdev,
      size,
      blksize,
      blocks,
      atime,
      mtime,
      ctime

   package new(dev,
               ino,
               mode,
               mode_str,
               nlink,
               uid,
               gid,
               rdev,
               size,
               blksize,
               blocks,
               atime,
               mtime,
               ctime)
      self.dev := dev
      self.ino := ino
      self.mode := mode
      self.mode_str := mode_str
      self.nlink := nlink
      self.uid := uid
      self.gid := gid
      self.rdev := rdev
      self.size := size
      self.blksize := blksize
      self.blocks := blocks
      self.atime := atime
      self.mtime := mtime
      self.ctime := ctime
      return
   end
end

class UnixFilePath(FilePath)
   public str()
      local e, s
      s := ""
      every e := !l do {
         if s[-1] ~== "/" then 
            s ||:= "/"
         s ||:= e
      }
      return s
   end

   public is_absolute()
      return l[1] == "/"
   end

   public absolute()
      if is_absolute() then
         return self
      return Files.get_path(Files.getcwd()).append(self)
   end

   public canonical()
      local e, r
      r := []
      every e := !absolute().l do {
         if e == "." then
            next
         else if e == ".." then {
            # /.. -> /
            if r[-1] ~== "/" then
               pull(r)
         } else
            put(r, e)
      }
      return UnixFilePath(r)
   end
end

class UnixFileSystem(FileSystem)
   public get_path(s)
      local l, t
      l := []
      s ? {
         put(l, ="/")
         until pos(0) do {
            t := tab(upto('/') | 0)
            if *t > 0 then
               put(l, t)
            move(1)
         }
      }
      return UnixFilePath(l)
   end

   public get_path_from_list(l)
      return UnixFilePath(l)
   end

   public get_home()
      return System.getenv("HOME")
   end

   public get_temp()
      return System.getenv("TEMP") | "/tmp"
   end

   public is_hidden(s)
      return any('.', s)
   end

   public is_relative_dir(s)
      return s == ("." | "..")
   end

   public get_roots()
      return "/"
   end

   public split_paths(s)
      local t
      s ? repeat {
         t := tab(upto(':') | 0)
         if *t = 0 then
            t := "."
         suspend t
         move(1) | break
      }
   end
end

class WindowsFilePath(FilePath)
   public str()
      local e, s
      s := ""
      every e := !l do {
         if *s > 0 & not any("\\:", s[-1]) then
            s ||:= "\\"
         s ||:= e
      }
      return s
   end

   public is_absolute()
      return l[1] == "\\\\" | l[1][2:0] == ":\\"
   end

   public absolute()
      local s
      if is_absolute() then
         return self
      if l[1] == "\\" then
         return WindowsFilePath([Files.getcwd()[1:4]] ||| l[2:0])
      if l[1][2:0] == ":" then {
         s := getdcwd(l[1][1]) | l[1] || "\\"
         return Files.get_path(s).append(WindowsFilePath(l[2:0]))
      }
      return Files.get_path(Files.getcwd()).append(self)
   end

   private static native getdcwd(d)

   public canonical()
      local e, r
      r := []
      every e := !absolute().l do {
         if e == "." then
            next
         else if e == ".." then {
            # Avoid, eg, c:\.. -> empty; c:\.. is in fact invalid.
            if *r > 1 then
               pull(r)
         } else
            put(r, map(e))
      }
      return WindowsFilePath(r)
   end
end

class WindowsFileSystem(FileSystem)
   public get_path(s)
      local l, t
      l := []
      s := map(s, "/", "\\")
      s ? {
         if &subject[2:4] == ":\\" then       # X:\
            put(l, move(3))
         else if &subject[2] == ":" then      # X:
            put(l, move(2))
         else if &subject[1:3] == "\\\\" then # \\X
            put(l, move(2))
         else if &subject[1] == "\\" then     # \X
            put(l, move(1))                
         until pos(0) do {
            t := tab(upto('\\') | 0)
            if *t > 0 then
               put(l, t)
            move(1)
         }
      }
      return WindowsFilePath(l)
   end

   public get_path_from_list(l)
      return WindowsFilePath(l)
   end

   public get_home()
      return System.getenv("HOME")
   end

   public get_temp()
      return System.getenv("TEMP") | "C:\\TEMP"
   end

   public is_hidden(s)
   end

   public is_relative_dir(s)
      return s == ("." | "..")
   end

   public native get_roots()

   public split_paths(s)
      local t
      s ? repeat {
         t := tab(upto(';') | 0)
         if *t = 0 then
            t := "."
         suspend t
         move(1) | break
      }
   end
end
