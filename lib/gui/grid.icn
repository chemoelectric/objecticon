package gui

import 
   util, 
   lang,
   ipl.sort,
   io

class CellInfo(Insets,Align)
   public 
      obj,            # An arbitrary object 
      grid,           # The grid we're in
      ax,             # Actual computed pixel location and size,
      ay,             # within insets, ie where to draw the thing
      aw,             # inside the cell.
      ah,
      s,              # Identifying string for print_layout
      x,              # Location, size in grid units.
      y, 
      w, 
      h, 
      dw,             # Desired cell width including insets
      dh, 
      pw,             # Preferred cell width excluding insets
      ph, 
      x_fill,         # Constraints: fill, align, weights, insets
      y_fill,
      x_weight,
      y_weight

   #
   # Output object
   #
   private object_output(oo)
      local t
      t := s || ": "
      t ||:= " pos=" || self.x || "," || self.y || " dim=" || self.w || "," || self.h ||
         " component pref size=" || pw || "," || ph
      t ||:= "\n\tcell desired size=" || dw || "," || dh
      t ||:= " located to=" || \ax || "," || \ay || " size set to " || \aw || "," || \ah

      t ||:= " \n\tfill=" || image(x_fill) || "," || image(y_fill) || 
         " weight=" || x_weight || "," || y_weight ||
         " align=" || image(x_align) || "," || image(y_align) ||
         " insets=l:" || l_inset || " t:" || t_inset || " r:" || r_inset || " b:" || b_inset
      oo.object_string(self, t)
   end
end

class Grid()
   public static const 
      EXTRA_CELLS,
      EXTRA_BORDERS,
      EXTRA_IGNORE

   public 
      gw,           # Grid width, height in cells
      gh, 
      p_col_w,      # Preferred column widths/row heights
      p_row_h,
      a_col_w,      # Actual column widths/row heights after extra
      a_row_h,      # space has been allocated
      col_x,        # Actual row x and y values
      row_y,
      col_weights,  # Column/row weights.
      row_weights,
      info,         # List of CellInfo for each component being laid out
      dii,          # Default inner padding, ie not at edge of grid
      doi,          # Default outer padding
      extra,        # Flag indicating how to allocate extra space
      pad_w,        # Padding to the left of the grid
      pad_h,        # Padding above the grid
      id_str,       # For generating CellInfo string ids for debug
      add_x,        # For auto-computing cell position and sizes.
      add_y,
      add_row_h

   private static validate_int(t, key, def)
      local val
      if val := member(t, key) then
         return integer(val) | runerr("Expected integer grid constraint", val)
      else
         return \def
   end

   private static validate_real(t, key, def)
      local val
      if val := member(t, key) then
         return real(val) | runerr("Expected real-valued grid constraint", val)
      else
         return \def
   end

   private static validate_flag(t, key)
      local val
      if val := member(t, key) then
         return check_flag(val) | runerr("Expected flag-valued grid constraint", val)
      else
         return &no
   end

   private static validate_x_align(t, key)
      local val
      if val := member(t, key) then {
         (val === (Align.L | Align.R | Align.C)) | runerr("Expected x-alignment grid constraint", val)
         return val
      }
      else
         return Align.C
   end

   private static validate_y_align(t, key)
      local val
      if val := member(t, key) then {
         (val === (Align.T | Align.B | Align.C)) | runerr("Expected y-alignment grid constraint", val)
         return val
      }
      else
         return Align.C
   end

   public create_cell(t)
      local ci
      ci := CellInfo()
      ci.grid := self
      ci.s := id_str[1]
      id_str[1] := ""
      self.add_x +:= validate_int(t, "x_tab")
      if self.add_y +:= validate_int(t, "y_tab") then
         add_row_h := 0
      ci.x := validate_int(t, "x", add_x)
      ci.y := validate_int(t, "y", add_y)
      ci.w := validate_int(t, "w", 1)
      ci.h := validate_int(t, "h", 1)
      add_row_h <:= ci.h
      if /validate_flag(t, "eol") then {
         add_x := ci.x + ci.w
         add_y := ci.y
      } else {
         add_x := 1
         add_y +:= add_row_h
         add_row_h := 0
      }
      ci.l_inset := validate_int(t, "l_inset")
      ci.t_inset := validate_int(t, "t_inset")
      ci.r_inset := validate_int(t, "r_inset")
      ci.b_inset := validate_int(t, "b_inset")
      ci.x_fill := validate_flag(t, "x_fill")
      ci.y_fill := validate_flag(t, "y_fill")
      ci.x_align := validate_x_align(t, "x_align")
      ci.y_align := validate_y_align(t, "y_align")
      ci.x_weight := validate_real(t, "x_weight", 0)
      ci.y_weight := validate_real(t, "y_weight", 0)

      put(info, ci)

      return ci
   end

   public dimension()
      local ci

      # Work out grid width/height
      gw := gh := 0
      every ci := !info do {
         gw <:= ci.x + ci.w - 1
         gh <:= ci.y + ci.h - 1
      }

      # Fill in final defaults now we have the grid dimensions.
      every ci := !info do {
         /ci.l_inset := if ci.x = 1 then self.doi else self.dii
         /ci.t_inset := if ci.y = 1 then self.doi else self.dii
         /ci.r_inset := if ci.x + ci.w = gw + 1 then self.doi else self.dii
         /ci.b_inset := if ci.y + ci.h = gh + 1 then self.doi else self.dii
         ci.dw := ci.pw + ci.l_inset + ci.r_inset
         ci.dh := ci.ph + ci.t_inset + ci.b_inset
      }

      compute_col_widths()
      compute_row_heights()
   end
   
   public static slice(start, span, l)
      local n
      n := 0
      every n +:= l[start to start + span - 1]
      return n
   end

   public static total(l)
      local n
      n := 0
      every n +:= !l
      return n
   end

   public static dist_by_weight(start, span, extra, l, weights, tw)
      local left, i, a, j

      left := extra
      every i := start to start + span - 1 do {
         a := integer(extra * weights[i] / tw)
         l[i] +:= a
         left -:= a
         if weights[i] > 0 then
            j := i
      }
      l[j] +:= left
   end

   public static dist_equally(start, span, extra, l)
      local left, i, a

      a := extra / span
      left := extra
      every i := start to start + span - 1 do {
         l[i] +:= a
         left -:= a
      }
      l[i] +:= left
   end

   public static allocate_space(start, span, extra, l, weights)
      local tw
      tw := slice(start, span, weights)
      if tw = 0 then
         dist_equally(start, span, extra, l)
      else
         dist_by_weight(start, span, extra, l, weights, tw)
   end

   public compute_col_widths()
      local i, need, l
      p_col_w := list(gw, 0)
      col_weights := list(gw, 0.0)
      l := isort(info, cell_width_sort)

      # Weights
      every i := !l do {
         need := i.x_weight - slice(i.x, i.w, col_weights)
         if need > 0 then
            dist_equally(i.x, i.w, need, col_weights)
      }

      # Compute sizes
      every i := !l do {
         need := i.dw - slice(i.x, i.w, p_col_w)
         if need > 0 then
            allocate_space(i.x, i.w, need, p_col_w, col_weights)
      }
   end

   public compute_row_heights()
      local i, need, l
      p_row_h := list(gh, 0)
      row_weights := list(gh, 0.0)
      l := isort(info, cell_height_sort)

      # Weights
      every i := !l do {
         need := i.y_weight - slice(i.y, i.h, row_weights)
         if need > 0 then
            dist_equally(i.y, i.h, need, row_weights)
      }

      # Compute sizes
      every i := !l do {
         need := i.dh - slice(i.y, i.h, p_row_h)
         if need > 0 then 
            allocate_space(i.y, i.h, need, p_row_h, row_weights)
      }
   end

   private static cell_width_sort(i)
      return i.w
   end

   private static cell_height_sort(i)
      return i.h
   end

   public print_layout()
      local x, y, t, i, s

      write("Grid dimensions:", gw, ",",gh)
      t := table()
      every t[(1 to gw)||","||(1 to gh)] := " "

      every i := !info do
         every t[(i.x to i.x + i.w - 1)||","||(i.y to i.y + i.h - 1)] := i.s

      write(s := repl("+-", gw) || "+")
      every y := 1 to gh do {
         every x := 1 to gw do
            writes("|", t[x||","||y])
         write("|\n",s)
      }

      write("----- Items ------")
      every write(to_string(!info))

      write("----- Data -------")
      write("p_col_w=", to_string(p_col_w))
      if \self.a_col_w then {
         write("a_col_w=", to_string(a_col_w))
         write("\textra width in a_col_w:", total(a_col_w)-total(p_col_w))
         write("\tleft pad border:", self.pad_w)
      }
      write("p_row_h=", to_string(p_row_h))
      if \self.a_row_h then {
         write("a_row_h=", to_string(a_row_h))
         write("\textra height in a_row_h:", total(a_row_h)-total(p_row_h))
         write("\ttop pad border:", self.pad_h)
      }

      write("col_weights=", to_string(col_weights))
      write("row_weights=", to_string(row_weights))
      write("\nPreferred size gives:", get_preferred_width(),",",get_preferred_height())
   end

   public get_preferred_width()
      return total(p_col_w)
   end

   public get_preferred_height()
      return total(p_row_h)
   end

   public compute_locations(x1, y1, w1, h1)
      local i, x, y, w, h, ew, eh, tw

      /x1 := 0
      /y1 := 0

      a_col_w := copy(p_col_w)
      a_row_h := copy(p_row_h)

      case self.extra of {
         EXTRA_CELLS : {
            # Extra width
            ew := w1 - total(p_col_w)
            tw := total(col_weights)
            if tw = 0 then
               # All weights zero - it goes on the border
               self.pad_w := ew / 2
            else {
               # Some weights, so no border and allocate by weight.
               self.pad_w := 0
               dist_by_weight(1, *a_col_w, ew, a_col_w, col_weights, tw)
            }

            # Same for height.
            eh := h1 - total(p_row_h)
            tw := total(row_weights)
            if tw = 0 then
               self.pad_h := eh / 2
            else {
               self.pad_h := 0
               dist_by_weight(1, *a_row_h, eh, a_row_h, row_weights, tw)
            }
         }
         EXTRA_BORDERS : {
            self.pad_w := (w1 - total(p_col_w)) / 2
            self.pad_h := (h1 - total(p_row_h)) / 2
         }
         EXTRA_IGNORE : {
            self.pad_w := self.pad_h := 0
         }
         default : runerr("Bad value for extra", self.extra)
      }

      col_x := []
      x := x1 + self.pad_w
      every w := !a_col_w do {
         put(col_x, x)
         x +:= w
      }

      row_y := []
      y := y1 + self.pad_h
      every h := !a_row_h do {
         put(row_y, y)
         y +:= h
      }

      every i := !info do {
         x := col_x[i.x] + i.l_inset
         y := row_y[i.y] + i.t_inset
         w := slice(i.x, i.w, a_col_w) - i.l_inset - i.r_inset
         h := slice(i.y, i.h, a_row_h) - i.t_inset - i.b_inset
         i.aw := if \i.x_fill then w else i.pw
         i.ah := if \i.y_fill then h else i.ph

         i.ax := case i.x_align of {
            Align.L : x
            Align.R : x + w - i.aw
            Align.C : x + (w - i.aw) / 2
         }

         i.ay := case i.y_align of {
            Align.T : y
            Align.B : y + h - i.ah
            Align.C : y + (h - i.ah) / 2
         }
      }
   end

   public compute_widths(w1)
      local x1, i, x, w, ew, tw

      x1 := 0

      a_col_w := copy(p_col_w)

      case self.extra of {
         EXTRA_CELLS : {
            # Extra width
            ew := w1 - total(p_col_w)
            tw := total(col_weights)
            if tw = 0 then
               # All weights zero - it goes on the border
               self.pad_w := ew / 2
            else {
               # Some weights, so no border and allocate by weight.
               self.pad_w := 0
               dist_by_weight(1, *a_col_w, ew, a_col_w, col_weights, tw)
            }
         }
         EXTRA_BORDERS : {
            self.pad_w := (w1 - total(p_col_w)) / 2
         }
         EXTRA_IGNORE : {
            self.pad_w := 0
         }
         default : runerr("Bad value for extra", self.extra)
      }

      col_x := []
      x := x1 + self.pad_w
      every w := !a_col_w do {
         put(col_x, x)
         x +:= w
      }

      every i := !info do {
         x := col_x[i.x] + i.l_inset
         w := slice(i.x, i.w, a_col_w) - i.l_inset - i.r_inset
         i.aw := if \i.x_fill then w else i.pw

         i.ax := case i.x_align of {
            Align.L : x
            Align.R : x + w - i.aw
            Align.C : x + (w - i.aw) / 2
         }
      }
   end

   #
   # Set the default inner inset
   #
   public set_dii(n)
      self.dii := n
      return self
   end

   #
   # Set the default outer inset
   #
   public set_doi(n)
      self.doi := n
      return self
   end

   #
   # Configure where to allocate any extra space.
   #
   # @param s one of {EXTRA_CELLS}, {EXTRA_BORDERS}, {EXTRA_IGNORE}
   #
   public set_extra(s)
      self.extra := s
      return self
   end

   private static init()
      EXTRA_CELLS := "cells"
      EXTRA_BORDERS := "borders"
      EXTRA_IGNORE := "ignore"
   end

   public new()
      self.dii := self.doi := 0
      self.extra := EXTRA_CELLS
      self.id_str := string(&ucase)
      self.add_y := self.add_x := 1
      self.add_row_h := 0
      self.info := []
      return
   end
end
