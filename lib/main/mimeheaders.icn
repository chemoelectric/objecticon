package util

import io(write)

#
# Base class for an object which has headers (Message, and HTTP response
# and request objects).
#
class MimeHeaders()
   private readable headers

   #
   # Show the header table (useful debug)
   #
   public show_headers()
      local h
      every h := !headers.sort() do {
         every write(h[1], ": ", !h[2])
      }
   end

   #
   # A convenience function to get the first header matching the given key, or fail
   #
   public get_first_header(key)
      return get_headers(key)[1]
   end

   #
   # Get all the headers for the key, or fail if the key has no headers
   # @return a list of all the headers for the key.  This will always be
   # @       a non-empty list.
   # @fail if no headers for the key have been defined
   #
   public get_headers(key)
      return \headers.get(key)
   end

   #
   # Get all the headers matching the given key as a string separated
   # by the given delimeter, which defaults to ","
   # @fail if there is no header with the given key
   #
   public get_catenated_headers(key, delim)
      local s, l, e

      l := get_headers(key) | fail

      /delim := ","

      s := ""
      every e := !l do {
         if *s > 0 then 
            s ||:= delim
         s ||:= e
      }

      return s
   end

   #
   # Add a header with the given key, after any existing ones with the same key
   #
   public add_header(key, val)
      if headers.member(key) then
         put(headers.get(key), val)
      else
         headers.insert(key, [val])
   end

   #
   # Set a header with the given key; any existing headers with the same key
   # are removed.
   #
   public set_header(key, val)
      headers.insert(key, [val])
   end

   #
   # Unset the header(s) for the given key
   #
   public unset_header(key)
      headers.delete(key)
   end

   #
   # Succeed iff there is a header with the given key.
   #
   public has_header(key)
      return headers.member(key)
   end

   public new()
      headers := ClTable()
      return
   end
end
