#
# Retrieve http pages.
#

import util, http, net, lang, ipl.options, io, posix

global total, ok, err, failed, hc, opts, stdin, skipped, out

class Monitor()
   private last_progress, prev_len

   private writes(a[])
      local t
      t := 0
      every t +:= *!a
      push(a, repl("\b", \prev_len))
      FileStream.stderr.writes!a
      prev_len := t
   end

   private write(a[])
      push(a, repl("\b", \prev_len))
      FileStream.stderr.write!a
      prev_len := &null
   end

   public progress()
      local len, read, now
      len := hc.get_length()
      read := hc.get_read()
      # Check to avoid printing huge number of progress messages very quickly.
      now := Prog.get_runtime_millis()
      if now - \last_progress < 250 then
         return
      last_progress := now
      if \len then
         writes(read, " bytes of ", len, " (", (read * 100) / len, "%)")
      else
         writes(read, " bytes read")
   end

   public complete()
      writes()
   end

   public writing_line(ev)
      write("Sent: ", ev)
   end

   public read_line(ev)
      write("Got : ", ev)
   end

   public read_string(ev)
      write("Got : data - 0x", Format.int_to_string(*ev, 16), " bytes")
   end

   public writing_string(ev)
      write("Sent: data - 0x", Format.int_to_string(*ev, 16), " bytes")
   end

   public failed(ev)
      write("Failed ", &why, repl(" ", 20))
   end

   public retrying(ev)
      write("Retrying ", &why, repl(" ", 20))
   end

   public other(ev, src, type)
      write(type)
   end

   public got_headers()
      local fname

      if \opts["head"|"c"] then
         fail

      if fname := hc.get_response().get_content_disposition_filename() then {
         get_out(fname)
         if check_skip() then
            hc.abort()
      }
   end
end


procedure main(args)
   local l, f, t, cookies

   opts := options(args, "-over! -i: -form:* -type: -o: -k: -q! -t+ -r+ -p: -d: -a: -f: -e: -l! -n: _
                         -head! -sslnv! -help! -c! -skip! -agent: -while! -close! -x:* -nz!")
   if \opts["help"] then {
      write(FileStream.stderr, "Usage: geturl [URL]... [OPTIONS]")
      write(FileStream.stderr, "Retrieve URL(s)")
      write(FileStream.stderr, "  -o OUTPUT FILE/DIR      Output file or directory")
      write(FileStream.stderr, "  -i INPUT FILE           Input file for a POST request")
      write(FileStream.stderr, "  -form K=V               Post an HTTP form with entry K=V; multiple uses allowed")
      write(FileStream.stderr, "  -type TYPE              Content type for a POST request")
      write(FileStream.stderr, "  -c                      Output to stdout (implies -q)")
      write(FileStream.stderr, "  -p STRING               Prepend string to all output files")
      write(FileStream.stderr, "  -d STRING               Append string to all output files")
      write(FileStream.stderr, "  -q                      Quiet mode")
      write(FileStream.stderr, "  -t TIMEOUT              Specify timeout (in seconds) to use")
      write(FileStream.stderr, "  -r RETRIES              Specify number of retries to use")
      write(FileStream.stderr, "  -while                  Set the retry-while-data flag")
      write(FileStream.stderr, "  -a USER:PASS            Specify authorization")
      write(FileStream.stderr, "  -f FILE                 Read URLs from file")
      write(FileStream.stderr, "  -e URL                  Set referer header")
      write(FileStream.stderr, "  -l                      Show HTTP headers and data flow")
      write(FileStream.stderr, "  -close                  Use Connection: Close")
      write(FileStream.stderr, "  -agent STRING           Set user agent field")
      write(FileStream.stderr, "  -head                   Do an HTTP HEAD")
      write(FileStream.stderr, "  -sslnv                  Don't verify SSL certificates")
      write(FileStream.stderr, "  -n FILE                 Append to the given partial file")
      write(FileStream.stderr, "  -k FILE                 Load cookies from file")
      write(FileStream.stderr, "  -skip                   Skip over any existing files")
      write(FileStream.stderr, "  -over                   Overwrite any existing files")
      write(FileStream.stderr, "  -x HEADER:VALUE         Set extra HTTP header; multiple uses allowed")
      write(FileStream.stderr, "  -help                   Help message")
      write(FileStream.stderr, "URL may contain range expansions eg {1-2+8-11}")
      exit(1)
   }
   total := ok := skipped := 0
   err := []
   failed := []

   hc := HttpClient()
   hc.set_timeout(\opts["t"] * 1000)
   hc.set_retries(\opts["r"])
   hc.set_user_agent(\opts["agent"])
   if \opts["sslnv"] then
      hc.set_ssl_verify(&no)

   if \opts["c"] then
      opts["q"] := 1

   if \opts["head"] then 
      opts["l"] := 1

   if \opts["nz"] then
      hc.set_gzip(&no)

   if \opts["close"] then
      hc.set_keep_alive(&no)

   if \opts["while"] then
      hc.set_retry_while_data(&yes)

   cookies := \opts["k"] | System.getenv("GETURL_COOKIES")
   if \cookies then {
      t := decode(Files.file_to_string(cookies)) | {
         write(FileStream.stderr, "Couldn't read/decode cookie file ", cookies, ": ", &why)
         t := table()
      }
      hc.set_cookies(t)
   }

   l := Monitor()
   if /opts["q"] then {
      hc.connect(l.failed, HttpClient.FAILED_EVENT)
      hc.connect(l.retrying, HttpClient.RETRYING_EVENT)
      if \opts["l"] then {
         hc.connect(l.read_line, NetClient.READ_LINE_EVENT)
         hc.connect(l.read_string, NetClient.READ_STRING_EVENT)
         hc.connect(l.writing_line, NetClient.WRITING_LINE_EVENT)
         hc.connect(l.writing_string, NetClient.WRITING_STRING_EVENT)
         hc.connect(l.other, NetClient.CONNECTING_EVENT)
         hc.connect(l.other, NetClient.CONNECTED_EVENT)
         hc.connect(l.other, NetClient.CLOSED_EVENT)
      } else {
         hc.connect(l.progress, HttpClient.PROGRESS_EVENT)
         hc.connect(l.complete, HttpClient.COMPLETE_EVENT)
      }
   }

   hc.connect(l.got_headers, "Headers")

   if \opts["f"] then {
      f := open(opts["f"]) | stop("Couldn't open ", opts["f"], ": ", &why)
      every process_one(expand_arg(|read(f)))
      close(f)
   } else if *args = 0 then {
      stdin := 1
      every process_one(expand_arg(|read()))
   } else
      every process_one(expand_arg(!args))

   hc.close()

   if /opts["q"] then {
      write(FileStream.stderr, "Summary: Total ", total, ", Okay ", ok, ", Skipped ", skipped, 
            ", HTTP error ", *err, ", Failed ", *failed)
      if *err > 0 then {
         write(FileStream.stderr, "HTTP errors on:")
         every write(FileStream.stderr, !err)
      }
      if *failed > 0 then {
         write(FileStream.stderr, "Failed on:")
         every write(FileStream.stderr, !failed)
      }
   }

   if \cookies then {
      t := cookies || ".bak"
      Files.string_to_file(t, encode(Cookie.expire_cookies(hc.get_cookies()))) | 
         stop("Couldn't encode to temp cookie file ", t, ": ", &why)
      # Use rename not move to ensure it's atomic
      Files.rename(t, cookies) | stop("Couldn't rename cookie file ", t, ": ", &why)
   }

   if *err = *failed = 0 then
      exit(0)
   else
      exit(1)
end


procedure process_one(a)
   local hr, url, u, p, start_t, res, end_t, kbps, s, msg, tmp_file, data_stream, 
      post_stream, content_type, t, k, v

   total +:= 1

   url := URL.parse(a) | stop("Invalid url: " || a)

   if /opts["head"] & /opts["c"] then {
      get_out(url.get_file_last(1))
      if check_skip() then
         fail
      if /opts["q"] then
         write(FileStream.stderr, "Saving URL ", url.str())
   }

   hr := HttpRequest()
   hr.set_url(url)
   if \opts["a"] then {
      opts["a"] ? {
         u := tab(upto(':')) | stop("Bad -a option")
         move(1)
         p := tab(0)
      }
      hr.set_username(u)
      hr.set_password(p)
   }
   if \opts["head"] then 
      hr.set_method("HEAD")

   hr.set_referer(\opts["e"])

   every s := !\opts["x"] do {
      s ? {
         if k := tab(upto(':')) then {
            move(1)
            tab(many(' \t'))
            v := tab(0)
            hr.set_header(k, v)
         }
      }
   }

   if \opts["n"] then {
      p := Files.stat(opts["n"]) | stop("Couldn't stat ", opts["n"], ": ", &why)
      hr.set_range(p.size)
   }

   if \opts["i"] & \opts["form"] then
      stop("Can't have -i and -form options together")

   if \opts["i"] then {
      /opts["head"] | stop("Can't have -head and -i options together")
      post_stream := FileStream.open(opts["i"], FileOpt.RDONLY) | stop("Couldn't open ", opts["i"], ": ", &why)
      hr.set_post_stream(post_stream)
      content_type := \opts["type"] | "application/x-www-form-urlencoded"
      hr.set_content_type(content_type)
   }

   if \opts["form"] then {
      /opts["head"] | stop("Can't have -head and -form options together")
      t := table()
      every s := !opts["form"] do {
         s ? {
            if k := tab(upto('=')) then {
               move(1)
               v := tab(0)
               t[k] := v
            }
         }
      }
      hr.set_html_form_data(t)
   }

   if /opts["head"] then {
      tmp_file := Files.make_temp_filename("http_geturl.", ".bin") | stop("Couldn't create temp file: ", &why)
      data_stream := BufferStream(FileStream.open(tmp_file, 
                                                  ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT))).
                      set_buff_size(8192) | stop("Couldn't open ", tmp_file, ": ", &why)
      hr.set_data_stream(data_stream)
   }

   start_t := Prog.get_runtime_millis()
   if res := hc.retrieve(hr) then {
      if /opts["head"] then {
         if \post_stream then
            post_stream.close() | stop("Couldn't close post_stream: ", &why)
         data_stream.close() | stop("Couldn't close data_stream: ", &why)
         if \opts["c"] then {
            Files.copy(tmp_file, "/dev/stdout") | stop("Couldn't copy ", tmp_file, " to stdout: ", &why)
            Files.remove(tmp_file)
         } else {
            end_t := Prog.get_runtime_millis()
            kbps := Format.numeric_to_string((hc.get_read() / 1024.0) / ((end_t - start_t) / 1000.0), 1)
            msg := hc.get_read() || " bytes OK (" || kbps  || " kB/s)"

            if out == "/dev/null" then {
               Files.remove(tmp_file)
               msg ||:= " -> " || out
            } else if \opts["n"] then {
               Files.append(tmp_file, out) | stop("Unable to append ", tmp_file, " to ", out, ": ", &why)
               Files.remove(tmp_file)
               msg ||:= " ->> " || out
            } else if \opts["over"] then {
               Files.move(tmp_file, out) | stop("Unable to move ", tmp_file, " to ", out, ": ", &why)
               msg ||:= " -> " || out
            } else if Files.equal_files(tmp_file, out) then {
               msg ||:= " : Existing file " || out || " is identical."
               Files.remove(tmp_file)
            } else {
               out := Files.ensure_unique_filename(out)
               Files.move(tmp_file, out)  | stop("Unable to move ", tmp_file, " to ", out, ": ", &why)
               msg ||:= " -> " || out
            }

            if /opts["q"] then
               write(FileStream.stderr, msg)
         }
      }
      ok +:= 1
   } else {
      if /opts["head"] then {
         if \post_stream then
            post_stream.close() | stop("Couldn't close post_stream: ", &why)
         data_stream.close() | stop("Couldn't close data_stream: ", &why)
         Files.remove(tmp_file)
      }
      if /hc.abort_flag then {
         if s := hc.get_http_error() then {
            put(err, a)
            if /opts["q"] then
               write(FileStream.stderr, "HTTP Error: ", s, " - no data output")
         } else {
            put(failed, a)
         }
      }
   }
end


procedure get_out(fname)
   if \opts["n"] then {
      out := opts["n"]
      fail
   }

   if *fname = 0 then
      fname := "geturl.out"

   fname := \opts["p"] || fname
   fname := fname || \opts["d"]

   if out := \opts["o"] then {
      if Files.is_directory(out) then
         out := Files.get_path(out).child(fname).str()
   } else
      out := fname
end


procedure check_skip()
   /opts["n"] | fail
   /opts["over"] | fail
   \opts["skip"] | fail
   Files.access(out) | fail
   if /opts["q"] then
      write(FileStream.stderr, "Skipping existing file ", out)
   skipped +:= 1
   return
end


procedure expand_arg(s)
   local s1, s2, s3
   s ? {
      s1 := tab(upto('{') | 0)
      if any('{') then {
         move(1)
         s2 := tab(upto('}')) | fail
         move(1)
         s3 := tab(0)
         suspend s1 || expand_braces(s2) || expand_arg(s3)
      } else
         return s1
   }
end

procedure expand_braces(s)
   local l, s1, s2, s3
   s ? repeat {
      s1 := tab(upto('-+') | 0)
      if any('-') then {
         move(1)
         s2 := tab(upto(':+') | 0)
         if any(':') then {
            move(1)
            s3 := tab(upto('+') | 0)
         } else
            s3 := 1
         if any('0', s1 | s2) then {
            l := *s1
            l <:= *s2
            suspend right(integer(s1) to integer(s2) by integer(s3), l, "0")
         } else
            suspend string(integer(s1) to integer(s2) by integer(s3))
      } else
         suspend s1
      move(1)
      if pos(0) then
         break
   }
end
