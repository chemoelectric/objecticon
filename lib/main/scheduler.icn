package io

import lang, util

# This stream wraps another stream (normally a {SocketStream}).  The
# {in} and {out} methods are invoked from the co-expression of the
# owning {Task}.  Those methods activate the {Task}'s {Scheduler}'s
# co-expression.  The stream's co-expression is re-activated only when
# the {Scheduler} determines the stream is ready for i/o.
#
class TaskStream(Stream, HasUnderlyingStream)
   private readable
      timeout
   private
      other,
      task

   public in(n)
      local r
      r := task.poll([other, Poll.IN], timeout) | fail
      if /r then return error("Timeout")
      poll_in_test(r[1]) | return error("poll() indicated an i/o error")
      return other.in(n)
   end

   public out(s)
      local r
      r := task.poll([other, Poll.OUT], timeout) | fail
      if /r then return error("Timeout")
      poll_out_test(r[1]) | return error("poll() indicated an i/o error")
      return other.out(s)
   end

   public close()
      if \close_underlying_flag then
         return other.close()
      return
   end

   public get_mode()
      return other.get_mode()
   end

   public seek(offset)
      return other.seek(offset)
   end

   public tell()
      return other.tell()
   end

   public truncate(len)
      return other.truncate(len)
   end

   public new(other, task, timeout)
      self.other := other
      self.close_underlying_flag := &yes
      self.task := task
      self.timeout := timeout
      return
   end
end

class Task()
   public const
      scheduler
   private readable
      xstate_vars,
      sleep_until,
      last_sleep,
      poll_until,
      poll_req
   package
      saved_xstate
   package readable
      coex,
      state,
      poll_err,
      poll_res,
      interrupt_flag

   # If a task is currently sleeping, then this alters the time it
   # will sleep for, behaving as though the original call to {sleep}
   # had given {n} as its parameter.
   #
   # @param n The time to wait for.  If {&null}, wait forever.
   #
   public change_sleep(n)
      \coex | runerr("change_sleep called on a currently active task")
      if is_sleeping() then
         sleep_until := (last_sleep + \n) | &null
   end

   # Succeed iff the task is currently active.
   #
   public is_active()
      return ./coex
   end

   # Succeed iff the task is the current task.  Note that a task may
   # be active, but not the current task, since a task may itself
   # invoke {Scheduler.work} in order to activate another task, in a
   # nested fashion.  This may happen for example when a task shows a
   # modal dialog, and hence calls {Scheduler.work} via the dispatcher
   # event loop.
   #
   public is_current()
      return self === scheduler.curr_task
   end

   # Succeed iff the task is currently sleeping
   public is_sleeping()
      return scheduler.is_sleeping(self)
   end

   # Succeed iff the task is currently polling
   public is_polling()
      return scheduler.is_polling(self)
   end

   # Succeed iff the task is currently in the ready state
   public is_ready()
      return scheduler.is_ready(self)
   end

   # Succeed iff the task is dormant, meaning it is not active, and is
   # not sleeping, polling or ready, meaning it won't be scheduled by
   # the scheduler, at least until {start} is called on it.
   public is_dormant()
      return scheduler.is_dormant(self)
   end

   # Suspend this task, which must be the currently scheduled task, in
   # order to carry out a {DescStream.poll}.  The parameters and
   # result are in the same form as for {DescStream.poll}.  The
   # difference between this and {DescStream.poll} is that the
   # scheduler will suspend this task whilst the poll is taking place,
   # whereas {DescStream.poll} will block.  If {timeout} is zero, then
   # there is no advantage in using this method, and {DescStream.poll}
   # is preferable.
   #
   # @param l A list of alternating {DescStream}, flag (from {Poll})
   # @        pairs.
   # @param timeout The optional timeout
   #
   public poll(l, timeout)
      self === scheduler.curr_task | runerr("poll called on task which is not current")
      self.coex := &current
      self.poll_until := (Prog.get_runtime_millis() + \timeout) | &null
      self.poll_req := l
      self.interrupt_flag := &null
      scheduler.now_poll(self)
      return if \interrupt_flag then
         error("Interrupted")
      else if \poll_err then
         error(poll_err)
      else
         .self.poll_res
   end

   # Suspend this task, which must be the currently scheduled task,
   # for {n} milliseconds.  If the task is interrupted this method
   # fails, setting {&why}, otherwise it succeeds and returns {&null}.
   #
   # @param n The time to wait for.  If {&null}, wait forever (or until
   # @        interrupted).
   # @return {&null} when the task awakes; fails on interrupt
   #
   public sleep(n)
      self === scheduler.curr_task | runerr("sleep called on task which is not current")
      self.coex := &current
      last_sleep := Prog.get_runtime_millis()
      sleep_until := (last_sleep + \n) | &null
      self.interrupt_flag := &null
      scheduler.now_sleep(self)
      if \interrupt_flag then
         return error("Interrupted")
      return
   end

   # Interrupt the task, which may not be currently active.  If the
   # task is currently sleeping or polling, then it is placed back in
   # the ready state.  This causes the original {poll} or {sleep} call
   # to fail, setting {&why}.
   #
   public interrupt()
      \coex | runerr("interrupt called on a currently active task")
      scheduler.interrupt(self)
   end

   # If the task is sleeping, then place it immediately back into the
   # ready state.  The task must not be currently active.
   #
   public notify()
      \coex | runerr("notify called on a currently active task")
      scheduler.notify(self)
   end

   # Suspend this task, which must be the currently scheduled task,
   # placing it immediately into the ready state in the scheduler.
   #
   public yield()
      self === scheduler.curr_task | runerr("yield called on task which is not current")
      self.coex := &current
      scheduler.now_yield(self)
   end

   # Suspend this task, which must be the currently scheduled task,
   # but do not resume it.  Control reverts to the scheduler.  The
   # task may be subsequently restarted with {start}.  Note that to
   # end a task, it is not simply sufficient to fall off the end of
   # the task's co-expression, {revert} must be used.
   #
   public revert()
      self === scheduler.curr_task | runerr("revert called on task which is not current")
      self.coex := &current
      scheduler.now_revert()
   end

   # Start the task, which may not be currently active.  If the task
   # was previously stopped in a particular state (eg sleeping), then
   # it continues from that same state.
   #
   public start()
      \coex | runerr("start called on a currently active task")
      scheduler.start(self)
   end

   # Stop the task, which may not be currently active.  This prevents
   # the scheduler from activating it.  Its present state is
   # remembered, and it may be started again in that state using
   # {start}.
   #
   public stop()
      \coex | runerr("stop called on a currently active task")
      scheduler.stop(self)
   end

   # Get the external state of the task (normally values of global
   # variables affected by the {Task}).  The returned state will
   # subsequently be passed to {restore_xstate}.  By default, this
   # method returns the values of the global variables defined in
   # {xstate_vars}.
   #
   package get_xstate()
      local l
      if \xstate_vars then {
         l := []
         every put(l, !xstate_vars)
      }
      return l
   end

   # Restore a state previously returned by {get_xstate}.
   #
   package restore_xstate(l)
      if \l then
         every !xstate_vars := pop(l)
   end

   #
   # Create a new {Task}.
   #
   # @param scheduler The {Scheduler} to use to activate the task.
   # @param coex The co-expression body of the task.
   # @param xstate_vars An optional co-expression generating global
   # @      variables to save and restore when switching to and
   # @      from this Task.
   #
   public new(scheduler, coex, xstate_vars)
      self.coex := coex
      self.scheduler := scheduler
      self.xstate_vars := xstate_vars
      return
   end
end

class Scheduler()
   public const
      poll_timeout
   private readable 
      coex,
      curr_task
   private
      ready,
      sleeping,
      polling
   
   public new(n)
      poll_timeout := \n | 0
      ready := set()
      sleeping := set()
      polling := set()
      return
   end

   package start(t)
      /t.state := ready
      insert(t.state, t)
   end

   package stop(t)
      delete(\t.state, t)
   end

   package is_sleeping(t)
      return member(sleeping, t)
   end

   package is_polling(t)
      return member(polling, t)
   end

   package is_ready(t)
      return member(ready, t)
   end

   package is_dormant(t)
      return \t.coex & not member(ready | polling | sleeping, t)
   end

   private set_state(t, x)
      delete(\t.state, t)
      t.state := x
      insert(t.state, t)
   end

   package interrupt(t)
      if member(sleeping | polling, t) then {
         t.interrupt_flag := 1
         set_state(t, ready)
      }
   end

   package notify(t)
      if member(sleeping, t) then
         set_state(t, ready)
   end

   package now_sleep(t)
      \coex | syserr("now_sleep with null coex")
      set_state(t, sleeping)
      coact(, coex)
   end

   package now_poll(t)
      \coex | syserr("now_poll with null coex")
      set_state(t, polling)
      coact(, coex)
   end

   package now_yield(t)
      \coex | syserr("now_yield with null coex")
      set_state(t, ready)
      coact(, coex)
   end

   package now_revert()
      \coex | syserr("now_revert with null coex")
      coact(, coex)
   end

   #
   # Test whether there are any tasks in the internal lists.
   #
   public empty()
      return not(*(ready | sleeping | polling) > 0)
   end

   private run(t)
      local sc, st, te, ov
      delete(t.state, t)
      t.state := &null
      sc := coex
      st := curr_task
      coex := &current
      curr_task := t
      te := t.coex
      t.coex := &null
      # Don't specify an activator unless we have to (ie if this is a
      # new co-expression).
      ov := t.get_xstate()
      if Coexpression.get_activator(te) then {
         t.restore_xstate(t.saved_xstate)
         coact(, te)
      } else
         @te
      t.saved_xstate := t.get_xstate()
      t.restore_xstate(ov)
      \t.coex | runerr("incorrect reversion to scheduler, task co-expression not set", t)
      coex === &current | syserr("scheduler co-expression not &current")
      coex := sc
      curr_task := st
    end

   public work()
      local t, r, curr_time, poll_l, x
      repeat {
         if t := ?ready then {
            run(t)
            return
         }

         if *sleeping > 0 then {
            curr_time := Prog.get_runtime_millis()
            every t := !sleeping do {
               if curr_time >= \t.sleep_until then
                  set_state(t, ready)
            }
            if *ready > 0 then
               next
         }

         if *polling > 0 then {
            poll_l := []
            every t := !polling do
               every put(poll_l, !t.poll_req)
            curr_time := Prog.get_runtime_millis() + poll_timeout
            if r := DescStream.poll(poll_l, poll_timeout) then {
               if /r then {
                  # Process timeout for each task.
                  every t := !polling do {
                     if curr_time > \t.poll_until then {
                        set_state(t, ready)
                        t.poll_err := t.poll_res := &null
                     }
                  }
               } else {
                  every t := !polling do {
                     # Extract relevant part of result
                     x := []
                     every 1 to *t.poll_req / 2 do
                        put(x, pop(r))
                     # If all zeros, it's the same as a timeout.
                     if !x ~= 0 then {
                        set_state(t, ready)
                        t.poll_res := x
                        t.poll_err := &null
                     } else if curr_time > \t.poll_until then {
                        set_state(t, ready)
                        t.poll_err := t.poll_res := &null
                     }
                  }
               }
            } else {
               # poll error; forward error to each Task
               every t := !polling do {
                  set_state(t, ready)
                  t.poll_err := &why
                  t.poll_res := &null
               }
            }
            # If we have a poll_timeout, the poll counts as work; otherwise it does not
            if poll_timeout > 0 then
               return
            if *ready > 0 then
               next
         }

         fail
      }
   end
end
