<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>datecomp.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     datecomp.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures for date comparison
<a name="6"/>#
<a name="7"/>#	Author:   C. Scott McArthur  (kaltorak@poboxes.com)
<a name="8"/>#
<a name="9"/>#	Date:     March 13, 1999 (03/13/1999)  :)
<a name="10"/>#    
<a name="11"/>#       Revised:  April 20, 1999 (04/20/1999)
<a name="12"/>#
<a name="13"/>############################################################################
<a name="14"/>#
<a name="15"/>#   This file is in the public domain.  But I will take money if you want :)
<a name="16"/>#
<a name="17"/>############################################################################
<a name="18"/>#
<a name="19"/>#   These procedures do simple date comparisons.  The first
<a name="20"/>#   is a greater than [dgt(date1, date2)] the second is less than 
<a name="21"/>#   [dlt(date1, date2)] the third is equaity [deq(date1, date2)], 
<a name="22"/>#   and the fourth will determine if the date parameter
<a name="23"/>#   in the future or not [futuredate(date1)] finally, pastdate  will 
<a name="24"/>#   determine if date1 is less than &amp;date [pastdate(date1)] (in the past)
<a name="25"/>#
<a name="26"/>#   dgt will succede if date1 is greater than date2
<a name="27"/>#   dlt will succede if date1 is less than date2
<a name="28"/>#   deq will succede if date1 is equal to date2
<a name="29"/>#   futuredate will succede if date1 is greater than &amp;date
<a name="30"/>#   pastdate will succede if date1 is less than &amp;date
<a name="31"/>#
<a name="32"/>#   The format for the parameters are strings of the format mm/dd/yyyy
<a name="33"/>#   or yyyy/mm/dd (not my favorite, but this will comply with icons format
<a name="34"/>#   of &amp;date)
<a name="35"/>#
<a name="36"/># NOTE:
<a name="37"/>#   These functions will not work unless they are 
<a name="38"/>#   formatted precicely as stated above (i.e., January first 12 ad needs to
<a name="39"/>#   be passed as "01/01/0012" or "0012/01/01")
<a name="40"/>#
<a name="41"/># REVISION: 
<a name="42"/>#    Added procedure betweendates(date1, date2, date3)
<a name="43"/>#    This function will return 1 if date 1 is between (or equal to)
<a name="44"/>#    date2 and date3.
<a name="45"/>#    Made all procedures that may need to reformat date call it by default.
<a name="46"/>#    Now, reformatdate will only reformat the date if needed.  Otherwise
<a name="47"/>#    it will just return what it was passed.
<a name="48"/># 
<a name="49"/>#    April 20, 1999
<a name="50"/>#      modified reformatdate to handle dates passed in as yyyymmdd with no '/'
<a name="51"/>#
<a name="52"/>############################################################################
<a name="53"/>
<a name="54"/>##  returns 1 if date1 is greater than date2, fails otherwise
<a name="55"/>
<a name="56"/>package ipl.datecomp
<a name="57"/>
<a name="58"/>procedure dgt(date1, date2)
<a name="59"/>
<a name="60"/>   # reformat the dates if we need to
<a name="61"/>   date1 := reformatdate(date1)
<a name="62"/>   date2 := reformatdate(date2)
<a name="63"/>
<a name="64"/>   # check the years. Is date1.year &gt; date2.year?
<a name="65"/>   if (integer(right(date1, 4)) &gt; integer(right(date2, 4))) then
<a name="66"/>      return
<a name="67"/>   else {
<a name="68"/>      # Is date1.year &lt; date2.year?
<a name="69"/>      if(integer(right(date2, 4)) &gt; integer(right(date1, 4))) then
<a name="70"/>         fail
<a name="71"/>      }
<a name="72"/>
<a name="73"/>   # the years are equal, check the months!  Is date1.month &gt; date2.month?
<a name="74"/>   if (integer(left(date1, 2)) &gt; integer(left(date2, 2))) then
<a name="75"/>      return
<a name="76"/>   else {
<a name="77"/>      # Is date1.month &lt; date2.month?
<a name="78"/>      if(integer(left(date2, 2)) &gt; integer(left(date1, 2))) then
<a name="79"/>         fail
<a name="80"/>      }
<a name="81"/>
<a name="82"/>   # check the days. cheat here a little bit.  Notice that the function
<a name="83"/>   # getmonth(thisdate) below really only returns whatever is enclosed
<a name="84"/>   # in two "/" marks.  Well, that is where the day is here, so we will
<a name="85"/>   # just call that function  :)
<a name="86"/>
<a name="87"/>   # Is date1.day &gt; date2.day?
<a name="88"/>   if (integer(getmonth(date1)) &gt; integer(getmonth(date2))) then
<a name="89"/>      return
<a name="90"/>   else {
<a name="91"/>      # Is date1.day &lt; date2.day?
<a name="92"/>      if(integer(getmonth(date2)) &gt; integer(getmonth(date1))) then
<a name="93"/>         fail
<a name="94"/>      }
<a name="95"/>
<a name="96"/>   # equal dates: dgt implicitly fails by falling off the end
<a name="97"/>end
<a name="98"/>
<a name="99"/>
<a name="100"/>
<a name="101"/>##  returns if date1 is less than date2, fails otherwise
<a name="102"/>procedure dlt(date1, date2)
<a name="103"/>
<a name="104"/>   return dgt(date2, date1)
<a name="105"/>
<a name="106"/>end
<a name="107"/>
<a name="108"/>
<a name="109"/>#  returns if date1 is the same as date2, fails otherwise (copy and paste is cool)
<a name="110"/>procedure deq(date1, date2)
<a name="111"/>   # first reformat the dates if we need to
<a name="112"/>   date1 := reformatdate(date1)
<a name="113"/>   date2 := reformatdate(date2)
<a name="114"/>   return date1 == date2
<a name="115"/>end
<a name="116"/>
<a name="117"/>
<a name="118"/># returns if date1 is in the future, fails otherwise
<a name="119"/>procedure futuredate(date1)
<a name="120"/>
<a name="121"/>   return dgt(date1, &amp;date)
<a name="122"/>
<a name="123"/>end
<a name="124"/>
<a name="125"/># returns if date1 is in the past, fails otherwise
<a name="126"/>procedure pastdate(date1)
<a name="127"/>
<a name="128"/>   return dgt(&amp;date, date1)
<a name="129"/>
<a name="130"/>end
<a name="131"/>
<a name="132"/>
<a name="133"/>#######################################################
<a name="134"/>##  This procedure will determine if date1 is between
<a name="135"/>##  the CLOSED interval dates of date2 and date3
<a name="136"/>##  (include date2 and date3 in the interval)
<a name="137"/>##  This will fail if date3 &lt; date2
<a name="138"/>#######################################################
<a name="139"/>procedure betweendates(date1, date2, date3)
<a name="140"/>   if dlt(date3, date2) then fail
<a name="141"/>   if dlt(date1, date2) then fail 
<a name="142"/>   if dgt(date1, date3) then fail
<a name="143"/>   return
<a name="144"/>end
<a name="145"/>
<a name="146"/>
<a name="147"/>#######################################################
<a name="148"/>##  This procedure will simply return the date format
<a name="149"/>##  mm/dd/yyyy for a date passed in as yyyy/mm/dd or yyyymmdd
<a name="150"/>##  This could probably be cleaned up some....
<a name="151"/>#######################################################
<a name="152"/>
<a name="153"/>procedure reformatdate(thisdate)
<a name="154"/>   local str
<a name="155"/>   ## if thisdate came as yyyymmdd then fix it
<a name="156"/>   thisdate ? {
<a name="157"/>      str := tab(find("/"))
<a name="158"/>      if (/str &amp; (8 = *thisdate)) then { ##  we will assume that the date came in as yyyymmdd
<a name="159"/>         move(4)
<a name="160"/>         str := move(2) || "/" || move(2)
<a name="161"/>         tab(1)
<a name="162"/>         str := str || "/" || move(4)
<a name="163"/>         return (str)
<a name="164"/>         }
<a name="165"/>      }
<a name="166"/>   str := ""
<a name="167"/>   ## first see if thisdate came as yyyy/mm/dd
<a name="168"/>   thisdate ? {
<a name="169"/>      str := tab(find("/"))
<a name="170"/>      if (*str &gt; 2) then {
<a name="171"/>         # year is first, let's make it how we want it
<a name="172"/>         return (getmonth(thisdate) || "/" || getday(thisdate) || "/" || getyear(thisdate))
<a name="173"/>         }
<a name="174"/>      else
<a name="175"/>         return thisdate
<a name="176"/>      }
<a name="177"/>end
<a name="178"/>
<a name="179"/>
<a name="180"/>#######################################################
<a name="181"/>##  these are just functions which are used to extract
<a name="182"/>##  specific parts of a date if the date is formatted 
<a name="183"/>##  yyyy/mm/dd.  You can use these too if you want :)
<a name="184"/>##  you can pass in &amp;date to extract todays parts
<a name="185"/>#######################################################
<a name="186"/>
<a name="187"/>procedure getmonth(thisdate)
<a name="188"/>   local thismonth
<a name="189"/>   ##  this returns the number of the current month
<a name="190"/>   thisdate ? {
<a name="191"/>      thismonth := tab(find("/"))
<a name="192"/>      ="/"
<a name="193"/>      thismonth := tab(find("/"))
<a name="194"/>      ="/"
<a name="195"/>      return thismonth
<a name="196"/>      }
<a name="197"/>end
<a name="198"/>
<a name="199"/>procedure getday(thisdate)
<a name="200"/>   ##  this returns the number of the current day
<a name="201"/>   return right(thisdate, 2)
<a name="202"/>end
<a name="203"/>
<a name="204"/>procedure getyear(thisdate)
<a name="205"/>   ##  this returns the number of the current year
<a name="206"/>   return left(thisdate, 4)
<a name="207"/>end
</pre></body></html>
