<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>iterfncs.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     iterfncs.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures for recursive functions using iteration
<a name="6"/>#
<a name="7"/>#	Author:   Ralph E. Griswold
<a name="8"/>#
<a name="9"/>#	Date:     May 2, 2001
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#  These procedures implement commonly referenced ``text-book''
<a name="18"/>#  recursively defined functions, but using iteration.
<a name="19"/>#
<a name="20"/>#	acker(i, j)	  Ackermann's function
<a name="21"/>#	fib(i, j)	  Generalized Fibonacci (Lucas) sequence
<a name="22"/>#
<a name="23"/>############################################################################
<a name="24"/>#
<a name="25"/>#  See also:  fastfncs.icn, memrfncs.icn, and recrfncs.icn
<a name="26"/>#
<a name="27"/>############################################################################
<a name="28"/>
<a name="29"/>package ipl.iterfncs
<a name="30"/>
<a name="31"/>procedure acker(i, j)
<a name="32"/>   local k, value, place
<a name="33"/>
<a name="34"/>   if i = 0 then return j + 1
<a name="35"/>
<a name="36"/>   value := list(i + 1)
<a name="37"/>   place := list(i + 1)
<a name="38"/>
<a name="39"/>   value[1] := 1
<a name="40"/>   place[1] := 0
<a name="41"/>
<a name="42"/>   repeat {				# new value[1]
<a name="43"/>      value[1] +:= 1
<a name="44"/>      place[1] +:= 1
<a name="45"/>      every k := 1 to i do {		# propagate value
<a name="46"/>         if place[k] = 1 then {		# initiate new level
<a name="47"/>            value[k + 1] := value[1]
<a name="48"/>            place[k + 1] := 0
<a name="49"/>            if k ~= i then break next
<a name="50"/>            }
<a name="51"/>         else {
<a name="52"/>            if place[k] = value[k + 1] then {
<a name="53"/>               value[k + 1] := value[1]
<a name="54"/>               place[k + 1] +:= 1
<a name="55"/>               }
<a name="56"/>            else break next
<a name="57"/>            }
<a name="58"/>         }
<a name="59"/>         if place[i + 1] = j then return value[1]	# check for end
<a name="60"/>      }
<a name="61"/>
<a name="62"/>end
<a name="63"/>
<a name="64"/># generalized Fibonacci sequence
<a name="65"/>procedure fib(i, m)			
<a name="66"/>   local j, n, k
<a name="67"/>
<a name="68"/>   /m := 0
<a name="69"/>
<a name="70"/>   if i = 1 then return 1
<a name="71"/>   if i = 2 then return m + 1
<a name="72"/>
<a name="73"/>   j := 1
<a name="74"/>   k := m + 1
<a name="75"/>
<a name="76"/>   every 1 to i - 2 do {
<a name="77"/>      n := j + k
<a name="78"/>      j := k
<a name="79"/>      k := n
<a name="80"/>      }
<a name="81"/>
<a name="82"/>   return n
<a name="83"/>
<a name="84"/>end
</pre></body></html>
