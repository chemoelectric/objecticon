<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>xmlformatter.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: xmlformatter.icn 8058 2019-12-13 16:36:45Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package xml
<a name="10"/>
<a name="11"/>import util
<a name="12"/>
<a name="13"/>#
<a name="14"/># A formatter for XML documents.  The default formatter behaviour is to output the
<a name="15"/># string content as held in the children array (this may or may not have had whitespace
<a name="16"/># removed depending on whether validation against a DTD occurred), and without
<a name="17"/># indentation.
<a name="18"/>#
<a name="19"/>class XmlFormatter(Formatter)
<a name="20"/>   public
<a name="21"/>      indent, 
<a name="22"/>      no_whitespace_flag, 
<a name="23"/>      text_trim_flag, 
<a name="24"/>      as_read_flag
<a name="25"/>
<a name="26"/>   #
<a name="27"/>   # Ensure that each opening element appears with an indent of n chars.  Whitespace
<a name="28"/>   # will be inserted as appropriate.  By default, no indentation is done.
<a name="29"/>   #
<a name="30"/>   public set_indent(n)
<a name="31"/>      self.indent := /n | need_integer(n, 0)
<a name="32"/>      link
<a name="33"/>   end
<a name="34"/>
<a name="35"/>   #
<a name="36"/>   # Configure whether whitespace-only string content will be discarded.  The default
<a name="37"/>   # is off, ie keep whitespace.
<a name="38"/>   #
<a name="39"/>   public set_no_whitespace(s)
<a name="40"/>      self.no_whitespace_flag := need_flag(s)
<a name="41"/>      link
<a name="42"/>   end
<a name="43"/>
<a name="44"/>   #
<a name="45"/>   # Configure whether whitespace-only string content will be discarded,
<a name="46"/>   # and in addition any other string content will be trimmed at both ends.  The
<a name="47"/>   # default is off
<a name="48"/>   #
<a name="49"/>   public set_text_trim(s)
<a name="50"/>      self.text_trim_flag := need_flag(s)
<a name="51"/>      link
<a name="52"/>   end
<a name="53"/>
<a name="54"/>   #
<a name="55"/>   # Configure the formatter so that the string content will be output as read from
<a name="56"/>   # the input; ie the formatter uses the whitespace_children list rather than the children
<a name="57"/>   # list.  The default is off.
<a name="58"/>   #
<a name="59"/>   public set_as_read(s)
<a name="60"/>      as_read_flag := need_flag(s)
<a name="61"/>      link
<a name="62"/>   end
<a name="63"/>
<a name="64"/>   protected override format_document(n)
<a name="65"/>      local c
<a name="66"/>      every c := !n.children do {
<a name="67"/>         format_node(c)
<a name="68"/>         write()
<a name="69"/>      }
<a name="70"/>   end
<a name="71"/>
<a name="72"/>   protected override format_content(s)
<a name="73"/>      writes1(s)
<a name="74"/>   end
<a name="75"/>
<a name="76"/>   protected override format_doctype(n)
<a name="77"/>      local s, x
<a name="78"/>      s := "&lt;!DOCTYPE "
<a name="79"/>      s ||:= \n.name
<a name="80"/>      x := n.external_id
<a name="81"/>      if \x then {
<a name="82"/>         if \x.public_id then
<a name="83"/>            s ||:= " PUBLIC \"" || x.public_id || "\" \"" || x.system_id || "\""
<a name="84"/>         else
<a name="85"/>            s ||:= " SYSTEM \"" || x.system_id || "\""
<a name="86"/>      }
<a name="87"/>      s ||:= "&gt;"
<a name="88"/>      writes1(s)
<a name="89"/>   end
<a name="90"/>
<a name="91"/>   protected override format_comment(n)
<a name="92"/>      writes("&lt;!--", n.comment, "--&gt;")
<a name="93"/>   end
<a name="94"/>
<a name="95"/>   protected override format_pi(n)
<a name="96"/>      local s
<a name="97"/>      s := "&lt;?" || n.target
<a name="98"/>      if \n.content then
<a name="99"/>         s ||:= " " || n.content 
<a name="100"/>      s ||:= "?&gt;"
<a name="101"/>      writes1(s)
<a name="102"/>   end
<a name="103"/>
<a name="104"/>   protected override format_element(n)
<a name="105"/>      local s, istr1, istr2, x, l, e
<a name="106"/>
<a name="107"/>      if \indent then {
<a name="108"/>         istr1 := "\N" || repl(" ", indent * level)
<a name="109"/>         istr2 := "\N" || repl(" ", indent * (level - 1))
<a name="110"/>      }
<a name="111"/>
<a name="112"/>      s := "&lt;" || n.name
<a name="113"/>      if *n.attributes &gt; 0 then {
<a name="114"/>         s ||:= " "
<a name="115"/>         every x := !sort(n.attributes) do {
<a name="116"/>            s ||:= x[1] || "=\"" || xml_escape(x[2], '&amp;&lt;&gt;\"') || "\" "
<a name="117"/>         }
<a name="118"/>      }
<a name="119"/>      if *n.children = 0 then
<a name="120"/>         s ||:= "/&gt;"
<a name="121"/>      else
<a name="122"/>         s ||:= "&gt;"
<a name="123"/>      writes1(s)
<a name="124"/>
<a name="125"/>      if *n.children &gt; 0 then {
<a name="126"/>         l := get_children(n)
<a name="127"/>         if *l = 1 &amp; text(l[1]) then {
<a name="128"/>            writes1(xml_escape(l[1], '&amp;&lt;&gt;\"'))
<a name="129"/>         } else {
<a name="130"/>            every e := !l do {
<a name="131"/>               if \indent then
<a name="132"/>                  writes1(istr1)
<a name="133"/>               if text(e) then
<a name="134"/>                  writes1(xml_escape(e, '&amp;&lt;&gt;\"'))
<a name="135"/>               else
<a name="136"/>                  format_node(e)
<a name="137"/>            }
<a name="138"/>            if \indent then
<a name="139"/>               writes1(istr2)
<a name="140"/>         }
<a name="141"/>         writes("&lt;/", n.name, "&gt;")
<a name="142"/>      }
<a name="143"/>   end
<a name="144"/>
<a name="145"/>   private get_children(el)
<a name="146"/>      if \as_read_flag then
<a name="147"/>         return \el.whitespace_children | el.children
<a name="148"/>      if \no_whitespace_flag then
<a name="149"/>         return el.get_children_no_whitespace()
<a name="150"/>      if \text_trim_flag then
<a name="151"/>         return el.get_trimmed_children()
<a name="152"/>
<a name="153"/>      return el.children
<a name="154"/>   end
<a name="155"/>
<a name="156"/>   protected override format_cdata(n)
<a name="157"/>      writes("&lt;![CDATA[", n.content, "]]&gt;")
<a name="158"/>   end
<a name="159"/>
<a name="160"/>   protected override format_xmldecl(n)
<a name="161"/>      local s
<a name="162"/>      s := "&lt;?xml "
<a name="163"/>      if \n.version then
<a name="164"/>         s ||:= "version='" || n.version || "' "
<a name="165"/>      if \n.encoding then
<a name="166"/>         s ||:= "encoding='" || n.encoding || "' "
<a name="167"/>      if \n.standalone then
<a name="168"/>         s ||:= "standalone='" || n.standalone || "' "
<a name="169"/>      s ||:= "?&gt;"
<a name="170"/>      writes1(s)
<a name="171"/>   end
<a name="172"/>end
<a name="173"/>
</pre></body></html>
