package lang

import util(need_flag, error)

final abstract class Proc()
   public static const
      Procedure,
      Function,
      Keyword,
      Operator,
      Internal,
      Argument,
      Dynamic,
      Static

   private static init()
      # Kinds of procedure
      Procedure := 0
      Function :=  1
      Keyword :=   2
      Operator :=  3
      Internal :=  4
      # Types of local variable
      Argument := 0
      Dynamic := 1
      Static := 2
   end
      
   # Return the name of the proc
   #
   public static native get_name(p, flag)

   # Return the program this proc resides in.  The program's &main
   # co-expression is returned.
   #
   public static native get_program(p, flag)

   # Return the name of the package in which this proc resides; fails
   # if the proc is not in a package.
   #
   public static get_package(p, flag)
      local cl
      need_flag(flag)
      if /flag & cl := get_defining_class(p) then
         return Class.get_package(cl)
      if get_kind(p) = Procedure then
         return extract_package(get_name(p, &yes))
   end

   # Return the source location of the proc.  For a native method, `flag`
   # indicates whether to return the location of the native method
   # declaration, or to fail.
   # :Returns :
   # :  a `Location` instance
   #
   public static get_location(p, flag)
      local cl, i, prog
      need_flag(flag)
      return if prog := get_program(p, &yes) then {
         # Note that we ignore flag in this case since we don't want
         # to lookup (if flag is 1), a method's name in the global
         # table.  Otherwise, for example, if we had a procedure abc
         # and also a method Xyz.abc, then get_location(Xyz.abc, 1)
         # would erroneously return the location of procedure abc.
         if cl := get_defining_class(p) &
            i := get_field_index(p) then
            Class.get_field_location(cl, i)
         else
            Prog.get_global_location(get_name(p, &yes), prog)
      } else {
         if cl := get_defining_class(p) &
            i := get_field_index(p) &
            /flag then
            Class.get_field_location(cl, i)
         else
            error("Proc not a procedure, has no location")
      }
   end

   # Return the class in which this method is defined; fails if this is not a method.
   #
   public static native get_defining_class(p)

   # Return the field name of the method; fails if this is not a method.
   #
   public static native get_field_name(p)

   # Return the field index of the method; fails if this is not a method.
   #
   public static native get_field_index(p)

   #
   # Return the kind of this procedure, which is one of the constants :-
   #  `Procedure` for a procedure or method defined in an icon source file
   #  `Function` a builtin function like `upto`, or a native method
   #  `Keyword` a keyword function, obtained via `Prog.get_keyword()`
   #  `Operator` an operator function, obtained via `Prog.get_operator()`
   #  `Internal` an internally used block of VM instructions.
   #
   public static native get_kind(p)

   public static get_n_locals(p)
      return get_n_arguments(p) + get_n_dynamics(p) + get_n_statics(p)
   end

   public static native get_n_arguments(p)
   public static native has_varargs(p)
   public static native get_n_dynamics(p)
   public static native get_n_statics(p)
   public static native get_local_index(p, id)

   public static get_local_names(p)
      suspend get_local_name(p, 1 to get_n_locals(p))
   end

   public static get_local_location(p, id)
      return Location!get_local_location_impl(p, id)
   end

   private static native get_local_location_impl(p, id)

   public static native get_local_name(p, id)

   #
   # Return the type of the given local, which is one of the constants
   # `Argument`, `Dynamic` or `Static`.
   #
   public static native get_local_kind(p, id)

   # load C function dynamically.
   public static native load(filename, funcname)

   # Succeed if and only if the given procedure has a definition, ie
   # is not an unresolved native, deferred or abstract method.
   public static native is_defined(p)

   # Lookup a procedure (or function) by name.  First the globals are
   # searched for a matching procedure or function.  Failing that, the
   # builtin function, operator and keyword tables are searched.
   # 
   # :Parameters :
   # :  `s` - a name to search for
   # :  `n` - the arity of an operator
   # :  `ce` - a coexpression, representing a loaded program, defaults
   #   to the main program
   # :Returns :
   # :  a procedure
   # :Fails :
   # :  if the name is unknown as a proc
   #
   public static for_name(s, n, ce)
      return proc(s, n, ce)
   end
end
