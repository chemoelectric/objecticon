package eval

import ipl.pdco, ipl.lists, lang, util, exception, parser

abstract class EvaluatorEnv()
   public abstract get(k, ev)
end

class DefaultEvaluatorEnv(EvaluatorEnv)
   private 
      vars, consts
   private readable
      write_globals_flag

   public override get(k, ev)
      return (if \write_globals_flag then glookup(k, ev) else .glookup(k, ev)) | tlookup(k)
   end

   private tlookup(k)
      if upto('.', k) then
         (k ?:= (="default.", tab(0))) | runerr("No such id: " || k)
      return .member(\consts, k) | vars[k]
   end

   private glookup(k, ev)
      local t, f
      if upto('.', k) then {
         k ?:= (="default.", tab(0))
         return lang.Prog.get_global(k)
      }
      t := []
      if lang.Prog.get_global(k) then
         put(t, k)
      every f := ev.get_imports() || "." || k do {
         if lang.Prog.get_global(f) then
            put(t, f)
      }
      if *t = 1 then
         return lang.Prog.get_global(t[1])
      if *t > 1 then
         runerr("Ambiguous name: " || k || "(" || list2str(t) || ")")
   end

   public set_vars(t)
      self.vars := t
      link
   end

   public set_consts(t)
      self.consts := t
      link
   end

   public set_write_globals(f)
      write_globals_flag := need_flag(f)
      link
   end

   public new(v, c)
      /v := table()
      self.vars := v
      self.consts := c
      return
   end
end

class Evaluator()
   private
      # Map of nodes (loops, breaks) to the enclosing loop node.
      loops,
      brk,
      subject,
      imports,
      pos,
      # Map of nodes (loops, breaks) to the topmost scan node in the enclosing loop
      scans,
      env,
      node

   private const
      dispatch,
      cdispatch

   private compute_loops(n, loop, scan)
      if is(n, Node) then
         cdispatch[n.label](n, loop, scan)
   end

   private cdo_loop(n, loop, scan)
      loops[n] := loop
      scans[n] := scan
      every compute_loops(n.gen(), n)
   end

   private cdo_create(n, loop, scan)
      every compute_loops(n.gen())
   end

   private cdo_break(n, loop, scan)
      loops[n] := \loop | throw("break without loop")
      scans[n] := scan
   end

   private cdo_breakexpr(n, loop, scan)
      loops[n] := \loop | throw("break without loop")
      scans[n] := scan
      every compute_loops(n.gen(), loops[loop], scans[loop])
   end

   private cdo_next(n, loop, scan)
      loops[n] := \loop | throw("next without loop")
      scans[n] := scan
   end

   private cdo_exit(n, loop, scan)
      throw("suspend/return/succeed/link/fail not allowed")
   end

   private cdo_scan(n, loop, scan)
      every compute_loops(n.child(1), loop, scan)
      /scan := n
      every compute_loops(n.child(3), loop, scan)
   end

   private cdo_default(n, loop, scan)
      every compute_loops(n.gen(), loop, scan)
   end

   private loop(n, ex)
      local res
      brk[n] := &current
      while res := !ex do {
         (res === "next") | return res
      }
   end

   private restore(n)
      local x
      if x := \scans[n] then {
         &subject := subject[x]
         &pos := pos[x]
      }
   end

   private save(n)
      subject[n] := &subject
      pos[n] := &pos
      return
   end

   private do_everydo(n)
      local e
      e := create_E(n.child(2))
      suspend E(loop(n, create while @e do E(n.child(4)) ))
   end

   private do_every(n)
      local e
      e := create_E(n.child(2))
      suspend E(loop(n, create while @e ))
   end

   private create_E(e)
      return create E(e)
   end

   private pos_list(x)
      return ipl.pdco.List{ x.gen().pos }
   end

   private do_invoke(n)
      local x
      x := pos_list(ExprList(n, 3))
      suspend case *x of {
         0: E(n.child(1))()
         1: E(n.child(1))(E(x[1]))
         2: E(n.child(1))(E(x[1]),E(x[2]))
         3: E(n.child(1))(E(x[1]),E(x[2]),E(x[3]))
         4: E(n.child(1))(E(x[1]),E(x[2]),E(x[3]),E(x[4]))
         5: E(n.child(1))(E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]))
         6: E(n.child(1))(E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]))
         7: E(n.child(1))(E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]))
         8: E(n.child(1))(E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]))
         9: E(n.child(1))(E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]))
         10: E(n.child(1))(E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]))
         11: E(n.child(1))(E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                                   E(x[11]))
         12: E(n.child(1))(E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                                   E(x[11]),E(x[12]))
         13: E(n.child(1))(E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                                   E(x[11]),E(x[12]),E(x[13]))
         14: E(n.child(1))(E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                                   E(x[11]),E(x[12]),E(x[13]),E(x[14]))
         15: E(n.child(1))(E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                                   E(x[11]),E(x[12]),E(x[13]),E(x[14]),E(x[15]))
         16: E(n.child(1))(E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                                   E(x[11]),E(x[12]),E(x[13]),E(x[14]),E(x[15]),E(x[16]))
         default: runerr("Too many parameters")
      }
   end

   private do_coinvoke(n)
      local x
      x := pos_list(ExprList(n, 3))
      suspend case *x of {
         0: E(n.child(1)){}
         1: E(n.child(1)){E(x[1])}
         2: E(n.child(1)){E(x[1]),E(x[2])}
         3: E(n.child(1)){E(x[1]),E(x[2]),E(x[3])}
         4: E(n.child(1)){E(x[1]),E(x[2]),E(x[3]),E(x[4])}
         5: E(n.child(1)){E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5])}
         6: E(n.child(1)){E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6])}
         7: E(n.child(1)){E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7])}
         8: E(n.child(1)){E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8])}
         9: E(n.child(1)){E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9])}
         10: E(n.child(1)){E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10])}
         11: E(n.child(1)){E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                                   E(x[11])}
         12: E(n.child(1)){E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                                   E(x[11]),E(x[12])}
         13: E(n.child(1)){E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                                   E(x[11]),E(x[12]),E(x[13])}
         14: E(n.child(1)){E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                                   E(x[11]),E(x[12]),E(x[13]),E(x[14])}
         15: E(n.child(1)){E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                                   E(x[11]),E(x[12]),E(x[13]),E(x[14]),E(x[15])}
         16: E(n.child(1)){E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                                   E(x[11]),E(x[12]),E(x[13]),E(x[14]),E(x[15]),E(x[16])}
         default: runerr("Too many parameters")
      }
   end

   private do_subscript(n)
      local x
      x := pos_list(ExprList(n, 3))
      suspend case *x of {
         0: E(n.child(1))[]
         1: E(n.child(1))[E(x[1])]
         2: E(n.child(1))[E(x[1]),E(x[2])]
         3: E(n.child(1))[E(x[1]),E(x[2]),E(x[3])]
         4: E(n.child(1))[E(x[1]),E(x[2]),E(x[3]),E(x[4])]
         5: E(n.child(1))[E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5])]
         6: E(n.child(1))[E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6])]
         7: E(n.child(1))[E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7])]
         8: E(n.child(1))[E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8])]
         9: E(n.child(1))[E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9])]
         10: E(n.child(1))[E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10])]
         11: E(n.child(1))[E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                           E(x[11])]
         12: E(n.child(1))[E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                           E(x[11]),E(x[12])]
         13: E(n.child(1))[E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                           E(x[11]),E(x[12]),E(x[13])]
         14: E(n.child(1))[E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                           E(x[11]),E(x[12]),E(x[13]),E(x[14])]
         15: E(n.child(1))[E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                           E(x[11]),E(x[12]),E(x[13]),E(x[14]),E(x[15])]
         16: E(n.child(1))[E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
                           E(x[11]),E(x[12]),E(x[13]),E(x[14]),E(x[15]),E(x[16])]
         default: runerr("Too many subscripts")
      }
   end

   private do_paren(n)
      local x
      x := pos_list(ExprList(n, 2))
      suspend case *x of {
         0:  &null
         1:  E(x[1])
         2:  (E(x[1]),E(x[2]))
         3:  (E(x[1]),E(x[2]),E(x[3]))
         4:  (E(x[1]),E(x[2]),E(x[3]),E(x[4]))
         5:  (E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]))
         6:  (E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]))
         7:  (E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]))
         8:  (E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]))
         9:  (E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]))
         10: (E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]))
         11: (E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
              E(x[11]))
         12: (E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
              E(x[11]),E(x[12]))
         13: (E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
              E(x[11]),E(x[12]),E(x[13]))
         14: (E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
              E(x[11]),E(x[12]),E(x[13]),E(x[14]))
         15: (E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
              E(x[11]),E(x[12]),E(x[13]),E(x[14]),E(x[15]))
         16: (E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
              E(x[11]),E(x[12]),E(x[13]),E(x[14]),E(x[15]),E(x[16]))
         default: runerr("Too many parenthesized expressions")
      }
   end

   private do_brack(n)
      local x, l
      x := pos_list(ExprList(n, 2))
      suspend case *x of {
         0:  []
         1:  [E(x[1])]
         2:  [E(x[1]),E(x[2])]
         3:  [E(x[1]),E(x[2]),E(x[3])]
         4:  [E(x[1]),E(x[2]),E(x[3]),E(x[4])]
         5:  [E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5])]
         6:  [E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6])]
         7:  [E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7])]
         8:  [E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8])]
         9:  [E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9])]
         10:  [E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10])]
         11:  [E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
               E(x[11])]
         12:  [E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
               E(x[11]),E(x[12])]
         13:  [E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
               E(x[11]),E(x[12]),E(x[13])]
         14:  [E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
               E(x[11]),E(x[12]),E(x[13]),E(x[14])]
         15:  [E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
               E(x[11]),E(x[12]),E(x[13]),E(x[14]),E(x[15])]
         16:  [E(x[1]),E(x[2]),E(x[3]),E(x[4]),E(x[5]),E(x[6]),E(x[7]),E(x[8]),E(x[9]),E(x[10]),
               E(x[11]),E(x[12]),E(x[13]),E(x[14]),E(x[15]),E(x[16])]
         default: {
            l := ipl.pdco.List{ create_E(!x) }
            copy(Lifo!l)
         }
      }
   end

   private do_case(n)
      local l, v, cc, def
      l := pos_list(CaseList(n, 5))
      if v := E(n.child(2)) then {
         every cc := !l do {
            if cc.label == "cclause" then {
               if v === E(cc.child(1)) then {
                  suspend E(cc.child(3))
                  fail
               }
            } else # Default clause
               def := cc
         }
         if \def then
            suspend E(def.child(3))
      }
   end

   private do_section(n) 
      suspend case n.child(4).tok of {
         YY.COLON : E(n.child(1))[E(n.child(3)):E(n.child(5))]
         YY.PCOLON : E(n.child(1))[E(n.child(3))+:E(n.child(5))]
         YY.MCOLON : E(n.child(1))[E(n.child(3))-:E(n.child(5))]
      }
   end

   private do_dottedident(n)
      local ls
      ls := Util.dottedid2string(n.child(1))
      if (ls == "default") | member(\imports, ls) then
         return env.get(ls || "." || n.child(3).s, self)
      suspend Class_get(E(n.child(1)), n.child(3).s)
   end

   # This is wrapped in a static method so that lookups if x is a
   # class give the right error message (606 rather than 607).
   private static Class_get(x, field)
      return lang.Class.get(x, field)
   end

   private do_keyword(n) 
      local s, f
      s := "&" || n.child(2).s
      f := lang.Prog.get_keyword(s) | runerr("Invalid keyword: "|| s)
      suspend f() 
   end

   private do_and(n) suspend E(n.child(1)) & E(n.child(3)) end
   private do_Bqmark(n) suspend 1(E(n.child(1)),save(n)) ? E(n.child(3)) end
   private do_swap(n) suspend E(n.child(1)) :=: E(n.child(3)) end
   private do_assign(n) suspend E(n.child(1)) := E(n.child(3)) end
   private do_revswap(n) suspend E(n.child(1)) <-> E(n.child(3)) end
   private do_revassign(n) suspend E(n.child(1)) <- E(n.child(3)) end
   private do_augconcat(n) suspend E(n.child(1)) ||:= E(n.child(3)) end
   private do_auglconcat(n) suspend E(n.child(1)) |||:= E(n.child(3)) end
   private do_augdiff(n) suspend E(n.child(1)) --:= E(n.child(3)) end
   private do_augunion(n) suspend E(n.child(1)) ++:= E(n.child(3)) end
   private do_augplus(n) suspend E(n.child(1)) +:= E(n.child(3)) end
   private do_augminus(n) suspend E(n.child(1)) -:= E(n.child(3)) end
   private do_augstar(n) suspend E(n.child(1)) *:= E(n.child(3)) end
   private do_auginter(n) suspend E(n.child(1)) **:= E(n.child(3)) end
   private do_augslash(n) suspend E(n.child(1)) /:= E(n.child(3)) end
   private do_augmod(n) suspend E(n.child(1)) %:= E(n.child(3)) end
   private do_augcaret(n) suspend E(n.child(1)) ^:= E(n.child(3)) end
   private do_augnmeq(n) suspend E(n.child(1)) =:= E(n.child(3)) end
   private do_augequiv(n) suspend E(n.child(1)) ===:= E(n.child(3)) end
   private do_augnmge(n) suspend E(n.child(1)) >=:= E(n.child(3)) end
   private do_augnmgt(n) suspend E(n.child(1)) >:= E(n.child(3)) end
   private do_augnmle(n) suspend E(n.child(1)) := E(n.child(3)) end
   private do_augnmlt(n) suspend E(n.child(1)) <:= E(n.child(3)) end
   private do_augnmne(n) suspend E(n.child(1)) ~=:= E(n.child(3)) end
   private do_augnequiv(n) suspend E(n.child(1)) ~===:= E(n.child(3)) end
   private do_augseq(n) suspend E(n.child(1)) ==:= E(n.child(3)) end
   private do_augsge(n) suspend E(n.child(1)) >>=:= E(n.child(3)) end
   private do_augsgt(n) suspend E(n.child(1)) >>:= E(n.child(3)) end
   private do_augsle(n) suspend E(n.child(1)) <<=:= E(n.child(3)) end
   private do_augslt(n) suspend E(n.child(1)) <<:= E(n.child(3)) end
   private do_augsne(n) suspend E(n.child(1)) ~==:= E(n.child(3)) end
   private do_augqmark(n) suspend 1(E(n.child(1)),save(n)) ?:= E(n.child(3)) end
   private do_augand(n) suspend E(n.child(1)) &:= E(n.child(3)) end
   private do_augat(n) suspend E(n.child(1)) @:= E(n.child(3)) end
   private do_augbang(n) suspend E(n.child(1)) !:= E(n.child(3)) end
   private do_to(n) suspend E(n.child(1)) to E(n.child(3)) end
   private do_toby(n) suspend E(n.child(1)) to E(n.child(3)) by E(n.child(5)) end
   private do_Bbar(n) suspend E(n.child(1)) | E(n.child(3)) end
   private do_Bseq(n) suspend E(n.child(1)) == E(n.child(3)) end
   private do_Bsge(n) suspend E(n.child(1)) >>= E(n.child(3)) end
   private do_Bsgt(n) suspend E(n.child(1)) >> E(n.child(3)) end
   private do_Bsle(n) suspend E(n.child(1)) <<= E(n.child(3)) end
   private do_Bslt(n) suspend E(n.child(1)) << E(n.child(3)) end
   private do_Bsne(n) suspend E(n.child(1)) ~== E(n.child(3)) end
   private do_Bnmeq(n) suspend E(n.child(1)) = E(n.child(3)) end
   private do_Bnmge(n) suspend E(n.child(1)) >= E(n.child(3)) end
   private do_Bnmgt(n) suspend E(n.child(1)) > E(n.child(3)) end
   private do_Bnmle(n) suspend E(n.child(1)) <= E(n.child(3)) end
   private do_Bnmlt(n) suspend E(n.child(1)) < E(n.child(3)) end
   private do_Bnmne(n) suspend E(n.child(1)) ~= E(n.child(3)) end
   private do_Bequiv(n) suspend E(n.child(1)) === E(n.child(3)) end
   private do_Bnequiv(n) suspend E(n.child(1)) ~=== E(n.child(3)) end
   private do_Bconcat(n) suspend E(n.child(1)) || E(n.child(3)) end
   private do_Blconcat(n) suspend E(n.child(1)) ||| E(n.child(3)) end
   private do_Bplus(n) suspend E(n.child(1)) + E(n.child(3)) end
   private do_Bdiff(n) suspend E(n.child(1)) -- E(n.child(3)) end
   private do_Bunion(n) suspend E(n.child(1)) ++ E(n.child(3)) end
   private do_Bminus(n) suspend E(n.child(1)) - E(n.child(3)) end
   private do_Bstar(n) suspend E(n.child(1)) * E(n.child(3)) end
   private do_Binter(n) suspend E(n.child(1)) ** E(n.child(3)) end
   private do_Bslash(n) suspend E(n.child(1)) / E(n.child(3)) end
   private do_Bmod(n) suspend E(n.child(1)) % E(n.child(3)) end
   private do_Bcaret(n) suspend E(n.child(1)) ^ E(n.child(3)) end
   private do_Bbackslash(n) suspend E(n.child(1)) \ E(n.child(3)) end
   private do_Bat(n) suspend E(n.child(1)) @ E(n.child(3)) end
   private do_Bbang(n) suspend E(n.child(1)) ! E(n.child(3)) end
   private do_Uat(n) suspend  @E(n.child(2)) end
   private do_Unot(n) suspend not E(n.child(2)) end
   private do_Ubar(n) suspend |E(n.child(2)) end
   private do_Uconcat(n) suspend |E(n.child(2)) end
   private do_Ulconcat(n) suspend |E(n.child(2)) end
   private do_Udot(n) suspend .E(n.child(2)) end
   private do_Ubang(n) suspend !E(n.child(2)) end
   private do_Udiff(n) suspend --E(n.child(2)) end
   private do_Uplus(n) suspend +E(n.child(2)) end
   private do_Ustar(n) suspend *E(n.child(2)) end
   private do_Uslash(n) suspend /E(n.child(2)) end
   private do_Ucaret(n) suspend ^E(n.child(2)) end
   private do_Uinter(n) suspend **E(n.child(2)) end
   private do_Utilde(n) suspend ~E(n.child(2)) end
   private do_Uminus(n) suspend -E(n.child(2)) end
   private do_Unmeq(n) suspend =E(n.child(2)) end
   private do_Unmne(n) suspend ~=E(n.child(2)) end
   private do_Useq(n) suspend ==E(n.child(2)) end
   private do_Usne(n) suspend ~==E(n.child(2)) end
   private do_Uequiv(n) suspend ===E(n.child(2)) end
   private do_Uunion(n) suspend ++E(n.child(2)) end
   private do_Uqmark(n) suspend ?E(n.child(2)) end
   private do_Unequiv(n) suspend ~===E(n.child(2)) end
   private do_Ubackslash(n) suspend \E(n.child(2)) end
   private do_field(n) suspend Class_get(E(n.child(1)), n.child(3).s) end
   private do_if(n) suspend if E(n.child(2)) then E(n.child(4)) end
   private do_ifelse(n) suspend if E(n.child(2)) then E(n.child(4)) else E(n.child(6)) end
   private do_unless(n) suspend unless E(n.child(2)) then E(n.child(4)) end
   private do_unlesselse(n) suspend unless E(n.child(2)) then E(n.child(4)) else E(n.child(6)) end
   private do_whiledo(n) suspend E( loop(n, create  while E(n.child(2)) do E(n.child(4)) )) end
   private do_while(n) suspend E( loop(n, create  while E(n.child(2)) )) end
   private do_untildo(n) suspend E( loop(n, create  until E(n.child(2)) do E(n.child(4)) )) end
   private do_until(n) suspend E( loop(n, create  until E(n.child(2)) )) end
   private do_repeat(n) suspend E( loop(n, create  repeat E(n.child(2)) )) end
   private do_create(n) return create_E(n.child(2)) end
   private do_brace(n) suspend E(n.child(2)) end
   private do_compound(n) suspend { E(n.child(1)) ; E(n.child(3)) } end
   private do_break(n) restore(n) ; return coact(Factory.new_keyword(, "null"), brk[loops[n]]) end
   private do_next(n) restore(n) ; return coact("next", brk[loops[n]]) end
   private do_breakexpr(n) restore(n) ; return coact(n.child(2), brk[loops[n]]) end
   private do_Empty(n) return end
   private do_default(n) fatalerr("Not implemented: " || n.label) end

   private E(n)
      if is(n, Token) then
         return case n.tok of {
            YY.IDENT: env.get(n.s, self)
            YY.INTLIT|YY.REALLIT|YY.STRINGLIT|YY.CSETLIT|YY.UCSLIT: n.val
            default : fatalerr("Not implemented: token " || to_string(n))
         }
      suspend dispatch[n.label](n)
   end
   
   public eval()
      (\env & \node) | runerr("eval() called without environment and/or node being set")
      brk := table()
      subject := table()
      pos := table()
      suspend E(node)
   end

   public set_env(env)
      self.env := env
      link
   end

   public set_node(n)
      loops := table()
      scans := table()
      node := n
      try1 { compute_loops(n) } | {
         node := loops := scans := &null
         fail
      }
      link
   end

   public set_imports(t)
      self.imports := t
      link
   end

   public get_imports()
      suspend .!\imports
   end

   public new()
      self.dispatch := table(do_default,
                             "Bat", do_Bat,
                             "Bbackslash", do_Bbackslash,
                             "Bbang", do_Bbang,
                             "Bbar", do_Bbar,
                             "Bcaret", do_Bcaret,
                             "Bconcat", do_Bconcat,
                             "Bdiff", do_Bdiff,
                             "Bequiv", do_Bequiv,
                             "Binter", do_Binter,
                             "Blconcat", do_Blconcat,
                             "Bminus", do_Bminus,
                             "Bmod", do_Bmod,
                             "Bnequiv", do_Bnequiv,
                             "Bnmeq", do_Bnmeq,
                             "Bnmge", do_Bnmge,
                             "Bnmgt", do_Bnmgt,
                             "Bnmle", do_Bnmle,
                             "Bnmlt", do_Bnmlt,
                             "Bnmne", do_Bnmne,
                             "Bplus", do_Bplus,
                             "Bqmark", do_Bqmark,
                             "Bseq", do_Bseq,
                             "Bsge", do_Bsge,
                             "Bsgt", do_Bsgt,
                             "Bslash", do_Bslash,
                             "Bsle", do_Bsle,
                             "Bslt", do_Bslt,
                             "Bsne", do_Bsne,
                             "Bstar", do_Bstar,
                             "Bunion", do_Bunion,
                             "Empty", do_Empty,
                             "Uat", do_Uat,
                             "Ubackslash", do_Ubackslash,
                             "Ubang", do_Ubang,
                             "Ubar", do_Ubar,
                             "Ucaret", do_Ucaret,
                             "Uconcat", do_Uconcat,
                             "Udiff", do_Udiff,
                             "Udot", do_Udot,
                             "Uequiv", do_Uequiv,
                             "Uinter", do_Uinter,
                             "Ulconcat", do_Ulconcat,
                             "Uminus", do_Uminus,
                             "Unequiv", do_Unequiv,
                             "Unmeq", do_Unmeq,
                             "Unmne", do_Unmne,
                             "Unot", do_Unot,
                             "Uplus", do_Uplus,
                             "Uqmark", do_Uqmark,
                             "Useq", do_Useq,
                             "Uslash", do_Uslash,
                             "Usne", do_Usne,
                             "Ustar", do_Ustar,
                             "Utilde", do_Utilde,
                             "Uunion", do_Uunion,
                             "and", do_and,
                             "assign", do_assign,
                             "augand", do_augand,
                             "augat", do_augat,
                             "augbang", do_augbang,
                             "augcaret", do_augcaret,
                             "augconcat", do_augconcat,
                             "augdiff", do_augdiff,
                             "augequiv", do_augequiv,
                             "auginter", do_auginter,
                             "auglconcat", do_auglconcat,
                             "augminus", do_augminus,
                             "augmod", do_augmod,
                             "augnequiv", do_augnequiv,
                             "augnmeq", do_augnmeq,
                             "augnmge", do_augnmge,
                             "augnmgt", do_augnmgt,
                             "augnmle", do_augnmle,
                             "augnmlt", do_augnmlt,
                             "augnmne", do_augnmne,
                             "augplus", do_augplus,
                             "augqmark", do_augqmark,
                             "augseq", do_augseq,
                             "augsge", do_augsge,
                             "augsgt", do_augsgt,
                             "augslash", do_augslash,
                             "augsle", do_augsle,
                             "augslt", do_augslt,
                             "augsne", do_augsne,
                             "augstar", do_augstar,
                             "augunion", do_augunion,
                             "brace", do_brace,
                             "brack", do_brack,
                             "break", do_break,
                             "breakexpr", do_breakexpr,
                             "case", do_case,
                             "coinvoke", do_coinvoke,
                             "compound", do_compound,
                             "create", do_create,
                             "default", do_default,
                             "dottedident", do_dottedident,
                             "every", do_every,
                             "everydo", do_everydo,
                             "field", do_field,
                             "if", do_if,
                             "ifelse", do_ifelse,
                             "invoke", do_invoke,
                             "keyword", do_keyword,
                             "next", do_next,
                             "paren", do_paren,
                             "repeat", do_repeat,
                             "revassign", do_revassign,
                             "revswap", do_revswap,
                             "section", do_section,
                             "subscript", do_subscript,
                             "swap", do_swap,
                             "to", do_to,
                             "toby", do_toby,
                             "unless", do_unless,
                             "unlesselse", do_unlesselse,
                             "until", do_until,
                             "untildo", do_untildo,
                             "while", do_while,
                             "whiledo", do_whiledo
                             )
      self.cdispatch := table(cdo_default)
      every cdispatch["everydo"|"every"|"whiledo"|"while"|"untildo"|"until"|"repeat"] := cdo_loop
      cdispatch["create"] := cdo_create
      cdispatch["break"] := cdo_break
      cdispatch["breakexpr"] := cdo_breakexpr
      cdispatch["next"] := cdo_next
      every cdispatch["fail"|"return"|"returnexpr"|"succeed"|"succeedexpr"|"link"|
                      "linkexpr"|"suspend"|"suspendexpr"|"suspendexprdo"] := cdo_exit
      every cdispatch["augqmark"|"Bqmark"] := cdo_scan
      return
   end
end
