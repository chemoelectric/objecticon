############################################################################
#
#	File:     sets.icn
#
#	Subject:  Procedures for set manipulation
#
#	Author:   Alan Beale
#
#	Date:     August 7, 1999
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#	Contributor:  Ralph E. Griswold
#
############################################################################
#
#       elementset(x)   returns a set that contains the individual elements
#                       of x, generated by the ! operator.
#
#       domain(T)       returns the domain of the function defined by the
#                       table T.
#
#       inverse(T, x)   returns the inverse of the function defined by the
#                       table T.  If x is null, it's the functional inverse.
#                       If x is an empty list, it's the relational inverse.
#                       If x is an empty set, it the relational inverse, but
#                       with each table member as a set instead of a list.
#
#       pairset(T)      converts the table T to an equivalent set of ordered
#                       pairs.
#
#       range(T)        returns the range of the function defined by the
#                       table T.
#  
#       seteq(S1, S2)   tests equivalence of sets S1 and S2.
#
#       setlt(S1, S2)   tests inclusion of set S1 in S2.
#
#       simage(S)       string image of set
#
############################################################################

package ipl.sets

# Returns a set that contains the individual elements of `x`,
# generated by the `!` operator.
#
procedure elementset(x)			
   local result

   result := set()
   every insert(result, !x)

   return result

end

# Converts the table `T` to an equivalent set of ordered pairs.
procedure pairset(T)			
    return elementset(sort(T))
end

# Returns the domain of the function defined by the table `T`.
procedure domain(T)			
    local dom

    dom := set()
    every insert(dom, key(T))
    return dom
end

# Returns the range of the function defined by the table `T`.
procedure range(T)			
    local ran

    ran := set()
    every insert(ran, !T)
    return ran
end

# Returns the inverse of the function defined by the table `T`.  If
# `Default` is null, it's the functional inverse.  If `Default` is an
# empty list, it's the relational inverse.  If `Default` is an empty
# set, it the relational inverse, but with each table member as a set
# instead of a list.
#
procedure inverse(T, Default)		
    local inv, delem, relem

    inv := table(Default)
    every delem := key(T) do {
        if type(Default) == "list" then
          if member(inv, relem := T[delem]) then
            put(inv[relem], delem)
          else inv[relem] := [delem]
        else if type(Default) == "set" then
          if member(inv, relem := T[delem]) then
            insert(inv[relem], delem)
          else inv[relem] := set(delem)
        else inv[T[delem]] := delem
    }
    return inv
end

# Tests equivalence of sets `set1` and `set2`.
procedure seteq(set1, set2)		
   local x

   if *set1 ~= *set2 then fail
   every x := !set1 do
      if not member(set2, x) then fail
   return set2

end

# Tests inclusion of set `set1` in `set2`.
procedure setlt(set1, set2)		
   local x

   if *set1 >= *set2 then fail
   every x := !set1 do
      if not member(set2, x) then fail
   return set2

end

# Test if `set1` is a subset of `set2`.
procedure setle(set1, set2)		
   local x

   if *set1 > *set2 then fail
   every x := !set1 do
      if not member(set2, x) then fail
   return set2

end

# String image of set
procedure simage(set)			
   local result

   result := ""

   every result ||:= image(!set) || ", "

   return "{ " || result[1:-2] || " }"

end
