############################################################################
#
#	File:     io.icn
#
#	Subject:  Procedures for input and output
#
#	Author:   Ralph E. Griswold
#
#	Date:     October 6, 2000
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#  Contributors:  Paul Abrahams, Bob Alexander, Will Evans, David A. Gamey,
#		  Richard L. Goerwitz, Will Menagarini, Charles Sharstis,
#		  and Gregg Townsend.
#
############################################################################
#
#  They provide facilities for handling input, output, and files.
#
#  There are other modules in the Icon program library that deal with
#  input and output.  They are not included here because they conflict
#  with procedures here or each other.
#
############################################################################
#
#  Links:  random, strings
#
############################################################################
#
#  Reading and writing files:
#
#	filetext(f)	reads the lines of f into a list and returns that
#			list
#
#	readline(file)	assembles backslash-continued lines from the specified
#			file into a single line.  If the last line in a file
#			ends in a backslash, that character is included in the
#			last line read.
#
#	splitline(file, line, limit)
#			splits line into pieces at first blank after
#			the limit, appending a backslash to identify split
#			lines (if a line ends in a backslash already, that's
#			too bad). The pieces are written to the	specified file.
#
############################################################################
#
#  Buffered input and output:
#
#	 ClearOut()	remove contents of output buffer without writing
#	 Flush()	flush output buffer
#	 GetBack()	get back line writen
#	 LookAhead()	look ahead at next line
#	 PutBack(s)	put back a line
#	 Read()		read a line
#	 ReadAhead(n)	read ahead n lines
#	 Write(s)	write a line
#
############################################################################

package ipl.io

import
   io(DescStream, FileOpt, FileStream, Files,
      Poll, close, open, read,
      stop, write),
   posix(System),
   util(error)

global buffer_in, buffer_out, Eof

# remove contents of output buffer
procedure ClearOut()			

   buffer_out := []

end

# flush output buffer
procedure Flush()			

   while write(pull(buffer_out))

   return

end

# get back line written
procedure GetBack()			

   return get(buffer_out)

end

# look at next line
procedure LookAhead()			

   return buffer_in[1]

end

# put back line read
procedure PutBack(s)			

   push(buffer_in,s)

   return

end

# read a line in buffered mode
procedure Read()			

   initial{
      buffer_in := []
      }

   if *buffer_in = 0 then
      put(buffer_in,read()) | (Eof := 1)
   return get(buffer_in)

end

# read ahead
procedure ReadAhead(n)			

   while *buffer_in < n do
      put(buffer_in,read()) | {
         Eof := 1
         fail
         }

   return

end

# write in buffered mode
procedure Write(s)			

   initial buffer_out := []

   push(buffer_out,s)
 
   return s

end

# open file on DPATH
procedure dopen(s)
   return open(Files.path_find(s, "DPATH"))
end

# read file into list
procedure filetext(f)			
   local input, text

   input := open(f) | stop("cannot open input file")

   text := []

   while put(text,read(input))

   close(input)

   return text

end

# assemble backslash-continued lines
procedure readline(file)		
   local line

   line := read(file) | fail

   while line[-1] == "\\" do
      line := line[1:-1] || read(file) | break

   return line

end

# split line into pieces
procedure splitline(file,line,limit)	
   local i, j

   if *line = 0 then {			# don't fail to write empty line
      write(file,line)
      return
      }
   while *line > limit do {
      line ?:= {
         i := j := 0
         every i := find(" ") do {	# find a point to split
            if i >= limit then break
            else j := i
            }
         if j = 0 then {		# can't split
            write(file,line)
            return
            }
         write(file,tab(j + 1),"\\")
         tab(0)				# update line
         }
      }
   if *line > 0 then write(file,line)	# the rest

   return

end

# The {posix.ExitInfo} of the last child process started by {filter} or {gather}
global last_exit_info

#
# Gather the output of an external command that takes no input.
#
# @param cmd the name of the command
# @param args the arg list
# @param env the env list
# @return the output of the command as a string
# @example
# @   gather("ls", ["/tmp"])
#
procedure gather(cmd, args, env)
   local pid, t, in, l
   l := FileStream.pipe() | fail
   pid := System.fork() | {
      every (!l).close()
      fail
   }
   if pid > 0 then {
      # Parent
      l[2].close()
      in := l[1]
      t := in.read_all() | {
         in.close()
         fail
      }
      in.close()
      last_exit_info := System.wait(pid) | fail
      return t
   } else {
      # Child
      l[2].dup2(FileStream.stdout) | stop(&why)
      every (!l).close()
      System.exec(cmd, args, env) | stop(&why)
      syserr("Not reached")
   }
end

#
# Filter a string through an external command, which is expected to read
# all of the provided data.
#
# @param data - a string which is fed as input to the command
# @param cmd the name of the command
# @param args the arg list
# @param env the env list
# @return the output of the command as a string
# @example
# @   filter(data, "gzip", ["-c"])
#
procedure filter(data, cmd, args, env)
   local pid, t, in, out, l

   l := FileStream.pipe() | fail
   (l |||:= FileStream.pipe() &
    pid := System.fork()) | {
      every (!l).close()
      fail
   }
   if pid > 0 then {
      # Parent
      l[2].close()
      l[3].close()
      in := l[1]
      out := l[4]
      t := filter1(data, in, out) | {
         in.close()
         out.close()
         fail
      }
      out.close()
      t ||:= in.read_all() | {
         in.close()
         fail
      }
      in.close()
      last_exit_info := System.wait(pid) | fail
      return t
   } else {
      # Child
      l[2].dup2(FileStream.stdout) | stop(&why)
      l[3].dup2(FileStream.stdin) | stop(&why)
      every (!l).close()
      System.exec(cmd, args, env) | stop(&why)
      syserr("Not reached")
   }
end

procedure filter1(data, in, out)
   local t, x, n
   data := string(data) | runerr(103, data)
   in.flag(FileOpt.NONBLOCK) | fail
   out.flag(FileOpt.NONBLOCK) | fail
   t := ""
   repeat {
      x := DescStream.poll([in, Poll.IN, out, Poll.OUT]) | fail
      if x[1] = Poll.IN then {
         t ||:= in.in(1048576) | fail
      } else if x[2] = Poll.OUT then {
         n := out.out(data) | fail
         data := data[n + 1:0]
         if *data = 0 then {
            in.flag(,FileOpt.NONBLOCK) | fail
            return t
         }
      } else
         return error("filter: child command i/o failed")
   }
end

procedure gzip(data)
   return filter(data, "gzip", ["-c"])
end

procedure gunzip(data)
   return filter(data, "gunzip", ["-c"])
end
