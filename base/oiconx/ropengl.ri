/*
 *  File: ropengl.ri
 *     3D facilities OpenGL support routines
 */
int texture(int width, int height, GLubyte *tex, int texmode);
wtp lookup_texture_byname(wbp w, char *name, int len, int type);

FILE *wopengl(char *name, struct b_list *lp, dptr attr, int n, int *err_index)
{
   FILE *f;
   wbp  w;
   wsp  ws;
   wcp  wc;
   GLfloat ambient_model[] = {0.2, 0.2, 0.2, 1.0};
   int  query;
   int major, minor;

   /* create an opengl window */
#ifdef XWindows
   int  L[] = {GLX_RGBA, GLX_DOUBLEBUFFER, GLX_DEPTH_SIZE, 16, None};

  /* create an opengl window */
   wdp wd = alc_display(NULL);
   if (!glXQueryExtension(wd->display, &query, &query)) {
      printf("X server has no OpenGL GLX extension");
      return NULL;
      }
   wd->vis = glXChooseVisual(wd->display, wd->screen, L);
   if (wd->vis == NULL) {
      printf("visual failed");
      return NULL;
      }
#endif					/* XWindows */
   f = wopen(name, lp, attr, n, err_index, 1);

   if (!f) return NULL;
   w = (wbp) f;
   ws = w->window;
   wc = w->context;

  /* set defaults for attributes */
   wc->eyeupx = wc->eyeupz = 0.0;
   wc->eyeupy = 1.0;
   wc->dim = 3;
   wc->eyeposx = wc->eyeposy =  wc->eyeposz = wc->eyedirx = wc->eyediry = 0.0;
   wc->eyedirz = -100.0;
   wc->autogen = 1;
   wc->texmode = wc->numtexcoords = 0;
   wc->texName = malloc(16 * sizeof(GLuint));
   if (wc->texName == NULL) return NULL;
   wc->nalced = 16;
   wc->texcoords = malloc(256 * sizeof (double));
   if (wc->texcoords == NULL) return NULL;
   wc->ntexcoordsalced = 256;
   wc->ntextures = 0;
   wc->curtexture = -1;

   /* create an empty list for list of function calls */
   if ((ws->funclist.vword.bptr = (union block *)alclist(0, MinListSlots)) == NULL)
      return NULL;
   ws->funclist.dword = D_List;

   /* set up the appropriate opengl states */
   glViewport(0, 0, (GLsizei)ws->width, (GLsizei)ws->height);
   glClearColor(RED(wc->bg)/(GLfloat)255, GREEN(wc->bg)/(GLfloat)255,
		BLUE(wc->bg)/(GLfloat)255, 0.0);

   glGenTextures(16, wc->texName);
   glEnable(GL_DEPTH_TEST);
   glEnable(GL_BLEND);
   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_TEXTURE_GEN_S);
   glEnable(GL_TEXTURE_GEN_T);
   glMaterialf(GL_FRONT, GL_SHININESS, 50.0);
   glEnable(GL_LIGHTING);
   glEnable(GL_LIGHT0);
   glEnable(GL_NORMALIZE);
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   glFrustum(-0.125, 0.125, -0.125 * ws->height / ws->width,
	     0.125 * ws->height / ws->width, 0.25, 50000.0);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   return f;
}


/*
 * code for primitives -- polygon, lines, points, segments, filled polygons,
 * tori, spheres, cubes, cylinders, and disks.
 */

/*
 * drawpoly() - draws polygons, lines, points, segments, and filled polygons
 */
int drawpoly(wbp w, double* v, int num, int type, int dim)
{
   int i, j;
   wcp wc = w->context;

   makecurrent(w);
   /* must reset the current normal vector */
   glNormal3f(0.0, 0.0, 1.0);

   /* each vertex has an x-coordinate and a y-coordinate */
   if (dim == 2){

      /* no texturing */
      if (!wc->texmode) {
         glBegin(type);
         for (i = 0; i < num; i=i+2)
            glVertex2d(v[i], v[i+1]);
         glEnd();
        }
      else {
         /* opengl will generate texture coordinates */
         if (wc->autogen) {
            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glBegin(type);
            for (i = 0; i < num; i=i+2)
               glVertex2d(v[i], v[i+1]);
            glEnd();
           }
         else {
            /*
             * There must be at least the same number of texture coordinate
             * pairs as there are vertices. If not, fail.
             */
            if (num/2 > wc->numtexcoords/2)
               return Failed;
            glBegin(type);
            j = 0;
            for (i = 0; i < num; i = i+2) {
               glTexCoord2f(wc->texcoords[j], wc->texcoords[j+1]);
               glVertex2d(v[i], v[i+1]);
               j += 2;
             }
            glEnd();
           }
        }
     }

   /* each vertex is of the form (x, y, z) */
   if (dim == 3){
      if (!wc->texmode) {
         glBegin(type);
         for (i = 0; i < num; i = i+3)
            glVertex3d(v[i], v[i+1], v[i+2]);
         glEnd();
       }
      else {

	 /* opengl should generate the texture coordinate */
         if (wc->autogen){

            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);

            glBegin(type);
            for (i = 0; i < num; i=i+3)
               glVertex3d(v[i], v[i+1], v[i+2]);
            glEnd();
           }
         else {
            /*
	     * If there are not the same number of texture coordinate pairs
	     * as there are vertices, fail.
	     */
            if (num/3 > wc->numtexcoords/2)
              return Failed;
            glBegin(type);
            j = 0;
            for (i = 0; i < num; i=i+3) {
               glTexCoord2f(wc->texcoords[j], wc->texcoords[j+1]);
               glVertex3d(v[i], v[i+1], v[i+2]);
               j = j + 2;
             }
            glEnd();
         }
      }
   }
   /* each vertex is of the form (x, y, z, w) */
   if (dim == 4){
      if (!wc->texmode){
         glBegin(type);
         for (i = 0; i < num; i=i+4)
            glVertex4d(v[i], v[i+1], v[i+2], v[i+3]);
         glEnd();
        }
      else {
         /* have opengl generate texture coordinates */
         if (wc->autogen){
            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glBegin(type);
            for (i = 0; i < num; i=i+4)
              glVertex4d(v[i], v[i+1], v[i+2], v[i+3]);
            glEnd();
           }
	 else {
	    /*
	     * fail if the number of vertices is more than
	     * the number of texture coordinate pairs
	     */
            if (num/4 > wc->numtexcoords/2)
               return Failed;
            glBegin(type);
            j = 0;
            for (i = 0; i < num; i=i+4) {
               glTexCoord2f(wc->texcoords[j], wc->texcoords[j+1]);
               glVertex4d(v[i], v[i+1], v[i+2], v[i+3]);
               j = j + 2;
              }
            glEnd();
           }
         }
       }
   return Succeeded;
}


/* helper function to draw a torus */
void torus(double radius1, double radius2, double x,double y, double z,int gen)
{
   int i, j;
   GLfloat theta, phi, theta1;
   GLfloat cosTheta, sinTheta;
   GLfloat cosTheta1, sinTheta1;
   GLfloat ringDelta, sideDelta;
   GLint rings = 16, nsides = 16;

   /* generate texture coordinates if needed */
   if (gen == 1){
      glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
      glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
      }

   /* push matrix to preform the needed translation */
   glPushMatrix();
   glTranslatef(x, y, z);

#ifndef M_PI
#define M_PI        3.14159265358979323846264338327950288419716939937511
#endif					/* M_PI */

   /* rotate to make the torus look nicer */
   glRotatef(130.0, 1.0, 0.0, 0.0);
   ringDelta = 2.0 * M_PI / rings;
   sideDelta = 2.0 * M_PI / nsides;
   theta = 0.0;
   cosTheta = 1.0;
   sinTheta = 0.0;

   /* draw the torus */
   for (i = rings - 1; i >= 0; i--) {
      theta1 = theta + ringDelta;
      cosTheta1 = cos(theta1);
      sinTheta1 = sin(theta1);
      glBegin(GL_QUAD_STRIP);
      phi = 0.0;
      for (j = nsides; j >= 0; j--) {
         GLfloat cosPhi, sinPhi, dist;
         phi += sideDelta;
         cosPhi = cos(phi);
         sinPhi = sin(phi);
         dist = radius2 + radius1 * cosPhi;
         glNormal3f(cosTheta1 * cosPhi, -sinTheta1 * cosPhi, sinPhi);
         glVertex3f(cosTheta1 * dist, -sinTheta1 * dist, radius1 * sinPhi);
         glNormal3f(cosTheta * cosPhi, -sinTheta * cosPhi, sinPhi);
         glVertex3f(cosTheta * dist, -sinTheta * dist,  radius1 * sinPhi);
         }
      glEnd();
      theta = theta1;
      cosTheta = cosTheta1;
      sinTheta = sinTheta1;
     }
   glPopMatrix();
   glFlush();
}

/* draw a cube */
void cube(double length, double x, double y, double z, int gen)
{
   static GLfloat n[6][3] = {
      {-1.0, 0.0, 0.0}, {0.0, 1.0, 0.0},{1.0, 0.0, 0.0},
      {0.0, -1.0, 0.0}, {0.0, 0.0, 1.0},{0.0, 0.0, -1.0}
      };

   static GLint faces[6][4] = {
      {0, 1, 2, 3}, {3, 2, 6, 7}, {7, 6, 5, 4},
      {4, 5, 1, 0}, {5, 6, 2, 1}, {7, 4, 0, 3}
      };

   GLfloat v[8][3], len_div_2 = length / 2;
   GLint i;

   glGetIntegerv(GL_MODELVIEW_STACK_DEPTH, &i);
   glPushMatrix();
   glGetIntegerv(GL_MODELVIEW_STACK_DEPTH, &i);

   glTranslatef(x, y, z);

   v[0][0] = v[1][0] = v[2][0] = v[3][0] = -len_div_2;
   v[4][0] = v[5][0] = v[6][0] = v[7][0] = len_div_2;
   v[0][1] = v[1][1] = v[4][1] = v[5][1] = -len_div_2;
   v[2][1] = v[3][1] = v[6][1] = v[7][1] = len_div_2;
   v[0][2] = v[3][2] = v[4][2] = v[7][2] = -len_div_2;
   v[1][2] = v[2][2] = v[5][2] = v[6][2] = len_div_2;

   /* set default coordinates if needed */

   if (gen == 1) {
      glDisable(GL_TEXTURE_GEN_S);
      glDisable(GL_TEXTURE_GEN_T);
      for (i = 5; i >= 0; i--) {
	 glBegin(GL_QUADS);
	 glNormal3fv(&n[i][0]);
	 glTexCoord2f(0.0, 0.0);
	 glVertex3fv(&v[faces[i][0]][0]);
	 glTexCoord2f(0.0, 1.0);
	 glVertex3fv(&v[faces[i][1]][0]);
	 glTexCoord2f(1.0, 1.0);
	 glVertex3fv(&v[faces[i][2]][0]);
	 glTexCoord2f(1.0, 0.0);
	 glVertex3fv(&v[faces[i][3]][0]);
	 glEnd();
	 }
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
      }
   else {
      for (i = 5; i >= 0; i--) {
	 glBegin(GL_QUADS);
	 glNormal3fv(&n[i][0]);
	 glVertex3fv(&v[faces[i][0]][0]);
	 glVertex3fv(&v[faces[i][1]][0]);
	 glVertex3fv(&v[faces[i][2]][0]);
	 glVertex3fv(&v[faces[i][3]][0]);
	 glEnd();
	 }
      }
   glPopMatrix();
}

/*
 * draw a sphere. This routine makes use of the glu library
 */
void sphere(double radius, double x, double y, double z, int gen)
{
   GLUquadricObj *qobj;
   glPushMatrix();
   glTranslatef(x, y, z);
   qobj = gluNewQuadric();
   gluQuadricDrawStyle(qobj, GLU_FILL);
   gluQuadricNormals(qobj,  GLU_SMOOTH);

   /* use the glu texture coordinates if texcoord ="auto" */
   if (gen == 1){
      glDisable(GL_TEXTURE_GEN_S);
      glDisable(GL_TEXTURE_GEN_T);
      gluQuadricTexture(qobj, GL_TRUE);
      }
   gluSphere(qobj, radius, 15, 10);
   if (gen == 1){
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
      }
   glPopMatrix();
}


/*
 * draw a cylinder. makes use of the glu library.
 */
void cylinder(double radius1, double radius2, double height,
              double x,  double y, double z, int gen)
{
   GLUquadricObj *qobj;

   /*
    * translate to the specified x,y, and z
    */
   glPushMatrix();
   glTranslatef(x, y, z);
   /*
    * rotate so cylinder points "up" by default
    */
   glRotated(270.0, 1.0, 0.0, 0.0);
   qobj = gluNewQuadric();

   gluQuadricDrawStyle(qobj, GLU_FILL);
   gluQuadricNormals(qobj,  GLU_SMOOTH);

   /* if needed generate texture coordinates */
   if (gen == 1){
      glDisable(GL_TEXTURE_GEN_S);
      glDisable(GL_TEXTURE_GEN_T);
      gluQuadricTexture(qobj, GL_TRUE);
     }
   /* draw the cylinder */
   gluCylinder(qobj, radius1, radius2, height, 15, 5);
   if (gen == 1){
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
     }
   glPopMatrix();
}

/*
 * draw a disk. angle2 < 360 degrees specifies a partial disk
 */
void disk(double radius1, double radius2, double angle1, double angle2,
          double x, double y, double z, int gen)
{
   GLUquadricObj *qobj;

   /* translate to the given x, y, z */
   glPushMatrix();
   glTranslatef(x, y, z);

   /* create the glu quadric */
   qobj = gluNewQuadric();
   gluQuadricDrawStyle(qobj, GLU_FILL);
   gluQuadricNormals(qobj,  GLU_SMOOTH);

   /* generate texture coordinate if needed. */
   if (gen == 1){
      glDisable(GL_TEXTURE_GEN_S);
      glDisable(GL_TEXTURE_GEN_T);
      gluQuadricTexture(qobj, GL_TRUE);
      }

   /* draw a disk */
   if (angle2 < 360.0)
      gluPartialDisk(qobj, radius1, radius2, 15, 5, angle1, angle2);
   else
      gluDisk(qobj, radius1, radius2, 15, 5);
   if (gen == 1){
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
      }
   glPopMatrix();
}

/* other helper functions */
  	
/*
 * pop a matrix from either the projection or the modelview matrix stack
 */
int popmatrix()
{
   int params1, params2;

   /* determine what is the current matrix stack */
   glGetIntegerv(GL_MATRIX_MODE, &params1);
   if (params1 == GL_PROJECTION) {
      /*
       * check the stack depth. return failed if the
       * matrix stack is one
       */
      glGetIntegerv(GL_PROJECTION_STACK_DEPTH, &params2);
      if (params2 > 1)
         glPopMatrix();
      else
	 return Failed;
      }

   else {
      /*
       * We are using the Modelview stack (what about texture stack?).
       * check to see if there is more than one
       * matrix on the stack. if not return Failed
       */
      glGetIntegerv(GL_MODELVIEW_STACK_DEPTH, &params2);
	 if (params2 > 1)
	    glPopMatrix();
    	 else {
	    return Failed;
            }
      }
   return Succeeded;
}


/* push a matrix onto the current stack -- that is
   either the modelview of projection matrix stack */
int pushmatrix()
{
   int params1, params2;

   /* determine the current matrix stack */
   glGetIntegerv(GL_MATRIX_MODE, &params1);
   if (params1 == GL_PROJECTION) {
      /*
       * check the stack depth. If there is already 2
       * matrices on the stack return Failed
       */
      glGetIntegerv(GL_PROJECTION_STACK_DEPTH, &params2);
      if (params2 < 2) {
         glPushMatrix();
         }
      else
	 return Failed;
      }

   else {
      /* must be the Modelview matrix stack
       * if the stack depth is greater than 32, fail
       */
      glGetIntegerv(GL_MODELVIEW_STACK_DEPTH, &params2);
      if (params2 < 32)
	 glPushMatrix();
      else
	 return Failed;
      }
   return Succeeded;
}

/*
 * push matrix and return a descriptor for a corresponding record
 */
int pushmatrix_rd(wbp w, dptr f)
{
   static dptr constr;
   int nfields;
   tended struct b_record *rp;

   if (!constr && !(constr = rec_structor3d("gl_pushmatrix")))
      syserr("failed to create opengl record constructor");
   nfields = (int) ((struct b_proc *)BlkLoc(*constr))->nfields;

   makecurrent(w);

   /* push a copy of the top matrix, if possible */
   if (pushmatrix() == 0)
      return 151;

   /*
    * create a record of the graphical object
    */
   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return -1);
   f->dword = D_Record;
   f->vword.bptr = (union block *)rp;
   MakeStr("PushMatrix", 10 ,&(rp->fields[0]));
   c_put(&(w->window->funclist), f);
   return 0;
}


/*
 * Functions that implement redrawing of windows.
 */

/*
 * redraws a opengl window by traversing the specifed list
 */
int redraw3D(wbp w)
{
   wcp wc = w->context;
   GLfloat deflt_ambient[4] = {0.2, 0.2, 0.2, 1.0};
   GLfloat deflt_diffuse[4] = {0.8, 0.8, 0.8, 1.0};
   GLfloat deflt_emission[4] = {0.0, 0.0, 0.0, 1.0};
   GLfloat deflt_specular[4] = {0.0, 0.0, 0.0, 1.0};

   makecurrent(w);

   /*
    * reset the defaults for those objects that used them
    */
   glClear(GL_COLOR_BUFFER_BIT |GL_DEPTH_BUFFER_BIT);
   glMatrixMode(GL_MODELVIEW);
   glPushMatrix();
   glLoadIdentity();
   gluLookAt(wc->eyeposx, wc->eyeposy, wc->eyeposz, wc->eyedirx, wc->eyediry,
	     wc->eyedirz, wc->eyeupx, wc->eyeupy, wc->eyeupz);

   glMaterialfv(GL_FRONT, GL_AMBIENT, deflt_ambient);
   glMaterialfv(GL_FRONT, GL_DIFFUSE, deflt_diffuse);
   glMaterialfv(GL_FRONT, GL_SPECULAR, deflt_specular);
   glMaterialfv(GL_FRONT, GL_EMISSION, deflt_emission);
   glMaterialf(GL_FRONT, GL_SHININESS, 50.0);

   setlinewidth(w, 1);
   glLineWidth(1.0);
   wc->dim = 3;

   if (!wc->autogen) {
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
      wc->autogen = 1;
      }
   if (wc->texmode) {
      glDisable(GL_TEXTURE_2D);
      wc->texmode = 0;
      }

   if (w->window->funclist.vword.bptr != NULL) {
      if (traversefunctionlist(w) == Failed)
         return Failed;
      }

   glPopMatrix();
   glXSwapBuffers(w->window->display->display, w->window->win);
   return Succeeded;
}

/*
 * traverse a list and produce the element given by position
 */
int c_traverse(struct b_list *hp, struct descrip * res, int position)
{
   register word i;
   register struct b_lelem *bp;
   int j, used;

   /*
    * Fail if the list is not big enough.
    */
   if (hp->size < position)
      return 0;

   /*
    * Point bp at the first list block.  If the first block has no
    *  elements in use, point bp at the next list block.
    */
   bp = (struct b_lelem *) hp->listhead;
   if (bp->nused <= 0) {
      bp = (struct b_lelem *) bp->listnext;
      hp->listhead = (union block *) bp;
      bp->listprev = (union block *) hp;
      }

   /*
    * Parse through the list blocks to find the specified element.
    */
   i = bp->first;
   used = bp->nused;
   for (j=0; j < position; j++){
      if (used <= 1){
	 bp = (struct b_lelem *) bp->listnext;
         used = bp->nused;
         i = bp->first;
         }
      else {
	 if (i++ >= bp->nslots) i = 0;
	 used--;
         }
      }
   *res = bp->lslots[i];
   return 1;
}

/*
 * traverse the given list and write its contents from subscript m through n,
 * which must be reals, to a C array of doubles.  m and n are 1-based
 * subscripts. Replaces a loop of calls to c_traverse().
 */
int c_realarray(struct b_list *hp, int m, int n, double *a)
{
   register word i;
   tended struct b_lelem *bp;
   tended struct descrip d;
   int j, used;

   /*
    * Fail if the list is not big enough (caller should check this first)
    */
   if (hp->size < n)
      return 0;

   /*
    * Point bp at the first list block.  If the first block has no
    *  elements in use, point bp at the next list block.
    */
   bp = (struct b_lelem *) hp->listhead;
   if (bp->nused <= 0) {
      bp = (struct b_lelem *) bp->listnext;
      hp->listhead = (union block *) bp;
      bp->listprev = (union block *) hp;
      }

   /*
    * Parse through the list blocks to find the specified element.
    */
   i = bp->first;
   used = bp->nused;
   for (j=0; j < n; j++){
      if (j >= (m-1)) {
	 d = bp->lslots[i];
         if (!cnv:real(d, d)) return 0;
	 bp->lslots[i] = d;
	 a[j-(m-1)] = BlkLoc(d)->realblk.realval;
	 }
      if (used <= 1){
	 bp = (struct b_lelem *) bp->listnext;
         used = bp->nused;
         i = bp->first;
         }
      else {
	 if (i++ >= bp->nslots) i = 0;
	 used--;
         }
      }
   return 1;
}

#define	REDRAW_CUBE 16
#define	REDRAW_CYLINDER 32
#define	REDRAW_DISK 48
#define	REDRAW_LINE 64
#define	REDRAW_POINT 80
#define	REDRAW_POLYGON 96
#define	REDRAW_SEGMENT 112
#define	REDRAW_SPHERE 128
#define	REDRAW_TORUS 144
#define	REDRAW_FG 160
#define	REDRAW_FILLPOLYGON 176
#define	REDRAW_IDENTITY 192
#define	REDRAW_MATRIXMODE 208
#define	REDRAW_POPMATRIX 224
#define	REDRAW_PUSHMATRIX 240
#define	REDRAW_ROTATE 256
#define	REDRAW_SCALE 272
#define	REDRAW_TEXTURE 288
#define	REDRAW_TEXCOORD 304
#define	REDRAW_TRANSLATE 320
#define	REDRAW_DIM 336
#define	REDRAW_LINEWIDTH 352
#define	REDRAW_TEXMODE 368

/*
 * Map 3D redrawing names to which switch case to use, and how many
 * real number arguments to convert.
 */
stringint redraw3Dnames[] = {
   { 0,			23 },		/* number of entries */
   { "DrawCube",	REDRAW_CUBE | 4 },
   { "DrawCylinder",	REDRAW_CYLINDER | 6},
   { "DrawDisk",	REDRAW_DISK | 7 },
   { "DrawLine",	REDRAW_LINE },
   { "DrawPoint",	REDRAW_POINT },
   { "DrawPolygon",	REDRAW_POLYGON },
   { "DrawSegment",	REDRAW_SEGMENT },
   { "DrawSphere",	REDRAW_SPHERE | 4 },
   { "DrawTorus",	REDRAW_TORUS | 5},
   { "Fg",		REDRAW_FG},
   { "FillPolygon",	REDRAW_FILLPOLYGON },
   { "Identity",	REDRAW_IDENTITY },
   { "MatrixMode",	REDRAW_MATRIXMODE },
   { "PopMatrix",	REDRAW_POPMATRIX },
   { "PushMatrix",	REDRAW_PUSHMATRIX },
   { "Rotate",		REDRAW_ROTATE | 4 },
   { "Scale",		REDRAW_SCALE | 3 },
   { "Texcoord",	REDRAW_TEXCOORD },
   { "Texture",		REDRAW_TEXTURE },
   { "Translate",	REDRAW_TRANSLATE | 3 },
   { "dim",		REDRAW_DIM },
   { "linewidth",	REDRAW_LINEWIDTH },
   { "texmode",		REDRAW_TEXMODE },
   };

/*
 * Traverse the list of functions and redraw the scene.
 */
int traversefunctionlist(wbp w)
{
   wcp wc = w->context;
   wsp ws = w->window;
   double x, y, z, r1, r2, h, a1, a2, *v, v2[256];
   C_integer num, dim;
   int i, j, tmp, vsize=256;
   tended struct descrip flist, fname, var1, var2;
   tended struct b_list *funclist;
   tended char *temp;
   tended struct b_record *rp;
   int elements = ws->funclist.vword.bptr->list.size;

   /*
    * The ith element of the list is a list with information
    * about the function call made on the window.
    */
   v = v2;
   for (i=0; i< elements; i++) {
      if (v != v2) free(v);
      v = v2;
      c_traverse((struct b_list *)ws->funclist.vword.bptr, &flist, i);
      if (is:record(flist)) {
	 fname = BlkLoc(flist)->record.fields[0];
	 rp = (struct b_record *)BlkLoc(flist);
	 tmp = si_s2i(redraw3Dnames, StrLoc(fname));
	 if (tmp == -1) {
	    return Failed; /* probably should runerr on this */
	    }
	 for (j=0; j < (tmp&7); j++) {
	    var1 = rp->fields[j+1];
	    if (!cnv:C_double(var1, v[j])) goto free_v_and_fail;
	    }

	 switch(tmp & ~0xf) {
	 case REDRAW_TORUS:
	    torus(v[3], v[4], v[0], v[1], v[2], (wc->texmode?wc->autogen:0));
	    break;
	 case REDRAW_CUBE:
	    cube(v[3], v[0], v[1], v[2], (wc->texmode?wc->autogen:0));
	    break;
	 case REDRAW_SPHERE:
	    sphere(v[3], v[0], v[1], v[2], (wc->texmode?wc->autogen:0));
	    break;
	 case REDRAW_CYLINDER:
	    cylinder(v[4], v[5], v[3], v[0], v[1], v[2],
		     (wc->texmode?wc->autogen:0));
	    break;
	 case REDRAW_DISK:
	    disk(v[3], v[4], v[5], v[6], v[0], v[1], v[2],
		 (wc->texmode?wc->autogen:0));
	    break;
	 case REDRAW_ROTATE:
	    glRotated(v[3], v[0], v[1], v[2]);
	    break;
	 case REDRAW_TRANSLATE:
	    glTranslated(v[0], v[1], v[2]);
	    break;
	 case REDRAW_SCALE:
	    glScaled(v[0], v[1], v[2]);
	    break;
	 case REDRAW_POPMATRIX:
	    if (popmatrix() != Succeeded) goto free_v_and_fail;
	    break;
	 case REDRAW_PUSHMATRIX:
	    if (pushmatrix() != Succeeded) goto free_v_and_fail;
	    break;
	 case REDRAW_IDENTITY:
	    glLoadIdentity();
	    break;
	 case REDRAW_MATRIXMODE:
	    if (!cnv:C_string(rp->fields[1], temp)) goto free_v_and_fail;
	    if (!strcmp("modelview", temp)) glMatrixMode(GL_MODELVIEW);
	    else if (!strcmp("projection", temp)) glMatrixMode(GL_PROJECTION);
	    break;
	 case REDRAW_TEXTURE:
	    /*
	     * lookup the name of the texture and bind it
             * the objects using glBindTexture()
	     */
	    if (!cnv:C_integer(rp->fields[1], num)) goto free_v_and_fail;
	    glBindTexture(GL_TEXTURE_2D, wc->texName[num]);
	    if (wc->texmode)
	       glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, wc->texmode);
	    break;
	 default:
            goto free_v_and_fail;
	    }
	 continue;
	 }
      else if (is:list(flist)) {
	 funclist = (struct b_list*)flist.vword.bptr;
   	 c_traverse (funclist, &fname, 0);
	 tmp = si_s2i(redraw3Dnames, StrLoc(fname));
	 if (funclist->size-1 > vsize) {
	    if (v == v2)
	       v = calloc(funclist->size, sizeof (double));
	    else {
	       v = realloc(v, funclist->size * sizeof (double));
	       }
	    vsize = funclist->size-1;
	    if (v == NULL) return Error;
	    }
	 }
      else {
	 return Failed;
	 }

      switch(tmp & ~0xf) {
      case REDRAW_TORUS:
	 torus(v[3], v[4], v[0], v[1], v[2], (wc->texmode?wc->autogen:0));
	 break;
      case REDRAW_CUBE:
	 cube(v[3], v[0], v[1], v[2], (wc->texmode?wc->autogen:0));
	 break;
      case REDRAW_SPHERE:
	 sphere(v[3], v[0], v[1], v[2], (wc->texmode?wc->autogen:0));
	 break;
      case REDRAW_CYLINDER:
	 cylinder(v[4], v[5], v[3], v[0], v[1], v[2],
		  (wc->texmode?wc->autogen:0));
	 break;
      case REDRAW_DISK:
	 disk(v[3], v[4], v[5], v[6], v[0], v[1], v[2],
	      (wc->texmode?wc->autogen:0));
	 break;
      case REDRAW_ROTATE:
	 glRotated(v[3], v[0], v[1], v[2]);
	 break;
      case REDRAW_TRANSLATE:
	 glTranslated(v[0], v[1], v[2]);
	 break;
      case REDRAW_SCALE:
	 glScaled(v[0], v[1], v[2]);
	 break;
      case REDRAW_POPMATRIX:
	 if (popmatrix() != Succeeded) goto free_v_and_fail;
	 break;
      case REDRAW_PUSHMATRIX:
	 if (pushmatrix() != Succeeded) goto free_v_and_fail;
	 break;
      case REDRAW_IDENTITY:
	 glLoadIdentity();
	 break;
      case REDRAW_MATRIXMODE:
	 if (!cnv:C_string(rp->fields[1], temp)) goto free_v_and_fail;
	 if (!strcmp("modelview", temp)) glMatrixMode(GL_MODELVIEW);
	 else if (!strcmp("projection", temp)) glMatrixMode(GL_PROJECTION);
	 break;
      case REDRAW_TEXTURE:
	 /*
	  * lookup the name of the texture and bind it
	  * the objects using glBindTexture()
	  */
	 if (!cnv:C_integer(rp->fields[1], num)) goto free_v_and_fail;
	 glBindTexture(GL_TEXTURE_2D, wc->texName[num]);
	 if (wc->texmode)
	    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, wc->texmode);
	 break;
      case REDRAW_FG:
	 /* Fg() or WAttrib("fg=...") */
	 if(!determinematerial(funclist)) {
free_v_and_fail:
	    if (v != v2) free(v);
	    return Failed;
	    }
	 break;
      case REDRAW_DIM:
	 /* WAttrib("dim=...") */
	 c_traverse(funclist, &var1, 1);
    	 if ((!cnv:C_integer(var1, dim))||(dim<1)||(dim>3))
	    goto free_v_and_fail;
         wc->dim = dim;
	 break;
      case REDRAW_LINEWIDTH:
	 /* WAttrib("linewidth=...") */
         c_traverse(funclist, &var1, 1);
         if (!cnv:C_integer(var1, num)) goto free_v_and_fail;
	 setlinewidth(w, num);
         glLineWidth(num);
	 break;
      case REDRAW_TEXMODE:
	 /* WAttrib("texmode=...") */
         c_traverse(funclist, &var1, 1);
         if (!cnv:C_integer(var1, num)) goto free_v_and_fail;

         /* texturing is on */
         if (num) {
            if (wc->texmode == 0)
	       glEnable(GL_TEXTURE_2D);

           wc->texmode = num;
           }
         /* texturing is off */
         else {
            if (wc->texmode != 0)
               glDisable(GL_TEXTURE_2D);
            wc->texmode = 0;
	    }
	 break;
      case REDRAW_TEXCOORD:      /* Texcoord() or WAttrib("texcoord=...") */
         /*
	  * first element tells us if opengl generates texture coordinates
	  */
         c_traverse(funclist, &var1, 1);
         if (!cnv:C_integer(var1, num)) goto free_v_and_fail;
         if (num) {
            glEnable(GL_TEXTURE_GEN_S);
            glEnable(GL_TEXTURE_GEN_T);
            wc->autogen = 1;
            }

        /* there is a list of texture coordinates to use */
         else {
            glDisable(GL_TEXTURE_GEN_S);
            glDisable(GL_TEXTURE_GEN_T);
            wc->autogen = 0;

	   if (wc->ntexcoordsalced < funclist->size-2) {
	      printf("need to grow ntexcooords alced %d need %d\n",
		     wc->ntexcoordsalced, funclist->size-2);
	      goto free_v_and_fail;
	      }

           /* traverse the list and set the texture coordinates */
           if(!c_realarray(funclist, 3, funclist->size, wc->texcoords)){
	      goto free_v_and_fail;
	      }
           wc->numtexcoords = funclist->size-2;
           }
	 break;
      case REDRAW_POLYGON:      /* DrawPolygon() */
         /* element in position 1 is the dim attribute */
         for (j = 0; j < (funclist->size)-1; j++) {
            c_traverse(funclist, &var2, j+1);
            if(!cnv:C_double(var2, v[j])) goto free_v_and_fail;
	    }

	 /* call drawpoly with GL_LINE_LOOP to get a polygon */
	 drawpoly(w, v, (funclist->size)-1, GL_LINE_LOOP, wc->dim);
	 break;
      case REDRAW_FILLPOLYGON:      /* FillPolygon() */
	 for (j = 0; j < (funclist->size)-1; j++) {
            c_traverse(funclist, &var2, j+1);
            if (!cnv:C_double(var2, v[j])) goto free_v_and_fail;
            }
	  /* drawpoly with GL_POLYGON will give filled polygons */
         drawpoly(w, v, (funclist->size)-1, GL_POLYGON, wc->dim);
	 break;
      case REDRAW_SEGMENT:      /* DrawSegment() */
	 for (j = 0; j < (funclist->size)-1; j++) {
	    c_traverse(funclist, &var2, j+1);
	    if (!cnv:C_double(var2, v[j])) goto free_v_and_fail;
	    }
	 drawpoly(w, v, (funclist->size)-1, GL_LINES, wc->dim);
	 break;
      case REDRAW_LINE:       /* DrawLine() */
	 for (j = 0; j < (funclist->size)-1; j++) {
	    c_traverse(funclist, &var2, j+1);
	    if (!cnv:C_double(var2, v[j])) goto free_v_and_fail;
	    }
	 drawpoly(w, v, (funclist->size)-1, GL_LINE_STRIP, wc->dim);
	 break;
      case REDRAW_POINT:       /* DrawPoint() */
	 for (j = 0; j < (funclist->size)-1; j++) {
	    c_traverse(funclist, &var2, j+1);
	    if (!cnv:C_double(var2, v[j])) goto free_v_and_fail;
            }
	 drawpoly(w, v, (funclist->size)-1, GL_POINTS, wc->dim);
	 break;
      default:
	 fprintf(stderr,"invalid displaylist entry '%s'\n", StrLoc(fname));
	 goto free_v_and_fail;
	 }
      }

   if (v!=v2) free(v);
   return Succeeded;
}

/*
 * traverse the given list and set material properties
 */
int determinematerial(struct b_list *list)
{
   struct descrip d;
   C_integer r, g, b, a;
   tended char *temp;
   GLfloat color[4];

   /*
    * Convert the elements of the list to the appropriate type. The first
    * element is a string which give the material property. the last three
    * elements should be the r, g, b value of that property
    */

   c_traverse( list, &d, 1);
   if (!cnv:C_string(d, temp))
	 return Failed;
   c_traverse( list, &d, 2);
   if (!cnv:C_integer(d, r))
	 return Failed;
   c_traverse( list, &d, 3);
   if (!cnv:C_integer(d, g))
	return Failed;
   c_traverse( list, &d, 4);
   if (!cnv:C_integer(d, b))
	 return Failed;
   c_traverse( list, &d, 5);
   if (!cnv:C_integer(d, a))
	 return Failed;

   /*
    * must convert from an integer between 0 and 65535
    * to a float between 0.0 and 0.0
    */
   color[0] = r/(GLfloat)65535;
   color[1] = g/(GLfloat)65535;
   color[2] = b/(GLfloat)65535;
   color[3] = a/(GLfloat)65535;  /* alpha value */

  /* set the material property */
   if (!strcmp(temp, "ambient"))
	glMaterialfv(GL_FRONT, GL_AMBIENT, color);
   else if (!strcmp(temp, "diffuse"))
	glMaterialfv(GL_FRONT, GL_DIFFUSE, color);
   else if (!strcmp(temp, "specular"))
	glMaterialfv(GL_FRONT, GL_SPECULAR, color);
   else if (!strcmp(temp, "emission"))
	glMaterialfv(GL_FRONT, GL_EMISSION, color);
   else if(!strcmp(temp, "shininess"))
      glMateriali(GL_FRONT, GL_SHININESS, r);

   /*
    * if it is not a material property, change the
    * current foreground color to r, g, b
    */
   if (!strcmp(temp, "none")) {
      glColor4f(color[0], color[1], color[2], color[3]);
      }

   return Succeeded;
}

/* routines to return an attribute vale */

/* returns the current value of the specified light */
int getlight(int light, char* buf)
{
   GLfloat pos[4];
   GLfloat amb[4];
   GLfloat diff[4];
   GLfloat spec[4];

   glGetLightfv(GL_LIGHT0 + light, GL_POSITION, pos);
   glGetLightfv(GL_LIGHT0 + light, GL_AMBIENT, amb);
   glGetLightfv(GL_LIGHT0 + light, GL_DIFFUSE, diff);
   glGetLightfv(GL_LIGHT0 + light, GL_SPECULAR, spec);

   sprintf(buf, "position %.2f,%.2f,%.2f; ambient %.2f,%.2f,%.2f; diffuse %.2f,%.2f,%.2f; specular %.2f,%.2f,%.2f",  pos[0], pos[1], pos[2], amb[0], amb[1], amb[2],  diff[0], diff[1], diff[2], spec[0], spec[1], spec[2]);
   return Succeeded;
}

/* returns the current material properties */
int getmaterials(char* buf)
{
   GLfloat amb[4];
   GLfloat diff[4];
   GLfloat spec[4];
   GLfloat emis[4];
   GLfloat shine;

   /* query opengl for current values */
   glGetMaterialfv(GL_FRONT, GL_EMISSION, emis);
   glGetMaterialfv(GL_FRONT, GL_AMBIENT, amb);
   glGetMaterialfv(GL_FRONT, GL_DIFFUSE, diff);
   glGetMaterialfv(GL_FRONT, GL_SPECULAR, spec);
   glGetMaterialfv(GL_FRONT, GL_SHININESS, &shine);

   sprintf(buf, "ambient %.2f,%.2f,%.2f; diffuse %.2f,%.2f,%.2f; specular %.2f,%.2f,%.2f; emission %.2f,%.2f,%.2f; shininess %.2f", amb[0], amb[1], amb[2],  diff[0], diff[1], diff[2], spec[0], spec[1], spec[2], emis[0], emis[1], emis[2], shine);
   return Succeeded;
}

int gettexture(wbp w, dptr dp)
{
   wcp wc= w->context;
   wtp wt = wc->textures;
   while (wt) {
      if (wt->texindex == wc->curtexture) {
	 *dp = wt->d;
	 return Succeeded;
	 }
      wt = wt->next;
      }
   return Failed;
}

void getatexcoord(double d, char *b)
{
   if ((double)(int)d == d) sprintf(b,"%d",(int)d);
   else sprintf(b,"%.3f",d);
}

/* get the user specified texture coordinates */
int gettexcoords(wbp w, char *buf)
{
   char *s = buf;
   int i;
   wcp wc = w->context;
   getatexcoord(wc->texcoords[0], s);
   s += strlen(s);
   for (i = 1; i < wc->numtexcoords; i++) {
      *s++ = ',';
      getatexcoord(wc->texcoords[i], s);
      s += strlen(s);
     }
   return Succeeded;
}

/* routines to set attribute values */

/* set the linewidth */
int setlinewidth3D(wbp w, LONG linewid)
{
   struct descrip f, funcname, width;
   struct b_list *func;

   if (linewid < 0) return Error;
   makecurrent(w);
   setlinewidth(w, linewid);
   glLineWidth(linewid);

   /* create a list */
   if ((func = alclist(0, MinListSlots)) == NULL)
      return Failed;
   f.dword = D_List;
   f.vword.bptr = (union block *) func;
   MakeStr("linewidth", 9, &funcname);
   c_put(&f, &funcname);
   MakeInt(linewid, &width);
   c_put(&f, &width);
   c_put(&(w->window->funclist), &f);

   return Succeeded;
}

/* given a string of semi-colon seperated material
 * properties (ambient, diffuse, specular, emission,
 * and shininess), parse the string and set material
 * properties
 */
int setmaterials(wbp w, char* s)
{
#ifdef XWindows
   wdp wd = w->window->display;
#endif					/* XWindows */
   int k, j, i = 0;
   long rd, gr, bl, al;
   GLfloat shine;
   GLfloat color[4];
   char sbuf1[MaxCvtLen];
   char sbuf2[MaxCvtLen];
   struct descrip f, funcname, material, r, b, g, a;
   struct b_list *func;

   makecurrent(w);
   while(s[i]) {
      j = 0;
      k = 0;

      /* create a list element for each material property */
      if ((func = alclist(0, MinListSlots)) == NULL)
         return Failed;
      f.dword = D_List;
      f.vword.bptr = (union block *) func;
      MakeStr("Fg", 2, &funcname);
      c_put(&f, &funcname);

     /*
      * parse the string to determine the material property and its value
      */
      while(isspace(s[i])) i++;
      while(s[i] && isalpha(s[i])) {
         sbuf1[k] = s[i];
         i++; k++;
	   }
      sbuf1[k] = '\0';

      /* ambient */
      if (!strcmp(sbuf1, "ambient")) {
         while(isspace(s[i])) i++;
         if(s[i] == '\0') return Failed;
         while(s[i] != '\0' && s[i] != ';') {
            sbuf2[j] = s[i];
            i++; j++;
	      }
         sbuf2[j] = '\0';
         /* determine the icon color */
         if(parsecolor(w,sbuf2, &rd, &gr, &bl, &al)== Failed)
            return Failed;
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = al/(GLfloat)65535; /* alpha value */

         /* set the property */
         glMaterialfv(GL_FRONT, GL_AMBIENT, color);
         MakeStr("ambient", 7, &material);
         c_put(&f, &material);
	   }

      /* diffuse */
      else if(!strcmp(sbuf1, "diffuse")) {
	 while(isspace(s[i])) i++;
	 if(s[i] == '\0') return Failed;
	 while(s[i] != '\0' && s[i] != ';') {
	    sbuf2[j] = s[i];
	    i++; j++;
	    }
	 sbuf2[j] = '\0';

         /* determine the appropriate icon color */
	 if(parsecolor(w,sbuf2, &rd, &gr, &bl, &al)==Failed)
            return Failed;

         /* convert values to floats between 0.0 and 1.0 */
	 color[0] = rd/(GLfloat)65535;
	 color[1] = gr/(GLfloat)65535;
	 color[2] = bl/(GLfloat)65535;
	 color[3] = al/(GLfloat)65535;

         /* set the property */
	 glMaterialfv(GL_FRONT, GL_DIFFUSE, color);
	 MakeStr("diffuse", 7, &material);
	 c_put(&f, &material);
	 }

      /* specular */
      else if (!strcmp(sbuf1, "specular")) {
         while(isspace(s[i])) i++;
         if(s[i] == '\0') return Failed;
         while(s[i] != '\0' && s[i] != ';') {
	    sbuf2[j] = s[i];
	    i++; j++;
	    }
	 sbuf2[j] = '\0';

         /*
	  * determine the icon color and convert to a float between 0.0 and 1.0
	  */
         if(parsecolor(w, sbuf2, &rd, &gr,&bl,&al)==Failed)
            return Failed;
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = al/(GLfloat)65535;

         /* set the property */
         glMaterialfv(GL_FRONT, GL_SPECULAR, color);
         MakeStr("specular", 8, &material);	
         c_put(&f, &material);
	 }

      /* shininess */
      else if(!strcmp(sbuf1, "shininess")) {
	 while(isspace(s[i])) i++;
	 if(s[i] == '\0') return Failed;
	 while(s[i] != '\0' && s[i] != ';') {
	    sbuf2[j] = s[i];
	    i++; j++;
	    }
	 sbuf2[j] = '\0';

	 /* set the shininess */
	 shine = atof(sbuf2);
	 glMaterialf(GL_FRONT, GL_SHININESS, shine);
         MakeStr("shininess", 9, &material);		
	 c_put(&f, &material);
	 rd = shine;
	 gr = 0;
	 bl = 0;
	 }
      /* emission */
      else if(!strcmp(sbuf1, "emission")) {
	 while(isspace(s[i])) i++;
	 if(s[i] == '\0') return Failed;
	 while(s[i] != '\0' && s[i] != ';') {
	    sbuf2[j] = s[i];
	    i++; j++;
	    }
	 sbuf2[j] = '\0';

	 /*
	  * determine r, g, b and convert them to floats between 0.0 and 1.0
	  */
	 if(parsecolor(w, sbuf2, &rd, &gr,&bl,&al)==Failed)
	    return Failed;
	 color[0] = rd/(GLfloat)65535;
	 color[1] = gr/(GLfloat)65535;
	 color[2] = bl/(GLfloat)65535;
	 color[3] = al/(GLfloat)65535;

	 /* set the emission color */
	 glMaterialfv(GL_FRONT, GL_EMISSION, color);
         MakeStr("emission", 8, &material);
	 c_put(&f, &material);
	 }

      /* otherwise set the current foreground color; treat as diffuse */
      else {
	 if(setfg(w, s) == Failed) return Failed;
         if(parsecolor(w, s, &rd, &gr, &bl, &al)==Failed)
            return Failed;
	 i = strlen(s);
	 color[0] = rd/(GLfloat)65535;
	 color[1] = gr/(GLfloat)65535;
	 color[2] = bl/(GLfloat)65535;
	 color[3] = al/(GLfloat)65535;
 	 glColor4f(color[0], color[1], color[2], color[3]);
	 glMaterialfv(GL_FRONT, GL_DIFFUSE, color);
         MakeStr("diffuse", 7, &material);
	 c_put(&f, &material);
         }

      /* put material property values on the list */
      MakeInt(rd, &r);
      c_put(&f, &r);
      MakeInt(gr, &g);
      c_put(&f, &g);
      MakeInt(bl, &b);
      c_put(&f, &b);
      MakeInt(al, &a);
      c_put(&f, &a);
      c_put(&(w->window->funclist), &f);

      /* fail if string is not in the correct format */
      if(s[i] != '\0' && s[i] != ';') return Failed;
      if (s[i])
         i++;
     }
   return Succeeded;
}


/*
 * set the lighting properties (position, ambient,
 * diffuse, specular, and "on" or "off")of a light
 */
int setlight(wbp w, char* s, int light)
{
   char* s2 = s;
   char s3[MaxCvtLen];
   GLboolean params;
   int i, j;
   GLfloat color[4];
   long rd, gr, bl, al;

   makecurrent(w);

   while(isspace(*s2)) s2++;

   /* turn on a light */
   if (!strncmp(s2, "on", 2)) {
      /* query opengl to see if it is already on */
      glGetBooleanv(light, &params);
      if (!params)
         glEnable(light);
      s2 = s2+2;
      if(*s2 != ',' && *s2 != '\0') return Failed;
      if(*s2 == ',') s2++;
      }
   /* turn off the light */
   if (!strncmp(s2, "off", 3)) {
      /* query opengl to make sure the light is not
          already off */
	 glGetBooleanv(light, &params);
	 if (params)
          glDisable(light);
       s2 = s2 + 3;
	 if(*s2 != ',' && *s2 != '\0') return Failed;
       if(*s2 == ',') s2++;
      }
   while(*s2 != '\0'){
      while(isspace(*s2)) s2++;

      /* set the ambient lighting values */
      if (!strncmp(s2, "ambient", 7)) {
         s2 = s2 + 7;
         i = 0;
         if(*s2 == '\0') return Failed;
         while(s2[i] != '\0' && s2[i] != ';') {
            s3[i] = s2[i];
            i++;
            }
         s3[i] = '\0';
         /*
	  * Determine the r, g, b values. Convert from an integer between
	  * 0 and 65535 to a float between 0.0 and 1.0
	  */
         if(parsecolor(w, s3, &rd, &gr, &bl, &al) ==Failed)
	      return Failed;

         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = al/(GLfloat)65535;

         /* set the ambient light value */
         glLightfv(light, GL_AMBIENT, color);
         s2 = s2 + i;
	 if(*s2 != ';' && *s2 != '\0') return Failed;
	 if(*s2 != '\0') s2++;
         }

      /* set the diffuse lighting values */
      if (!strncmp(s2, "diffuse", 7)) {
         s2 = s2 + 7;
         i = 0;
         if(*s2 == '\0') return Failed;
         while(s2[i] != '\0' && s2[i] != ';') {
            s3[i] = s2[i];
            i++;
            }
         s3[i] = '\0';
         /* convert the icon r, g, b values to floats
            between 0.0 and 1.0 */
         if(parsecolor(w, s3, &rd, &gr, &bl,&al) == Failed)
	      return Failed;
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = al/(GLfloat)65535;

         /* set the diffuse value of the light */
         glLightfv(light, GL_DIFFUSE, color);
         s2 = s2 + i;
         if(*s2 != ';' && *s2 != '\0') return Failed;
         if(*s2 != '\0') s2++;
         }
      /* set the specular lighting values */
      if (!strncmp(s2, "specular", 8)) {
         s2 = s2 + 8;
         i = 0;
         if(*s2 == '\0') return Failed;
         while(s2[i] != '\0' && s2[i] != ';') {
            s3[i] = s2[i];
            i++;
            }
         s3[i] = '\0';
         /* convert to appropriate values */
         if (parsecolor(w, s3, &rd, &gr, &bl, &al)==Failed)
            return Failed;
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = al/(GLfloat)65535;
         glLightfv(light, GL_SPECULAR, color);
         s2 = s2 + i;
         if(*s2 != ';' && *s2 != '\0') return Failed;
         if(*s2 != '\0') s2++;
         }
      /* set the positon of the light */
	if (!strncmp(s2, "position", 8)) {
         s2 = s2 + 8;
	   for (j = 0; j < 2; j++) {
           while(isspace(*s2)) s2++;
           i = 0;
           if(*s2 == '\0') return Failed;
           while(s2[i] != '\0' && s2[i] != ',') {
              s3[i] = s2[i];
              i++;
              }
           s3[i] = '\0';
           color[j] = atof(s3);
           s2 = s2 + i;
           if(*s2 != ',') return Failed;
           s2++;
           }
         while(isspace(*s2)) s2++;
         if(*s2 == '\0') return Failed;
         while(s2[i] != '\0' && s2[i] != ';') {
            s3[i] = s2[i];
            i++;
            }
         s3[i] = '\0';
         color[2] = atof(s3);
         color[3] = 0.0;
         s2 = s2  + i;
         if(*s2 != ';' && *s2 != '\0') return Failed;
         if(*s2 != '\0') s2++;
         glLightfv(light, GL_POSITION, color);
         }
      }

      /* the lighting on the scene has changed, we must redraw the window */
      redraw3D(w);
      return Succeeded;
}

/* set the dim attribute */
int setdim(wbp w, char* s)
{
   struct descrip f, funcname;
   struct b_list *func;
   struct descrip d;
   int dim;

   makecurrent(w);
   /* create a list */
   if ((func = alclist(0, MinListSlots)) == NULL)
         return Failed;
   f.dword = D_List;
   f.vword.bptr = (union block*) func;
   MakeStr("dim", 3, &funcname);
   c_put(&f, &funcname);

   dim = atoi(s);
   /* must be a value between 1 and 4 */
   if (dim < 1 || dim > 4)
      return Error;
   w->context->dim = dim;

   /* put the value of dim on the list of functions */
   MakeInt(dim, &d);
   c_put(&f, &d);
   c_put(&(w->window->funclist), &f);
   return Succeeded;
}

/* set the texture mode, either on or off */
int settexmode(wbp w, char* s)
{
   tended struct descrip f, funcname;
   struct b_list *func;
   struct descrip mode;
   wcp wc = w->context;
   int oldtexmode = wc->texmode;

   makecurrent(w);
    /* create a list */
   if ((func = alclist(0, MinListSlots)) == NULL)
      return Failed;
   f.dword = D_List;
   f.vword.bptr = (union block*) func;
   MakeStr("texmode", 7, &funcname);
   c_put(&f, &funcname);

   /*
    * turn textures on in replace, blend, or modulate (default mode = replace)
    */
   if (!strcmp("on", s) || !strcmp("replace", s)) {
      wc->texmode = GL_REPLACE;
      }
   else if (!strcmp("blend", s)) {
      wc->texmode = GL_BLEND;
      }
   else if (!strcmp("modulate", s)) {
      wc->texmode = GL_MODULATE;
      }
   /* turn texture off */
   else if (!strcmp("off", s)) {
      wc->texmode = 0;
     }
   /* not a valid texture mode so generate an error */
   else
      return Error;

   if ((oldtexmode == 0) && (wc->texmode != 0)) {
      glEnable(GL_TEXTURE_2D);
      }
   else if ((oldtexmode != 0) && (wc->texmode == 0)) {
      glDisable(GL_TEXTURE_2D);
      }

   MakeInt(wc->texmode, &mode);
   c_put(&f, &mode);
   c_put(&(w->window->funclist), &f);
   return Succeeded;
}

/* set texture coordinates */
int settexcoords(wbp w, char* s)
{
   double r;
   char* s2 = s;
   char s3[MaxCvtLen];
   int j, i =0;
   tended struct descrip f = nulldesc, val = nulldesc;
   struct descrip funcname, mode;
   tended struct b_list *func;
   makecurrent(w);

   /* create a list */
   if ((func = alclist(0, MinListSlots)) == NULL)
      return Failed;
   f.dword = D_List;
   f.vword.bptr = (union block*) func;
   MakeStr("Texcoord", 8, &funcname);
   c_put(&f, &funcname);

   while(isspace(*s2)) s2++;

   /*
    * check if we need to generate texture coordinates
    */
   if (!strcmp(s2, "auto")){
      w->context->autogen = 1;
      if (!glIsEnabled(GL_TEXTURE_GEN_S))
         glEnable(GL_TEXTURE_GEN_S);
      if (!glIsEnabled(GL_TEXTURE_GEN_T))
         glEnable(GL_TEXTURE_GEN_T);
      mode = onedesc;
      c_put(&f, &mode);
      c_put(&(w->window->funclist), &f);
      return Succeeded;
      }

   /*
    * otherwise a string of texture coordinates should be given
    */
   else if(isdigit(*s2)) {
      mode = zerodesc;
      c_put(&f, &mode);
      j = w->context->numtexcoords = 0;
      w->context->autogen = 0;

      /* must turn off automatic texture generation */
      if (glIsEnabled(GL_TEXTURE_GEN_S))
         glDisable(GL_TEXTURE_GEN_S);
      if (glIsEnabled(GL_TEXTURE_GEN_T))
         glDisable(GL_TEXTURE_GEN_T);
      /* parse string */
      while(*s2 != '\0') {
         while(*s2 != ',' && *s2 != '\0' ) {
            s3[i] = *s2;
            i++; s2++;
           }
         s3[i]='\0';
        /* create a list element for the coordinate */
	 if (j >= w->context->ntexcoordsalced) {
	    w->context->texcoords = realloc(w->context->texcoords,
					    (w->context->ntexcoordsalced + 1+
					     strlen(s)/2) * sizeof(double));
	    if (w->context->texcoords == NULL)
	       return Failed;
	    w->context->ntexcoordsalced += (strlen(s)/2);
	    }
         w->context->texcoords[j] = r = atof(s3);
         BlkLoc(val) = (union block *)alcreal(r);
         val.dword = D_Real;
         c_put(&f, &val);
         j++;
         if(*s2 == ',') {
	    s2++;
	    i=0;
	    }
         else break;
         }
      /* Number of texture coordinates must be even */
      if (BlkLoc(f)->list.size % 2) {
	 return Error;
	 }
      /* save the number of texture coordinates */
      w->context->numtexcoords = j;
      c_put(&(w->window->funclist), &f);
     }
   /* return an error for any other value */
   else return Error;	
}

/* set the eyepos attribute */
int seteyepos(wbp w, char *s)
{
   char *s2 =s;
   wcp wc = w->context;

   /* parse string */
   while (isspace(*s2)) s2++;

   /* get the x-coordinate of eyepos */
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.'))
      return Error;
   wc->eyeposx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* get the y-coordinate of eyepos */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeposy = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* get the z-coordinate of eyepos */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeposz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2) return Error;

   redraw3D(w);
   return Succeeded;
}

/* sets the eyedir attribute */
int seteyedir(wbp w, char *s)
{
   char *s2 = s;
   wcp wc = w->context;

   while (isspace(*s2)) s2++;
   /* find the x-coordinate of eyedir */
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyedirx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* find the y-coordinate */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyediry= atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* find the z-coordinate */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyedirz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* if there are more entries return an error */
   if (*s2) return Error;
   redraw3D(w);
   return Succeeded;
}

/* sets the eyeup attribute */
int seteyeup(wbp w, char *s)
{
   char *s2 = s;
   wcp wc = w->context;

   while (isspace(*s2)) s2++;

   /* set the x-coordinate of eyeyp */
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.'))
      return Error;
   wc->eyeupx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* set the y-coordinate of eyeup */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.'))
      return Error;
   wc->eyeupy= atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }

   /* set the z-coordinate of eyeup */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.'))
      return Error;
   wc->eyeupz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2) return Error;
   redraw3D(w);
   return Succeeded;
}


/* set the eye attribute */
/* this set the eyeup, eyedir, and the eyepos attributes */
int seteye(wbp w, char *s)
{
   char *s2 = s;
   wcp wc = w->context;

   while (isspace(*s2)) s2++;

   /* set the eyepos attribute */
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeposx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeposy = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeposz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   /* set the eyedir attribute */
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyedirx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyediry= atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyedirz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }

   /* set the eyeup attribute */
   if (*s2++ != ',') return Error;
   while (isspace(*s2)) s2++;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeupx = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeupy= atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2++ != ',') return Error;
   if (!isdigit(*s2) && (*s2 != '-') &&(*s2 != '.')) return Error;
   wc->eyeupz = atof(s2);

   if (*s2 == '-') s2++;
   while (isdigit(*s2)) s2++;
   if (*s2 == '.') {
      s2++;
      while (isdigit(*s2)) s2++;
      }
   if (*s2) return Error;
   if (redraw3D(w) == Failed)
      return Failed;
   return Succeeded;
}

/* set a texture */
int settexture(wbp w, char* str, int len)
{
   wcp wc = w->context;
   char* s;
   int nfields;
   struct descrip f;
   struct descrip d;
   tended struct b_record *rp;
   static dptr constr;
   wtp wt;
   int ttype;

   makecurrent(w);
   if (!constr &&  !(constr = rec_structor3d("gl_texture")))
      syserr("failed to create opengl record constructor");
   nfields = (int) ((struct b_proc *)BlkLoc(*constr))->nfields;

   /*
    * create a record of the graphical object and its parameters
    */
   if (!(rp = alcrecd(nfields, BlkLoc(*constr))))
      return Failed;
   f.dword = D_Record;
   f.vword.bptr = (union block *)rp;
   MakeStr("Texture", 7, &(rp->fields[0])); 

   s=str;
   while(isspace(*s)) s++;
   while(isdigit(*s)) s++;
   while(isspace(*s)) s++;
   if (*s == ',')  /* must be an image string */
      ttype = 3;
   else		  /* it is a file name */
      ttype = 1;

   wt = lookup_texture_byname(w, str, len, ttype);
   if (wt == NULL) return Failed;

   /*
    * To redraw the window we must keep track of the "texture name" assigned
    * to it by opengl. This name is stored in wc->texName[wc->ntextures].
    * So by remembering wc->ntextures we can recover the name of the texture.
    */
   MakeInt(wc->curtexture, &(rp->fields[1]));
   c_put(&(w->window->funclist), &f);

   return Succeeded;
}

/*
 * convert a icon image string into a useable opengl texture
 */
int imagestr(wbp w, char* str)
{
   struct palentry *e;
   int c, i, width, height, row, p;
   word nchars;
   unsigned char *t, *z, *s;

   /* Extract the Width and skip the following comma.*/

   s = str;
   z = s + strlen(str);		/* end+1 of string */
   width = 0;
   while (s < z && *s == ' ')	/* skip blanks */
      s++;
   while (s < z && isdigit(*s))	/* scan number */
      width = 10 * width + *s++ - '0';
   while (s < z && *s == ' ')	/* skip blanks */
      s++;
   if (width == 0 || *s++ != ',') /* skip comma */
      return Failed;
   while (s < z && *s == ' ')	/* skip blanks */
      s++;
   if (s >= z)			     /* if end of string */
	 return Failed;

 /* Check for a bilevel format */
   if ((c = *s) == '#' || c == '~') {
      s++;
      nchars = 0;
      for (t = s; t < z; t++)
         if (isxdigit(*t))
            nchars++;	         /* count hex digits */
         else if (*t != PCH1 && *t != PCH2)
            return Failed;	  /* illegal punctuation */
      if (nchars == 0)
         return Failed;
      row = (width + 3) / 4;	/* digits per row */
      if (nchars % row != 0)
         return Failed;
      height = nchars / row;

      i = bltex(w, width, height, c, s, (word)(z - s));
      if (i == Succeeded)
	   return Succeeded;
      else
	   return Failed;
      }
	

 /* Extract the palette name and skip its comma.*/
   c = *s++;		     /* save initial character */
   p = 0;
   while (s < z && isdigit(*s))    /* scan digits */
      p = 10 * p + *s++ - '0';
   while (s < z && *s == ' ')	  /* skip blanks */
	 s++;
   if (s >= z || p == 0 || *s++ != ',')/* skip comma */
      return Failed;
   if (c == 'g' && p >= 2 && p <= 256)	/* validate grayscale number */
      p = -p;
   else if (c != 'c' || p < 1 || p > 6)	/* validate color number */
      return Failed;

   /* Scan the image to see which colors are needed. */
   e = palsetup(p);
   if (e == NULL)
      return Failed;
   for (i = 0; i < 256; i++)
      e[i].used = 0;
   nchars = 0;
   for (t = s; t < z; t++) {
      c = *t;
      e[c].used = 1;
      if (e[c].valid || e[c].transpt)
         nchars++;	/* valid color, or transparent */
      else if (c != PCH1 && c != PCH2)
         return Failed;
      }
   if (nchars == 0)
      return Failed;			/* empty image */
   if (nchars % width != 0){
      return Failed;			/* not rectangular */
      }

   /* Create the texture */

   height = nchars/width;

   i = textureimg(w, width, height, e, s, (word)(z-s));
   if (i == Succeeded)
      return Succeeded;
   else
      return Failed;
}

/* convert a file into a opengl texture */
int fileimage(wbp w, char* filename)
{
   int r, i, nwidth, nheight;
   int status;
   word l;
   struct imgdata im;
   r = readGIF(filename, 0, &im);

   /* a gif file */
   if (r == Succeeded){
      i = textureimg(w, im.width, im.height, im.paltbl, im.data,
                     (word)im.width*(word)im.height);

   /* we need to handle other cases beside gif...
	 what are those cases ? ... look at ReadImage */
     }
   /* not a gif file */
   else {
     i = SCREENDEPTH(w);
     i = i / 8;
#if HAVE_LIBJPEG
     r = readJPEG(filename, i, &im);

     if (r == Succeeded) {
        switch (i) {
        case 1: i = textureimg(w, im.width, im.height, im.paltbl, im.data,
                        (word)im.width*(word)im.height);
                break;
        case 2: /* i = texture_16img(w, im);
                break; */
        case 3: i = texture_24img(w, im);
                break;
        }
      }
     else
#endif					/* HAVE_JPEG */
         r = readimage(w, filename, 0, 0, &status);
    }
   if (i == Succeeded)
	 return Succeeded;
   else
      return Failed;
}


/*
 * converts the icon representation of an image into
 * a format accepted by opengl
 */
int textureimg(wbp w, int width, int height,
               struct palentry *e, unsigned char *s, word len)
{
#ifdef XWindows
   wdp wd = w->window->display;
#endif					/* XWindows */
   int c, v, i;
   unsigned int ix = 0, iy = height -1;
   GLubyte *tex = (GLubyte *)malloc(height * width * 3);

   makecurrent(w);
   if (tex == NULL) return Failed;

   /*
    * convert string s into an array that can be used by opengl as a texture.
    * we must start at height=height-1 and width=0 to make this look right
    */

   while (len--) {
      c = *s++;
      v = e[c].valid;
      if (v) {
         /* r,g,b component must be between 0 and 256 */
	   tex[(iy*width+ix)*3+0] = e[c].clr.red/256;
	   tex[(iy*width+ix)*3+1] = e[c].clr.green/256;
 	   tex[(iy*width+ix)*3+2] = e[c].clr.blue/256;
        }
      if (v || e[c].transpt) {		/* advance if valid or transparent */
	   if (e[c].transpt) { /* if transparent use background color */
            tex[(iy*width+ix)*3+0] = (GLint)RED(w->context->bg);
            tex[(iy*width+ix)*3+1] = (GLint)GREEN(w->context->bg);
            tex[(iy*width+ix)*3+2] = (GLint)BLUE(w->context->bg);
         }
         if (++ix >= width) {
            ix = 0;	
	  	/* reset for new row */
            iy--;
            }
         }
      }
      if (ix > 0) {	/* pad final row if incomplete */
         while (ix < width) {
            tex[(iy*width+ix)*3+0] = (GLint)RED(w->context->bg);
            tex[(iy*width+ix)*3+1] = (GLint)GREEN(w->context->bg);
            tex[(iy*width+ix)*3+2] = (GLint)BLUE(w->context->bg);
            ix++;
           }
	 }

   /* set the texture */
   i = texture(width, height, (GLubyte *)tex, w->context->texmode);

   free(tex);

   if (i == Succeeded)
      return Succeeded;
   else
      return Failed;
}

/* convert a bi-level image into an opengl texture */
int bltex(wbp w, int width, int height, int ch, char *s, word len)
{
#ifdef XWindows
   wdp wd = w->window->display;
#endif					/* XWindows */
   unsigned int m, msk1, c, ix, iy;
   int r, b, g, i;
   GLubyte tex[height][width][3];

   makecurrent(w);
   m = width % 4;
   if (m == 0)
      msk1 = 8;
   else               /* mask for first byte of row */
      msk1 = 1 << (m - 1);		
   ix = width;
   iy = height-1;
   m = msk1;
   while (len--) {
      /* if hexadecimal character */
      if (isxdigit(c = *s++)) {		
         if (!isdigit(c))		
            c += 9;
         while (m > 0) {
	    --ix;
	    if (c & m){
	       r = (GLint)RED(w->context->fg);
	       g = (GLint)GREEN(w->context->fg);
 	       b = (GLint)BLUE(w->context->fg);
	       tex[iy][ix][0] = r;
	       tex[iy][ix][1] = g;
	       tex[iy][ix][2] = b;
            }
	    else if (ch != TCH1) {
    	       r = (GLint)RED(w->context->bg);
	       g = (GLint)GREEN(w->context->bg);
  	       b = (GLint)BLUE(w->context->bg);
	       tex[iy][ix][0] = r;
	       tex[iy][ix][1] = g;
	       tex[iy][ix][2] = b;
            }
            m >>= 1;
          }
         if (ix == 0) {	    /* if end of row */
            ix = width;
            iy--;
            m = msk1;
            }
         else
            m = 8;
         }
      }
   if (ix > 0)				/* pad final row if incomplete */
      while (ix < width){
         r = (GLint)RED(w->context->bg);
         g = (GLint)GREEN(w->context->bg);
         b = (GLint)BLUE(w->context->bg);
         tex[iy][ix][0] = r;
         tex[iy][ix][1] = g;
         tex[iy][ix][2] = b;
         ix++;
       }

   i = texture(width, height, (GLubyte *)tex, w->context->texmode);
   if (i == Succeeded)
	return Succeeded;
   else
     return Failed;
}


/* check if a number is a power of two */
int powertwo(int a)
{
   int p = 1;
   while(p < a){
      p = p*2;
     }
   if (a == p) return 0;
   else return p;
}

static wclrp lastcp;

/* convert a 2D window into a texture */
int texwindow2D(wbp w, wbp w2d)
{
   struct imgmem imem;
   int i, j, r;
   long rv;
   wsp ws = w2d->window;
   char strout[50];
   char *s2;
   GLubyte tex[ws->height][ws->width][3], *texp;
   LinearColor clr;
   wclrp cp;
   unsigned long c;
   wcp wc = w2d->context;
#ifdef XWindows
   wdp wd = w2d->window->display;
   Display *stddpy = wd->display; 
   XColor colorcell;
   lastcp = wd->colors;
#endif					/* XWindows */

   makecurrent(w);
   imem.x = 0;
   imem.y = 0;
   imem.width = ws->width;
   imem.height = ws->height;
   /* call get pixel to get pixel information */
   if (getpixel_init(w2d, &imem) == Failed)
      return Failed;
   for(j=0; j < ws->height; j++)
	for(i=0; i < ws->width; i++) {
#ifdef XWindows
	   c = colorcell.pixel = XGetPixel(imem.im, i, j);
	   rv = 0xff000000;
	   if (lastcp->c == c) {
	      texp = tex[ws->height-j-1][i];
	      texp[0] = lastcp->r>>8;
	      texp[1] = lastcp->g>>8;
	      texp[2] = lastcp->b>>8;
	      continue;
	      }
	   else
	      for (cp = wd->colors ; cp < wd->colors + wd->numColors; cp++) {
		 if (cp->c == c) {
		    lastcp = cp;
		 foundc:
		    texp = tex[ws->height-j-1][i];
		    texp[0] = cp->r>>8;
		    texp[1] = cp->g>>8;
		    texp[2] = cp->b>>8;
		    continue;
		    }
		 }
	   if (rv == 0xff000000) {
	      XQueryColor(stddpy, wd->cmap, &colorcell);
	      rv = 1;
	      clr = lcolor(w, colorcell);
   	   tex[ws->height-j-1][i][0] = clr.red>>8;
   	   tex[ws->height-j-1][i][1] = clr.green>>8;
    	   tex[ws->height-j-1][i][2] = clr.blue>>8;
	      }
#else
 	   if (getpixel(w2d, i, j, &rv, strout, &imem) == Failed)
            return Failed;
	   s2 = strout;
         /* parse string to get pixel values */
	   while(isspace(*s2)) s2++;
   	   tex[ws->height-j-1][i][0] = atoi(s2)/256;
  	   while(isdigit(*s2)) s2++;
   	   s2++;
   	   tex[ws->height-j-1][i][1] = atoi(s2)/256;
   	   while (isdigit(*s2)) s2++;
  	   s2++;
    	   tex[ws->height-j-1][i][2] = atoi(s2)/256;
#endif
        }

   /* apply the texture */
   r = texture(ws->width, ws->height, (GLubyte*)tex, w->context->texmode);
   if (r == Succeeded)
	return Succeeded;
   else
     return Failed;
}

/* use another opengl window as a texture source */
int texwindow3D(wbp w1, wbp w2)
{
   wsp ws = w2->window;
   int width = ws->width;
   int height = ws->height;
   int i;
   GLubyte tex[height][width][3];

   /* change the current context to w2's context */
#ifdef XWindows
   glXMakeCurrent(ws->display->display, ws->win, w2->context->ctx);
   glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, tex);
   glXMakeCurrent(w1->window->display->display, w1->window->win, w1->context->ctx);
    i = texture(width, height, (GLubyte *)tex, w1->context->texmode);
#endif					/* XWindows */
#ifdef MSWindows
   {
   HDC stddc = CreateWinDC(w2);
   wglMakeCurrent(stddc, w2->context->ctx);
   glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, tex);
   ReleaseDC(ws->iconwin, stddc);
   stddc = CreateWinDC(w1);
   wglMakeCurrent(stddc, w1->context->ctx);
   i = texture(width, height, (GLubyte *)tex, w1->context->texmode);
   ReleaseDC(w1->window->iconwin, stddc);
   }
#endif					/* MSWindows */
    if (i == Succeeded)
       return Succeeded;
    else
       return Failed;
}

/* apply a texture to a scene */
int texture(int width, int height, GLubyte *tex, int texmode)
{
   GLubyte *tex2;

   /* if not a power of two, scale image to closest power of two */
   if (powertwo(width) || powertwo(height)) {
      int neww=1, newh=1, rv;
      while (neww * 2 < width) neww *= 2;
      while (newh * 2 < height) newh *= 2;
      tex2 = (GLubyte *) malloc(neww * newh * 3);
      if (tex2 == NULL) return Failed;
      rv = gluScaleImage(GL_RGB, width, height, GL_UNSIGNED_BYTE, tex,
			 neww, newh, GL_UNSIGNED_BYTE, tex2);
      if (rv) { free(tex2); return Failed; }
      width = neww;
      height = newh;
      }
   else tex2 = tex;

   glTexImage2D(GL_TEXTURE_2D, 0, 3, width, height, 0, GL_RGB,
		GL_UNSIGNED_BYTE, tex2);

   if (tex2 != tex) free(tex2);

   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
   glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, texmode);
   return Succeeded;
}

/*
 * do a translation
 * return -i for runerr 102 on arg i; return 1 for runerr(0) on alloc failure
 */
int translate(wbp w, dptr argv, int i, dptr f)
{
   static dptr constr;
   double coords[3];
   int j, nfields;
   tended struct b_record *rp;

   if (!constr)
      if (!(constr = rec_structor3d("gl_translate")))
	 syserr("failed to create opengl record constructor");
   nfields = (int) ((struct b_proc *)BlkLoc(*constr))->nfields;

   /*
    * convert parameters and perform the translation
    */
   for (j=0; j<3; j++)
      if (!cnv:C_double(argv[i+j], coords[j])) return (-(i+j)-1);

   makecurrent(w);
   glTranslated(coords[0], coords[1], coords[2]);

   /*
    * Create a record of the graphical object and its parameters
    */
   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return 1);
   f->dword = D_Record;
   f->vword.bptr = (union block *)rp;
   MakeStr("Translate", 9, &(rp->fields[0]));
   for (j = i; j < i+3; j++)
      rp->fields[1 + j - i] = argv[j];
   c_put(&(w->window->funclist), f);
   return 0;
}

/*
 * do a rotation
 * return -i for runerr 102 on arg i; return 1 for runerr(0) on alloc failure
 */
int rotate(wbp w, dptr argv, int i, dptr f)
{
   int nfields, j;
   double coords[4];
   static dptr constr;
   tended struct b_record *rp;

   if (!constr)
      if (!(constr = rec_structor3d("gl_rotate")))
	 syserr("failed to create opengl record constructor");
   nfields = (int) ((struct b_proc *)BlkLoc(*constr))->nfields;

   /* convert parameters and perform the rotation */
   for (j=0; j < 4; j++)
      if (!cnv:C_double(argv[i+j], coords[j])) return (-(i+j)-1);
   makecurrent(w);
   glRotated(coords[0], coords[1], coords[2], coords[3]);

   /*
    * create a record of the graphical object and its parameters
    */
   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return 1);
   f->dword = D_Record;
   f->vword.bptr = (union block *)rp;
   MakeStr("Rotate", 6, &(rp->fields[0]));
   /* strangeness here preserves name,x,y,z,... field ordering */
   rp->fields[4] = argv[i];
   rp->fields[1] = argv[i+1];
   rp->fields[2] = argv[i+2];
   rp->fields[3] = argv[i+3];
   c_put(&(w->window->funclist), f);
   return 0;
}

/*
 * do a scaling
 * return -i for runerr 102 on arg i; return 1 for runerr(0) on alloc failure
 */
int scale(wbp w, dptr argv, int i, dptr f)
{
   int nfields, j;
   double coords[3];
   static dptr constr;
   tended struct b_record *rp;

   if (!constr)
      if (!(constr = rec_structor3d("gl_scale")))
	 syserr("failed to create opengl record constructor");
   nfields = (int) ((struct b_proc *)BlkLoc(*constr))->nfields;

   /*
    * convert parameters and perform scaling
    */
   for(j=0; j<3; j++)
      if (!cnv:C_double(argv[i+j], coords[j])) return -(i+j)-1;
   makecurrent(w);
   glScaled(coords[0], coords[1], coords[2]);

   /*
    * create a record of the graphical object and its parameters
    */
   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return 1);
   f->dword = D_Record;
   f->vword.bptr = (union block *)rp;
   MakeStr("Scale", 5, &(rp->fields[0]));
   for (j = i; j < i+3; j++)
      rp->fields[1 + j - i] = argv[j];
   c_put(&(w->window->funclist), f);
   return 0;
}

/*
 * For each 3D graphics operation, there is a descriptor that
 * holds the record constructor for that type of primitive.
 * The first field is named "name"; for > 1 field, their names are in
 * an array. If fields > 2, then fields 2-4 are named "x", "y", "z".
 */
struct descrip gl_torus = {D_Null};
struct descrip gl_cube = {D_Null};
struct descrip gl_sphere = {D_Null};
struct descrip gl_cylinder = {D_Null};
struct descrip gl_disk = {D_Null};
struct descrip gl_rotate = {D_Null};
struct descrip gl_translate = {D_Null};
struct descrip gl_scale = {D_Null};
struct descrip gl_popmatrix = {D_Null};
struct descrip gl_pushmatrix = {D_Null};
struct descrip gl_identity = {D_Null};
struct descrip gl_matrixmode = {D_Null};
struct descrip gl_texture = {D_Null};

char * gl_torus_fields[] = {"radius1","radius2"};
char * gl_cube_fields[] = {"length"};
char * gl_sphere_fields[] = {"radius"};
char * gl_cylinder_fields[] ={"height","radius1","radius2"};
char * gl_disk_fields[] = {"radius1","radius2", "angle1","angle2"};
char * gl_rotate_fields[] = {"angle"};
char * gl_matrixmode_fields[] = {"mode"};
char * gl_texture_fields[] = {"texture_handle"};

dptr rec_structinate(dptr dp, char *name, int nfields, char *a[])
{
   int i;
   struct descrip s;
   struct descrip fields[16];
   if (is:null(*dp)) {
      AsgnCStr(s, name);
      AsgnCStr(fields[0], "name");
      if (nfields > 2) {
         AsgnCStr(fields[1], "x");
         AsgnCStr(fields[2], "y");
         AsgnCStr(fields[3], "z");
         for(i=4; i < nfields; i++)
            AsgnCStr(fields[i], a[i-4]);
         }
      else if (nfields == 2)
         AsgnCStr(fields[1], a[0]);
      dp->dword = D_Proc;
      dp->vword.bptr = (union block *)dynrecord(&s, fields, nfields);
      }
   return dp;
}

dptr rec_structor3d(char *name)
{
#ifdef Graphics3D
   if (!strcmp(name, "gl_torus"))
      return rec_structinate(&gl_torus, "gl_torus", 6, gl_torus_fields);
   else if (!strcmp(name, "gl_cube"))
      return rec_structinate(&gl_cube, "gl_cube", 5, gl_cube_fields);
   else if (!strcmp(name, "gl_sphere"))
      return rec_structinate(&gl_sphere, "gl_sphere", 5, gl_sphere_fields);
   else if (!strcmp(name, "gl_cylinder"))
      return rec_structinate(&gl_cylinder, "gl_cylinder",7,gl_cylinder_fields);
   else if (!strcmp(name, "gl_disk"))
      return rec_structinate(&gl_disk, "gl_disk", 8, gl_disk_fields);
   else if (!strcmp(name, "gl_rotate"))
      return rec_structinate(&gl_rotate, "gl_rotate", 5, gl_rotate_fields);
   else if (!strcmp(name, "gl_translate"))
      return rec_structinate(&gl_translate, "gl_translate", 4, NULL);
   else if (!strcmp(name, "gl_scale"))
      return rec_structinate(&gl_scale, "gl_scale", 4, NULL);
   else if (!strcmp(name, "gl_popmatrix"))
      return rec_structinate(&gl_popmatrix, "gl_popmatrix", 1, NULL);
   else if (!strcmp(name, "gl_pushmatrix"))
      return rec_structinate(&gl_pushmatrix, "gl_pushmatrix", 1, NULL);
   else if (!strcmp(name, "gl_identity"))
      return rec_structinate(&gl_identity, "gl_identity", 1, NULL);
   else if (!strcmp(name, "gl_matrixmode"))
      return rec_structinate(&gl_matrixmode, "gl_matrixmode",
				2, gl_matrixmode_fields);
   else if (!strcmp(name, "gl_texture"))
      return rec_structinate(&gl_texture, "gl_texture", 2, gl_texture_fields);
#endif					/* Graphics3D */

   return 0;
}

wtp lookup_texture_byname(wbp w, char *name, int len, int ttype)
{
   char filename[MaxFileName +1];
   wcp wc = w->context;
   wtp wt = wc->textures, wt2;
   int i;
   makecurrent(w);
   while (wt) {
      if (wt->textype == ttype) {
	 switch (ttype) {
	 case 1: /* file */
	    if ((StrLen(wt->d) == len) && strncmp(StrLoc(wt->d),name,len)==0) {
	       wc->curtexture = wt->texindex;
	       return wt;
	       }
	    break;
	 case 2: /* window */
	    break;
	 case 3: /* string */
	    break;
	    }
	 }
      wt = wt->next;
      }
   GRFX_ALLOC(wt2, _wtexture);
   wt2->textype = ttype;
   StrLoc(wt2->d) = strdup(name);
   StrLen(wt2->d) = len;

   wt2->next = wc->textures;
   if (wc->textures) {
      wc->textures->previous = wt2;
      }
   wc->textures = wt2;

   /*
    * need a new texture name, make room for it if necessary
    */
   if (wc->ntextures >= wc->nalced) {
      wc->nalced *= 2;
      wc->texName = realloc(wc->texName, wc->nalced * sizeof(GLuint));
      glGenTextures(wc->nalced / 2, wc->texName + wc->nalced / 2);
      }
   glBindTexture(GL_TEXTURE_2D, wc->texName[wc->ntextures]);
   wc->curtexture = wt2->texindex = wc->ntextures;
   wc->ntextures++;

   if (ttype == 3)
      i = imagestr(w, name);
   else {
      strncpy(filename, name, MaxFileName);
      filename[MaxFileName] = '\0';
      i = fileimage(w, filename);
      }
   if (i == Succeeded)
      return wt2;
   else return NULL;
}

int texture_24img(wbp w, struct imgdata im)
{
#ifdef XWindows
   wdp wd = w->window->display;
#endif					/* XWindows */
   int width=im.width, height=im.height;
   word len;
   int c, v, i;
   unsigned char *t;
   unsigned int ix = 0, iy = height -1;
   GLubyte *tex = (GLubyte *)malloc(im.height * im.width * 3);

   width = im.width;
   len = (word)im.width * (word)im.height;
   makecurrent(w);
   if (tex == NULL) return Failed;

   /*
    * convert string s into an array that can be used by opengl as a texture.
    * we must start at height=height-1 and width=0 to make this look right
    */

   t = im.data;
   while (len--) {
         /* r,g,b component must be between 0 and 256 */
      tex[(iy*width+ix)*3+0] = t[0];
      tex[(iy*width+ix)*3+1] = t[1];
      tex[(iy*width+ix)*3+2] = t[2];
      t = t+3;
      if (++ix >= width) {
         ix = 0;	
 	/* reset for new row */
         iy--;
      }
    }
    if (ix > 0) {	/* pad final row if incomplete */
         while (ix < width) {
            tex[(iy*width+ix)*3+0] = (GLint)RED(w->context->bg);
            tex[(iy*width+ix)*3+1] = (GLint)GREEN(w->context->bg);
            tex[(iy*width+ix)*3+2] = (GLint)BLUE(w->context->bg);
            ix++;
           }
	 }

   /* set the texture */
   i = texture(width, height, (GLubyte *)tex, w->context->texmode);

   free(tex);

   if (i == Succeeded)
      return Succeeded;
   else
      return Failed;
}

int texture_16img(wbp w, struct imgdata im)
{
#ifdef XWindows
   wdp wd = w->window->display;
#endif					/* XWindows */
   int width=im.width, height=im.height;
   word len;
   int c, v, i;
   unsigned char *t;
   unsigned int ix = 0, iy = height -1;
   GLubyte *tex = (GLubyte *)malloc(height * width * 3);

   len = (word)im.width * (word)im.height;
   makecurrent(w);
   if (tex == NULL) return Failed;

   /*
    * convert string s into an array that can be used by opengl as a texture.
    * we must start at height=height-1 and width=0 to make this look right
    */

   t = im.data;
   while (len--) {
         /* r,g,b component must be between 0 and 256 */
      tex[(iy*width+ix)*3+0] = t[0] && 0xF8;
      tex[(iy*width+ix)*3+1] = t[1] && 0xF8;
      tex[(iy*width+ix)*3+2] = t[2] && 0xF8;
      t = t+3;
      if (++ix >= width) {
         ix = 0;	
 	/* reset for new row */
         iy--;
      }
   }
   if (ix > 0) {	/* pad final row if incomplete */
         while (ix < width) {
            tex[(iy*width+ix)*3+0] = (GLint)RED(w->context->bg);
            tex[(iy*width+ix)*3+1] = (GLint)GREEN(w->context->bg);
            tex[(iy*width+ix)*3+2] = (GLint)BLUE(w->context->bg);
            ix++;
           }
    }

   /* set the texture */
   i = texture(width, height, (GLubyte *)tex, w->context->texmode);

   free(tex);

   if (i == Succeeded)
      return Succeeded;
   else
      return Failed;
}
