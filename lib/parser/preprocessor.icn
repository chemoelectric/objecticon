package parser

import io, util

class Preprocessor(Connectable)
   private
      sym_table,if_stack,file_stack,if_state,
      file,filename,line,
      nest_level,include_name,
      include_set,print_filename,
      encoding,print_encoding

   public static const 
      DEFAULT_SYMBOLS

   private static init()
      local s
      DEFAULT_SYMBOLS := table()
      # reverse engineer the predefined symbols list from our predefined symbols
      every s := &features do {
         DEFAULT_SYMBOLS[case s of {
            "Object Icon": "_OBJECT_ICON"
            "V2": "_V2"
            "keyboard functions": "_KEYBOARD_FUNCTIONS"
            "JPEG images": "_JPEG"
            "PNG images": "_PNG"
            "SSL networking": "_SSL"
            "MS Win32":"_MS_WIN32"
            "UNIX":"_UNIX"
            "POSIX":"_POSIX"
            "ASCII":"_ASCII"
            "co-expressions":"_CO_EXPRESSIONS"
            "dynamic loading":"_DYNAMIC_LOADING"
            "event monitoring":"_EVENT_MONITOR"
            "large integers":"_LARGE_INTEGERS"
            "multiple programs":"_MULTITASKING"
            "pipes":"_PIPES"
            "system function":"_SYSTEM_FUNCTION"
            "graphics":"_GRAPHICS"
            "X Windows":"_X_WINDOW_SYSTEM"
            "Linux": "_LINUX"
            "Solaris": "_SOLARIS"
            "AIX": "_AIX"
            "BSD": "_BSD"
            "Darwin": "_DARWIN"
            "Cygwin": "_CYGWIN"
         }] := "1"
      }
   end

   #
   # Preprocess a file to a string.
   #
   public preprocess(fname, predefined_syms)
      local sb
      sb := RamStream()
      every sb.out(preprocess_gen(fname, predefined_syms) || "\n")
      return sb.done()
   end

   #
   # Preprocesses a file, generating output lines.
   #
   public preprocess_gen(fname, predefined_syms)
      local s
      preproc_new(fname, predefined_syms) | fail
      suspend sync_lines()      
      while s := read_line() do {
         # s will be &null if we have just come back from an include.  If so,
         # produce a #line directive.
         if /s then
            suspend sync_lines()      
         else s ? {
            if match("#line") then {
               move(1)
               suspend scan_directive()
            } else {
               scan_space()
               if ="$" & any(&letters ++ &digits ++ ' \t\f\r') then {
                  suspend scan_directive()
               } else {
                  move(1)
                  suspend scan_text()
               }
            }
         }
      }
      close(\file)
      done()
   end

   #
   # a_Initializes the preprocessor "object".
   #
   private preproc_new(fname,predefined_syms)
      sym_table := \predefined_syms | copy(DEFAULT_SYMBOLS)
      if_stack := []
      file_stack := []
      include_set := set(fname)
      if_state := &null
      filename := include_name := fname
      line := 0
      print_filename := &null
      print_encoding := &null
      nest_level := 0
      encoding := "ASCII"
      if not(file := open(fname)) then {
         err("cannot open " || image(fname) || ": " || &why)
         fail
      }
      return
   end

   #
   # Clears the values of certain space-consuming variables.
   #
   private done()
      sym_table := if_stack := file_stack :=
         filename := print_filename := print_encoding :=
         encoding := file := include_set := &null
      return
   end

   #
   # a_Scans an encoding identifier.
   #
   private get_encoding()
      suspend any(&letters) & tab(many(&letters ++ &digits ++ '-'))
   end

   #
   # a_Scans a preprocessor directive.  This method fails or returns
   # either a blank line or a #line directive.
   #
   private scan_directive()
      local sym,value,new_file,new_filename,new_line,new_encoding,old,preproc_command,old_if_state,fname,t
      scan_space()
      preproc_command := scan_word()
      if \if_state then {
         if match("if",preproc_command) then {
            preproc_command := "$if"
         }
      }
      scan_space()
      case preproc_command of {
         "define": {
            if /if_state then {
               if sym := scan_word() &
                  value := scan_define_value() then 
               {
                  if \ (old := sym_table[sym]) ~=== value then {
                     err("redefinition of " || sym || " = " ||
                                   old)
                  } else {
                     sym_table[sym] := value
                  }
               } else {
                  err()
               }
               return ""
            }
         }
         "undef": {
            if /if_state then {
               if sym := scan_word() & at_end() then {
                  delete(sym_table,sym)
               } else {
                  err()
               }
               return ""
            }
         }
         "load": {
            if /if_state then {
               if sym := scan_word() &
                  scan_opt_space() &
                  fname := scan_qword() & *fname > 0 & at_end() then 
               {
                  if t := Files.path_find(fname, 
                                          "OI_INCL",
                                          FilePath(filename).parent().str()) then
                  {
                     if value := image(Files.file_to_string(t)) then {
                        if \ (old := sym_table[sym]) ~=== value then {
                           err("redefinition of " || sym || " = " ||
                               old)
                        } else {
                           sym_table[sym] := value
                        }
                     } else
                        err("cannot load " || image(t) || ": " || &why)
                  } else
                     err("cannot find " || image(fname) || " on path")
               } else
                  err()
               return ""
            }
         }
         "uload": {
            if /if_state then {
               if sym := scan_word() &
                  scan_opt_space() &
                  fname := scan_qword() & *fname > 0 & at_end() then 
               {
                  if t := Files.path_find(fname, 
                                          "OI_INCL",
                                          FilePath(filename).parent().str()) then
                  {
                     if value := "u" || image(Files.file_to_string(t)) then {
                        if \ (old := sym_table[sym]) ~=== value then {
                           err("redefinition of " || sym || " = " ||
                               old)
                        } else {
                           sym_table[sym] := value
                        }
                     } else
                        err("cannot load " || image(t) || ": " || &why)
                  } else
                     err("cannot find " || image(fname) || " on path")
               } else
                  err()
               return ""
            }
         }
         "ifdef" | "ifndef": {
            push(if_stack,if_state)
            if sym := scan_word() & at_end() then {
               if /if_state then {
                  value := (\sym_table[sym] & &null) | "false"
                  if match("n",preproc_command,3) then {
                     value := (\value & &null) | "false"
                  }
                  if_state := value
               } else {
                  if_state := "off"
               }
            } else {
               if_state := "off"
               err()
            }

            if /if_state then
               return ""
            else
               fail
         }
         "$if": {    # handles if... command in "if'd-out" code
            push(if_stack,if_state)
            if_state := "off"
            fail
         }
         "elsifdef" | "elsifndef" : {
            if sym := scan_word() & at_end() then {
               if *if_stack <= nest_level then {
                  err("no corresponding $if...")
               } else {
                  if \if_state == "false" then {
                     value := (\sym_table[sym] & &null) | "false"
                     if match("n",preproc_command,6) then {
                        value := (\value & &null) | "false"
                     }
                     if_state := value
                  } else {
                     if_state := "off"
                  }
               }
            } else {
               err()
            }
            if /if_state then
               return sync_lines()
            else
               fail
         }
         "else": {
            if at_end() then {
               if *if_stack <= nest_level then {
                  err("no corresponding $if...")
               } else {
                  if_state := {
                     case if_state of {
                        "false": &null
                        "off": "off"
                        default: "false"
                     }
                  }
               }
            } else {
               err()
            }
            if /if_state then
               return sync_lines()
            else
               fail
         }
         "endif": {
            old_if_state := if_state
            if at_end() then {
               (*if_stack >= nest_level &
                if_state := pop(if_stack)) |
                  err("no corresponding $if...")
            } else {
               *if_stack >= nest_level &
                  if_state := pop(if_stack)
               err()
            }
            if /if_state then {
               if /old_if_state then
                  return ""
               else
                  return sync_lines()
            } else
               fail
         }
         "include": {
            if /if_state then {
               if sym := scan_qword() & *sym > 0 & at_end() then {
                  if member(include_set,sym) then {
                     err("circular reference to " || image(sym))
                  } else {
                     if new_filename := Files.path_find(sym, 
                                                        "OI_INCL",
                                                        FilePath(filename).parent().str()) then
                     {
                        if new_file := open(new_filename) then {
                           every push(file_stack,
                                      encoding|file|filename|
                                      include_name|line|
                                      nest_level)
                           filename := new_filename
                           include_name := sym
                           file := new_file
                           line := 0
                           encoding := "ASCII"
                           nest_level := *if_stack
                           insert(include_set,sym)
                        } else
                           err("cannot open " || image(new_filename) || ": " || &why)
                     } else
                        err("cannot find " || image(sym) || " on path")
                  }
               } else {
                  err()
               }
               return sync_lines()
            }
         }
         "line": {
            if new_line := integer(tab(many(&digits))) &
               scan_opt_space() &
               (new_filename := scan_qword() | &null) \ 1 &
               (/new_filename | *new_filename > 0) \ 1 &
               scan_opt_space() &
               (new_encoding := get_encoding() | &null) \ 1 &
               at_end() then 
            {
               filename := Files.path_find(\new_filename, 
                                           &null,
                                           FilePath(filename).parent().str()) | \new_filename
               encoding := \new_encoding
               line := new_line - 1
            } else {
               err()
            }
            if /if_state then
               return sync_lines()
         }
         "error": {
            if /if_state then {
               scan_space()
               err(trim(tab(find("#") | 0),' \t\f\r'))
               return ""
            }
         }
         "encoding": {
            if /if_state then {
               if sym := get_encoding() &
                  at_end() then
                  encoding := sym
               else
                  err()
               return sync_lines()
            }
         }
         "ITRACE": {
            if /if_state then {
               if value := integer(tab(many(&digits ++ '-'))) &
                  at_end() then 
               {
                  &trace := value
               } else {
                  err()
               }
               return ""
            }
         }
         default: {
            if /if_state then {
               err("unknown preprocessor directive:" || preproc_command)
               return ""
            }
         }
      }
   end

   #
   # Scans and make substitutions in a text line.
   #
   private scan_text(done_set)
      local q,result,p,interesting_in_quotes,ident,value,t
      if /if_state then {
         if *sym_table > 0 then {
            &pos := q := 1
            result := ""
            while tab(upto('#"\'_' ++ &letters)) do {
               case move(1) of {
                  "#": {
                     move(-1)
                     tab(0)
                  }
                  "\"" | "'": {
                     interesting_in_quotes := '\\' ++ &subject[&pos - 1]
                     repeat {
                        while tab(upto(interesting_in_quotes)) do {
                           case move(1) of {
                              "\\": move(1)
                              default: {
                                 break break
                              }
                           }
                        }
                        suspend if q = 1 then .&subject else result || &subject[q:0]
                        if not match("_",,-1) then {
                           break
                        }
                        t := read_line() | fail
                        # If we've just come back from a $include, t will be &null, so set it to
                        # "#line ..." (this is bound to be a nonsense result anyway, since we're in
                        # the middle of a multi-line string).
                        /t := sync_lines()
                        &subject := t
                        result := ""
                     }
                  }
                  default: {
                     move(-1)
                     p := &pos
                     ident := tab(many(&letters ++ &digits ++ '_'))
                     if value := \sym_table[ident] then {
                        if /done_set |
                        {type(done_set) == "string" &
                            done_set := set(done_set)
                         not member(done_set,ident)} then {
                            value ? value :=
                               scan_text(insert(copy(\done_set),
                                                ident) | ident)
                            result ||:= &subject[q:p] || value
                            q := &pos
                         }
                     }
                  }
               }
            }
            suspend if q = 1 then .&subject else result || &subject[q:0]
         }
         else {
            suspend .&subject
         }
      }
   end

   #
   # Reads an input line.  Manages end-of-file and reverting to including
   # file if appropriate, failing at end-of-input.
   #
   private read_line()
      local result
      until result := read(file) do {
         if *if_stack ~= nest_level then {
            err("$if(s) without $endif(s): " ||
                          *if_stack - nest_level)
            until *if_stack <= nest_level do
               if_state := pop(if_stack)
         }
         close(file)
         file := &null
         delete(include_set,include_name)
         (nest_level := pop(file_stack) &
          line := pop(file_stack) &
          include_name := pop(file_stack) &
          filename := pop(file_stack) &
          file := pop(file_stack) &
          encoding := pop(file_stack)) | fail
         return &null
      }
      line +:= 1
      return result
   end

   #
   # Scans an identifier.
   #
   private scan_word()
      suspend any(&letters ++ '_') & tab(many(&letters ++ &digits ++ '_'))
   end

   #
   # Scans a possibly-quoted word (e.g. a file name).
   #
   private scan_qword()
      suspend 2(="\"",
                tab(find("\"")),
                move(1)) |
         scan_word()
   end

   #
   # Scans the value of a $define.
   #
   private scan_define_value()
      local q,interesting_in_quotes

      if ="(" then {
         fail      # "$define name(" is specifically prohibited; needs whitespace
      }
      scan_space()
      q := &pos
      (while tab(upto('#"\'')) do {
         case move(1) of {
            "#": {
               move(-1)
               break
            }
            default: {
               interesting_in_quotes := '\\' ++ &subject[&pos - 1]
               repeat {
                  while tab(upto(interesting_in_quotes)) do {
                     case move(1) of {
                        "\\": move(1)
                        default: {
                           break break
                        }
                     }
                  }
                  fail # end of line inside quotes!!
               }
            }
         }
      }) | tab(0)
      return trim(&subject[q:&pos],' \t\f\r')
   end

   #
   # Scans white space.
   #
   private scan_space()
      suspend tab(many(' \t\f\r'))
   end

   #
   # Scans optional white space.
   #
   private scan_opt_space()
      local i
      suspend if i := many(' \t\f\r') then tab(i) else ""
   end

   #
   # Tests for &pos at the logical end of a preprocessor directive.
   #
   private at_end()
      scan_space()
      return pos(0) | match("#")
   end

   #
   # Determines if a "#lines" is called for and generates one if so.
   #
   private sync_lines()
      if (encoding ~=== print_encoding) |
         (filename ~=== print_filename) then 
      {
         print_encoding := encoding
         print_filename := filename
         return "#line " || (line + 1) || " \"" || filename || "\" " || encoding
      }
      return "#line " || (line + 1)
   end

   private err(msg)
      /msg := "Invalid preprocessor line"
      fire("error", ErrorDetail(FilePath(filename).canonical().str(), line, msg))
   end
end
