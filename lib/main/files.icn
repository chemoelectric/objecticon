package io

import 
   util,
   ipl.random

$include "posix.icn"

#
# This class has several static methods which provide
# system-independent access to the file system.
#
class Files()
   private static const FS

   private static init()
      FS := 
         if has_feature("MS Win32") then 
            WindowsFileSystem()
         else if has_feature("UNIX") then
            UnixFileSystem()
         else
            stop("Can't init_file_system: unknown o/s type")
   end

   #
   # Read the given directory returning a list of [name, {Stat}] pairs.
   #
   public static list(s)
      local l, p, s2, sr, path, path2
      path := FS.get_path(s)
      p := DirStream.open(path.str()) | return error("Can't open " || image(path.str()) || ":" || &why)
      l := []
      while s2 := read(p) do {
         path2 := path.child(s2)
         sr := lstat(path2.str()) | {
            p.close()
            return error("Can't stat " || image(path2.str()) || ":" || &why)
         }
         put(l, [s2, sr])
      }
      close(p)
      return l
   end

   #
   # Return a {FilePath} corresponding to the given path in string
   # form.
   #
   public static get_path(s)
      return FS.get_path(s)
   end

   #
   # Return a {FilePath} corresponding to the elements in the given
   # list.
   #
   public static get_path_from_list(l)
      return FS.get_path_from_list(default.copy(l))
   end

   #
   # Return the home directory.
   #
   public static get_home()
      return FS.get_home()
   end

   #
   # Return the temporary directory.
   #
   public static get_temp()
      return FS.get_temp()
   end

   #
   # Succeed iff the given file is hidden.
   #
   public static is_hidden(s)
      return FS.is_hidden(s)
   end

   #
   # Succeed iff the given file is a relative directory name (on Unix,
   # "." or "..").
   #
   public static is_relative_dir(s)
      return FS.is_relative_dir(s)
   end

   #
   # Get the roots of the file system.
   #
   public static get_roots()
      suspend FS.get_roots()
   end

   #
   # Split a list of paths (such as the $PATH variable) into its
   # constituent elements.
   #
   public static split_paths(s)
      suspend FS.split_paths(s)
   end

   #
   # Load a file into a string
   #
   public static file_to_string(fn)
      local res, f
      f := FileStream.open(fn, O_RDONLY) | return error("Couldn't open " || fn || ":" || &why)
      res := ""
      while res ||:= f.reads(8192)
      f.close()
      f.eof() | fail
      return res
   end

   #
   # Write a string to a file.
   #
   public static string_to_file(fn, s)
      local f
      f := FileStream.open(fn, ior(O_WRONLY, O_TRUNC, O_CREAT)) | 
         return error("Couldn't open " || fn || ":" || &why)
      f.writes(s) | {
         f.close()
         fail
      }
      f.close() | fail
      return s
   end

   #
   # Make a temporary filename.
   # @param prefix, by default empty
   # @param suffix, by default empty
   # @param path, the directory, by default {get_temp()}
   # @param len, the number of digits in the result, default 8
   #
   public static make_temp_filename(prefix, suffix, path, len)
      local p, name, f

      /prefix := ""
      /suffix := ""
      /path := get_temp()
      /len := 8

      randomize()

      p := get_path(path)
      repeat {
         ?1                                # change &random
         name := p.child(prefix || left(&random, len, "0") || suffix).str()
         if not access(name) then {
            # Touch the filename to stop anyone else using it.
            f := FileStream.open(name, ior(O_WRONLY, O_CREAT)) | fail
            f.close()
            return name
         }
      }
   end

   #
   # Succeed iff the two given files have the same content.
   #
   public static equal_files(s1, s2)
      local f1, f2, r

      stat(s1).size = stat(s2).size | fail

      f1 := FileStream.open(s1, O_RDONLY) | return error("Couldn't open " || s1 || ":" || &why)
      f2 := FileStream.open(s2, O_RDONLY) | {
         f1.close()
         return error("Couldn't open " || s2 || ":" || &why)
      }

      if equal_files1(f1, f2) then
         r := 1

      f1.close()
      f2.close()

      return \r
   end

   private static equal_files1(f1, f2)
      local b1, b2

      while b1 := f1.reads(8192) do {
         b2 := f2.reads(8192) | fail
         b1 == b2 | fail
      }
      f1.eof() | fail
      # A further read of f2 should fail and set its eof flag.
      if f2.reads(1) then
         fail
      return f2.eof()
   end

   #
   # Succeed iff the given file is a directory.
   #
   public static is_directory(s)
      return stat(s).mode[1] == "d"
   end

   #
   # Move a file.  First, try to move it by renaming it.  If that
   # fails, try to copy the file then delete the original, or if that
   # fails, fail.
   #
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static move(s1, s2)
      if rename(s1, s2) then
         return
      copy(s1, s2) | fail
      remove(s1)
      return
   end

   #
   # Rename a file.
   #
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static defer rename(s1, s2)

   #
   # Create a (hard) link to a file.
   #
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static defer hardlink(s1, s2)

   #
   # Create a symlink to a file.
   #
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static defer symlink(s1, s2)

   #
   # Read a symbolic link
   #
   # @param s the source filename
   #
   public static defer readlink(s)

   #
   # Remove a file, or an empty directory
   #
   # @param s the file or empty directory
   #
   public static defer remove(s)

   #
   # Make a new directory
   #
   # @param s the directory path
   # @param perm the permission bits, defaults to rwxr-xr-x
   #
   public static defer mkdir(s, perm)

   #
   # Truncate the given file to {len} bytes.
   #
   # @param s1 the source filename
   # @param len the desired length
   #
   public static defer truncate(s, len)

   #
   # Obtain information about the given file
   #
   # @param s the file
   # @return a {Stat} object
   #
   public static stat(s)
      return Stat!stat_impl(s)
   end

   private static defer stat_impl(s)

   #
   # Obtain information about the given file without following
   # symlinks.
   #
   # @param s the file
   # @return a {Stat} object
   #
   public static lstat(s)
      return Stat!lstat_impl(s)
   end

   private static defer lstat_impl(s)

   #
   # Check whether the given file can be accessed in the given mode.
   #
   public static defer access(s, mode)

   #
   # Copy a file.
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static copy(s1, s2)
      local f1, f2
      f1 := FileStream.open(s1, O_RDONLY) | return error("Couldn't open " || s1 || ":" || &why)
      f2 := FileStream.open(s2, ior(O_WRONLY, O_TRUNC, O_CREAT)) | {
         f1.close()
         return error("Couldn't open " || s2 || ":" || &why)
      }
      while f2.writes(f1.reads(8192))
      f1.close()
      f2.close() | return error("Failed to close " || s2 || ":" || &why)
      f1.eof() | fail
      return
   end

   #
   # Append file {s1} onto {s2}.
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static append(s1, s2)
      local f1, f2
      f1 := FileStream.open(s1, O_RDONLY) | return error("Couldn't open " || s1 || ":" || &why)
      f2 := FileStream.open(s2, ior(O_WRONLY, O_APPEND, O_CREAT)) | {
         f1.close()
         return error("Couldn't open " || s2 || ":" || &why)
      }
      while f2.writes(f1.reads(8192))
      f1.close()
      f2.close() | return error("Failed to close " || s2 || ":" || &why)
      f1.eof() | fail
      return
   end

   #
   # Given a stem filename, return another unique filename based upon it.
   #
   public static ensure_unique_filename(stem)
      local i, p, s
      access(stem) | return stem
      i := 1
      every p := find(".", stem)
      repeat {
         s := stem
         if /p then
            s ||:= "_" || i
         else
            s[p] := "_" || i || s[p]
         access(s) | return s
         i +:= 1
      }
   end

   #
   # This procedure searches for a file on a environment-defined path.
   # It follows the same logic as the C function pathfind() in
   # mlocal.c
   #
   # @param f the file to look for
   # @param n the name of the environment variable holding the path
   #
   public static path_find(f, n, mode)
      local p, s

      /mode := F_OK
      # First of all see if it exists without any search
      if access(f, mode) then
         return f

      p := get_path(f)
      # We never append absolute paths to the search path
      if p.is_absolute() then
         fail

      # Search all the elements in the path
      every s := get_path(split_paths(getenv(n))).append(p).str() do {
         if access(s, mode) then
            return s
      }
   end
end

#
# This class provides implementations of some of the methods in
# {Files}.  It is not used directly by clients.
#
class FileSystem()
   public defer get_path(s)

   public defer get_path_from_list(l)

   public defer get_home()

   public defer get_temp()

   public defer is_hidden(s)

   public defer is_relative_dir(s)

   public defer get_roots()

   public defer split_paths(s)
end

#
# This class manipulates file paths by treating them as a list of
# elements.  Instances are not created directly by the client, rather
# they are created initially via {Files.get_path()} and then via other
# methods in this class.
#
# Instances of this class are immutable.
#
class FilePath()
   protected l

   #
   # Return the number of elements in the path.
   #
   public size()
      return *l
   end

   #
   # Return the {i}th element in the path.
   #
   public get(i)
      return .l[i]
   end

   #
   # Generate the elements in the path.
   #
   public gen()
      suspend .!l
   end

   #
   # Return the path formed by appending the elements of this path to
   # the other path.
   #
   public append(other)
      return classof(self)(l ||| other.l)
   end

   #
   # Return the parent path, ie a path with everything but the last
   # element.  Fails if the path has no elements.
   #
   public parent()
      return classof(self)(l[1:-1])
   end

   #
   # Return the child path, ie a path with the same elements plus the
   # element {s}.
   #
   public child(s)
      return classof(self)(l ||| [s])
   end

   #
   # Return a path which represents the absolute path of this
   # path.
   #
   public defer absolute()

   #
   # Convert the path back into a string.
   #
   public defer str()

   #
   # Succeed iff this path represents an absolute path.
   #
   public defer is_absolute()

   #
   # Canonicalize a path, which means trying to turn it into a
   # standard form.  This involves (at least) getting the absolute
   # path and removing any redundant path elements.
   #
   public defer canonical()

   package new(l)
      self.l := l
      return
   end
end

#
# This class represents file stat information.
#
class Stat()
   public const 
      dev,
      ino,
      mode,
      nlink,
      uid,
      gid,
      rdev,
      size,
      blksize,
      blocks,
      atime,
      mtime,
      ctime

   package new(dev,
               ino,
               mode,
               nlink,
               uid,
               gid,
               rdev,
               size,
               blksize,
               blocks,
               atime,
               mtime,
               ctime)
      self.dev := dev
      self.ino := ino
      self.mode := mode
      self.nlink := nlink
      self.uid := uid
      self.gid := gid
      self.rdev := rdev
      self.size := size
      self.blksize := blksize
      self.blocks := blocks
      self.atime := atime
      self.mtime := mtime
      self.ctime := ctime
      return
   end
end

class UnixFilePath(FilePath)
   public str()
      local e, s
      s := ""
      every e := !l do {
         if s[-1] ~== "/" then 
            s ||:= "/"
         s ||:= e
      }
      return s
   end

   public is_absolute()
      return l[1] == "/"
   end

   public absolute()
      if is_absolute() then
         return self
      return Files.get_path(chdir()).append(self)
   end

   public canonical()
      local e, r
      r := []
      every e := !absolute().l do {
         if e == "." then
            next
         else if e == ".." then {
            # /.. -> /
            if r[-1] ~== "/" then
               pull(r)
         } else
            put(r, e)
      }
      return UnixFilePath(r)
   end
end

class UnixFileSystem(FileSystem)
   public get_path(s)
      local l, t
      l := []
      s ? {
         put(l, ="/")
         while not pos(0) do {
            t := tab(upto('/') | 0)
            if *t > 0 then
               put(l, t)
            move(1)
         }
      }
      return UnixFilePath(l)
   end

   public get_path_from_list(l)
      return UnixFilePath(l)
   end

   public get_home()
      return getenv("HOME")
   end

   public get_temp()
      return getenv("TEMP") | "/tmp"
   end

   public is_hidden(s)
      return any('.', s)
   end

   public is_relative_dir(s)
      return s == ("." | "..")
   end

   public get_roots()
      return "/"
   end

   public split_paths(s)
      local t
      s ? repeat {
         t := tab(upto(':') | 0)
         if *t = 0 then
            t := "."
         suspend t
         if pos(0) then
            break
         move(1)
      }
   end
end

class WindowsFilePath(FilePath)
   public str()
      local e, s
      s := ""
      every e := !l do {
         if *s > 0 & not any("\\:", s[-1]) then
            s ||:= "\\"
         s ||:= e
      }
      return s
   end

   public is_absolute()
      return l[1] == "\\\\" | l[1][2:0] == ":\\"
   end

   public absolute()
      local s
      if is_absolute() then
         return self
      if l[1] == "\\" then
         return WindowsFilePath([chdir()[1:4]] ||| l[2:0])
      if l[1][2:0] == ":" then {
         s := getdcwd(l[1][1]) | l[1] || "\\"
         return Files.get_path(s).append(WindowsFilePath(l[2:0]))
      }
      return Files.get_path(chdir()).append(self)
   end

   private static defer getdcwd(d)

   public canonical()
      local e, r
      r := []
      every e := !absolute().l do {
         if e == "." then
            next
         else if e == ".." then
            pull(r)
         else
            put(r, map(e))
      }
      return WindowsFilePath(r)
   end
end

class WindowsFileSystem(FileSystem)
   public get_path(s)
      local l, t
      l := []
      s := map(s, "/", "\\")
      s ? {
         if &subject[2:4] == ":\\" then       # X:\
            put(l, move(3))
         else if &subject[2] == ":" then      # X:
            put(l, move(2))
         else if &subject[1:3] == "\\\\" then # \\X
            put(l, move(2))
         else if &subject[1] == "\\" then     # \X
            put(l, move(1))                
         while not pos(0) do {
            t := tab(upto('\\') | 0)
            if *t > 0 then
               put(l, t)
            move(1)
         }
      }
      return WindowsFilePath(l)
   end

   public get_path_from_list(l)
      return WindowsFilePath(l)
   end

   public get_home()
      return getenv("HOME")
   end

   public get_temp()
      return getenv("TEMP") | "C:\\TEMP"
   end

   public is_hidden(s)
   end

   public is_relative_dir(s)
      return s == ("." | "..")
   end

   public defer get_roots()

   public split_paths(s)
      local t
      s ? repeat {
         t := tab(upto(';') | 0)
         if *t = 0 then
            t := "."
         suspend t
         if pos(0) then
            break
         move(1)
      }
   end
end
