package util

import lang(Class)

#
# Succeed iff the sequence generated by {&features} contains the given
# string.
#
procedure has_feature(x)
   static s
   initial {
      s := set()
      every insert(s, &features)
   }
   return member(s, x)
end

#
# Convenient procedure to set {&why} to the given string and fail.
#
procedure error(s)
   &why := s
end

# This class just provides a simple constructor which initializes the
# instance fields in the order they were defined in the class, from
# the given parameters.  In other words, rather like a record
# constructor.  The fields in the subclass must of course be
# accessible to this class's constructor.
#
# @example
# @  class Abc(SimpleConstructor) public const a, b, c end
# @  ...
# @  x := Abc(1,2,3)  # Sets a,b,c to 1,2,3 respectively
#  
class SimpleConstructor()
   public new(a[])
      every Class.get(self, 1 to Class.get_n_instance_fields(self)) := pop(a)
      return
   end
end

# Invoke co-expression e, generating its results, saving the value of
# {var} before, and restoring it after each result.  This is
# potentially useful when using co-operating scheduled tasks (see
# {io.Task}).
#
# @example
# @ save_var{task.sleep(1000), exception.throw_handler}
#
procedure save_var(e, var)
   local t
   t := !var
   repeat {
      suspend 1(@e, !var :=: t) do {
         !var :=: t
         break next
      }
      !var := t
      fail
   }
end

# Like {save_var}, but saves the value of {&subject} and {&pos}
# instead.
#
procedure save_scan(e)
   local ss, sp, tp
   ss := &subject
   sp := &pos
   repeat {
      suspend 1(@e, tp := &pos, &subject :=: ss, &pos := sp, sp := tp) do {
         tp := &pos
         &subject :=: ss
         &pos := sp
         sp := tp
         break next
      }
      &subject := ss
      &pos := sp
      fail
   }
end
