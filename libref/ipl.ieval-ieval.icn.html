<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>ieval.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># Support procedures for ieval.
<a name="3"/>#
<a name="4"/>
<a name="5"/>package ipl.ieval
<a name="6"/>
<a name="7"/>import io, gui-(List), lang, xdg, ipl.columnize, parser(Parser,Token), eval, util,
<a name="8"/>   ipl.pdco, ipl.sort, ipl.termdialog, ipl.lists, ipl.scan, net, ipl.printf
<a name="9"/>
<a name="10"/>$load IEVAL_LOGO "rpp.IEVAL_LOGO.png"
<a name="11"/>
<a name="12"/>package record Activation(coex, info)
<a name="13"/>package record NamePair(long, short)
<a name="14"/>
<a name="15"/>class IevalTermDialog(TermDialog, MinimalObjectOutput)
<a name="16"/>end
<a name="17"/>
<a name="18"/>class Ieval(MinimalObjectOutput)
<a name="19"/>   private
<a name="20"/>      input, output, error, quiet_flag,
<a name="21"/>      oos, trace_flag, parse_flag, last_runerr, hlim,
<a name="22"/>      elim, llim, history, is_flowterm
<a name="23"/>
<a name="24"/>   private const
<a name="25"/>       par, vars, ev, consts, imports, files, ee, opts
<a name="26"/>
<a name="27"/>   private show_env()
<a name="28"/>      local p
<a name="29"/>      every p := !sort(vars) do {
<a name="30"/>         output.writes(p[1], " = ")
<a name="31"/>         oos.show(p[2])
<a name="32"/>         output.write()
<a name="33"/>      }
<a name="34"/>   end
<a name="35"/>
<a name="36"/>   private show_help()
<a name="37"/>      output.
<a name="38"/>         write("!env         Show the values stored in the environment, excluding these predefined").
<a name="39"/>         write("             values").
<a name="40"/>         write("!help        Show help").
<a name="41"/>         write("!parse       Toggle parse mode, in which just the syntax structure of the command is").
<a name="42"/>         write("             printed").
<a name="43"/>         write("!trace       Toggle tracing").
<a name="44"/>         write("!wglob       Toggle the write-globals flag").
<a name="45"/>         write("!traceback   Show the traceback of the last command that gave a runtime error").
<a name="46"/>         write("!quiet       Don't force evaluation of all of the values in the expression, and don't").
<a name="47"/>         write("             output any expression value").
<a name="48"/>         write("dir(x,l)     With no parameter, show all global variables.  With a parameter, show").
<a name="49"/>         write("             information about it.  If l is non-null, show class field locations").
<a name="50"/>         write("!hist        Show the command line history").
<a name="51"/>         write("!cls         Clear the screen").
<a name="52"/>         write("old(s)       Search history for commands containing string s").
<a name="53"/>         write("hlim(n)      Set the history limit to n").
<a name="54"/>         write("elim(n)      Set the expression limit to n (min 10)").
<a name="55"/>         write("llim(n)      Set the gui log area line limit to n").
<a name="56"/>         write("load(s,a[])  Load the given prog, and set its error handler.  Optional symbols in").
<a name="57"/>         write("             a[] are then loaded as variables, as in sym()").
<a name="58"/>         write("sym(p,a[])   Load symbols from prog p as variables").
<a name="59"/>         write("gg(s,p)      Get the given global from the the given prog (shorthand for").
<a name="60"/>         write("             Prog.get_global)").
<a name="61"/>         write("c3(c)        Show the C3 linearizaton algorithm for class c").
<a name="62"/>         write("oos          The ObjectOutputStream used to output results").
<a name="63"/>         write("out          The OutputStream of the terminal").
<a name="64"/>         write("vars         The environment (as shown by !env), as a table")
<a name="65"/>   end
<a name="66"/>
<a name="67"/>   private do_c3(c)
<a name="68"/>      linearize_c3(c, set(), table(), 0)
<a name="69"/>   end
<a name="70"/>
<a name="71"/>   private linearize_c3(c, seen, cache, depth)
<a name="72"/>      local t, e, v, sl, spc
<a name="73"/>      spc := repl(" ", depth * 3)
<a name="74"/>      output.writes(spc, "C3: ", text_link(Class.get_name(c)), "(", supers_string(c), ")")
<a name="75"/>      if v := member(cache, c) then {
<a name="76"/>         output.write()
<a name="77"/>         output.write(spc, "Result: ", *v, " classes (see above)")
<a name="78"/>         return v
<a name="79"/>      }
<a name="80"/>      if member(seen, c) then {
<a name="81"/>         error.write("Circular inheritance: " || Class.get_name(c))
<a name="82"/>         fail
<a name="83"/>      }
<a name="84"/>      sl := List{ Class.get_supers(c) }
<a name="85"/>      if *sl = 0 then {
<a name="86"/>         output.write(" = ", Class.get_name(c) )
<a name="87"/>         return [c]
<a name="88"/>      }
<a name="89"/>      output.write()
<a name="90"/>      insert(seen, c)
<a name="91"/>      t := []
<a name="92"/>      every e := !sl do
<a name="93"/>         put(t, copy(linearize_c3(e, seen, cache, depth + 1))) | fail
<a name="94"/>      delete(seen, c)
<a name="95"/>      put(t, sl)
<a name="96"/>      output.write(spc, "   Added: ", Class.get_name(c))
<a name="97"/>      v := push(merge_c3(t, depth + 1), c) | fail
<a name="98"/>      output.write(spc, "Result: ", *v, " classes")
<a name="99"/>      cache[c] := v
<a name="100"/>      return v
<a name="101"/>   end
<a name="102"/>
<a name="103"/>   private static in_tail(l, h)
<a name="104"/>      succeed keyof(!l, h) &gt; 1
<a name="105"/>   end
<a name="106"/>
<a name="107"/>   private merge1_c3(l, r, depth)
<a name="108"/>      local h, e
<a name="109"/>      every h := (!l)[1] do {
<a name="110"/>         unless in_tail(l, h) then {
<a name="111"/>            put(r, h)
<a name="112"/>            output.write(repl(" ", depth * 3), "Added: ", Class.get_name(h))
<a name="113"/>            # Pop h off any of the lists
<a name="114"/>            every e := !l do {
<a name="115"/>               if e[1] === h then
<a name="116"/>                  pop(e)
<a name="117"/>            }
<a name="118"/>            return
<a name="119"/>         }
<a name="120"/>      }
<a name="121"/>      error.write("Inheritance hierarchy cannot be linearized")
<a name="122"/>   end
<a name="123"/>
<a name="124"/>   private merge_c3(l, depth)
<a name="125"/>      local r
<a name="126"/>      r := []
<a name="127"/>      while !!l do
<a name="128"/>         merge1_c3(l, r, depth) | fail
<a name="129"/>      return r
<a name="130"/>   end
<a name="131"/>
<a name="132"/>   private get_screen_width()
<a name="133"/>      return if is(output, TermDialog) then
<a name="134"/>         output.get_term_width()
<a name="135"/>      else
<a name="136"/>         LineEditorStream.get_console_width() | 80
<a name="137"/>   end
<a name="138"/>
<a name="139"/>   private text_link2(l, i)
<a name="140"/>      return text_link(l[i])
<a name="141"/>   end
<a name="142"/>
<a name="143"/>   private output_columns(l)
<a name="144"/>      every output.write(columnize_gen(qsort(l, Text.consistent_compare), get_screen_width(),,, text_link2))
<a name="145"/>   end
<a name="146"/>
<a name="147"/>   private list_syms()
<a name="148"/>      local l, e
<a name="149"/>      l := []
<a name="150"/>      every e := get_accessible_global_names() do
<a name="151"/>         if e ? ((not upto('.')) | (=!imports &amp; ="." &amp; (not upto('.')))) then
<a name="152"/>            put(l, e)
<a name="153"/>      output_columns(l)
<a name="154"/>   end
<a name="155"/>
<a name="156"/>   private list_prog_syms(prog)
<a name="157"/>      output_columns(List{ get_accessible_global_names(prog) })
<a name="158"/>   end
<a name="159"/>
<a name="160"/>   private show_parse(x, level)
<a name="161"/>      /level := 0
<a name="162"/>      if is(x, Token) then
<a name="163"/>         output.write(repl("\t", level), x.s)
<a name="164"/>      else
<a name="165"/>         every show_parse(x.gen(), level + 1)
<a name="166"/>   end
<a name="167"/>
<a name="168"/>   private flags_string(f)
<a name="169"/>      local s
<a name="170"/>      s := ""
<a name="171"/>      if iand(f, Class.Method) ~= 0 then
<a name="172"/>         s ||:= "Method "
<a name="173"/>      if iand(f, Class.Private) ~= 0 then
<a name="174"/>         s ||:= "Private "
<a name="175"/>      if iand(f, Class.Public) ~= 0 then
<a name="176"/>         s ||:= "Public "
<a name="177"/>      if iand(f, Class.Protected) ~= 0 then
<a name="178"/>         s ||:= "Protected "
<a name="179"/>      if iand(f, Class.Package) ~= 0 then
<a name="180"/>         s ||:= "Package "
<a name="181"/>      if iand(f, Class.Static) ~= 0 then
<a name="182"/>         s ||:= "Static "
<a name="183"/>      if iand(f, Class.Const) ~= 0 then
<a name="184"/>         s ||:= "Const "
<a name="185"/>      if iand(f, Class.Readable) ~= 0 then
<a name="186"/>         s ||:= "Readable "
<a name="187"/>      if iand(f, Class.Optional) ~= 0 then
<a name="188"/>         s ||:= "Optional "
<a name="189"/>      if iand(f, Class.Abstract) ~= 0 then
<a name="190"/>         s ||:= "Abstract "
<a name="191"/>      if iand(f, Class.Native) ~= 0 then
<a name="192"/>         s ||:= "Native "
<a name="193"/>      if iand(f, Class.Final) ~= 0 then
<a name="194"/>         s ||:= "Final "
<a name="195"/>      if iand(f, Class.Override) ~= 0 then
<a name="196"/>         s ||:= "Override "
<a name="197"/>      if iand(f, Class.Special) ~= 0 then
<a name="198"/>         s ||:= "Special "
<a name="199"/>      if iand(f, Class.Removed) ~= 0 then
<a name="200"/>         s ||:= "Removed "
<a name="201"/>      s[-1] := ""
<a name="202"/>      return s
<a name="203"/>   end
<a name="204"/>
<a name="205"/>   private comma_string(e)
<a name="206"/>      return String(e, ", ")
<a name="207"/>   end
<a name="208"/>
<a name="209"/>   private supers_string(c)
<a name="210"/>      return comma_string{Class.get_name(Class.get_supers(c))} 
<a name="211"/>   end
<a name="212"/>
<a name="213"/>   private implements_string(c)
<a name="214"/>      return comma_string{text_link(Class.get_name(Class.get_implemented_classes(c)))}
<a name="215"/>   end
<a name="216"/>
<a name="217"/>   private fields_string(c)
<a name="218"/>      return comma_string{Constructor.get_field_names(c)}
<a name="219"/>   end
<a name="220"/>
<a name="221"/>   private text_link(s)
<a name="222"/>      return if /is_flowterm then s else 
<a name="223"/>         "\e[!\"text:" || URL.percent_encode(s, URL.PATH_CHAR) || "\"L" || s || "\e[!L" 
<a name="224"/>   end
<a name="225"/>
<a name="226"/>   private locn_string(l)
<a name="227"/>      local fp
<a name="228"/>      fp := FilePath(l.file)
<a name="229"/>      return if \is_flowterm &amp; fp.is_absolute() then
<a name="230"/>         Files.begin_link(l.file, l.line) || "line " || l.line || " in " || l.file || Files.end_link()
<a name="231"/>      else
<a name="232"/>         "line " || l.line || " in " || l.file
<a name="233"/>   end
<a name="234"/>
<a name="235"/>   private abbr_locn_string(l)
<a name="236"/>      local fp
<a name="237"/>      fp := FilePath(l.file)
<a name="238"/>      return if \is_flowterm &amp; fp.is_absolute() then
<a name="239"/>         Files.begin_link(l.file, l.line) || "line " || l.line || " in " || fp.get(-1) || Files.end_link()
<a name="240"/>      else
<a name="241"/>         "line " || l.line || " in " || fp.get(-1)
<a name="242"/>   end
<a name="243"/>
<a name="244"/>   private kind_string(f)
<a name="245"/>      return case f of {
<a name="246"/>         Proc.Procedure: "Procedure"
<a name="247"/>         Proc.Function: "Function"
<a name="248"/>         Proc.Keyword: "Keyword"
<a name="249"/>         Proc.Operator: "Operator"
<a name="250"/>         Proc.Internal: "Internal"
<a name="251"/>      }
<a name="252"/>   end
<a name="253"/>
<a name="254"/>   private var_string(f)
<a name="255"/>      return case f of {
<a name="256"/>         Proc.Argument: "Argument"
<a name="257"/>         Proc.Dynamic: "Dynamic"
<a name="258"/>         Proc.Static: "Static"
<a name="259"/>      }
<a name="260"/>   end
<a name="261"/>
<a name="262"/>   private args_string(f)
<a name="263"/>      local s
<a name="264"/>      s := Proc.get_n_arguments(f)
<a name="265"/>      if Proc.has_varargs(f) then
<a name="266"/>         s ||:= "[]"
<a name="267"/>      return s
<a name="268"/>   end
<a name="269"/>
<a name="270"/>   private print_table(t, links)
<a name="271"/>      local widths, col, row
<a name="272"/>      /links := set()
<a name="273"/>      widths := []
<a name="274"/>      every col := 1 to *t[1] - 1 do
<a name="275"/>         put(widths, MaxNN{ *(!t)[col] })
<a name="276"/>      every row := !t do {
<a name="277"/>         every col := 1 to *t[1] do {
<a name="278"/>            output.writes1(if member(links, col) then text_link(row[col]) else row[col])
<a name="279"/>            if col &lt; *t[1] then
<a name="280"/>               output.writes1(repl(" ", 4 + widths[col] - *row[col]))
<a name="281"/>         }
<a name="282"/>         output.write()
<a name="283"/>      }
<a name="284"/>   end
<a name="285"/>
<a name="286"/>   private dir(a[])
<a name="287"/>      local f, t, c, s
<a name="288"/>      if *a = 0 then
<a name="289"/>         list_syms()
<a name="290"/>      else case type(c := a[1]) of {
<a name="291"/>         "object"|"cast"|"class": {
<a name="292"/>            s := map(flags_string(Class.get_class_flags(c)))
<a name="293"/>            if *s &gt; 0 then
<a name="294"/>               output.writes(s, " ")
<a name="295"/>            output.write("class ", Class.get_name(c), "(", supers_string(c), ")")
<a name="296"/>            output.write("   at ", locn_string(Class.get_location(c))) 
<a name="297"/>            output.write("   implements ", implements_string(c))
<a name="298"/>            t := []
<a name="299"/>            every f := Class.get_field_names(c) do {
<a name="300"/>               put(t, [f, 
<a name="301"/>                       Class.get_name(Class.get_field_defining_class(c, f)), 
<a name="302"/>                       right(Class.get_field_index(c, f), *Class.get_n_fields(c)),
<a name="303"/>                       flags_string(Class.get_field_flags(c, f)) ])
<a name="304"/>               if \a[2] then
<a name="305"/>                  put(t[-1], abbr_locn_string(Class.get_field_location(c, f)))
<a name="306"/>            }
<a name="307"/>            t := qsort(t, index_cmp(1, Text.consistent_compare))
<a name="308"/>            print_table(t, set(1))
<a name="309"/>         }
<a name="310"/>         "procedure"|"methp": {
<a name="311"/>            output.write(map(kind_string(Proc.get_kind(c))), " ", Proc.get_name(c), "(", args_string(c), ")")
<a name="312"/>            output.write("   at ", locn_string(Proc.get_location(c))) 
<a name="313"/>            output.write("   method of ", text_link(Class.get_name(Proc.get_defining_class(c))))
<a name="314"/>            t := []
<a name="315"/>            every f := Proc.get_local_names(c) do
<a name="316"/>               put(t, [f,
<a name="317"/>                       var_string(Proc.get_local_kind(c, f))])
<a name="318"/>            print_table(t)
<a name="319"/>         }
<a name="320"/>         "record"|"constructor": {
<a name="321"/>            output.write("constructor ",
<a name="322"/>                         Constructor.get_name(c), "(", fields_string(c), ")")
<a name="323"/>            output.write("   at ", locn_string(Constructor.get_location(c))) 
<a name="324"/>         }
<a name="325"/>         "co-expression": {
<a name="326"/>            if Coexpression.is_main(c) then
<a name="327"/>               list_prog_syms(c)
<a name="328"/>            else {
<a name="329"/>               oos.show(c)
<a name="330"/>               output.write()
<a name="331"/>            }
<a name="332"/>         }
<a name="333"/>         default: {
<a name="334"/>            oos.show(c)
<a name="335"/>            output.write()
<a name="336"/>         }
<a name="337"/>      }
<a name="338"/>   end
<a name="339"/>
<a name="340"/>   private cls()
<a name="341"/>      if is(output, DescStream) then
<a name="342"/>         output.writes1("\e[2J\e[H")
<a name="343"/>      else
<a name="344"/>         output.clear_text()
<a name="345"/>   end
<a name="346"/>
<a name="347"/>   private hist(s)
<a name="348"/>      local i, e
<a name="349"/>      /s := u""
<a name="350"/>      s := map(need_ucs(s))
<a name="351"/>      i := input.get_history_start_no()
<a name="352"/>      every e := !input.get_history() do {
<a name="353"/>         if find(s, map(e)) then
<a name="354"/>            output.write(right(i, 4), "  ", e)
<a name="355"/>         i +:= 1
<a name="356"/>      }
<a name="357"/>   end
<a name="358"/>
<a name="359"/>   private wglob()
<a name="360"/>      ee.set_write_globals(toggle_flag(ee.write_globals_flag))
<a name="361"/>      return ee.write_globals_flag
<a name="362"/>   end
<a name="363"/>
<a name="364"/>   private set_elim(n)
<a name="365"/>      elim := need_integer(\n, 10)
<a name="366"/>      return .elim
<a name="367"/>   end
<a name="368"/>
<a name="369"/>   private set_hlim(n)
<a name="370"/>      if hlim := need_integer(\n, 10) then
<a name="371"/>         input.set_history_limit(hlim)
<a name="372"/>      return .hlim
<a name="373"/>   end
<a name="374"/>
<a name="375"/>   private set_llim(n)
<a name="376"/>      if llim := need_integer(\n, 0) &amp; is(input, TermDialog) then
<a name="377"/>         input.set_log_limit(llim)
<a name="378"/>      return .llim
<a name="379"/>   end
<a name="380"/>
<a name="381"/>   # Check for an runtime error in the given prog (may be &amp;null), and
<a name="382"/>   # output any error to file f.  Succeeds in this case, fails
<a name="383"/>   # otherwise.
<a name="384"/>   private check_error(f, prog)
<a name="385"/>      local s, i
<a name="386"/>      if s := Prog.eval_keyword("&amp;errortext", prog) then {
<a name="387"/>         if i := Prog.eval_keyword("&amp;errornumber", prog) then
<a name="388"/>            f.write("Runtime error ", i, ": ", s)
<a name="389"/>         else
<a name="390"/>            f.write("Runtime error: ", s)
<a name="391"/>         f.write("Offending value: ", image(Prog.eval_keyword("&amp;errorvalue", prog)))
<a name="392"/>         last_runerr := Prog.eval_keyword("&amp;errorcoexpr", prog)
<a name="393"/>         errorclear(prog)
<a name="394"/>         return
<a name="395"/>      }
<a name="396"/>   end
<a name="397"/>
<a name="398"/>   private load_handler(prog)
<a name="399"/>      coact()
<a name="400"/>      repeat {
<a name="401"/>         check_error(error, prog)
<a name="402"/>         cofail(&amp;handler)
<a name="403"/>      }
<a name="404"/>   end
<a name="405"/>
<a name="406"/>   private load(s, a[])
<a name="407"/>      local p, e
<a name="408"/>      s := Files.find_exe(s) | return whyf("Command not found: %s", s)
<a name="409"/>      p := Prog.load(s,, 0, 0) | return whyf("Couldn't load %s: %w", s)
<a name="410"/>      e := create load_handler(p)
<a name="411"/>      @e
<a name="412"/>      Prog.eval_keyword("&amp;handler", p) := e
<a name="413"/>      sym!push(a, p)
<a name="414"/>      return p
<a name="415"/>   end
<a name="416"/>
<a name="417"/>   private sym(p, a[])
<a name="418"/>      local s, k, v
<a name="419"/>      every s := need_string(!a) do {
<a name="420"/>         if v := Prog.get_global(s, p) then {
<a name="421"/>            k := map(s, ".", "_")
<a name="422"/>            while Prog.get_global(k) do
<a name="423"/>               k ||:= "_"
<a name="424"/>            vars[k] := v
<a name="425"/>            output.write(k, " = ", image(v))
<a name="426"/>         } else
<a name="427"/>            error.write("Symbol ", s, " not found")
<a name="428"/>      }
<a name="429"/>   end
<a name="430"/>
<a name="431"/>   private traceback()
<a name="432"/>      local act_chain, depth, fe2, LIMIT, ae, fe, ce
<a name="433"/>      
<a name="434"/>      # Produce similar output to:-
<a name="435"/>      #    Coexpression.traceback(\last_runerr, &amp;yes)
<a name="436"/>
<a name="437"/>      ce := \last_runerr | fail
<a name="438"/>      act_chain := []
<a name="439"/>      until (!act_chain).coex === ce do {
<a name="440"/>         push(act_chain, Activation(ce, Coexpression.get_stack_info(ce)))
<a name="441"/>         ce := Coexpression.get_activator(ce) | break
<a name="442"/>      }
<a name="443"/>
<a name="444"/>      depth := 0
<a name="445"/>      every depth +:= *(!act_chain).info
<a name="446"/>
<a name="447"/>      LIMIT := 100
<a name="448"/>      output.write("Traceback:")
<a name="449"/>      every ae := !act_chain do {
<a name="450"/>         if depth - LIMIT &gt;= *ae.info then
<a name="451"/>            depth -:= *ae.info
<a name="452"/>         else {
<a name="453"/>            if ce := Coexpression.get_activator(ae.coex) then
<a name="454"/>               output.write("co-expression#", serial(ae.coex), " activated by co-expression#", serial(ce))
<a name="455"/>            else
<a name="456"/>               output.write("co-expression#", serial(ae.coex), "  (never activated)")
<a name="457"/>            if depth &gt; LIMIT then {
<a name="458"/>               if depth = LIMIT + 1 then
<a name="459"/>                  depth := LIMIT
<a name="460"/>               else
<a name="461"/>                  output.write("   ... ", depth - LIMIT, " calls omitted")
<a name="462"/>            }
<a name="463"/>            fe2 := &amp;null
<a name="464"/>            every fe := back(ae.info) do {
<a name="465"/>               if depth &lt;= LIMIT then {
<a name="466"/>                  output.writes("   ", fe.proc, "(", list2str(fe.args), ")")
<a name="467"/>                  if \fe2 then
<a name="468"/>                     output.write(" from ", abbr_locn_string(fe2))
<a name="469"/>                   else
<a name="470"/>                     output.write()
<a name="471"/>               }
<a name="472"/>               depth -:= 1
<a name="473"/>               fe2 := fe
<a name="474"/>            }
<a name="475"/>            if \fe2 then
<a name="476"/>               output.write("   at ", abbr_locn_string(fe2))
<a name="477"/>         }
<a name="478"/>      }
<a name="479"/>   end
<a name="480"/>
<a name="481"/>   public new(imports, files, opts)
<a name="482"/>      self.imports := imports
<a name="483"/>      self.files := files
<a name="484"/>      self.opts := opts
<a name="485"/>      par := Parser()
<a name="486"/>      vars := table()
<a name="487"/>      consts := table()
<a name="488"/>      ee := DefaultEvaluatorEnv(vars, consts)
<a name="489"/>      if \opts["wglob"] then
<a name="490"/>         ee.set_write_globals(&amp;yes)
<a name="491"/>      ev := Evaluator().
<a name="492"/>         set_env(ee).
<a name="493"/>         set_imports(imports)
<a name="494"/>      hlim := \opts["hlim"] | 500
<a name="495"/>      llim := \opts["llim"] | 600
<a name="496"/>      elim := \opts["elim"] | 35
<a name="497"/>      return
<a name="498"/>   end
<a name="499"/>
<a name="500"/>   public run()
<a name="501"/>      local hfile
<a name="502"/>      is_flowterm := Yes{ \opts["g"] | FileStream.stdout.is_flowterm_tty() }
<a name="503"/>      if \opts["z"] then
<a name="504"/>         do_nothing()
<a name="505"/>      else {
<a name="506"/>         hfile := FilePath(BaseDir.ensure_data_home()).child("ieval").str() | stopf("Couldn't access data dir: %w")
<a name="507"/>         history := decode_from_file(hfile) | []
<a name="508"/>         if \opts["g"] then
<a name="509"/>            do_gui()
<a name="510"/>         else
<a name="511"/>            do_line_editor()
<a name="512"/>         encode_to_file(hfile, input.get_history()) | stopf("Couldn't encode to history file %s: %w", hfile)
<a name="513"/>         write("Ciao")
<a name="514"/>      }
<a name="515"/>   end
<a name="516"/>
<a name="517"/>   private prelim()
<a name="518"/>      local f, s, n
<a name="519"/>      consts["env"] := create show_env()
<a name="520"/>      consts["help"] := create show_help()
<a name="521"/>      consts["trace"] := create trace_flag := toggle_flag(trace_flag)
<a name="522"/>      consts["parse"] := create parse_flag := toggle_flag(parse_flag)
<a name="523"/>      consts["quiet"] := create quiet_flag := toggle_flag(quiet_flag)
<a name="524"/>      consts["wglob"] := create wglob()
<a name="525"/>      consts["dir"] := dir
<a name="526"/>      consts["sym"] := sym
<a name="527"/>      consts["hist"] := create hist()
<a name="528"/>      consts["cls"] := create cls()
<a name="529"/>      consts["old"] := hist
<a name="530"/>      consts["elim"] := set_elim
<a name="531"/>      consts["hlim"] := set_hlim
<a name="532"/>      consts["llim"] := set_llim
<a name="533"/>      consts["c3"] := do_c3
<a name="534"/>      consts["load"] := load
<a name="535"/>      consts["gg"] := Prog.get_global
<a name="536"/>      consts["traceback"] := create traceback()
<a name="537"/>      consts["oos"] := oos := ObjectOutputStream(output).set_indent(3)
<a name="538"/>      consts["out"] := output
<a name="539"/>      consts["vars"] := vars
<a name="540"/>
<a name="541"/>      f := FilePath(BaseDir.ensure_config_home()).child("ieval").str() | stopf("Couldn't access config dir: %w")
<a name="542"/>      if Files.access(f) then
<a name="543"/>         push(files, f)
<a name="544"/>      every f := !files do {
<a name="545"/>         s := Files.file_to_string(f) | stopf("Couldn't load %s: %w", f)
<a name="546"/>         n := par.parse_expression(s) | stopf("Couldn't parse %s: %w", f)
<a name="547"/>         ev.set_node(n) | stopf("Couldn't parse %s: %w", f) 
<a name="548"/>         Safe{ev.eval()}
<a name="549"/>         if check_error(FileStream.stderr) then
<a name="550"/>            break
<a name="551"/>      }
<a name="552"/>
<a name="553"/>      # History is set here (rather than when input is created), so
<a name="554"/>      # that history is not truncated to the default length (hlim may
<a name="555"/>      # be set in the initialization files).
<a name="556"/>      (\input).set_history(history)
<a name="557"/>   end
<a name="558"/>
<a name="559"/>   private body(s)
<a name="560"/>      local n, i, v, run
<a name="561"/>
<a name="562"/>      run := create save_state(create ev.eval(), 
<a name="563"/>                               States(TraceState(if /trace_flag then 0 else -1), HandlerState(&amp;current)))
<a name="564"/>      if n := par.parse_expression(s, "UTF-8") then {
<a name="565"/>         if \parse_flag &amp; s ~== "!parse" then
<a name="566"/>            show_parse(n)
<a name="567"/>         else {
<a name="568"/>            if ev.set_node(n) then {
<a name="569"/>               if \quiet_flag then
<a name="570"/>                  !run
<a name="571"/>               else {
<a name="572"/>                  i := elim
<a name="573"/>                  every v := !run do {
<a name="574"/>                     i -:= 1
<a name="575"/>                     if i &lt; 0 then {
<a name="576"/>                        output.write(".... (result sequence truncated)")
<a name="577"/>                        break
<a name="578"/>                     }
<a name="579"/>                     # Handle the possibility that v's object_output may give a runerr.
<a name="580"/>                     Safe{ oos.show(v) }
<a name="581"/>                     if &amp;errortext then
<a name="582"/>                        break
<a name="583"/>                     output.write()
<a name="584"/>                  }
<a name="585"/>               }
<a name="586"/>               check_error(error)
<a name="587"/>            } else
<a name="588"/>               error.write("Couldn't parse: ", &amp;why)
<a name="589"/>         }
<a name="590"/>      } else
<a name="591"/>         error.write("Couldn't parse: ", &amp;why)
<a name="592"/>   end
<a name="593"/>
<a name="594"/>   private static complete_keyword(p, subj, pos)
<a name="595"/>      local l, e
<a name="596"/>      l := []
<a name="597"/>      every e := Proc.get_name(Prog.get_keywords()) do {
<a name="598"/>         if match(p, e) then
<a name="599"/>            put(l, simple_insert(e, p, subj, pos))
<a name="600"/>      }
<a name="601"/>      return l
<a name="602"/>   end
<a name="603"/>
<a name="604"/>   private static simple_insert(e, p, subj, pos)
<a name="605"/>      return CompleteElement(e, subj[1:pos - *p] || e || subj[pos:0], pos - *p + *e)
<a name="606"/>   end
<a name="607"/>
<a name="608"/>   private lookup_global(p)
<a name="609"/>      return Safe1{ ee.get(string(p), ev) }
<a name="610"/>   end
<a name="611"/>
<a name="612"/>   private static get_accessible_global_names(P)
<a name="613"/>      local n, i
<a name="614"/>      every n := 1 to Prog.get_n_globals(P) do {
<a name="615"/>         i := Prog.get_global_flags(n, P)
<a name="616"/>         if iand(i, Prog.Package) = 0 |
<a name="617"/>            iand(i, Prog.Readable) ~= 0
<a name="618"/>         then
<a name="619"/>            suspend Prog.get_global_name(n, P)
<a name="620"/>      }
<a name="621"/>   end
<a name="622"/>
<a name="623"/>   private gen_package_global_names(h)
<a name="624"/>      local e
<a name="625"/>      if h == "default" then {
<a name="626"/>         every e := get_accessible_global_names() do
<a name="627"/>            upto('.', e) | suspend "default." || e
<a name="628"/>         suspend "default." || key(consts | vars)
<a name="629"/>      } else if member(imports, string(h)) then {
<a name="630"/>         every e := get_accessible_global_names() do
<a name="631"/>            e ? if =h &amp; ="." &amp; (not upto('.')) then
<a name="632"/>               suspend e
<a name="633"/>      }
<a name="634"/>   end
<a name="635"/>
<a name="636"/>   private dot_candidates(h)
<a name="637"/>      local v, f, i
<a name="638"/>      suspend !imports || "." | gen_package_global_names(h)
<a name="639"/>      if v := lookup_global(h) then {
<a name="640"/>         case type(v) of {
<a name="641"/>            "class": {
<a name="642"/>               every f := Class.get_class_field_names(v) do {
<a name="643"/>                  i := Class.get_field_flags(v, f)
<a name="644"/>                  if iand(i, Class.Static) ~= 0 &amp; 
<a name="645"/>                     iand(i, Class.Public + Class.Readable) ~= 0
<a name="646"/>                  then
<a name="647"/>                     suspend h || "." || f
<a name="648"/>               }
<a name="649"/>            }
<a name="650"/>            "object": {  
<a name="651"/>               every f := Class.get_field_names(v) do {
<a name="652"/>                  i := Class.get_field_flags(v, f)
<a name="653"/>                  # Test for Special to exclude new()
<a name="654"/>                  if iand(i, Class.Static + Class.Special) = 0 &amp;
<a name="655"/>                     iand(i, Class.Public + Class.Readable) ~= 0
<a name="656"/>                  then
<a name="657"/>                     suspend h || "." || f
<a name="658"/>               }
<a name="659"/>            }
<a name="660"/>            "record": 
<a name="661"/>               suspend h || "." || Constructor.get_field_names(v)
<a name="662"/>         }
<a name="663"/>      }
<a name="664"/>   end
<a name="665"/>
<a name="666"/>   private complete_ident_dot(p, h, t, subj, pos)
<a name="667"/>      local c
<a name="668"/>      every c := dot_candidates(h) do
<a name="669"/>         if match(p, c) then
<a name="670"/>            suspend simple_insert(c, p, subj, pos)
<a name="671"/>   end
<a name="672"/>
<a name="673"/>   private complete_ident_no_dot(p, subj, pos)
<a name="674"/>      local e, l, t, v
<a name="675"/>
<a name="676"/>      l := []
<a name="677"/>      every e := !imports || "." | "default." do
<a name="678"/>         if match(p, e) then
<a name="679"/>            put(l, NamePair(e, e))
<a name="680"/>      every e := key(consts | vars) do
<a name="681"/>         if match(p, e) &amp; not Prog.get_global_name(e) then
<a name="682"/>            put(l, NamePair("default." || e, e))
<a name="683"/>      every e := Prog.get_global_names() do
<a name="684"/>         if not upto('.', e) &amp; match(p, e) then
<a name="685"/>            put(l, NamePair("default." || e, e))
<a name="686"/>      every e := get_accessible_global_names() do
<a name="687"/>         e ? if =!imports &amp; ="." &amp; (not upto('.')) &amp; match(p) then
<a name="688"/>            put(l, NamePair(e, tab(0)))
<a name="689"/>
<a name="690"/>      # Note any ambiguities
<a name="691"/>      t := table(0)
<a name="692"/>      every t[(!l).short] +:= 1
<a name="693"/>
<a name="694"/>      every e := !l do {
<a name="695"/>         v := if t[e.short] &gt; 1 then e.long else e.short
<a name="696"/>         suspend simple_insert(v, p, subj, pos)
<a name="697"/>      }
<a name="698"/>   end
<a name="699"/>
<a name="700"/>   private complete_ident(p, subj, pos)
<a name="701"/>      local l, i
<a name="702"/>      l := []
<a name="703"/>      if i := backto('.', p) then
<a name="704"/>         every put(l, complete_ident_dot(p, p[1: i - 1], p[i:0], subj, pos))
<a name="705"/>      else
<a name="706"/>         every put(l, complete_ident_no_dot(p, subj, pos))
<a name="707"/>      return l
<a name="708"/>   end
<a name="709"/>
<a name="710"/>   private complete(subj, pos)
<a name="711"/>      local p, l
<a name="712"/>      subj ? {
<a name="713"/>         tab(pos)
<a name="714"/>         l := if p := tab(rev_many0(&amp;letters)) &amp; rev_any('&amp;') then
<a name="715"/>            complete_keyword(u"&amp;" || p, subj, pos)
<a name="716"/>         else if p := tab(rev_many(&amp;letters ++ &amp;digits ++ '_.')) &amp; any(&amp;letters ++ '_', p[1]) then
<a name="717"/>            complete_ident(p, subj, pos)
<a name="718"/>         else
<a name="719"/>            []
<a name="720"/>      }
<a name="721"/>      if *l = 1 &amp; l[1].str == subj then
<a name="722"/>         pop(l)
<a name="723"/>      return qsort(l, cmp_CompleteElement)
<a name="724"/>   end
<a name="725"/>
<a name="726"/>   private do_gui()
<a name="727"/>      local s, t, prompt
<a name="728"/>
<a name="729"/>      input := IevalTermDialog().
<a name="730"/>         set_complete_function(complete).
<a name="731"/>         set_label("ieval").
<a name="732"/>         set_icon(IEVAL_LOGO).
<a name="733"/>         set_history_limit(hlim).
<a name="734"/>         set_log_limit(llim)
<a name="735"/>
<a name="736"/>      if \opts["a"] then
<a name="737"/>         input.set_popup_on_tab(&amp;no)
<a name="738"/>
<a name="739"/>      error := output := input
<a name="740"/>      s := ""
<a name="741"/>      prompt := "&gt; "
<a name="742"/>      input.connect(create {
<a name="743"/>         t := string(input.line)
<a name="744"/>         output.write(prompt, t)
<a name="745"/>         s ||:= t
<a name="746"/>         if s[-1] == "\\" then {
<a name="747"/>            s[-1] := ""
<a name="748"/>            prompt := "&gt;&gt; "
<a name="749"/>         } else {
<a name="750"/>            body(s)
<a name="751"/>            prompt := "&gt; "
<a name="752"/>            s := ""
<a name="753"/>         }
<a name="754"/>      }, Event.ACTION)
<a name="755"/>      # Do prelim() after showing the TermDialog, since output to
<a name="756"/>      # it will be discarded before it is live.
<a name="757"/>      input.show()
<a name="758"/>      prelim()
<a name="759"/>      Dispatcher.message_loop(input)
<a name="760"/>   end
<a name="761"/>
<a name="762"/>   private do_nothing()
<a name="763"/>      output := FileStream.stdout
<a name="764"/>      error := FileStream.stderr
<a name="765"/>      prelim()
<a name="766"/>   end
<a name="767"/>
<a name="768"/>   private do_line_editor()
<a name="769"/>      local s, t, prompt
<a name="770"/>      input := LineEditorStream(opts["s"]).
<a name="771"/>         set_complete_function(complete).
<a name="772"/>         set_history_limit(hlim) | stopf("Failed to create LineEditorStream: %w")
<a name="773"/>
<a name="774"/>      do_nothing()
<a name="775"/>
<a name="776"/>      s := ""
<a name="777"/>      prompt := "&gt; "
<a name="778"/>      repeat {
<a name="779"/>         input.set_prompt(prompt)
<a name="780"/>         save_why{ t := input.read_line() | stopf("Failed to read input: %w") }
<a name="781"/>         if /t then break
<a name="782"/>         s ||:= t
<a name="783"/>         if s[-1] == "\\" then {
<a name="784"/>            s[-1] := ""
<a name="785"/>            prompt := "&gt;&gt; "
<a name="786"/>         } else {
<a name="787"/>            body(s)
<a name="788"/>            prompt := "&gt; "
<a name="789"/>            s := ""
<a name="790"/>         }
<a name="791"/>      }
<a name="792"/>   end
<a name="793"/>end
</pre></body></html>
