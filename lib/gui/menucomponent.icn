#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui
import util

#
# This is the superclass of all the objects that make up the
# menu system (other than the top level {Components} of course).
#
# It encapsulates the position and space of labels in the parent
# menu, as well as methods which allow this item to be a popup
# submenu. A submenu need not necessarily contain other
# {MenuComponent}s; see for example the {Palette} class.  A
# conventional submenu, which does contain children, is in the
# {Menu} class.
#
# @field tooltip=val: see {set_tooltip}
# @field accel=string : see {set_accel}
# @field border={ABorder} : see {set_border}
# @field is_shaded=flag : see {set_is_shaded}
# @field is_decorative=flag : see {set_is_decorative}
#
class MenuComponent(Rect,SetFields,Connectable)
   public 
      label_x,                                
      label_y,                                
      label_w,  
      label_h,                                
      is_sub_menu_flag,                                
      is_decorative_flag,                                
      parent_component,                               
      is_shaded_flag,                                
      parent,                  
      tooltip,         
      accel,
      children,
      border,
      temp_win

   public initially()
      self.parent_component := (\parent).parent_component
      (\self.border).initially(self.parent_component)
      every (!self.children).initially()
   end

   public finally()
      (\self.border).finally()
      every (!self.children).finally()
      self.parent_component := &null
   end

   #
   # Add the given {MenuComponent} to the Menu.
   #
   # @param c   The {MenuComponent} to add.
   # @param i   The index to add at; if omitted then the new component
   # @          is appended to the end.
   #
   public add(c, i)
      /i := 0
      insert(self.children, i, c)
      c.set_parent(self)
   end

   #
   # Get the index of the given child component
   #
   public get_index(c)
      return keyof(self.children, c)
   end

   #
   # Remove the {MenuComponent} from the menu.
   # @param c   The {MenuComponent} to remove.
   #
   public remove(c)
      remove_index(get_index(c))
   end

   #
   # Remove the {MenuComponent} at the given index from the list of children.
   # @param i    The index
   #
   public remove_index(i)
      self.children[i].set_parent(&null)
      delete(self.children, i)
   end

   #
   # Succeed iff the component has been initialized with {init()}, but
   # not yet cleaned up with {finally()}.
   #
   public is_initialized()
      return \self.parent_component
   end

   public set_parent(x)
      return self.parent := x
   end

   #
   # Get the parent {MenuComponent}, or fail if there is none.
   #
   public get_parent()
      return \self.parent
   end

   #
   # Succeed iff the component is shaded
   #
   public is_shaded()
      return \self.is_shaded_flag
   end

   #
   # Succeed if the component is not shaded.
   #
   public is_unshaded()
      return /self.is_shaded_flag
   end

   #
   # Toggle whether or not the item is shaded.  If it is, it is
   # displayed in a filtered way and will not accept input.
   #
   public toggle_is_shaded()
      self.is_shaded_flag := toggle_flag(self.is_shaded_flag)
      possibly_invalidate()
   end

   #
   # Set the shaded status of the component.
   #
   public set_is_shaded(s)
      self.is_shaded_flag := check_flag(s)
      possibly_invalidate()
   end

   #
   # Invalidate the parent {Component} if this is the root of the menu hierarchy, or
   # the parent menu if it is open.
   #
   public possibly_invalidate()
      if /self.parent then
         (\self.parent_component).invalidate()
      else
         (\parent.temp_win).invalidate(get_label_rect())
   end

   #
   # The label's area as a {Rect}
   #
   public get_label_rect()
      return Rect(label_x, label_y, label_w, label_h)
   end

   #
   # Return the parent {Component}, for example a {MenuBar}.
   #
   public get_parent_component()
      return \self.parent_component
   end

   public set_parent_component(x)
      self.parent_component := x
   end

   public is_sub_menu()
      return \self.is_sub_menu_flag
   end

   public set_is_decorative(s)
      self.is_decorative_flag := check_flag(s)
   end

   public is_decorative()
      return \self.is_decorative_flag
   end

   public in_label_region(e)
      return (self.label_y <= e.y < self.label_y + self.label_h) & 
         (self.label_x <= e.x < self.label_x + self.label_w)
   end

   #
   # Set the tooltip.
   #
   public set_tooltip(x)
      self.tooltip := x
   end

   #
   # Return the tooltip, if any.
   #
   public get_tooltip()
      return \self.tooltip
   end

   #
   # Set the mnemonic key, which will be used with the Alt key to provide keyboard
   # shortcuts.
   #
   public set_accel(k)
      self.accel := k
   end

   #
   # Get the mnemonic key, if present, or fail otherwise.
   #
   public get_accel()
      return \self.accel
   end

   #
   # Invoked by the menu system to set the component's label position.
   #
   public set_label_pos(x, y)
      self.label_x := x
      self.label_y := y
   end

   #
   # Close the menu system.
   #
   public close_all()
      parent_component.close_all()
   end

   #
   # Called when the menu component is selected
   #
   public succeed(ev)
      close_all()
      fire(Event.ACTION, ev)
   end

   #
   # Abstract methods for the label sizes.
   #
   public defer get_label_left_width()
   public defer get_label_left_height()
   public defer get_label_mid_width()
   public defer get_label_mid_height()
   public defer get_label_right_width()
   public defer get_label_right_height()

   #
   # Abstract method for the display of the labels.
   #
   public defer draw_label(W, lw, mw, rw)

   #
   # The following methods are only called for a MenuComponent which pops up
   # a sub-menu, ie is_sub_menu_flag is non-null.
   #

   #
   # Deduce which child label is under pointer, if any, given we're in the region.
   #
   public which_item(e)
      local m
      every m := !self.children do {
         if /m.is_shaded_flag & /m.is_decorative_flag & m.in_label_region(e) then
            return m
      }
   end

   #
   # Invoked after the x,y co-ordinates are set, this method should be implemented
   # so that the submenu may initialize its size.  The method should leave the
   # instance variables w and h initialized.
   #
   public defer resize()

   #
   # Invoked by the parent menu when the right cursor key is pressed.
   #
   public cursor_on()
   end

   #
   # Display the submenu
   #
   public defer display(w, r)

   #
   # Handle the given event.
   #
   public defer handle_event(e)

   #
   # Is the cursor over us?
   # 
   public in_region(e)
      return temp_win.in_region(e)
   end

   #
   # Set the border to use - this relates to the popup submenu, 
   # not the label.
   #
   public set_border(b)
      (\self.border).finally()
      self.border := b
      if is_initialized() then {
         self.border.initially(self.parent_component)
      }
   end

   protected create_proxy()
      return SubMenuProxyComponent(self)
   end

   #
   # Display the submenu.
   #
   public show()
      /self.temp_win | fail

      #
      # Open a temporary area for the menu and copy.
      #
      self.temp_win := create_proxy()
      self.temp_win.set_pos(self.x, 
                            self.y)
      self.temp_win.set_size(self.w, self.h)
      self.temp_win.set_z(self.parent_component.parent_dialog.get_top_z())
      # Copy attribs of the parent component
      self.temp_win.set_all_wattribs(self.parent_component.get_effective_wattribs())
      self.parent_component.parent_dialog.add(self.temp_win)
      self.temp_win.initially()
      self.temp_win.resize()
      self.temp_win.invalidate()
   end

   #
   # Hide the submenu.
   #
   public hide()
      \self.temp_win | fail

      #
      # Restore window area.
      #
      self.temp_win.invalidate()
      self.parent_component.parent_dialog.remove(self.temp_win)
      self.temp_win.finally()
      self.temp_win := &null
   end

   #
   # Position the menu so that it is on-screen if possible.  The preferred
   # position is x, y.  If that is not possible, then xa, ya give
   # another position to try, but this time the values are right-adjusted.
   # These params default to the right and bottom of the screen respectively.
   #
   public position_nicely(x, y, xa, ya)
      local x1, y1, pw

      pw := self.parent_component.parent_dialog
      /xa := pw.w
      /ya := pw.h

      self.x := x
      self.y := y
      self.resize()

      x1 := y1 := &null
      if self.x + self.w > pw.w then
         x1 := 0 <= xa - self.w
      if self.y + self.h > pw.h then
         y1 := 0 <= ya - self.h

      if \x1 | \y1 then {
         /x1 := self.x
         /y1 := self.y
         self.x := x1
         self.y := y1
         self.resize()
      }
   end

   public set_one(f)
      case f.attr of {
         "tooltip" : set_tooltip(f.val)
         "accel" : set_accel(f.string_val())
         "border" : set_border(f.object_val(gui.ABorder))
         "is_shaded" :  set_is_shaded(f.flag_val())
         "is_decorative" :  set_is_decorative(f.flag_val())
         default : fail
      }
      return
   end

   public new(a[])
      cast(self,Connectable).new()
      self.children := []
      set_fields(a)
      return
   end
end


class SubMenuProxyComponent(Component)
   public menu

   public display(r)
      menu.display(self.cbwin, r)
   end

   public get_tooltip(e)
      local m
      every m := !menu.children do {
         if m.in_label_region(e) then
            return m.get_tooltip(e)
      }
   end

   public new(m)
      cast(self,Component).new()
      self.menu := m
      set_tooltip_follows_mouse(&yes)
      return
   end
end


