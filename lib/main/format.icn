#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package util

import lang, ipl.scan(max_many), io(RamStream)

final abstract class Format()
   public static const
      SIG_DIGITS,
      DECIMAL_POINT,
      THOUSANDS_SEPARATOR

   private static init()
      # Max number of significant digits output by numeric_to_string
      SIG_DIGITS := 14
      DECIMAL_POINT := env_string("OI_FORMAT_DECIMAL_POINT") | "."
      THOUSANDS_SEPARATOR := env_string("OI_FORMAT_THOUSANDS_SEPARATOR") | ","
   end
      
   #
   # Convert an integer to a string.
   #
   # :Parameters :
   # :  `base` - The desired base of the result.
   # :  `p` - The minimum width of the result, padding with zeroes
   #               if necessary.
   #
   public static int_to_string(subject, base, p)
      local s, n, digs, neg
      s := ""
      /base := 16
      base := need_integer(base, 2)
      /p := 1
      p := need_integer(p, 0)
      n := need_integer(subject)
      if n < 0 then {
         n := -n
         neg := 1
      }
      digs := "0123456789ABCDEF"[1:base + 1]
      while n > 0 do {
         s := digs[n % base + 1] || s
         n /:= base
      }

      if p > *s then
         s := repl("0", p - *s) || s

      if \neg then
         s := "-" || s

      return s
   end

   #
   # Convert a numeric to a string.
   #
   # :Parameters :
   # :  `p` - The number of decimal places to produce (default 4).
   # :  `f` -  A cset of flags.  If c contains `'e'` then the output is
   #           in scientific notation.  `'E'` is the same, but uses a
   #           a capital "E" in the result. If c contains `','` then commas
   #           are introduced into the non-fractional part of the number;
   #           if c contains `'+'` then a leading + is added to positive
   #           numbers.  If c contains `'s'` then trailing fractional
   #           zeroes are replaced with spaces, whilst `'z'` means drop
   #           such zeroes altogether.
   #
   public static numeric_to_string(subject, p, f)
      local n1, s, t, lim, d, zs, dig, i, n, ec

      /f := ''
      f := need_cset(f)
      n := need_numeric(subject)
      /p := 4
      p := need_integer(p, 0)

      n1 := abs(n)
      any(f, ec <- "e"|"E")
      if /ec & type(n1) == "integer" then 
         s := string(n1) || repl("0", p)
      else {
         t := norm(n1)
         lim := if \ec then p else p + t[2]
         if lim >= -1 then {
            s := ""
            d := t[1]
            if lim > SIG_DIGITS then {
               zs := repl("0", lim - SIG_DIGITS)
               lim := SIG_DIGITS
            }
            every 0 to lim do {
               s ||:= dig := integer(d)
               d := (d - dig) * 10.0
            }
            if integer(d) >= 5 then {
               (every i := *s to 1 by -1 do
                if s[i] := 10 > s[i] + 1 then break
                else s[i] := 0
                ) | {          # need to add 1 to left of s
                   s := "1" || s
                   if \ec then {
                      s[-1] := ""
                      t[2] +:= 1
                   }
                }
            }
            s ||:= \zs
            s := repl("0", 0 < p + 1 - *s) || s
         } 
         else s := repl("0", p + 1)
      }

      if any(f, ",") then
         every s[*s - p - 3 to 1 by -3] ||:= THOUSANDS_SEPARATOR

      if p > 0 then {
         s[-p - 1] ||:= DECIMAL_POINT
         if any(f, "s"| "z") then {
            "0" ~== s[i := *s to *s - p + 1 by -1]         
            s[i + 1 : 0] := if any(f, "s") then
               repl(" ", *s - i)
            else ""
         }
      }
      if n < 0 then
         s := "-" || s
      else
         if any(f, "+") then 
            s := "+" || s

      return if \ec then
         s || ec || (if t[2] < 0 then "-" else "+") || abs(t[2])
      else s   
   end

   private static norm(n)
      local m, e, ve, s
      static pwr
      initial pwr := [1e1, 1e2, 1e4, 1e8, 1e16, 1e32]

      # Do integers separately so that we don't have any problems with
      # large integers outside of the range of reals.
      #
      if type(n) == "integer" then {
         s := string(n)
         e := *s - 1
         s[1] ||:= "."
         return [real(s), e]
      }

      if n = 0.0 then
         return [0.0, 0]

      m := if n < 1.0 then 1.0 / n else n
      e := 0

      if not(pwr[1 + (ve := 1 to *pwr)] > m) then {
         while m /:= (m >= pwr[ve]) do
            e +:= 2 ^ (ve - 1)
         ve -:= 1
      }

      # invariant : 1 <= m < pwr[1 + ve] & m * 10 ^ e = m0 
      while m >= 10.0 do {
         if m /:= (m >= pwr[ve]) then
            e +:= 2 ^ (ve - 1)
         ve -:= 1
      }

      if n < 1.0 then {
         e := -e
         if m := 10.0 / (1.0 ~= m) then 
            e -:= 1
      }
      return [m, e]
   end

   private static unescape_char(ch)
      return case string(ch) of {
         "n": "\n"
         "l": "\l"
         "b": "\b"
         "d": "\d"
         "e": "\e"
         "r": "\r"
         "t": "\t"
         "v": "\v"
         "f": "\f"
         default:  ch
      }
   end

   #
   # Remove escape sequences from the subject.
   #
   public static unescape(subject)
      local res
      subject ? {
         # Shortcut for common case
         upto('\\') | return .&subject
         res := RamStream()
         repeat {
            res.out(tab(upto('\\') | 0))
            move(1) | break
            res.out((if any('01234567') then
                        char(iand("8r" || tab(max_many('01234567', 3)), 8r377))
                     else if ="x" then
                        char("16r" || tab(max_many(&digits ++ 'abcdefABCDEF', 2)))
                     else if ="u" then
                        Text.utf8_seq("16r" || tab(max_many(&digits ++ 'abcdefABCDEF', 4)))
                     else if ="U" then
                        Text.utf8_seq("16r" || tab(max_many(&digits ++ 'abcdefABCDEF', 6))) | {
                           res.close()
                           return error("Code point out of range")
                        }
                     else if ="^" then
                        char(iand(ord(move(1)), 8r37))
                     else 
                        unescape_char(move(1))) | "\0")
         }
         res := res.done()
         return if type(&subject) == "ucs" then ucs(res) | error("Invalid UTF-8 escape sequence") else res
      }
   end

   #
   # Remove escape sequences from the subject, but return the corresponding cset rather than
   # a string.
   #
   public static cset_unescape(subject)
      local l, state, c, prev, esc_flag
      state := 0
      l := []
      subject ? until pos(0) do {
         if any('\\') then {
            esc_flag := &yes
            move(1)
            c := (if any('01234567') then
                     iand("8r" || tab(max_many('01234567', 3)), 8r377)
                  else if ="x" then
                     integer("16r" || tab(max_many(&digits ++ 'abcdefABCDEF', 2)))
                  else if ="u" then
                     integer("16r" || tab(max_many(&digits ++ 'abcdefABCDEF', 4)))
                  else if ="U" then
                     (16r10FFFF >= integer("16r" || tab(max_many(&digits ++ 'abcdefABCDEF', 6)))) |
                        return error("Code point out of range")
                  else if ="^" then
                     iand(ord(move(1)), 8r37)
                  else 
                     ord(unescape_char(move(1)))) | 0
         } else {
            esc_flag := &no
            c := ord(move(1))
         }

         case state of {
            0: {
               prev := c
               state := 1
            }
            1 : {
               if /esc_flag & (c = 45) then
                  state := 2
               else {
                  put(l, prev)
                  put(l, prev)
                  prev := c
               }                     
            }
            2 : {
               put(l, prev)
               put(l, c)
               state := 0
            }
         }
      }
      if state = 1 then {
         put(l, prev)
         put(l, prev)
      }
      else if state = 2 then
         return error("Incomplete cset range");
      return Text.create_cset(l)
   end

   # Convert a string into shell format by escaping certain special
   # shell characters.
   #
   public static shell_escape(s)
      local t, ch
      t := ""
      s ? repeat {
         t ||:= tab(upto('\0-\x1f\x7f|\\*;?@+&#()<>~[]{}!$`\'\" ') | 0)
         ch := move(1) | break
         t ||:= case string(ch) of {
            "\x07": "$'\\a'"
            "\b" : "$'\\b'"
            "\e" : "$'\\e'"
            "\f" : "$'\\f'"
            "\n" : "$'\\n'"
            "\r" : "$'\\r'"
            "\t" : "$'\\t'"
            "\v" : "$'\\v'"
            !'\0-\x1f\x7f' : "$'\\x" || int_to_string(ord(ch),,2) || "'"
            default : "\\" || ch
         }
      }
      return t
   end

   #
   # Convert the subject integer into words, eg 231 to "Two Hundred and Thirty-One"
   #
   public static int_to_words(subject)
      local n, s, i, m
      static small, tens, pwr10, pwr10num

      initial {
         small := ["One", "Two", "Three", "Four", "Five", "Six",
                   "Seven", "Eight", "Nine", "Ten", "Eleven", 
                   "Twelve", "Thirteen", "Fourteen", "Fifteen",
                   "Sixteen", "Seventeen", "Eighteen", "Nineteen"]

         tens := ["Ten", "Twenty", "Thirty", "Forty", "Fifty", "Sixty",
                  "Seventy", "Eighty", "Ninety"]

         pwr10 := ["Million", "Thousand", "Hundred"]

         pwr10num := [1000000, 1000, 100]
      }

      n := need_integer(subject)

      s := ""

      every i := 1 to *pwr10num do
         if (m := n / pwr10num[i]) > 0 then {
            if *s > 0 then
               s ||:= " "

            s ||:= int_to_words(m) || " " || pwr10[i]

            n %:= pwr10num[i]
         }

      if n = 0 then {
         if *s = 0 then
            s := "Zero"
      } else {
         if *s > 0 then
            s ||:= " and "

         if n < 20 then
            s ||:= small[n]
         else {
            s ||:= tens[n / 10]
            if n % 10 > 0 then
               s ||:= "-" || small[n % 10]
         }
      }

      return s
   end
end
