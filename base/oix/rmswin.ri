/*
 * rmswin.ri - Microsoft Windows-specific graphics interface code.
 *
 */

#define FONTHASH_SIZE 64
#define CURSORHASH_SIZE 128

static struct SharedCursor *null_cursor;
static wcp alccontext(wbp w);
static void init_window_system(void);
static void setup_cursors(void);
static int inited;
static void open_screen_win(wsp ws);
static void close_screen_win(wsp ws);
static wfp fonts[FONTHASH_SIZE], default_font;
static struct wcursor *cursors[CURSORHASH_SIZE];
static wfp load_font(char *s);
static gb_Font *mkfont(char *s);
static HDC dummy_hdc;
static wsp wsp_for_hwnd(HWND hwnd);
static wcp clonecontext(wcp src);
static void freecontext(wcp wc);
static void freewindow(wsp ws);
static void resizepixmap(wbp w);
static struct imgdataformat imgdataformat_MSBGRA32;
static struct SharedColor *new_sharedcolor(char *name, int r, int g, int b, int a);
static struct SharedColor *link_sharedcolor(struct SharedColor *i);
static void unlink_sharedcolor(struct SharedColor *i);
static struct SharedBitmap *new_sharedbitmap(struct imgdata *imd);
static struct SharedBitmap *link_sharedbitmap(struct SharedBitmap *x);
static void unlink_sharedbitmap(struct SharedBitmap *x);
static struct SharedCursor *new_sharedcursor(HCURSOR cursor);
static struct SharedCursor *link_sharedcursor(struct SharedCursor *x);
static void unlink_sharedcursor(struct SharedCursor *x);
static struct wcursor *lookup_wcursor(char *name);
static struct wcursor *ensure_wcursor(char *name);
static void synch_cursor(wsp ws);
static gb_Bitmap *imgdata_to_bitmap(struct imgdata *imd);
static void bitmap_to_imgdata(gb_Bitmap *bm, struct imgdata *imd);
static wbp findwbp(wsp ws);
static void handle_paint(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse_enter(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse_leave(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse_move(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse_wheel(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse_up(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse_down(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_capture_changed(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_keypress(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_size(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_move(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_getminmaxinfo(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_showwindow(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void capture_mouse(wsp ws);
static void uncapture_mouse(wsp ws);
static void track_mouse(wsp ws);
static void apply_windowlabel(wsp ws);
static void mk_Draw(wbp w, gb_Draw *d);
static int get_outer_width(wsp ws);
static int get_outer_height(wsp ws);
static void synch_state(wsp ws, int new_state);
static void init_pos(wsp ws);

static void dbg(char *fmt, ...);

static int mouse_debug = 0;

static struct SharedColor *black, *white;

#begdef CheckUnhidden(ws)
do {
   if (!ws->win) {
      LitWhy("Window is hidden");
      return Failed;
   }
} while(0)
#enddef

/* List of windows with win non-null */
static wsp vwstates;

/* List of bindings */
static wbp wbndngs;

#define PALCLR(c) (c | 0x2000000L)

static int BORDER_HEIGHT;
static int BORDER_WIDTH;

/*
 * draw ops
 */
stringint drawops[] = {
    { 0, 2},
    {"over",  0},
    {"source",  1},
};

/*
 * line types
 */
stringint linestyles[] = {
    {0, 3},
    {"enddisc",      EndDisc},
    {"endsquare",    EndSquare},
    {"solid",        EndSquare},
};

#define NormalCanvas 1
#define HiddenCanvas 2
#define IconicCanvas 3
#define PopupCanvas  4
#define MaximizedCanvas  5
#define WithdrawnCanvas  6

static stringint canvastypes[] = {
    {0, 6},
    {"hidden",      HiddenCanvas},
    {"iconic",      IconicCanvas},
    {"maximized",   MaximizedCanvas},
    {"normal",      NormalCanvas},
    {"popup",       PopupCanvas},
    {"withdrawn",   WithdrawnCanvas},
};

#if 0
static void dump_all(void)
{
    int i,j,k;
    wsp x;
    wbp y;
    i = 0;
    for (y = wbndngs; y; y = y->next) {
        printf("Binding %p\n",y);
        printf("\tcanvas %p\n",y->window);
        printf("\tcontext %p\n",y->context);
        ++i;
    }
    printf("============\n");
    j = 0;
    for (x = wstates; x; x = x->next) {
        printf("Canvas %p\n",x);
        printf("\trefcount=%d\n", x->refcount);
        printf("\tlabel=%s\n", x->windowlabel);
        printf("\tgeometry=%d,%d %dx%d\n", x->x,x->y,x->width,x->height);
        printf("\twin=%d\n", (int)x->win);
        ++j; 
    }
    printf("============\n");
    k = 0;
    for (x = vwstates; x; x = x->vnext) {
        printf("Non-hidden Canvas %p\n",x);
        printf("\trefcount=%d\n", x->refcount);
        printf("\tlabel=%s\n", x->windowlabel);
        printf("\tgeometry=%d,%d %dx%d\n", x->x,x->y,x->width,x->height);
        printf("\twin=%d\n", (int)x->win);
        ++k; 
    }

    printf("Total %d bindings %d canvases (%d non-hidden)\n",i,j,k);
    fflush(stdout);
}
#endif

/*
 * allocate a window binding structure
 */
static wbp alcwbinding(void)
{
    wbp w;
    w = rt_zalloc(sizeof(struct _wbinding));
    GLink(w, wbndngs);
    return w;
}

/*
 * free a window binding.
 */
void freewbinding(wbp w)
{
    freewindow(w->window);
    freecontext(w->context);
    GUnlink(w, wbndngs);
    free(w);
}

wbp wopen(char *display)
{
    wbp w;
    wsp ws;

    if (!inited) {
        init_window_system();
        inited = 1;
    }

    /*
     * allocate a binding, a window state, and a context
     */
    w = alcwbinding();

    GAlloc(ws, _wstate);
    ws->listp = nulldesc;
    ws->windowlabel = defaultwindowlabel;
    add_gc_global(&ws->windowlabel);
    add_gc_global(&ws->listp);
    ws->cursor = lookup_wcursor("arrow");
    ws->minwidth = ws->minheight = 1;
    ws->maxwidth = ws->maxheight = INT_MAX;
    w->window = ws;
    ws = w->window;
    create_list(64, &ws->listp);
    ws->width = ws->height = 1;
    w->context = alccontext(w);
    ws->x = ws->y = -INT_MAX;
    ws->pix = gb_create_Bitmap(ws->width, ws->height, w->context->bg->color, 0);
    ws->pixwidth = ws->width;
    ws->pixheight = ws->height;
    ws->win = 0;
    return w;
}

static void mk_Draw(wbp w, gb_Draw *d)
{
    wsp ws = w->window;
    wcp wc = w->context;
    d->win = ws->win;
    d->pix = ws->pix;
    d->clipx = wc->clipx;
    d->clipy = wc->clipy;
    d->clipw = wc->clipw;
    d->cliph = wc->cliph;
    d->font = wc->font->font;
    d->fg = wc->fg->color;
    d->bg = wc->bg->color;
    d->linewidth = wc->linewidth;
    if (wc->pattern)
        d->pattern = wc->pattern->bitmap;
    else
        d->pattern = 0;
    d->drawop = wc->drawop->i;
    d->linestyle = wc->linestyle->i;
}

static void apply_windowlabel(wsp ws)
{
    WCHAR *mbs = ucs_to_wchars(&ws->windowlabel, 1);
    SetWindowTextW(ws->win, mbs);
    free(mbs);
}

static void handle_getminmaxinfo(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    MINMAXINFO *mmi = (MINMAXINFO *)lp;
    if (ws->resizable) {
        mmi->ptMinTrackSize.x = ws->minwidth + BORDER_WIDTH;
        mmi->ptMinTrackSize.y = ws->minheight + BORDER_HEIGHT;
        if (ws->maxwidth != INT_MAX)
            mmi->ptMaxTrackSize.x = ws->maxwidth + BORDER_WIDTH;
        if (ws->maxheight != INT_MAX)
            mmi->ptMaxTrackSize.y = ws->maxheight + BORDER_HEIGHT;
    } else {
        mmi->ptMinTrackSize.x = mmi->ptMaxTrackSize.x =
            ws->width + BORDER_WIDTH;
        mmi->ptMinTrackSize.y = mmi->ptMaxTrackSize.y =
            ws->height + BORDER_HEIGHT;
    }
}

static void handle_move(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    int newx, newy;
    /* x,y represents the position of the drawable area. Casting to
       INT16 ensures -ve values are handle correctly */
    newx = (INT16)LOWORD(lp);
    newy = (INT16)HIWORD(lp); 
    if ((newx != ws->x) || (newy != ws->y)) {
        ws->x = newx;
        ws->y = newy;
        qeventcode(ws, WINDOWMOVED);
    }
}

static void handle_size(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    int neww, newh;
    switch (wp) {
        case SIZE_MINIMIZED: {
            synch_state(ws, IconicCanvas);
            return;
        }
        case SIZE_MAXIMIZED: {
            synch_state(ws, MaximizedCanvas);
            break;
        }
        case SIZE_RESTORED: {
            synch_state(ws, NormalCanvas);
            break;
        }
    }

    neww = LOWORD(lp);
    newh = HIWORD(lp);

    if ((ws->width != neww) || (ws->height != newh)) {
        ws->width = neww;
        ws->height = newh;
        resizepixmap(findwbp(ws));
        qeventcode(ws, WINDOWRESIZED);
    }
}

static void handle_showwindow(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    if (wp == 0)
        synch_state(ws, WithdrawnCanvas);
    else if (ws->state != PopupCanvas)
        synch_state(ws, NormalCanvas);
}

static void synch_state(wsp ws, int new_state)
{
    if (ws->state != new_state) {
        ws->state = new_state;
        qeventcode(ws, WINDOWSTATE);
    }
}

static void handle_keypress(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    DWORD dw;
    int t, fl;
    POINT p;
    static struct descrip curr;
    static int inited = 0;

    if (msg == WM_KEYUP || msg == WM_SYSKEYUP) {
        if (!inited)
            return;
    } else if (msg == WM_CHAR || msg == WM_SYSCHAR) {
        StrLen(curr) = 1;
        StrLoc(curr) = &allchars[wp & 0xFF];
        inited = 1;
    } else { /* WM_KEYDOWN or WM_SYSKEYDOWN */
        if (wp == VK_DELETE) {
            StrLen(curr) = 1;
            StrLoc(curr) = &allchars[127];
        } else 
            MakeInt(wp, &curr);
        inited = 1;
    }

   /* Mouse location in SCREEN coordinates; convert to client */
    dw = GetMessagePos();
    p.x = (INT16)LOWORD(dw);
    p.y = (INT16)HIWORD(dw);
    ScreenToClient(ws->win, &p);

    t = GetMessageTime();

    fl = 0;
    if (GetKeyState(VK_CONTROL) < 0)
        fl |= MOD_CTRL;
    if (GetKeyState(VK_SHIFT) < 0)
        fl |= MOD_SHIFT;
    if (msg == WM_SYSKEYDOWN || msg == WM_SYSCHAR || msg == WM_SYSKEYUP)
        fl |= MOD_META;
    if (msg == WM_KEYUP || msg == WM_SYSKEYUP)
        fl |= MOD_RELEASE;
    qevent(ws, &curr, p.x, p.y, t, fl);
}

static void handle_mouse_wheel(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    int t;
    POINT p;
    int state = 0;
    int fl = 0;

    if (MK_LBUTTON & wp) state |= 1;
    if (MK_MBUTTON & wp) state |= 2;
    if (MK_RBUTTON & wp) state |= 4;

    /* Unlike normal mouse events, the co-ordinates are absolute, so
     * convert to client co-ordinates.
     */
    p.x = (INT16)LOWORD(lp);
    p.y = (INT16)HIWORD(lp);
    ScreenToClient(ws->win, &p);

    t = GetMessageTime();

    if (MK_CONTROL & wp)
        fl |= MOD_CTRL;
    if (MK_SHIFT & wp)
        fl |= MOD_SHIFT;

    /*
     * We only get one MS event for a wheel movement, so call
     * qmouseevents twice, once with the button 4 or 5 going down and
     * again with it coming up.  This generates one icon event, on the
     * second qmouseevents call.
     */
    if ((INT_PTR)wp > 0)
        qmouseevents(ws, state|8, p.x, p.y, t, fl);
    else
        qmouseevents(ws, state|16, p.x, p.y, t, fl);
    
    qmouseevents(ws, state, p.x, p.y, t, fl);
}

static void dbg(char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    fflush(stderr);
}

static void capture_mouse(wsp ws)
{
    if (mouse_debug) dbg("capture_mouse() grabbingmouse=%d\n", ws->grabbingmouse);
    if (ws->grabbingmouse == 0) {
        ws->savedgrab = SetCapture(ws->win);
        if (mouse_debug) dbg("SetCapture, saved grab=%x ourselves=%x\n",ws->savedgrab, ws->win);
    }
    ++ws->grabbingmouse;
    if (mouse_debug) dbg("now grabbingmouse=%d\n", ws->grabbingmouse);
}

static void uncapture_mouse(wsp ws)
{
    if (mouse_debug) dbg("uncapture_mouse() grabbingmouse=%d\n", ws->grabbingmouse);
    if (ws->grabbingmouse > 0) {
        --ws->grabbingmouse;
        if (ws->grabbingmouse == 0) {
            if (mouse_debug) dbg("SetCapture to %x\n",ws->savedgrab);
            /* This will in fact now call handle_capture_changed() */
            SetCapture(ws->savedgrab);
            ws->savedgrab = 0;
        }
    }
    if (mouse_debug) dbg("now grabbingmouse=%d\n", ws->grabbingmouse);
}

/*
 * This may be called either when we release in uncapture_mouse above,
 * or externally.  In either case, set the count and grab to zero.
 * Some calls to uncapture_mouse() may follow, and do nothing.
 */
static void handle_capture_changed(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    if (mouse_debug) dbg("handle_capture_changed(), resetting grabbingmouse to 0\n");
    ws->savedgrab = 0;
    ws->grabbingmouse = 0;
}

static void track_mouse(wsp ws)
{
    TRACKMOUSEEVENT tme;
    tme.cbSize = sizeof(TRACKMOUSEEVENT);
    tme.dwFlags = TME_LEAVE;
    tme.hwndTrack = ws->win;
    TrackMouseEvent(&tme);
    ws->trackingmouse = 1;
}

static void handle_mouse_leave(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    int t;
    struct descrip d;
    if (mouse_debug) dbg("handle_mouse_leave()\n");
    t = GetMessageTime();
    MakeInt(MOUSEEXITED, &d);
    qevent(ws, &d, 0, 0, t, 0);
    ws->trackingmouse = 0;
}

static void handle_mouse_enter(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    int t, x, y;
    struct descrip d;
    if (mouse_debug) dbg("handle_mouse_enter()\n");
    x = (INT16)LOWORD(lp);
    y = (INT16)HIWORD(lp);
    t = GetMessageTime();
    MakeInt(MOUSEENTERED, &d);
    qevent(ws, &d, x, y, t, 0);
}

static void handle_mouse_move(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    if (mouse_debug) dbg("handle_mouse_move()\n");
    if (!ws->trackingmouse) {
        handle_mouse_enter(ws, msg, wp, lp);
        track_mouse(ws);
    }
    synch_cursor(ws);
    handle_mouse(ws, msg, wp, lp);
}

static void handle_mouse_up(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    if (mouse_debug) dbg("handle_mouse_up()\n");
    uncapture_mouse(ws);
    synch_cursor(ws);
    handle_mouse(ws, msg, wp, lp);
}

static void handle_mouse_down(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    if (mouse_debug) dbg("handle_mouse_down()\n");
    capture_mouse(ws);
    synch_cursor(ws);
    handle_mouse(ws, msg, wp, lp);
}

static void handle_mouse(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    int t;
    int x, y;
    int state = 0;
    int fl = 0;

    if (MK_LBUTTON & wp) state |= 1;
    if (MK_MBUTTON & wp) state |= 2;
    if (MK_RBUTTON & wp) state |= 4;

    x = (INT16)LOWORD(lp);
    y = (INT16)HIWORD(lp);
    t = GetMessageTime();

    if (MK_CONTROL & wp)
        fl |= MOD_CTRL;
    if (MK_SHIFT & wp)
        fl |= MOD_SHIFT;

    qmouseevents(ws, state, x, y, t, fl);
}

static void handle_paint(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    gb_do_paint(ws->win, ws->pix);
}

LRESULT_CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    wsp ws;
    ws = wsp_for_hwnd(hwnd);
    if (ws) {
        switch(msg) {
            case WM_PAINT:
                handle_paint(ws, msg, wp, lp);
                return 0;
            case WM_MOUSEMOVE:
                handle_mouse_move(ws, msg, wp, lp);
                return 0;
            case WM_MOUSELEAVE:
                handle_mouse_leave(ws, msg, wp, lp);
                return 0;
            case WM_MOUSEWHEEL:
                handle_mouse_wheel(ws, msg, wp, lp);
                return 0;
            case WM_CAPTURECHANGED:
                handle_capture_changed(ws, msg, wp, lp);
                return 0;
            case WM_LBUTTONDOWN: 
            case WM_RBUTTONDOWN:
            case WM_MBUTTONDOWN:
                handle_mouse_down(ws, msg, wp, lp);
                return 0;
            case WM_LBUTTONUP:
            case WM_RBUTTONUP:
            case WM_MBUTTONUP:
                handle_mouse_up(ws, msg, wp, lp);
                return 0;
            case WM_KEYDOWN:
            case WM_SYSKEYDOWN:
            case WM_CHAR:
            case WM_SYSCHAR:
                handle_keypress(ws, msg, wp, lp);
                return 0;
            case WM_KEYUP:
            case WM_SYSKEYUP:
                if (ws->inputmask & IM_KEY_RELEASE)
                    handle_keypress(ws, msg, wp, lp);
                return 0;
            case WM_SIZE:
                handle_size(ws, msg, wp, lp);
                return 0;
            case WM_MOVE:
                handle_move(ws, msg, wp, lp);
                return 0;
            case WM_GETMINMAXINFO:
                handle_getminmaxinfo(ws, msg, wp, lp);
                return 0;
            case WM_SHOWWINDOW:
                handle_showwindow(ws, msg, wp, lp);
                return 0;
            case WM_CLOSE:
                qeventcode(ws, WINDOWCLOSED);
                return 0;
        }
    }
    return DefWindowProc(hwnd, msg, wp, lp);
}

void pollevent(wbp w)
{
    MSG m;
    /* some while PeekMessage loops here, maybe one per window ? */
    while (PeekMessage(&m, NULL, 0, 0, PM_NOREMOVE)) {
        if (GetMessage(&m, NULL, 0, 0) <= 0)
            return;
        TranslateMessage(&m);
        DispatchMessage(&m);
    }
}

int ownselection(wbp w, char *selection)
{
    wsp ws = w->window;
    tended struct descrip tmp;

    CheckUnhidden(ws);

    /* Ignore anything other than CLIPBOARD selections. */
    if (strcmp(selection, "CLIPBOARD") == 0) {
        MakeInt(SELECTIONREQUEST, &tmp);
        list_put(&ws->listp, &tmp);
        list_put(&ws->listp, &zerodesc);/* req id */
        LitStr("none", &tmp);           /* property */
        list_put(&ws->listp, &tmp);
        cstr2string(selection, &tmp);   /* selection */
        list_put(&ws->listp, &tmp);
        LitStr("UTF8_STRING", &tmp);    /* type */
        list_put(&ws->listp, &tmp);
        list_put(&ws->listp, &zerodesc); /* time */
    }
    return Succeeded;
}

int requestselection(wbp w, char *selection, char *target)
{
    wsp ws = w->window;
    tended struct descrip tmp, res;

    CheckUnhidden(ws);
    res = nulldesc;
    if (strcmp(selection, "CLIPBOARD") == 0 &&
        strcmp(target, "UTF8_STRING") == 0) {
        HANDLE hg;
        char *phg;
        if (!OpenClipboard(NULL)) {
            LitWhy("Failed to open windows clipboard");
            return Failed;
        }
        hg = GetClipboardData(CF_UNICODETEXT);
        if (hg) {
            phg = (char *)GlobalLock(hg);
            wchars_to_ucs((WCHAR *)phg, &res);
            GlobalUnlock(hg);
        }
        CloseClipboard();
    }

    MakeInt(SELECTIONRESPONSE, &tmp);
    list_put(&ws->listp, &tmp);
    cstr2string(selection, &tmp);   /* selection */
    list_put(&ws->listp, &tmp);
    cstr2string(target, &tmp);      /* target */
    list_put(&ws->listp, &tmp);
    list_put(&ws->listp, &res);

    return Succeeded;
}

int sendselectionresponse(wbp w, word requestor, char *property, 
                          char *selection, char *target, word time, dptr data)
{
    wsp ws = w->window;
    HGLOBAL hg;
    char *phg;
    SIZE_T nbytes;

    CheckUnhidden(ws);

    /* data is &null if the selection doesn't support what we asked for (UTF8_STRING) */
    if (is:null(*data))
        return Succeeded;

    if (!cnv:ucs(*data, *data))
        ReturnErrVal(128, *data, Error);

    if (!OpenClipboard(NULL)) {
        LitWhy("Failed to open windows clipboard");
        return Failed;
    }

    EmptyClipboard();
    nbytes = (UcsBlk(*data).length + 1) * sizeof(WCHAR);
    MemProtect(hg = GlobalAlloc(GMEM_DDESHARE, nbytes));
    phg = (char *)GlobalLock(hg);
    ucs_to_wchars1((WCHAR *)phg, data, 1);
    GlobalUnlock(hg);
    SetClipboardData(CF_UNICODETEXT, hg);
    CloseClipboard();
    return Succeeded;
}

static void close_screen_win(wsp ws)
{
    if (ws->win) {
        DestroyWindow(ws->win);
        ws->win = 0;
        ws->state = HiddenCanvas;
        GUnlink4(ws, vwstates, vnext, vprevious);
    }
}

static wsp wsp_for_hwnd(HWND hwnd)
{
    wsp ws;
    for (ws = vwstates; ws; ws = ws->vnext) {
        if (ws->win == hwnd) 
            return ws;
    }
    return 0;
}

static void init_pos(wsp ws)
{
    POINT p;
    p.x = p.y = 0;
    ClientToScreen(ws->win, &p);
    ws->x = p.x;
    ws->y = p.y;
}

static void open_screen_win(wsp ws)
{
    switch (ws->state) {
        case PopupCanvas: {
            ws->win = CreateWindowEx(WS_EX_TOPMOST | WS_EX_TOOLWINDOW,
                                     "oix", 
                                     NULL,
                                     WS_CHILD,
                                     ws->x == -INT_MAX ? 0 : ws->x, 
                                     ws->y == -INT_MAX ? 0 : ws->y,
                                     ws->width,
                                     ws->height,
                                     GetDesktopWindow(),
                                     NULL, NULL, NULL); 
            SetWindowPos(ws->win, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
            break;
        } 
        default: {
            HWND parent;
            if (ws->transientfor)
                parent = ws->transientfor->win;
            else
                parent = NULL;
            ws->win = CreateWindowEx(0,
                                     "oix", 
                                     NULL,
                                     WS_OVERLAPPEDWINDOW,
                                     ws->x == -INT_MAX ? CW_USEDEFAULT : ws->x, 
                                     ws->y == -INT_MAX ? CW_USEDEFAULT : ws->y,
                                     ws->width + BORDER_WIDTH,
                                     ws->height + BORDER_HEIGHT,
                                     parent,
                                     NULL, NULL, NULL);
            apply_windowlabel(ws);
        }
    }

    switch (ws->state) {
        case WithdrawnCanvas: {
            ShowWindow(ws->win, SW_HIDE);
            break;
        }
        case IconicCanvas: {
            ShowWindow(ws->win, SW_MINIMIZE);
            break;
        }
        case MaximizedCanvas: {
            ShowWindow(ws->win, SW_MAXIMIZE);
            break;
        }
        case NormalCanvas:
        case PopupCanvas: {
            ShowWindow(ws->win, SW_SHOWNORMAL);
            break;
        }
    }

    init_pos(ws);

    GLink4(ws, vwstates, vnext, vprevious);
}

int setcanvas(wbp w, char *s)
{
    wsp ws = w->window;
    HWND stdwin = ws->win;
    stringint *e;

    e = stringint_lookup(canvastypes, s);
    if (!e)
        return Failed;

    if (e->i == ws->state)
        return Succeeded;

    /*
     * If we're presently hidden, just open the visible window.
     */
    if (!ws->win) {
        if (e->i != HiddenCanvas) {
            ws->state = e->i;
            /* We should now get a WM_PAINT message which will copy
             * the pix to the new window. */
            open_screen_win(ws);
        }
        return Succeeded;
    }

    /*
     * More complex cases, with the window already unhidden.
     */
    switch (e->i) {
        case HiddenCanvas: {
            close_screen_win(ws);
            break;
        }
        case IconicCanvas: {
            if (ws->state == PopupCanvas)
                return Failed;
            ShowWindow(ws->win, SW_MINIMIZE);
            break;
        }
        case WithdrawnCanvas: {
            if (ws->state == PopupCanvas)
                return Failed;
            ShowWindow(ws->win, SW_HIDE);
            break;
        }
        case MaximizedCanvas: {
            if (ws->state == PopupCanvas)
                return Failed;
            ShowWindow(ws->win, SW_MAXIMIZE);
            break;
        }
        case NormalCanvas: {
            if (ws->state == PopupCanvas)
                return Failed;
            ShowWindow(ws->win, SW_SHOWNORMAL);
            break;
        }
        case PopupCanvas:
            return Failed;
    }
    return Succeeded;
}

int setwindowlabel(wbp w, dptr val)
{
    wsp ws = w->window;
    ws->windowlabel = *val;
    if (ws->win)
        apply_windowlabel(ws);
    return Succeeded;
}

static gb_Font *mkfont(char *s)
{
    int flags;
    double size;
    char family[MAXFONTWORD];
    if (!parsefont(s, family, &flags, &size))
        return 0;
    return gb_find_Font(family, flags, size);
}

static wfp load_font(char *s)
{
    wfp rv;
    int i;
    gb_Font *f;

    /*
     * See if the font is already loaded.
     */
    i = hasher(hashcstr(s), fonts);
    for(rv = fonts[i]; rv; rv = rv->next) {
        if (!strcmp(s, rv->name))
            return rv;
    }

    f = mkfont(s);
    if (!f)
        return 0;

    rv = rt_zalloc(sizeof(struct _wfont));
    rv->name = salloc(s);
    gb_get_metrics(dummy_hdc, f, &rv->ascent, &rv->descent, &rv->maxwidth);
    /*dbg("ascent=%d descent=%d maxwidth=%d\n", rv->ascent,rv->descent,rv->maxwidth);*/
    rv->font = f;
    rv->next = fonts[i];
    fonts[i] = rv;
    return rv;
}

/*
 * Set the window's font by name.
 */
int setfont(wbp w, char *s)
{
    wfp f = load_font(s);
    if (!f)
        return Failed;
    w->context->font = f;
    return Succeeded;
}

int lowerwindow(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    SetWindowPos(ws->win, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
    return Succeeded;
}

int raisewindow(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    SetWindowPos(ws->win, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
    return Succeeded;
}

int setlinestyle(wbp w, char *val)
{
    stringint *e;
    wcp wc = w->context;
    e = stringint_lookup(linestyles, val);
    if (!e)
        return Failed;
    wc->linestyle = e;
    return Succeeded;
}

int setlinewidth(wbp w, double linewid)
{
    wcp wc = w->context;
    wc->linewidth = linewid;
    return Succeeded;
}

double getlinewidth(wbp w)
{
    return w->context->linewidth;
}

int getdepth(wbp w, int *res)
{
    int i, j;
    i = GetDeviceCaps(dummy_hdc, BITSPIXEL);
    j = GetDeviceCaps(dummy_hdc, PLANES);
    *res = i * j;
    return Succeeded;
}

/*
 * Set the context's foreground color
 */
int setfg(wbp w, char *val)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(val, &r, &g, &b, &a))
        return Failed;
    unlink_sharedcolor(wc->fg);
    wc->fg = new_sharedcolor(val, r, g, b, a);
    return Succeeded;
}

char *getfg(wbp w)
{
    return w->context->fg->name;
}

/*
 * Set the window context's background color
 */
int setbg(wbp w, char *val)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(val, &r, &g, &b, &a))
        return Failed;
    unlink_sharedcolor(wc->bg);
    wc->bg = new_sharedcolor(val, r, g, b, a);
    return Succeeded;
}

char *getbg(wbp w)
{
    return w->context->bg->name;
}

int setpointer(wbp w, char *val)
{
    struct wcursor *c;
    wsp ws = w->window;
    c = lookup_wcursor(val);
    if (!c)
        return Failed;
    ws->cursor = c;
    return Succeeded;
}

int setdrawop(wbp w, char *val)
{
    wcp wc = w->context;
    stringint *e = stringint_lookup(drawops, val);
    if (!e)
        return Failed;
    wc->drawop = e;
    return Succeeded;
}

int getpattern(wbp w, struct imgdata *imd)
{
    wcp wc = w->context;
    if (!wc->pattern)
        return Failed;
    bitmap_to_imgdata(wc->pattern->bitmap, imd);
    return Succeeded;
}

char *getlinestyle(wbp w)
{
    return w->context->linestyle->s;
}

char *getpointer(wbp w)
{
    return w->window->cursor->name;
}

char *getdisplay(wbp w)
{
    return "MS Windows";
}

char *getdrawop(wbp w)
{
    return w->context->drawop->s;
}

char *getcanvas(wbp w)
{
    char *v = stringint_int2str(canvastypes, w->window->state);
    if (!v)
        syserr("Invalid value of state");
    return v;
}

/*
 * erase an area
 */
void erasearea(wbp w, int x, int y, int width, int height)
{
    gb_Draw d;
    mk_Draw(w, &d);
    gb_erasearea(&d, x, y, width, height);
}

/*
 * copy an area
 */
int copyarea(wbp w, int x, int y, int width, int height, wbp w2, int x2, int y2)
{
    gb_Draw d;
    mk_Draw(w2, &d);
    gb_copyarea(w->window->pix, x, y, width, height, &d, x2, y2);
    return Succeeded;
}

void captureimgdata(wbp w, int x, int y, struct imgdata *imd)
{
    wsp ws = w->window;
    int i, j;
    gb_Color *p;
    imd->data = rt_malloc(imd->width * imd->height * sizeof(gb_Color));
    p = (gb_Color *)imd->data;
    for(i = y; i < y + imd->height; i++)
        for(j = x; j < x + imd->width; j++)
            *p++ = gb_getpixel(ws->pix, j, i);
    imd->format = &imgdataformat_MSBGRA32;
}

void drawimgdata(wbp w, int x, int y, struct imgdata *imd)
{
    gb_Bitmap *bm;
    gb_Draw d;
    mk_Draw(w, &d);
    bm = imgdata_to_bitmap(imd);
    gb_draw_Bitmap(&d, x, y, bm);
    gb_free_Bitmap(bm);

}

struct imgdataformat *getimgdataformat(wbp w)
{
    return &imgdataformat_MSBGRA32;
}

int getdisplaysize(wbp w, int *width, int *height)
{
    *width = GetDeviceCaps(dummy_hdc, HORZRES);
    *height = GetDeviceCaps(dummy_hdc, VERTRES);
    return Succeeded;
}

int getdisplaysizemm(wbp w, int *width, int *height)
{
    *width = GetDeviceCaps(dummy_hdc, HORZSIZE);
    *height = GetDeviceCaps(dummy_hdc, VERTSIZE);
    return Succeeded;
}

int querypointer(wbp w, int *x, int *y)
{
    wsp ws = w->window;
    POINT p;
    CheckUnhidden(ws);
    GetCursorPos(&p);
    ScreenToClient(ws->win, &p);
    *x = p.x;
    *y = p.y;
    return Succeeded;
}

int queryrootpointer(wbp w, int *x, int *y)
{
    POINT p;
    GetCursorPos(&p);
    *x = p.x;
    *y = p.y;
    return Succeeded;
}

void drawlines(wbp w, struct point *points, int npoints)
{
    gb_Draw d;
    int x, y, width, height, adj;
    mk_Draw(w, &d);
    points_extent(points, npoints, &x, &y, &width, &height);
    adj = d.linewidth;
    gb_drawlines(&d, points, npoints, x - adj, y - adj, width + 2 * adj, height + 2 * adj);
}

void drawarc(wbp wb, double cx, double cy, double rx, double ry, double angle1, double angle2)
{
    gb_Draw d;
    mk_Draw(wb, &d);
    gb_drawarc(&d, cx, cy, rx, ry, angle1, angle2);
}

void fillarc(wbp wb, double cx, double cy, double rx, double ry, double angle1, double angle2)
{
    gb_Draw d;
    mk_Draw(wb, &d);
    gb_fillarc(&d, cx, cy, rx, ry, angle1, angle2);
}

void filltrapezoids(wbp w, struct trapezoid *traps, int ntraps)
{
    int i;
    for (i = 0; i < ntraps; ++i) {
        struct point p[4];
        p[0].x = traps[i].x1; p[0].y = traps[i].top;
        p[1].x = traps[i].x2; p[1].y = traps[i].top;
        p[2].x = traps[i].x4; p[2].y = traps[i].bottom;
        p[3].x = traps[i].x3; p[3].y = traps[i].bottom;
        fillpolygon(w, p, 4);
    }
}

void filltriangles(wbp w, struct triangle *tris, int ntris)
{
    int i;
    for (i = 0; i < ntris; ++i) {
        struct point p[3];
        p[0].x = tris[i].p1.x; p[0].y = tris[i].p1.y;
        p[1].x = tris[i].p2.x; p[1].y = tris[i].p2.y;
        p[2].x = tris[i].p3.x; p[2].y = tris[i].p3.y;
        fillpolygon(w, p, 3);
    }
}

void fillpolygon(wbp w, struct point *points, int npoints)
{
    gb_Draw d;
    int x, y, width, height, adj;
    mk_Draw(w, &d);
    points_extent(points, npoints, &x, &y, &width, &height);
    adj = 4;
    gb_fillpolygon(&d, points, npoints, x - adj, y - adj, width + 2 * adj, height + 2 * adj);
}

void fillrectangle(wbp wb, int x, int y, int width, int height)
{
    gb_Draw d;
    mk_Draw(wb, &d);
    gb_fillrectangle(&d, x, y, width, height);
}

void drawrectangle(wbp wb, int x, int y, int width, int height, int thick)
{
    gb_Draw d;
    mk_Draw(wb, &d);
    gb_drawrectangle(&d, x, y, width, height, thick);
}

static wcp alccontext(wbp w)
{
    wcp wc;
    GAlloc(wc, _wcontext);
    wc->fg = link_sharedcolor(black);
    wc->bg = link_sharedcolor(white);
    wc->drawop = stringint_lookup(drawops, "over");
    wc->linestyle = stringint_lookup(linestyles, "solid");
    wc->linewidth = 1.0;
    wc->font = default_font;
    wc->leading = defaultleading;
    wc->clipx = wc->clipy = 0;
    wc->clipw = wc->cliph = -1;
    return wc;
}

/*
 * allocate a context, cloning attributes from an existing context
 */
static wcp clonecontext(wcp src)
{
    wcp wc;

    GAlloc(wc, _wcontext);

    wc->clipx = src->clipx;
    wc->clipy = src->clipy;
    wc->clipw = src->clipw;
    wc->cliph = src->cliph;
    wc->dx = src->dx;
    wc->dy = src->dy;
    wc->fg = link_sharedcolor(src->fg);
    wc->bg = link_sharedcolor(src->bg);
    if (src->pattern)
        wc->pattern = link_sharedbitmap(src->pattern);
    wc->drawop = src->drawop;
    wc->linewidth = src->linewidth;
    wc->linestyle = src->linestyle;
    wc->font = src->font;
    return wc;
}

/*
 * free a window state
 */
static void freewindow(wsp ws)
{
    ws->refcount--;
    if(ws->refcount == 0) {
        close_screen_win(ws);
        gb_free_Bitmap(ws->pix);
        del_gc_global(&ws->listp);
        del_gc_global(&ws->windowlabel);
        if (ws->transientfor)
            freewindow(ws->transientfor);
        free(ws);
    }
}

/*
 * free a window context
 */
static void freecontext(wcp wc)
{
    wc->refcount--;
    if(wc->refcount == 0) {
        if (wc->pattern)
            unlink_sharedbitmap(wc->pattern);
        unlink_sharedcolor(wc->fg);
        unlink_sharedcolor(wc->bg);
        free(wc);
    }
}

int walert(wbp w, int volume)
{
    MessageBeep(0);
    return Succeeded;
}

int setpattern(wbp w, struct imgdata *imd)
{
    wcp wc = w->context;
    if (wc->pattern)
        unlink_sharedbitmap(wc->pattern);
    if (imd)
        wc->pattern = new_sharedbitmap(imd);
    else
        wc->pattern = 0;
    return Succeeded;
}

static int get_outer_width(wsp ws)
{
    if (ws->state == PopupCanvas)
        return ws->width;
    else
        return ws->width + BORDER_WIDTH;
}

static int get_outer_height(wsp ws)
{
    if (ws->state == PopupCanvas)
        return ws->height;
    else
        return ws->height + BORDER_HEIGHT;
}

void doconfig(wbp w, int status)
{
    wsp ws = w->window;
    wcp wc = w->context;
    if (status & (C_POS | C_SIZE | C_MINSIZE | C_MAXSIZE | C_RESIZE)) {
        if (ws->win) {
            switch (status & (C_POS|C_SIZE)) {
                case C_POS|C_SIZE: {
                    SetWindowPos(ws->win, ws->win, ws->x, ws->y,
                                 get_outer_width(ws), get_outer_height(ws),
                                 SWP_NOZORDER|SWP_NOACTIVATE);
                    break;
                }
                case C_SIZE: {
                    SetWindowPos(ws->win, ws->win, 0, 0,
                                 get_outer_width(ws), get_outer_height(ws),
                                 SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
                    break;
                }
                case C_POS: {
                    SetWindowPos(ws->win, ws->win,
                                 ws->x,
                                 ws->y,
                                 0, 0, SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
                    break;
                }
            }
        }
    }
    if (status & C_SIZE)
        resizepixmap(w);
}

int grabpointer(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    capture_mouse(ws);
    return Succeeded;
}

int ungrabpointer(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    uncapture_mouse(ws);
    return Succeeded;
}

static void resizepixmap(wbp w)
{
    gb_Bitmap *np;
    wsp ws = w->window;
    wcp wc = w->context;
    if (ws->pixwidth == ws->width && ws->pixheight == ws->height)
        return;
    ws->pixwidth = ws->width;
    ws->pixheight = ws->height;
    np = gb_create_Bitmap(ws->pixwidth, ws->pixheight, wc->bg->color, ws->pix);
    gb_free_Bitmap(ws->pix);
    ws->pix = np;
}

void ucs_to_wchars1(WCHAR *buff, dptr str, int nullterm)
{
    word len, i;
    char *p;
    len = UcsBlk(*str).length;
    p = StrLoc(UcsBlk(*str).utf8);
    for (i = 0; i < len; ++i) {
        int ch = utf8_iter(&p);
        buff[i] = (WCHAR)(ch < 0x10000 ? ch : 0xfffd);
    }
    if (nullterm)
        buff[len] = 0;
}

WCHAR *ucs_to_wchars(dptr str, int nullterm)
{
    WCHAR *mbs;
    /* +1 for null terminator */
    mbs = rt_malloc((UcsBlk(*str).length + 1) * sizeof(WCHAR));
    ucs_to_wchars1(mbs, str, nullterm);
    return mbs;
}

void string_to_wchars1(WCHAR *buff, dptr str, int nullterm)
{
    word len, i;
    char *p;
    len = StrLen(*str);
    p = StrLoc(*str);
    for (i = 0; i < len; ++i)
        buff[i] = (WCHAR)*p++;
    if (nullterm)
        buff[len] = 0;
}

WCHAR *string_to_wchars(dptr str, int nullterm)
{
    WCHAR *mbs;
    /* +1 for null terminator */
    mbs = rt_malloc((StrLen(*str) + 1) * sizeof(WCHAR));
    string_to_wchars1(mbs, str, nullterm);
    return mbs;
}

void wchars_to_ucs(WCHAR *src, dptr res)
{
    tended char *ts;
    tended struct b_ucs *bp;
    tended struct descrip utf8;
    word wlen, slen;
    WCHAR *p;
    char *q;

    wlen = 0;
    slen = 0;
    p = src;
    while (*p) {
        slen += utf8_seq(*p, 0);
        ++wlen;
        ++p;
    }

    /*dbg("We got %d unicode chars -> %d utf8 len\n", (int)wlen, (int)slen);*/
    MemProtect(ts = alcstr(0, slen));
    p = src;
    q = ts;
    while (*p) {
        int n = utf8_seq(*p, q);
        /*dbg("wrote char %d as %d bytes\n", (int)(*p), n);*/
        q += n;
        ++p;
    }

    MakeStr(ts, slen, &utf8);
    bp = make_ucs_block(&utf8, wlen);
    res->dword = D_Ucs;
    BlkLoc(*res) = (union block *)bp;
}

int textwidth(wbp w, dptr str)
{
    float f;
    WCHAR *mbs;
    word len;
    gb_Draw d;
    mk_Draw(w, &d);
    if (is:string(*str)) {
        mbs = string_to_wchars(str, 0);
        len = StrLen(*str);
    } else {
        mbs = ucs_to_wchars(str, 0);
        len = UcsBlk(*str).length;
    }
    f = gb_textwidth(&d, mbs, len);
    free(mbs);
    return (int)f;
}

void drawstring(wbp w, int x, int y, dptr str)
{
    wcp wc = w->context;
    WCHAR *mbs;
    word len;
    gb_Draw d;
    mk_Draw(w, &d);
    if (is:string(*str)) {
        mbs = string_to_wchars(str, 0);
        len = StrLen(*str);
    } else {
        mbs = ucs_to_wchars(str, 0);
        len = UcsBlk(*str).length;
    }
    gb_drawstring(&d, x, y, mbs, len);
    free(mbs);
}

int warppointer(wbp w, int x, int y)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    SetCursorPos(ws->x + x, ws->y + y);
    return Succeeded;
}

int readimagefileimpl(char *filename, struct imgdata *imd) 
{
    gb_Bitmap *bm;
    bm = gb_load_Bitmap(filename);
    if (!bm)
        return NoCvt;
    bitmap_to_imgdata(bm, imd);
    gb_free_Bitmap(bm);
    return Succeeded;
}

int writeimagefileimpl(char *filename, struct imgdata *imd)
{
    return NoCvt;
}

int readimagedataimpl(dptr data, struct imgdata *imd)
{
    int rv;
    char *fn;
    if (!(is_png(data) || is_jpeg(data)))
        return NoCvt;
    fn = datatofile(data);
    if (!fn)
        return Failed;
    rv = readimagefileimpl(fn, imd);
    remove(fn);
    return rv;
}

int settransientfor(wbp w, wbp other)
{
    wsp ws = w->window;
    if (ws->win) {
        LitWhy("Can't set transient_for on an open window");
        return Failed;
    }
    if (other) {
        if (ws->transientfor)
            freewindow(ws->transientfor);
        ws->transientfor = linkwindow(other->window);
    } else {
        if (ws->transientfor)
            freewindow(ws->transientfor);
        ws->transientfor = 0;
    }
    return Succeeded;
}

int setwindowicon(wbp w, struct imgdata *imd)
{
    return Failed;
}

int getwindowicon(wbp w, struct imgdata *imd)
{
    return Failed;
}

int grabkeyboard(wbp w)
{
    return Succeeded;
}

int ungrabkeyboard(wbp w)
{
    return Succeeded;
}

wbp clonewindow(wbp w)
{
    wbp w2;
    w2 = alcwbinding();
    w2->window = linkwindow(w->window);
    w2->context = clonecontext(w->context);
    return w2;
}

wbp couplewindows(wbp w1, wbp w2)
{
    wbp w3;
    w3 = alcwbinding();
    w3->window = linkwindow(w1->window);
    w3->context = linkcontext(w2->context);
    return w3;
}

static struct SharedColor *new_sharedcolor(char *name, int r, int g, int b, int a)
{
    struct SharedColor *res;
    GAlloc(res, SharedColor);
    res->name = salloc(name);
    res->color = gb_make_Color(a / 256, r / 256, g / 256, b / 256);
    return res;
}

static struct SharedColor *link_sharedcolor(struct SharedColor *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedcolor(struct SharedColor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        free(x->name);
        free(x);
    }
}

static struct SharedCursor *new_sharedcursor(HCURSOR cursor)
{
    struct SharedCursor *res;
    GAlloc(res, SharedCursor);
    res->cursor = cursor;
    return res;
}

static struct SharedCursor *link_sharedcursor(struct SharedCursor *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedcursor(struct SharedCursor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        free(x->cursor);
        free(x);
    }
}

static struct wcursor *lookup_wcursor(char *name)
{
    struct wcursor *rv;
    int i;
    i = hasher(hashcstr(name), cursors);
    for(rv = cursors[i]; rv; rv = rv->next) {
        if (!strcmp(name, rv->name))
            return rv;
    }
    return 0;
}

static struct wcursor *ensure_wcursor(char *name)
{
    struct wcursor *rv;
    int i;
    i = hasher(hashcstr(name), cursors);
    for(rv = cursors[i]; rv; rv = rv->next) {
        if (!strcmp(name, rv->name))
            return rv;
    }
    rv = rt_zalloc(sizeof(struct wcursor));
    rv->name = salloc(name);
    rv->next = cursors[i];
    cursors[i] = rv;
    return rv;
}

static void bitmap_to_imgdata(gb_Bitmap *bm, struct imgdata *imd)
{
    int i, j;
    UINT width, height;
    gb_Color *p;
    gb_get_Bitmap_size(bm, &width, &height);
    imd->format = &imgdataformat_MSBGRA32;
    imd->width = width;
    imd->height = height;
    imd->data = rt_malloc(imd->width * imd->height * sizeof(gb_Color));
    p = (gb_Color *)imd->data;
    for(j = 0; j < imd->height; j++) {
        for(i = 0; i < imd->width; i++)
            *p++ = gb_getpixel(bm, i, j);
    }
}

static gb_Bitmap *imgdata_to_bitmap(struct imgdata *imd)
{
    gb_Bitmap *bm;
    int i, j;
    bm = gb_create_empty_Bitmap(imd->width, imd->height);
    for(j = 0; j < imd->height; j++) {
        for(i = 0; i < imd->width; i++) {
            int r, g, b, a;
            imd->format->getpixel(imd, i, j, &r, &g, &b, &a);
            gb_setpixel(bm, i, j, a / 256, r / 256, g / 256, b / 256);
        }
    }
    return bm;
}

static struct SharedBitmap *new_sharedbitmap(struct imgdata *imd)
{
    struct SharedBitmap *res;
    GAlloc(res, SharedBitmap);
    res->bitmap = imgdata_to_bitmap(imd);
    return res;
}

static struct SharedBitmap *link_sharedbitmap(struct SharedBitmap *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedbitmap(struct SharedBitmap *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        gb_free_Bitmap(x->bitmap);
        free(x);
    }
}

int focuswindow(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    SetFocus(ws->win);
    return Succeeded;
}

static void synch_cursor(wsp ws)
{
    ws->savedcursor = SetCursor(ws->cursor->shared_cursor->cursor);
    if (mouse_debug) dbg("synch_cursor to %s, savedcursor=%x\n", ws->cursor->name, ws->savedcursor);
}

int definepointer(wbp w, char *name, int x, int y)
{
    struct wcursor *rv;
    rv = ensure_wcursor(name);
    if (rv->shared_cursor) {
        unlink_sharedcursor(rv->shared_cursor);
        rv->shared_cursor = link_sharedcursor(null_cursor);
    } else
        rv->shared_cursor = link_sharedcursor(null_cursor);
    return Succeeded;
}

int copypointer(wbp w, char *dest, char *src)
{
    struct wcursor *sc, *dc;
    sc = lookup_wcursor(src);
    if (!sc)
        return Failed;
    dc = ensure_wcursor(dest);
    if (sc != dc) {
        if (dc->shared_cursor) {
            unlink_sharedcursor(dc->shared_cursor);
            dc->shared_cursor = link_sharedcursor(sc->shared_cursor);
        } else
            dc->shared_cursor = link_sharedcursor(sc->shared_cursor);
    }
    return Succeeded;
}

static wbp findwbp(wsp ws)
{
    wbp wb;
    for (wb = wbndngs; wb; wb = wb->next)
        if (wb->window == ws)
            return wb;
    syserr("Couldn't find wbp for wsp");
    return 0;  /* not reached */
}

static void setup_cursor(char *name, LPCTSTR cid)
{
    int i;
    struct wcursor *rv;
    i = hasher(hashcstr(name), cursors);
    rv = rt_zalloc(sizeof(struct wcursor));
    rv->name = name;
    if (cid)
        rv->shared_cursor = new_sharedcursor(LoadCursor(NULL, cid));
    else
        rv->shared_cursor = link_sharedcursor(null_cursor);
    rv->next = cursors[i];
    cursors[i] = rv;
}

static void init_window_system(void)
{
    WNDCLASSEX wc;
    RECT r;
    wc.cbSize =         sizeof(WNDCLASSEX); 
    wc.style =          CS_DBLCLKS;
    wc.lpfnWndProc =    WndProc;
    wc.cbClsExtra =     0;
    wc.cbWndExtra =     0;
    wc.hInstance =      GetModuleHandle(0);
    wc.hIcon =          LoadIcon(0, IDI_APPLICATION);
    wc.hCursor =        LoadCursor(0, IDC_ARROW);
    wc.hbrBackground =  GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =   0;
    wc.lpszClassName =  "oix";
    wc.hIconSm =        LoadIcon(0, IDI_APPLICATION);
    RegisterClassEx(&wc);
    r.left = r.top = r.right = r.bottom = 0;
    AdjustWindowRect(&r, WS_OVERLAPPEDWINDOW, FALSE);
    BORDER_WIDTH = r.right - r.left;
    BORDER_HEIGHT = r.bottom - r.top;
    gb_initialize(ffatalerr);
    dummy_hdc = GetDC(0);
    black = new_sharedcolor("black", 0, 0, 0, 0xffff);
    white = new_sharedcolor("white", 0xffff,0xffff,0xffff, 0xffff);
    default_font = load_font(defaultfont);
    if (!default_font)
        ffatalerr("Couldn't load default font");
    setup_cursors();
}

static void setup_cursors()
{
    null_cursor = new_sharedcursor(LoadCursor(NULL, IDC_ARROW));

    /* Windows ones */
    setup_cursor("help", IDC_HELP);
    setup_cursor("hand", IDC_HAND);
    setup_cursor("ibeam", IDC_IBEAM);
    setup_cursor("uparrow", IDC_UPARROW);
    setup_cursor("wait", IDC_WAIT);
    setup_cursor("starting", IDC_APPSTARTING);
    setup_cursor("sizeall", IDC_SIZEALL);
    setup_cursor("sizenesw", IDC_SIZENESW);
    setup_cursor("sizens", IDC_SIZENS);
    setup_cursor("sizenwse", IDC_SIZENWSE);
    setup_cursor("sizewe", IDC_SIZEWE);
    setup_cursor("no", IDC_NO);

    setup_cursor("X cursor", 0);
    setup_cursor("arrow", IDC_ARROW);
    setup_cursor("based arrow down", 0);
    setup_cursor("based arrow up", 0);
    setup_cursor("boat", 0);
    setup_cursor("bogosity", 0);
    copypointer(0, "bottom left corner", "sizenesw");
    copypointer(0, "bottom right corner", "sizenwse");
    setup_cursor("bottom side", 0);
    setup_cursor("bottom tee", 0);
    setup_cursor("box spiral", 0);
    setup_cursor("center ptr", 0);
    copypointer(0, "circle", "no");
    setup_cursor("clock", 0);
    setup_cursor("coffee mug", 0);
    setup_cursor("cross", IDC_CROSS);
    setup_cursor("cross reverse", 0);
    setup_cursor("crosshair", 0);
    setup_cursor("diamond cross", 0);
    setup_cursor("dot", 0);
    setup_cursor("dotbox", 0);
    copypointer(0, "double arrow", "sizens");
    setup_cursor("draft large", 0);
    setup_cursor("draft small", 0);
    setup_cursor("draped box", 0);
    setup_cursor("exchange", 0);
    copypointer(0, "fleur", "sizeall");
    setup_cursor("gobbler", 0);
    setup_cursor("gumby", IDC_SIZENESW);
    copypointer(0, "hand1", "hand");
    copypointer(0, "hand2", "hand");
    setup_cursor("heart", 0);
    setup_cursor("icon", 0);
    setup_cursor("iron cross", 0);
    setup_cursor("left ptr", 0);
    setup_cursor("left side", 0);
    setup_cursor("left tee", 0);
    setup_cursor("leftbutton", 0);
    setup_cursor("ll angle", 0);
    setup_cursor("lr angle", 0);
    setup_cursor("man", 0);
    setup_cursor("middlebutton", 0);
    setup_cursor("mouse", 0);
    setup_cursor("pencil", 0);
    setup_cursor("pirate", 0);
    setup_cursor("plus", 0);
    copypointer(0, "question arrow", "help");
    setup_cursor("right ptr", 0);
    setup_cursor("right side", 0);
    setup_cursor("right tee", 0);
    setup_cursor("rightbutton", 0);
    setup_cursor("rtl logo", 0);
    setup_cursor("sailboat", 0);
    setup_cursor("sb down arrow", 0);
    copypointer(0, "sb h double arrow", "sizewe");
    setup_cursor("sb left arrow", 0);
    setup_cursor("sb right arrow", 0);
    copypointer(0, "sb up arrow", "uparrow");
    copypointer(0, "sb v double arrow", "sizens");
    setup_cursor("shuttle", 0);
    setup_cursor("sizing", 0);
    setup_cursor("spider", 0);
    setup_cursor("spraycan", 0);
    setup_cursor("star", 0);
    setup_cursor("target", 0);
    setup_cursor("tcross", 0);
    setup_cursor("top left arrow", 0);
    copypointer(0, "top left corner", "sizenwse");
    copypointer(0, "top right corner", "sizenesw");
    setup_cursor("top side", 0);
    setup_cursor("top tee", 0);
    setup_cursor("trek", 0);
    setup_cursor("ul angle", 0);
    setup_cursor("umbrella", 0);
    setup_cursor("ur angle", 0);
    copypointer(0, "watch", "wait");
    copypointer(0, "xterm", "ibeam");
}

static void set_MSBGRA32(struct imgdata *imd, int x, int y, int r, int g, int b, int a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    *s++ = b / 256;
    *s++ = g / 256;
    *s++ = r / 256;
    *s++ = a / 256;
}

static void get_MSBGRA32(struct imgdata *imd, int x, int y, int *r, int *g, int *b, int *a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    *b = 257 * (*s++);
    *g = 257 * (*s++);
    *r = 257 * (*s++);
    *a = 257 * (*s++);
}

static struct imgdataformat imgdataformat_MSBGRA32 = {set_MSBGRA32,get_MSBGRA32,0,0,getlength_32,8,24,0,"MSBGRA32"};

void registerplatformimgdataformats()
{
    registerimgdataformat(&imgdataformat_MSBGRA32);
}
