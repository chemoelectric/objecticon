#
# $Id$
#

package http

import util,
   lang,
   net,
   io,
   ipl.base64

#
# Little helper class to store cookie details
#
class Cookie()
   package readable
      name,
      value,
      expires, 
      domain, 
      path,
      secure,
      comment, 
      version

   #
   # This is a utility function to remove any expired cookies from
   # a table of cookies.
   #
   public static expire_cookies(cookies)
      local e, f, g, now, t
      now := Time()
      every e := !sort(cookies) do {
         every f := !sort(e[2]) do {
            every g := !sort(f[2]) do {
               t := g[2].expires
               /t | t.after(now) | delete(f[2], g[1])
            }
            if *f[2] = 0 then
               delete(e[2], f[1])
         }
         if *e[2] = 0 then
            delete(cookies, e[1])
      }
      return cookies
   end
end

#
# An http client
#
# @field http_version=string: see {set_http_version}
# @field user_agent=string: see {set_user_agent}
# @field retries=integer: see {set_retries}
# @field retry_while_data=flag: see {set_retry_while_data}
# @field keep_alive=flag : see {set_keep_alive}
# @field cookies=table : see {set_cookies}
# @field see also {NetClient}
#
class HttpClient(NetClient)
   public static const
      TOKEN_CHAR,
      COMPLETE_EVENT,
      FAILED_EVENT,
      ABORTED_EVENT,
      RETRYING_EVENT,
      HEADERS_EVENT,
      PROGRESS_EVENT,
      EVENT_TABLE

   private static init()
      TOKEN_CHAR := &ascii[33:128] -- '()<>@,;:\\\"/[]?={} \t'
      COMPLETE_EVENT := "Complete"
      FAILED_EVENT := "Failed"
      ABORTED_EVENT := "Aborted"
      RETRYING_EVENT := "Retrying"
      HEADERS_EVENT := "Headers"
      PROGRESS_EVENT := "Progress"
      EVENT_TABLE := table(,
                           "complete", COMPLETE_EVENT,
                           "failed", FAILED_EVENT,
                           "aborted", ABORTED_EVENT,
                           "retrying", RETRYING_EVENT,
                           "headers", HEADERS_EVENT,
                           "progress", PROGRESS_EVENT)
   end

   private readable 
      request,
      response,
      open_url,
      retries,
      retry_while_data_flag,
      length,
      read,
      http_version,
      http_error,
      keep_alive_flag,
      user_agent,
      redir_set, 
      auth_req_count,
      auth_scheme,
      basic_auth_header,
      nonce,
      nonce_count,
      cnonce,
      opaque,
      ha1,
      qop,
      realm,
      cookies,
      abort_flag

   #
   # Set the http version to use; by default "1.1"
   #
   public set_http_version(s)
      http_version := s
   end

   #
   # Set the user-agent identification
   #
   public set_user_agent(s)
      self.user_agent := s
   end

   #
   # Configure whether the client uses the keep-alive feature (the
   # default is yes).
   #
   public set_keep_alive(s)
      self.keep_alive_flag := check_flag(s)
   end

   #
   # This flag indicates that after a timeout, the retries count should
   # be reset if any data was received.
   #
   public set_retry_while_data(s)
      self.retry_while_data_flag := check_flag(s)
   end

   #
   # Set the cookies table.
   #
   public set_cookies(m)
      self.cookies := m
   end

   #
   # Get the cookies table.
   #
   public get_cookies()
      return self.cookies
   end

   #
   # Get the current HttpRequest
   #
   public get_request()
      return self.request
   end

   #
   # Get the current HttpResponse
   #
   public get_response()
      return self.response
   end

   #
   # Abort the current request.
   #
   public abort()
      self.abort_flag := 1
   end

   #
   # 
   private write_request_headers()
      local e, v
      every e := !request.headers.sort() do {
         e[1][1] := map(e[1][1], &lcase, &ucase)
         every v := !e[2] do
            write_line(e[1] || ": " || v) | fail
      }
      return
   end

   #
   # Set the number of retries to use.  The default is two.
   #
   public set_retries(retries)
      self.retries := retries
   end

   #
   # Retrieve the given {HttpRequest} request, or fail if that
   # is not possible.
   #
   # @param request - an {HttpRequest} instance
   # @return an {HttpResponse} object.
   public retrieve(request)
      # Create our own copy of the request as we may modify it during
      # redirects
      self.request := HttpRequest()
      self.request.set_url(clone(request.url))
      self.request.set_method(request.method)
      self.request.set_headers(clone(request.headers))
      self.request.set_username(request.username)
      self.request.set_password(request.password)
      self.request.set_referer(request.referer)
      self.request.set_range(request.range_start, request.range_end)
      self.request.set_content_type(request.content_type)
      if /request.data_stream then
         request.method === "HEAD" | runerr("No data stream set")
      else {
         request.data_stream.can(Stream.WRITE + Stream.TRUNCATE) | 
                        runerr("Data stream not writable and truncatable", request.data_stream)
         self.request.set_data_stream(request.data_stream)
      }
      if /request.post_stream then
         request.method ~=== "POST" | runerr("No data stream set on a POST")
      else {
         request.post_stream.can(Stream.READ + Stream.SEEK) | 
                        runerr("Post stream not readable and seekable", request.post_stream)
         self.request.set_post_stream(request.post_stream)
      }

      auth_req_count := 0
      redir_set := set()
      abort_flag := &null
      repeat {
         http_error := &null

         retrieve_page() | fail

         if find("200"|"206", response.get_status()) then
            return response

         if find("401", response.get_status()) then
            handle_authentication() | fail
         else if find("301"|"302"|"303"|"307", response.get_status()) then
            handle_redirect() | fail
         else
            return on_http_error(response.get_status())
      }
   end

   #
   # 
   private handle_redirect()
      local l, s, u
      #
      # A redirection, so extract the URL if possible.
      #
      l := response.get_first_header("Location") | return on_http_error("No Location in a redirect response")
      if match("http://", l) then {
         u := URL.parse(l) | return on_http_error("Invalid Location in a redirect response: " || l)
         request.set_url(u)
      } else
         #
         # It shouldn't be a relative URL, but that seems to be
         # commonplace.
         #
         request.url.set_relative(l)
      
      s := to_string(request.url)
      if member(redir_set, s) then
         return on_http_error("Circular redirection detected: " || s)
      insert(redir_set, s)

      #
      # On a redirect, a POST becomes a GET.
      #
      if request.method == "POST" then {
         request.set_method("GET")
         request.set_post_stream()
         request.unset_header("content-length")
         request.unset_header("content-type")
      }
      auth_req_count := 0
      return
   end

   #
   # 
   private handle_authentication()
      local s, t
      if /(request.username | request.password) then
         return on_http_error("Authentication requested - please set username, password")

      if auth_req_count > 0 then
         return on_http_error("Failed to authenticate - correct username, password")
      auth_req_count +:= 1

      s := response.get_first_header("www-authenticate") | 
         return on_http_error("No WWW-Authenticate in a 401 response")

      t := parse_generic_header(s)
      if member(t, "Basic") then {
         auth_scheme := "Basic"
         return setup_basic_authentication()
      }
      if member(t, "Digest") then {
         auth_scheme := "Digest"
         return setup_digest_authentication()
      }

      return on_http_error("WWW-Authenticate header contained unknown authentication method.")
   end

   #
   # 
   private setup_basic_authentication(t)
      basic_auth_header := "Basic " || base64encode(request.username || ":" || request.password)
      return
   end

   #
   # 
   private setup_digest_authentication(t)
      local algorithm, md5, qop_options

      self.realm := \t["realm"] | 
         return on_http_error("WWW-Authenticate digest header didn't contain a realm")
      self.nonce := \t["nonce"] | 
         return on_http_error("WWW-Authenticate digest header didn't contain a nonce")
      self.opaque := t["opaque"] 

      algorithm := \t["algorithm"] | "MD5"
      self.nonce_count := 0
      self.cnonce := "0a4f113b"
      
      #
      # Calculate HA1
      #
      md5 := MD5()
      md5.update(request.username || ":" || realm || ":" || request.password)
      if map(algorithm) == "md5-sess" then {
         md5.update(":" || nonce || ":" || cnonce)
      }
      self.ha1 := md5.final_str()

      #
      # Get the available qop values and select a qop.
      #
      qop_options := set()
      \t["qop"] ? {
         while(tab(upto(TOKEN_CHAR))) do 
            insert(qop_options, map(tab(many(TOKEN_CHAR))))
      }
      self.qop := member(qop_options, "auth-int" | "auth") | &null

      return
   end

   #
   # 
   private create_digest_authorization_header()
      local md5, nc, h, t, hentity, ha2, s

      self.nonce_count +:= 1
      nc := map(Format.int_to_string(self.nonce_count, 16, 8))
      md5 := MD5()
      #
      # Calculate HA2
      #
      md5.update(request.method || ":" || request.url.get_file())
      if \qop == "auth-int" then {
         # Calculate H(entity)
         t := MD5()
         if \request.post_stream then {
            # Just fail; the whole request will surely fail anyway.
            request.post_stream.seek(1) | fail
            while s := request.post_stream.reads(1048576) do
               t.update(s)
            request.post_stream.eof() | fail
         }
         hentity := t.final_str()
         md5.update(":" || hentity)
      }

      ha2 := md5.final_str()

      md5.update(ha1 || ":" || nonce || ":")
      if \self.qop then
         md5.update(nc || ":" || cnonce || ":" || qop || ":")

      md5.update(ha2)

      h := "Digest username=\"" || request.username || "\",\r\n\t" ||
         "realm=" || realm || ",\r\n\t" ||
         "nonce=" || nonce || ",\r\n\t" ||
         "uri=\"" || request.url.get_file() || "\",\r\n\t"
      if \qop then {
         h ||:= "qop=" || qop || ",\r\n\t" ||
            "nc=" || nc || ",\r\n\t" ||
            "cnonce=" || cnonce || ",\r\n\t"
      }
      if \opaque then
         h ||:= "opaque=" || opaque || ",\r\n\t"
      h ||:= "response=\"" || md5.final_str() || "\""

      return h
   end

   #
   # 
   private unq(s)
      if s[1] == "\"" then 
         s[1] := ""
      if s[-1] == "\"" then 
         s[-1] := ""
      return s
   end

   #
   # 
   private parse_generic_header(s)
      local t, k, v

      t := table()
      s ? repeat {
         tab(upto(TOKEN_CHAR)) | break
         k := tab(many(TOKEN_CHAR))
         if ="=" then {
            if any('\"') then
               v := parse_quoted_string(1)
            else
               v := tab(many(TOKEN_CHAR)) | ""
         } else
            v := &null
         insert(t, k, v)
      }
      return t
   end

   #
   # 
   # @param omit - if non-null, omit the quotes from the result
   private parse_quoted_string(omit)
      local res

      if /omit then
         res := move(1)
      else {
         res := ""
         move(1)
      }

      repeat {
         res ||:= tab(upto('\\\"') | 0)
         if pos(0) then
            break
         else if any('\"') then {
            if /omit then 
               res ||:= move(1)
            else
               move(1)
            break
         } else if any('\\') then {
            res ||:= move(2)
         }
      }
      return res
   end

   #
   # 
   private create_authorization_header()
      case auth_scheme of {
         "Basic":
            return create_basic_authorization_header()
         "Digest":
            return create_digest_authorization_header()
         default:
            fail
      }
   end

   #
   # 
   private create_basic_authorization_header()
      return basic_auth_header
   end

   #
   # 
   private parse_cookie_string(s)
      local c, k, v, t, d

      s ? repeat {
         tab(upto(TOKEN_CHAR)) | break
         k := tab(many(TOKEN_CHAR))
         if ="=" then {
            if any('\"') then
               # The first one (c.value) keeps its quotes, the others don't.
               v := parse_quoted_string(c)
            else
               v := tab(upto(';') | 0)
         } else
            v := &null
         if /c then {
            c := Cookie()
            c.name := k
            c.value := v
         } else {
            case map(k) of {
               "expires" : {
                  if t := Time.parse(v, "EEE, dd-MMM-yyyy hh:mm:ss zzz") then
                     c.expires := t
               }
               "path" : c.path := v
               "domain" : c.domain := v
               "secure" : c.secure := 1
               "max-age" : {
                  if d := integer(v) then {
                     t := Time()
                     t.set_seconds(t.seconds + d)
                     c.expires := t
                  }
               }
               "comment" : c.comment := v
               "version" : c.version := integer(v)
            }
         }
      }

      return \c
   end

   private valid_cookie(c)
      local d, e

      # The path must be a prefix of the request url path
      #
      if \c.path then
         match(c.path, request.url.get_file()) | fail

      if \c.domain then {
         d := map(c.domain)
         e := map(request.url.get_address())

         # The domain must have an embedded dot
         #
         upto('.', trim(d, '.')) | fail

         # The domain must match a domain key of the request address
         #
         d == domain_keys(e) | fail

         # The prefix of the request address after discarding the
         # domain must have no embedded dots.  Eg "www.acme.co.uk"
         # can't specify ".co.uk" since "www.acme" has an embedded dot
         # - but it can specify ".acme.co.uk".
         #
         if upto('.', trim(e[1:-*d], '.')) then
            fail
      }

      return
   end

   #
   # Store any cookie values in the current page's header.
   # 
   private store_cookies()
      local c, domain, path, paths, vals, s

      every s := !response.get_headers("set-cookie") do {
         if (c := parse_cookie_string(s)) & valid_cookie(c) then {
            domain := map(\c.domain | request.url.get_address())
            (paths := member(cookies, domain)) | insert(cookies, domain, paths := table())
            path := c.path
            if /path then {
               # Netscape cookies default to the full file path; rfc2109 ones
               # default to the file up to, but not including, the right-most /.
               if /c.version then
                  path := request.url.get_file()
               else {
                  path := request.url.get_file_dir()
                  if path[-1] == "/" then
                     path[-1] := ""
               }
            }
            (vals := member(paths, path)) | insert(paths, path, vals := table())
            insert(vals, map(c.name), c)
         }
      }
   end

   # 
   # Given a domain name, generate all the valid matching cookie domain
   # values.
   #
   private domain_keys(s)
      # If a numerical address, then just return s
      if many('0-9.', s) = *s + 1 then
         return s
      suspend ("." || s) | s
      s ? {
         while tab(upto('.')) do {
            suspend s[&pos:0]
            move(1)
            suspend s[&pos:0]
         }
      }
   end

   #
   # 
   private create_cookie_header()
      local s, e, f, domain, path, c, now, ver

      domain := map(request.url.get_address())
      path := request.url.get_file()
      now := Time()
      s := ""
      every e := \cookies[domain_keys(domain)] do {
         every f := back(sort(e)) do {
            if match(f[1], path) then {
               every c := (!sort(f[2]))[2] do {
                  if /c.expires | c.expires.after(now) then {
                     if *s > 0 then
                        s ||:= "; "
                     s ||:= c.name
                     s ||:= "=" || \c.value
                     if \c.version then {
                        s ||:= "; $Path=\"" || \c.path || "\"" 
                        s ||:= "; $Domain=\"" || \c.domain || "\"" 
                        ver := c.version
                     }
                  }
               }
            }
         }
      }

      if \ver then
         s := "$Version=\"" || ver || "\"; " || s

      if *s > 0 then
         return s
   end

   #
   # Useful debug function
   # 
   public dump_cookies()
      local c, e, f
      every e := !sort(cookies) do {
         write("domain:", e[1])
         every f := back(sort(e[2])) do {
            write("\tpath:", f[1])
            every c := (!sort(f[2]))[2] do {
               write("\t\t", to_string(c))
            }
         }
      }
   end

   #
   # 
   private on_http_error(s)
      http_error := s
      return error(s)
   end

   #
   # After invoking retrieve(), this method can be used to determine
   # whether a failure was caused by a network failure or an HTTP failure
   # (for example 404 not found).  In the former case this method fails; in
   # the latter case the error string is returned.
   #
   public get_http_error()
      return \http_error
   end

   #
   # 
   private maybe_open()
      if not(is_open()) | /open_url | open_url.get_address() ~== request.url.get_address() |
         open_url.get_port() ~= request.url.get_port() then 
      {
         close()
         set_server(request.url.get_address())
         set_port(request.url.get_port())
         if request.url.get_protocol() == "https" then
            set_ssl(&yes)
         else
            set_ssl(&no)
         open() | fail
         open_url := clone(request.url)
      }
      return
   end

   #
   # Retrieve the current request; doesn't handle redirects and so
   # on - these are handled by the caller, retrieve().
   # 
   private retrieve_page()
      local i, prev_read

      i := retries

      self.read := self.length := &null

      repeat {
         prev_read := self.read
         if tryone() then {
            store_cookies()
            fire(COMPLETE_EVENT)
            return response
         }

         close()
         if \abort_flag then {
            error("Aborted")
            fire(ABORTED_EVENT)
            fail
         }

         if prev_read ~=== self.read & \retry_while_data_flag then {
            i := retries
         } else if (i -:= 1) < 0 then {
            if retries > 0 then
               error("Gave up after " || (1+retries) || " attempts - last reason: " || &why)
            fire(FAILED_EVENT)
            fail
         }

         fire(RETRYING_EVENT)
      }
   end

   #
   #
   # Retrieve the given url.  A {HttpResponse} object is returned upon success.
   # Failure occurs if the url could not be retrieved.
   #
   private tryone()
      local s
      #
      # Open the connection
      #
      maybe_open() | fail

      #
      # Write the request
      #
      write_request() | fail

      repeat {
         #
         # Create a response
         #
         response := HttpResponse()
         response.set_url(request.url)
         s := read_line() | fail
         response.set_status(s)

         #
         # Read the response.
         #
         read_headers() | fail
         fire(HEADERS_EVENT)
         if \abort_flag then
            fail

         #
         # A 100 ("Continue") result means go round again and get 
         # the status/headers again - they follow immediately after
         # the end of the first headers.
         #
         find("100", response.get_status()) | break
      }

      if request.method === "HEAD" then
         maybe_close()
      else
         read_data() | fail

      return
   end
   
   #
   # 
   private maybe_close()
      #
      # Close if told to do so.
      #
      if map(response.get_first_header("connection")) == "close" then
         close()
   end

   #
   # 
   private write_request()
      local rs, sz, s, f
      request.set_header("user-agent", user_agent)
      request.set_header("host", request.url.get_address())
      request.set_header("referer", \request.referer)
      request.unset_header("cookie")
      request.set_header("cookie", create_cookie_header())

      if \keep_alive_flag then
         request.set_header("connection", "Keep-Alive")

      f := (\request.range_start | 0) + (\self.read | 0)
      rs := if f > 0 then
         f || "-"
      else
         "-"
      rs ||:= \request.range_end
            
      if rs == "-" then
         request.unset_header("range")
      else
         request.set_header("range", "bytes=" || rs)

      write_line(request.method || " " || request.url.get_file() || 
                 " HTTP/" || http_version) | fail

      if \request.post_stream then {
         \request.content_type | runerr("Content-type header not set on a POST")
         request.set_header("content-type", request.content_type)
         sz := request.post_stream.seek(0) - 1 | fail
         request.set_header("content-length", sz)
         request.set_header("authorization", create_authorization_header())
         write_request_headers() | fail
         write_line() | fail
         request.post_stream.seek(1) | fail
         while s := request.post_stream.reads(1048576) do {
            if not write_str(s) then {
               f.close()
               fail
            }
         }
         request.post_stream.eof() | fail
      } else {
         request.set_header("authorization", create_authorization_header())
         write_request_headers() | fail
         write_line() | fail
      }

      return
   end

   #
   # 
   private read_headers()
      local s, key, val
      repeat {
         s := read_line() | fail
         if *s = 0 then {
            # Add last header (if any).
            response.add_header(\key, val)
            break
         }
         s ? {
            #
            # A continuation line starts with a space or a tab.
            #
            if any(' \t') then
               val ||:= tab(0)
            else {
               # Add current header and start a new one.
               response.add_header(\key, val)
               key := tab(upto(':') | 0)
               =": "
               val := tab(0)
            }
         }
      }
      return
   end

   #
   # 
   private read_data()
      #
      # See whether we are continuing a partial read.  If so, the
      # self.read and self.length values continue from the previous
      # attempt.  Otherwise, they are reset and the output stream
      # truncated.
      #
      if not(\self.read & find("206", response.get_status())) then {
         request.data_stream.truncate(0) | fail
         self.length := integer(response.get_first_header("content-length")) | &null
         self.read := 0
      }

      #
      # Read the data.
      #
      if trim(map(response.get_first_header("transfer-encoding"))) == "chunked" then
         return read_chunked()
      else if /length then
         return read_to_eof()
      else
         return read_length()
   end

   #
   # 
   private read_chunked()
      local l, chunk, s
      repeat {
         l := read_line() | fail
         l ? {
            chunk := integer("16r" || tab(many('0987654321abcdefABCDEF'))) |
               return error("Expected chunk-length specifier; got " || l)
         }
         if chunk = 0 then
            break
         while chunk > 0 do {
            if \abort_flag then fail
            s := read_str(min(1048576, chunk)) | fail
            add_some(s) | fail
            chunk -:= *s
         }
         l := read_line() | fail
         if *l > 0 then
            return error("Expected empty line at end of chunk")
      }
      #
      # Read any trailing lines, upto an empty line.
      #
      repeat {
         l := read_line() | fail
         if *l = 0 then
            break
      }

      maybe_close()

      return
   end

   #
   # 
   private read_to_eof()
      local s
      #
      # No content length.  Read until eof, then close.
      #
      while s := read_str(1048576) do {
         if \abort_flag then fail
         add_some(s) | fail
      }
      # 
      # Make sure we actually read to the end of file
      #
      eof() | {
         close()
         fail
      }

      close()

      return
   end

   #
   # 
   private read_length()
      local s
      #
      # Got a content length.  Read len bytes and leave the connection
      # open - unless told to close it.
      #
      while self.read < length do {
         if \abort_flag then fail
         s := read_str(min(1048576, length - self.read)) | fail
         add_some(s) | fail
      }

      maybe_close()

      return
   end

   #
   # Return the length of the current download, or fail if unknown
   #
   public get_length()
      return \self.length
   end

   #
   # Return the number of bytes read so far.
   #
   public get_read()
      return self.read
   end

   #
   # 
   private add_some(s)
      self.read +:= *s
      fire(PROGRESS_EVENT)
      return request.data_stream.writes(s)
   end

   public set_one(f)
      case f.attr of {
         "http_version": set_http_version(f.string_val())
         "user_agent": set_user_agent(f.string_val())
         "retries": set_retries(f.int_val())
         "retry_while_data": set_retry_while_data(f.flag_val())
         "keep_alive" : set_keep_alive(f.flag_val())
         "cookies" : set_cookies(f.table_val())
         default: return try_event(f, EVENT_TABLE) | cast(self,NetClient).set_one(f)
      }
      return
   end

   public new(a[])
      cast(self,NetClient).new()
      cookies := table()
      set_timeout(12000)
      keep_alive_flag := 1
      retries := 2
      http_version := "1.1"
      user_agent := "httpclient.icn [en] (" || &host || ")"
      set_fields(a)
      return
   end
end
