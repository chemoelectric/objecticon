<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Saving and restoring global state</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="pandoc.css" />
</head>
<body>
<a href="index.html">Contents</a>
<header id="title-block-header">
<h1 class="title">Saving and restoring global state</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#varstate">VarState</a></li>
</ul></li>
<li><a href="#uses">Uses</a></li>
<li><a href="#other-state-classes">Other <code>State</code> classes</a></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<p>Object Icon has several global variables and keywords, such as <code>&amp;subject</code>, <code>&amp;pos</code> and <code>&amp;why</code>.</p>
<p>Occasionally it is necessary to evaluate an expression without disturbing the value of one or more of these variables. This involves saving and restoring the value of the variable(s) concerned, and there is a library procedure to help with this, <a href="libref/index.html?util.save_state.html"><code>util.save_state</code></a>.</p>
<p>This procedure takes two parameters; firstly a co-expression whose results we wish to evaluate, and an instance of a class, <a href="libref/index.html?util.State.html"><code>util.State</code></a>, which controls which global values are actually saved and restored, as each result is generated.</p>
<p>Notionally, <code>save_state</code> works like this :-</p>
<pre><code>procedure save_state(e, state)
   local v
   state.swap()
   while v := @e do {
      state.swap()
      suspend v
      state.swap()
   }
   state.swap()
end</code></pre>
<p>However, in practice its implementation is a little more involved, because it takes care not to dereference any variables generated by <code>e</code>. The above implementation unfortunately does dereference when it stores the result of the <code>@e</code> in the temporary variable, <code>v</code>. In any case, the <code>swap()</code> method is called just before, and just after, <code>e</code> is activated.</p>
<p>Here is an example program showing how a global variable <code>g</code> can be saved and restored using <code>save_state</code> :-</p>
<p><a href="saveglobal.icn">Download saveglobal.icn</a></p>
<pre><code>import io, util

global g

class MyGlobalState(State)
   private tg

   public override swap()
      g :=: tg
   end

   #
   # i gives the initial value seen by the co-expression we&#39;re evaluating
   #
   public new(i)
      self.tg := i
      return
   end
end

procedure other()
   local i
   write(&quot;other begin: g=&quot;, g)
   every i := 1 to 5 do {
      g +:= 1
      suspend i
      write(&quot;other loop: g=&quot;, g)
   }
   write(&quot;other end: g=&quot;, g)
end

procedure main()
   local i, e
   e := create other()
   g := 300
   write(&quot;main begin: g=&quot;, g)
   every i := save_state(e, MyGlobalState(100)) do {
      g -:= 1
      write(&quot;main loop: i=&quot;, i, &quot; g=&quot;, g)
   }
   write(&quot;main end: g=&quot;, g)
end
</code></pre>
<p>The output is :-</p>
<pre><code>main begin: g=300
other begin: g=100
main loop: i=1 g=299
other loop: g=101
main loop: i=2 g=298
other loop: g=102
main loop: i=3 g=297
other loop: g=103
main loop: i=4 g=296
other loop: g=104
main loop: i=5 g=295
other loop: g=105
other end: g=105
main end: g=295</code></pre>
<p>If you follow through what <code>save_state</code> does, in conjunction with <code>MyGlobalState</code>, you will see that just before <code>e</code> is invoked by <code>save_state</code> for the first time, the value of <code>g</code> is exchanged with the temporary <code>tg</code>, which has been initialized to the value <code>i</code>. Then, as each value is generated by <code>e</code>, the (potentially changed) value of <code>g</code> is saved, and the old value is restored. The generated value is suspended. Should resumption occur, the same thing happens again, only in reverse, and the loop continues. Finally, <code>e</code> is exhausted, and the saved value is restored for a final time.</p>
<p>In this way, <code>e</code>, effectively has its own copy of <code>g</code>, which it can read and write consistently between generating results.</p>
<h2 id="varstate">VarState</h2>
<p>There is a useful class, <a href="libref/index.html?util.VarState.html"><code>util.VarState</code></a>, which in fact can save us from writing a class like <code>MyGlobalState</code>. It takes a co-expression which generates a global variable to save and restore, and an optional initial value. We could have used this in <code>main</code> above as follows :-</p>
<pre><code>    every i := save_state(e, VarState(create g, 100)) do {
          ...
    }</code></pre>
<h1 id="uses">Uses</h1>
<p><code>save_state</code> is particularly useful when an expression may exit via a co-expression activation that doesn’t return. One example would be the throwing of an <a href="Coexpressions.html#exception-handling">exception</a>. For example,</p>
<pre><code>import io, exception

procedure main()
   &quot;outer subject&quot; ? {
      tab(3)
      try1{{
         &quot;inner subject&quot; ? {
            tab(5)
            throw(&quot;Some problem&quot;)
         }
      }} | write(&quot;Exception occurred: &quot;, &amp;why)
      write(&quot;Now &amp;subject=&quot;, image(&amp;subject), &quot; &amp;pos=&quot;, &amp;pos)
   }
end</code></pre>
<p>when run this produces :-</p>
<pre><code>Exception occurred: Some problem
Now &amp;subject=&quot;inner subject&quot; &amp;pos=5</code></pre>
<p>Note how the values of <code>&amp;subject</code> and <code>&amp;pos</code> have “escaped” from the inner scanning expression, overwriting the values in the outer scan.</p>
<p>This can easily be solved by enclosing the <code>try1</code> in a call to <code>save_state</code>, and using <a href="libref/index.html?util.ScanState.html"><code>util.ScanState</code></a>, a <code>State</code> that saves <code>&amp;subject</code> and <code>&amp;pos</code>.</p>
<pre><code>      ...
      save_state(create try1{{
         &quot;inner subject&quot; ? {
            tab(5)
            throw(&quot;Some problem&quot;)
         }
      }} | write(&quot;Exception occurred: &quot;, &amp;why)
      , ScanState())
      ...</code></pre>
<p>This leaves <code>&amp;subject</code> and <code>&amp;pos</code> set to their correct values.</p>
<p>Another example is the reverting of an <a href="libref/index.html?io.Task.html"><code>io.Task</code></a> to its <a href="libref/index.html?io.Scheduler.html">scheduler</a>. For example, consider a <code>Task</code> like the following :-</p>
<pre><code>t := Task(scheduler, create {{
   &quot;some subject&quot; ? {
        tab(5)
        ...
        t.sleep(100)
        ...
   }
}})</code></pre>
<p>In this example, the call to <code>sleep</code> will activate the scheduler, leaving <code>&amp;subject</code> and <code>&amp;pos</code> with the local values. By the time the scheduler re-activates the <code>Task</code>, <code>&amp;subject</code> and <code>&amp;pos</code> may well have changed, and their values will not be what the <code>Task</code> expects.</p>
<p>To address this problem, <code>Task</code> accepts an optional third parameter, giving a <code>State</code>, which is used to save and restore state each time the task switches to and from the scheduler. So in this case we would need to change the above to</p>
<pre><code>t := Task(scheduler, create {{
    ... as above ...
}}, ScanState())</code></pre>
<p>For more information on schedulers, see <a href="Coexpressions.html#non-blocking-io-and-background-tasks">here</a>.</p>
<h1 id="other-state-classes">Other <code>State</code> classes</h1>
<p>There are various <code>State</code> subclasses for saving the common global keywords and variables; see the list of subclasses in <code>State</code>’s <a href="libref/index.html?util.State.html">documentation page</a>.</p>
<p>Most notably there is <a href="libref/index.html?util.States.html"><code>util.States</code></a>, which brings together several <code>State</code>s into one <code>State</code>. So, if we wanted a state to save the scanning state as well as global variables <code>g1</code> and <code>g2</code>, we could use :-</p>
<pre><code>States(ScanState(), VarState{g1}, VarState{g2})</code></pre>
<a href="index.html">Contents</a>
</body>
</html>
