<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>proc.icn</title></head><body><pre>
<a name="1"/>package lang
<a name="2"/>
<a name="3"/>import util(error)
<a name="4"/>
<a name="5"/>#
<a name="6"/># This class allows information about procedures, functions, etc, to
<a name="7"/># be obtained.  The parameters named `p` to the methods may be any
<a name="8"/># function or procedure or method pointer.
<a name="9"/>#
<a name="10"/># Additionally, `p` may be a two-element list.  The first element
<a name="11"/># should be a class or object, the second a field name or number
<a name="12"/># referencing a method.  This enables information about instance,
<a name="13"/># special or private methods to be obtained.  In order to ensure
<a name="14"/># consistency in information about native methods, passing a class in
<a name="15"/># this way will cause it to be initialized if it isn't already.
<a name="16"/>#
<a name="17"/># Note that methods which are resolved to stub functions may not
<a name="18"/># behave as expected.  These stub functions are used as placeholders
<a name="19"/># for optional, abstract and (unresolved) native methods.  They are
<a name="20"/># also used to replace methods which `oit` deems unreferenced
<a name="21"/># ("removed methods").
<a name="22"/>#
<a name="23"/># Since these stub functions are shared by many methods, they do not
<a name="24"/># link back to a particular class and field.  Thus, the `get_name`
<a name="25"/># method, for example, will return the stub function's name rather
<a name="26"/># than the name which one might otherwise expect.
<a name="27"/>#
<a name="28"/>final abstract class Proc()
<a name="29"/>   public static const
<a name="30"/>      Procedure,      # Value from `get_kind` indicating an icon procedure
<a name="31"/>      Function,       # Value from `get_kind` indicating a native function or method
<a name="32"/>      Keyword,        # Value from `get_kind` indicating a keyword function
<a name="33"/>      Operator,       # Value from `get_kind` indicating an operator
<a name="34"/>      Internal,       # Value from `get_kind` indicating an internal block of VM instructions
<a name="35"/>      Argument,       # Value from `get_local_kind` indicating an argument
<a name="36"/>      Dynamic,        # Value from `get_local_kind` indicating a dynamic variable
<a name="37"/>      Static          # Value from `get_local_kind` indicating a static variable
<a name="38"/>
<a name="39"/>   private static init()
<a name="40"/>      # Kinds of procedure
<a name="41"/>      Procedure := 0
<a name="42"/>      Function :=  1
<a name="43"/>      Keyword :=   2
<a name="44"/>      Operator :=  3
<a name="45"/>      Internal :=  4
<a name="46"/>      # Types of local variable
<a name="47"/>      Argument := 0
<a name="48"/>      Dynamic := 1
<a name="49"/>      Static := 2
<a name="50"/>   end
<a name="51"/>      
<a name="52"/>   # Return the name of the proc.  For a method, the name is
<a name="53"/>   # return in the form `class.method`.
<a name="54"/>   #
<a name="55"/>   # For example :-
<a name="56"/>   # ~
<a name="57"/>   #    get_name(FileStream.pipe)` -&gt; "io.FileStream.pipe"
<a name="58"/>   # ~
<a name="59"/>   #
<a name="60"/>   # Stub methods always return their stub name (since they
<a name="61"/>   # aren't recognised as fields) :-
<a name="62"/>   # ~
<a name="63"/>   #    # Optional method
<a name="64"/>   #    get_name([Stream, "in"]) -&gt; "optional_method_stub"
<a name="65"/>   # ~
<a name="66"/>   #
<a name="67"/>   public static get_name(p)
<a name="68"/>      return get_name_impl(arg(p))
<a name="69"/>   end
<a name="70"/>
<a name="71"/>   # Return the program this proc resides in, or fail if it is not in
<a name="72"/>   # a program.  The program's &amp;main co-expression is returned.  For a
<a name="73"/>   # method (including resolved native methods), the declaring class's
<a name="74"/>   # program is returned.
<a name="75"/>   #
<a name="76"/>   # For example :-
<a name="77"/>   # ~
<a name="78"/>   #    get_program(DescStream.poll)` -&gt; co-expression#123
<a name="79"/>   # ~
<a name="80"/>   #
<a name="81"/>   # Note that stub methods will always fail :-
<a name="82"/>   # ~
<a name="83"/>   #    # Optional method
<a name="84"/>   #    get_program([Stream, "in"])` -&gt; fails
<a name="85"/>   # ~
<a name="86"/>   #
<a name="87"/>   public static get_program(p)
<a name="88"/>      return get_program_impl(arg(p))
<a name="89"/>   end
<a name="90"/>
<a name="91"/>   # Return the name of the package in which this proc resides; fails
<a name="92"/>   # if the proc is not in a package.  For a method, the package of
<a name="93"/>   # the declaring class is returned.
<a name="94"/>   #
<a name="95"/>   # For example :-
<a name="96"/>   # ~
<a name="97"/>   #    get_package(FileStream.pipe)` -&gt; "io"
<a name="98"/>   # ~
<a name="99"/>   #
<a name="100"/>   # Note that stub methods will always fail :-
<a name="101"/>   # ~
<a name="102"/>   #    # Optional method
<a name="103"/>   #    get_package([Stream, "in"])` -&gt; fails
<a name="104"/>   # ~
<a name="105"/>   #
<a name="106"/>   public static get_package(p)
<a name="107"/>      local cl
<a name="108"/>      p := arg(p)
<a name="109"/>      if cl := get_defining_class_impl(p) then
<a name="110"/>         return Class.get_package(cl)
<a name="111"/>      if get_kind_impl(p) = Procedure then
<a name="112"/>         return extract_package(get_name_impl(p))
<a name="113"/>   end
<a name="114"/>
<a name="115"/>   # Return the source location of the proc.  For a method, the
<a name="116"/>   # location of the method declaration is returned.
<a name="117"/>   #
<a name="118"/>   # For example :-
<a name="119"/>   # ~
<a name="120"/>   #    # Native method
<a name="121"/>   #    get_location(DescStream.poll)` -&gt; Location#1(...)
<a name="122"/>   # ~
<a name="123"/>   #
<a name="124"/>   # Note that stub methods will always fail :-
<a name="125"/>   # ~
<a name="126"/>   #    # Optional method
<a name="127"/>   #    get_location([Stream, "in"])` -&gt; fails
<a name="128"/>   # ~
<a name="129"/>   #
<a name="130"/>   # :Returns :
<a name="131"/>   # :  a `Location` instance
<a name="132"/>   #
<a name="133"/>   public static get_location(p)
<a name="134"/>      local cl, i, prog
<a name="135"/>      p := arg(p)
<a name="136"/>      return if cl := get_defining_class_impl(p) &amp;
<a name="137"/>         i := get_field_index_impl(p) then
<a name="138"/>         Class.get_field_location(cl, i)
<a name="139"/>      else if prog := get_program_impl(p) then
<a name="140"/>         Prog.get_global_location(get_name_impl(p), prog)
<a name="141"/>      else
<a name="142"/>         # Set &amp;why for consistency, since it is set by
<a name="143"/>         # Class.get_field_location &amp; Prog.get_global_location
<a name="144"/>         error("Proc not a procedure, has no location")
<a name="145"/>   end
<a name="146"/>
<a name="147"/>   # Return the class in which this method is defined; fails if this
<a name="148"/>   # is not a method.
<a name="149"/>   #
<a name="150"/>   public static get_defining_class(p)
<a name="151"/>      return get_defining_class_impl(arg(p))
<a name="152"/>   end
<a name="153"/>
<a name="154"/>   # Return the field name of the method; fails if this is not a
<a name="155"/>   # method.
<a name="156"/>   #
<a name="157"/>   public static get_field_name(p)
<a name="158"/>      return get_field_name_impl(arg(p))
<a name="159"/>   end
<a name="160"/>
<a name="161"/>   # Return the field index of the method; fails if this is not a
<a name="162"/>   # method.
<a name="163"/>   #
<a name="164"/>   public static get_field_index(p)
<a name="165"/>      return get_field_index_impl(arg(p))
<a name="166"/>   end
<a name="167"/>
<a name="168"/>   #
<a name="169"/>   # Return the kind of this procedure, which is one of the constants :-
<a name="170"/>   # * `Procedure` for a procedure or method defined in an icon source file
<a name="171"/>   # * `Function` a builtin function like `upto`, or a native method
<a name="172"/>   # * `Keyword` a keyword function, obtained via `Prog.get_keyword()`
<a name="173"/>   # * `Operator` an operator function, obtained via `Prog.get_operator()`
<a name="174"/>   # * `Internal` an internally used block of VM instructions.
<a name="175"/>   #
<a name="176"/>   public static get_kind(p)
<a name="177"/>      return get_kind_impl(arg(p))
<a name="178"/>   end
<a name="179"/>
<a name="180"/>   # Return the number of locals (arguments, dynamic locals and
<a name="181"/>   # statics) of the proc; fails if this is not an procedure.
<a name="182"/>   #
<a name="183"/>   public static get_n_locals(p)
<a name="184"/>      p := arg(p)
<a name="185"/>      return get_n_arguments_impl(p) + get_n_dynamics_impl(p) + get_n_statics_impl(p)
<a name="186"/>   end
<a name="187"/>
<a name="188"/>   # Return the number of arguments of the proc; fails if this is not
<a name="189"/>   # an procedure.
<a name="190"/>   #
<a name="191"/>   public static get_n_arguments(p)
<a name="192"/>      return get_n_arguments_impl(arg(p))
<a name="193"/>   end
<a name="194"/>
<a name="195"/>   # Succeeds if this is a procedure with variable args.
<a name="196"/>   #
<a name="197"/>   public static has_varargs(p)
<a name="198"/>      return has_varargs_impl(arg(p))
<a name="199"/>   end
<a name="200"/>
<a name="201"/>   # Return the number of dynamic locals of the proc; fails if this is
<a name="202"/>   # not an procedure.
<a name="203"/>   #
<a name="204"/>   public static get_n_dynamics(p)
<a name="205"/>      return get_n_dynamics_impl(arg(p))
<a name="206"/>   end
<a name="207"/>
<a name="208"/>   # Return the number of static variables in the proc; fails if this
<a name="209"/>   # is not an procedure.
<a name="210"/>   #
<a name="211"/>   public static get_n_statics(p)
<a name="212"/>      return get_n_statics_impl(arg(p))
<a name="213"/>   end
<a name="214"/>
<a name="215"/>   # Return the local name with the given id (name or index number).
<a name="216"/>   #
<a name="217"/>   public static get_local_index(p, id)
<a name="218"/>      return get_local_index_impl(arg(p), id)
<a name="219"/>   end
<a name="220"/>
<a name="221"/>   # Generate the local names of the procedure.
<a name="222"/>   #
<a name="223"/>   public static get_local_names(p)
<a name="224"/>      p := arg(p)
<a name="225"/>      suspend get_local_name_impl(p, 1 to get_n_locals(p))
<a name="226"/>   end
<a name="227"/>
<a name="228"/>   # Return the location of the local variable with the given id (name
<a name="229"/>   # or index number).
<a name="230"/>   #
<a name="231"/>   public static get_local_location(p, id)
<a name="232"/>      return Location!get_local_location_impl(arg(p), id)
<a name="233"/>   end
<a name="234"/>
<a name="235"/>   # Return the name of the local variable with the given id (name or
<a name="236"/>   # index number).
<a name="237"/>   #
<a name="238"/>   public static get_local_name(p, id)
<a name="239"/>      return get_local_name_impl(arg(p), id)
<a name="240"/>   end
<a name="241"/>
<a name="242"/>   #
<a name="243"/>   # Return the type of the given local, which is one of the constants
<a name="244"/>   # * `Argument`,
<a name="245"/>   # * `Dynamic` (ie, a variable declared "local") or
<a name="246"/>   # * `Static`.
<a name="247"/>   #
<a name="248"/>   public static get_local_kind(p, id)
<a name="249"/>      return get_local_kind_impl(arg(p), id)
<a name="250"/>   end
<a name="251"/>
<a name="252"/>   private static arg(p)
<a name="253"/>      if type(p) == "list" then {
<a name="254"/>         *p = 2 | runerr("Two-element list expected", p)
<a name="255"/>         if type(p[1]) == "class" then
<a name="256"/>            Class.ensure_initialized(p[1])
<a name="257"/>         p := get_proc_field!p | runerr(&amp;why, p[2])
<a name="258"/>      }
<a name="259"/>      return p
<a name="260"/>   end
<a name="261"/>
<a name="262"/>   private static native get_name_impl(p)
<a name="263"/>   private static native get_program_impl(p)
<a name="264"/>   private static native get_defining_class_impl(p)
<a name="265"/>   private static native get_field_name_impl(p)
<a name="266"/>   private static native get_field_index_impl(p)
<a name="267"/>   private static native get_kind_impl(p)
<a name="268"/>   private static native get_n_arguments_impl(p)
<a name="269"/>   private static native has_varargs_impl(p)
<a name="270"/>   private static native get_n_dynamics_impl(p)
<a name="271"/>   private static native get_n_statics_impl(p)
<a name="272"/>   private static native get_local_index_impl(p, id)
<a name="273"/>   private static native get_local_location_impl(p, id)
<a name="274"/>   private static native get_local_name_impl(p, id)
<a name="275"/>   private static native get_local_kind_impl(p, id)
<a name="276"/>   private static native get_proc_field(c, field)
<a name="277"/>
<a name="278"/>   # load C function dynamically.
<a name="279"/>   public static native load(filename, funcname)
<a name="280"/>
<a name="281"/>   # Lookup a procedure (or function) by name.  First the globals are
<a name="282"/>   # searched for a matching procedure or function.  Failing that, the
<a name="283"/>   # builtin function, operator and keyword tables are searched.
<a name="284"/>   # 
<a name="285"/>   # :Parameters :
<a name="286"/>   # :  `s` - a name to search for
<a name="287"/>   # :  `n` - the arity of an operator
<a name="288"/>   # :  `ce` - a coexpression, representing a loaded program, defaults
<a name="289"/>   #   to the main program
<a name="290"/>   # :Returns :
<a name="291"/>   # :  a procedure
<a name="292"/>   # :Fails :
<a name="293"/>   # :  if the name is unknown as a proc
<a name="294"/>   #
<a name="295"/>   public static for_name(s, n, ce)
<a name="296"/>      return proc(s, n, ce)
<a name="297"/>   end
<a name="298"/>end
</pre></body></html>
