package util

import ipl.functional

class Connectable()
   private listeners

   # This variable contains the last `Listener` added with `connect()`.
   private readable last_listener

   #
   # Helper method to create and fire an Event object from the given parameters.
   #
   public fire(type, param)
      local l

      if /type then 
         runerr("null type to fire")

      every l := !listeners do {
         if /l.type | l.type === type then
            l.proc(param, self, type)
      }
      return self
   end

   #
   # Create and connect a `Listener` to this object.  To get the actual `Listener`
   # instance added, use the variable `last_listener`.
   #
   # @param proc The procedure or other invocable to call on an event.
   # @param etype The particular event to listen for; null means all events
   # @param pos The position in the listener list, default 0.
   # @return self
   #
   public connect(proc, etype, pos)
      if type(proc) == "co-expression" then
         proc := exprf(proc)
      /pos := 0
      listeners := copy(listeners)
      insert(listeners, 
             pos,
             last_listener <- Listener(proc, etype)) | fail
      return self
   end

   #
   # This is like `connect`, but the listener is automatically disconnected
   # after it is fired `n` times.  `n` defaults to 1.
   # @return self
   #
   public connect_n(proc, etype, pos, n)
      local x
      /n := 1
      if type(proc) == "co-expression" then
         proc := exprf(proc)
      connect(lambda{{ 
         proc!_a
         n -:= 1
         if n = 0 then
            disconnect(x)
      }}, etype, pos) | fail
      x := last_listener
      return self
   end

   #
   # This returns the last `Listener` instance added with `connect`.
   # This can then be passed (for example) to `disconnect()`.
   #
   public get_last_listener()
      return .\last_listener
   end

   #
   # Remove all `Listener`s with the given proc field.
   #
   public disconnect_proc(proc)
      local t, l
      t := []
      every l := !listeners do {
         if l.proc === proc then
            l.disable()
         else 
            put(t, l)
      }
      listeners := t
      return self
   end

   #
   # Remove all `Listener`s with the given type field.
   #
   public disconnect_type(type)
      local t, l
      t := []
      every l := !listeners do {
         if l.type === type then
            l.disable()
         else 
            put(t, l)
      }
      listeners := t
      return self
   end

   #
   # Remove a `Listener` previously added by {connect}
   # @param l The `Listener` to disconnect 
   #
   public disconnect(l)
      local t
      t := []
      every put(t, l ~=== !listeners)
      l.disable()
      listeners := t
      return self
   end

   #
   # Generate the listeners
   #
   public gen_listeners()
      suspend .!listeners
   end

   #
   # Reconnect a `Listener` previously added by {connect} and
   # then removed by {disconnect}.
   # @param l The `Listener` to reconnect 
   # @param pos The position in the listener list, default 0.
   #
   public reconnect(l, pos)
      /pos := 0
      listeners := copy(listeners)
      insert(listeners, pos, l) | fail
      l.reenable()
      return self
   end

   public new()
      listeners := []
      return
   end
end

