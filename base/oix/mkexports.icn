import io, lang, ipl.printf, util, ipl.scan, ipl.options

global syms, opts, home

record Symbol(id, typ, params)

procedure backspace()
   return tab(rev_many(' \t',,,1))
end

procedure fwdspace()
   return tab(many(' \t'))
end

procedure rev_id()
   return tab(rev_many(&letters ++ &digits ++ '_',,,1))
end

procedure one_line(s)
   local id, typ, arr, params, i
   s ? {
      fwdspace()
      if pos(0) | any('#/*') then fail
      if ="declare_convert_" then fail

      if ="extern" then {
         fwdspace()
         i := &pos
         tab(upto(';')) | stopf("No ; in line '%s'", s)
         backspace()
         if rev_any(']',,,1) then
            arr := tab(backto('[',,,1) - 1)
         else
            arr := ""
         backspace()
         id := rev_id() | stopf("No identifier in line '%s'", s)
         typ := tab(i) || arr
      } else {
         tab(upto(';')) | stopf("No ; in line '%s'", s)
         tab(backto(')',,,1)) | stopf("No ) in line '%s'", s)
         params := tab(backto('(',,,1) - 1)
         backspace()
         id := rev_id() | stopf("No identifier in line '%s'", s)
         backspace()
         typ := tab(1)
      }
   }
   insert(syms, id, Symbol(id, typ, params))
end

procedure incomplete(s)
   s ? {
      tab(0)
      backspace()
      if rev_any(',',,,1) then
         return
   }
end

procedure traverse_header(f)
   local s, l
   f := open_header(f)
   s := ""
   while l := f.read() do {
      s ||:= l
      incomplete(s) | {
         one_line(s)
         s := ""
      }
   }
   f.close()
end

procedure struct_out(f, sym)
   if \sym.params then
      fprintf(f, "    %s (*%s)%s;\n", sym.typ, sym.id, sym.params)
   else
      fprintf(f, "    %s*%s;\n", sym.typ, sym.id)
end

procedure decl_out(f, sym)
   fprintf(f, "    &%s,\n", sym.id)
end

procedure define_out(f, sym)
   fprintf(f, "#define %s (*(imported->%s))\n", sym.id, sym.id)
end

procedure header(f)
   write(f, "/* Auto-generated by mkexports.icn */")
   write(f)
end

procedure output(o1, o2, o3)
   local f, s, sym

   every header(o1 | o2 | o3)

   o1.write("struct oisymbols {")
   o2.write("struct oisymbols oiexported = {")

   o3.write("/*")
   o3.write("* This file is included by rtt-generated C files when rtt is given")
   o3.write("* the -x option.  It is needed for loadable libraries which can't")
   o3.write("* access oix's symbols directly.")
   o3.write("*/")
   o3.write("static struct oisymbols *imported;\n\n")

   f := open_file("exportsyms.txt") | stopf("Couldn't open export syms file: %w")
   while s := f.read() do {
      if s ? =("#if" | "#endif") then
         every (o1 | o2 | o3).write(s)
      else if not(*s = 0 | s[1] == "#") then {
         sym := member(syms, s) | stopf("Couldn't lookup symbol '%s'", s)
         struct_out(o1, sym)
         decl_out(o2, sym)
         define_out(o3, sym)
      }
   }
   f.close()
   o1.write("};")
   o2.write("};")
   o3.write("\n\n/* Called by oix when the library is first loaded */")
   o3.write("#if MSWIN32")
   o3.write("__declspec(dllexport)")
   o3.write("#endif")
   o3.write("void setimported(struct oisymbols *x)")
   o3.write("{")
   o3.write("   imported = x;")
   o3.write("}")
   every (o1 | o2 | o3).close()
end

procedure open_file(s, mode)
   return open(s, mode) | stopf("Couldn't open header file %s: %w", s)
end

procedure open_header(s, mode)
   return open_file(home.walk("base", "h", s).str(), mode)
end

procedure main(a)
   local o1, o2, o3
   opts := options(a, [Opt("t",, "Test mode")])
   home := FilePath(env_string("OI_HOME")) | stop("OI_HOME not set")
   syms := table()
   every traverse_header("rproto.h" | "rexterns.h" | "mproto.h")
   if \opts["t"] then {
      write("Symbols:\n\n", to_string(syms, 3))
      every (o1 | o2 | o3) := StringStream()
      output(o1, o2, o3)
      writes("\n\n", o1.str(), "\n\n", o2.str(), "\n\n", o3.str())
   } else {
      output(open_header("oisymbols.h", "w"),
             open_file("oiexported.ri", "w"),
             open_header("imported.h", "w"))
      write("OK")
   }
end
