############################################################################
#
#	File:     cfunc.icn
#
#	Subject:  Procedures implemented in C
#
#	Author:   Gregg M. Townsend
#
#	Date:     June 8, 2001
#
############################################################################
#
#     These Icon procedures transparently load and execute functions
#  implemented in C.  Each procedure is a simple stub.  The first call
#  to a stub causes it to replace itself with the corresponding
#  dynamically loaded C function, after which the C function processes
#  the arguments and returns a result (or fails).  Subsequent calls
#  go straight to the C function without involving the Icon stub.
#
#     C functions are loaded from a file "libcfunc.so" that is found by
#  searching $FPATH.  The default $FPATH is set by iconx to include
#  this library.
#
############################################################################
#
#  Requires:  Dynamic loading
#
############################################################################

#  DO NOT EDIT THIS FILE DIRECTLY. 
#  It was created mechanically by the shell file "mkfunc.sh".
#  Edit that instead.

package ipl.cfunc

import
   ipl.io(pathload)

$define LIB "libcfunc.so"

# bitcount.c:
# count bits in an integer 
procedure bitcount(a[])      		
   return(bitcount:=pathload(LIB,"bitcount"))!a;end

# files.c:
# change UNIX file permissions 
procedure chmod(a[])      		
   return(chmod:=pathload(LIB,"icon_chmod"))!a;end
# change UNIX permission mask 
procedure umask(a[])      		
   return(umask:=pathload(LIB,"icon_umask"))!a;end

# fpoll.c:
# await data from file 
procedure fpoll(a[])      		
   return(fpoll:=pathload(LIB,"fpoll"))!a;end

# internal.c:
# return descriptor d-word 
procedure dword(a[])      		
   return(dword:=pathload(LIB,"dword"))!a;end
# return descriptor v-word 
procedure vword(a[])      		
   return(vword:=pathload(LIB,"vword"))!a;end
# construct descriptor 
procedure descriptor(a[])      		
   return(descriptor:=pathload(LIB,"icon_descriptor"))!a;end
# load value from memory 
procedure peek(a[])      		
   return(peek:=pathload(LIB,"peek"))!a;end
# create spy-port to memory 
procedure spy(a[])      		
   return(spy:=pathload(LIB,"spy"))!a;end

# lgconv.c:
# convert large integer to string 
procedure lgconv(a[])      		
   return(lgconv:=pathload(LIB,"lgconv"))!a;end

# osf.c:
# query OSF system table 
procedure osftable(a[])      		
   return(osftable:=pathload(LIB,"osftable"))!a;end

# pack.c:
# pack integer into bytes 
procedure pack(a[])      		
   return(pack:=pathload(LIB,"pack"))!a;end
# unpack integer from bytes 
procedure unpack(a[])      		
   return(unpack:=pathload(LIB,"unpack"))!a;end

# ppm.c:
# extract width of PPM string 
procedure ppmwidth(a[])      		
   return(ppmwidth:=pathload(LIB,"ppmwidth"))!a;end
# extract height of PPM string 
procedure ppmheight(a[])      		
   return(ppmheight:=pathload(LIB,"ppmheight"))!a;end
# extract max of PPM string 
procedure ppmmax(a[])      		
   return(ppmmax:=pathload(LIB,"ppmmax"))!a;end
# extract data from PPM string 
procedure ppmdata(a[])      		
   return(ppmdata:=pathload(LIB,"ppmdata"))!a;end
# stretch contrast of PPM string 
procedure ppmstretch(a[])      		
   return(ppmstretch:=pathload(LIB,"ppmstretch"))!a;end
# sharpen a PPM string 
procedure ppmsharpen(a[])      		
   return(ppmsharpen:=pathload(LIB,"ppmsharpen"))!a;end
# convolve PPM with matrix 
procedure ppm3x3(a[])      		
   return(ppm3x3:=pathload(LIB,"ppm3x3"))!a;end
# dither PPM to Icon image 
procedure ppmimage(a[])      		
   return(ppmimage:=pathload(LIB,"ppmimage"))!a;end

# process.c:
# kill process 
procedure kill(a[])      		
   return(kill:=pathload(LIB,"icon_kill"))!a;end
# query process ID 
procedure getpid(a[])      		
   return(getpid:=pathload(LIB,"icon_getpid"))!a;end
# query user ID 
procedure getuid(a[])      		
   return(getuid:=pathload(LIB,"icon_getuid"))!a;end
# query group ID 
procedure getgid(a[])      		
   return(getgid:=pathload(LIB,"icon_getgid"))!a;end

# tconnect.c:
# connect to TCP socket 
procedure tconnect(a[])      		
   return(tconnect:=pathload(LIB,"tconnect"))!a;end

#---
