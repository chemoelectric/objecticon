<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>textbutton.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: textbutton.icn 8535 2020-09-27 19:02:24Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package gui
<a name="10"/>
<a name="11"/>import util
<a name="12"/>
<a name="13"/>#
<a name="14"/># A button with a text label.
<a name="15"/>#
<a name="16"/># The size of the button can either be set using `set_size()`,
<a name="17"/># be left to default to a size based on the given label.
<a name="18"/>#
<a name="19"/>class TextButton(Button, BorderWhilstEntered)
<a name="20"/>   public 
<a name="21"/>      paint,
<a name="22"/>      paint_down
<a name="23"/>
<a name="24"/>   public override display()
<a name="25"/>      local p
<a name="26"/>
<a name="27"/>      p := if /paint_down | (self.is_down === self.is_checked_flag) then
<a name="28"/>         paint
<a name="29"/>      else
<a name="30"/>         paint_down
<a name="31"/>
<a name="32"/>      p.draw_rect(self.cbwin, border.float(self, p))
<a name="33"/>
<a name="34"/>      if /border_whilst_entered_flag | \is_down | (is_unshaded() &amp; \entered) then {
<a name="35"/>         if \self.is_down then {
<a name="36"/>            border.draw_down_rect(self.cbwin, self)
<a name="37"/>            border.draw_rev_rect(self.cbwin, self)
<a name="38"/>         } else if /self.is_checked_flag then
<a name="39"/>            border.draw_rect(self.cbwin, self)
<a name="40"/>         else
<a name="41"/>            border.draw_rev_rect(self.cbwin, self)
<a name="42"/>      }
<a name="43"/>
<a name="44"/>      if should_draw_focus() then
<a name="45"/>         border.draw_focus_rect(self.cbwin, self)
<a name="46"/>   end
<a name="47"/>
<a name="48"/>   #
<a name="49"/>   # Set the label.
<a name="50"/>   # :Parameters :
<a name="51"/>   # :  `x` - The label.
<a name="52"/>   #
<a name="53"/>   public set_label(x)
<a name="54"/>      return set_paint(paint_for_string(x))
<a name="55"/>   end
<a name="56"/>
<a name="57"/>   public set_label_down(x)
<a name="58"/>      return set_paint_down(paint_for_string(x))
<a name="59"/>   end
<a name="60"/>
<a name="61"/>   #
<a name="62"/>   # Set down image to use in the button
<a name="63"/>   #
<a name="64"/>   # :Parameters :
<a name="65"/>   # :  `x` - The down image
<a name="66"/>   #
<a name="67"/>   public set_image_down(x)
<a name="68"/>      return if /x then
<a name="69"/>         set_paint_down()
<a name="70"/>      else
<a name="71"/>         set_paint_down(ImagePaint().set_image(x))
<a name="72"/>   end
<a name="73"/>
<a name="74"/>   #
<a name="75"/>   # Set an image to use in the button
<a name="76"/>   # :Parameters :
<a name="77"/>   # :  `x` - The image
<a name="78"/>   #
<a name="79"/>   public set_image(x)
<a name="80"/>      return set_paint(ImagePaint().set_image(x))
<a name="81"/>   end
<a name="82"/>
<a name="83"/>   #
<a name="84"/>   # Set the up/down images (if any) to the strings provided.
<a name="85"/>   # The two images must have the same dimensions.
<a name="86"/>   # :Parameters :
<a name="87"/>   # :  `x` - The up image
<a name="88"/>   # :  `y` - The down image
<a name="89"/>   #
<a name="90"/>   public set_images(x, y)
<a name="91"/>      set_image(x)
<a name="92"/>      set_image_down(y)
<a name="93"/>      link
<a name="94"/>   end
<a name="95"/>
<a name="96"/>   public set_paint(p)
<a name="97"/>      if is_initialized() then {
<a name="98"/>         (\self.paint).finally()
<a name="99"/>         self.paint := p
<a name="100"/>         self.paint.initially(self, self.accel)
<a name="101"/>         self.invalidate()
<a name="102"/>      } else
<a name="103"/>         self.paint := p
<a name="104"/>      link
<a name="105"/>   end
<a name="106"/>
<a name="107"/>   public set_paint_down(p)
<a name="108"/>      if is_initialized() then {
<a name="109"/>         (\self.paint_down).finally()
<a name="110"/>         self.paint_down := p
<a name="111"/>         (\self.paint_down).initially(self, self.accel)
<a name="112"/>         self.invalidate()
<a name="113"/>      } else
<a name="114"/>         self.paint_down := p
<a name="115"/>      link
<a name="116"/>   end
<a name="117"/>
<a name="118"/>   public override initially()
<a name="119"/>      \self.paint | runerr("No label specified")
<a name="120"/>      Button.initially()
<a name="121"/>      self.paint.initially(self, self.accel)
<a name="122"/>      (\self.paint_down).initially(self, self.accel)
<a name="123"/>   end
<a name="124"/>
<a name="125"/>   public override finally()
<a name="126"/>      Button.finally()
<a name="127"/>      paint.finally()
<a name="128"/>      (\paint_down).finally()
<a name="129"/>   end
<a name="130"/>
<a name="131"/>   public override get_default_width()
<a name="132"/>      local t
<a name="133"/>      t := paint.w
<a name="134"/>      t &lt;:= (\paint_down).w
<a name="135"/>      return t + border.get_total_width()
<a name="136"/>   end
<a name="137"/>
<a name="138"/>   public override get_default_height()
<a name="139"/>      local t
<a name="140"/>      t := paint.h
<a name="141"/>      t &lt;:= (\paint_down).h
<a name="142"/>      return t + border.get_total_height()
<a name="143"/>   end
<a name="144"/>
<a name="145"/>   public override new()
<a name="146"/>      Button.new()
<a name="147"/>      BorderWhilstEntered.new()
<a name="148"/>      self.border := CompoundBorder().
<a name="149"/>                       set_outer(RaisedBorder()).
<a name="150"/>                       set_inner(EmptyBorder())
<a name="151"/>      return
<a name="152"/>   end
<a name="153"/>end
<a name="154"/>
<a name="155"/># A helper class for a component whose border is only shown whilst the
<a name="156"/># mouse cursor is over the component.
<a name="157"/>#
<a name="158"/>abstract class BorderWhilstEntered(Component)
<a name="159"/>   public 
<a name="160"/>      border_whilst_entered_flag,
<a name="161"/>      entered
<a name="162"/>
<a name="163"/>   public static const
<a name="164"/>      DEFAULT
<a name="165"/>
<a name="166"/>   private static init()
<a name="167"/>      DEFAULT := env_flag("OI_BORDER_WHILST_ENTERED_DEFAULT")
<a name="168"/>   end
<a name="169"/>
<a name="170"/>   #
<a name="171"/>   # If set, only draw the border whilst the button is enabled and the
<a name="172"/>   # mouse pointer is over the button.  This is useful for toolbar
<a name="173"/>   # buttons.
<a name="174"/>   #
<a name="175"/>   public set_border_whilst_entered(s)
<a name="176"/>      if border_whilst_entered_flag ~===:= need_flag(s) then
<a name="177"/>         invalidate()
<a name="178"/>      link
<a name="179"/>   end
<a name="180"/>
<a name="181"/>   public handle_enter(e)
<a name="182"/>      entered := &amp;yes
<a name="183"/>      if \border_whilst_entered_flag then
<a name="184"/>         invalidate()
<a name="185"/>   end
<a name="186"/>
<a name="187"/>   public handle_exit(e)
<a name="188"/>      entered := &amp;no
<a name="189"/>      if \border_whilst_entered_flag then
<a name="190"/>         invalidate()
<a name="191"/>   end
<a name="192"/>
<a name="193"/>   public handle_interrupted(e)
<a name="194"/>      handle_exit(e)
<a name="195"/>   end
<a name="196"/>
<a name="197"/>   public override new()
<a name="198"/>      connect(handle_enter, Event.MOUSE_ENTER)
<a name="199"/>      connect(handle_exit, Event.MOUSE_EXIT)
<a name="200"/>      connect(handle_interrupted, Event.INTERRUPTED)
<a name="201"/>      border_whilst_entered_flag := DEFAULT
<a name="202"/>      return
<a name="203"/>   end
<a name="204"/>end
</pre></body></html>
