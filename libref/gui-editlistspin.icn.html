<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>editlistspin.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: editlistspin.icn 8828 2021-01-08 12:48:33Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package gui
<a name="10"/>
<a name="11"/>import
<a name="12"/>   util,
<a name="13"/>   ipl.pdco
<a name="14"/>
<a name="15"/>#
<a name="16"/># Selection from a list with edit
<a name="17"/>#
<a name="18"/>class EditListSpin(SelectionSpin)
<a name="19"/>   public
<a name="20"/>      # The last event which changed the view via a change in selection (as opposed to editing).
<a name="21"/>      applied_event
<a name="22"/>
<a name="23"/>   public was_applied(ev)
<a name="24"/>      succeed ev === applied_event
<a name="25"/>   end
<a name="26"/>
<a name="27"/>   public override apply_selection(ev)
<a name="28"/>      local s 
<a name="29"/>      s := convert_element(object_get_selection()) | view.get_contents()[1:1]
<a name="30"/>      if /ev then
<a name="31"/>         self.view.set_contents(s)
<a name="32"/>      else
<a name="33"/>         self.view.assign_contents(s,, applied_event := ev, &amp;yes)
<a name="34"/>   end
<a name="35"/>
<a name="36"/>   public on_textfield(ev, src, type)
<a name="37"/>      synch_selection()
<a name="38"/>      # Fire the event with self as source.
<a name="39"/>      fire(type, ev)
<a name="40"/>   end
<a name="41"/>
<a name="42"/>   #
<a name="43"/>   # Set the text field's filter (see `TextField` for details).
<a name="44"/>   # :Parameters :
<a name="45"/>   # :  `c` - The filter
<a name="46"/>   #
<a name="47"/>   public set_filter(c)
<a name="48"/>      self.view.set_filter(c)
<a name="49"/>      link
<a name="50"/>   end
<a name="51"/>
<a name="52"/>   #
<a name="53"/>   # Return the contents of the text field (which may have
<a name="54"/>   # been edited).
<a name="55"/>   #
<a name="56"/>   public get_contents()
<a name="57"/>      return view.get_contents()
<a name="58"/>   end
<a name="59"/>
<a name="60"/>   public override create_view()
<a name="61"/>      return SpinTextField()
<a name="62"/>   end
<a name="63"/>
<a name="64"/>   #
<a name="65"/>   # Set the contents of the text to the given string; the
<a name="66"/>   # selection is set to any matching item in the list, or
<a name="67"/>   # &amp;null if there is no match.
<a name="68"/>   #
<a name="69"/>   public set_contents(x)
<a name="70"/>      self.view.set_contents(x)
<a name="71"/>      synch_selection()
<a name="72"/>      link
<a name="73"/>   end
<a name="74"/>
<a name="75"/>   # Set the list selection items to the list x, but then synchronize
<a name="76"/>   # the selection in the list with the view, rather than the other
<a name="77"/>   # way around (as `set_selection_list` does).
<a name="78"/>   #
<a name="79"/>   # :Parameters :
<a name="80"/>   # :  `The` - list of items
<a name="81"/>   #
<a name="82"/>   public synch_set_selection_list(x)
<a name="83"/>      self.selection_list := need_list(x)
<a name="84"/>      /self.selection := 1
<a name="85"/>      constrain_selection()
<a name="86"/>      synch_selection()
<a name="87"/>      link
<a name="88"/>   end
<a name="89"/>
<a name="90"/>   public synch_selection()
<a name="91"/>      local s, i
<a name="92"/>      s := view.get_contents()
<a name="93"/>      every i := 1 to *selection_list do {
<a name="94"/>         if convert_element(selection_list[i]) == s then {
<a name="95"/>            selection := i
<a name="96"/>            return i
<a name="97"/>         }
<a name="98"/>      }
<a name="99"/>   end
<a name="100"/>
<a name="101"/>   public override get_default_width()
<a name="102"/>      return border.get_total_width() +
<a name="103"/>         up.get_preferred_width() +
<a name="104"/>         # Max string length + space for cursor (cf TextField's get_view() method)
<a name="105"/>         MaxNN{ self.cbwin.text_width((view.contents | convert_element(!self.selection_list)) || " ") } +
<a name="106"/>         view.border.get_total_width()
<a name="107"/>   end
<a name="108"/>
<a name="109"/>   public override new()
<a name="110"/>      SelectionSpin.new()
<a name="111"/>      every view.connect(self.on_textfield, Event.CONTENT_CHANGED | Event.ACTION)
<a name="112"/>      return
<a name="113"/>   end
<a name="114"/>end
<a name="115"/>
<a name="116"/>
</pre></body></html>
