package lang

#
# This class contains various helpful methods to get information about
# a class at runtime.
#
class Class()
   public static const 
      # Integer flag for a method
      Method,
      # Integer flag for a private field
      Private,
      # Integer flag for a public field
      Public,
      # Integer flag for a protected field
      Protected,
      # Integer flag for a package field
      Package,
      # Integer flag for a static field
      Static,
      # Integer flag for a constant field
      Const,
      # Integer flag for a readable field
      Readable,
      # Integer flag for a deferred method
      Defer, 
      # Integer flag for a final method or class
      Final,
      # Integer flag for a special method, ie init or new.
      Special

   private static init()
      Method := 8r01
      Private := 8r02
      Public := 8r04
      Protected := 8r010
      Package := 8r020
      Static := 8r040
      Const := 8r0100
      Readable := 8r0200
      Defer := 8r0400
      Final := 8r01000
      Special := 8r02000
   end

   private static defer create_raw(c)
   private static defer complete_raw(o)

   # Return the name of the class
   #
   public static defer get_name(c)

   # Return the class of the object or cast
   #
   public static defer get_class(c)

   # Return the program this class resides in.  The program's &main
   # co-expression is returned.
   #
   public static defer get_program(c)

   # Return the name of the package in which this class resides; fails
   # if the class is not in a package.
   #
   public static defer get_package(c)

   # Return the source location of the class
   # @return a {Location} instance
   #
   public static get_location(c)
      return Location!get_location_impl(c)
   end

   private static defer get_location_impl(c)

   # Generate the superclasses of the class {c}
   #
   public static defer get_supers(c)

   # Generate the implemented classes of the class {c}
   #
   public static defer get_implemented_classes(c)

   # Succeed iff the class {c} implements the class {target}.  This is
   # similar to the builtin is() function, but takes a class as its
   # first argument, whereas is() takes an object (or fails).
   #
   public static defer implements(c, target)

   # Generate the field names of the class {c}.  The instance fields
   # come first, followed by the class fields.
   #
   public static defer get_field_names(c)

   # Return the number of fields in the class {c}.
   #
   public static defer get_n_fields(c)

   # Return the flags for the class {c}, which in fact can only be
   # zero or {Final}, for a final class.
   #
   public static defer get_class_flags(c)

   # Generate the field names of the class fields of class {c}.
   #
   public static defer get_class_field_names(c)

   # Return the number of class fields of class {c}.
   #
   public static defer get_n_class_fields(c)

   # Generate the field names of the instance fields of class {c}.
   #
   public static defer get_instance_field_names(c)

   # Return the number of instance fields of class {c}.
   #
   public static defer get_n_instance_fields(c)

   # Return the flags of the given field in class{c}.
   # @param c the class
   # @param field either a field name or number
   # @return an integer, being the OR of all the flags
   # @fail if the field is unknown
   #
   public static defer get_field_flags(c, field)

   # Return the field index number of the given field in class{c}.
   # @param c the class
   # @param field either a field name or number
   # @return an integer, being the index
   # @fail if the field is unknown
   #
   public static defer get_field_index(c, field)

   # Return the field name of the given field in class{c}.
   # @param c the class
   # @param field either a field name or number
   # @return the field name
   # @fail if the field is unknown
   #
   public static defer get_field_name(c, field)


   # Return the source location of the given field in class{c}.
   # @param c the class
   # @param field either a field name or number
   # @return a {Location} instance
   # @fail if the field is unknown
   #
   public static get_field_location(c, field)
      return Location!get_field_location_impl(c, field)
   end

   private static defer get_field_location_impl(c, field)

   # Return the class in which the given field is defined.
   # @param c the class
   # @param field either a field name or number
   # @return the defining class of the field
   # @fail if the field is unknown
   #
   public static defer get_field_defining_class(c, field)

   # Return the object part of a method pointer.
   # @param mp a methp structure
   # @return an object
   #
   private static defer get_methp_object(mp)

   # Return the procedure part of a method pointer.
   # @param mp a methp structure
   # @return a procedure object (which will be an instance method)
   #
   private static defer get_methp_proc(mp)

   # Return the object part of a cast.
   # @param mp a cast structure created with the {cast()} function
   # @return an object
   #
   private static defer get_cast_object(c)
   
   # Return the class part of a cast.
   # @param mp a cast structure created with the {cast()} function
   # @return a class
   #
   private static defer get_cast_class(c)

   # Get the value of the field in {x}, behaving in exactly the same way
   # as though the "." operation had been invoked with equivalent values.
   #
   # @param x either a class, cast or object
   # @param field either a field name or number
   # @return the field value
   # @runerr if the field is unknown or access is not permitted
   #
   public static defer get(x, field)

   # This behaves in exactly the same way as {get} above, but fails
   # rather than stops with a runtime error, if the field is unknown
   # or access is denied.  On failure, {&why} is set to an appropriate
   # message.
   #
   # @param x either a class, cast or object
   # @param field either a field name or number
   # @return the field value
   # @fail if the field is unknown or access is not permitted
   #
   public static defer getf(x, field, quiet)

   # This behaves in exactly the same way as {getf} above, but
   # doesn't set {&why} on failure.
   #
   # @param x either a class, cast or object
   # @param field either a field name or number
   # @return the field value
   # @fail if the field is unknown or access is not permitted
   #
   public static defer getq(x, field)

   # Set the given field, which must be a method, in the class from
   # which this method was invoked, to be the given procedure.
   #
   # @param field either a field name or number
   # @param proc a procedure
   # @runerr if the field is unkown, the field already has a method,
   # @ or isn't a method field, the procedure is already a method or the
   # @ field is not defined in the class from which this method was
   # @ invoked.
   #
   public static defer set_method(field, proc)   

   # This method tries to resolve all the unresolved deferred methods
   # declared in the class from which is called, from the dll {lib}.
   # Methods are matched to functions in the dll using the same scheme
   # for native methods in the main runtime interpreter, namely by
   # using the form "<class>_<method>", with all dots in <class>
   # replaced by underscores.  Any methods not found are simply
   # ignored.  If the library cannot be found, the call fails and sets
   # {&why} to the message reported by dlerror.
   # 
   # @param lib the name of the dll
   # @fail if the library cannot be found.
   #
   public static defer load_library(lib)   

   # Lookup a class by name
   # 
   # @param s a class name
   # @param ce a coexpression, representing a loaded program, defaults
   # @ to the main program
   # @return a class
   # @fail if the class is unknown
   #
   public static for_name(s, ce)
      local t
      if t := Prog.get_named_global(s, ce) & type(t) == "class" then
         return t
   end

   # Initialize a class, by calling its static init method.  Has no
   # effect if the class has already been initialized.
   #
   public static defer ensure_initialized(c)
end
