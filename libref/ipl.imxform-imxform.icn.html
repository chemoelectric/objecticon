<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>imxform.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     imxform.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures to transform image matrices
<a name="6"/>#
<a name="7"/>#	Author:   Ralph E. Griswold
<a name="8"/>#
<a name="9"/>#	Date:     June 10, 2001
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#  This file contains procedures that manipulate matrices that represent
<a name="18"/>#  images.
<a name="19"/>#
<a name="20"/>############################################################################
<a name="21"/>#
<a name="22"/>#  Requires:  Version 8.11, graphics
<a name="23"/>#
<a name="24"/>############################################################################
<a name="25"/>#
<a name="26"/>#  Links:  factors, imsutils, random, strings
<a name="27"/>#
<a name="28"/>############################################################################
<a name="29"/>
<a name="30"/>package ipl.imxform
<a name="31"/>
<a name="32"/>import
<a name="33"/>   ipl.factors(prime_factors),
<a name="34"/>   ipl.random(shuffle),
<a name="35"/>   ipl.strings(collate, decollate, rotate)
<a name="36"/>
<a name="37"/>#
<a name="38"/>#  Reduces a image matrix to the smallest equivalent one.
<a name="39"/>
<a name="40"/>procedure imxreduce(rows)
<a name="41"/>
<a name="42"/>   rows := imxcollap(rows)
<a name="43"/>   rows := imxrotate(rows, 90)
<a name="44"/>   rows := imxcollap(rows)
<a name="45"/>   rows := imxrotate(rows, -90)
<a name="46"/>
<a name="47"/>   return rows
<a name="48"/>
<a name="49"/>end
<a name="50"/>
<a name="51"/>procedure imxcollap(rows)
<a name="52"/>   local size, fact
<a name="53"/>
<a name="54"/>   size := *rows
<a name="55"/>   every fact := prime_factors(size).p do {
<a name="56"/>      while rowdupl(rows, fact) do {
<a name="57"/>         size /:= fact
<a name="58"/>         rows := rows[1+:size]
<a name="59"/>         }
<a name="60"/>      }
<a name="61"/>
<a name="62"/>   return rows
<a name="63"/>
<a name="64"/>end
<a name="65"/>
<a name="66"/>procedure rowdupl(rows, n)
<a name="67"/>   local span, i, j
<a name="68"/>
<a name="69"/>   if *rows % n ~= 0 then fail
<a name="70"/>
<a name="71"/>   span := *rows / n
<a name="72"/>
<a name="73"/>   every i := 1 to n - 1 do
<a name="74"/>      every j := 1 to span do
<a name="75"/>         if rows[j] ~== rows[i * span + j] then fail
<a name="76"/>
<a name="77"/>   return
<a name="78"/>
<a name="79"/>end
<a name="80"/>
<a name="81"/>#
<a name="82"/>#  Produces the inclusive "or" of two image matrices.
<a name="83"/>
<a name="84"/>procedure imxor(rows1, rows2)
<a name="85"/>   local i, j
<a name="86"/>
<a name="87"/>   if (*rows1 ~= *rows2) | (**rows1 ~= **rows2) then fail
<a name="88"/>
<a name="89"/>   rows1 := copy(rows1)
<a name="90"/>
<a name="91"/>   every i := 1 to *rows1 do
<a name="92"/>      every j := upto('1', rows2[i]) do
<a name="93"/>         rows1[i][j] := "1"
<a name="94"/>
<a name="95"/>   return rows1
<a name="96"/>
<a name="97"/>end
<a name="98"/>
<a name="99"/>#
<a name="100"/>#  Produces the "and" of two image matrices.
<a name="101"/>
<a name="102"/>procedure imxand(rows1, rows2)
<a name="103"/>   local i, j
<a name="104"/>
<a name="105"/>   if (*rows1 ~= *rows2) | (**rows1 ~= **rows2) then fail
<a name="106"/>
<a name="107"/>   rows1 := copy(rows1)
<a name="108"/>
<a name="109"/>   every i := 1 to *rows1 do
<a name="110"/>      every j := upto('0', rows2[i]) do
<a name="111"/>         rows1[i][j] := "0"
<a name="112"/>
<a name="113"/>   return rows1
<a name="114"/>
<a name="115"/>end
<a name="116"/>
<a name="117"/>#
<a name="118"/>#  Produces the exclusive "or" of two image matrices.
<a name="119"/>
<a name="120"/>procedure imxxor(rows1, rows2)
<a name="121"/>   local i, j
<a name="122"/>
<a name="123"/>   if (*rows1 ~= *rows2) | (**rows1 ~= **rows2) then fail
<a name="124"/>
<a name="125"/>   rows1 := copy(rows1)
<a name="126"/>
<a name="127"/>   every i := 1 to *rows1 do
<a name="128"/>      every j := 1 to **rows1 do
<a name="129"/>         rows1[i][j] := if rows1[i][j] == rows2[i][j] then "0" else "1"
<a name="130"/>
<a name="131"/>   return rows1
<a name="132"/>
<a name="133"/>end
<a name="134"/>
<a name="135"/>#
<a name="136"/>#  Scrambles a image matrix by shuffling it.  If dir is "h", the columns of each row
<a name="137"/>#  are scrambled; if "v", the the rows are scrambled.  If "b", bits are
<a name="138"/>#  scrambled throughout the image matrix.
<a name="139"/>
<a name="140"/>procedure imxscramb(rows, dir)
<a name="141"/>   local i, all
<a name="142"/>
<a name="143"/>   case dir of {
<a name="144"/>      "h":  {
<a name="145"/>          every i := 1 to *rows do
<a name="146"/>             rows[i] := shuffle(rows[i])
<a name="147"/>          }
<a name="148"/>      "v":  rows := shuffle(rows)
<a name="149"/>      "b" | &amp;null:  {
<a name="150"/>         all := ""
<a name="151"/>         every all ||:= !rows
<a name="152"/>         all := shuffle(all)
<a name="153"/>         every i := 1 to *rows do {
<a name="154"/>            rows[i] := left(all, *rows[1])
<a name="155"/>            all[1 +: *rows[1]] := ""
<a name="156"/>            }
<a name="157"/>         }
<a name="158"/>      default:   runerr("*** illegal specification in scramble()", dir)
<a name="159"/>      }
<a name="160"/>
<a name="161"/>   return rows
<a name="162"/>
<a name="163"/>end 
<a name="164"/>
<a name="165"/>#
<a name="166"/>#  Create bit-shifted copy of an image matrix.  If dir is "h", then the
<a name="167"/>#  shift is horizontal; if "v", vertical. The default is horizontal.
<a name="168"/>#  Positive shift is to the right for horizontal shifts, downward for vertical
<a name="169"/>#  shifts.  The default shift is 0 and the default direction is horizontal.
<a name="170"/>
<a name="171"/>procedure imxshift(rows, shift, dir)
<a name="172"/>   local i
<a name="173"/>
<a name="174"/>   /shift := 0
<a name="175"/>
<a name="176"/>   rows := copy(rows)
<a name="177"/>
<a name="178"/>   case dir of {
<a name="179"/>      "h" | &amp;null: {			# horizontal shift
<a name="180"/>         every i := 1 to *rows do
<a name="181"/>            rows[i] := rotate(rows[i], -shift)
<a name="182"/>         }
<a name="183"/>      "v": {				# vertical shift
<a name="184"/>         if shift &gt; 0 then
<a name="185"/>            every 1 to shift do
<a name="186"/>               push(rows, pull(rows))
<a name="187"/>         else if shift &lt; 0 then
<a name="188"/>            every 1 to -shift do
<a name="189"/>               put(rows, pop(rows))
<a name="190"/>         }
<a name="191"/>      default:  runerr("*** illegal specification in imxshift()", dir)
<a name="192"/>      }
<a name="193"/>
<a name="194"/>   return rows
<a name="195"/>
<a name="196"/>end
<a name="197"/>
<a name="198"/>#
<a name="199"/>#  Place a border around a image matrix.  l, r, t, and b specify the number of bits
<a name="200"/>#  to add at the left, right, top, and bottom, respectively.  c specifies
<a name="201"/>#  the color of the border, "0" for white, "1" for black.
<a name="202"/>
<a name="203"/>procedure imxborder(rows, l, r, t, b, c)
<a name="204"/>   local i, row, left, right
<a name="205"/>
<a name="206"/>   /l := 1
<a name="207"/>   /r := 1
<a name="208"/>   /t := 1
<a name="209"/>   /b := 1
<a name="210"/>   /c := "0"
<a name="211"/>
<a name="212"/>   if l = r = t = b = 0 then return rows
<a name="213"/>
<a name="214"/>   row := repl(c, *rows[1] + l + r)
<a name="215"/>   left := repl(c, l)
<a name="216"/>   right := repl(c, r)
<a name="217"/>
<a name="218"/>   every i := 1 to *rows do
<a name="219"/>       rows[i] := left || rows[i] || right
<a name="220"/>
<a name="221"/>   every 1 to t do
<a name="222"/>      push(rows, row)
<a name="223"/>
<a name="224"/>   every 1 to b do
<a name="225"/>      put(rows, row)
<a name="226"/>
<a name="227"/>   return rows
<a name="228"/>
<a name="229"/>end
<a name="230"/>
<a name="231"/>#
<a name="232"/>#  Crop a image matrix.  l, r, t, and b specify the number of bits
<a name="233"/>#  to crop at the left, right, top, and bottom, respectively.
<a name="234"/>
<a name="235"/>procedure imxcrop(rows, l, r, t, b)
<a name="236"/>   local i
<a name="237"/>
<a name="238"/>   /l := 0
<a name="239"/>   /r := 0
<a name="240"/>   /t := 0
<a name="241"/>   /b := 0
<a name="242"/>
<a name="243"/>   if l = r = t = b = 0 then return rows
<a name="244"/>
<a name="245"/>   if ((*rows[1] - l - r) | (*rows - t - b)) &lt; 4 then fail
<a name="246"/>
<a name="247"/>   every 1 to t do
<a name="248"/>      get(rows)
<a name="249"/>
<a name="250"/>   every 1 to b do
<a name="251"/>      pull(rows)
<a name="252"/>
<a name="253"/>   every i := 1 to *rows do
<a name="254"/>       rows[i] := rows[i][l + 1 : -r]
<a name="255"/>
<a name="256"/>   return rows
<a name="257"/>
<a name="258"/>end
<a name="259"/>
<a name="260"/>#  Creates a tile in every other pixel is discarded.  dir determines the
<a name="261"/>#  direction is which the halving is done.  If dir is "b" or null, it's
<a name="262"/>#  done both vertically and horizontally.  If dir is "v", it's only done
<a name="263"/>#  vertically, while if dir is "v", it's done only vertically.
<a name="264"/>#  If choice is "o" or null, odd-numbered rows or columns are kept;
<a name="265"/>#  if "e", the even-numbered ones.
<a name="266"/>
<a name="267"/>procedure imxhalve(rows, dir, choice)
<a name="268"/>   local newrows, i
<a name="269"/>
<a name="270"/>   choice := if choice === ("o" | &amp;null) then 1 else 0
<a name="271"/>   newrows := []
<a name="272"/>
<a name="273"/>   case dir of {
<a name="274"/>      "v": {
<a name="275"/>         every i := choice to *rows by 2 do
<a name="276"/>            put(newrows, rows[i])
<a name="277"/>         }
<a name="278"/>      "h":  every put(newrows, decollate(!rows, choice))
<a name="279"/>      "b" | &amp;null: return imxhalve(imxhalve(rows, "v", choice), "h", choice)
<a name="280"/>      }
<a name="281"/>
<a name="282"/>   return newrows
<a name="283"/>
<a name="284"/>end
<a name="285"/>         
<a name="286"/>#
<a name="287"/>#  Creates a tile in which each pixel doubled.  dir determines the
<a name="288"/>#  direction in which the doubling is done.  If dir is "b" or null, it's
<a name="289"/>#  done both horizontally and vertically.  If dir is "v", it's only done
<a name="290"/>#  vertically, while if dir is "h", it's done only horizontally.
<a name="291"/>
<a name="292"/>procedure imxdouble(rows, dir)
<a name="293"/>   local row, newrows
<a name="294"/>
<a name="295"/>   newrows := []
<a name="296"/>
<a name="297"/>   case dir of {
<a name="298"/>      "v":  {
<a name="299"/>         every row := !rows do
<a name="300"/>            every put(newrows, row | row)
<a name="301"/>         }
<a name="302"/>      "h":  {
<a name="303"/>         every row := !rows do
<a name="304"/>            put(newrows, collate(row, row))
<a name="305"/>         }
<a name="306"/>      "b" | &amp;null: return imxdouble(imxdouble(rows, "v"), "h")
<a name="307"/>      }
<a name="308"/>
<a name="309"/>   return newrows
<a name="310"/>
<a name="311"/>end
<a name="312"/>
<a name="313"/>#
<a name="314"/>#  Flip image matrix.  The possible values of dir are "h" (horizontal flip),
<a name="315"/>#  "v" (vertical flip), "l" (left diagonal), and "r" (right diagonal).
<a name="316"/>#  (The left diagonal extends from the upper left corner to the bottom
<a name="317"/>#  right corner; the right diagonal from the upper right to the lower
<a name="318"/>#  left.
<a name="319"/>
<a name="320"/>procedure imxflip(rows, dir)
<a name="321"/>   local newrows, x, y, i
<a name="322"/>
<a name="323"/>   case dir of {
<a name="324"/>      "l": {
<a name="325"/>         newrows := imxrotate(rows)
<a name="326"/>         every y := 1 to *rows do
<a name="327"/>            every x := 1 to *rows[1] do
<a name="328"/>               newrows[x, y] := rows[y, x]
<a name="329"/>         }
<a name="330"/>      "r": {
<a name="331"/>         newrows := list(*rows[1], repl("0", *rows))
<a name="332"/>         every y := 1 to *rows do
<a name="333"/>            every x := 1 to *rows[1] do
<a name="334"/>               if rows[y, x] == "1" then
<a name="335"/>                  newrows[x, y] := "1"
<a name="336"/>         }
<a name="337"/>      "h":  {
<a name="338"/>         newrows := copy(rows)
<a name="339"/>         every i := 1 to *rows do
<a name="340"/>            newrows[i] := reverse(newrows[i])
<a name="341"/>         }
<a name="342"/>      "v":  {
<a name="343"/>         newrows := copy(rows)
<a name="344"/>         every i := 1 to *rows / 2 do
<a name="345"/>           newrows[i] :=: newrows[-i]
<a name="346"/>         }
<a name="347"/>      default:  runerr("*** illegal flip specification in imxflip()", dir)
<a name="348"/>      }
<a name="349"/>
<a name="350"/>   return newrows
<a name="351"/>      
<a name="352"/>end
<a name="353"/>
<a name="354"/>#
<a name="355"/>#  Invert white and black bits in image matrix specification
<a name="356"/>
<a name="357"/>procedure imxinvert(rows)
<a name="358"/>   local i
<a name="359"/>
<a name="360"/>   every i := 1 to *rows do
<a name="361"/>      rows[i] := map(rows[i], "10", "01")
<a name="362"/>
<a name="363"/>   return rows
<a name="364"/>
<a name="365"/>end
<a name="366"/>
<a name="367"/>#
<a name="368"/>#  Reduce image matrix to its smallest equivalent form (with at least 4 columns).
<a name="369"/>#  Limited to square image matrices for portability -- other possibilities exist
<a name="370"/>#  for operating on and/or producing image matrices that are not square.
<a name="371"/>
<a name="372"/>
<a name="373"/>procedure imxminim(rows)
<a name="374"/>   local halfw, halfh, i
<a name="375"/>
<a name="376"/>   if (*rows ~= *rows[1]) | (*rows % 2 ~= 0) then return rows
<a name="377"/>
<a name="378"/>   repeat {
<a name="379"/>  
<a name="380"/>      if *rows[1] &lt; 8 then break		# can't reduce to &lt; 4 columns
<a name="381"/>
<a name="382"/>      halfw := *rows[1] / 2
<a name="383"/>      halfh := *rows / 2
<a name="384"/>   
<a name="385"/>      every i := 1 to halfh do			# check rows in top and bottom
<a name="386"/>         if (rows[i] ~== rows[i + halfh]) |
<a name="387"/>            (rows[i][1+:halfw] ~== rows[i][0-:halfw]) then break break
<a name="388"/>   
<a name="389"/>      every 1 to halfh do			# reducible; remove rows
<a name="390"/>         pop(rows)
<a name="391"/>   
<a name="392"/>      every i := 1 to halfh do			# truncate rows
<a name="393"/>         rows[i] := rows[i][1+:halfw]
<a name="394"/>   
<a name="395"/>      }
<a name="396"/>
<a name="397"/>   return rows
<a name="398"/>
<a name="399"/>end
<a name="400"/>
<a name="401"/>#  Create rotated copy of an image matrix.  If dir is "cw" or "90", rotation is
<a name="402"/>#  90 degrees clockwise; if "ccw" or "-90", 90 degrees counter-clockwise.
<a name="403"/>#  If dir is "180", rotation is 180 degrees.  The default is "cw".
<a name="404"/>
<a name="405"/>procedure imxrotate(rows, dir)
<a name="406"/>   local newrows, i, row, pix
<a name="407"/>
<a name="408"/>   /dir := "cw"
<a name="409"/>
<a name="410"/>   case string(dir) of {
<a name="411"/>      "ccw" | "-90":  {			# counter-clockwise
<a name="412"/>         newrows := list(*rows[1], "")
<a name="413"/>         every row := !rows do  {
<a name="414"/>            i := 0
<a name="415"/>            every pix := !row do
<a name="416"/>               newrows[i -:= 1] ||:= pix
<a name="417"/>            }
<a name="418"/>        }
<a name="419"/>      "cw" | "90" | &amp;null:  {			# clockwise
<a name="420"/>         newrows := list(*rows[1], "")
<a name="421"/>         every row := !rows do {
<a name="422"/>            i := 0
<a name="423"/>            every pix := !row do
<a name="424"/>               newrows[i +:= 1] := pix || newrows[i]
<a name="425"/>            }
<a name="426"/>         }
<a name="427"/>      "180": {
<a name="428"/>         newrows := []
<a name="429"/>         every push(newrows, reverse(!rows))
<a name="430"/>         }
<a name="431"/>      default:  runerr("*** illegal rotation specification in imxrotate()", dir)
<a name="432"/>   }
<a name="433"/>
<a name="434"/>   return newrows
<a name="435"/>
<a name="436"/>end
<a name="437"/>
<a name="438"/>#
<a name="439"/>#  Trim border whitespace from image matrix
<a name="440"/>
<a name="441"/>procedure imxtrim(rows)
<a name="442"/>
<a name="443"/>   while (*rows &gt; 4) &amp; not(upto('1', rows[1])) do
<a name="444"/>      get(rows)
<a name="445"/>
<a name="446"/>   while (*rows &gt; 4) &amp; not(upto('1', rows[-1])) do
<a name="447"/>      pull(rows)
<a name="448"/>
<a name="449"/>   rows := imxrotate(rows, "cw")
<a name="450"/>
<a name="451"/>   while (*rows &gt; 4) &amp; not(upto('1', rows[1])) do
<a name="452"/>      get(rows)
<a name="453"/>
<a name="454"/>   while (*rows &gt; 4) &amp; not(upto('1', rows[-1])) do
<a name="455"/>      pull(rows)
<a name="456"/> 
<a name="457"/>   return imxrotate(rows, "ccw")
<a name="458"/>
<a name="459"/>end
<a name="460"/>
<a name="461"/>#
<a name="462"/>#  Centers non-white portion of image matrix
<a name="463"/>
<a name="464"/>procedure imxcenter(rows, w, h)
<a name="465"/>   local rw, rh, vert, horz, t, l
<a name="466"/>
<a name="467"/>   rows := imxtrim(rows)
<a name="468"/>
<a name="469"/>   rw := *rows[1]
<a name="470"/>   rh := *rows
<a name="471"/>
<a name="472"/>   if (rh = h) &amp; (rw = w) then return rows
<a name="473"/>   if (rh &gt; h) | (rw &gt; w) then fail
<a name="474"/>
<a name="475"/>   horz := w - rw
<a name="476"/>   vert := h - rh
<a name="477"/>   l := horz / 2
<a name="478"/>   t := vert / 2
<a name="479"/>
<a name="480"/>   return imxborder(rows, l, horz - l, t, vert - t)
<a name="481"/>
<a name="482"/>end
<a name="483"/>
<a name="484"/>#  Create a blank i-by-j image matrix
<a name="485"/>
<a name="486"/>procedure imxcreate(i, j)
<a name="487"/>
<a name="488"/>   return list(i, repl("0", j))
<a name="489"/>
<a name="490"/>end
</pre></body></html>
