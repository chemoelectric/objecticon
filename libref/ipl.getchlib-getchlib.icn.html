<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>getchlib.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     getchlib.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures for getch for UNIX
<a name="6"/>#
<a name="7"/>#	Author:   Richard L. Goerwitz
<a name="8"/>#
<a name="9"/>#	Date:     May 2, 2001
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#	Version:  1.14
<a name="18"/>#
<a name="19"/>############################################################################
<a name="20"/>#
<a name="21"/>#  Implementing getch() is a much, much more complex affair under UNIX
<a name="22"/>#  than it is under, say, MS-DOS.  This library represents one,
<a name="23"/>#  solution to the problem - one which can be run as a library, and
<a name="24"/>#  need not be compiled into the run-time system.  Note that it will
<a name="25"/>#  not work on all systems.  In particular, certain Suns (with a
<a name="26"/>#  screwy stty command) and the NeXT 1.0 OS (lacking the -g option for
<a name="27"/>#  stty) do not run getchlib properly.  See the bugs section below for
<a name="28"/>#  workarounds.
<a name="29"/>#
<a name="30"/>#  Four basic utilities are included here:
<a name="31"/>#
<a name="32"/>#	getch()		- waits until a keystroke is available &amp;
<a name="33"/>#	    returns it without displaying it on the screen
<a name="34"/>#	getche()	- same as getch() only with echo
<a name="35"/>#	getse(s)	- like getche() only for strings.  The optional
<a name="36"/>#	    argument s gives getse() something to start with.  Use this
<a name="37"/>#           if, say, you want to read single characters in cbreak mode,
<a name="38"/>#           but get more input if the character read is the first part
<a name="39"/>#           of a longer command.  If the user backspaces over everything
<a name="40"/>#           that has been input, getse() fails.  Returns on \r or \n.
<a name="41"/>#	reset_tty()	- absolutely vital routine for putting the cur-
<a name="42"/>#           rent tty line back into cooked mode; call it before exiting
<a name="43"/>#           or you will find yourself with a locked-up terminal; use it
<a name="44"/>#           also if you must temporarily restore the terminal to cooked
<a name="45"/>#           mode
<a name="46"/>#
<a name="47"/>#  Note that getse() *must* be used in place of read() if you
<a name="48"/>#  are planning on using getch() or getche(), since read()
<a name="49"/>#  assumes a tty with "sane" settings.
<a name="50"/>#
<a name="51"/>#  Warning:  The routines below do not do any sophisticated output
<a name="52"/>#  processing.  As noted above, they also put your tty line in raw
<a name="53"/>#  mode.  I know, I know:  "Raw is overkill - use cbreak."  But in
<a name="54"/>#  a world that includes SysV, one must pick a lowest common denomi-
<a name="55"/>#  nator.  And no, icanon != cbreak.
<a name="56"/>#
<a name="57"/>#  BUGS: These routines will not work on systems that do not imple-
<a name="58"/>#  ment the -g option for the stty command.  The NeXT workstation is
<a name="59"/>#  an example of such a system.  Tisk, tisk.  If you are on a BSD
<a name="60"/>#  system where the network configuration makes stty | more impossible,
<a name="61"/>#  then substitute /usr/5bin/stty (or whatever your system calls the
<a name="62"/>#  System V stty command) for /bin/stty in this file.  If you have no
<a name="63"/>#  SysV stty command online, then you can try replacing every instance
<a name="64"/>#  of "stty -g 2&gt;&amp;1" below with "stty -g 2&gt;&amp;1 1&gt; /dev/tty" or
<a name="65"/>#  something similar.
<a name="66"/>#
<a name="67"/>############################################################################
<a name="68"/>#
<a name="69"/>#  Example program:
<a name="70"/>#
<a name="71"/>#      The following program is a simple file viewer.  To run, it
<a name="72"/>#  needs to be linked with itlib.icn, iscreen.icn, and this file
<a name="73"/>#  (getchlib.icn).
<a name="74"/>#
<a name="75"/>#  procedure main(a)
<a name="76"/>#
<a name="77"/>#      # Simple pager/file searcher for UNIX systems.  Must be linked
<a name="78"/>#      # with itlib.icn and iscreen.icn.
<a name="79"/>#  
<a name="80"/>#      local intext, c, s
<a name="81"/>#  
<a name="82"/>#      # Open input file
<a name="83"/>#      intext := open(a[1],"r") | {
<a name="84"/>#  	ewrite("Can't open input file.")
<a name="85"/>#  	exit(1)
<a name="86"/>#      }
<a name="87"/>#  
<a name="88"/>#      # Initialize screen
<a name="89"/>#      clear()
<a name="90"/>#      print_screen(intext) | exit(0)
<a name="91"/>#  
<a name="92"/>#      # Prompt &amp; read input
<a name="93"/>#      repeat {
<a name="94"/>#  	iputs(igoto(getval("cm"), 1, getval("li")))
<a name="95"/>#  	emphasize()
<a name="96"/>#  	writes("More? (y/n or /search):")
<a name="97"/>#  	write_ce(" ")
<a name="98"/>#  	case c := getche() of {
<a name="99"/>#  	    "y" : print_screen(intext) | break
<a name="100"/>#  	    " " : print_screen(intext) | break
<a name="101"/>#  	    "n" : break
<a name="102"/>#  	    "q" : break
<a name="103"/>#  	    "/" : {
<a name="104"/>#  		iputs(igoto(getval("cm"), 1, getval("li")))
<a name="105"/>#  		emphasize()
<a name="106"/>#  		writes("Enter search string:")
<a name="107"/>#  		write_ce(" ")
<a name="108"/>#  		pattern := GetMoreInput()
<a name="109"/>#  		/pattern | "" == pattern &amp; next
<a name="110"/>#  		# For more complex patterns, use findre() (IPL findre.icn)
<a name="111"/>#  		if not find(pattern, s := !intext) then {
<a name="112"/>#  		    iputs(igoto(getval("cm"), 1, getval("li")))
<a name="113"/>#  		    emphasize()
<a name="114"/>#  		    write_ce("String not found.")
<a name="115"/>#  		    break
<a name="116"/>#  		}
<a name="117"/>#  		else print_screen(intext, s) | break
<a name="118"/>#  	    }
<a name="119"/>#  	}
<a name="120"/>#      }
<a name="121"/>#  
<a name="122"/>#      reset_tty()
<a name="123"/>#      write()
<a name="124"/>#      exit(0)
<a name="125"/>#
<a name="126"/>#  end
<a name="127"/>#  
<a name="128"/>#  procedure GetMoreInput(c)
<a name="129"/>#  
<a name="130"/>#      local input_string
<a name="131"/>#      static BS
<a name="132"/>#      initial BS := getval("bc") | "\b"
<a name="133"/>#  
<a name="134"/>#      /c := ""
<a name="135"/>#      if any('\n\r', chr := getch())
<a name="136"/>#      then return c
<a name="137"/>#      else {
<a name="138"/>#  	chr == BS &amp; fail
<a name="139"/>#  	writes(chr)
<a name="140"/>#  	input_string := getse(c || chr) | fail
<a name="141"/>#  	if any('\n\r', input_string)
<a name="142"/>#  	then fail else (return input_string)
<a name="143"/>#      }
<a name="144"/>#  
<a name="145"/>#  end
<a name="146"/>#  
<a name="147"/>#  procedure print_screen(f,s)
<a name="148"/>#  
<a name="149"/>#      if /s then
<a name="150"/>#  	begin := 1
<a name="151"/>#      # Print top line, if one is supplied
<a name="152"/>#      else {
<a name="153"/>#  	iputs(igoto(getval("cm"), 1, 1))
<a name="154"/>#  	write_ce(s ? tab(getval("co") | 0))
<a name="155"/>#  	begin := 2
<a name="156"/>#      }
<a name="157"/>#  
<a name="158"/>#      # Fill the screen with lines from f; clear and fail on EOF.
<a name="159"/>#      every i := begin to getval("li") - 1 do {
<a name="160"/>#  	iputs(igoto(getval("cm"), 1, i))
<a name="161"/>#  	if not write_ce(read(f) ? tab(getval("co") | 0)) then {
<a name="162"/>#  	    # Clear remaining lines on the screen.
<a name="163"/>#  	    every j := i to getval("li") do {
<a name="164"/>#  		iputs(igoto(getval("cm"), 1, j))
<a name="165"/>#  		iputs(getval("ce"))
<a name="166"/>#  	    }
<a name="167"/>#  	    iputs(igoto(getval("cm"), 1, i))
<a name="168"/>#  	    fail
<a name="169"/>#  	}
<a name="170"/>#      }
<a name="171"/>#      return
<a name="172"/>#  
<a name="173"/>#  end
<a name="174"/>#  
<a name="175"/>#  procedure write_ce(s)
<a name="176"/>#  
<a name="177"/>#      normal()
<a name="178"/>#      iputs(getval("ce")) |
<a name="179"/>#  	writes(repl(" ",getval("co") - *s))
<a name="180"/>#      writes(s)
<a name="181"/>#      return
<a name="182"/>#
<a name="183"/>#  end
<a name="184"/>#
<a name="185"/>############################################################################
<a name="186"/>#
<a name="187"/>#  Requires: UNIX
<a name="188"/>#
<a name="189"/>############################################################################
<a name="190"/>#
<a name="191"/>#  Links: itlib
<a name="192"/>#
<a name="193"/>############################################################################
<a name="194"/>
<a name="195"/>package ipl.getchlib
<a name="196"/>
<a name="197"/>import
<a name="198"/>   io(close, open, reads, stop,
<a name="199"/>      writes),
<a name="200"/>   ipl.iolib(getval)
<a name="201"/>
<a name="202"/>global c_cc, current_mode		# what mode are we in, raw or cooked?
<a name="203"/>record termio_struct(vintr,vquit,verase,vkill)
<a name="204"/>
<a name="205"/>procedure getse(s)
<a name="206"/>
<a name="207"/>    # getse() - like getche, only for strings instead of single chars
<a name="208"/>    #
<a name="209"/>    # This procedure *must* be used instead of read() if getch
<a name="210"/>    # and/or getche are to be used, since these put the current tty
<a name="211"/>    # line in raw mode.
<a name="212"/>    #
<a name="213"/>    # Note that the buffer can be initialized by calling getse with a
<a name="214"/>    # string argument.  Note also that, as getse now stands, it will
<a name="215"/>    # fail if the user backspaces over everything that has been input.
<a name="216"/>    # This change does not coincide with its behavior in previous ver-
<a name="217"/>    # sions.  It can be changed by commenting out the line "if *s &lt; 1
<a name="218"/>    # then fail" below, and uncommenting the line "if *s &lt; 1 then
<a name="219"/>    # next."
<a name="220"/>
<a name="221"/>    local chr
<a name="222"/>    static BS
<a name="223"/>    initial {
<a name="224"/>	BS := getval("bc") | "\b"
<a name="225"/>	unless getval("bs") then {
<a name="226"/>	    reset_tty()
<a name="227"/>	    stop("Your terminal can't backspace!")
<a name="228"/>	}
<a name="229"/>    }
<a name="230"/>
<a name="231"/>    /s := ""
<a name="232"/>    repeat {
<a name="233"/>	case chr := getch() | fail of {
<a name="234"/>	    "\r"|"\n"    : return s
<a name="235"/>	    c_cc.vkill   : {
<a name="236"/>		if *s &lt; 1 then next
<a name="237"/>		every 1 to *s do writes(BS)
<a name="238"/>		s := ""
<a name="239"/>	    }
<a name="240"/>	    c_cc.verase   : {
<a name="241"/>		# if *s &lt; 1 then next
<a name="242"/>		writes(BS) &amp; s := s[1:-1]
<a name="243"/>		if *s &lt; 1 then fail
<a name="244"/>	    }
<a name="245"/>	    default: writes(chr) &amp; s ||:= chr
<a name="246"/>	}
<a name="247"/>    }
<a name="248"/>
<a name="249"/>end
<a name="250"/>
<a name="251"/>
<a name="252"/>
<a name="253"/>procedure setup_tty()
<a name="254"/>    change_tty_mode("setup")
<a name="255"/>    return
<a name="256"/>end
<a name="257"/>
<a name="258"/>
<a name="259"/>
<a name="260"/>procedure reset_tty()
<a name="261"/>
<a name="262"/>    # Reset (global) mode switch to &amp;null to show we're in cooked mode.
<a name="263"/>    current_mode := &amp;null
<a name="264"/>    change_tty_mode("reset")
<a name="265"/>    return
<a name="266"/>
<a name="267"/>end
<a name="268"/>
<a name="269"/>
<a name="270"/>
<a name="271"/>procedure getch()
<a name="272"/>
<a name="273"/>    local chr
<a name="274"/>
<a name="275"/>    # If the global variable current_mode is null, then we have to
<a name="276"/>    # reset the terminal to raw mode.
<a name="277"/>    if /current_mode := 1 then
<a name="278"/>	setup_tty()
<a name="279"/>
<a name="280"/>    chr := reads()
<a name="281"/>    case chr of {
<a name="282"/>	c_cc.vintr : reset_tty() &amp; stop()  # shouldn't hard code this in
<a name="283"/>	c_cc.vquit  : reset_tty() &amp; stop()
<a name="284"/>	default : return chr
<a name="285"/>    }
<a name="286"/>
<a name="287"/>end
<a name="288"/>
<a name="289"/>
<a name="290"/>
<a name="291"/>procedure getche()
<a name="292"/>
<a name="293"/>    local chr
<a name="294"/>
<a name="295"/>    # If the global variable current_mode is null, then we have to
<a name="296"/>    # reset the terminal to raw mode.
<a name="297"/>    if /current_mode := 1 then
<a name="298"/>	setup_tty()
<a name="299"/>
<a name="300"/>    chr := reads()
<a name="301"/>    case chr of {
<a name="302"/>	c_cc.vintr  : reset_tty() &amp; stop()
<a name="303"/>	c_cc.vquit  : reset_tty() &amp; stop()
<a name="304"/>	default : writes(chr) &amp; return chr
<a name="305"/>    }
<a name="306"/>
<a name="307"/>end
<a name="308"/>
<a name="309"/>
<a name="310"/>
<a name="311"/>procedure change_tty_mode(switch)
<a name="312"/>
<a name="313"/>    # global c_cc   (global record containing values for kill, etc. chars)
<a name="314"/>    local get_term_params, i
<a name="315"/>    static reset_string
<a name="316"/>    initial {
<a name="317"/>	getval("li")    # check to be sure itlib is set up
<a name="318"/>	find("unix",map(&amp;features)) |
<a name="319"/>	    stop("change_tty_mode:  These routines must run under UNIX.")
<a name="320"/>	get_term_params := open("stty -g 2&gt;&amp;1","pr")
<a name="321"/>	reset_string := get_term_params.read()
<a name="322"/>	close(get_term_params)
<a name="323"/>	reset_string ? {
<a name="324"/>	    # tab upto the fifth field of the output of the stty -g cmd
<a name="325"/>	    # fields of stty -g seem to be the same as those of the
<a name="326"/>	    # termio struct, except that the c_line field is missing
<a name="327"/>	    every 1 to 4 do tab(find(":")+1)
<a name="328"/>	    c_cc := termio_struct("\x03","\x1C","\x08","\x15")
<a name="329"/>	    every i := 1 to 3 do {
<a name="330"/>		c_cc[i] := char(integer("16r"||tab(find(":"))))
<a name="331"/>		move(1)
<a name="332"/>	    }
<a name="333"/>	    c_cc[i+1] := char(integer("16r"||tab(0)))
<a name="334"/>	}
<a name="335"/>    }
<a name="336"/>
<a name="337"/>    if switch == "setup"
<a name="338"/>    then system("stty -echo raw")
<a name="339"/>    else system("stty "||reset_string)
<a name="340"/>
<a name="341"/>    return
<a name="342"/>
<a name="343"/>end
</pre></body></html>
