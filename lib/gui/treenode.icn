#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

import util, ipl.pdco

#
# This class represents a node in a {Tree} object.
#
class TreeNode()
   public 
      label,
      icon_paint,
      always_expandable_flag,
      depth,
      is_expanded_flag,
      children,
      draw_line,
      parent

   #
   # Traverse all the {TreeNode}s in this subtree, including this
   # {TreeNode}, in preorder ordering.
   #
   public traverse_all_preorder()
      coact(self)
      every (!children).traverse_all_preorder()
   end

   #
   # Traverse all the {TreeNode}s in this subtree, including this
   # {TreeNode}, in postorder ordering.
   #
   public traverse_all_postorder()
      every (!children).traverse_all_postorder()
      coact(self)
   end

   #
   # Traverse all the open {TreeNode}s in this subtree, including this
   # {TreeNode}, in preorder ordering.
   #
   public traverse_open_preorder()
      coact(self)
      if \self.is_expanded_flag then
         every (!children).traverse_open_preorder()
   end

   #
   # Traverse all open {TreeNode}s in this subtree, including this
   # {TreeNode}, in postorder ordering.
   #
   public traverse_open_postorder()
      if \self.is_expanded_flag then
         every (!children).traverse_open_postorder()
      coact(self)
   end

   #
   # Expand all the {TreeNode}s below this node.  Nodes with no children
   # are not expanded unless the force flag is set to 1.
   #
   public expand(force)
      local n
      every n := Seq{traverse_all_postorder()} do
         if \force | *n.children > 0 then
            n.is_expanded_flag := 1
   end

   #
   # This method expands the path from this node to the root,
   # thereby ensuring it is visible.  This node itself is not
   # expanded, only its parents.
   #
   public expand_to_root()
      local n
      n := self
      repeat {
         n := n.get_parent() | break
         n.set_expanded(&yes)
      }
   end

   #
   # Set the label for this node.
   #
   public set_label(x)
      self.label := x
      return self
   end

   #
   # Return the label
   #
   public get_label()
      return self.label
   end

   # Set the icons for this node, as three {Paint} instances.  The
   # first is displayed if the {TreeNode} is open and has children,
   # the second is displayed if the {TreeNode} is closed and has
   # children, and the third is displayed if the node has no children.
   #
   public set_icon_paint(i1, i2, i3)
      self.icon_paint := [i1, i2, i3]
      return self
   end

   #
   # Add the given {TreeNode} to this {TreeNode}'s list of children.
   # @param  The {TreeNode} to add.
   # @param i   The index to add at; if omitted then the new node
   # @          is appended to the end.
   #
   public add(n, i)
      /i := 0
      insert(self.children, i, n)
      n.parent := self
      return self
   end

   #
   # Get the index of the given child node
   #
   public get_index(n)
      return keyof(self.children, n)
   end

   #
   # Delete the given {TreeNode} from the children.
   #
   public remove(n)
      remove_index(get_index(n))
      return self
   end

   #
   # Remove the {TreeNode} at the given index from the list of children.
   # @param i    The index
   #
   public remove_index(i)
      self.children[i].parent := &null
      delete(self.children, i)
      return self
   end

   #
   # Get the parent node, or fail if there is none.
   #
   public get_parent()
      return \self.parent
   end

   #
   # Get the child nodes
   #
   public get_children()
      return children
   end

   #
   # This configures the {TreeNode} so that it is always treated as though it has children
   # for display purposes, event though it may in fact have no children.
   #
   public set_always_expandable(s)
      self.always_expandable_flag := check_flag(s)
      return self
   end

   #
   # Set the expanded flag.  Note that this will not update the GUI, to do that
   # call tree.tree_structure_changed() on the tree in which the node resides.
   #
   public set_expanded(s)
      self.is_expanded_flag := check_flag(s)
      return self
   end
      
   #
   # Toggle the opened status of the {TreeNode}. Note that this will not update the GUI, to do that
   # call tree.tree_structure_changed() on the tree in which the node resides.
   #
   public toggle_expanded()
      self.is_expanded_flag := toggle_flag(self.is_expanded_flag)
      return self
   end

   #
   # Succeed iff the node is opened
   #
   public is_expanded()
      return \is_expanded_flag
   end

   #
   # Clear all the children
   #
   public clear_children()
      children := []
      return self
   end

   public new()
      children := []
      return
   end
end

