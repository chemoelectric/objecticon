package parser

import io, util

class Preprocessor(Connectable)
   private
      preproc_sym_table,preproc_if_stack,preproc_file_stack,preproc_if_state,
      preproc_file,preproc_filename,preproc_line,
      preproc_nest_level,preproc_include_name,
      preproc_include_set,preproc_print_filename,
      preproc_err_count,preproc_encoding,preproc_print_encoding

   public static const 
      DEFAULT_SYMBOLS

   private static init()
      local s
      DEFAULT_SYMBOLS := table()
      # reverse engineer the predefined symbols list from our predefined symbols
      every s := &features do {
         DEFAULT_SYMBOLS[case s of {
            "Object Icon": "_OBJECT_ICON"
            "V2": "_V2"
            "keyboard functions": "_KEYBOARD_FUNCTIONS"
            "JPEG images": "_JPEG"
            "PNG images": "_PNG"
            "SSL networking": "_SSL"
            "MS Win32":"_MS_WIN32"
            "UNIX":"_UNIX"
            "POSIX":"_POSIX"
            "ASCII":"_ASCII"
            "co-expressions":"_CO_EXPRESSIONS"
            "dynamic loading":"_DYNAMIC_LOADING"
            "event montoring":"_EVENT_MONITOR"
            "large integers":"_LARGE_INTEGERS"
            "multiple programs":"_MULTITASKING"
            "pipes":"_PIPES"
            "system function":"_SYSTEM_FUNCTION"
            "graphics":"_GRAPHICS"
            "X Windows":"_X_WINDOW_SYSTEM"
         }] := "1"
      }
   end

   #
   # Preprocess a file to a string.
   #
   public preprocess(fname, predefined_syms)
      local sb
      sb := RamStream()
      every sb.out(preprocess_gen(fname, predefined_syms) || "\n")
      return sb.done()
   end

   #
   # Preprocesses a file, generating output lines.
   #
   public preprocess_gen(fname, predefined_syms)
      local line
      preproc_new(fname, predefined_syms) | fail
      suspend preproc_sync_lines()      
      while line := preproc_read() do {
         # line will be &null if we have just come back from an include.  If so,
         # produce a #line directive.
         if /line then
            suspend preproc_sync_lines()      
         else line ? {
            if match("#line") then {
               move(1)
               suspend preproc_scan_directive()
            } else {
               preproc_space()
               if ="$" & any(&letters ++ &digits ++ ' \t\f\r') then {
                  suspend preproc_scan_directive()
               } else {
                  move(1)
                  suspend preproc_scan_text()
               }
            }
         }
      }
      close(\preproc_file)
      preproc_done()
   end

   #
   # a_Initializes the preprocessor "object".
   #
   private preproc_new(fname,predefined_syms)
      preproc_sym_table := \predefined_syms | copy(DEFAULT_SYMBOLS)
      preproc_if_stack := []
      preproc_file_stack := []
      preproc_include_set := set(fname)
      preproc_if_state := &null
      preproc_filename := preproc_include_name := fname
      preproc_line := 0
      preproc_print_filename := &null
      preproc_print_encoding := &null
      preproc_nest_level := 0
      preproc_err_count := 0
      preproc_encoding := "ASCII"
      if not(preproc_file := open(fname)) then {
         err("cannot open " || image(fname))
         fail
      }
      return
   end

   #
   # Clears the values of certain space-consuming variables.
   #
   private preproc_done()
      preproc_sym_table := preproc_if_stack := preproc_file_stack :=
         preproc_filename := preproc_print_filename := preproc_print_encoding :=
         preproc_encoding := preproc_file := preproc_include_set := &null
      return
   end

   #
   # a_Scans an encoding identifier.
   #
   private preproc_get_encoding()
      suspend any(&letters) & tab(many(&letters ++ &digits ++ '-'))
   end

   #
   # a_Scans a preprocessor directive.  This method fails or returns
   # either a blank line or a #line directive.
   #
   private preproc_scan_directive()
      local sym,value,new_file,new_filename,new_line,new_encoding,old,preproc_command,old_if_state,fname
      preproc_space()
      preproc_command := preproc_word()
      if \preproc_if_state then {
         if match("if",preproc_command) then {
            preproc_command := "$if"
         }
      }
      preproc_space()
      case preproc_command of {
         "define": {
            if /preproc_if_state then {
               if sym := preproc_word() &
                  value := preproc_scan_define_value() then 
               {
                  if \ (old := preproc_sym_table[sym]) ~=== value then {
                     err("redefinition of " || sym || " = " ||
                                   old)
                  } else {
                     preproc_sym_table[sym] := value
                  }
               } else {
                  err()
               }
               return ""
            }
         }
         "undef": {
            if /preproc_if_state then {
               if sym := preproc_word() & preproc_at_end() then {
                  delete(preproc_sym_table,sym)
               } else {
                  err()
               }
               return ""
            }
         }
         "load": {
            if /preproc_if_state then {
               if sym := preproc_word() &
                  preproc_opt_space() &
                  fname := preproc_qword() & *fname > 0 & preproc_at_end() then 
               {
                  if value := image(Files.file_to_string(Files.path_find(fname, 
                                                         "OIINCL",
                                                          FilePath(preproc_filename).parent().str()))) then 
                  {
                     if \ (old := preproc_sym_table[sym]) ~=== value then {
                        err("redefinition of " || sym || " = " ||
                                      old)
                     } else {
                        preproc_sym_table[sym] := value
                     }
                  } else {
                     err("cannot open " || image(fname))
                  }
               } else {
                  err()
               }
               return ""
            }
         }
         "uload": {
            if /preproc_if_state then {
               if sym := preproc_word() &
                  preproc_opt_space() &
                  fname := preproc_qword() & *fname > 0 & preproc_at_end() then 
               {
                  if value := "u" || image(Files.file_to_string(Files.path_find(fname, 
                                                                "OIINCL",
                                                                FilePath(preproc_filename).parent().str()))) then 
                  {
                     if \ (old := preproc_sym_table[sym]) ~=== value then {
                        err("redefinition of " || sym || " = " ||
                                      old)
                     } else {
                        preproc_sym_table[sym] := value
                     }
                  } else {
                     err("cannot open " || image(fname))
                  }
               } else {
                  err()
               }
               return ""
            }
         }
         "ifdef" | "ifndef": {
            push(preproc_if_stack,preproc_if_state)
            if sym := preproc_word() & preproc_at_end() then {
               if /preproc_if_state then {
                  value := (\preproc_sym_table[sym] & &null) | "false"
                  if match("n",preproc_command,3) then {
                     value := (\value & &null) | "false"
                  }
                  preproc_if_state := value
               } else {
                  preproc_if_state := "off"
               }
            } else {
               preproc_if_state := "off"
               err()
            }

            if /preproc_if_state then
               return ""
            else
               fail
         }
         "$if": {    # handles if... command in "if'd-out" code
            push(preproc_if_stack,preproc_if_state)
            preproc_if_state := "off"
            fail
         }
         "elsifdef" | "elsifndef" : {
            if sym := preproc_word() & preproc_at_end() then {
               if *preproc_if_stack <= preproc_nest_level then {
                  err("no corresponding $if...")
               } else {
                  if \preproc_if_state == "false" then {
                     value := (\preproc_sym_table[sym] & &null) | "false"
                     if match("n",preproc_command,6) then {
                        value := (\value & &null) | "false"
                     }
                     preproc_if_state := value
                  } else {
                     preproc_if_state := "off"
                  }
               }
            } else {
               err()
            }
            if /preproc_if_state then
               return preproc_sync_lines()
            else
               fail
         }
         "else": {
            if preproc_at_end() then {
               if *preproc_if_stack <= preproc_nest_level then {
                  err("no corresponding $if...")
               } else {
                  preproc_if_state := {
                     case preproc_if_state of {
                        "false": &null
                        "off": "off"
                        default: "false"
                     }
                  }
               }
            } else {
               err()
            }
            if /preproc_if_state then
               return preproc_sync_lines()
            else
               fail
         }
         "endif": {
            old_if_state := preproc_if_state
            if preproc_at_end() then {
               (*preproc_if_stack >= preproc_nest_level &
                preproc_if_state := pop(preproc_if_stack)) |
                  err("no corresponding $if...")
            } else {
               *preproc_if_stack >= preproc_nest_level &
                  preproc_if_state := pop(preproc_if_stack)
               err()
            }
            if /preproc_if_state then {
               if /old_if_state then
                  return ""
               else
                  return preproc_sync_lines()
            } else
               fail
         }
         "include": {
            if /preproc_if_state then {
               if sym := preproc_qword() & *sym > 0 & preproc_at_end() then {
                  if member(preproc_include_set,sym) then {
                     err("circular reference to " || image(sym))
                  } else {
                     if new_file := open(new_filename := 
                                         Files.path_find(sym, 
                                                         "OIINCL",
                                                         FilePath(preproc_filename).parent().str()))
                     then {
                        every push(preproc_file_stack,
                                   preproc_encoding|preproc_file|preproc_filename|
                                   preproc_include_name|preproc_line|
                                   preproc_nest_level)
                        preproc_filename := new_filename
                        preproc_include_name := sym
                        preproc_file := new_file
                        preproc_line := 0
                        preproc_encoding := "ASCII"
                        preproc_nest_level := *preproc_if_stack
                        insert(preproc_include_set,sym)
                     } else {
                        err("cannot open " || image(sym))
                     }
                  }
               } else {
                  err()
               }
               return preproc_sync_lines()
            }
         }
         "line": {
            if new_line := integer(tab(many(&digits))) &
               preproc_opt_space() &
               (new_filename := preproc_qword() | &null) \ 1 &
               (/new_filename | *new_filename > 0) \ 1 &
               preproc_opt_space() &
               (new_encoding := preproc_get_encoding() | &null) \ 1 &
               preproc_at_end() then 
            {
               preproc_filename := Files.path_find(\new_filename, 
                                                   &null,
                                                   FilePath(preproc_filename).parent().str()) | \new_filename
               preproc_encoding := \new_encoding
               preproc_line := new_line - 1
            } else {
               err()
            }
            if /preproc_if_state then
               return preproc_sync_lines()
         }
         "error": {
            if /preproc_if_state then {
               preproc_space()
               err(trim(tab(find("#") | 0),' \t\f\r'))
               return ""
            }
         }
         "encoding": {
            if /preproc_if_state then {
               if sym := preproc_get_encoding() &
                  preproc_at_end() then
                  preproc_encoding := sym
               else
                  err()
               return preproc_sync_lines()
            }
         }
         "ITRACE": {
            if /preproc_if_state then {
               if value := integer(tab(many(&digits ++ '-'))) &
                  preproc_at_end() then 
               {
                  &trace := value
               } else {
                  err()
               }
               return ""
            }
         }
         default: {
            if /preproc_if_state then {
               err("unknown preprocessor directive:" || preproc_command)
               return ""
            }
         }
      }
   end

   #
   # a_Scans and make substitutions in a text line.
   #
   private preproc_scan_text(done_set)
      local q,result,p,interesting_in_quotes,ident,value,t
      if /preproc_if_state then {
         if *preproc_sym_table > 0 then {
            &pos := q := 1
            result := ""
            while tab(upto('#"\'_' ++ &letters)) do {
               case move(1) of {
                  "#": {
                     move(-1)
                     tab(0)
                  }
                  "\"" | "'": {
                     interesting_in_quotes := '\\' ++ &subject[&pos - 1]
                     repeat {
                        while tab(upto(interesting_in_quotes)) do {
                           case move(1) of {
                              "\\": move(1)
                              default: {
                                 break break
                              }
                           }
                        }
                        suspend if q = 1 then .&subject else result || &subject[q:0]
                        if not match("_",,-1) then {
                           break
                        }
                        t := preproc_read() | fail
                        # If we've just come back from a $include, t will be &null, so set it to
                        # "#line ..." (this is bound to be a nonsense result anyway, since we're in
                        # the middle of a multi-line string).
                        /t := preproc_sync_lines()
                        &subject := t
                        result := ""
                     }
                  }
                  default: {
                     move(-1)
                     p := &pos
                     ident := tab(many(&letters ++ &digits ++ '_'))
                     if value := \preproc_sym_table[ident] then {
                        if /done_set |
                        {type(done_set) == "string" &
                            done_set := set(done_set)
                         not member(done_set,ident)} then {
                            value ? value :=
                               preproc_scan_text(insert(copy(\done_set),
                                                        ident) | ident)
                            result ||:= &subject[q:p] || value
                            q := &pos
                         }
                     }
                  }
               }
            }
            suspend if q = 1 then .&subject else result || &subject[q:0]
         }
         else {
            suspend .&subject
         }
      }
   end

   #
   # Reads an input line.  Manages end-of-file and reverting to including
   # file if appropriate, failing at end-of-input.
   #
   private preproc_read()
      local result
      until result := read(preproc_file) do {
         if *preproc_if_stack ~= preproc_nest_level then {
            err("$if(s) without $endif(s): " ||
                          *preproc_if_stack - preproc_nest_level)
            until *preproc_if_stack <= preproc_nest_level do
               preproc_if_state := pop(preproc_if_stack)
         }
         close(preproc_file)
         preproc_file := &null
         delete(preproc_include_set,preproc_include_name)
         (preproc_nest_level := pop(preproc_file_stack) &
          preproc_line := pop(preproc_file_stack) &
          preproc_include_name := pop(preproc_file_stack) &
          preproc_filename := pop(preproc_file_stack) &
          preproc_file := pop(preproc_file_stack) &
          preproc_encoding := pop(preproc_file_stack)) | fail
         return &null
      }
      preproc_line +:= 1
      return result
   end

   #
   # a_Scans an identifier.
   #
   private preproc_word()
      suspend any(&letters ++ '_') & tab(many(&letters ++ &digits ++ '_'))
   end

   #
   # a_Scans a possibly-quoted word (e.g. a file name).
   #
   private preproc_qword()
      suspend 2(="\"",
                tab(find("\"")),
                move(1)) |
         preproc_word()
   end

   #
   # a_Scans the value of a $define.
   #
   private preproc_scan_define_value()
      local q,interesting_in_quotes

      if ="(" then {
         fail      # "$define name(" is specifically prohibited; needs whitespace
      }
      preproc_space()
      q := &pos
      (while tab(upto('#"\'')) do {
         case move(1) of {
            "#": {
               move(-1)
               break
            }
            default: {
               interesting_in_quotes := '\\' ++ &subject[&pos - 1]
               repeat {
                  while tab(upto(interesting_in_quotes)) do {
                     case move(1) of {
                        "\\": move(1)
                        default: {
                           break break
                        }
                     }
                  }
                  fail # end of line inside quotes!!
               }
            }
         }
      }) | tab(0)
      return trim(&subject[q:&pos],' \t\f\r')
   end

   #
   # a_Scans white space.
   #
   private preproc_space()
      suspend tab(many(' \t\f\r'))
   end

   #
   # a_Scans optional white space.
   #
   private preproc_opt_space()
      local i
      suspend if i := many(' \t\f\r') then tab(i) else ""
   end

   #
   # Tests for &pos at the logical end of a preprocessor directive.
   #
   private preproc_at_end()
      preproc_space()
      return pos(0) | match("#")
   end

   #
   # Determines if a "#lines" is called for and generates one if so.
   #
   private preproc_sync_lines()
      if (preproc_encoding ~=== preproc_print_encoding) |
         (preproc_filename ~=== preproc_print_filename) then 
      {
         preproc_print_encoding := preproc_encoding
         preproc_print_filename := preproc_filename
         return "#line " || (preproc_line + 1) || " \"" || preproc_filename || "\" " || preproc_encoding
      }
      return "#line " || (preproc_line + 1)
   end

   private err(msg)
      /msg := "Invalid preprocessor line"
      fire("error", ErrorDetail(FilePath(preproc_filename).canonical().str(), preproc_line, msg))
   end
end
