#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package xml

import ipl.scan

class Tag(Node)
   public const
      attributes
   private readable
      name,
      closed,
      empty

   #
   # Set the name of the tag, which is converted to upper case.  Any
   # leading "/" should be omitted.
   #
   public set_name(s) 
      name := map(s, &lcase, &ucase)
      return self
   end

   #
   # Succeed if the given tag is a matching closing tag for this tag.
   #
   public balances(other)
      return \other.closed & (name == other.name)
   end

   #
   # Indicate that the tag is a closing tag, ie has a leading "/"
   #
   public set_closed()
      closed := 1
      return self
   end

   #
   # Indicate that the tag is an empty tag.
   #
   public set_empty()
      empty := 1
      return self
   end

   #
   # Set an attribute for this tag.
   #
   public set_attribute(key, value)
      attributes[map(key, &lcase, &ucase)] := value
      return self
   end

   public new()
      cast(self,Node).new()
      self.attributes := table()
      return
   end
end


class HtmlParser()
   private 
      doc,
      utf8_flag

   public static const
      HTML_IDINTRO,
      HTML_IDCHARS,
      HTML_KEYCHARS,
      HTML_VALCHARS, 
      HTML_DELIM,
      HTML_SPACE,
      HTML_STANDALONE,
      HTML_AUTOCLOSE,
      HTML_ENTITIES,
      HTML_PUBID_CHAR

   private static init()
      HTML_SPACE := '\x20\x09\x0D\x0A'
      HTML_IDINTRO := 'A-Za-z'
      HTML_IDCHARS := 'A-Za-z0-9.\-'
      HTML_KEYCHARS := 'A-Za-z0-9_'
      HTML_VALCHARS := &ascii -- ' \t\n\r>'
      HTML_DELIM := '\"\''
      HTML_PUBID_CHAR := ' \n\rA-Za-z0-9\-\'()+,./:=?;!*#@$_%'
      HTML_STANDALONE := set("IMG", "BR", "HR", "META", "BASE", "INPUT", "AREA", 
                             "BASEFONT", "BGSOUND", "COL", "ISINDEX", "PARAM",
                             "LINK", "NEXTID", "SPACER", "WBR")

      HTML_AUTOCLOSE := table(,
                              "LI", set("LI"),
                              "P", set("P"),
                              "A", set("A"),
                              "DD", set("DD", "DT"),
                              "DT", set("DT", "DD"),
                              "TR", set("TR", "THEAD", "TBODY", "TFOOT"),
                              "TD", set("TD", "TR", "TH", "THEAD", "TBODY", "TFOOT"),
                              "TH", set("TH", "TR", "TD", "THEAD", "TBODY", "TFOOT"),
                              "THEAD", set("THEAD", "TFOOT", "TBODY"),
                              "TBODY", set("THEAD", "TFOOT", "TBODY"),
                              "TFOOT", set("THEAD", "TFOOT", "TBODY"),
                              "COLGROUP", set("COLGROUP", "TH", "TR", "TD", "TBODY", "TFOOT", "THEAD"),
                              "OPTION", set("OPTION"))

      HTML_ENTITIES := table(,
                             "quot", 34, "amp", 38, "apos", 39, "lt", 60, "gt", 62, "OElig", 338,
                             "oelig", 339, "Scaron", 352, "scaron", 353, "Yuml", 376, "circ", 710,
                             "tilde", 732, "ensp", 8194, "emsp", 8195, "thinsp", 8201, "zwnj", 8204,
                             "zwj", 8205, "lrm", 8206, "rlm", 8207, "ndash", 8211, "mdash", 8212,
                             "lsquo", 8216, "rsquo", 8217, "sbquo", 8218, "ldquo", 8220, "rdquo", 8221,
                             "bdquo", 8222, "dagger", 8224, "Dagger", 8225, "permil", 8240, "lsaquo", 8249,
                             "rsaquo", 8250, "euro", 8364, "fnof", 402, "Alpha", 913, "Beta", 914,
                             "Gamma", 915, "Delta", 916, "Epsilon", 917, "Zeta", 918, "Eta", 919,
                             "Theta", 920, "Iota", 921, "Kappa", 922, "Lambda", 923, "Mu", 924,
                             "Nu", 925, "Xi", 926, "Omicron", 927, "Pi", 928, "Rho", 929,
                             "Sigma", 931, "Tau", 932, "Upsilon", 933, "Phi", 934, "Chi", 935,
                             "Psi", 936, "Omega", 937, "alpha", 945, "beta", 946, "gamma", 947,
                             "delta", 948, "epsilon", 949, "zeta", 950, "eta", 951, "theta", 952,
                             "iota", 953, "kappa", 954, "lambda", 955, "mu", 956, "nu", 957,
                             "xi", 958, "omicron", 959, "pi", 960, "rho", 961, "sigmaf", 962,
                             "sigma", 963, "tau", 964, "upsilon", 965, "phi", 966, "chi", 967,
                             "psi", 968, "omega", 969, "thetasym", 977, "upsih", 978, "piv", 982,
                             "bull", 8226, "hellip", 8230, "prime", 8242, "Prime", 8243, "oline", 8254,
                             "frasl", 8260, "weierp", 8472, "image", 8465, "real", 8476, "trade", 8482,
                             "alefsym", 8501, "larr", 8592, "uarr", 8593, "rarr", 8594, "darr", 8595,
                             "harr", 8596, "crarr", 8629, "lArr", 8656, "uArr", 8657, "rArr", 8658,
                             "dArr", 8659, "hArr", 8660, "forall", 8704, "part", 8706, "exist", 8707,
                             "empty", 8709, "nabla", 8711, "isin", 8712, "notin", 8713, "ni", 8715,
                             "prod", 8719, "sum", 8721, "minus", 8722, "lowast", 8727, "radic", 8730,
                             "prop", 8733, "infin", 8734, "ang", 8736, "and", 8743, "or", 8744,
                             "cap", 8745, "cup", 8746, "int", 8747, "there4", 8756, "sim", 8764,
                             "cong", 8773, "asymp", 8776, "ne", 8800, "equiv", 8801, "le", 8804,
                             "ge", 8805, "sub", 8834, "sup", 8835, "nsub", 8836, "sube", 8838,
                             "supe", 8839, "oplus", 8853, "otimes", 8855, "perp", 8869, "sdot", 8901,
                             "lceil", 8968, "rceil", 8969, "lfloor", 8970, "rfloor", 8971, "lang", 9001,
                             "rang", 9002, "loz", 9674, "spades", 9824, "clubs", 9827, "hearts", 9829,
                             "diams", 9830, "nbsp", 160, "iexcl", 161, "cent", 162, "pound", 163,
                             "curren", 164, "yen", 165, "brvbar", 166, "sect", 167, "uml", 168,
                             "copy", 169, "ordf", 170, "laquo", 171, "not", 172, "shy", 173,
                             "reg", 174, "macr", 175, "deg", 176, "plusmn", 177, "sup2", 178,
                             "sup3", 179, "acute", 180, "micro", 181, "para", 182, "middot", 183,
                             "cedil", 184, "sup1", 185, "ordm", 186, "raquo", 187, "frac14", 188,
                             "frac12", 189, "frac34", 190, "iquest", 191, "Agrave", 192, "Aacute", 193,
                             "Acirc", 194, "Atilde", 195, "Auml", 196, "Aring", 197, "AElig", 198,
                             "Ccedil", 199, "Egrave", 200, "Eacute", 201, "Ecirc", 202, "Euml", 203,
                             "Igrave", 204, "Iacute", 205, "Icirc", 206, "Iuml", 207, "ETH", 208,
                             "Ntilde", 209, "Ograve", 210, "Oacute", 211, "Ocirc", 212, "Otilde", 213,
                             "Ouml", 214, "times", 215, "Oslash", 216, "Ugrave", 217, "Uacute", 218,
                             "Ucirc", 219, "Uuml", 220, "Yacute", 221, "THORN", 222, "szlig", 223,
                             "agrave", 224, "aacute", 225, "acirc", 226, "atilde", 227, "auml", 228,
                             "aring", 229, "aelig", 230, "ccedil", 231, "egrave", 232, "eacute", 233,
                             "ecirc", 234, "euml", 235, "igrave", 236, "iacute", 237, "icirc", 238,
                             "iuml", 239, "eth", 240, "ntilde", 241, "ograve", 242, "oacute", 243,
                             "ocirc", 244, "otilde", 245, "ouml", 246, "divide", 247, "oslash", 248,
                             "ugrave", 249, "uacute", 250, "ucirc", 251, "uuml", 252, "yacute", 253,
                             "thorn", 254, "yuml", 255)
   end

   #
   # Parse the string s returning an HtmlDocument object.
   #
   public parse(s)
      local i, node
      doc := HtmlDocument()

      utf8_flag := if type(s) == "ucs" then 1 else &null

      s ? {
         repeat {
            move_to_node()

            if pos(0) then {
               #
               # No opening node found, so put whole in html tags and retry
               #
               return parse("<html>" || s || "</html>")
            }

            i := &pos
            # parse_node() must succeed since move_to_node() didn't
            # leave us at pos(0)
            node := parse_node()

            if is(node, DocType | Comment) then
               doc.add(node)
            else if is(node, Tag) then {
               if /node.closed & (node.name == "HTML") then {
                  #
                  # Found the html start point, so parse and return that node.
                  #
                  doc.add(parse_element(node))
                  return doc
               } else {
                  #
                  # Bad structure, so put html tags around it and start again.
                  #
                  return parse(s[1:i] || "<html>" || s[i:0] || "</html>")
               }
            }
         }
      }
   end

   #
   # Parse the current input into an {Node}
   #
   private parse_node()
      if match(u"<!DOCTYPE") then
         return parse_doctype()
      if match(u"<!") then
         return parse_comment()
      if match(u"<") then
         return parse_tag()
   end

   #
   # Parse and return an Element, given the starting tag
   #
   private parse_element(start_tag)
      local res, i, node, n

      res := HtmlElement()

      res.name := start_tag.name
      res.attributes := start_tag.attributes

      case string(start_tag.name) of {
         "PLAINTEXT":
            res.add("" ~== remove_entities(tab(0)))
         "XMP" | "SCRIPT" | "STYLE": {
            if /start_tag.empty then
               res.add("" ~== move_past_end_tag(start_tag))
         }
         "TITLE": {
            if /start_tag.empty then
               res.add("" ~== remove_entities(move_past_end_tag(start_tag)))
         }
         default: {
            if not(\start_tag.empty | is_standalone_tag(start_tag.name)) then {
               repeat {
                  res.add("" ~== remove_entities(move_to_node()))
                  if pos(0) then
                     break

                  i := &pos
                  node := parse_node(res) | break

                  if is(node, Tag) then {
                     if start_tag.balances(node) then 
                        break

                     if should_close_tag(start_tag, node) then {
                        #
                        # Auto-close the tag, for example we have encountered something like :-
                        # <td> .... <tr>
                        # The opening <tr> implicitly closes the <td>.  The <tr> needs to be
                        # rescanned, so tab back.
                        #
                        &pos := i
                        break
                     }
                     else if /node.closed then
                        res.add(n := parse_element(node))
                  } else {
                     #
                     # It's either a coment, or something else; just add it to the list of children
                     #
                     res.add(node)
                  }            
               }
            }
         }
      }

      return res
   end

   #
   # DOCTYPE
   #
   private parse_doctype()
      local res

      res := DocType()
      =u"<!DOCTYPE" | fail

      tab(upto(HTML_IDINTRO))
      res.name := tab(many(HTML_IDCHARS))

      tab(many(HTML_SPACE))
      if =u"SYSTEM" then {
         res.external_id := ExternalID()
         tab(many(HTML_SPACE))
         res.external_id.system_id := parse_system_literal()
      } else if =u"PUBLIC" then {
         res.external_id := ExternalID()
         tab(many(HTML_SPACE))
         res.external_id.public_id := parse_pubid_literal()
         tab(many(HTML_SPACE))
         res.external_id.system_id := parse_system_literal()
      }
      tab(upto('>')) | fail
      move(1)
      return res
   end

   private parse_system_literal()
      local c, res
      any('\'\"') | fail
      c := move(1)
      res := tab(upto(c)) | fail
      move(1)
      return res
   end

   private parse_pubid_literal()
      local c, res, t
      if any('\'') then
         t := HTML_PUBID_CHAR -- '\''
      else if any('\"') then
         t := HTML_PUBID_CHAR
      else
         fail
      c := move(1)
      res := tab(many0(t))  # many0() so that res may be an empty string
      =c | fail
      return res
   end

   #
   # Comment - SGML style parsing; different from xml comment in that you can
   # have a legal comment like <!-- abc -- def -->
   # see http://htmlhelp.com/reference/wilbur/misc/comment.html
   #
   private parse_comment()
      local res, s, t
      res := Comment()
      =u"<!" | fail
      s := move(0)  # Empty string, same type as &subject
      repeat {
         tab(upto('->'))
         if =u">" then
            break
         =u"--" | fail
         t := tab(find(u"--")) | fail
         =u"--"
         s ||:= t
      }
      res.comment := s
      return res
   end

   #
   # Normal tag
   #
   private parse_tag()
      local res, key, c, s, value

      res := Tag()
      =u"<" | fail
      if =u"/" then
         res.set_closed()
      s := (any(HTML_IDINTRO) & tab(many(HTML_IDCHARS))) | fail
      res.set_name(s)
      repeat {
         tab(upto(HTML_KEYCHARS ++ '/>'))
         if =u"/>" then {
            res.set_empty()
            break
         }
         if =u">" then
            break

         key := tab(many(HTML_KEYCHARS)) | break

         tab(upto(HTML_VALCHARS ++ '>='))

         if =u"=" then {
            tab(upto(HTML_VALCHARS ++ HTML_DELIM))
            if any(HTML_DELIM) then {
               c := move(1)
               s := tab(upto(c) | 0)
               move(1)
            } else
               s := tab(many(HTML_VALCHARS)) | break
            value := remove_entities(s)
         } else
            # See http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.3.4.2
            value := map(key)

         res.set_attribute(key, value)
      }

      return res
   end

   # Move past the next end tag to match the given start tag,
   # regardless of intervening content
   #
   private move_past_end_tag(start_tag)
      local s, i, t
      s := ""
      repeat {
         s ||:= tab(upto('<') | 0)
         if pos(0) then
            break
         i := &pos
         if t := parse_tag() & start_tag.balances(t) then
            break
         &pos := i
         s ||:= move(1)
      }
      return s
   end

   #
   # Move to the next node (tag, comment, doctype), or end of file.
   #
   private move_to_node()
      local s, i
      s := ""
      repeat {
         s ||:= tab(upto('<') | 0)
         if pos(0) then
            break
         i := &pos
         if parse_node() then {
            #
            # Found a valid node, so tab back and break
            #
            &pos := i
            break
         }
         #
         # Not a valid node, so tab back and continue
         #
         &pos := i
         s ||:= move(1)
      }

      return s
   end

   #
   # Parse an entity character, eg "&#xff;", returning the integer char number.
   #
   private parse_entity()
      local i
      =u"&"
      i := (if any('#') then {
         move(1)
         if any('x') then {
            move(1)
            integer("16r" || tab(many('0-9a-fA-F')))
         } else
            integer(tab(many(&digits)))
      } else
         member(HTML_ENTITIES, string(tab(many(&ucase ++ &lcase))))) | fail
      =u";" | fail
      return i
   end

   #
   # Remove the entity characters from a string.
   #
   private remove_entities(s)
      local res, i, j
      res := ""
      s ? repeat {
         res ||:= tab(upto('&') | 0)
         if pos(0) then
            break
         i := &pos
         res ||:= if j := parse_entity() then {
            if \utf8_flag then
               uchar(j | 63)
            else
               char(j | 63)
         } else {
            &pos := i
            move(1)
         }
      }
      return res
   end

   #
   # Return the document being parsed.
   #
   public get_document()
      return doc
   end

   #
   # Succeed if and only if the tag name is a standalone tag, ie it has no
   # matching closing tag.
   #
   public static is_standalone_tag(name)
      return member(HTML_STANDALONE, string(name))
   end

   #
   # Succeed if and only if the tag implicitly closes when the other
   # tag (which may be a closing tag) is encountered at the same level.
   #
   public static should_close_tag(tag, other)
      local t
      if t := member(HTML_AUTOCLOSE, string(tag.name)) then
         return \other.closed | member(t, string(other.name))
   end
end
