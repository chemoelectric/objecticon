<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>parser.icn</title></head><body><pre>
<a name="1"/>package parser
<a name="2"/>
<a name="3"/>import util, io
<a name="4"/>
<a name="5"/>final class ErrorDetail()
<a name="6"/>   public const src, line, msg
<a name="7"/>
<a name="8"/>   # Does the same as abbreviate() in tmain.c
<a name="9"/>   private static abbreviate(name)
<a name="10"/>      local l
<a name="11"/>      l := FilePath(name).get(-1)
<a name="12"/>      return if Files.access(name, Access.R_OK) then {
<a name="13"/>         if Files.standard_case_cmp(FilePath(l).canonical().str(), name) = 0 then
<a name="14"/>            l
<a name="15"/>         else
<a name="16"/>            name
<a name="17"/>      } else
<a name="18"/>         l
<a name="19"/>   end
<a name="20"/>
<a name="21"/>   # Produce a string version of the message in the same form as
<a name="22"/>   # produced by the compiler, including embedded filename and line
<a name="23"/>   # no.
<a name="24"/>   #
<a name="25"/>   public esc_str()
<a name="26"/>      local s
<a name="27"/>      s := if \src then {
<a name="28"/>         if FilePath(src).is_absolute() &amp; line &gt; 0 then
<a name="29"/>            Files.begin_link(src, line) || "File " || abbreviate(src) || "; "
<a name="30"/>         else
<a name="31"/>            "File " || abbreviate(src) || "; "            
<a name="32"/>      } else
<a name="33"/>         ""
<a name="34"/>      s ||:= "Line " || line
<a name="35"/>      if \src then
<a name="36"/>         s ||:= Files.end_link()
<a name="37"/>      s ||:= " # " || msg
<a name="38"/>      return s
<a name="39"/>   end
<a name="40"/>
<a name="41"/>   #
<a name="42"/>   # Produce a string version of the message in the same form
<a name="43"/>   # as produced by the compiler.
<a name="44"/>   #
<a name="45"/>   public str()
<a name="46"/>      local s
<a name="47"/>      s := if \src then
<a name="48"/>         "File " || abbreviate(src) || "; "
<a name="49"/>      else
<a name="50"/>         ""
<a name="51"/>      s ||:= "Line " || line || " # " || msg
<a name="52"/>      return s
<a name="53"/>   end
<a name="54"/>
<a name="55"/>   package new(src, line, msg)
<a name="56"/>      self.src := src
<a name="57"/>      self.line := line
<a name="58"/>      self.msg := msg
<a name="59"/>      return
<a name="60"/>   end
<a name="61"/>end
<a name="62"/>
<a name="63"/>class Parser(Connectable)
<a name="64"/>   private
<a name="65"/>      first_err, pp, lex, yy
<a name="66"/>
<a name="67"/>   public static const 
<a name="68"/>      PREPROCESSOR_ERROR_EVENT, 
<a name="69"/>      LEXER_ERROR_EVENT,
<a name="70"/>      PARSER_ERROR_EVENT
<a name="71"/>
<a name="72"/>   private static init()
<a name="73"/>      PREPROCESSOR_ERROR_EVENT := "preprocessor error"
<a name="74"/>      LEXER_ERROR_EVENT := "lexer error"
<a name="75"/>      PARSER_ERROR_EVENT := "parser error"
<a name="76"/>   end
<a name="77"/>
<a name="78"/>   public override new()
<a name="79"/>      Connectable.new()
<a name="80"/>      pp := Preprocessor().connect(pperror)
<a name="81"/>      lex := Lex().connect(lxerror)
<a name="82"/>      yy := YY().connect(yyerror)
<a name="83"/>      return
<a name="84"/>   end
<a name="85"/>
<a name="86"/>   public parse(s, encoding)
<a name="87"/>      local yyval
<a name="88"/>      first_err := &amp;null
<a name="89"/>      # Because we don't have the pp-generated # at the top of the file we start
<a name="90"/>      # at line 1 not line 0, and also in the given encoding.
<a name="91"/>      yyval := yy.yyparse(create lex.yylex(s,, encoding, 1))
<a name="92"/>      if \first_err then
<a name="93"/>         return error(first_err)
<a name="94"/>      return Prog(yyval)
<a name="95"/>   end
<a name="96"/>
<a name="97"/>   #
<a name="98"/>   # Parse `s`, as an expression (actually, a compound expression).
<a name="99"/>   #
<a name="100"/>   public parse_expression(s, encoding)
<a name="101"/>      s := "procedure main() ; " || s || " end"
<a name="102"/>      return parse(s, encoding).get_body().get(1).get_body_node()
<a name="103"/>   end
<a name="104"/>
<a name="105"/>   public parse_file(fname, predefined_syms)
<a name="106"/>      local s, yyval
<a name="107"/>      first_err := &amp;null
<a name="108"/>      s := pp.preprocess(fname, predefined_syms)
<a name="109"/>      if \first_err then
<a name="110"/>         return error(first_err)
<a name="111"/>      yyval := yy.yyparse(create lex.yylex(s))
<a name="112"/>      if \first_err then
<a name="113"/>         return error(first_err)
<a name="114"/>      return Prog(yyval)
<a name="115"/>   end
<a name="116"/>
<a name="117"/>   private yyerror(s)
<a name="118"/>      local ed, token
<a name="119"/>      # The last token sent by the lexer.
<a name="120"/>      token := yy.yylval
<a name="121"/>      ed := ErrorDetail(token.filename, token.line, image(token.s) || ": " || s)
<a name="122"/>      fire(PARSER_ERROR_EVENT, ed)
<a name="123"/>      /first_err := ed.str()
<a name="124"/>   end
<a name="125"/>
<a name="126"/>   private lxerror(ed)
<a name="127"/>      fire(LEXER_ERROR_EVENT, ed)
<a name="128"/>      /first_err := ed.str()
<a name="129"/>   end
<a name="130"/>
<a name="131"/>   private pperror(ed)
<a name="132"/>      fire(PREPROCESSOR_ERROR_EVENT, ed)
<a name="133"/>      /first_err := ed.str()
<a name="134"/>   end
<a name="135"/>end
</pre></body></html>
