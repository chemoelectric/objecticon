<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>component.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: component.icn 8604 2020-10-21 15:54:02Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package gui
<a name="10"/>
<a name="11"/>import 
<a name="12"/>   ipl.sort,
<a name="13"/>   ipl.pdco,
<a name="14"/>   ipl.lists,
<a name="15"/>   util
<a name="16"/>
<a name="17"/>#
<a name="18"/># This is the parent class of all the GUI components.  All of
<a name="19"/># its methods and variables therefore apply to its sub-classes.
<a name="20"/>#
<a name="21"/>class Component(Rect,XYAlign,Connectable)
<a name="22"/>   public 
<a name="23"/>      #
<a name="24"/>      # x position as specified by `set_pos()`, eg "50%"
<a name="25"/>      #                        
<a name="26"/>      x_spec,
<a name="27"/>      #
<a name="28"/>      # y position as specified by set_pos().
<a name="29"/>      #
<a name="30"/>      y_spec,
<a name="31"/>      #
<a name="32"/>      # width specifier as specified in set_size(), eg "100%"              
<a name="33"/>      #
<a name="34"/>      w_spec, 
<a name="35"/>      #
<a name="36"/>      # height specifier as specified in set_size(),
<a name="37"/>      #
<a name="38"/>      h_spec, 
<a name="39"/>      #
<a name="40"/>      # An integer used to sort the parent's z_children list.
<a name="41"/>      #
<a name="42"/>      z,
<a name="43"/>      #
<a name="44"/>      # This can be set to alter the tab-focus ordering of the parent
<a name="45"/>      # container.
<a name="46"/>      #
<a name="47"/>      tab_ord,
<a name="48"/>      #
<a name="49"/>      # The `Dialog` class instance of which this `Component` is a part.
<a name="50"/>      #
<a name="51"/>      parent_dialog,
<a name="52"/>      #
<a name="53"/>      # A map of the Icon window graphics attributes, eg "bg"-&gt;"blue",
<a name="54"/>      # "resize"-&gt;"on" etc.
<a name="55"/>      wattribs,
<a name="56"/>      effective_wattribs,
<a name="57"/>      #
<a name="58"/>      # Flags indicating whether the `Component` currently is shaded;
<a name="59"/>      # `&amp;null` means it isn't.
<a name="60"/>      is_shaded_flag, 
<a name="61"/>      effective_is_shaded_flag,
<a name="62"/>      #
<a name="63"/>      # Flag to indicate that the `Component` will take care of drawing
<a name="64"/>      # its own shaded representation.  By default off, meaning this
<a name="65"/>      # class will shade the component.
<a name="66"/>      #
<a name="67"/>      draw_own_shading_flag,
<a name="68"/>      #
<a name="69"/>      # Flags indicating whether the `Component` currently is hidden;
<a name="70"/>      # `&amp;null` means it isn't.
<a name="71"/>      is_hidden_flag,
<a name="72"/>      effective_is_hidden_flag,
<a name="73"/>      #
<a name="74"/>      # A cloned window created by combining a buffer window with
<a name="75"/>      # the `Component`'s attributes.  The component draws itself
<a name="76"/>      # into this window.
<a name="77"/>      cbwin,
<a name="78"/>      #
<a name="79"/>      # Flag indicating whether the `Component` accepts keyboard focus
<a name="80"/>      # by way of the tab key being pressed;  `&amp;null` means it doesn't.
<a name="81"/>      accepts_focus_flag,
<a name="82"/>      #
<a name="83"/>      # Tooltip config
<a name="84"/>      #
<a name="85"/>      tooltip,         
<a name="86"/>      tooltip_start_delay,
<a name="87"/>      tooltip_end_delay,
<a name="88"/>      #
<a name="89"/>      # Reference to enclosing `Component` object.
<a name="90"/>      #
<a name="91"/>      parent,
<a name="92"/>      #
<a name="93"/>      # List of child components
<a name="94"/>      #
<a name="95"/>      children,
<a name="96"/>      #
<a name="97"/>      # The same children, but sorted in z order.
<a name="98"/>      #
<a name="99"/>      z_children,
<a name="100"/>      #
<a name="101"/>      # The same children, but sorted in tab order.
<a name="102"/>      #
<a name="103"/>      tab_children,
<a name="104"/>      #
<a name="105"/>      # Mnemonic key for keyboard accelerators.
<a name="106"/>      #
<a name="107"/>      accel,
<a name="108"/>      #
<a name="109"/>      # The child which we want to give the focus to.
<a name="110"/>      #
<a name="111"/>      preferred_focus,
<a name="112"/>      #
<a name="113"/>      # Flags to turn on drag and drop
<a name="114"/>      #
<a name="115"/>      allow_drag_flag,
<a name="116"/>      allow_drop_flag,
<a name="117"/>      #
<a name="118"/>      # Mouse pointer.
<a name="119"/>      #
<a name="120"/>      pointer,
<a name="121"/>      #
<a name="122"/>      # Layout manager
<a name="123"/>      #
<a name="124"/>      layout_delegate,
<a name="125"/>      #
<a name="126"/>      # Layout constraints
<a name="127"/>      # 
<a name="128"/>      constraints,
<a name="129"/>      #
<a name="130"/>      # Show layout grid - for layout debugging
<a name="131"/>      #
<a name="132"/>      show_layout_flag,
<a name="133"/>      #
<a name="134"/>      # A component to inherit wattribs from rather than the parent.
<a name="135"/>      #
<a name="136"/>      wattrib_ancestor,
<a name="137"/>      #
<a name="138"/>      # Border instance
<a name="139"/>      #
<a name="140"/>      border
<a name="141"/>
<a name="142"/>   #
<a name="143"/>   # Set the tooltip.  This object is passed to `create_tooltip_component` when a
<a name="144"/>   # tooltip is to be created.
<a name="145"/>   #
<a name="146"/>   public set_tooltip(x)
<a name="147"/>      self.tooltip := x
<a name="148"/>      link
<a name="149"/>   end
<a name="150"/>
<a name="151"/>   #
<a name="152"/>   # Return the tooltip, if any.
<a name="153"/>   #
<a name="154"/>   public get_tooltip()
<a name="155"/>      return \self.tooltip
<a name="156"/>   end
<a name="157"/>
<a name="158"/>   #
<a name="159"/>   # Set the delay in ms before the tooltip appears.
<a name="160"/>   #
<a name="161"/>   public set_tooltip_start_delay(x)
<a name="162"/>      self.tooltip_start_delay := x
<a name="163"/>      link
<a name="164"/>   end
<a name="165"/>
<a name="166"/>   #
<a name="167"/>   # Get the tooltip start delay.
<a name="168"/>   #
<a name="169"/>   public get_tooltip_start_delay()
<a name="170"/>      return self.tooltip_start_delay
<a name="171"/>   end
<a name="172"/>
<a name="173"/>   #
<a name="174"/>   # Set the delay in ms before the tooltip disappears after it has been
<a name="175"/>   # shown; &amp;null means infinite.
<a name="176"/>   #
<a name="177"/>   public set_tooltip_end_delay(x)
<a name="178"/>      self.tooltip_end_delay := x
<a name="179"/>      link
<a name="180"/>   end
<a name="181"/>
<a name="182"/>   #
<a name="183"/>   # Get the tooltip end delay.
<a name="184"/>   #
<a name="185"/>   public get_tooltip_end_delay()
<a name="186"/>      return \self.tooltip_end_delay
<a name="187"/>   end
<a name="188"/>
<a name="189"/>   #
<a name="190"/>   # Create a tooltip Component.  By default delegates this to the `Style` object,
<a name="191"/>   # to create a standard `Label`.  The content is then set from the tip, which
<a name="192"/>   # can be a string or a `Paint` instance.
<a name="193"/>   #
<a name="194"/>   public create_tooltip_component(tip)
<a name="195"/>      local c, s
<a name="196"/>      c := Gui.style.create_tooltip_label()
<a name="197"/>      if s := text(tip) then
<a name="198"/>         c.set_label(s)
<a name="199"/>      else
<a name="200"/>         c.set_paint(tip)
<a name="201"/>      if \self.accel then
<a name="202"/>         c.set_linked_accel(self)
<a name="203"/>      return c
<a name="204"/>   end
<a name="205"/>
<a name="206"/>   #
<a name="207"/>   # Set the pointer.  When the mouse moves over the component,
<a name="208"/>   # the pointer cursor will automatically be set to this value.
<a name="209"/>   #
<a name="210"/>   public set_pointer(x)
<a name="211"/>      self.pointer := x
<a name="212"/>      link
<a name="213"/>   end
<a name="214"/>
<a name="215"/>   #
<a name="216"/>   # Return the pointer string, if any.
<a name="217"/>   #
<a name="218"/>   public get_pointer()
<a name="219"/>      return \self.pointer
<a name="220"/>   end
<a name="221"/>
<a name="222"/>   #
<a name="223"/>   # Set the border to use.
<a name="224"/>   #
<a name="225"/>   public set_border(b)
<a name="226"/>      if is_initialized() then {
<a name="227"/>         (\self.border).finally()
<a name="228"/>         self.border := b
<a name="229"/>         (\self.border).initially(self)
<a name="230"/>         self.invalidate()
<a name="231"/>      } else
<a name="232"/>         self.border := b
<a name="233"/>      link
<a name="234"/>   end
<a name="235"/>
<a name="236"/>   #
<a name="237"/>   # Return the clip rectangle of `cbwin` as a `Rect`.  Fails if there
<a name="238"/>   # is no clip.
<a name="239"/>   #
<a name="240"/>   public get_cbwin_clip()
<a name="241"/>      return Rect!cbwin.get_clip()
<a name="242"/>   end
<a name="243"/>
<a name="244"/>   #
<a name="245"/>   # Get the cloned buffer window, as seen by a child component.
<a name="246"/>   #
<a name="247"/>   public get_cbwin()
<a name="248"/>      return \self.cbwin
<a name="249"/>   end
<a name="250"/>
<a name="251"/>   #
<a name="252"/>   # Get the wattribs in effect in the component's cbwin window.  Fails if the
<a name="253"/>   # component is not initialized.
<a name="254"/>   #
<a name="255"/>   public get_effective_wattribs()
<a name="256"/>      return \effective_wattribs
<a name="257"/>   end
<a name="258"/>
<a name="259"/>   #
<a name="260"/>   # This method can be overridden to succeed if the component should keep
<a name="261"/>   # an event rather than allow it to be used by the parent dialog to move
<a name="262"/>   # the focus between c
<a name="263"/>   #
<a name="264"/>   public keeps(e)
<a name="265"/>   end
<a name="266"/>
<a name="267"/>   #
<a name="268"/>   # Succeed if the component is hidden; for example if it is
<a name="269"/>   # within a tabbed pane not presently visible.
<a name="270"/>   #
<a name="271"/>   public is_hidden()
<a name="272"/>      succeed \effective_is_hidden_flag
<a name="273"/>   end
<a name="274"/>
<a name="275"/>   #
<a name="276"/>   # Succeed if the component is not hidden.
<a name="277"/>   #
<a name="278"/>   public is_unhidden()
<a name="279"/>      succeed /effective_is_hidden_flag
<a name="280"/>   end
<a name="281"/>
<a name="282"/>   #
<a name="283"/>   # Swap the hidden status of the component.
<a name="284"/>   #
<a name="285"/>   public toggle_is_hidden()
<a name="286"/>      return set_is_hidden(toggle_flag(is_hidden_flag))
<a name="287"/>   end
<a name="288"/>
<a name="289"/>   #
<a name="290"/>   # Set the hidden status of the component.
<a name="291"/>   #
<a name="292"/>   public set_is_hidden(s)
<a name="293"/>      need_flag(s)
<a name="294"/>      if s ~=== is_hidden_flag then {
<a name="295"/>         # NB - try invalidate before and after, since invalidating a hidden
<a name="296"/>         # component is a no-op.
<a name="297"/>         invalidate()
<a name="298"/>         is_hidden_flag := s
<a name="299"/>         hidden_change()
<a name="300"/>         invalidate()
<a name="301"/>      }
<a name="302"/>      link
<a name="303"/>   end
<a name="304"/>
<a name="305"/>   #
<a name="306"/>   # Called to re-compute the effective_is_hidden_flags under this tree.
<a name="307"/>   #
<a name="308"/>   public hidden_change()
<a name="309"/>      local v
<a name="310"/>      is_initialized() | fail
<a name="311"/>      v := Yes{ (\parent).is_hidden() | \is_hidden_flag }
<a name="312"/>      if effective_is_hidden_flag ~===:= v then {
<a name="313"/>         every (!children).hidden_change()
<a name="314"/>         fire(if /v then Event.RESUMED else Event.INTERRUPTED)
<a name="315"/>      }
<a name="316"/>   end
<a name="317"/>
<a name="318"/>   #
<a name="319"/>   # Succeeds if the component is shaded; fails otherwise.  A
<a name="320"/>   # shaded component, such as a button, may be displayed
<a name="321"/>   # differently, and will not generate events.
<a name="322"/>   #
<a name="323"/>   public is_shaded()
<a name="324"/>      succeed \effective_is_shaded_flag
<a name="325"/>   end
<a name="326"/>
<a name="327"/>   #
<a name="328"/>   # Succeed if the component is not shaded.
<a name="329"/>   #
<a name="330"/>   public is_unshaded()
<a name="331"/>      succeed /effective_is_shaded_flag
<a name="332"/>   end
<a name="333"/>
<a name="334"/>   #
<a name="335"/>   # Called to re-compute the effective_is_shaded_flags under this tree.
<a name="336"/>   #
<a name="337"/>   public shaded_change()
<a name="338"/>      local v
<a name="339"/>      is_initialized() | fail
<a name="340"/>      v := Yes{ (\parent).is_shaded() | \is_shaded_flag }
<a name="341"/>      if effective_is_shaded_flag ~===:= v then {
<a name="342"/>         every (!children).shaded_change()
<a name="343"/>         fire(if /v then Event.RESUMED else Event.INTERRUPTED)
<a name="344"/>      }
<a name="345"/>   end
<a name="346"/>
<a name="347"/>   #
<a name="348"/>   # Flag to indicate that the `Component` will take care of drawing
<a name="349"/>   # its own shaded representation.  By default off, meaning this
<a name="350"/>   # class will shade the component.
<a name="351"/>   #
<a name="352"/>   public set_draw_own_shading(s)
<a name="353"/>      if draw_own_shading_flag ~===:= need_flag(s) then
<a name="354"/>         invalidate()
<a name="355"/>      link
<a name="356"/>   end
<a name="357"/>
<a name="358"/>   #
<a name="359"/>   # Set the preferred focus, which is the component to which focus is
<a name="360"/>   # given when a mouse click occurs in this component.  By default,
<a name="361"/>   # this is set to the component itself.
<a name="362"/>   #
<a name="363"/>   public set_preferred_focus(c)
<a name="364"/>      self.preferred_focus := c
<a name="365"/>      link
<a name="366"/>   end
<a name="367"/>
<a name="368"/>   #
<a name="369"/>   # Return the preferred focus.
<a name="370"/>   #
<a name="371"/>   public get_preferred_focus()
<a name="372"/>      return self.preferred_focus
<a name="373"/>   end
<a name="374"/>
<a name="375"/>   #
<a name="376"/>   # Determines whether the component accepts the tab focus
<a name="377"/>   #
<a name="378"/>   public accepts_focus()
<a name="379"/>      succeed \self.accepts_focus_flag
<a name="380"/>   end
<a name="381"/>
<a name="382"/>   #
<a name="383"/>   # Handle the component's keyboard accelerator key.  By
<a name="384"/>   # default, this requests the keyboard focus (if the
<a name="385"/>   # component is configured to accept it).
<a name="386"/>   #
<a name="387"/>   public handle_accel(e)
<a name="388"/>      grab_focus(e)
<a name="389"/>   end
<a name="390"/>
<a name="391"/>   #
<a name="392"/>   # Grab the focus for this component's preferred focus.  Fails if
<a name="393"/>   # the focus is not given to the component, returns `self`
<a name="394"/>   # otherwise.
<a name="395"/>   #
<a name="396"/>   # :Parameters :
<a name="397"/>   # :  `e` - the causing event, if any.
<a name="398"/>   #
<a name="399"/>   public grab_focus(e)
<a name="400"/>      link (\parent_dialog).set_focus(find_focus(e), e)
<a name="401"/>   end
<a name="402"/>
<a name="403"/>   #
<a name="404"/>   # Swap the shaded status of the component.
<a name="405"/>   #
<a name="406"/>   public toggle_is_shaded()
<a name="407"/>      return set_is_shaded(toggle_flag(is_shaded_flag))
<a name="408"/>   end
<a name="409"/>
<a name="410"/>   #
<a name="411"/>   # Set the shaded status of the component.
<a name="412"/>   #
<a name="413"/>   public set_is_shaded(s)
<a name="414"/>      if is_shaded_flag ~===:= need_flag(s) then {
<a name="415"/>         shaded_change()
<a name="416"/>         invalidate()
<a name="417"/>      }
<a name="418"/>      link
<a name="419"/>   end
<a name="420"/>
<a name="421"/>   #
<a name="422"/>   # Set the flag indicating that the component accepts tab focus.
<a name="423"/>   #
<a name="424"/>   public set_accepts_focus(s)
<a name="425"/>      self.accepts_focus_flag := need_flag(s)
<a name="426"/>      link
<a name="427"/>   end
<a name="428"/>
<a name="429"/>   #
<a name="430"/>   # This draws, or re-draws, the component and all its children in the dialog
<a name="431"/>   # window.
<a name="432"/>   #
<a name="433"/>   public display()
<a name="434"/>      display_children()
<a name="435"/>   end
<a name="436"/>
<a name="437"/>   #
<a name="438"/>   # Useful function to display the children.
<a name="439"/>   #
<a name="440"/>   public display_children()
<a name="441"/>      every display_child(!self.z_children)
<a name="442"/>   end
<a name="443"/>
<a name="444"/>   public display_child(c)
<a name="445"/>      if c.is_unhidden() then
<a name="446"/>         c.invoke_display!cbwin.drawable(c.x, c.y, c.w, c.h)
<a name="447"/>   end
<a name="448"/>
<a name="449"/>   public invoke_display(rx, ry, rw, rh)
<a name="450"/>      cbwin.clip(rx, ry, rw, rh).erase_area(rx, ry, rw, rh)
<a name="451"/>      self.display()
<a name="452"/>      if \self.show_layout_flag then
<a name="453"/>         (\layout_delegate).display()
<a name="454"/>      # Only need to shade if we are shaded and the parent won't shade for us.  This also
<a name="455"/>      # avoids filtering twice, which makes the result too grey.
<a name="456"/>      if is_shaded() &amp; not((\parent).is_shaded()) &amp; /draw_own_shading_flag then
<a name="457"/>         Gui.style.shade_rectangle(self.cbwin, rx, ry, rw, rh)
<a name="458"/>   end
<a name="459"/>
<a name="460"/>   #
<a name="461"/>   # Add the given window attribute and value to those used in
<a name="462"/>   # this component's cloned buffer window.
<a name="463"/>   #
<a name="464"/>   public set_wattrib(attr, val)
<a name="465"/>      every remove_wattrib(WAttrib.gen_conflicting(attr))
<a name="466"/>      insert(self.wattribs, attr, val)
<a name="467"/>      link
<a name="468"/>   end
<a name="469"/>
<a name="470"/>   #
<a name="471"/>   # Remove the given window attribute.
<a name="472"/>   #
<a name="473"/>   public remove_wattrib(attr)
<a name="474"/>      delete(self.wattribs, attr)
<a name="475"/>      link
<a name="476"/>   end
<a name="477"/>
<a name="478"/>   #
<a name="479"/>   # Return the window attrib with the given name in the icon attribs
<a name="480"/>   # list, or fail if none is present.
<a name="481"/>   #
<a name="482"/>   public get_wattrib(attr)
<a name="483"/>      return member(self.wattribs, attr)
<a name="484"/>   end
<a name="485"/>
<a name="486"/>   #
<a name="487"/>   # Clear all wattribs
<a name="488"/>   #
<a name="489"/>   public clear_wattribs()
<a name="490"/>      clear(self.wattribs)
<a name="491"/>      link
<a name="492"/>   end
<a name="493"/>
<a name="494"/>   #
<a name="495"/>   # Set all of the wattribs to the given table.
<a name="496"/>   #
<a name="497"/>   public set_all_wattribs(t)
<a name="498"/>      self.wattribs := copy(t)
<a name="499"/>      link
<a name="500"/>   end
<a name="501"/>
<a name="502"/>   #
<a name="503"/>   # Copy an attrib from another component to this one.  If the
<a name="504"/>   # attribute is absent in the other component it is deleted from
<a name="505"/>   # this one.
<a name="506"/>   #
<a name="507"/>   public copy_wattrib(attr, other)
<a name="508"/>      local val
<a name="509"/>      if val := other.get_wattrib(attr) then
<a name="510"/>         set_wattrib(attr, val)
<a name="511"/>      else
<a name="512"/>         remove_wattrib(attr)
<a name="513"/>      link
<a name="514"/>   end
<a name="515"/>
<a name="516"/>   #
<a name="517"/>   # Set a layout constraint
<a name="518"/>   #
<a name="519"/>   public set_constraint(key, val)
<a name="520"/>      insert(self.constraints, key, val)
<a name="521"/>      link
<a name="522"/>   end
<a name="523"/>
<a name="524"/>   #
<a name="525"/>   # Remove a layout constraint
<a name="526"/>   #
<a name="527"/>   public remove_constraint(key)
<a name="528"/>      delete(self.constraints, key)
<a name="529"/>      link
<a name="530"/>   end
<a name="531"/>
<a name="532"/>   #
<a name="533"/>   # Get a layout constraint, or fail if it's not present.
<a name="534"/>   #
<a name="535"/>   public get_constraint(key)
<a name="536"/>      return member(self.constraints, key)
<a name="537"/>   end
<a name="538"/>
<a name="539"/>   #
<a name="540"/>   # Clear all constraints
<a name="541"/>   #
<a name="542"/>   public clear_constraints()
<a name="543"/>      clear(self.constraints)
<a name="544"/>      link
<a name="545"/>   end      
<a name="546"/>
<a name="547"/>   #
<a name="548"/>   # This method disposes of the component's cloned windows and
<a name="549"/>   # re-creates them afresh using the current value of the window attribs.
<a name="550"/>   # 
<a name="551"/>   # This method may be used to put any changed icon window attributes,
<a name="552"/>   # set with set_wattrib above, into effect.
<a name="553"/>   #
<a name="554"/>   public reset()
<a name="555"/>      self.finally()
<a name="556"/>      self.initially()
<a name="557"/>      self.layout()
<a name="558"/>      self.invalidate()
<a name="559"/>      link
<a name="560"/>   end
<a name="561"/>
<a name="562"/>   #
<a name="563"/>   # Return a z that would ensure a component were on top in the
<a name="564"/>   # z order.
<a name="565"/>   #
<a name="566"/>   public get_top_z()
<a name="567"/>      return (self.z_children[-1].z + 1) | 1
<a name="568"/>   end
<a name="569"/>
<a name="570"/>   #
<a name="571"/>   # Return a z that would ensure a component were on bottom in the
<a name="572"/>   # z order.
<a name="573"/>   #
<a name="574"/>   public get_bottom_z()
<a name="575"/>      return (self.z_children[1].z - 1) | -1
<a name="576"/>   end
<a name="577"/>
<a name="578"/>   #
<a name="579"/>   # Which component does the point lie in, searching in z-order?
<a name="580"/>   #
<a name="581"/>   public whose_point(ex, ey)
<a name="582"/>      local c
<a name="583"/>      every c := back(z_children) do {
<a name="584"/>         if c.is_unhidden() &amp; c.inside(ex, ey) then
<a name="585"/>            return c
<a name="586"/>      }
<a name="587"/>   end
<a name="588"/>
<a name="589"/>   #
<a name="590"/>   # Is the given Point (normally the current event) within this
<a name="591"/>   # component?  `e` may be null, in which case we just test whether
<a name="592"/>   # this component is in the point chain.
<a name="593"/>   #
<a name="594"/>   public in_region(e)
<a name="595"/>      #
<a name="596"/>      # Use the point chain if we can
<a name="597"/>      #
<a name="598"/>      succeed if /e | (e === parent_dialog.get_point_chain_source()) then
<a name="599"/>         keyof(parent_dialog.get_point_chain(), self)
<a name="600"/>      else
<a name="601"/>         get_clip_rect().inside(e.x, e.y)
<a name="602"/>   end
<a name="603"/>
<a name="604"/>   #
<a name="605"/>   # Succeed if this component is held with the given button press.
<a name="606"/>   # :Parameters :
<a name="607"/>   # :  `e` - The mouse press event code - Mouse.LEFT_PRESS, Mouse.RIGHT_PRESS or Mouse.MIDDLE_PRESS
<a name="608"/>   #
<a name="609"/>   public is_held(e)
<a name="610"/>      succeed keyof(parent_dialog.get_held(e), self)
<a name="611"/>   end
<a name="612"/>
<a name="613"/>   #
<a name="614"/>   # Method called when the component gets the keyboard focus; may be extended.
<a name="615"/>   # :Parameters :
<a name="616"/>   # :  `e` - the event causing the change of focus, if any
<a name="617"/>   #
<a name="618"/>   public got_focus(e)
<a name="619"/>      focus_changed(e)
<a name="620"/>      fire(Event.GOT_FOCUS, e)
<a name="621"/>   end
<a name="622"/>
<a name="623"/>   #
<a name="624"/>   # Return the Icon window of the dialog in which the component resides.
<a name="625"/>   #
<a name="626"/>   public get_parent_win()
<a name="627"/>      return (\self.parent_dialog).get_win()
<a name="628"/>   end
<a name="629"/>
<a name="630"/>   #
<a name="631"/>   # Succeed if this component has the dialog's focus.
<a name="632"/>   #
<a name="633"/>   public has_focus()
<a name="634"/>      succeed (\self.parent_dialog).get_focus() === self
<a name="635"/>   end
<a name="636"/>
<a name="637"/>   #
<a name="638"/>   # Succeed if this component should draw itself with the focus shown
<a name="639"/>   # (eg a red border or cursor).
<a name="640"/>   #
<a name="641"/>   public should_draw_focus()
<a name="642"/>      succeed has_focus() &amp; is_unshaded() &amp; (\parent_dialog).is_unblocked() &amp; (\parent_dialog).is_focus_in()
<a name="643"/>   end
<a name="644"/>
<a name="645"/>   #
<a name="646"/>   # Method called when the component loses the keyboard focus; may be extended.
<a name="647"/>   # :Parameters :
<a name="648"/>   # :  `e` - the event causing the change of focus, if any
<a name="649"/>   #
<a name="650"/>   public lost_focus(e)
<a name="651"/>      focus_changed(e)
<a name="652"/>      fire(Event.LOST_FOCUS, e)
<a name="653"/>   end
<a name="654"/>
<a name="655"/>   #
<a name="656"/>   # This is invoked when the focus is got/lost, or may need to be
<a name="657"/>   # redrawn; by default it just calls invalidate.
<a name="658"/>   #
<a name="659"/>   # :Parameters :
<a name="660"/>   # :  `e` - the event causing the change of focus, if any
<a name="661"/>   #
<a name="662"/>   public focus_changed(e)
<a name="663"/>      invalidate()
<a name="664"/>   end
<a name="665"/>
<a name="666"/>   #
<a name="667"/>   # Set the x and y position of the component.  Each coordinate
<a name="668"/>   # can be either an absolute pixel position, or can be given in
<a name="669"/>   # the form of a percentage plus or minus an offset.  For
<a name="670"/>   # example :-
<a name="671"/>   # ~
<a name="672"/>   #   c.set_pos(100, "25%")
<a name="673"/>   #   c.set_pos("50%-20", "25%+100")
<a name="674"/>   # ~
<a name="675"/>   # :Parameters :
<a name="676"/>   # :  `x_spec` - The x specification.
<a name="677"/>   # :  `y_spec` - The y specification.
<a name="678"/>   #
<a name="679"/>   public set_pos(x_spec, y_spec)
<a name="680"/>      self.x_spec := x_spec
<a name="681"/>      self.y_spec := y_spec
<a name="682"/>      link
<a name="683"/>   end
<a name="684"/>
<a name="685"/>   #
<a name="686"/>   # Set the x specification
<a name="687"/>   # :Parameters :
<a name="688"/>   # :  `x_spec` - The x specification.
<a name="689"/>   #
<a name="690"/>   public set_x(x_spec)
<a name="691"/>      self.x_spec := x_spec
<a name="692"/>      link
<a name="693"/>   end
<a name="694"/>
<a name="695"/>   #
<a name="696"/>   # Set the y specification
<a name="697"/>   # :Parameters :
<a name="698"/>   # :  `y_spec` - The y specification.
<a name="699"/>   #
<a name="700"/>   public set_y(y_spec)
<a name="701"/>      self.y_spec := y_spec
<a name="702"/>      link
<a name="703"/>   end
<a name="704"/>
<a name="705"/>   #
<a name="706"/>   # Set the z value.
<a name="707"/>   # :Parameters :
<a name="708"/>   # :  `z` - The z value.
<a name="709"/>   #
<a name="710"/>   public set_z(z)
<a name="711"/>      self.z := need_integer(z)
<a name="712"/>      link
<a name="713"/>   end
<a name="714"/>
<a name="715"/>   #
<a name="716"/>   # Set the size of the component.  The parameters are in the
<a name="717"/>   # same format as for `set_pos()`
<a name="718"/>   # above.  Some components will
<a name="719"/>   # set sensible default sizes, but for others the size must be
<a name="720"/>   # set explicitly.
<a name="721"/>   #
<a name="722"/>   public set_size(w_spec, h_spec)
<a name="723"/>      self.w_spec := w_spec
<a name="724"/>      self.h_spec := h_spec
<a name="725"/>      link
<a name="726"/>   end
<a name="727"/>
<a name="728"/>   #
<a name="729"/>   # Set the width specification
<a name="730"/>   # :Parameters :
<a name="731"/>   # :  `w_spec` - The width specification.
<a name="732"/>   #
<a name="733"/>   public set_width(w_spec)
<a name="734"/>      self.w_spec := w_spec
<a name="735"/>      link
<a name="736"/>   end
<a name="737"/>
<a name="738"/>   #
<a name="739"/>   # Set the height specification
<a name="740"/>   # :Parameters :
<a name="741"/>   # :  `h_spec` - The height specification.
<a name="742"/>   #
<a name="743"/>   public set_height(h_spec)
<a name="744"/>      self.h_spec := h_spec
<a name="745"/>      link
<a name="746"/>   end
<a name="747"/>
<a name="748"/>   # Set the alignment of the component.  Options for `x_align` are
<a name="749"/>   # `Align.L`, `Align.C` and `Align.R`, for left, centre, and right
<a name="750"/>   # alignment.  Options for `y_align` are `Align.T`, `Align.C` and
<a name="751"/>   # `Align.B`, for top centre and bottom alignment.  The default
<a name="752"/>   # alignment is `Align.L`, `Align.T`.
<a name="753"/>   #
<a name="754"/>   # :Parameters :
<a name="755"/>   # :  `x_align` - The x alignment
<a name="756"/>   # :  `y_align` - The y alignment
<a name="757"/>   #
<a name="758"/>   public set_align(x_align, y_align)
<a name="759"/>      self.x_align := x_align
<a name="760"/>      self.y_align := y_align
<a name="761"/>      link
<a name="762"/>   end
<a name="763"/>
<a name="764"/>   #
<a name="765"/>   # Set the x alignment
<a name="766"/>   # :Parameters :
<a name="767"/>   # :  `x_align` - The x alignment
<a name="768"/>   #
<a name="769"/>   public set_x_align(x_align)
<a name="770"/>      self.x_align := x_align
<a name="771"/>      link
<a name="772"/>   end
<a name="773"/>
<a name="774"/>   #
<a name="775"/>   # Set the y alignment
<a name="776"/>   # :Parameters :
<a name="777"/>   # :  `y_align` - The y alignment
<a name="778"/>   #
<a name="779"/>   public set_y_align(y_align)
<a name="780"/>      self.y_align := y_align
<a name="781"/>      link
<a name="782"/>   end
<a name="783"/>
<a name="784"/>   #
<a name="785"/>   # Set the position and size of the component.
<a name="786"/>   # :See also :
<a name="787"/>   # :  set_pos
<a name="788"/>   # :  set_size
<a name="789"/>   #
<a name="790"/>   public set_geometry(x_spec, y_spec, w_spec, h_spec)
<a name="791"/>      self.x_spec := x_spec
<a name="792"/>      self.y_spec := y_spec
<a name="793"/>      self.w_spec := w_spec
<a name="794"/>      self.h_spec := h_spec
<a name="795"/>      link
<a name="796"/>   end
<a name="797"/>
<a name="798"/>   #
<a name="799"/>   # Set the tab priority, which affects the tab focus ordering of the parent.
<a name="800"/>   #
<a name="801"/>   public set_tab_ord(x)
<a name="802"/>      self.tab_ord := need_integer(x)
<a name="803"/>      link
<a name="804"/>   end
<a name="805"/>
<a name="806"/>   #
<a name="807"/>   # Set the accelerator key, which will be used with the Alt
<a name="808"/>   # key to provide keyboard accelerators.
<a name="809"/>   #
<a name="810"/>   public set_accel(k)
<a name="811"/>      self.accel := need_text(k)
<a name="812"/>      link
<a name="813"/>   end
<a name="814"/>
<a name="815"/>   #
<a name="816"/>   # Get the accelerator key, if any.
<a name="817"/>   #
<a name="818"/>   public get_accel()
<a name="819"/>      return \self.accel
<a name="820"/>   end
<a name="821"/>
<a name="822"/>   #
<a name="823"/>   # Get the component's parent component, or fail if there is none.
<a name="824"/>   #
<a name="825"/>   public get_parent()
<a name="826"/>      return \self.parent
<a name="827"/>   end
<a name="828"/>
<a name="829"/>   #
<a name="830"/>   # Set the component's parent component.
<a name="831"/>   #
<a name="832"/>   public set_parent(c)
<a name="833"/>      self.parent := c
<a name="834"/>      link
<a name="835"/>   end
<a name="836"/>
<a name="837"/>   # Generate the chain of components starting with this component and
<a name="838"/>   # going up through the parents.
<a name="839"/>   #
<a name="840"/>   public gen_parents()
<a name="841"/>      local t
<a name="842"/>      t := self
<a name="843"/>      while \t do {
<a name="844"/>         suspend t
<a name="845"/>         t := t.parent
<a name="846"/>      }
<a name="847"/>   end
<a name="848"/>
<a name="849"/>   #
<a name="850"/>   # Complete the final setup before display by initializing the parent
<a name="851"/>   # dialog reference and creating the cloned windows.
<a name="852"/>   #
<a name="853"/>   public initially()
<a name="854"/>      local k, a
<a name="855"/>      /cbwin | runerr("initially() called out of sequence")
<a name="856"/>      \parent | runerr("Incorrect ancestry (parent null)")
<a name="857"/>      parent_dialog := parent.get_parent_dialog()
<a name="858"/>      effective_is_hidden_flag := Yes{ parent.is_hidden() | \is_hidden_flag }
<a name="859"/>      effective_is_shaded_flag := Yes{ parent.is_shaded() | \is_shaded_flag }
<a name="860"/>      Gui.style.polish(self)
<a name="861"/>      a := \wattrib_ancestor | parent
<a name="862"/>      effective_wattribs := copy(a.get_effective_wattribs()) | 
<a name="863"/>         runerr("Failed to get effective wattribs from ancestor", a)
<a name="864"/>      every k := key(wattribs) do {
<a name="865"/>         Gui.is_context_attrib(k) |
<a name="866"/>            runerr("Invalid (non-graphics context) attribute for component", k)
<a name="867"/>         effective_wattribs[k] := wattribs[k]
<a name="868"/>      }
<a name="869"/>      compute_z_order()
<a name="870"/>      compute_tab_order()
<a name="871"/>      cbwin := if \wattrib_ancestor then
<a name="872"/>         fresh_clone_win_with(parent.get_cbwin(), effective_wattribs)
<a name="873"/>      else
<a name="874"/>         clone_win_with(parent.get_cbwin(), wattribs)
<a name="875"/>      (\border).initially(self)
<a name="876"/>      every (!children).initially()
<a name="877"/>   end
<a name="878"/>
<a name="879"/>   #
<a name="880"/>   # Returns the dialog holding the component, or fail if unset
<a name="881"/>   #
<a name="882"/>   public get_parent_dialog()
<a name="883"/>      return \self.parent_dialog
<a name="884"/>   end
<a name="885"/>
<a name="886"/>   #
<a name="887"/>   # Sets the owning Dialog of the component.
<a name="888"/>   #
<a name="889"/>   # :Parameters :
<a name="890"/>   # :  `c` - The parent dialog.
<a name="891"/>   #
<a name="892"/>   public set_parent_dialog(c)
<a name="893"/>      self.parent_dialog := c
<a name="894"/>      link
<a name="895"/>   end
<a name="896"/>
<a name="897"/>   #
<a name="898"/>   # This method may be extended.  It is invoked just before the
<a name="899"/>   # window is closed.
<a name="900"/>   #
<a name="901"/>   public finally()
<a name="902"/>      \cbwin | runerr("finally() called out of sequence")
<a name="903"/>      reset_layout()
<a name="904"/>      (\border).finally()
<a name="905"/>      cbwin.close()
<a name="906"/>      effective_wattribs := cbwin := &amp;null
<a name="907"/>      every (!children).finally()
<a name="908"/>      parent_dialog := &amp;null
<a name="909"/>   end
<a name="910"/>
<a name="911"/>   #
<a name="912"/>   #
<a name="913"/>   # Parse a position specification into an absolute value.
<a name="914"/>   # :Parameters :
<a name="915"/>   # :  `total` - The total value
<a name="916"/>   # :  `s` - The size specifier 
<a name="917"/>   #
<a name="918"/>   public static parse_pos(total, s)
<a name="919"/>      local pct, off
<a name="920"/>      s ? {
<a name="921"/>         if pct := 0.01 * integer(tab(upto('%'))) then {
<a name="922"/>            move(1) 
<a name="923"/>            if ="-" then
<a name="924"/>               off := -integer(tab(0)) | fail
<a name="925"/>            else if ="+" then
<a name="926"/>               off := integer(tab(0)) | fail
<a name="927"/>            else off := 0
<a name="928"/>         } else {
<a name="929"/>            pct := 0
<a name="930"/>            off := integer(tab(0)) | fail
<a name="931"/>         }
<a name="932"/>      }
<a name="933"/>      return integer(pct * total + off)
<a name="934"/>   end
<a name="935"/>
<a name="936"/>   public get_preferred_width()
<a name="937"/>      return integer(self.w_spec) | get_default_width() | (\layout_delegate).get_preferred_width() | runerr("Width must be specified")
<a name="938"/>   end
<a name="939"/>
<a name="940"/>   public get_preferred_height(pw)
<a name="941"/>      local i
<a name="942"/>      if i := integer(self.h_spec) then
<a name="943"/>         return i
<a name="944"/>      /pw := get_preferred_width()
<a name="945"/>      return get_default_height(pw) | (\layout_delegate).get_preferred_height(pw) | runerr("Height must be specified")
<a name="946"/>   end
<a name="947"/>
<a name="948"/>   #
<a name="949"/>   # Size this component using compute_absolutes, and then layout all
<a name="950"/>   # its children.
<a name="951"/>   #
<a name="952"/>   public resize()
<a name="953"/>      compute_absolutes()
<a name="954"/>      layout()
<a name="955"/>      link
<a name="956"/>   end
<a name="957"/>
<a name="958"/>   public get_default_width()
<a name="959"/>   end
<a name="960"/>
<a name="961"/>   public get_default_height()
<a name="962"/>   end
<a name="963"/>
<a name="964"/>   #
<a name="965"/>   # Set the `Layout` to use to `l`, which may be `&amp;null`.
<a name="966"/>   #
<a name="967"/>   public set_layout(l)
<a name="968"/>      self.layout_delegate := l
<a name="969"/>      (\l).set_parent(self)
<a name="970"/>      link
<a name="971"/>   end
<a name="972"/>
<a name="973"/>   #
<a name="974"/>   # Given that this component's size and position has already been
<a name="975"/>   # calculated, this method lays out all of its children.
<a name="976"/>   #
<a name="977"/>   public layout()
<a name="978"/>      if /layout_delegate then
<a name="979"/>         every (!children).compute_absolutes()
<a name="980"/>      else
<a name="981"/>         layout_delegate.layout()
<a name="982"/>      every (!children).layout()
<a name="983"/>   end
<a name="984"/>
<a name="985"/>   #
<a name="986"/>   # Recursively shift the `x` and `y` location variables of this
<a name="987"/>   # component and its descendants by the given amounts.
<a name="988"/>   #
<a name="989"/>   public shift(dx, dy)
<a name="990"/>      self.x +:= dx
<a name="991"/>      self.y +:= dy
<a name="992"/>      every (!children).shift(dx, dy)
<a name="993"/>   end
<a name="994"/>
<a name="995"/>   #
<a name="996"/>   # Recursively call `reset_layout()` on this component and all of
<a name="997"/>   # its descendants.
<a name="998"/>   #
<a name="999"/>   public reset_all_layouts()
<a name="1000"/>      reset_layout()
<a name="1001"/>      every (!self.children).reset_all_layouts()
<a name="1002"/>      link
<a name="1003"/>   end
<a name="1004"/>
<a name="1005"/>   #
<a name="1006"/>   # Invoke the `reset()` method of the layout delegate (if any).
<a name="1007"/>   #
<a name="1008"/>   public reset_layout()
<a name="1009"/>      (\layout_delegate).reset()
<a name="1010"/>      link
<a name="1011"/>   end
<a name="1012"/>
<a name="1013"/>   #
<a name="1014"/>   # Invoke `reset_layout()` on this component and all of its
<a name="1015"/>   # ancestors.
<a name="1016"/>   #
<a name="1017"/>   public reset_layout_chain()
<a name="1018"/>      every gen_parents().reset_layout()
<a name="1019"/>      link
<a name="1020"/>   end
<a name="1021"/>
<a name="1022"/>   #
<a name="1023"/>   # Compute the absolute positions and sizes from the
<a name="1024"/>   # specifications given by `set_pos()` and `set_size()`.
<a name="1025"/>   #
<a name="1026"/>   public compute_absolutes()
<a name="1027"/>      local wspec, hspec
<a name="1028"/>      #
<a name="1029"/>      # Check for unspecified fields
<a name="1030"/>      #
<a name="1031"/>      \self.x_spec | runerr("x position unspecified")
<a name="1032"/>      \self.y_spec | runerr("y position unspecified")
<a name="1033"/>
<a name="1034"/>      self.x := parent.x + parse_pos(parent.w, self.x_spec) | runerr("Invalid x position specification", self.x_spec)
<a name="1035"/>      self.y := parent.y + parse_pos(parent.h, self.y_spec) | runerr("Invalid y position specification", self.y_spec)
<a name="1036"/>      wspec := \self.w_spec | get_preferred_width()
<a name="1037"/>      self.w := parse_pos(parent.w, wspec) | runerr("Invalid width specification", wspec)
<a name="1038"/>      hspec := \self.h_spec | get_preferred_height(self.w)
<a name="1039"/>      self.h := parse_pos(parent.h, hspec) | runerr("Invalid height specification", hspec)
<a name="1040"/>
<a name="1041"/>      #
<a name="1042"/>      # Adjust x, y based on alignments
<a name="1043"/>      #
<a name="1044"/>      case self.x_align of {
<a name="1045"/>         Align.C : self.x -:= self.w / 2
<a name="1046"/>         Align.R : self.x -:= self.w
<a name="1047"/>         Align.L : &amp;null
<a name="1048"/>         default : runerr("Incorrect x alignment specifier", self.x_align)
<a name="1049"/>      }
<a name="1050"/>      case self.y_align of {
<a name="1051"/>         Align.C : self.y -:= self.h / 2
<a name="1052"/>         Align.B : self.y -:= self.h
<a name="1053"/>         Align.T : &amp;null
<a name="1054"/>         default : runerr("Incorrect y alignment specifier", self.y_align)
<a name="1055"/>      }
<a name="1056"/>   end
<a name="1057"/>
<a name="1058"/>   #
<a name="1059"/>   # Given a `WinEvent` `e`, recursively add to list `l` so that it
<a name="1060"/>   # contains a list of the components containing the point, with the
<a name="1061"/>   # deepest in the component hierarchy being at the front of the
<a name="1062"/>   # list.
<a name="1063"/>   #
<a name="1064"/>   public build_point_chain(l, e)
<a name="1065"/>      local c
<a name="1066"/>      if c := whose_point(e.x, e.y) then {
<a name="1067"/>         c.build_point_chain(l, e)
<a name="1068"/>         put(l, c)
<a name="1069"/>      }
<a name="1070"/>   end
<a name="1071"/>
<a name="1072"/>   #
<a name="1073"/>   # Traverse all the components, including subcomponents, with a
<a name="1074"/>   # post-order traversal.
<a name="1075"/>   #
<a name="1076"/>   public traverse_postorder()
<a name="1077"/>      every (!self.children).traverse_postorder()
<a name="1078"/>      coact(self)
<a name="1079"/>   end
<a name="1080"/>
<a name="1081"/>   #
<a name="1082"/>   # Traverse all the components, including subcomponents, with a
<a name="1083"/>   # pre-order traversal.
<a name="1084"/>   #
<a name="1085"/>   public traverse_preorder()
<a name="1086"/>      coact(self)
<a name="1087"/>      every (!self.children).traverse_preorder()
<a name="1088"/>   end
<a name="1089"/>
<a name="1090"/>   #
<a name="1091"/>   # Return the preferred focus, if it accepts focus.
<a name="1092"/>   #
<a name="1093"/>   public find_focus(e)
<a name="1094"/>      if self.preferred_focus.is_unshaded() &amp; 
<a name="1095"/>         self.preferred_focus.is_unhidden() &amp;
<a name="1096"/>         self.preferred_focus.accepts_focus(e) then
<a name="1097"/>         return self.preferred_focus
<a name="1098"/>   end
<a name="1099"/>
<a name="1100"/>   #
<a name="1101"/>   # Search for a component with the matching accelerator key within
<a name="1102"/>   # components rooted at this component.
<a name="1103"/>   #
<a name="1104"/>   public find_accel(e)
<a name="1105"/>      local c, f
<a name="1106"/>
<a name="1107"/>      if self.is_unshaded() &amp; self.is_unhidden() then {
<a name="1108"/>         # Note this is a pre-order search.  This is needed for TabSet, which
<a name="1109"/>         # wants to handle its tabs' accelerator keys.
<a name="1110"/>
<a name="1111"/>         if match_accel(e) then
<a name="1112"/>            link
<a name="1113"/>
<a name="1114"/>         every c := !self.children do {
<a name="1115"/>            if f := c.find_accel(e) then
<a name="1116"/>               return f
<a name="1117"/>         }
<a name="1118"/>      }
<a name="1119"/>   end
<a name="1120"/>
<a name="1121"/>   #
<a name="1122"/>   # Generate the focusable children of this tree of components, in tab focus order.
<a name="1123"/>   #
<a name="1124"/>   public gen_focusable(e)
<a name="1125"/>      local c
<a name="1126"/>      every c := Seq{traverse_tab_order()} do {
<a name="1127"/>         if c.accepts_focus(e) &amp; c.is_unhidden() &amp; c.is_unshaded() then
<a name="1128"/>            suspend c
<a name="1129"/>      }
<a name="1130"/>   end
<a name="1131"/>
<a name="1132"/>   #
<a name="1133"/>   # Succeed if the given (key) event matches this component's accelerator.
<a name="1134"/>   #
<a name="1135"/>   public match_accel(e)
<a name="1136"/>      succeed self.accel === e
<a name="1137"/>   end
<a name="1138"/>
<a name="1139"/>   #
<a name="1140"/>   # Traverse the components under this tree in the order in which
<a name="1141"/>   # tab focus should iterate over them.
<a name="1142"/>   #
<a name="1143"/>   public traverse_tab_order()
<a name="1144"/>      coact(self)
<a name="1145"/>      every (!self.tab_children).traverse_tab_order()
<a name="1146"/>   end
<a name="1147"/>
<a name="1148"/>   #
<a name="1149"/>   # Invalidate the `Component`'s rectangle on the screen, optionally
<a name="1150"/>   # intersected with `r`.
<a name="1151"/>   #
<a name="1152"/>   public invalidate(r)
<a name="1153"/>      if self.is_live() &amp; self.is_unhidden() then
<a name="1154"/>         parent_dialog.invalidate_rect(if /r then get_clip_rect()
<a name="1155"/>                                       else r.intersect(get_clip_rect()))
<a name="1156"/>      link
<a name="1157"/>   end
<a name="1158"/>
<a name="1159"/>   # Invoke layout() and return self.
<a name="1160"/>   #
<a name="1161"/>   public do_layout()
<a name="1162"/>      layout()
<a name="1163"/>      link
<a name="1164"/>   end
<a name="1165"/>
<a name="1166"/>   #
<a name="1167"/>   # Get the clipping rectangle of this component, ie the rectangle actually
<a name="1168"/>   # visible (ignoring other overlapping components).  Fails if the component is
<a name="1169"/>   # not visible at all.
<a name="1170"/>   #
<a name="1171"/>   public get_clip_rect()
<a name="1172"/>      local r, c
<a name="1173"/>      c := r := self
<a name="1174"/>      repeat {
<a name="1175"/>         c := c.parent
<a name="1176"/>         if /c then
<a name="1177"/>            return r
<a name="1178"/>         r := r.intersect(c) | fail
<a name="1179"/>      }
<a name="1180"/>   end
<a name="1181"/>
<a name="1182"/>   #
<a name="1183"/>   # Compute the z_children list.
<a name="1184"/>   #
<a name="1185"/>   public compute_z_order()
<a name="1186"/>      self.z_children := isort(self.children, component_zsort)
<a name="1187"/>   end
<a name="1188"/>
<a name="1189"/>   #
<a name="1190"/>   # Compute the tab order list.
<a name="1191"/>   #
<a name="1192"/>   public compute_tab_order()
<a name="1193"/>      self.tab_children := isort(self.children, component_tabsort)
<a name="1194"/>   end
<a name="1195"/>
<a name="1196"/>   private static component_zsort(c)
<a name="1197"/>      return c.z
<a name="1198"/>   end
<a name="1199"/>
<a name="1200"/>   private static component_tabsort(c)
<a name="1201"/>      return c.tab_ord
<a name="1202"/>   end
<a name="1203"/>
<a name="1204"/>   #
<a name="1205"/>   # Add the `Component` to the list of children.
<a name="1206"/>   #
<a name="1207"/>   # :Parameters :
<a name="1208"/>   # :  `c` - The `Component` to add.
<a name="1209"/>   # :  `i` - The index to add at; if omitted then the new component
<a name="1210"/>   #            is appended to the end.
<a name="1211"/>   # :Fails :
<a name="1212"/>   # :  If i is out of range
<a name="1213"/>   #
<a name="1214"/>   public add(c, i)
<a name="1215"/>      /i := 0
<a name="1216"/>      insert(self.children, i, c) | fail
<a name="1217"/>      c.set_parent(self)
<a name="1218"/>      if is_initialized() then {
<a name="1219"/>         compute_z_order()
<a name="1220"/>         compute_tab_order()
<a name="1221"/>         c.initially()
<a name="1222"/>      }
<a name="1223"/>      link
<a name="1224"/>   end
<a name="1225"/>
<a name="1226"/>   #
<a name="1227"/>   # Get the index of the given child component
<a name="1228"/>   #
<a name="1229"/>   public get_index(c)
<a name="1230"/>      return keyof(self.children, c)
<a name="1231"/>   end
<a name="1232"/>
<a name="1233"/>   #
<a name="1234"/>   # Remove the `Component` from the list of children.
<a name="1235"/>   # :Parameters :
<a name="1236"/>   # :  `c` - The `Component` to remove.
<a name="1237"/>   # :Fails :
<a name="1238"/>   # :  If c is not a child of this instance.
<a name="1239"/>   #
<a name="1240"/>   public remove(c)
<a name="1241"/>      return remove_index(get_index(c))
<a name="1242"/>   end
<a name="1243"/>
<a name="1244"/>   #
<a name="1245"/>   # Remove the `Component` at the given index from the list of children.
<a name="1246"/>   # :Parameters :
<a name="1247"/>   # :  `i` - The index
<a name="1248"/>   # :Fails :
<a name="1249"/>   # :  If i is out of range
<a name="1250"/>   #
<a name="1251"/>   public remove_index(i)
<a name="1252"/>      local c
<a name="1253"/>      c := self.children[i] | fail
<a name="1254"/>      delete(self.children, i)
<a name="1255"/>      c.set_parent(&amp;null)
<a name="1256"/>      if is_initialized() then {
<a name="1257"/>         compute_z_order()
<a name="1258"/>         compute_tab_order()
<a name="1259"/>         c.finally()
<a name="1260"/>      }
<a name="1261"/>      link
<a name="1262"/>   end
<a name="1263"/>
<a name="1264"/>   #
<a name="1265"/>   # Remove all the children.
<a name="1266"/>   #
<a name="1267"/>   public remove_all()
<a name="1268"/>      link remove_list()
<a name="1269"/>   end
<a name="1270"/>
<a name="1271"/>   #
<a name="1272"/>   # Move the `Component` to the given index position.
<a name="1273"/>   # :Parameters :
<a name="1274"/>   # :  `c` - The `Component` to move.
<a name="1275"/>   # :  `j` - The new position.
<a name="1276"/>   # :Fails :
<a name="1277"/>   # :  If c is not a child of this instance, 
<a name="1278"/>   #             or j is out of range.
<a name="1279"/>   #
<a name="1280"/>   public reposition(c, j)
<a name="1281"/>      return reposition_index(get_index(c), j)
<a name="1282"/>   end
<a name="1283"/>
<a name="1284"/>   #
<a name="1285"/>   # Move the `Component` at position `i` to `j`.
<a name="1286"/>   # :Parameters :
<a name="1287"/>   # :  `i` - The old position.
<a name="1288"/>   # :  `j` - The new position.
<a name="1289"/>   # :Fails :
<a name="1290"/>   # :  If either index is out of range.
<a name="1291"/>   #
<a name="1292"/>   public reposition_index(i, j)
<a name="1293"/>      lmove(children, i, j) | fail
<a name="1294"/>      if is_initialized() then {
<a name="1295"/>         compute_z_order()
<a name="1296"/>         compute_tab_order()
<a name="1297"/>      }
<a name="1298"/>      link
<a name="1299"/>   end
<a name="1300"/>
<a name="1301"/>   #
<a name="1302"/>   # Succeed iff the component has been initialized with `initially()`, but
<a name="1303"/>   # not yet cleaned up with `finally()`.
<a name="1304"/>   #
<a name="1305"/>   public is_initialized()
<a name="1306"/>      succeed \self.parent_dialog
<a name="1307"/>   end
<a name="1308"/>
<a name="1309"/>   # Remove the children in the range `i:j`, returning the
<a name="1310"/>   # removed children in a list.
<a name="1311"/>   # :Parameters :
<a name="1312"/>   # :  `i` - The start slice index, default 1
<a name="1313"/>   # :  `j` - The end slice index, default 0
<a name="1314"/>   # :Fails :
<a name="1315"/>   # :  If the range is invalid.
<a name="1316"/>   #
<a name="1317"/>   #
<a name="1318"/>   public remove_list(i, j)
<a name="1319"/>      local l
<a name="1320"/>      l := lextract(children, i, j) | fail
<a name="1321"/>      every (!l).set_parent(&amp;null)
<a name="1322"/>      if is_initialized() then {
<a name="1323"/>         compute_z_order()
<a name="1324"/>         compute_tab_order()
<a name="1325"/>         every (!l).finally()
<a name="1326"/>      }
<a name="1327"/>      return l
<a name="1328"/>   end
<a name="1329"/>
<a name="1330"/>   # Add all the `Component`s contained in list `l` at index `i`.
<a name="1331"/>   #
<a name="1332"/>   # :Parameters :
<a name="1333"/>   # :  `l` - The list to add
<a name="1334"/>   # :  `i` - The index
<a name="1335"/>   # :Fails :
<a name="1336"/>   # :  If i is out of range
<a name="1337"/>   #
<a name="1338"/>   public add_list(l, i)
<a name="1339"/>      linsert(children, l, i) | fail
<a name="1340"/>      every (!l).set_parent(self)
<a name="1341"/>      if is_initialized() then {
<a name="1342"/>         compute_z_order()
<a name="1343"/>         compute_tab_order()
<a name="1344"/>         every (!l).initially()
<a name="1345"/>      }
<a name="1346"/>      link
<a name="1347"/>   end
<a name="1348"/>
<a name="1349"/>   # Move all the children of `other`, to this `Component`, adding
<a name="1350"/>   # them at index `i`.  `other` will be left empty.
<a name="1351"/>   #
<a name="1352"/>   # :Parameters :
<a name="1353"/>   # :  `other` - The source `Component`.
<a name="1354"/>   # :  `i` - The index to add at; if omitted then the new components
<a name="1355"/>   #              are appended to the end.
<a name="1356"/>   # :Fails :
<a name="1357"/>   # :  If i is out of range
<a name="1358"/>   #
<a name="1359"/>   public move_all(other, i)
<a name="1360"/>      return add_list(other.remove_list(), i)
<a name="1361"/>   end
<a name="1362"/>
<a name="1363"/>   #
<a name="1364"/>   # Succeed iff the component has been initialized AND has a position and
<a name="1365"/>   # size on the screen, ie has been laid out by its parent.
<a name="1366"/>   #
<a name="1367"/>   public is_live()
<a name="1368"/>      succeed \self.x &amp; \self.parent_dialog
<a name="1369"/>   end
<a name="1370"/>
<a name="1371"/>   #
<a name="1372"/>   # Get the list of `Component`s in this `Container`.
<a name="1373"/>   # :Returns :
<a name="1374"/>   # :  The list of `Component`s
<a name="1375"/>   #
<a name="1376"/>   public get_children()
<a name="1377"/>      return self.children
<a name="1378"/>   end
<a name="1379"/>
<a name="1380"/>   #
<a name="1381"/>   # Invoked on a drag gesture; if the component wishes to start a
<a name="1382"/>   # drag and drop session, it should succeed and return the drag
<a name="1383"/>   # content, otherwise it should fail.  The drag content is
<a name="1384"/>   # subsequently stored in the `content` of the current `Drag`
<a name="1385"/>   # object.
<a name="1386"/>   #
<a name="1387"/>   # NB - this method will only be invoked if the allow_drag flag is
<a name="1388"/>   # non-null (see `set_allow_drag()`).
<a name="1389"/>   #
<a name="1390"/>   # :Parameters :
<a name="1391"/>   # :  `e` - the event, an instance of WindowEvent
<a name="1392"/>   #
<a name="1393"/>   public can_drag(e)
<a name="1394"/>   end
<a name="1395"/>
<a name="1396"/>   #
<a name="1397"/>   # Invoked after `can_drag` succeeds, at the beginning of an
<a name="1398"/>   # operation.  Two pointers, "dnd positive" and "dnd negative"
<a name="1399"/>   # should be defined to indicate to the user whether the current
<a name="1400"/>   # operation has a potential drop or not.  By default, this method
<a name="1401"/>   # just uses two pre-defined pointers.
<a name="1402"/>   #
<a name="1403"/>   public define_dnd_pointers(drag)
<a name="1404"/>      cbwin.copy_pointer("dnd negative", Dialog.DND_NEGATIVE_POINTER)
<a name="1405"/>      cbwin.copy_pointer("dnd positive", Dialog.DND_POSITIVE_POINTER)
<a name="1406"/>   end
<a name="1407"/>
<a name="1408"/>   #
<a name="1409"/>   # Invoked during a drag.  The component may update itself to
<a name="1410"/>   # indicate a potential drop location.  If it succeeds, then this
<a name="1411"/>   # component becomes the "drag holder".  It is the only component
<a name="1412"/>   # for which drag_event() is called in the future.  Should the
<a name="1413"/>   # method fail, then the component ceases to be the "drag holder"
<a name="1414"/>   # and other components are tried again.
<a name="1415"/>   #
<a name="1416"/>   # NB - this method will only be invoked if the allow_drop flag is
<a name="1417"/>   # non-null (see `set_allow_drop()`).
<a name="1418"/>   #
<a name="1419"/>   # :Parameters :
<a name="1420"/>   # :  `drag` - the current Drag object.
<a name="1421"/>   # :  `e` - the drag event
<a name="1422"/>   #
<a name="1423"/>   public drag_event(drag, e)
<a name="1424"/>   end
<a name="1425"/>
<a name="1426"/>   #
<a name="1427"/>   # Invoked on the "drag holder", ie after the drag_event() method
<a name="1428"/>   # has succeeded for a particular event.  The method indicates
<a name="1429"/>   # whether the current location is suitable for a drop.  The mouse
<a name="1430"/>   # cursor is updated accordingly.  The component remains the "drag
<a name="1431"/>   # holder" regardless of whether this method succeeds or fails.  On
<a name="1432"/>   # success, the data returned is put into the content field of a
<a name="1433"/>   # Drag object, which is passed to `perform_drop()` on a drop event.
<a name="1434"/>   #
<a name="1435"/>   # It may also be invoked independently of any particular event, for
<a name="1436"/>   # example if the state potentially changes via a ticker.  In this
<a name="1437"/>   # case the passed event is null.
<a name="1438"/>   #
<a name="1439"/>   # :Parameters :
<a name="1440"/>   # :  `drag` - the current Drag object.
<a name="1441"/>   # :  `e` - the drag event; may be `&amp;null`.
<a name="1442"/>   #
<a name="1443"/>   public can_drop(drag, e)
<a name="1444"/>   end
<a name="1445"/>
<a name="1446"/>   #
<a name="1447"/>   # Invoked on a drop.  The component's can_drop() method has
<a name="1448"/>   # previously succeeded during the drag.  However, the component can
<a name="1449"/>   # still reject the drop if it so wishes.
<a name="1450"/>   #
<a name="1451"/>   # If the component accepts the drop, it should handle it and succeed;
<a name="1452"/>   # otherwise it should fail.
<a name="1453"/>   #
<a name="1454"/>   # NB - this method will only be invoked if the allow_drop flag is
<a name="1455"/>   # non-null (see `set_allow_drop()`).
<a name="1456"/>   #
<a name="1457"/>   # :Parameters :
<a name="1458"/>   # :  `drag` - the current Drag object representing the drag
<a name="1459"/>   # :  `drop` - the current Drag object representing the drop.
<a name="1460"/>   # :  `e` - the drop event
<a name="1461"/>   #
<a name="1462"/>   public perform_drop(drag, drop, e)
<a name="1463"/>   end
<a name="1464"/>
<a name="1465"/>   #
<a name="1466"/>   # Invoked on the component that started the drag, after a successful drop
<a name="1467"/>   # :Parameters :
<a name="1468"/>   # :  `drag` - the current Drag object representing the drag
<a name="1469"/>   # :  `drop` - the current Drag object representing the drop.
<a name="1470"/>   # :  `e` - the drop event
<a name="1471"/>   #
<a name="1472"/>   public end_drag(drag, drop, e)
<a name="1473"/>   end
<a name="1474"/>
<a name="1475"/>   #
<a name="1476"/>   # Invoked at the end of drag and drop (on the drag holder) to clear any drag state
<a name="1477"/>   # :Parameters :
<a name="1478"/>   # :  `e` - the last event
<a name="1479"/>   #
<a name="1480"/>   public drag_reset(e)
<a name="1481"/>   end
<a name="1482"/>
<a name="1483"/>   #
<a name="1484"/>   # Configure whether the component allows drags, if it is so capable.
<a name="1485"/>   #
<a name="1486"/>   public set_allow_drag(s)
<a name="1487"/>      self.allow_drag_flag := need_flag(s)
<a name="1488"/>      link
<a name="1489"/>   end
<a name="1490"/>
<a name="1491"/>   #
<a name="1492"/>   # Configure whether the component allows drops, if it is so capable.
<a name="1493"/>   #
<a name="1494"/>   public set_allow_drop(s)
<a name="1495"/>      self.allow_drop_flag := need_flag(s)
<a name="1496"/>      link
<a name="1497"/>   end
<a name="1498"/>
<a name="1499"/>   #
<a name="1500"/>   # Set a `Component` to inherit attribs from, rather than the
<a name="1501"/>   # parent.  A special value, `Gui.EMPTY_WATTRIB_ANCESTOR` may be
<a name="1502"/>   # used, which indicates that an empty table of attributes should be
<a name="1503"/>   # inherited.
<a name="1504"/>   #
<a name="1505"/>   public set_wattrib_ancestor(c)
<a name="1506"/>      self.wattrib_ancestor := c
<a name="1507"/>      link
<a name="1508"/>   end
<a name="1509"/>
<a name="1510"/>   #
<a name="1511"/>   # Set whether the component will show the layout grid, if any.
<a name="1512"/>   #
<a name="1513"/>   public set_show_layout(s)
<a name="1514"/>      self.show_layout_flag := need_flag(s)
<a name="1515"/>      link
<a name="1516"/>   end
<a name="1517"/>
<a name="1518"/>   #
<a name="1519"/>   # Set the `WAttrib.BG` attribute; see `set_wattrib()`.
<a name="1520"/>   #
<a name="1521"/>   public set_bg(v)
<a name="1522"/>      return set_wattrib(WAttrib.BG, v)
<a name="1523"/>   end
<a name="1524"/>
<a name="1525"/>   #
<a name="1526"/>   # Set the `WAttrib.FG` attribute; see `set_wattrib()`.
<a name="1527"/>   #
<a name="1528"/>   public set_fg(v)
<a name="1529"/>      return set_wattrib(WAttrib.FG, v)
<a name="1530"/>   end
<a name="1531"/>
<a name="1532"/>   #
<a name="1533"/>   # Set the `WAttrib.DRAW_OP` attribute; see `set_wattrib()`.
<a name="1534"/>   #
<a name="1535"/>   public set_draw_op(v)
<a name="1536"/>      return set_wattrib(WAttrib.DRAW_OP, v)
<a name="1537"/>   end
<a name="1538"/>
<a name="1539"/>   #
<a name="1540"/>   # Set the `WAttrib.FONT` attribute; see `set_wattrib()`.
<a name="1541"/>   #
<a name="1542"/>   public set_font(v)
<a name="1543"/>      return set_wattrib(WAttrib.FONT, v)
<a name="1544"/>   end
<a name="1545"/>
<a name="1546"/>   #
<a name="1547"/>   # Set the `WAttrib.LEADING` attribute; see `set_wattrib()`.
<a name="1548"/>   #
<a name="1549"/>   public set_leading(v)
<a name="1550"/>      return set_wattrib(WAttrib.LEADING, v)
<a name="1551"/>   end
<a name="1552"/>
<a name="1553"/>   #
<a name="1554"/>   # Set the `WAttrib.LINE_WIDTH` attribute; see `set_wattrib()`.
<a name="1555"/>   #
<a name="1556"/>   public set_line_width(v)
<a name="1557"/>      return set_wattrib(WAttrib.LINE_WIDTH, v)
<a name="1558"/>   end
<a name="1559"/>
<a name="1560"/>   #
<a name="1561"/>   # Set the `WAttrib.LINE_END` attribute; see `set_wattrib()`.
<a name="1562"/>   #
<a name="1563"/>   public set_line_end(v)
<a name="1564"/>      return set_wattrib(WAttrib.LINE_END, v)
<a name="1565"/>   end
<a name="1566"/>
<a name="1567"/>   #
<a name="1568"/>   # Set the `WAttrib.LINE_JOIN` attribute; see `set_wattrib()`.
<a name="1569"/>   #
<a name="1570"/>   public set_line_join(v)
<a name="1571"/>      return set_wattrib(WAttrib.LINE_JOIN, v)
<a name="1572"/>   end
<a name="1573"/>
<a name="1574"/>   #
<a name="1575"/>   # Set the `WAttrib.PATTERN` attribute; see `set_wattrib()`.
<a name="1576"/>   #
<a name="1577"/>   public set_pattern(v)
<a name="1578"/>      return set_wattrib(WAttrib.PATTERN, v)
<a name="1579"/>   end
<a name="1580"/>
<a name="1581"/>   #
<a name="1582"/>   # Set the `WAttrib.MASK` attribute; see `set_wattrib()`.
<a name="1583"/>   #
<a name="1584"/>   public set_mask(v)
<a name="1585"/>      return set_wattrib(WAttrib.MASK, v)
<a name="1586"/>   end
<a name="1587"/>
<a name="1588"/>   public override new()
<a name="1589"/>      Connectable.new()
<a name="1590"/>      self.wattribs := table()
<a name="1591"/>      self.children := []
<a name="1592"/>      self.x_align := Align.L
<a name="1593"/>      self.y_align := Align.T
<a name="1594"/>      self.constraints := table()
<a name="1595"/>      self.preferred_focus := self
<a name="1596"/>      self.z := self.tab_ord := 0
<a name="1597"/>      self.tooltip_start_delay := Dialog.TOOLTIP_START_DELAY
<a name="1598"/>      self.tooltip_end_delay := Dialog.TOOLTIP_END_DELAY
<a name="1599"/>      return
<a name="1600"/>   end
<a name="1601"/>end
</pre></body></html>
