#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package net

import 
   lang,
   util,
   ipl.lastc

#
# This class encapsulates a URL
#
class URL(ObjectOutput)
   private readable 
      scheme,
      userinfo,
      host,
      path,
      query,
      fragment,
      port

   #
   # Return the default port for the given scheme
   #
   public static get_default_port(scheme)
      return case string(scheme) of {
         "http": 80
         "https": 443
      }
   end

   #
   # Set the scheme field.
   #
   public set_scheme(x)
      self.scheme := x
      return self
   end

   #
   # Get the scheme field.
   #
   public get_scheme()
      return .self.scheme
   end

   #
   # Set the port field.
   #
   public set_port(x)
      self.port := x
      return self
   end

   #
   # Get the port field, or fail if it is not set.
   #
   public get_port()
      return .\self.port
   end

   #
   # Set the userinfo field.
   #
   public set_userinfo(x)
      self.userinfo := x
      return self
   end

   #
   # Get the userinfo field, or fail if it is not set.
   #
   public get_userinfo()
      return .\self.userinfo
   end

   #
   # Get the file, which is the path followed by the query (if any).
   #
   public get_file()
      local s
      s := path
      s ||:= "?" || \query
      return s
   end

   #
   # Return the path
   #
   public get_path()
      return .path
   end

   #
   # Set the path field.
   #
   public set_path(x)
      self.path := x
      return self
   end

   #
   # Return the query field, or fail if there is no query.
   #
   public get_query()
      return .\query
   end

   #
   # Set the query field.
   #
   public set_query(x)
      self.query := x
      return self
   end

   #
   # Set the fragment field.
   #
   public set_fragment(x)
      self.fragment := x
      return self
   end

   #
   # Get the optional fragment field, failing if none is set.
   #
   public get_fragment()
      return .\self.fragment
   end

   #
   # Set the host field.
   #
   public set_host(x)
      self.host := x
      return self
   end

   #
   # Get the host field, or fail if this is not a hierarchical url.
   #
   public get_host()
      return .\self.host
   end

   #
   # Output object
   #
   private object_output(oo)
      oo.object_string(self, str())
   end

   #
   # Convert to string representation
   #
   public str()
      local s
      s := self.scheme || ":"
      if \self.host then {
         s ||:= "//"
         s ||:= \self.userinfo || "@"
         if self.scheme == "file" then
            s ||:= "localhost" ~== self.host 
         else
            s ||:= self.host
         if \port & not(port = get_default_port(scheme)) then
            s ||:= ":" || self.port
      }
      s ||:= self.path
      s ||:= "?" || \self.query
      s ||:= "#" || \self.fragment
      return s
   end

   # Extract the cgi parameters from the {file} field.  Fails if there
   # is no query in the file part.
   # @return   A table, representing the keys and values of the fields.
   #
   public extract_cgi_parameters()
      return make_cgi_table(\query)
   end

   # Return a new URL with the query part set using
   # the table of CGI parameters.  The old query portion (if any) is
   # discarded.
   # @param cgi   The table of keys/values.
   #
   public with_cgi_parameters(cgi)
      return URL(scheme, userinfo, host, port, path, make_cgi_string(cgi), fragment)
   end

   #
   # Amend the query field given a table of CGI parameters.  The old query
   # portion (if any) is discarded.
   # @param cgi   The table of keys/values.
   #
   public set_cgi_parameters(cgi)
      self.query := make_cgi_string(cgi)
      return self
   end

   #
   # Create a URL by parsing the given string.  Returns a new {URL} if okay,
   # or sets &why on failure.
   #
   public static parse(s)
      local scheme, userinfo, host, path, query, fragment, port
      s ? {
         scheme := 1(map(tab(many(&lcase ++ &ucase ++ &digits ++ '+-.'))), =":") | return error("Scheme required")
         if ="//" then {
            userinfo := 1(tab(upto('@')), move(1))
            host := tab(upto(':/#?') | 0)
            if *host = 0 then {
               if scheme == "file" then
                  host := "localhost"
               else
                  return error("No host")
            }
            port := if =":" then
               integer(tab(many(&digits))) | return error("Bad port")
            else 
               get_default_port(scheme)
            path := tab(upto('#?') | 0)
            if *path = 0 then
               path := "/"
            else
               (path[1] == "/") | return error("Path should start with /")
         } else {
            if scheme == ("http" | "https" | "file") then
               return error("// expected")
            path := tab(upto('#?') | 0)
         }
         if any('?') then {
            move(1)
            query := tab(upto('#') | 0)
         }
         if any('#') then {
            move(1)
            fragment := tab(0)
         }
      }
      return URL(scheme, userinfo, host, port, path, query, fragment)
   end

   #
   # Return a new URL relative to this URL, based on the given relative string s.
   #
   public get_relative(s)
      local new_path, new_query, new_fragment
      if s[1:3] == "//" then
         return parse(scheme || ":" || s)
      if s[1] == "#" then
         #
         # Just reference, filename doesn't change.
         # 
         return URL(scheme, userinfo, host, port, path, query, s[2:0])
      else {
         #
         # File name and possibly reference.
         #
         if s[1] == "?" then
            # eg http://a/b/c?d + ?e -> http://a/b/c?e
            s := path || s
         else if s[1] ~== "/" then
            # eg http://a/b/c?d + e -> http://a/b/e
            s ?:= strip_dot_dirs(get_path_dir() || tab(upto('?') | 0)) || tab(0)
         s ? {
            new_path := tab(upto('#?') | 0)
            if any('?') then {
               move(1)
               new_query := tab(upto('#') | 0)
            }
            if any('#') then {
               move(1)
               new_fragment := tab(0)
            }
         }
         return URL(scheme, userinfo, host, port, new_path, new_query, new_fragment)
      }
   end

   #
   # Get the last portion of the path, ie that past the last "/".  May be
   # the empty string (eg for "http://abc.com/").
   #
   public get_path_last()
      path ? {
         tab(0)
         until lastc('/') do
            move(-1)
         return tab(0)
      }
   end

   #
   # Get the portion of the file name upto and including the last "/".  The filename
   # should always be at least a "/", so this should return at least that.
   #
   public get_path_dir()
      path ? {
         tab(0)
         until lastc('/') do
            move(-1)
         return tab(1)
      }
   end

   #
   # Create a new URL from the given constituent parts.
   #
   public new(scheme, userinfo, host, port, path, query, fragment)
      self.scheme := scheme
      self.userinfo := userinfo
      self.host := host
      self.port := port
      self.path := path
      self.query := query
      self.fragment := fragment
      return
   end

   #
   # Create a CGI parameter string from a table
   #
   public static make_cgi_string(cgi)
      local l, s
      s := ""
      every l := !sort(cgi) do {
         if string(l[2]) then
            s ||:= convert_hex(l[1]) || "=" || convert_hex(l[2]) || "&"
         else
            every s ||:= convert_hex(l[1]) || "=" || convert_hex(!l[2]) || "&"
      }
      s[-1] := ""
      return s
   end

   #
   # Create a CGI parameter string by adding any encoding necessary.
   #
   public static convert_hex(s)
      local res
      static convert_chars
      initial 
         convert_chars := &lcase ++ &ucase ++ &digits ++ '_*.\- '
      s := string(s) | runerr(103, s)
      res := ""
      s ? repeat {
         res ||:= tab(many(convert_chars))
         if pos(0) then
            break
         res ||:= "%" || Format.int_to_string(ord(move(1)),,2)
      }
      res := map(res, " ", "+")
      return res
   end

   #
   # Make a cgi param table from the given string.  Note that the keys and entries are
   # always strings (never ucs).
   # @return   A table, representing the keys and values of the fields.
   #
   public static make_cgi_table(s)
      local cgi, key, val, l
      s := string(s) | runerr(103, s)
      cgi := table()
      s ? {
         until pos(0) do {
            key := tab(upto('&=') | 0)
            if ="=" then
               val := extract_hex(tab(upto('&') | 0))
            else
               val := ""
            ="&"
            (l := member(cgi, key)) | insert(cgi, key, l := [])
            put(l, val)
         }
      }
      return cgi
   end

   #
   # Convert a CGI parameter string by extracting any encoded
   # characters.  The result is always a string, never ucs.
   #
   public static extract_hex(s)
      local res
      s := string(s) | runerr(103, s)
      res := ""
      s := map(s, "+", " ") 
      s ? repeat {
         res ||:= tab(upto('%') | 0)
         move(1) | break
         res ||:= char("16r" || move(2))
      }
      return res
   end

   private static rmdir(s, i)
      while s[i - 1] ~== "/" do
         i -:= 1
      # Never remove the root /
      return 1 < i
   end

   #
   # Remove the dotted dirs from a file path, eg "/a/b/c/../g"->"/a/b/g"
   #
   public static strip_dot_dirs(s)
      local i
      while i := find("/.", s) do {
         if s[i+:4] == "/../" then
            (s[rmdir(s, i):i + 4] := "") | break
         else if s[i:0] == "/.." then
            (s[rmdir(s, i):0] := "") | break
         else if s[i+:3] == "/./" then
            s[i+:3] := "/"
         else if s[i:0] == "/." then
            s[i:0] := "/"
         else
            break
      }
      return s
   end
end
