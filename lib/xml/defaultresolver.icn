#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package xml

import http, net, util, io

#
# The default resolver resolves from a URL or the local file system.
#
# If the system id begins with "http://", it is treated as a web URL, and
# loaded over the network.  
#
# If it begins with "file://", then it is treated as a
# local file (for an absolute path on Unix like systems, that would be
# three forward slashes at the start : "file:///tmp/file.dtd").
#
# Otherwise, the system id is treated as a filename.
#
# @field cache_uris=flag: see {set_cache_uris}
# @field http_client={HttpClient}: see {set_http_client}
#
class DefaultResolver(Resolver,SetFields)
   private
      public_mapping,
      uri_cache,
      cache_uris_flag,
      http_client

   #
   # Set a mapping from a public id to an alternative URI.  The alternative URI
   # will then be loaded when the public id is encountered, rather than the
   # given system id.  The alternative may be a simple filename if desired.
   #
   # @example 
   # @  set_public_mapping("-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN", 
   # @                     "/tmp/web-app_2_3.dtd")
   # @param pub_id the public id
   # @param uri the alternative uri
   #
   public set_public_mapping(pub_id, uri)
      insert(public_mapping, pub_id, uri)
   end

   #
   # Configure whether the resolver remembers URIs internally to save getting them
   # more than once.  This is on by default.
   #
   public set_cache_uris(s)
      self.cache_uris_flag := to_flag(s)
   end

   #
   # Use the given HttpClient for getting http:// URLs.  Use this to set custom timeout
   # or retry values for example.
   #
   public set_http_client(hc)
      self.http_client := hc
   end

   #
   # Cache an individual system id (URI) to the given value.
   #
   public cache_uri(sys_id, val)
      insert(uri_cache, sys_id, val)
   end

   public resolve(external_id)
      local sys_id, res

      #
      # Try to map from the public id (if any) to an alternative URI
      #
      if member(public_mapping, external_id.get_public_id()) then
         sys_id := public_mapping[external_id.get_public_id()]
      else
         sys_id := external_id.get_system_id()

      #
      # Try the cache.
      #
      if \cache_uris_flag & member(uri_cache, sys_id) then
         return uri_cache[sys_id]

      res := resolve_impl(sys_id) | fail

      #
      # Cache if appropriate
      #
      if \cache_uris_flag then
         cache_uri(sys_id, res)

      return res
   end

   private resolve_impl(sys_id)
      if match("http://", sys_id) then
         return get_http(sys_id)

      if match("file://", sys_id) then
         return get_local(sys_id[8:0])

      return get_local(sys_id)
   end

   private get_local(sys_id)
      return Files.file_to_string(sys_id) | error("Couldn't open:" || sys_id)
   end

   private get_http(sys_id)
      local url, hp, hr, sb

      url := URL.parse(sys_id) | fail

      sb := RamStream()
      hr := HttpRequest("url=",url, "data_stream=",sb)
      hp := http_client.retrieve(hr) | {
         sb.close()
         fail
      }

      return sb.done()
   end

   protected set_one(f)
      case f.attr of {
         "cache_uris": set_cache_uris(f.flag_val())
         "http_client": set_http_client(f.object_val(HttpClient))
         default : fail
      }
      return
   end

   public new(a[])
      public_mapping := table()
      uri_cache := table()
      cache_uris_flag := 1
      self.http_client := HttpClient()
      set_fields(a)
      return
   end
end

