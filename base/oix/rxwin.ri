/*
 * File: rxwin.ri - X11 system-specific graphics interface code.
 */

#ifdef Graphics

#define RootState IconicState+1

/*
 * Global variables specific to X
 */
XSizeHints size_hints;

/*
 * function prototypes
 */
static int	     handle_misc      (wdp display, wbp w);
static int	     handle_config    (wbp w, XConfigureEvent *event);
static int           handle_exposures (wbp w, XExposeEvent *event);
static void          handle_mouse     (wbp w, XButtonEvent *event);
static void          handle_keypress  (wbp w, XKeyEvent *event);
static XImage *	     getximage	      (wbp w, int x, int y,
                                       int width, int height, int init);
static void          moveWindow       (wbp w, int x, int y);
static int           moveResizeWindow	(wbp w, int x, int y, int wd, int h);
static void          makeIcon         (wbp w, int x, int y);
static int	     wmap	      (wbp w, wbp parent);
static Pixmap        loadimage	      (wbp w, char *filename, unsigned int *height, 
                                       unsigned int *width, int atorigin, int *status);
static int convert_KeySym_to_code_point(KeySym k);

#ifdef HAVE_LIBXFT
int xft_stringwidth(wbp w, char *s, int n);
#endif

stringint drawops[] = {
   { 0, 16},
   {"and",		GXand},
   {"andInverted",	GXandInverted},
   {"andReverse",	GXandReverse},
   {"clear",		GXclear},
   {"copy",		GXcopy},
   {"copyInverted",	GXcopyInverted},
   {"equiv",		GXequiv},
   {"invert",		GXinvert},
   {"nand",		GXnand},
   {"noop",		GXnoop},
   {"nor",		GXnor},
   {"or",		GXor},
   {"orInverted",	GXorInverted},
   {"orReverse",	GXorReverse},
   {"set",		GXset},
   {"xor",		GXxor},
};

#define NUMCURSORSYMS	78

stringint cursorsyms[] = {
  { 0, NUMCURSORSYMS},
  {"X cursor",		XC_X_cursor},
  {"arrow",		XC_arrow},
  {"based arrow down",	XC_based_arrow_down},
  {"based arrow up",	XC_based_arrow_up},
  {"boat",		XC_boat},
  {"bogosity",		XC_bogosity},
  {"bottom left corner",XC_bottom_left_corner},
  {"bottom right corner",XC_bottom_right_corner},
  {"bottom side",	XC_bottom_side},
  {"bottom tee",	XC_bottom_tee},
  {"box spiral",	XC_box_spiral},
  {"center ptr",	XC_center_ptr},
  {"circle",		XC_circle},
  {"clock",		XC_clock},
  {"coffee mug",	XC_coffee_mug},
  {"cross",		XC_cross},
  {"cross reverse",	XC_cross_reverse},
  {"crosshair",		XC_crosshair},
  {"diamond cross",	XC_diamond_cross},
  {"dot",		XC_dot},
  {"dotbox",		XC_dotbox},
  {"double arrow",	XC_double_arrow},
  {"draft large",	XC_draft_large},
  {"draft small",	XC_draft_small},
  {"draped box",	XC_draped_box},
  {"exchange",		XC_exchange},
  {"fleur",		XC_fleur},
  {"gobbler",		XC_gobbler},
  {"gumby",		XC_gumby},
  {"hand1",		XC_hand1},
  {"hand2",		XC_hand2},
  {"heart",		XC_heart},
  {"icon",		XC_icon},
  {"iron cross",	XC_iron_cross},
  {"left ptr",		XC_left_ptr},
  {"left side",		XC_left_side},
  {"left tee",		XC_left_tee},
  {"leftbutton",	XC_leftbutton},
  {"ll angle",		XC_ll_angle},
  {"lr angle",		XC_lr_angle},
  {"man",		XC_man},
  {"middlebutton",	XC_middlebutton},
  {"mouse",		XC_mouse},
  {"pencil",		XC_pencil},
  {"pirate",		XC_pirate},
  {"plus",		XC_plus},
  {"question arrow",	XC_question_arrow},
  {"right ptr",		XC_right_ptr},
  {"right side",	XC_right_side},
  {"right tee",		XC_right_tee},
  {"rightbutton",	XC_rightbutton},
  {"rtl logo",		XC_rtl_logo},
  {"sailboat",		XC_sailboat},
  {"sb down arrow",	XC_sb_down_arrow},
  {"sb h double arrow",	XC_sb_h_double_arrow},
  {"sb left arrow",	XC_sb_left_arrow},
  {"sb right arrow",	XC_sb_right_arrow},
  {"sb up arrow",	XC_sb_up_arrow},
  {"sb v double arrow",	XC_sb_v_double_arrow},
  {"shuttle",		XC_shuttle},
  {"sizing",		XC_sizing},
  {"spider",		XC_spider},
  {"spraycan",		XC_spraycan},
  {"star",		XC_star},
  {"target",		XC_target},
  {"tcross",		XC_tcross},
  {"top left arrow",	XC_top_left_arrow},
  {"top left corner",	XC_top_left_corner},
  {"top right corner",	XC_top_right_corner},
  {"top side",		XC_top_side},
  {"top tee",		XC_top_tee},
  {"trek",		XC_trek},
  {"ul angle",		XC_ul_angle},
  {"umbrella",		XC_umbrella},
  {"ur angle",		XC_ur_angle},
  {"watch",		XC_watch},
  {"xterm",		XC_xterm},
  {"num glyphs",	XC_num_glyphs},
};


static int selection_debug = 0;

static char *atom_fmt(wsp ws,Atom a) {
    static int n = 0;
    static char buff[8][96];
    char *s, *r;
    r = buff[n];
    if (a == None)
        return "None(0)";

    s = XGetAtomName(ws->display->display, a);
    if (s) {
        sprintf(r, "%.64s(%ld)", s, (long)a);
        XFree(s);
    } else {
        sprintf(r, "?unknown atom(%ld)", (long)a);
    }

    n = (n + 1) % 8;
    return r;
}

/*
 * Get the string name of the given Atom into dest.  The string is
 * allocated in the string region.
 */
void get_atom_descriptor(wsp ws, Atom a, dptr dest)
{
    char *s = XGetAtomName(ws->display->display, a);
    cstr2string(s, dest);
    XFree(s);
}


/*
 * Routines to convert property data into text strings.
 */

#define NUMBER_ATOMS    12

char*   atom_names[NUMBER_ATOMS]= {
    "CHARACTER_POSITION",
    "CLIENT_WINDOW",
    "HOST_NAME",
    "HOSTNAME",
    "LENGTH",
    "LIST_LENGTH",
    "NAME",
    "OWNER_OS",
    "SPAN",
    "TARGETS",
    "TIMESTAMP",
    "USER"
};

static Atom     atom_array[NUMBER_ATOMS];


/* Macros to access elements in atom_names array. */
#define CHARACTER_POSITION  0
#define CLIENT_WINDOW       1
#define HOST_NAME           2
#define HOSTNAME            3
#define LENGTH              4
#define LIST_LENGTH         5
#define NAME                6
#define OWNER_OS            7
#define SPAN                8
#define TARGETS             9
#define TIMESTAMP           10
#define USER                11



static int InternAtoms(Display* display)
{
    int i;

#if XlibSpecificationRelease > 5
    /*
     * X11R6 introduces XInternAtoms.
     */
    return XInternAtoms(display, atom_names, NUMBER_ATOMS, False, atom_array);

#else					/* R5 and below. */

    for (i = 0; i < NUMBER_ATOMS; i++) {
        atom_array[i] = XInternAtom(display, atom_names[i], False);

        if (atom_array[i] == None) {
            return 0;
        }
    }

    return 1;

#endif					/* R5 and below. */
}


Atom ConvertTarget(Display* display, Atom desired_target)
{
    static int  intern_status = 0;

    /* Ensure that our atoms are interned. */
    if (intern_status == 0) {
        intern_status = InternAtoms(display);
    }

    /* Check for common cases. */
    if ( (desired_target == atom_array[TIMESTAMP])    ||
         (desired_target == atom_array[LIST_LENGTH] ) ||
         (desired_target == atom_array[LENGTH] ) ) {
        return XA_INTEGER;
    }

    if ( desired_target == atom_array[CHARACTER_POSITION] ) {
        return atom_array[SPAN];
    }

    if ( desired_target == atom_array[TARGETS] ) {
        return XA_ATOM;
    }

    if ( desired_target == atom_array[CLIENT_WINDOW] ) {
        return XA_WINDOW;
    }

    if (( desired_target == atom_array[HOST_NAME] ) ||
        ( desired_target == atom_array[HOSTNAME] ) ||
        ( desired_target == atom_array[NAME] ) ||
        ( desired_target == atom_array[OWNER_OS] ) ||
        ( desired_target == atom_array[USER] ) ) {
        return XA_STRING;
    }
    /* Otherwise, no need to convert target. */
    return desired_target;
}

char* PropertyToString(Display* display, Atom target, int number_items,
                       void* data)
{
    Atom            new_target;
    Atom            timestamp, span;
    unsigned long*  long_array;
    int*            int_array;
    char*           string0 = NULL;
    int             i, length;
    char            temp[100];
    char*           atom_name;

    /* Convert our atoms. */
    timestamp = XInternAtom(display, "TIMESTAMP", False);
    span      = XInternAtom(display, "SPAN", False);

    /* Convert target, if necessary. */
    new_target = ConvertTarget(display, target);

    if (new_target == XA_ATOM) {

        long_array = (unsigned long*) data;

        length = number_items * 30;
        MemProtect(string0 = malloc( length + 1 ));
        string0[0] = '\0';

        /* Convert to atom names. */
        for (i = 0; i < number_items; i++) {
            atom_name = XGetAtomName(display, long_array[i] );

            if (atom_name != NULL) {

                /* Check that space is available. */
                length -= strlen(atom_name);
 
                if (length > 1) {
                    strcat(string0, atom_name);
                    strcat(string0, "\n");
                }
                XFree(atom_name);
            }
        }
    }
    else if (new_target == XA_STRING) {
        MemProtect(string0 = malloc(number_items + 1));
        strcpy(string0, (char *)data);
    }
    else if ((new_target == XA_INTEGER) ||
             (new_target == span) ||
             (new_target == timestamp) ) {

        int_array = (int*) data;

        length = number_items * 20;
        MemProtect(string0 = malloc( length + 1 ));
        string0[0] = '\0';

        for (i = 0; i < number_items; i++) {
            sprintf(temp, "%d ", int_array[i]);

            /* Check that space is available. */
            length -= strlen(temp);
            if (length > 0) {
                strcat(string0, temp);
            }
        }
    }
    else if (new_target == XA_WINDOW) {

        long_array = (unsigned long*) data;

        length = number_items * 12;
        MemProtect(string0 = malloc( length + 1 ));
        string0[0] = '\0';

        for (i = 0; i < number_items; i++) {
            sprintf(temp, "0x%8.8lu ", long_array[i]);
            strcat(string0, temp);
        }

    }
    else {
        /* Add extra cases as necessary... */
    }

    return string0;

}

/*
 * Function to append data to an X property.
 */

static int     ErrorFlag = False;
static int     LastError = None;

#define BUFSIZE     1024

#define NUMBER_ERRORS   18

char*  ErrorCodes[ NUMBER_ERRORS ] = {
    "Success",           /* 0  */
    "BadRequest",        /* 1  */
    "BadValue",          /* 2  */
    "BadWindow",         /* 3  */
    "BadPixmap",         /* 4  */
    "BadAtom",           /* 5  */
    "BadCursor",         /* 6  */
    "BadFont",           /* 7  */
    "BadMatch",          /* 8  */
    "BadDrawable",       /* 9  */
    "BadAccess",         /* 10 */
    "BadAlloc",          /* 11 */
    "BadColor",          /* 12 */
    "BadGC",             /* 13 */
    "BadIDChoice",       /* 14 */
    "BadName",           /* 15 */
    "BadLength",         /* 16 */
    "BadImplementation"  /* 17 */
};


static void ErrorHandler(Display* display, XErrorEvent* error_event)
{   
    char string0[BUFSIZE + 1];
    printf("ERROR\n");fflush(stdout);
    ErrorFlag = True;
    LastError = (int) error_event->error_code;

    /* Find out the error message and print it. */
    XGetErrorText(display, error_event->error_code, string0, BUFSIZE);

    fprintf(stderr, "X Error on display %s.i\nResource %ld:  ",
            DisplayString( display ), error_event->resourceid );

    if ((error_event->error_code > 0 ) && 
        (error_event->error_code < NUMBER_ERRORS ) ) {

        fprintf( stderr, "%s (%s).\n", string0,
                 ErrorCodes[ error_event->error_code ] );
    }
    else {
        fprintf( stderr, "%s.\n", string0 );
    }

    fprintf(stderr, "Op code %d.%d, Error code %d\n", error_event->request_code,
            error_event->minor_code, error_event->error_code );
}


void ResetErrorFlag()
{  
    ErrorFlag = False;
    LastError = None;
}

void SetErrorHandler()
{   
    (void) XSetErrorHandler((XErrorHandler) ErrorHandler);
}

/*
 * handle_misc processes pending events on display.
 * if w is non-null, block until a returnable event arrives.
 * returns 1 on success, 0 on failure.
 */
static int handle_misc(wdp wd, wbp w)
{
    XEvent event;
    Window evwin;
    static int presscount = 0;
    wbp wb;
    wsp ws = 0;

    while ((w != NULL) || XPending(wd->display)) {

        XNextEvent(wd->display, &event);
        evwin = event.xexpose.window;  /* go ahead, criticize all you like */

/* could avoid doing this search every event by handling 1 window at a time */
        for (wb = wbndngs; wb; wb=wb->next) {
            ws = wb->window;
            if (ws->display == wd) {
                if (ws->win == evwin) break;
                if (ws->iconwin == evwin) break;
                if (ws->pix == evwin) break;
                if (ws->initialPix == evwin) break;
	    }
        }
        if (!wb) continue;
        if (evwin == ws->iconwin) {
            switch (event.type) {
                case Expose:
                    if (ws->iconpix)
                        XCopyArea(wd->display, ws->iconpix, ws->iconwin,
                                  wd->icongc, 0, 0, ws->iconw, ws->iconh, 3, 3);
                    else
                        XDrawString(wd->display, evwin, wd->icongc, 4,
                                    ws->display->fonts->ascent + 2,
                                    ws->iconlabel, strlen(ws->iconlabel));
                    if (ws->iconic == IconicState)
                        SETEXPOSED(wb);
                    break;
                case KeyRelease: {
                    if (ws->inputmask & KeyReleaseMask) {
                        handle_keypress(wb, (XKeyEvent *)&event);
                    }
                    break;
                }
                case KeyPress:
                    handle_keypress(wb, (XKeyEvent *)&event);
                    break;
                case ButtonPress:
                    if (ws->iconic == IconicState)
                        XMapWindow(ws->display->display, ws->win);
                    ws->iconic = NormalState;        /* set the current state */
                    break;
                case ConfigureNotify:
                    ws->iconx = ((XConfigureEvent *)&event)->x;
                    ws->icony = ((XConfigureEvent *)&event)->y;
                    break;
	    }
        }
        else {
            switch (event.type) {
                case SelectionRequest: {
                    tended struct descrip tmp;
                    if (selection_debug)
                        printf("SelectionRequest event:\n\towner=%lx requestor=%lx "
                               "property=%s target=%s selection=%s\n",
                               (long)event.xselectionrequest.owner,
                               (long)event.xselectionrequest.requestor,
                               atom_fmt(ws, event.xselectionrequest.property),
                               atom_fmt(ws, event.xselectionrequest.target),
                               atom_fmt(ws, event.xselectionrequest.selection)
                            );

                    MakeInt(SELECTIONREQUEST, &tmp);
                    list_put(&ws->listp, &tmp);
                    MakeInt((word)event.xselectionrequest.requestor, &tmp);
                    list_put(&ws->listp, &tmp);
                    get_atom_descriptor(ws, event.xselectionrequest.property, &tmp);
                    list_put(&ws->listp, &tmp);
                    get_atom_descriptor(ws, event.xselectionrequest.target, &tmp);
                    list_put(&ws->listp, &tmp);
                    get_atom_descriptor(ws, event.xselectionrequest.selection, &tmp);
                    list_put(&ws->listp, &tmp);
                    MakeInt(event.xselectionrequest.time, &tmp);
                    list_put(&ws->listp, &tmp);
                    break;
                }

                case SelectionClear: {
                    tended struct descrip tmp;
                    if (selection_debug)
                        printf("SelectionClear event win=%lx selection=%s\n",
                               (long)event.xselectionclear.window,
                               atom_fmt(ws, event.xselectionclear.selection));
                    MakeInt(SELECTIONCLEAR, &tmp);
                    list_put(&ws->listp, &tmp);
                    get_atom_descriptor(ws, event.xselectionclear.selection, &tmp);
                    list_put(&ws->listp, &tmp);
                    break;
                }

                case SelectionNotify: {
                    Atom actual_type, property;
                    int actual_format;
                    unsigned long bytes_after, nitems;
                    unsigned char *prop;
                    word bytes_read;
                    tended struct descrip tmp;
                    int status;
                    char *conv_str;

                    if (selection_debug)
                        printf("SelectionNotify: requestor=%lx selection=%s target=%s property=%s\n",
                               (long)event.xselection.requestor,
                               atom_fmt(ws, event.xselection.selection),
                               atom_fmt(ws, event.xselection.target),
                               atom_fmt(ws, event.xselection.property));

                    MakeInt(SELECTIONRESPONSE, &tmp);
                    list_put(&ws->listp, &tmp);
                    get_atom_descriptor(ws, event.xselection.selection, &tmp);
                    list_put(&ws->listp, &tmp);
                    get_atom_descriptor(ws, event.xselection.target, &tmp);
                    list_put(&ws->listp, &tmp);

                    if (event.xselection.property == None) {
                        if (selection_debug)
                            printf("XGetWindowProperty xselection.property == None\n");
                        list_put(&ws->listp, &nulldesc);
                        break;
                    }

                    property = XInternAtom(ws->display->display, "_UNICON_PROP", False);

                    status = XGetWindowProperty(ws->display->display,
                                                ws->win,
                                                property,
                                                0,
                                                8192,   /* Means we won't get back > 32kb of stuff */
                                                True,
                                                AnyPropertyType,
                                                &actual_type,
                                                &actual_format,
                                                &nitems,
                                                &bytes_after,
                                                &prop);

                    if (status != Success) {
                        if (selection_debug)
                            printf("XGetWindowProperty failed\n");
                        list_put(&ws->listp, &nulldesc);
                        break;
                    }

                    if (actual_type == None) {
                        if (selection_debug)
                            printf("XGetWindowProperty returned actual_type == None\n");
                        list_put(&ws->listp, &nulldesc);
                        break;
                    }

                    /* Shouldn't ever happen */
                    if (!prop) {
                        if (selection_debug)
                            printf("XGetWindowProperty set prop to null\n");
                        list_put(&ws->listp, &nulldesc);
                        break;
                    }

                    bytes_read = nitems * (actual_format/8);
                    if (selection_debug)
                        printf("Got %lu items x %d bits -> %ld bytes\n",nitems, actual_format, (long)bytes_read);

                    conv_str = PropertyToString(ws->display->display,
                                                actual_type,
                                                nitems,
                                                prop);
                    if (conv_str) {
                        /* Make an Icon string out of the data */
                        cstr2string(conv_str, &tmp);
                        free(conv_str);
                    } else {
                        /* Make an Icon string out of the data */
                        bytes2string((char *)prop, bytes_read, &tmp);
                    }
                    list_put(&ws->listp, &tmp);

                    XFree(prop);
                    
                    break;
                }

                case KeyRelease: {
                    if (ws->inputmask & KeyReleaseMask) {
                        handle_keypress(wb, (XKeyEvent *)&event);
                    }
                    break;
                }
                case KeyPress:
                    handle_keypress(wb, (XKeyEvent *)&event);
                    break;
                case ButtonPress:
                    presscount++;
                    handle_mouse(wb, (XButtonEvent *)&event);
                    break;
                case ButtonRelease:
                    if (--presscount < 0) presscount = 0;
                    handle_mouse(wb, (XButtonEvent *)&event);
                    break;
                case MotionNotify:
                    if (presscount || wb->window->inputmask)
                        handle_mouse(wb, (XButtonEvent *)&event);
                    break;
                case NoExpose:
                    break;
                case Expose:
                    if (!handle_exposures(wb, (XExposeEvent *)&event))
                        return 1;
                    continue;
                case UnmapNotify:
                    wb->window->iconic = IconicState;
                    continue;
                case MapNotify:
                    if ((ws->width != DisplayWidth(wd->display, wd->screen)) ||
                        (ws->height != DisplayHeight(wd->display, wd->screen)))
                        ws->iconic = NormalState;
                    else
                        ws->iconic = MaximizedState;
                    continue;
                case ConfigureNotify:
                    if (!handle_config(wb, (XConfigureEvent *)&event)) {
                        return 0;
                    }
                    break;
                case ClientMessage: {
                    /*
                     * only client message we handle at present are destroy requests
                     */
                    struct descrip d;
                    MakeInt(WINDOWCLOSED, &d);
                    qevent(wb->window, &d, 0, 0, 0, 0, 0);
                    return 1;
                    break;
                }
                case DestroyNotify:
                    if (!ISZOMBIE(wb))
                        fatalerr(141, NULL);
                    /*
                     * first of all, we are done with this window
                     */
                    ws->win = (Window) NULL;

                    /*
                     * if there are no more references, we are done with the pixmap
                     *  too.  Free it and the colors allocated for this canvas.
                     */
                    if (ws->refcount == 0) {
                        if (wb->window->pix) {
                            Display *d = ws->display->display;
                            XSync(d, False);
                            if (ws->pix)
                                XFreePixmap(d, ws->pix);
                            ws->pix = (Pixmap) NULL;
                        }
#ifdef HAVE_LIBXFT
                        if (ws->pixDraw) {
                            XftDrawDestroy(ws->pixDraw);
                            ws->pixDraw = NULL;
                        }
#endif
                        if (ws->initialPix != (Pixmap) NULL) {
                            Display *d = ws->display->display;
                            XSync(d, False);
                            XFreePixmap(d, ws->initialPix);
                            ws->initialPix = (Pixmap) NULL;
                        }
                        free_xcolors(wb, 2); /* free regular colors */
                        free_xcolors(wb, 1); /* free icon colors */
                    }
                    break;
                default:
                    continue;
            }
            if ((w != NULL) &&
                ((evwin == w->window->win) || (evwin == w->window->iconwin))) {
                return 1;
            }
        }
    }
    return 1;
}

/*
 * poll for available events on all opened displays.
 * this is where the interpreter calls into the X interface.
 */
void pollevent()
{
    wdp wd;
    for (wd = wdsplys; wd; wd = wd->next) {
        if (wd->program == curpstate)
            handle_misc(wd, NULL);
    }
}

/*
 * get a single item from w's pending queue
 */
int wgetq(wbp w, dptr res, word t)
{
    while (1) {
        STDLOCALS(w);		/* leave inside loop; ws->pix can change! */
        if (!EVQUEEMPTY(w)) {
            EVQUEGET(w,*res);
            return 1;
        }
        /* If we need a timeout, we select right here so we know an event will
           be available when XNextEvent is called by handle_misc */
        if (t > 0 && iselect(XConnectionNumber(wd->display), t) == 0)
            /* timer expired */
            return -2;
        handle_misc(wd, w);
    }
}

/*
 * wclose - close a window.  If is a real on-screen window,
 * wait for a DestroyNotify event from the server before returning.
 */
int wclose(wbp w)
{
    STDLOCALS(w);

    XSync(stddpy, False);

    pollevent();

    /*
     * Force window to close (turn into a pixmap)
     */
    if (ws->win && ws->refcount > 1) {
        SETZOMBIE(w);
#ifdef HAVE_LIBXFT
        if (ws->winDraw) {
            XftDrawDestroy(ws->winDraw);
            ws->winDraw = NULL;
        }
#endif
        XDestroyWindow(stddpy,stdwin);
        XFlush(stddpy);
        ws->refcount--;
        while (ws->win)
            pollevent();
    }
    /*
     * Entire canvas terminates
     */
    else {
        free_xcolors(w, 2);
        free_xcolors(w, 1);
/*      free_window(ws);  */
        free_binding(w);
    }

    return 0;
}
/*
 * flush a window
 */
void wflush(wbp w)
{
    STDLOCALS(w);
    XFlush(stddpy);
}
/*
 * flush all windows
 */
void wflushall()
{
    wdp wd;
    for (wd = wdsplys; wd != NULL; wd = wd->next) {
        XFlush(wd->display);
    }
}
/*
 * sync all the servers
 */
void wsync(wbp w)
{
    wdp wd;
    if (w == NULL) {
        for (wd = wdsplys; wd != NULL; wd = wd->next) {
            XSync(wd->display, False);
        }
    }
    else
        XSync(w->window->display->display, False);
}

/*
 * open a window
 * This routine really just allocates a window data structure.
 * The interesting part is done in wmap, after the user preferences
 * passed to Icon have been parsed.  Returns NULL on error/failure;
 * err_index is set to one of:
 *  >= 0: the index of an offending attribute value
 *  -1  : ordinary failure
 *  -2  : out of memory
 */
wbp wopen(wbp parent, char *name, struct b_list *lp, dptr attr, int n, int *err_index)
{
    wbp w;
    wsp ws;
    char dispchrs[256];
    char answer[128];
    char *display = NULL;
    int i;
    tended struct b_list *tlp;
    tended struct descrip attrrslt;

    tlp = lp;
    for(i=0;i<n;i++) {
        if (is:string(attr[i]) &&
            (StrLen(attr[i])>8) &&
            !strncmp("display=",StrLoc(attr[i]),8)) {
            strncpy(dispchrs,StrLoc(attr[i])+8,StrLen(attr[i])-8);
            dispchrs[StrLen(attr[i]) - 8] = '\0';
            display = dispchrs;
        }
    }

    if ((w = alc_wbinding()) == NULL) {
        *err_index = -2;
        return NULL;
    }
    if ((w->window = alc_winstate()) == NULL) {
        *err_index = -2;
        free_binding(w);
        return NULL;
    }
    if ((w->window->display = alc_display(display)) == NULL) {
        *err_index = -1; /* might be out of memory, probably bad DISPLAY var. */
        free_binding(w);
        return NULL;
    }
    ws = w->window;

    ws->vis = DefaultVisual(ws->display->display, ws->display->screen); 

    ws->listp.dword = D_List;
    BlkLoc(ws->listp) = (union block *)tlp;

    /*
     * some attributes of the display and window are used in the context
     */
	
    if ((w->context = alc_context(w)) == NULL) {
        *err_index = -2;
        free_binding(w);
        return NULL;
    }
	
    /*
     * some attributes of the context determine window defaults
     */
    ws->height = w->context->font->height * 12;
    ws->width  = w->context->font->maxwidth * 80;
    /*
     * Loop through any remaining arguments.
     */
    for (i = 0; i < n; i++){
        /*
         * write the attribute,
         *  except "display=" attribute, which is done earlier
         */
        if((StrLen(attr[i])<9)||strncmp(StrLoc(attr[i]),"display=",8)) {
            switch (wattrib((wbp) w, StrLoc(attr[i]), StrLen(attr[i]), &attrrslt,
                            answer)) {
                case Error:
                    *err_index = i;
                    return NULL;
                case Failed:
                    free_binding((wbp)w);
                    *err_index = -1;
                    return NULL;
	    }
        }
    }
    if (ws->windowlabel == NULL) {
        ws->windowlabel = salloc(name);
    }
    if ((i = wmap(w, parent)) != Succeeded) {
        if (i == Failed) *err_index = -1;
        else *err_index = 0;
        return NULL;
    }
	
    if (ws->win) {
        Atom WMDeleteWindow = XInternAtom(ws->display->display, "WM_DELETE_WINDOW", True);
        XSetWMProtocols(ws->display->display, ws->win, &WMDeleteWindow, 1);
    }

    return w;
}

/*
 * make an icon for a window
 */
static void makeIcon(wbp w, int x, int y)  /* x,y = current mouse position */
{
    int status;
    STDLOCALS(w);
   
    /* if a pixmap image has been specified, load it */
    if (ws->initicon.width) {
        ws->iconpix = XCreatePixmap(stddpy, DefaultRootWindow(stddpy),
                                    ws->iconw, ws->iconh,
                                    DefaultDepth(stddpy,wd->screen));
    }
    else if (ws->iconimage && strcmp(ws->iconimage, "")) {
        ws->iconpix = loadimage(w, ws->iconimage, &(ws->iconh), &(ws->iconw),
                                0, &status);
        ws->iconh += 6;
        ws->iconw += 6;
    }
    else {    /* determine the size of the icon window */
        ws->iconh = wd->fonts->ascent +
            wd->fonts->descent + 5;
        if (ws->iconlabel == NULL) ws->iconlabel = "";
#ifdef HAVE_LIBXFT
        ws->iconw = xft_stringwidth(w, ws->iconlabel,
                                  strlen(ws->iconlabel)) + 6;
#else
        ws->iconw = XTextWidth(wd->fonts->fsp, ws->iconlabel,
                               strlen(ws->iconlabel)) + 6;
#endif
    }

    /* if icon position hint exists, get it */
    if (ws->wmhintflags & IconPositionHint) {
        x = ws->iconx;
        y = ws->icony;
    }

    /* create the icon window */
    ws->iconwin = XCreateSimpleWindow(stddpy, DefaultRootWindow(stddpy), x, y,
                                      ws->iconw, ws->iconh, 2,
                                      wd->colors[wc->fg].c,
                                      wd->colors[wc->bg].c);

    /* select events for the icon window */
    XSelectInput(stddpy, ws->iconwin,
                 ExposureMask | KeyPressMask | ButtonPressMask |
                 StructureNotifyMask);

}


/*
 * Create a canvas.
 *  If a window, cause the window to actually become visible on the screen.
 *  returns Succeeded, Failed, or Error
 */
static int wmap(wbp w, wbp parent)
{
    XWindowAttributes attrs;
    XGCValues gcv;
    unsigned long gcmask =
        GCFont | GCForeground | GCBackground | GCFillStyle | GCCapStyle;
    struct imgdata *imd;
    int i, r;
    int new_pixmap = 0;
    struct descrip progname;
    char *p, *s, sbuf[256];
    XWMHints wmhints;
    XClassHint clhints;
    STDLOCALS(w);

    /*
     *  Create a pixmap for this canvas if there isn't one already.
     */
    if (ws->pix == (Pixmap) NULL) {
        if (ws->initialPix) {
            ws->pix = ws->initialPix;
            ws->initialPix = (Pixmap) NULL;
            ws->pixwidth = ws->width;
            ws->pixheight = ws->height;
        }
        else {
            ws->pix = XCreatePixmap(stddpy, DefaultRootWindow(stddpy),
                                    ws->width, ws->height,
                                    DefaultDepth(stddpy,wd->screen));
            ws->pixwidth = ws->width;
            ws->pixheight = ws->height;
            new_pixmap = 1;
        }
        stdpix = ws->pix;
    }


    /*
     * create the X window (or use the DefaultRootWindow if requested)
     */
    if (ws->iconic != HiddenState) {
        XSetWindowAttributes attr;
        attr.background_pixmap = None;
        attr.background_pixel = wd->colors[wc->bg].c;
        attr.border_pixel = wd->colors[wc->fg].c;
        attr.event_mask = StructureNotifyMask | ExposureMask;
 
        ws->win = ((ws->iconic == RootState) ? DefaultRootWindow(stddpy) :
                   XCreateSimpleWindow(stddpy, DefaultRootWindow(stddpy),
                                       ws->posx < 0 ? 0 : ws->posx,
                                       ws->posy < 0 ? 0 : ws->posy, ws->width,
                                       ws->height, 1,
                                       wd->colors[wc->fg].c,
                                       wd->colors[wc->bg].c));

        if (ws->win == (Window) NULL)
            return Failed;

        /* If the window has a parent, set the WM_TRANSIENT_FOR hint. */
        if (parent && parent->window->win)
            XSetTransientForHint(stddpy, ws->win, parent->window->win);

        /* Turn off background; this prevents X filling the background on an expose
           and hence prevents unsightly flicker on a resize. */
        if (ws->win)
            XSetWindowBackgroundPixmap(stddpy, ws->win, None);

        stdwin = ws->win;
        XClearWindow(stddpy, stdwin);
    }

    /*
     * before creating the graphics context, construct a description
     * of any non-default initial graphics context values.
     */
    gcv.foreground = wd->colors[wc->fg].c ^ (ISXORREVERSE(w) ? wd->colors[wc->bg].c : 0);
    gcv.background = wd->colors[wc->bg].c;
#ifdef HAVE_LIBXFT
    gcv.font       = wd->xfont->fid;
#else
    gcv.font       = wc->font->fsp->fid;
#endif
    if (wc->fillstyle)
        gcv.fill_style = wc->fillstyle;
    else
        gcv.fill_style = wc->fillstyle = FillSolid;
    if (wc->linestyle || wc->linewidth) {
        gcmask |= (GCLineWidth | GCLineStyle);
        gcv.line_width = wc->linewidth;
        gcv.line_style = wc->linestyle;
        if (wc->linewidth > 1) {
            gcv.dashes = 3 * wc->linewidth;
            gcmask |= GCDashList;
        }
    }
    else
        wc->linestyle = LineSolid;
    gcv.cap_style = CapProjecting;

    /*
     * Create a graphics context (or change an existing one to conform
     * with initial values).
     */
    if (stdgc == NULL) {
        wc->gc = XCreateGC(stddpy, stdpix, gcmask, &gcv);
        stdgc = wc->gc;
        if (stdgc == NULL) return Failed;
    }
    else
        XChangeGC(stddpy, stdgc, gcmask, &gcv);


    if (wc->clipw >= 0)
        setclip(w);

    if (new_pixmap) {
        XSetForeground(stddpy, stdgc, wd->colors[wc->bg].c);
        XFillRectangle(stddpy, ws->pix, stdgc, 0, 0, ws->width, ws->height);
        XSetForeground(stddpy, stdgc,
                       wd->colors[wc->fg].c ^(ISXORREVERSE(w)?wd->colors[wc->bg].c:0));
    }

    imd = &ws->initimage;
    if (imd->width) {
        r = strimage(w, 0, 0, imd->width, imd->height, imd->paltbl,
                     imd->data, (word)imd->width * (word)imd->height, 0);
        free(imd->paltbl);
        free(imd->data);
        imd->width = 0;
        if (r < 0)
            return Failed;
    }

    imd = &ws->initicon;
    if (imd->width) {
        r = strimage(w, 0, 0, imd->width, imd->height, imd->paltbl,
                     imd->data, (word)imd->width * (word)imd->height, 1);
        free(imd->paltbl);
        free(imd->data);
        imd->width = 0;
        if (r < 0)
            return Failed;
        wmhints.icon_window = ws->iconwin;
        ws->wmhintflags |= IconWindowHint;
    }

    if (wc->patternname != NULL) {
        if (SetPattern(w, wc->patternname, strlen(wc->patternname)) != Succeeded)
            return Failed;
    }

    /*
     *  if we are opening a pixmap, we are done at this point.
     */
    if (stdwin == (Window) NULL) return Succeeded;

    if (ws->iconic != RootState) {
        size_hints.flags = PSize | PMinSize | PMaxSize;
        size_hints.width = ws->width;
        size_hints.height= ws->height;
        if (ws->posx == -(INT_MAX)) ws->posx = 0;
        else size_hints.flags |= USPosition;
        if (ws->posy == -(INT_MAX)) ws->posy = 0;
        else size_hints.flags |= USPosition;
        size_hints.x = ws->posx;
        size_hints.y = ws->posy;
        if (ISRESIZABLE(w)) {
            size_hints.min_width = ws->minwidth;
            size_hints.min_height = ws->minheight;
            size_hints.max_width = DisplayWidth(stddpy, wd->screen);
            size_hints.max_height = DisplayHeight(stddpy, wd->screen);
        }
        else {
            size_hints.min_width = size_hints.max_width = ws->width;
            size_hints.min_height = size_hints.max_height = ws->height;
        }
        if (ws->iconlabel == NULL) {
            ws->iconlabel = salloc(ws->windowlabel);
        }
        XSetStandardProperties(stddpy, stdwin, ws->windowlabel, ws->iconlabel,
                               0,0,0, &size_hints);
        XSelectInput(stddpy, stdwin, XMasks(ws->inputmask));
    }

    wmhints.input = True;
    wmhints.flags = InputHint;
    if (ws->iconic != RootState) {
        if (ws->iconimage != NULL) {
            makeIcon(w, ws->posx < 0 ? 0 : ws->posx, ws->posy < 0 ? 0 : ws->posy);
            wmhints.icon_window = ws->iconwin;
            ws->wmhintflags |= IconWindowHint;
        }
        wmhints.flags |= (ws->wmhintflags | StateHint);
        wmhints.initial_state = ws->iconic;
        wmhints.icon_x = ws->iconx;
        wmhints.icon_y = ws->icony;
    }
    XSetWMHints(stddpy, stdwin, &wmhints);

    /*
     * Set the class hints that name the program (for reference by the
     * window manager) following conventions given in O'Reilly.
     */
    cnv:string(kywd_prog, progname);
    if (! (s = getenv("RESOURCE_NAME"))) {
        p = StrLoc(progname);
        s = p + StrLen(progname);
        while (s > p && s[-1] != '/')
            s--;				/* find tail of prog_name */
        clhints.res_name = sbuf;
        clhints.res_class = "IconProg";
        for (i=0; s < p+StrLen(progname); ) clhints.res_name[i++] = *s++;
        clhints.res_name[i] = '\0';
        XSetClassHint(stddpy, stdwin, &clhints);
    }

    if (wd->cmap != DefaultColormap(stddpy,wd->screen)) { /* ? */
        XSetWindowColormap(stddpy, stdwin, wd->cmap);
    }
    XSync(stddpy, False);

    if (ws->iconic != RootState) {
        CLREXPOSED(w);
        XMapWindow(stddpy, stdwin);
    }

    XGetWindowAttributes(stddpy, stdwin, &attrs);
    ws->width = attrs.width;
    ws->height = attrs.height;
    if (!resizePixmap(w, ws->width, ws->height)) return Failed;

    if (stdwin) {
        i = ws->theCursor;
        if (!(wd->cursors[i]))
            wd->cursors[i] = XCreateFontCursor(stddpy, 2 * i);
        XDefineCursor(stddpy, stdwin, wd->cursors[i]);
    }

    /*
     * busy loop for an expose event, unless of course we are starting out
     *  in an iconic state
     */
    CLRZOMBIE(w);

    XSetFunction(stddpy, stdgc, wc->drawop);
    XSync(stddpy, False);

    return Succeeded;
}


int do_config(wbp w, int status)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    int wid = ws->width, ht = ws->height;
    int posx = ws->posx, posy = ws->posy;
    XTextProperty textprop;

    if (! resizePixmap(w, ws->width, ws->height))
        return Failed;
    if (ws->win) {
        XSync(wd->display, False);
        pollevent();
        if (status == 1)
            moveWindow(w, posx, posy);
        else {
            if (status == 2)
                posx = posy = -INT_MAX;
            if (moveResizeWindow(w, posx, posy, wid, ht) == Failed)
                return Failed;
        }

        /* XSync is not enough because the window manager gets involved here. */
        XFlush(wd->display);			      /* force out request */
        XGetWMName(wd->display, ws->win, &textprop);    /* force WM round trip */
        XSync(wd->display, False);		      /* NOW sync */
    }
    return Succeeded;
}

int setheight(wbp w, SHORT new_height)
{
    STDLOCALS(w);
    if (new_height < 0) return Failed;
    ws->height = size_hints.height = new_height;
    return Succeeded;
}

int setwidth(wbp w, SHORT new_width)
{
    STDLOCALS(w);
    if (new_width < 0) return Failed;
    ws->width = size_hints.width = new_width;
    return Succeeded;
}

int setgeometry(wbp w, char *geo)
{
    int width = 0, height = 0;
    int x = 0, y = 0, status;
    STDLOCALS(w);

    if ((status = parsegeometry(geo, &x, &y, &width, &height)) == 0)
        return Error;
    if (status & 1) {
        ws->width = size_hints.width = width;
        ws->height = size_hints.height = height;
    }
    /*
     * can't set position on hidden windows (but can on opening ones)
     */
    if ((stdwin || !stdpix) && (status & 2)) {
        ws->posx = x;
        ws->posy = y;
    }
    /* insert assigns here:
     *  ws->posx = ((sign > 0) ? tmp :
     *              DisplayWidth(stddpy,wd->screen) - ws->width - tmp);
     *  ws->posy = ((sign > 0) ? tmp :
     *              DisplayHeight(stddpy,wd->screen) - ws->height - tmp);
     */
    return Succeeded;
}

int setminheight(wbp w, SHORT new_height)
{
    XSizeHints size_hints;
    long t;
    STDLOCALS(w);
    if (new_height < 0) return Failed;
    ws->minheight = new_height;
    if (ws->win) {
        XGetWMNormalHints(stddpy, ws->win, &size_hints, &t);
        size_hints.min_height = ws->minheight;
        XSetWMNormalHints(stddpy, ws->win, &size_hints);
    }
    return Succeeded;
}

int setminwidth(wbp w, SHORT new_width)
{
    XSizeHints size_hints;
    long t;
    STDLOCALS(w);
    if (new_width < 0) return Failed;
    ws->minwidth = new_width;
    if (ws->win) {
        XGetWMNormalHints(stddpy, ws->win, &size_hints, &t);
        size_hints.min_width = ws->minwidth;
        XSetWMNormalHints(stddpy, ws->win, &size_hints);
    }
    return Succeeded;
}

/*
 * Note that the three strings are pointers into the string space;
 * data is a safe pointer into a frame.
 */
int send_selection_response(wbp w, word requestor, char *property, char *target, char *selection, word time, dptr data)
{
    Atom property_atom, target_atom, selection_atom, XA_TARGETS, target_list[32];
    XEvent theevent;
    struct lgstate state;
    tended struct b_lelem *le;
    tended char *cstr_target;
    int target_cnt = 1;
    STDLOCALS(w);

    if (selection_debug)
        printf("sendselectionresponse:\n\trequestor=%lx "
               "property=%s target=%s selection=%s time=%ld\n",
               (long)requestor, property, target, selection, (long)time);

    property_atom = XInternAtom(ws->display->display, property, False);
    target_atom = XInternAtom(ws->display->display, target, False);
    selection_atom = XInternAtom(ws->display->display, selection, False);
    XA_TARGETS = XInternAtom(ws->display->display, "TARGETS", False);

    if (target_atom == XA_TARGETS) {
        if (!is:list(*data))
            ReturnErrVal(108, *data, Error);
        target_list[0] = XA_TARGETS;
        for (le = lgfirst(&ListBlk(*data), &state); le;
             le = lgnext(&ListBlk(*data), &state, le)) {
            if (!cnv:C_string(le->lslots[state.result], cstr_target))
                ReturnErrVal(148, le->lslots[state.result], Error);
            target_list[target_cnt++] = XInternAtom(ws->display->display, cstr_target, False);
            if (selection_debug)
                printf("\tAdding target:%s\n", cstr_target);
        }
        XChangeProperty(ws->display->display,
                        requestor,
                        property_atom,
                        target_atom,
                        32,
                        PropModeReplace,
                        (unsigned char *)target_list,
                        target_cnt);
        theevent.xselection.property = property_atom;
    } else if (is:null(*data)) {
        /* Can't handle this target type */
        if (selection_debug)
            printf("\tSetting property to None\n");
        theevent.xselection.property = None;
    } else {
        if (!cnv:string(*data, *data))
            ReturnErrVal(103, le->lslots[state.result], Error);
        if (selection_debug)
            printf("\tSetting property to %d bytes of data\n", (int)StrLen(*data));
        XChangeProperty(ws->display->display,
                        requestor,
                        property_atom,
                        target_atom,
                        8,
                        PropModeReplace,
                        (unsigned char *)StrLoc(*data),
                        StrLen(*data));
        theevent.xselection.property = property_atom;
    }

    theevent.type = SelectionNotify;
    theevent.xselection.serial = 0; /*event.xselectionrequest.serial;*/
    theevent.xselection.send_event = True;
    theevent.xselection.requestor = requestor;
    theevent.xselection.selection = selection_atom;
    theevent.xselection.target = target_atom;
    theevent.xselection.time = time;

    XSendEvent(ws->display->display,
               requestor,
               False, NoEventMask, &theevent);

    return Succeeded;
}

int own_selection(wbp w, char *selname)
{
    Atom selection;
    Window curr;
    {
    STDLOCALS(w);

    selection = XInternAtom(ws->display->display, selname, False);

    curr = XGetSelectionOwner(ws->display->display, selection);
    /* Check for no change in selection */
    if (curr == ws->win)
        return Succeeded;

    if (selection_debug)
        printf("Owner of selection %s set from %lx -> %lx\n", 
               atom_fmt(ws, selection),
               (long)curr,
               (long)ws->win);

    /*
     * X doesn't send a SelectionClear event to us when the selection
     * changes between our own windows, so if the current owner is one
     * our windows, send it a "clear" message.
     */
    if (curr) {
        wsp x;
        for (x = wstates; x; x = x->next) {
            if (x->win == curr) {
                tended struct descrip tmp;
                if (selection_debug)
                    printf("Enqueueing artificial SELECTIONCLEAR to current owner %lx\n",(long)curr);
                MakeInt(SELECTIONCLEAR, &tmp);
                list_put(&x->listp, &tmp);
                get_atom_descriptor(x, selection, &tmp);
                list_put(&x->listp, &tmp);
                break;
            }
        }
    }

    XSetSelectionOwner(ws->display->display, 
                       selection,
                       ws->win,
                       CurrentTime);

    return Succeeded;
    }
}

int request_selection(wbp w, char *selname, char *targetname)
{
    Atom selection, property, target;
    STDLOCALS(w);

    selection = XInternAtom(ws->display->display, selname, False);
    property = XInternAtom(ws->display->display, "_UNICON_PROP", False);
    target = XInternAtom(ws->display->display, targetname, False);
    if (selection_debug)
        printf("getselectioncontent: calling XConvertSelection selection=%s target=%s property=%s requestor=%lx\n",
               atom_fmt(ws, selection),
               atom_fmt(ws, target),
               atom_fmt(ws, property),
               (long)ws->win);

    XConvertSelection(ws->display->display,
                      selection, 
                      target, 
                      property, 
                      ws->win,
                      CurrentTime);

    return Succeeded;
}


int allowresize(wbp w, int on)
{
    if (on)
        SETRESIZABLE(w);
    else
        CLRRESIZABLE(w);
    return Succeeded;
}

void warpPointer(wbp w, int x, int y)
{
    wsp ws = w->window;
    XWarpPointer(ws->display->display, None, ws->win, 0,0,0,0, x, y);
}

/*
 * #@#@ This is a bug
 */
int seticonlabel(wbp w, char *val)
{
    STDLOCALS(w);
    if (ws->iconlabel != NULL) free(ws->iconlabel);
    ws->iconlabel = salloc(val);
   
    if (stddpy && stdwin) {
        XSetIconName(stddpy, stdwin, w->window->iconlabel);
        if (ws->iconic == IconicState && !ws->iconpix && ws->iconwin) {
            XClearWindow(stddpy, ws->iconwin);
            XDrawString(stddpy, ws->iconwin, wd->icongc, 4,
                        wd->fonts->ascent + 2,
                        ws->iconlabel, strlen(ws->iconlabel));
        }
    }
    return Succeeded;
}

/*
 * setwindowlabel
 */
int setwindowlabel(wbp w, char *s)
{
    wsp ws = w->window;
    if (ws->windowlabel != NULL) free(ws->windowlabel);
    ws->windowlabel = salloc(s);

    if (ws->display && ws->display->display && ws->win)
        XStoreName(ws->display->display, ws->win,
                   *ws->windowlabel ? ws->windowlabel : " ");    /* empty string fails */
    return Succeeded;
}



/*
 * setpointer() - define a mouse pointer shape
 */
int setpointer(wbp w, char *val)
{
    int i = stringint_str2int(cursorsyms,val) >> 1;
    STDLOCALS(w);
    if (i < 0 || i >= NUMCURSORSYMS) return Failed;

    ws->theCursor = i;
    if (!(wd->cursors[i]))
        wd->cursors[i] = XCreateFontCursor(stddpy, 2 * i);
    if (stdwin)
        XDefineCursor(stddpy, stdwin, wd->cursors[i]);
    return Succeeded;
}

/*
 * setdrawop() - set the drawing operation
 */
int setdrawop(wbp w, char *val)
{
    STDLOCALS(w);
    XSync(stddpy, False);
    if (!strcmp(val,"reverse")) {
        if (!ISXORREVERSE(w)) {
            SETXORREVERSE(w);
            wc->drawop = GXxor;
            if (stdgc)
                XSetForeground(stddpy, stdgc,
                               wd->colors[wc->fg].c ^ wd->colors[wc->bg].c);
        }
    }
    else {
        if (ISXORREVERSE(w)) {
            CLRXORREVERSE(w);
            if (stdgc)
                XSetForeground(stddpy, stdgc, wd->colors[wc->fg].c);
        }
        wc->drawop = stringint_str2int(drawops,val);
        if (wc->drawop == -1) { wc->drawop = GXcopy; return Error; }
    }
    if (stdgc) XSetFunction(stddpy, stdgc, wc->drawop);
    return Succeeded;
}

/*
 * rebind() - bind w's context to that of w2.
 */
int rebind(wbp w, wbp w2)
{
    if (w->window->display != w2->context->display) return Failed;
    w->context = w2->context;
    return Succeeded;
}


void setclip(wbp w)
{
    wcp wc = w->context;
    XRectangle rec;
    if (wc->gc) {
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XSetClipRectangles(wc->display->display, wc->gc, 0, 0, &rec, 1,Unsorted);
    }
}

void unsetclip(wbp w)
{
    wcp wc = w->context;
    if (wc->gc) {
        XSetClipMask(wc->display->display, wc->gc, None);
    }
}

void getcanvas(wbp w, char *s)
{
    if (w->window->win == (Window) NULL) sprintf(s, "hidden");
    else
        switch (w->window->iconic) {
            case RootState:
                sprintf(s, "root");
                break;
            case NormalState:
                sprintf(s, "normal");
                break;
            case IconicState:
                sprintf(s, "iconic");
                break;
            case MaximizedState:
                sprintf(s, "maximal");
                break;
            case HiddenState:
                sprintf(s, "hidden");
                break;
            default:
                sprintf(s, "???");
        }
}


int setinputmask(wbp w, char *val)
{
    wsp ws = w->window;
    if (strchr(val,'k')) {
        ws->inputmask |= KeyReleaseMask;
    }
    else {
        ws->inputmask &= ~KeyReleaseMask;
    }
    if (strchr(val,'m')) {
        ws->inputmask |= PointerMotionMask;
    }
    else {
        ws->inputmask &= ~PointerMotionMask;
    }

    if (ws->win)
        XSelectInput(ws->display->display, ws->win, XMasks(ws->inputmask));
    return Succeeded;
}

/*
 *  Set the canvas type, either during open (pixmap is null, set a flag)
 *   or change an existing canvas to a different type.
 */
int setcanvas(wbp w, char *s)
{
    XTextProperty textprop;
    STDLOCALS(w);

    if (!strcmp(s, "iconic")) {
        if (ws->pix == (Pixmap) NULL) {
            ws->wmhintflags |= StateHint;
            ws->iconic = IconicState;
        }
        else {
            if (ws->iconic != IconicState) {
                if (ws->win == (Window) NULL) {
                    wmap(w, 0);
                }
                XIconifyWindow(ws->display->display, ws->win, ws->display->screen);
                XSync(stddpy, False);
                while (ws->iconic != IconicState)
                    if (handle_misc(wd, NULL) < 1) {
                        return Failed;
                    }
	    }
        }
    }

    else if (!strcmp(s, "normal")) {
        if (ws->pix == (Pixmap) NULL) {
            ws->iconic = NormalState;
        }
        else {
            if (ws->win == (Window) NULL) {
                ws->iconic = NormalState;
                ws->initialPix = ws->pix;
                ws->pix = (Window) NULL;
                wmap(w, 0);
	    }
            else if (ws->iconic == IconicState) {
                XMapWindow(stddpy, stdwin);
                XSync(stddpy, False);
                while (ws->iconic == IconicState)
                    pollevent();
	    }
            else if (ws->iconic == MaximizedState) {
                moveResizeWindow(w, ws->normalx, ws->normaly,
                                 ws->normalw, ws->normalh);
                ws->iconic = NormalState;
	    }
        }
    }
    else if (!strcmp(s, "maximal")) {
        if (ws->iconic != MaximizedState) {
            int expect_config= (ws->width != DisplayWidth(stddpy, wd->screen)) ||
                (ws->height != DisplayHeight(stddpy, wd->screen));
            ws->normalx = ws->posx;
            ws->normaly = ws->posy;
            ws->normalw = ws->width;
            ws->normalh = ws->height;
            ws->width = DisplayWidth(stddpy, wd->screen);
            ws->height= DisplayHeight(stddpy, wd->screen);
            if (ws->pix != (Pixmap) NULL) {
                if (ws->win == (Window) NULL) {
                    ws->iconic = MaximizedState;
                    ws->initialPix = ws->pix;
                    ws->pix = (Window) NULL;
                    wmap(w, 0);
                }
                else if (ws->iconic == IconicState) {
                    XMapWindow(stddpy, stdwin);
                    XSync(stddpy, False);
                    while (ws->iconic == IconicState)
                        pollevent();
                }
                else if (expect_config) {
                    moveResizeWindow(w, 0, 0, ws->width, ws->height);
                    /* XSync is not enough because the window manager gets involved here. */
                    XFlush(wd->display);			      /* force out request */
                    XGetWMName(wd->display, ws->win, &textprop);    /* force WM round trip */
                    XSync(wd->display, False);		      /* NOW sync */
                    pollevent();
                    moveWindow(w, -ws->posx, -ws->posy);
                    XFlush(wd->display);			      /* force out request */
                    XGetWMName(wd->display, ws->win, &textprop);    /* force WM round trip */
                    XSync(wd->display, False);		      /* NOW sync */
                }
	    }
            ws->iconic = MaximizedState;
        }
    }
    else if (!strcmp(s, "hidden")) {
        if (ws->pix == (Pixmap)NULL) {
            ws->iconic = HiddenState;
        }
        else {
            if (ws->win != (Window) NULL) {
                if (ws->iconic == MaximizedState) {
                    ws->posx = ws->normalx;
                    ws->posy = ws->normaly;
                    ws->width = ws->normalw;
                    ws->height = ws->normalh;
                    ws->iconic = NormalState;
                }
                if (ws->iconic != IconicState) {
                    SETZOMBIE(w);
#ifdef HAVE_LIBXFT
                    if (ws->winDraw) {
                        XftDrawDestroy(ws->winDraw);
                        ws->winDraw = NULL;
                    }
#endif
                    XDestroyWindow(stddpy, stdwin);
                    XFlush(stddpy);
                    while (ws->win)
                        pollevent();
                }
	    }
        }
    }
    else return Error;
    XSync(ws->display->display, False);
    return Succeeded;
}

int seticonicstate(wbp w, char *s)
{
    STDLOCALS(w);

    if (!strcmp(s, "icon")) {
        if (ws->pix == (Pixmap) NULL) {
            ws->wmhintflags |= StateHint;
            ws->iconic = IconicState;
        }
        else {
            if (ws->iconic != IconicState) {
                XIconifyWindow(ws->display->display, ws->win, ws->display->screen);
	    }
        }
    }
    else if (!strcmp(s, "window")) {
        if (ws->win != (Window) NULL) {
            if (ws->iconic == IconicState) {
                XMapWindow(stddpy, stdwin);
	    }
        }
    }
    else if (!strcmp(s, "root")) {
        if (ws->win == (Window) NULL)
            ws->iconic = RootState;
        else return Failed;
    }
    else return Error;
    XSync(ws->display->display, False);
    return Succeeded;
}

int seticonpos(wbp w, char *s)
{
    char *s2;
    wsp ws = w->window;

    ws->wmhintflags |= IconPositionHint;
    s2 = s;
    ws->iconx = atol(s2);
    while (isspace((unsigned char)*s2)) s2++;
    while (isdigit((unsigned char)*s2)) s2++;
    if (*s2++ != ',') return Error;
    ws->icony = atol(s2);

    if (ws->win) {
        if (ws->iconwin == (Window) NULL)
            makeIcon(w, ws->iconx, ws->icony);
        if (remap(w, ws->iconx, ws->icony) == -1) return Error;
    }
    return Succeeded;
}

int geticonpos(wbp w, char *s)
{
    wsp ws = w->window;
    sprintf(s,"%d,%d", ws->iconx, ws->icony);
    return Succeeded;
}


/*
 * if the window exists and is visible, set its position to (x,y)
 */
static void moveWindow(wbp w, int x, int y)
{
    STDLOCALS(w);
    ws->posx = x;
    ws->posy = y;
    if (stdwin) {
        XMoveWindow(stddpy, stdwin, ws->posx, ws->posy);
        XSync(stddpy, False);
    }
}

static int moveResizeWindow(wbp w, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    ws->width = width;
    ws->height = height;

    size_hints.flags = PMinSize | PMaxSize;
    if (ISRESIZABLE(w)) {
        size_hints.min_width = ws->minwidth;
        size_hints.min_height = ws->minheight;
        size_hints.max_width = DisplayWidth(wd->display, wd->screen);
        size_hints.max_height = DisplayHeight(wd->display, wd->screen);
    }
    else {
        size_hints.min_width = size_hints.max_width = width;
        size_hints.min_height = size_hints.max_height = height;
    }
    XSetNormalHints(wd->display, ws->win, &size_hints);

    if (resizePixmap(w, width, height) == 0) return Failed;

    if (ws->win != (Window) NULL) {
        if (x == -INT_MAX && y == -INT_MAX)
            XResizeWindow(wd->display, ws->win, width, height);
        else
            XMoveResizeWindow(wd->display, ws->win, x, y, width, height);
        XSync(wd->display, False);
    }
    return Succeeded;
}

/*
 * Set the context's fill style by name.
 */
int setfillstyle(wbp w, char *s)
{
    STDLOCALS(w);

    if (!strcmp(s, "solid")) {
        wc->fillstyle = FillSolid;
    }
    else if (!strcmp(s, "masked")
             || !strcmp(s, "stippled") || !strcmp(s, "patterned")) {
        wc->fillstyle = FillStippled;
    }
    else if (!strcmp(s, "textured")
             || !strcmp(s, "opaquestippled") || !strcmp(s, "opaquepatterned")) {
        wc->fillstyle = FillOpaqueStippled;
    }
    else return Error;
    if (stdpix) {
        XSetFillStyle(stddpy, stdgc, wc->fillstyle);
    }
    return Succeeded;
}

/*
 * Set the context's line style by name.
 */
int setlinestyle(wbp w, char *s)
{
    STDLOCALS(w);

    if (!strcmp(s, "solid")) {
        wc->linestyle = LineSolid;
    }
    else if (!strcmp(s, "onoff") || !strcmp(s, "dashed")) {
        wc->linestyle = LineOnOffDash;
    }
    else if (!strcmp(s, "doubledash") || !strcmp(s, "striped")) {
        wc->linestyle = LineDoubleDash;
    }
    else return Error;
    if (stdpix) {
        XSetLineAttributes(stddpy, stdgc,
                           wc->linewidth, wc->linestyle, CapProjecting, JoinMiter);
    }
    return Succeeded;
}

/*
 * Set the context's line width
 */
int setlinewidth(wbp w, LONG linewid)
{
    unsigned long gcmask;
    XGCValues gcv;
    STDLOCALS(w);

    if (linewid < 0) return Error;
    wc->linewidth = linewid;
    if (stdpix) {
        gcv.line_width = linewid;
        gcv.line_style = wc->linestyle;
        if (linewid > 1)
            gcv.dashes = 3 * wc->linewidth;
        else
            gcv.dashes = 4;
        gcmask = GCLineWidth | GCLineStyle | GCDashList;
        XChangeGC(stddpy, stdgc, gcmask, &gcv);
    }
    return Succeeded;
}

/*
 * Reset the context's foreground color to whatever it is supposed to be.
 */
int resetfg(wbp w)
{
    wcp wc = w->context;
    wdp wd = wc->display;
    if (wc->gc != NULL)
        XSetForeground(wc->display->display, wc->gc,
                       wd->colors[wc->fg].c ^ (ISXORREVERSE(w) ? wd->colors[wc->bg].c : 0));
    return Succeeded;
}

/*
 * Set the context's foreground color by name.
 */
int setfg(wbp w, char *s)
{
    wclrp cp;
    wcp wc = w->context;
    wdp wd = w->window->display;
    Protect(cp = alc_color(w,s), return Failed);
    wc->fg = (cp - wd->colors);
    return resetfg(w);
}

int setfgrgb(wbp w, int r, int g, int b)
{
    char sbuf1[32];
    sprintf(sbuf1, "%d,%d,%d", r, g, b);
    return setfg(w, sbuf1);
}

/*
 * Set the context's foreground color by color cell.
 */
int isetfg(wbp w, int fg)
{
    int i, r, g, b;
    STDLOCALS(w);

    if (fg >= 0) {
        b = fg & 255;
        fg >>= 8;
        g = fg & 255;
        fg >>= 8;
        r = fg & 255;
        return setfgrgb(w, r * 257, g * 257, b * 257);
    }
    for (i = 2; i < DMAXCOLORS; i++)
        if (wd->colors[i].type == MUTABLE && wd->colors[i].c == -fg - 1)
            break;
    if (i == DMAXCOLORS) return Failed;
    wc->fg = i;
    return resetfg(w);
}

/*
 * Set the window context's background color by name.
 */
int setbg(wbp w, char *s)
{
    wclrp cp;
    wcp wc = w->context;
    wdp wd = w->window->display;
    GC stdgc = wc->gc;
    Display *stddpy = wd->display;
    Protect(cp = alc_color(w,s), return Failed);
    wc->bg = (cp - wd->colors);
    if (stdgc != NULL)
        XSetBackground(stddpy, stdgc, cp->c);
    return ISXORREVERSE(w) ? resetfg(w) : Succeeded;
}

int setbgrgb(wbp w, int r, int g, int b)
{
    char sbuf1[32];
    sprintf(sbuf1, "%d,%d,%d", r, g, b);
    return setbg(w, sbuf1);
}

/*
 * Set the context's background color by color cell.
 */
int isetbg(wbp w, int bg)
{
    int i, r, g, b;
    STDLOCALS(w);

    if (bg >= 0) {
        b = bg & 255;
        bg >>= 8;
        g = bg & 255;
        bg >>= 8;
        r = bg & 255;
        return setbgrgb(w, r * 257, g * 257, b * 257);
    }
    for (i = 2; i < DMAXCOLORS; i++)
        if (wd->colors[i].type == MUTABLE && wd->colors[i].c == -bg - 1)
            break;
    if (i == DMAXCOLORS) return Failed;
    wc->bg = i;
    if (stdgc != NULL)
        XSetBackground(stddpy, stdgc, wd->colors[wc->bg].c);
    return ISXORREVERSE(w) ? resetfg(w) : Succeeded;
}

/*
 * Set the gamma correction value.
 */
int setgamma(wbp w, double gamma)
{
    wcp wc = w->context;
    wdp wd = w->window->display;
    wc->gamma = gamma;
    setfg(w, wd->colors[wc->fg].name);	/* reinterpret current Fg/Bg spec */
    setbg(w, wd->colors[wc->bg].name);
    return Succeeded;
}

/*
 * Set the display by name.  Really should cache answers as per fonts below;
 * for now just open a new display each time.  Note that this can only be
 * called before a window is instantiated...
 */
int setdisplay(wbp w, char *s)
{
    wdp d;
    /* can't change display for mapped window! */
    if (w->window->pix != (Pixmap) NULL)
        return Failed;

    Protect(d = alc_display(s), return 0);
    w->window->display = d;
    w->context->fg = 0;
    w->context->bg = 1;
    w->context->font = d->fonts;
    return Succeeded;
}

int setleading(wbp w, int i)
{
    w->context->leading = i;
    return Succeeded;
}

int setimage(wbp w, char *val)
{
    wsp ws = w->window;
    int status;
    ws->initialPix = loadimage(w, val, &(ws->height), &(ws->width),
                               0, &status);
    if (ws->initialPix == (Pixmap) NULL) return Failed;
    return Succeeded;
}

void toggle_fgbg(wbp w)
{
    int tmp;
    STDLOCALS(w);
    tmp = wc->fg;
    wc->fg = wc->bg;
    wc->bg = tmp;
    if (stdpix) {
        XSetForeground(stddpy, stdgc,
                       wd->colors[wc->fg].c ^ (ISXORREVERSE(w)?wd->colors[wc->bg].c:0));
        XSetBackground(stddpy, stdgc, wd->colors[wc->bg].c);
    }
}

void getdisplay(wbp w, char *answer)
{
    char *tmp;
    wdp wd = w->window->display;
    if (!strcmp(wd->name, "")) {
        if ((tmp = getenv("DISPLAY")) != NULL)
            sprintf(answer, "%s", tmp);
        else
            *answer = '\0';
    }
    else sprintf(answer, "%s", wd->name);
}

int getvisual(wbp w, char *answer)
{
    wdp wd = w->window->display;
    Visual * v = DefaultVisual(wd->display,wd->screen);
    sprintf(answer, "%d,%d,%d", v->class, v->bits_per_rgb, v->map_entries );
    return Succeeded;
}
/*
 * getpos() - update the window state's notion of its current position
 */
int getpos(wbp w)
{
    Window garbage1, garbage2;
    int root_x, root_y, win_x, win_y;
    unsigned int key_buttons;
    STDLOCALS(w);
    if (!stdwin) return Failed;
    /*
     * This call is made because it is guaranteed to generate
     * a synchronous request of the server, not just ask Xlib
     * what the window position was last it knew.
     */
    if (XQueryPointer(stddpy, stdwin, &garbage1, &garbage2,
                      &root_x, &root_y, &win_x, &win_y, &key_buttons) ==
        False) {
        return Failed;
    }
    ws->posx = root_x - win_x;
    ws->posy = root_y - win_y;
    return Succeeded;
}

void getfg(wbp w, char *answer)
{
    sprintf(answer, "%s", w->window->display->colors[w->context->fg].name);
}

void getbg(wbp w, char *answer)
{
    sprintf(answer, "%s", w->window->display->colors[w->context->bg].name);
}

void getlinestyle(wbp w, char *answer)
{
    wcp wc = w->context;
    sprintf(answer,"%s",
            (wc->linestyle==LineSolid)?"solid":
            ((wc->linestyle==LineOnOffDash)?"dashed":"striped"));
}

void getfntnam(wbp w, char *answer)
{
    sprintf(answer,"%s", w->context->font->name);
}

void getpointername(wbp w, char *answer)
{
    strcpy(answer, stringint_int2str(cursorsyms, 2 * w->window->theCursor));
}

void getdrawop(wbp w, char *answer)
{
    char *s;
    if (ISXORREVERSE(w)) s = "reverse";
    else s = stringint_int2str(drawops, w->context->drawop);
    if (s) sprintf(answer, "%s", s);
    else strcpy(answer, "copy");
}

void geticonic(wbp w, char *answer)
{
    switch (w->window->iconic) {
        case RootState:
            sprintf(answer, "root");
            break;
        case NormalState:
            sprintf(answer, "window");
            break;
        case IconicState:
            sprintf(answer, "icon");
            break;
        default:
            sprintf(answer, "???");
    }
}

/*
 * Set the window's font by name.
 */
int setfont(wbp w, char **s)
{
    wfp tmp;
    STDLOCALS(w);

    /* could free up previously allocated font here */

    Protect(tmp = alc_font(w,s), return Failed);
    wc->font = tmp;

#ifndef HAVE_LIBXFT
    if (stdgc != NULL)
        XSetFont(stddpy, stdgc, wc->font->fsp->fid);
#endif

    return Succeeded;
}

/*
 * callback procedures
 */

static int handle_exposures(wbp w, XExposeEvent *event)
{
    int returnval;
    STDLOCALS(w);
    returnval = ISEXPOSED(w);
    SETEXPOSED(w);
    if (stdwin && !ISZOMBIE(w)) {
/* if its a 3D window, do we skip this part ?? */
        if (wc->drawop != GXcopy)
            XSetFunction(stddpy, stdgc, GXcopy);
        if (wc->clipw >= 0)
            unsetclip(w);
        XCopyArea(stddpy, stdpix, stdwin, stdgc, event->x,event->y,
                  event->width,event->height, event->x,event->y);
        if (wc->clipw >= 0)
            setclip(w);
        if (wc->drawop != GXcopy)
            XSetFunction(stddpy,stdgc,wc->drawop);
/* end of " if its a 3D window " */


    }
    return returnval;
}
#ifndef min
#define min(x,y) (((x)<(y))?(x):(y))
#define max(x,y) (((x)>(y))?(x):(y))
#endif

/*
 * resizePixmap(w,width,height) -- ensure w's backing pixmap is at least
 * width x height pixels.
 *
 * Resizes the backing pixmap, if needed.  Called when X resize events
 * arrive, as well as when programs make explicit resize requests.
 *
 * Returns 0 on failure.
 */
int resizePixmap(wbp w, int width, int height)
{
    Pixmap p;
    STDLOCALS(w);
    if (ws->pix == (Pixmap) NULL) return 1;
    if ((width > ws->pixwidth) || (height > ws->pixheight)) {
        int x = ws->pixwidth, y = ws->pixheight;

        ws->pixheight = max(ws->pixheight, height);
        ws->pixwidth  = max(ws->pixwidth, width);
        p = XCreatePixmap(stddpy, DefaultRootWindow(stddpy), ws->pixwidth,
                          ws->pixheight, DefaultDepth(stddpy,wd->screen));
        if (p == (Pixmap) NULL)
            return 0;

        /*
         * This staggering amount of redudancy manages to make sure the new
         * pixmap gets initialized including areas not in the old pixmap.
         * The window is redrawn.
         */
        XSetForeground(stddpy, stdgc, wd->colors[wc->bg].c);
        if (wc->drawop != GXcopy)
            XSetFunction(stddpy, stdgc, GXcopy);
        if (wc->fillstyle != FillSolid)
            XSetFillStyle(stddpy, stdgc, FillSolid);
        if (wc->clipw >= 0)
            unsetclip(w);
	   
        if (width > x) {
            XFillRectangle(stddpy, p, stdgc, x, 0, width-x, ws->pixheight);
            if (stdwin != (Window) NULL)
                XFillRectangle(stddpy,stdwin,stdgc, x, 0, width-x, ws->pixheight);
        }
        if (height > y) {
            XFillRectangle(stddpy, p, stdgc, 0, y, x, height - y);
            if (stdwin != (Window) NULL)
                XFillRectangle(stddpy, stdwin, stdgc, 0, y, x, height - y);
        }
        XSetForeground(stddpy, stdgc,
                       wd->colors[wc->fg].c ^ (ISXORREVERSE(w)?wd->colors[wc->bg].c:0));
        XCopyArea(stddpy, stdpix, p, stdgc, 0, 0, x, y, 0, 0);
        if (wc->drawop != GXcopy)
            XSetFunction(stddpy,stdgc,wc->drawop);
        if (wc->fillstyle != FillSolid)
            XSetFillStyle(stddpy, stdgc, wc->fillstyle);
        if (wc->clipw >= 0)
            setclip(w);

        XFreePixmap(stddpy, stdpix);	/* free old pixmap */
        ws->pix = p;
#ifdef HAVE_LIBXFT
        if (ws->pixDraw) {
            XftDrawDestroy(ws->pixDraw);
            ws->pixDraw = NULL;
        }
#endif
    }
    return 1;
}

/*
 * Resize operations are made as painless as possible, but the
 * user program is informed anyhow.  The integer coordinates are
 * the new size of the window, in pixels.
 */
static int handle_config(wbp w, XConfigureEvent *event)
{
    struct descrip d;
    STDLOCALS(w);

    /*
     * Update X-Icon's information about the window's configuration
     */

    ws->posx = event->x;
    ws->posy = event->y;

    /*
     * If this was not a resize, drop it
     */
    if ((event->width == ws->width) && (event->height == ws->height))
        return 1;

    ws->width = event->width;
    ws->height = event->height;

    if (! resizePixmap(w, event->width, event->height)) return 0;


    /*
     * The initial configure event generates no Icon-level "events"
     */
    if (!ISEXPOSED(w))
        return 1;

    MakeInt(RESIZED, &d);
    qevent(w->window, &d, ws->width, ws->height, ~(uword)0, 0, 0);
    return 1;
}

/*
 * Queue up characters for keypress events.
 */
static void handle_keypress(wbp w, XKeyEvent *event)
{
    int i,j;
    char s[10];
    tended struct descrip d;
    KeySym k;

    w->window->pointerx = event->x;
    w->window->pointery = event->y;

    /* First try to convert the event to a simple char string, and a KeySym */
    i = XLookupString(event, s, sizeof(s), &k, NULL);
    if (i > 0) {
        /* Found a char string, so generate string event(s) */
        StrLen(d) = 1;
        for (j = 0; j < i; j++) {
            StrLoc(d) = &allchars[s[j] & 0xFF];
            qevent(w->window, &d, event->x, event->y,
                   (uword)event->time, event->state,
                   (event->type == KeyRelease) );
        }
        return;
    }

    /* Second try is to convert to a unicode char; if found generate a 1-char
     * ucs/string */
    i = convert_KeySym_to_code_point(k);
    if (i > 0) {
        if (i < 256) {
            StrLen(d) = 1;
            StrLoc(d) = &allchars[i];
        } else {
            d.dword = D_Ucs;
            BlkLoc(d) = (union block *)make_one_char_ucs_block(i);
        }
        qevent(w->window, &d, event->x, event->y,
               (uword)event->time, event->state,
               (event->type == KeyRelease) );
        return;
    }

    /* Neither of those worked, so it must be a non-character key (cursor key, etc).
     * So just generate the numerical value of the KeySym as an integer.
     */
    MakeInt(k, &d);
    qevent(w->window, &d, event->x, event->y,
           (uword)event->time, event->state,
           (event->type == KeyRelease) );
}

#include "rxkeysyms.ri"

#define swap(a,b) { tmp = a; a = b; b = tmp; }
/*
 * Handle button presses and drag events.  In the case of drags, we should
 * really be looking at an XMotionEvent instead of an XButtonEvent, but
 * the structures are identical up to the button field (which we do not
 * examine for drag events).  Mouse coordinates are queued up after the event.
 */
static void handle_mouse(wbp w, XButtonEvent *event)
{
    static unsigned int buttonorder[3] =
        { Button1Mask, Button2Mask, Button3Mask };
    unsigned int tmp;
    int eventcode = 0;
    struct descrip d;

    if (event->type == MotionNotify) {
        if (event->state & buttonorder[0]) {
            if (buttonorder[0] == Button1Mask)
                eventcode = MOUSELEFTDRAG;
            else if (buttonorder[0] == Button2Mask)
                eventcode = MOUSEMIDDRAG;
            else
                eventcode = MOUSERIGHTDRAG;
        }
        else if (event->state & buttonorder[1]) {
            if (buttonorder[1] == Button1Mask)
                eventcode = MOUSELEFTDRAG;
            else if (buttonorder[1] == Button2Mask)
                eventcode = MOUSEMIDDRAG;
            else
                eventcode = MOUSERIGHTDRAG;
        }
        else if (event->state & buttonorder[2]) {
            if (buttonorder[2] == Button1Mask)
                eventcode = MOUSELEFTDRAG;
            else if (buttonorder[2] == Button2Mask)
                eventcode = MOUSEMIDDRAG;
            else
                eventcode = MOUSERIGHTDRAG;
        }
        else {
            eventcode = MOUSEMOVED;
        }
    }
    else switch (event->button) {
        case Button1: {
            eventcode = MOUSELEFT;
            if (buttonorder[2] == Button1Mask)
                swap(buttonorder[1],buttonorder[2]);
            if (buttonorder[1] == Button1Mask)
                swap(buttonorder[0],buttonorder[1]);
            break;
        }
        case Button2: {
            eventcode = MOUSEMID;
            if (buttonorder[2] == Button2Mask)
                swap(buttonorder[1],buttonorder[2]);
            if (buttonorder[1] == Button2Mask)
                swap(buttonorder[0],buttonorder[1]);
            break;
        }
        case Button3: {
            eventcode = MOUSERIGHT;
            if (buttonorder[2] == Button3Mask)
                swap(buttonorder[1],buttonorder[2]);
            if (buttonorder[1] == Button3Mask)
                swap(buttonorder[0],buttonorder[1]);
            break;
        }
        case Button4: {
            eventcode = MOUSE4;
            break;
        }
        case Button5: {
            eventcode = MOUSE5;
            break;
        }
    }
    if (event->type == ButtonRelease) {
        eventcode -= (MOUSELEFT - MOUSELEFTUP);
        swap(buttonorder[0],buttonorder[1]);
        swap(buttonorder[1],buttonorder[2]);
    }

    /*
     * Don't generate events for these codes.  Rather, MOUSE4UP and
     * MOUSE5UP are used to generate the &wheelup and &wheeldown
     * events respectively.
     */
    if (eventcode == MOUSE4 || eventcode == MOUSE5)
        return;

    w->window->pointerx = event->x;
    w->window->pointery = event->y;

    MakeInt(eventcode,&d);

    qevent(w->window, &d, event->x, event->y, (uword)event->time, event->state, 0);
}


/*
 * fill a series of rectangles
 */
void fillrectangles(wbp w, XRectangle *recs, int nrecs)
{
    STDLOCALS(w);

    /*
     * Free colors if drawop=copy, fillstyle~=masked, no clipping,
     * and a single rectangle that fills the whole window.
     */
    if (!RECX(*recs) && !RECY(*recs) && RECWIDTH(*recs) >= ws->width &&
        RECHEIGHT(*recs) >= ws->height && nrecs == 1 &&
        wc->drawop == GXcopy && wc->fillstyle != FillStippled && wc->clipw < 0) {
        RECWIDTH(*recs) = ws->pixwidth;	/* fill hidden part */
        RECHEIGHT(*recs) = ws->pixheight;
        free_xcolors(w, 0);			/* free old colors */
    }
    RENDER2(XFillRectangles, recs, nrecs);
}

/*
 * erase an area
 */
void eraseArea(wbp w, int x, int y, int width, int height)
{
    STDLOCALS(w);

    /*
     * if width >= window width or height >= window height, clear any
     * offscreen portion as well in order to allow the freeing of colors.
     */
    if (x + width  >= ws->width)  width  = ws->pixwidth - x;
    if (y + height >= ws->height) height = ws->pixheight - y;

    /*
     * fill the rectangle with the background color
     */
    XSetForeground(stddpy, stdgc, wd->colors[wc->bg].c);
    if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, GXcopy);
    if (wc->fillstyle != FillSolid) XSetFillStyle(stddpy, stdgc, FillSolid);
    RENDER4(XFillRectangle, x, y, width, height);
    XSetForeground(stddpy, stdgc,
                   wd->colors[wc->fg].c ^ (ISXORREVERSE(w)?wd->colors[wc->bg].c:0));
    if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, wc->drawop);
    if (wc->fillstyle != FillSolid) XSetFillStyle(stddpy, stdgc, wc->fillstyle);

    /*
     * if the entire window is cleared, free up colors
     */
    if (!x && !y && width >= ws->pixwidth && height >= ws->pixheight &&
        wc->clipw < 0) {
        free_xcolors(w, 0);
    }
}

/*
 * copy an area
 */
int copyArea(wbp w, wbp w2, int x, int y, int width, int height, int x2, int y2)
{
    int lpad, rpad, tpad, bpad;
    Pixmap src;
    wsp ws1 = w->window, ws2 = w2->window;
    wclrp cp, cp2 = NULL;
    STDLOCALS(w2);

    if (w->window->display->display != w2->window->display->display) {
        wdp wd1 = ws1->display;
        unsigned long c = 0;
        int i, j;
        Display *d1 = wd1->display;
        XColor clr;
        XImage *xim;

        /*
         * Copying is between windows on two different displays.
         */
        if (x<0 || y<0 || x+width > ws1->pixwidth || y+height > ws1->pixheight)
            return Failed;		/*#%#%# BOGUS, NEEDS FIXING */
        xim = XGetImage(d1, ws1->pix, x, y, width, height,
                        (1<<DefaultDepth(d1,wd1->screen))-1,XYPixmap);
        XSetFunction(stddpy, stdgc, GXcopy);
        for (i=0; i < width; i++) {
            for (j=0; j < height; j++) {
                clr.pixel = XGetPixel(xim, i, j);
                if (cp2 != NULL && c == clr.pixel) {
                    XSetForeground(stddpy, stdgc, cp2->c);
                    RENDER2(XDrawPoint, i + x2, j + y2);
                    continue;
                }
                c = clr.pixel;
                cp2 = NULL;
                for ( cp = wd1->colors; cp < wd->colors + wd->numColors; cp++) {
                    if (cp->c == c) {
                        if (cp->name[0]=='\0') {
                            XQueryColor(d1, wd1->cmap, &clr);
                            cp->r = clr.red;
                            cp->g = clr.green;
                            cp->b = clr.blue;
                            sprintf(cp->name,"%d,%d,%d",cp->r,cp->g,cp->b);
                        }
                        cp2 = alc_rgb(w2, cp->name, cp->r, cp->g, cp->b, 0);
                        if (cp2 == NULL) return Failed;
                        break;
                    }
                }
                if (cp2 == NULL) {
                    XQueryColor(d1, wd1->cmap, &clr);
                    cp2 = alc_rgb(w2, "unknown", clr.red, clr.green, clr.blue, 0);
                }
                if (cp2 == NULL) return Failed;
                XSetForeground(stddpy, stdgc, cp2->c);
                RENDER2(XDrawPoint, i + x2, j + y2);
	    }
        }
        XSetForeground(stddpy, stdgc,
                       wd->colors[wc->fg].c ^ (ISXORREVERSE(w2) ? wd->colors[wc->bg].c : 0));
        XSetFunction(stddpy, stdgc, wc->drawop);
        XSync(stddpy,False);
        XDestroyImage(xim);
    }
    else {
        /*
         * Copying is between windows on one display, perhaps the same window.
         */
        src = ws1->pix;
        if (src != stdpix) {
            /* copying between different windows; handle color bookkeeping */
            if (!x2 && !y2 &&
                ((width  >= ws2->pixwidth)  || !width) &&
                ((height >= ws2->pixheight) || !height) && w2->context->clipw < 0){
                free_xcolors(w2, 0);
            }
            copy_colors(w, w2);
        }
        XSetForeground(stddpy, stdgc, wd->colors[wc->bg].c);
        XSetFunction(stddpy, stdgc, GXcopy);

        if (x+width<0 || y+height<0 || x>=ws1->pixwidth || y>=ws1->pixheight) {
            /* source is entirely offscreen */
            RENDER4(XFillRectangle, x2, y2, width, height);
        }
        else {
            /*
             * Check for source partially offscreen, but copy first and
             * fill later in case the source and destination overlap.
             */
            lpad = rpad = tpad = bpad = 0;
            if (x < 0) {			/* source extends past left edge */
                lpad = -x;
                width -= lpad;
                x2 += lpad;
                x = 0;
            }
            if (x + width > ws1->pixwidth) {  /* source extends past right edge */
                rpad = x + width - ws1->pixwidth;
                width -= rpad;
            }
            if (y < 0) {			/* source extends above top edge */
                tpad = -y;
                height -= tpad;
                y2 += tpad;
                y = 0;
            }
            if (y + height > ws1->pixheight) {  /* source extends below bottom */
                bpad = y + height - ws1->pixheight;
                height -= bpad;
            }
            /*
             * Copy the area.
             */
            if (stdwin)
                XCopyArea(stddpy, src, stdwin, stdgc, x, y, width, height, x2, y2);
            XCopyArea(stddpy, src, stdpix, stdgc, x, y, width, height, x2, y2);
            /*
             * Fill any edges not provided by source.
             */
            if (lpad > 0)
                RENDER4(XFillRectangle, x2-lpad, y2-tpad, lpad, tpad+height+bpad);
            if (rpad > 0)
                RENDER4(XFillRectangle, x2+width, y2-tpad, rpad, tpad+height+bpad);
            if (tpad > 0)
                RENDER4(XFillRectangle, x2, y2-tpad, width, tpad);
            if (bpad > 0)
                RENDER4(XFillRectangle, x2, y2+height, width, bpad);
        }

        XSetForeground(stddpy,stdgc,
                       wd->colors[wc->fg].c^(ISXORREVERSE(w2) ? wd->colors[wc->bg].c :0));
        XSetFunction(stddpy, stdgc, wc->drawop);
    }
    return Succeeded;
}


wbp sprite;
int tics;
int lastx,lasty;
int animwidth, animheight;

void animHelper(wbp w, XPoint p[], int n)
{
    int i=0;
    STDLOCALS(w);

    for ( ; i < n; i++) {
        int j;

        /*
         * redraw that portion of the previous image that isn't overlapped
         * by the new image being drawn
         */
        if (lastx >= 0) {
            int dx = p[i].x - lastx, dy = p[i].y - lasty;
            if (dx > 0) XCopyArea(stddpy,stdpix,stdwin,stdgc, lastx, lasty,
                                  dx, animheight, lastx, lasty);
            else if (dx < 0)
                XCopyArea(stddpy,stdpix,stdwin,stdgc, lastx+animwidth+dx, lasty,
                          -dx, animheight, lastx+animwidth+dx, lasty);

            if (dy > 0) XCopyArea(stddpy, stdpix, stdwin, stdgc, lastx, lasty,
                                  animwidth, dy, lastx, lasty);
            else if (dy < 0)
                XCopyArea(stddpy,stdpix,stdwin,stdgc, lastx, lasty+animheight+dy,
                          animwidth, -dy, lastx, lasty+animheight+dy);
        }

        XCopyArea(stddpy, sprite->window->pix, stdwin, stdgc,
                  0, 0, animwidth, animheight, p[i].x, p[i].y);
        XFlush(stddpy);
        for (j = 0; j < tics; j++);
/*     
 * erase the whole box approach:
 *      XCopyArea(stddpy, stdpix, stdwin, stdgc,
 *                0, 0, animwidth, animheight, p[i].x, p[i].y);
 */
        lastx = p[i].x;
        lasty = p[i].y;
    }
}


int getdefault(wbp w, char *prog, char *opt, char *answer)
{
    char *p;
    STDLOCALS(w);

   
    if ((p = XGetDefault(stddpy,prog,opt)) == NULL)
        return Failed;
    strcpy(answer, p);
    return Succeeded;
}


/*
 * Allocate a mutable color
 */
int mutable_color(wbp w, dptr argv, int ac, int *retval)
{
    XColor colorcell;
    LinearColor clr;
    unsigned long plane_masks[1], pixels[1];
    char *colorname;
    tended char  *str;
    int i;
    long alpha;
    {
        STDLOCALS(w);

        /*
         * X11 Bug Warning:  some old versions of the X server, but not X11R5,
         * will crash sometime after a failed call to XNewColor.  This happens
         * only if a virtual colormap has been allocated and completely filled
         * and then XNewColor is called to allocate a new, unshared entry.  The
         * request fails, as it should, but when the program eventually exits
         * the X server crashes.  This has been seen on OpenWindows 3.0,
         * Irix 4.0.1, and HP-UX 7.0.
         */

        if (!XAllocColorCells(stddpy,wd->cmap,False,plane_masks,0,pixels,1)) {
            /*
             * try again with a virtual colormap
             */
            if (!go_virtual(w) ||
                !XAllocColorCells(stddpy,wd->cmap,False,plane_masks,0,pixels,1))
                return Failed;                         /* cannot allocate an entry */
        }

        /*
         * allocate a slot in wdisplay->colors and wstate->theColors arrays
         */
        i = alc_centry(wd);
        if (i == 0)
            return Failed;
        wd->colors[i].type = MUTABLE;
        wd->colors[i].c = pixels[0];


        /* save color index as "name", followed by a null string for value */
        colorname = wd->colors[i].name;
        sprintf(colorname, "%ld", -pixels[0] - 1);	/* index is name */
        colorname = colorname + strlen(colorname) + 1;
        *colorname = '\0';				/* value unknown */

        if (ws->numColors < WMAXCOLORS) {
            if (ws->theColors == NULL) {
                MemProtect(ws->theColors = calloc(WMAXCOLORS, sizeof(short)));
            }
            ws->theColors[ws->numColors++] = i;
        }

        if (ac > 0) {                     /* set the color */
            if (ac != 1) return Error;
            /*
             * old-style check for C integer
             */
            else if (argv[0].dword == D_Integer) {/* check for color cell */
                if (IntVal(argv[0]) >= 0)
                    return Failed;        /* must be negative */
                colorcell.pixel = -IntVal(argv[0]) - 1;
                XQueryColor(stddpy, wd->cmap, &colorcell);
                clr = lcolor(w, colorcell);
                sprintf(colorname, "%ld,%ld,%ld", clr.red, clr.green, clr.blue);
            }
            else {
                if (!cnv:C_string(argv[0],str)) {
                    ReturnErrVal(103,argv[0], Error);
                }
                if (parsecolor(w, str, &clr.red, &clr.green, &clr.blue, &alpha) != Succeeded) {
                    free_xcolor(w, pixels[0]);
                    return Failed;                   /* invalid color specification */
                }
                strcpy(colorname, str);
                colorcell = xcolor(w, clr);
            }
            colorcell.pixel = pixels[0];
            XStoreColor(stddpy, wd->cmap, &colorcell);
        }

        *retval = (-pixels[0] - 1);
        return Succeeded;
    }
}

char *get_mutable_name(wbp w, int mute_index)
{
    wdp dp;
    Display *d;
    int i;
    char *colorname;

    dp = w->window->display;
    d = dp->display;

    for (i = 2; i < DMAXCOLORS; i++)
        if (dp->colors[i].type == MUTABLE && dp->colors[i].c == - mute_index - 1)
	    break;
    if (i == DMAXCOLORS)
        return NULL;
    colorname = dp->colors[i].name;			/* color name field */
    colorname = colorname + strlen(colorname) + 1;	/* set value follows */
    return colorname;
}

int set_mutable(wbp w, int i, char *s)
{
    LinearColor clr;
    long alpha;
    XColor colorcell;
    wdp dp = w->window->display;

    if (parsecolor(w, s, &clr.red, &clr.green, &clr.blue, &alpha) != Succeeded)
        return Failed;                        /* invalid color specification */
    colorcell = xcolor(w, clr);
    colorcell.pixel = -i - 1;
    XStoreColor(dp->display, dp->cmap, &colorcell);
    return Succeeded;
}

void free_mutable(wbp w, int mute_index)
{
    wdp dp;
    Display *d;
    int i;

    dp = w->window->display;
    d = dp->display;

    for (i = 2; i < DMAXCOLORS; i++)
        if (dp->colors[i].type == MUTABLE && dp->colors[i].c == - mute_index - 1)
            break;
    if (i != DMAXCOLORS)
        free_xcolor(w, dp->colors[i].c); 
}


void freecolor(wbp w, char *s)
{
    wdp dp;
    Display *d;
    long i, alpha;
    LinearColor clr;
    XColor color;

    if (parsecolor(w, s, &clr.red, &clr.green, &clr.blue, &alpha) != Succeeded)
        return;
    dp = w->window->display;
    d = dp->display;
    color = xcolor(w, clr);

    for (i = 2; i < DMAXCOLORS; i++)
        if (dp->colors[i].r == color.red && dp->colors[i].g == color.green
            && dp->colors[i].b == color.blue && dp->colors[i].type != MUTABLE)
            break;
    if (i != DMAXCOLORS)
        free_xcolor(w, dp->colors[i].c);
}

/*
 * Draw a bilevel image
 */
int blimage(wbp w, int x, int y, int width, int height, int ch, unsigned char *s, word len)
{
    unsigned int m, msk1, c, ix, iy;
    long fg, bg;
    XImage *im;
    STDLOCALS(w);

    /*
     * Get an XImage structure and free the old color set if possible.
     */
    im = getximage(w, x, y, width, height, ch == TCH1);
    if (im == NULL)
        return Error;

    /*
     * Read the image string and set the pixel values.  Note that
     * the hex digits in sequence fill the rows *right to left*.
     */
    m = width % 4;
    if (m == 0)
        msk1 = 8;
    else
        msk1 = 1 << (m - 1);		/* mask for first byte of row */

    fg = wd->colors[wc->fg].c;
    bg = wd->colors[wc->bg].c;
    ix = width;
    iy = 0;
    m = msk1;
    while (len--) {
        if (isxdigit((unsigned char)(c = *s++))) {		/* if hexadecimal character */
            if (!isdigit((unsigned char)c))		/* fix bottom 4 bits if necessary */
                c += 9;
            while (m > 0) {		/* set (usually) 4 pixel values */
                --ix;
                if (c & m)
                    XPutPixel(im, ix, iy, fg);
                else if (ch != TCH1)	/* if zeroes aren't transparent */
                    XPutPixel(im, ix, iy, bg);
                m >>= 1;
            }
            if (ix == 0) {			/* if end of row */
                ix = width;
                iy++;
                m = msk1;
            }
            else
                m = 8;
        }
    }
    if (ix > 0)				/* pad final row if incomplete */
        while (ix < width)
            XPutPixel(im, ix++, iy, bg);

    /*
     * Put it on the screen.
     */
    if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, GXcopy);
    RENDER7(XPutImage, im, 0, 0, x, y, width, height);
    XDestroyImage(im);
    if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, wc->drawop);
    return Succeeded;
}

/*
 * Draw a character-per-pixel image
 */
int strimage(wbp w, int x, int y, int width, int height, 
             struct palentry *e, unsigned char *s, word len, int on_icon)
{
    int c, v, ret = 0, trans = 0;
    unsigned int r, g, b, ix, iy;
    XImage *im;
    wclrp cp;
    int ciarray[256];
    char tmp[32];
    STDLOCALS(w);

    if (e) {
        /*
         * Get an XImage structure and free the old color set if possible.
         */
        for (c = 0; c < 256; c++)
            trans |= e[c].used && e[c].transpt;
    }
    im = getximage(w, x, y, width, height, trans);
    if (im == NULL)
        return -1;
    if (e) {
        /*
         * Allocate the colors we need.  Use black or white if unsuccessful.
         */
        ret = 0;
        for (c = 0; c < 256; c++)
            if (e[c].used && e[c].valid) {
                r = e[c].clr.red;
                g = e[c].clr.green;
                b = e[c].clr.blue;
                sprintf(tmp, "%d,%d,%d", r, g, b);
                cp = alc_rgb(w, tmp, r, g, b, 0);
                if (cp == NULL) {
                    ret++;
                    if ((0.299 * r + 0.587 * g + 0.114 * b) > 32767)
                        cp = alc_rgb(w, "white", 65535, 65535, 65535, 0);
                    else
                        cp = alc_rgb(w, "black", 0, 0, 0, 0);
                }
                ciarray[c] = cp-wd->colors;
            }

        /*
         * Read the image string and set the pixel values.
         */
        ix = iy = 0;
        while (len--) {
            c = *s++;
            v = e[c].valid;
            if (v)				/* put char if valid */
                XPutPixel(im, ix, iy, wd->colors[ciarray[c]].c);
            if (v || e[c].transpt) { 		/* advance if valid or transparent */
                if (++ix >= width) {
                    ix = 0;			/* reset for new row */
                    iy++;
                }
            }
        }
        if (ix > 0) {			/* pad final row if incomplete */
            while (ix < width)
                XPutPixel(im, ix++, iy, wd->colors[wc->bg].c);
        }
    }
    else {
        iy = 0;
        while (iy < height) {
            ix = 0;
            while (ix < width) {
                int b = *s++ * 257;
                int g = *s++ * 257;
                int r = *s++ * 257;
                wclrp cp = alc_rgb(w,"anon", r, g, b, 0);
                XPutPixel(im, ix++, iy, cp->c);
	    }
            iy++;
        }
    }
    /*
     * Put it on the screen.
     */
    if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, GXcopy);
    if (on_icon) {
        if (ws->iconwin == (Window) NULL) makeIcon(w, 0, 0);
        XPutImage(stddpy, ws->iconwin, stdgc, im, 0, 0, x, y, width, height);
        XPutImage(stddpy, ws->iconpix, stdgc, im, 0, 0, x, y, width, height);
    }
    else {
        XPutImage(stddpy, ws->pix, stdgc, im, 0, 0, x, y, width, height);
        if (ws->win)
            XCopyArea(stddpy, ws->pix, ws->win, stdgc, x, y, width, height, x, y);
    }
    XDestroyImage(im);
    if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, wc->drawop);
    return ret;
}

/*
 * getimstr(w, x, y, width, height, paltbl, data) -- get image as a string.
 *
 * Stores the specified subimage in data, one pixel per byte, and sets
 * entries in paltbl corresponding to the pixel values that were used.
 */

/*
 * Compare two unsigned long values for qsort or bsearch.
 */
static int ulcmp(unsigned long *p1, unsigned long *p2)
{
    register unsigned long u1 = *p1;
    register unsigned long u2 = *p2;

    if (u1 < u2)
        return -1;
    else
        return (u1 > u2);
}


/*
 * The getimstr() code assumes that a maximum of 256 colors can be onscreen
 * at one time.  If DMAXCOLORS maximum is raised, code must be added for the
 * depth>8 case to reduce the local copy of the image to no more than the
 * 256-color maximum allowed in a GIF file.  This reduction operation is
 * nontrivial; look up "color quantization" in computer graphics literature.
 */
#passthru #if (DMAXCOLORS > 256)
#passthru   Deliberate Syntax error
#passthru #endif				/* DMAXCOLORS */

int getimstr(wbp w, int x, int y, int width, int height,
             struct palentry paltbl[DMAXCOLORS], unsigned char *data)
{
    XImage *im;
    XColor colorcell;
    wclrp cp;
    unsigned long px, clist[DMAXCOLORS], *lp;
    int i, ncolors;
    STDLOCALS(w);

    /*
     * Get an XImage structure containing window pixel values.
     */
    im = getximage(w, x, y, width, height, 1);
    if (!im)
        return 0;
   
    if (im->depth <= 8) {

        /*
         * We can use the pixel values directly as color indices.
         * Put them in the data string, noting which colors are used.
         */
        for (i = 0; i < DMAXCOLORS; i++)
            clist[i] = i;
        for (y = 0; y < height; y++)
            for (x = 0; x < width; x++) {
                *data++ = px = XGetPixel(im, x, y) & 0xFF;
                paltbl[px].used = 1;
            }
    }

    else {

        /*
         * Make a sorted list of the pixel values of the colors that are in
         * use.  Search this list for every pixel and store the resulting
         * list index as the color index.
         */
        lp = clist;
        for (cp = wd->colors; cp < wd->colors + wd->numColors; cp++)
            *lp++ = cp->c;
        ncolors = lp - clist;
        qsort((char *)clist, ncolors, sizeof(*clist), (QSortFncCast)ulcmp);

        for (y = 0; y < height; y++)
            for (x = 0; x < width; x++) {
                px = XGetPixel(im, x, y);
                lp = (unsigned long *)bsearch((char *)&px, (char *)clist,
                                              ncolors, sizeof(*clist), (BSearchFncCast)ulcmp);
                if (lp)
                    i = lp - clist;
                else
                    i = 0;			/* use black if not found */
                *data++ = i;
                paltbl[i].used = 1;
            }
    }

    /*
     * Query the real color values from X; Icon's data structures
     * may show several entries for any particular pixel value.
     */
    for (i = 0; i < DMAXCOLORS; i++)
        if (paltbl[i].used) {
            colorcell.pixel = clist[i];
            colorcell.flags = DoRed | DoGreen | DoBlue;
            XQueryColor(stddpy, wd->cmap, &colorcell);
            paltbl[i].clr = lcolor(w, colorcell);
            paltbl[i].valid = 1;
        }

    XDestroyImage(im);
    return 1;
}

/*
 * Create an XImage structure corresponding to subimage (x, y, w, h).
 * If init is nonzero, initialize it with current contents.
 * If init is zero and (x,y,w,h) fills the window, free existing color set.
 */
static XImage *getximage(wbp w, int x, int y, int width, int height, int init)
{
    int tx, ty;
    XImage *im;
    STDLOCALS(w);

    im = XCreateImage(stddpy, DefaultVisual(stddpy, wd->screen),
                      DefaultDepth(stddpy, wd->screen), ZPixmap, 0, NULL, width, height, 32, 0);
    if (im == NULL)
        return NULL;
    im->data = malloc((im->bytes_per_line * height));
    if (im->data == NULL) {
        XDestroyImage(im);
        return NULL;
    }

    if (!init) {
        if (x <= 0 && y <= 0 && x + width >= ws->pixwidth &&
            y + height >= ws->pixheight && wc->clipw < 0) {
            free_xcolors(w, 0);
        }
        return im;
    }

    tx = ty = 0;
    if (x < 0)  { tx -= x; width += x; x = 0; }
    if (y < 0)  { ty -= y; height += y; y = 0; }
    if (x + width > ws->width)  { width = ws->width - x; }
    if (y + height > ws->height) { height = ws->height - y; }
    if (width > 0 && height > 0)
        XGetSubImage(stddpy, stdpix, x, y, width, height, AllPlanes, ZPixmap,
                     im, tx, ty);
    return im;
}

int readimage(wbp w, char *filename, int x, int y, int *status)
{
    Pixmap p;
    unsigned int width, height;
    STDLOCALS(w);
    if (!x && !y)
        p = loadimage(w, filename, &height, &width, 1, status);
    else
        p = loadimage(w, filename, &height, &width, 0, status);
    if (p == (Pixmap) NULL) return Failed;

    if (wc->drawop != GXcopy)
        XSetFunction(stddpy, stdgc, GXcopy);
    if (stdwin)
        XCopyArea(stddpy, p, stdwin, stdgc, 0, 0, width, height, x, y);
    XCopyArea(stddpy, p, stdpix, stdgc, 0, 0, width, height, x, y);
    if (wc->drawop != GXcopy)
        XSetFunction(stddpy,stdgc,wc->drawop);

    /*
     * Make sure previous ops on p are complete, then free it.
     */
    XSync(stddpy, False);
    XFreePixmap(stddpy, p);
    return Succeeded;
}


/*
 * Initialize client for producing pixels from a window
 */
int getpixel_init(wbp w, struct imgmem *imem)
{
    STDLOCALS(w);

    if (imem->width <= 0 || imem->height <= 0) {
        imem->im = NULL;
        return Succeeded;
    }
    imem->im = XGetImage(stddpy, stdpix,
                         imem->x, imem->y, imem->width, imem->height,
                         (1 << DefaultDepth(stddpy, wd->screen))-1, XYPixmap);
   
    if (imem->im == NULL) return Failed;
    return Succeeded;
}

static wclrp lastcp;

int getpixel_term(wbp w, struct imgmem *imem)
{
    if (imem->im != NULL)
        XDestroyImage(imem->im);
    lastcp = NULL;
    return Succeeded;
}

/*
 * Return pixel (x,y) from a window in long value (rv)
 */
int getpixel(wbp w, int x, int y, word *rv, char *s, struct imgmem *imem)
{
    XColor colorcell;
    LinearColor clr;
    wclrp cp;
    unsigned long c;
    wcp wc = w->context;
    wdp wd = w->window->display;
    Display *stddpy = wd->display; 

    if (x < imem->x || x >= imem->x + imem->width ||
        y < imem->y || y >= imem->y + imem->height)
        c = colorcell.pixel = wd->colors[wc->bg].c;
    else
        c = colorcell.pixel = XGetPixel(imem->im, x - imem->x, y - imem->y);
    *rv = 0xff000000;

    if (lastcp && (lastcp->c == c)) { cp = lastcp; goto foundc; }
    else
        for (cp = wd->colors ; cp < wd->colors + wd->numColors; cp++) {
            if (cp->c == c) {
                lastcp = cp;
              foundc:
                if (cp->type == MUTABLE)
                    *rv = -c - 1;
                else {
                    *rv = 1;
                    colorcell.red = cp->r;
                    colorcell.green = cp->g;
                    colorcell.blue = cp->b;
                    clr = lcolor(w, colorcell);
                    sprintf(s, "%ld,%ld,%ld", clr.red, clr.green, clr.blue);
                }
                break;
            }
        }
    if (*rv == 0xff000000) {
        XQueryColor(stddpy, wd->cmap, &colorcell);
        *rv = 1;
        clr = lcolor(w, colorcell);
        sprintf(s, "%ld,%ld,%ld", clr.red, clr.green, clr.blue);
    }
    return Succeeded;
}


int query_pointer(wbp w, XPoint *pp)
{
    Display *theDisplay;
    Window theWindow;
    Window garbage1, garbage2;
    int root_x, root_y, win_x, win_y;
    unsigned int key_buttons;

    theDisplay = w->window->display->display;
    theWindow  = w->window->win;
    if (theWindow == (Window) NULL) return Failed;

    XQueryPointer(theDisplay, theWindow, &garbage1, &garbage2,
                  &root_x, &root_y, &win_x, &win_y, &key_buttons);
    pp->x = w->window->pointerx = win_x;
    pp->y = w->window->pointery = win_y;
    return Succeeded;
}

int query_rootpointer(XPoint *pp)
{
    Display *theDisplay;
    Window theWindow;
    Window garbage1, garbage2;
    int root_x, root_y, win_x, win_y;
    unsigned int key_buttons;
    wdp wd;
    if (wdsplys == NULL) {
        /*
         * Initialize the window system
         */
        Protect(wd = alc_display(NULL), return Failed);

        theDisplay = wd->display;
        theWindow  = DefaultRootWindow(wd->display);
    }
    else {
        wd = wdsplys;
        theDisplay = wd->display;
        theWindow  = DefaultRootWindow(wd->display);
    }
    XQueryPointer(theDisplay, theWindow, &garbage1, &garbage2,
                  &root_x, &root_y, &win_x, &win_y, &key_buttons);
    pp->x = root_x;
    pp->y = root_y;
    return Succeeded;
}


int patbits[] = {
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFE,0xFF,0xEF,0xFF,0xFE,0xFF,0xEF,0xFF,
    0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,
    0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,
    0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,
    0x01,0x00,0x10,0x00,0x01,0x00,0x10,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,
    0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,
    0x10,0x10,0x10,0xFF,0x10,0x10,0x10,0x10,
    0x82,0x44,0x28,0x10,0x28,0x44,0x82,0x01,

    0x0F,0x0F,0x0F,0x0F,0xF0,0xF0,0xF0,0xF0,
    0x1B,0x18,0x81,0xB1,0x36,0x06,0x60,0x63,
    0x02,0x02,0x05,0xF8,0x20,0x20,0x50,0x8F,
    0x03,0x84,0x48,0x30,0x03,0x84,0x48,0x30,
};

/*
 * pattern symbols
 */
stringint siPatternSyms[] = {
    {0,		16},
    { "black",	 0},
    { "checkers",	 12},
    { "darkgray",	 2},
    { "diagonal",	 8},
    { "grains",	 13},
    { "gray",	 3},
    { "grid",	 10},
    { "horizontal",9},
    { "lightgray", 4},
    { "scales",	 14},
    { "trellis",	 11},
    { "vertical",	 7},
    { "verydark",	 1},
    { "verylight", 5},
    { "waves",	 15},
    { "white",	 6},
};

/*
 * SetPattern
 */
int SetPattern(wbp w, char *name, int len)
{
    int width, nbits;
    int i;
    int symbol;
    C_integer v, bits[MAXXOBJS];
    Pixmap p;
    char data[MAXXOBJS];
    char *buf = data;
    STDLOCALS(w);

    if (wc->patternname != NULL)
        free(wc->patternname);
    wc->patternname = salloc(name);
   
    /*
     * If the pattern starts with a number it is a width , bits encoding
     */
    if ((len > 0) && isdigit((unsigned char)name[0])) {
        nbits = MAXXOBJS;
        switch (parsepattern(name, len, &width, &nbits, bits)) {
            case Failed:
                return Failed;
            case Error:
                ReturnErrNum(145, Error);
        }
        if (!stdgc) return Succeeded;
        return SetPatternBits(w, width, bits, nbits);
    }

    /*
     * Otherwise, it is a named pattern.  Find the symbol id.
     */
    if ((symbol = stringint_str2int(siPatternSyms, wc->patternname)) >= 0) {
        if (!stdgc) return Succeeded;
        for(i = 0; i < 8; i++) {
            v = patbits[symbol * 8 + i];
            *buf++ = v;
        }
        p = XCreateBitmapFromData(stddpy, stdpix, data, 8, 8);
        XSetStipple(stddpy, stdgc, p);
        XSync(stddpy, False);
        XFreePixmap(stddpy, p);
        return Succeeded;
    }
    return Failed;
}

int SetPatternBits(wbp w, int width, C_integer *bits, int nbits)
{
    C_integer v;
    int i, j;
    Pixmap p;
    char data[MAXXOBJS];
    char *buf = data;
    STDLOCALS(w);

    for(i = 0; i < nbits; i++) {
        v = bits[i];
        for(j=0; j<width; j+=8) {
            *buf++ = v;
            v >>= 8;
        }
    }

    p = XCreateBitmapFromData(stddpy, stdpix, data, width, nbits);
    XSetStipple(stddpy, stdgc, p);
    XSync(stddpy, False);
    XFreePixmap(stddpy, p);
    return Succeeded;
}



/*
 * remap a window ... this time with an iconwin
 */
int remap(wbp w, int x, int y)
{
    XSizeHints size_hints;
    XWMHints   *wmhints;
    STDLOCALS(w);

    XGetSizeHints(stddpy, stdwin, &size_hints, XA_WM_NORMAL_HINTS);
    wmhints = XGetWMHints(stddpy, stdwin);
    if (ws->iconwin)
        XDestroyWindow(stddpy, ws->iconwin);
#ifdef HAVE_LIBXFT
    if (ws->winDraw) {
        XftDrawDestroy(ws->winDraw);
        ws->winDraw = NULL;
    }
#endif
    if (stdwin)
        XDestroyWindow(stddpy, stdwin);
    ws->win = XCreateSimpleWindow(stddpy, DefaultRootWindow(stddpy),
                                  ws->posx, ws->posy, ws->width,
                                  ws->height, 4,
                                  wd->colors[wc->fg].c, wd->colors[wc->bg].c);
    XSetStandardProperties(stddpy, ws->win, ws->windowlabel,
                           ws->iconlabel, 0, 0, 0, &size_hints);
    XSelectInput(stddpy, ws->win, XMasks(ws->inputmask));

    ws->iconwin = XCreateSimpleWindow(stddpy, DefaultRootWindow(stddpy),
                                      ws->iconx, ws->icony, ws->iconw,
                                      ws->iconh, 2,
                                      wd->colors[wc->fg].c,
                                      wd->colors[wc->bg].c);
    XSelectInput(stddpy, ws->iconwin,
                 ExposureMask | KeyPressMask | ButtonPressMask);

    wmhints->flags |= IconPositionHint;
    wmhints->icon_x = x;
    wmhints->icon_y = y;
    wmhints->initial_state = ws->iconic;
    wmhints->icon_window = ws->iconwin;
    wmhints->flags |= IconWindowHint;
    XSetWMHints(stddpy, ws->win, wmhints);
    CLREXPOSED(w);
    XMapWindow(stddpy, ws->win);
    if (ws->iconic == NormalState) {
        while (!ISEXPOSED(w))
            pollevent();
    }
    ws->iconx = x;
    ws->icony = y;
    XSync(stddpy, False);
    XFree((char *)wmhints);
    return 1;
}


int seticonimage(wbp w, dptr dp)
{
    int status;
    Pixmap pix;
    tended char *tmp;
    {
        STDLOCALS(w);
        /* get the pixmap file named by x */
        if (is:string(*dp)) {
            unsigned int height, width;
            if (!cnv:C_string(*dp,tmp))
                ReturnErrVal(103, *dp, Error);

            if ((ws->iconimage != NULL) && strcmp(ws->iconimage, ""))
                free(ws->iconimage);
            ws->iconimage = salloc(tmp);

            if (ws->iconwin == (Window) NULL) makeIcon(w,0,0);
            else {
                pix = loadimage(w, ws->iconimage, &height, &width, 0, &status);
                if (pix == (Pixmap) NULL)
                    return Failed;
                XCopyArea(stddpy, pix, ws->iconwin, wd->icongc,
                          0, 0, width, height, 0, 0);
                if (ws->iconpix) {
                    XSync(stddpy, False);
                    XFreePixmap(stddpy, ws->iconpix);
                }
                ws->iconpix = pix;
                ws->iconw = width;
                ws->iconh = height;
                if (remap(w,ws->iconx,ws->icony) == -1)
                    ReturnErrNum(144, Error);
            }
        }
        else
            return Failed;
        return Succeeded;
    }
}


/*
 * dumpimage -- write an image to a disk file in an X format.
 *
 * Accepts only .xpm and .xbm file names, returning NoCvt for anything else.
 */

int dumpimage(wbp w, char *filename, unsigned int x, unsigned int y, 
              unsigned int width, unsigned int height)
{
    int status, slen;
    STDLOCALS(w);

    /*
     * Check for bilevel XBM (X BitMap) format.
     */
    slen = strlen(filename);
    if ((slen > 4) &&
        (!strcmp(".xbm", filename + slen - 4) ||
         !strcmp(".XBM", filename + slen - 4))) {
        /*
         * Write a bitmap from a "color" window (presumed to have only BW in it).
         * BlackPixel ^ WhitePixel will have a 1 in the first bit in which
         * they are different, so this bit is the plane we want to copy.
         */

        if (DefaultDepth(stddpy,wd->screen) != 1) {
            unsigned long bw =
                BlackPixel(stddpy,wd->screen) ^ WhitePixel(stddpy,wd->screen);
            Pixmap p1 = XCreatePixmap(stddpy, DefaultRootWindow(stddpy),
                                      width, height, 1);
            XGCValues xgc;
            GC thinGC;
            int i;
            /*
             * pick out the bitplane on which Black and White differ
             */
            for(i=0;!((1<<i) & bw);i++);
            bw &= (1<<i);
            /*
             * Construct a 1-bit-deep GC for use in copying the plane.
             */
            xgc.foreground = BlackPixel(stddpy,wd->screen);
            xgc.background = WhitePixel(stddpy,wd->screen);
            thinGC = XCreateGC(stddpy,p1,GCForeground|GCBackground,&xgc);

            if (i>DefaultDepth(stddpy,wd->screen)) return Failed;
            XCopyPlane(stddpy,stdpix,p1,thinGC,x,y,width,height,0,0,bw);
            status= XWriteBitmapFile(stddpy, filename, p1, width, height, -1, -1);

            XSync(stddpy, False);
            XFreePixmap(stddpy, p1);
            XFreeGC(stddpy,thinGC);
            if (status != BitmapSuccess) return Failed;
        }
        else {
            if(x || y) {
                Pixmap p1 = XCreatePixmap(stddpy, DefaultRootWindow(stddpy), width,
                                          height, DefaultDepth(stddpy,wd->screen));

                XCopyArea(stddpy, stdpix, p1, stdgc, x, y, width, height, 0, 0);
                XSync(stddpy, False);

                status = XWriteBitmapFile(stddpy, filename, p1, width, height, -1, -1);

                XSync(stddpy, False);
                XFreePixmap(stddpy, p1);

                if (status != BitmapSuccess) return Failed;

            }
            else if (XWriteBitmapFile(stddpy, filename, stdpix,
                                      width, height, -1, -1) != BitmapSuccess)
                return Failed;

        }
        return Succeeded;
    }
    /*
     * Check for XPM (color X PixMap) format.
     */
    else if (((slen > 4) &&
              (!strcmp(".xpm", filename + slen - 4) ||
               !strcmp(".XPM", filename + slen - 4))) ||
             ((slen > 6) && !strcmp(".xpm.Z", filename + slen - 6))) {
#ifdef HAVE_LIBXPM
        /*
         * Could optimize by calling XpmWriteFileFromPixmap directly on the
         * stdpix...
         */
        Pixmap p1 = XCreatePixmap(stddpy, DefaultRootWindow(stddpy), width,
                                  height, DefaultDepth(stddpy,wd->screen));

        XCopyArea(stddpy, stdpix, p1, stdgc, x, y, width, height, 0, 0);
        XSync(stddpy, False);

        status = XpmWriteFileFromPixmap(stddpy, filename, p1,
                                        (Pixmap) NULL, NULL);
        XSync(stddpy, False);
        XFreePixmap(stddpy, p1);

        if (status == XpmSuccess)
            return Succeeded;
#endif					/* HAVE_LIBXPM */
        return Failed;
    }
    else
        return NoCvt;		/* not an X format -- write GIF instead */
}

/*
 * Load an image, in any format we can figure out.
 */
static Pixmap loadimage(wbp w, char *filename, unsigned int *height, 
                        unsigned int *width, int atorigin, int *status)
{
    Pixmap p1, p2 = (Pixmap) NULL;
    int xhot, yhot;
    XGCValues gcv;
    unsigned long gcmask = GCFont | GCForeground | GCBackground;
    int isxbm;
    STDLOCALS(w);

    if (!strcmp(".xbm", filename + strlen(filename) - 4))
        isxbm = 1;
    else if (!strcmp(".xpm", filename + strlen(filename) - 4) ||
             !strcmp(".xpm.Z", filename + strlen(filename) - 6))
        isxbm = 0;
    else {
        /*
         * Not sure what kind of file this is, make a guess
         * For example, the format might be on the first line of the file,
         * so open it up and read some.
         */
        FILE *ftemp = fopen(filename,"r");
        char s[6];
        int  i;

        if (!ftemp) {
            return (Pixmap) NULL;
        }
        if ((long)fread(s,1,6,ftemp) < (long)6) {
            fclose(ftemp);
            return (Pixmap) NULL;
        }
        fclose(ftemp);
        /* check s for XPM string */
        isxbm = 1;         /* default to xbm */
        for (i = 0; i <= 3; i++)
            if (!strncmp(&s[i], "XPM", 3))
                isxbm = 0;
    }

    if (isxbm) {    /* isxbm = 1 => .xbm file */
        if (XReadBitmapFile(stddpy, DefaultRootWindow(stddpy), filename,
                            width, height, &p1, &xhot, &yhot) != BitmapSuccess)
            return (Pixmap) NULL;
        else *status = 0;
        p2 = XCreatePixmap(stddpy, DefaultRootWindow(stddpy), *width, *height,
                           DefaultDepth(stddpy,DefaultScreen(stddpy)));
    }
    else {				/* isxbm == 0 => .xpm file */
#ifdef HAVE_LIBXPM
        int i, j;
        XpmAttributes a;
        XColor color;
        LinearColor clr;
        Pixmap dummy;
        a.npixels = 0;
        a.colormap = wd->cmap;
        a.valuemask = XpmReturnPixels | XpmColormap;
      
        *status = XpmReadFileToPixmap(stddpy, DefaultRootWindow(stddpy),
                                      filename, &p2, &dummy, &a);

        if (*status == XpmColorFailed && go_virtual(w)) {
            /* try again with a virtual colormap */
            a.npixels = 0;
            a.colormap = wd->cmap;
            a.valuemask = XpmReturnPixels | XpmColormap;
            *status = XpmReadFileToPixmap(stddpy, DefaultRootWindow(stddpy),
                                          filename, &p2, &dummy, &a);
        }

        if (*status != XpmSuccess) {
            if (*status == XpmColorFailed)
                *status = 1;
            else
                return (Pixmap) NULL;
        }
        else *status = 0;
        *height = a.height;
        *width = a.width;

        /*
         * if the loaded image is to cover an entire window, free up colors
         * currently in use by the window
         */
        if (atorigin && *width >= ws->pixwidth && *height >= ws->pixheight
            && wc->clipw < 0) {
            free_xcolors(w, 0);
        }

        /*
         * OK, now register all the allocated colors with the display
         * and window in which we are residing.
         */
        for (i = 0; i < a.npixels; i++) {
            for (j = 2; j < DMAXCOLORS; j++)
                if (wd->colors[j].refcount == 0) break;
            if (j == DMAXCOLORS) {
                return (Pixmap) NULL;
	    }
            if (j == wd->numColors) wd->numColors++;
            else if (j > wd->numColors) {
                wd->numColors = j+1;
	    }
            wd->colors[j].refcount = 1;
            /*
             * Store their allocated pixel (r,g,b) values.
             */
            color.pixel = wd->colors[j].c = a.pixels[i];
            XQueryColor(stddpy, wd->cmap, &color);
            wd->colors[j].r = color.red;
            wd->colors[j].g = color.green;
            wd->colors[j].b = color.blue;
            clr = lcolor(w, color);
            sprintf(wd->colors[j].name,"%ld,%ld,%ld",clr.red,clr.green,clr.blue);
            if (ws->numColors == WMAXCOLORS)
                ;
            else {
                if (ws->theColors == NULL) {
                    MemProtect(ws->theColors = calloc(WMAXCOLORS, sizeof(short)));
                }
                ws->theColors[ws->numColors++] = j;
	    }
        }
#else					/* HAVE_LIBXPM */
        return (Pixmap) NULL;
#endif					/* HAVE_LIBXPM */
    }

    if (p2 == (Pixmap) NULL) {
        return (Pixmap) NULL;
    }

    if (stdgc == NULL) {
        gcv.foreground = wd->colors[wc->fg].c;
        gcv.background = wd->colors[wc->bg].c;
#ifdef HAVE_LIBXFT
        gcv.font       = wd->xfont->fid;
#else
        gcv.font       = wc->font->fsp->fid;
#endif
        wc->gc = XCreateGC(stddpy, p2, gcmask, &gcv);
        stdgc = wc->gc;
    }

    if (isxbm) {
        XCopyPlane(stddpy, p1, p2, stdgc, 0, 0, *width, *height, 0, 0, 1);
        XSync(stddpy, False);
        XFreePixmap(stddpy, p1);
    }
    return p2;
}

/*
 * Interpret a platform-specific color name s.
 * Under X, we can do this only if there is a window.
 */
int nativecolor(wbp w, char *s, long *r, long *g, long *b)
{
    XColor colorcell;
    LinearColor clr;
    wsp ws;
    wdp wd;

    if (!w)				/* if no window, give up */
        return 0;
    ws = w->window;
    wd = ws->display;
    if (!XParseColor(wd->display, wd->cmap, s, &colorcell))
        return 0;				/* if unknown to X */
    clr = lcolor(w, colorcell);
    *r = clr.red;
    *g = clr.green;
    *b = clr.blue;
    return 1;
}

/*
 * Convert an X color into an Icon linear color.
 */
LinearColor lcolor(wbp w, XColor colorcell)
{
    LinearColor l;
    double gamma = w->context->gamma;

    l.red   = 65535 * pow((int)colorcell.red   / 65535.0, gamma);
    l.green = 65535 * pow((int)colorcell.green / 65535.0, gamma);
    l.blue  = 65535 * pow((int)colorcell.blue  / 65535.0, gamma);
    return l;
}

/*
 * Convert an Icon linear color into an X colorcell.
 */
XColor xcolor(wbp w, LinearColor c)
{
    XColor x;
    double invgamma = 1.0 / w->context->gamma;

    x.red   = 65535 * pow(c.red   / 65535.0, invgamma);
    x.green = 65535 * pow(c.green / 65535.0, invgamma);
    x.blue  = 65535 * pow(c.blue  / 65535.0, invgamma);
    x.flags = DoRed | DoGreen | DoBlue;
    x.pixel = 0;
    x.pad = 0;

    return x;
}


int raiseWindow(wbp w)
{
    XEvent event;
    XWindowAttributes attr;

    wsp ws = w->window;
    if (ws->win) {
        XMapRaised(ws->display->display, ws->win);

        /* Wait for the window to become viewable before giving
           it the focus. */
        for (;;) {
            XGetWindowAttributes(ws->display->display, ws->win, &attr);
            if (attr.map_state == IsViewable)
                break;
            /* Not viewable yet, so wait for a MapNotify event. */
            XWindowEvent(ws->display->display, 
                         ws->win,
                         StructureNotifyMask, 
                         &event);
        }

        /* Now it is viewable, so give it the focus. */
        XSetInputFocus(ws->display->display, ws->win, RevertToParent, CurrentTime);
    }
    return Succeeded;
}

int lowerWindow(wbp w)
{
    if (w->window->win)
        XLowerWindow(w->window->display->display, w->window->win);
    return Succeeded;
}

int walert(wbp w, int volume)
{
    STDLOCALS(w);
    XBell(stddpy, volume);    
    XFlush(stddpy);
    return Succeeded;
}

#ifdef HAVE_LIBXFT
int xft_stringwidth(wbp w, char *s, int n)
{
    XGlyphInfo	extents; 

    XftTextExtents8 (w->window->display->display,
                     w->context->font->fsp,
                     (FcChar8 *)s,
                     n,
                     &extents);
    return extents.xOff;
}

int xft_utf8width(wbp w, char *s, int n)
{
    XGlyphInfo	extents; 

    XftTextExtentsUtf8 (w->window->display->display,
                        w->context->font->fsp,
                        (FcChar8 *)s,
                        n,
                        &extents);
    return extents.xOff;
}


void drawstrng(wbp w, int x, int y, char *str, int slen)
{
    XftColor color;
    Region r;
    XRectangle rec;
    struct wcolor *cc;
    STDLOCALS(w);

    if (ws->win && !ws->winDraw)
        ws->winDraw = XftDrawCreate(ws->display->display,
                                    ws->win,
                                    ws->vis,
                                    ws->display->cmap);

    if (!ws->pixDraw)
        ws->pixDraw = XftDrawCreate(ws->display->display,
                                    ws->pix,
                                    ws->vis,
                                    ws->display->cmap);
    /* Don't think xft can do XOR drawing, so just swap bg/fg instead */
    if (ISXORREVERSE(w))
        cc = &wd->colors[wc->bg];
    else
        cc = &wd->colors[wc->fg];
    color.pixel = cc->c;
    color.color.red = cc->r;
    color.color.green = cc->g;
    color.color.blue = cc->b;
    color.color.alpha = 0xffff;

    if (wc->clipw >= 0 && wc->cliph >=0) {
        r = XCreateRegion();
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XUnionRectWithRegion(&rec, r, r);
        if (ws->winDraw) 
            XftDrawSetClip(w->window->winDraw, r);
        if (ws->pixDraw) 
            XftDrawSetClip(w->window->pixDraw, r);
        XDestroyRegion(r);
    } else {
        if (ws->winDraw) 
            XftDrawSetClip(w->window->winDraw, 0);
        if (ws->pixDraw) 
            XftDrawSetClip(w->window->pixDraw, 0);
    }

    if (ws->winDraw)
        XftDrawString8 (ws->winDraw,
                        &color,
                        wc->font->fsp,
                        x,
                        y,
                        (FcChar8 *)str,
                        slen);

    if (ws->pixDraw)
        XftDrawString8 (ws->pixDraw,
                        &color,
                        wc->font->fsp,
                        x,
                        y,
                        (FcChar8 *)str,
                        slen);
}

void drawutf8(wbp w, int x, int y, char *str, int slen)
{
    XftColor color;
    Region r;
    XRectangle rec;
    struct wcolor *cc;
    STDLOCALS(w);

    if (ws->win && !ws->winDraw)
        ws->winDraw = XftDrawCreate(ws->display->display,
                                    ws->win,
                                    ws->vis,
                                    ws->display->cmap);

    if (!ws->pixDraw)
        ws->pixDraw = XftDrawCreate(ws->display->display,
                                    ws->pix,
                                    ws->vis,
                                    ws->display->cmap);
    /* Don't think xft can do XOR drawing, so just swap bg/fg instead */
    if (ISXORREVERSE(w))
        cc = &wd->colors[wc->bg];
    else
        cc = &wd->colors[wc->fg];
    color.pixel = cc->c;
    color.color.red = cc->r;
    color.color.green = cc->g;
    color.color.blue = cc->b;
    color.color.alpha = 0xffff;

    if (wc->clipw >= 0 && wc->cliph >=0) {
        r = XCreateRegion();
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XUnionRectWithRegion(&rec, r, r);
        if (ws->winDraw) 
            XftDrawSetClip(w->window->winDraw, r);
        if (ws->pixDraw) 
            XftDrawSetClip(w->window->pixDraw, r);
        XDestroyRegion(r);
    } else {
        if (ws->winDraw) 
            XftDrawSetClip(w->window->winDraw, 0);
        if (ws->pixDraw) 
            XftDrawSetClip(w->window->pixDraw, 0);
    }

    if (ws->winDraw)
        XftDrawStringUtf8 (ws->winDraw,
                           &color,
                           wc->font->fsp,
                           x,
                           y,
                           (FcChar8 *)str,
                           slen);

    if (ws->pixDraw)
        XftDrawStringUtf8 (ws->pixDraw,
                           &color,
                           wc->font->fsp,
                           x,
                           y,
                           (FcChar8 *)str,
                           slen);
}

#endif            /* HAVE_LIBXFT */

#endif            /* Graphics */

