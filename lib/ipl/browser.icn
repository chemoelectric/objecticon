package ipl.browser

import 
   gui, 
   lang, 
   mail,
   http,
   util,
   io,
   net,
   xml,
   posix,
   ipl.pdco,
   ipl.sort,
   ipl.strings,
   ipl.caseless

$load BROKEN_LINK "rpp.BROKEN_LINK_24.gif"

class Req()
   public const
      client, url, referer, callback, kind, form_data, on_status

   public new(client, url, referer, callback, kind, form_data, on_status)
      self.client := client
      self.url := url 
      self.referer := referer
      self.callback := callback
      self.kind := kind
      self.form_data := form_data
      self.on_status := on_status
      return
   end
end

class Resp()
   public const
      err, url, referer, data, fname, content_type, kind, form_data, data_file

   public new(err, url, referer, data, fname, content_type, kind, form_data, data_file)
      self.err := err
      self.url := url
      self.referer := referer
      self.data := data
      self.fname := fname
      self.content_type := content_type
      self.kind := kind
      self.form_data := form_data
      self.data_file := data_file
      return
   end
end

class Handled()
   public const
      data, fname, content_type

   public new(data, fname, content_type)
      self.data := data
      self.fname := fname
      self.content_type := content_type
      return
   end
end

class CacheEntry()
   public const
      url, data, fname, content_type, expiry

   public new(url, data, fname, content_type, expiry)
      self.url := url
      self.data := data
      self.fname := fname
      self.content_type := content_type
      self.expiry := expiry
      return
   end
end

class Cache()
   private t, total, lim

   public get(url)
      local k, ent
      k := string(url.str())
      if ent := member(t, k) then {
         if \ent.expiry < Time.get_system_seconds() then
            del(ent)
         else
            return ent
      }
   end

   private del(ent)
      local k
      k := string(ent.url.str())
      total -:= *ent.data
      delete(t, k)
   end

   public add(ent)
      local k, old
      k := string(ent.url.str())
      #write("cache add ",k, " expiry ", (\ent.expiry - Time.get_system_seconds()) | "-")
      if old := member(t, k) then
         del(old)
      while *t > 0 &  total + *ent.data > lim do
         del(?t)
      insert(t, k, ent)
      total +:= *ent.data
      return
   end

   public new(lim)
      t := table()
      self.lim := lim
      total := 0
      return
   end
end

class Worker()
   private
      pool, httpc, tmp_file, cancelled
   package
      doing, task
   
   public static const NORMAL, NAVIGATE, REFRESH, DOWNLOAD

   private static init()
      NORMAL := 1
      NAVIGATE := 2
      REFRESH := 3
      DOWNLOAD := 4
   end

   public initially()
      task.start()
   end

   public finally()
      if \doing then
         cancel()
      else {
         # httpc may be null, since we may have started but never been run
         (\httpc).close()
         task.stop()
      }
   end

   public cancel()
      if \doing then {
         cancelled := 1
         task.interrupt()
         httpc.abort()
         if \tmp_file then {
            Files.remove(tmp_file)
            tmp_file := &null
         }
      }
   end

   public read()
      return httpc.get_read()
   end

   public length()
      return httpc.get_length()
   end

   private dwrite(a[])
      writes("[", serial(self), "] ")
      write!a
   end

   private writing_line(ev)
      dwrite("Sent: ", ev)
   end

   private read_line(ev)
      dwrite("Got : ", ev)
   end

   private read_string(ev)
      dwrite("Got : data - 0x", Format.int_to_string(*ev, 16), " bytes")
   end

   private writing_string(ev)
      dwrite("Sent: data - 0x", Format.int_to_string(*ev, 16), " bytes")
   end

   private failed(ev)
      dwrite("Failed ", &why, repl(" ", 20))
   end

   private retrying(ev)
      dwrite("Retrying ", &why, repl(" ", 20))
   end

   private other(ev, src, type)
      dwrite(type)
   end

   private static ls_sort(x)
      return map(x[1])
   end

   private static grname(gid, cache)
      local s
      (s := member(cache, gid)) | insert(cache, gid, s := (System.getgr(gid).name | gid))
      return s
   end

   private static uname(uid, cache)
      local s
      (s := member(cache, uid)) | insert(cache, uid, s := (System.getpw(uid).name | uid))
      return s
   end

   private cvt_file(f)
      local e, l, t, path, rs, now, tf, gcache, ucache
      ucache := table()
      gcache := table()
      if Files.is_directory(f) then {
         l := isort(Files.list(f), ls_sort) | fail
         now := Time.get_system_seconds()
         return use {
            rs := RamStream(),
            {
               rs.out("<html><head><title>Directory " || f || "</title></head><table>")
               path := FilePath(f)
               every e := !l do {
                  t := e[2]
                  tf := if now - t.mtime > 180 * 86400 then
                     Time(t.mtime + Time.SYSTEM_BASE_OFFSET).format("MMM'&nbsp;'dd'&nbsp;&nbsp;'yyyy")
                  else
                     Time(t.mtime + Time.SYSTEM_BASE_OFFSET).format("MMM'&nbsp;'dd'&nbsp;'HH:mm")
                  rs.out("<tr><td>" || t.mode_str || "&nbsp;<td>" || uname(t.uid, ucache) || "&nbsp;<td>" || grname(t.gid, gcache) ||
                         "&nbsp;<td align=right>" || Format.numeric_to_string(t.size, 0, ',') || "<td>&nbsp;" || tf || "&nbsp;<td>" ||
                         "<a href=\"file://" || URL.percent_encode(path.child(e[1]).canonical().str(), URL.UNRESERVED ++ '/') || "\">" || e[1] || "</a></tr>" || "\n")
               }
               rs.out("</table></html>")
               rs.str()
            }
         }
      } else
         return Files.file_to_string(f)
   end

   private status(ev, src, type)
      (\(\doing).on_status)(ev, src, type)
   end

   private setup_httpc()
      httpc := HttpClient().
         set_task(task).
         set_cookies(pool.cookies).
         set_authentications(pool.authentications).
         set_authentication_function(pool.authentication_function)
      httpc.set_user_agent(\pool.user_agent)

      every httpc.connect(status, 
                          NetClient.CONNECTING_EVENT |
                          NetClient.CONNECTED_EVENT |
                          NetClient.CLOSED_EVENT |
                          HttpClient.COMPLETE_EVENT |
                          HttpClient.FAILED_EVENT |
                          HttpClient.ABORTED_EVENT |
                          HttpClient.RETRYING_EVENT) 

      if \pool.log_http_flag then {
         httpc.connect(failed, HttpClient.FAILED_EVENT).
            connect(retrying, HttpClient.RETRYING_EVENT).
            connect(read_line, NetClient.READ_LINE_EVENT).
            connect(read_string, NetClient.READ_STRING_EVENT).
            connect(writing_line, NetClient.WRITING_LINE_EVENT).
            connect(writing_string, NetClient.WRITING_STRING_EVENT).
            connect(other, NetClient.CONNECTING_EVENT).
            connect(other, NetClient.CONNECTED_EVENT).
            connect(other, NetClient.CLOSED_EVENT).
            connect(other, HttpClient.COMPLETE_EVENT)
      }
   end

   private handle_file_req(r)
      local data
      if data := cvt_file(r.url.get_decoded_path()) then
         r.callback(Resp(, r.url, r.referer, data, r.url.get_decoded_path_last(),, r.kind))
      else
         r.callback(Resp(&why, r.url, r.referer,,,, r.kind))
   end

   private get_expiry(hres)
      local s, t, now, ma
      now := Time.get_system_seconds()
      if t := HttpClient.parse_generic_header(hres.get_first_header("Cache-Control")) then {
         if member(t, "no-cache") then
            fail
         if ma := integer(member(t, "max-age")) then
            return now + (0 < ma)
      }
      if s := hres.get_first_header("Expires") then {
         t := Time.parse(s, "E, d MMM yyyy hh:mm:ss z") | fail
         return now < t.get_unix_seconds()
      }
      return
   end

   private handle_http_req(r)
      local s, data, hreq, hres, fname, ct, x, ce
      if r.kind ~= REFRESH & /r.form_data & (ce := pool.cache.get(r.url)) then
         r.callback(Resp(, r.url, r.referer, ce.data, ce.fname, ce.content_type, r.kind))
      else if r.kind = DOWNLOAD then {
         tmp_file := Files.make_temp_filename("http_oibrowser.", ".bin") | stop("Couldn't create temp file: ", &why)
         s := BufferStream(FileStream(tmp_file, 
                                      ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT))).
            set_buff_size(8192) | stop("Couldn't open ", tmp_file, ": ", &why)
         hreq := HttpRequest().
            set_output_stream(s). 
            set_url(r.url).
            set_header("Accept-charset", "UTF-8, ISO-8859-1")
         if (\r.referer).scheme ~== u"file" then
            hreq.set_referer(r.referer.str())
         if hres := httpc.retrieve(hreq) then {
            s.close()
            fname := hres.get_filename()
            ct := ContentType.parse(hres.get_first_header("Content-Type"))
            # Note that cancelling removes tmp_file
            if /cancelled then
               r.callback(Resp(, hres.url, r.referer,, fname, ct, r.kind, 
                               if hreq.url === hres.url then r.form_data else &null, tmp_file))
         } else {
            s.close()
            if /cancelled then {
               save_why{Files.remove(tmp_file)}
               r.callback(Resp(&why, r.url, r.referer,,,, r.kind, r.form_data))
            }
         }
      } else use {
         s := RamStream(),
         {
            hreq := HttpRequest().
               set_output_stream(s). 
               set_url(r.url).
               set_header("Accept-charset", "UTF-8, ISO-8859-1")
            if (\r.referer).scheme ~== u"file" then
               hreq.set_referer(r.referer.str())
            if \r.form_data then {
               if is(r.form_data, Message) then
                  hreq.set_multipart_form_data(r.form_data)
               else
                  hreq.set_html_form_data(r.form_data)
            }

            if hres := httpc.retrieve(hreq) then {
               data := s.str()
               fname := hres.get_filename()
               ct := ContentType.parse(hres.get_first_header("Content-Type"))
               # Note we have to take into account redirections in deciding whether to cache
               # and whether form data should be in the response.
               if httpc.request.method == "GET" & x := get_expiry(hres) then
                  pool.cache.add(CacheEntry(hres.url, data, fname, ct, x))
               if /cancelled then
                  r.callback(Resp(, hres.url, r.referer, data, fname, ct, r.kind, 
                                  if hreq.url === hres.url then r.form_data else &null))
            } else {
               if /cancelled then
                  r.callback(Resp(&why, r.url, r.referer,,,, r.kind, r.form_data))
            }
         }
      }
   end

   private handle_func(r, f)
      local x, s
      if x := f(r) then {
         if is(x, Handled) then
            r.callback(Resp(, r.url, r.referer, x.data, x.fname, x.content_type, r.kind))
         else if s := string(x) then
            r.callback(Resp(, r.url, r.referer, s, r.url.get_path_last(),, r.kind))
         else
            runerr(103, x)
      } else
         r.callback(Resp(&why, r.url, r.referer,,,, r.kind))
   end

   private handle_req(r)
      local f, t
      t := string(r.url.scheme)
      case t of {
         "file": handle_file_req(r)
         "http"|"https": handle_http_req(r)
         default: {
            if f := member(pool.scheme_handlers, t) then
               handle_func(r, f)
            else
               r.callback(Resp("Unknown url scheme", r.url, r.referer,,,, r.kind))
         }
      }
   end

   private run()
      setup_httpc()
      repeat {
         while /pool.active do {
            # finally() has been called; close resources and revert
            httpc.close()
            task.revert()
         }
         until doing := pool.queue_get() do
            task.sleep()
         #write("doing for ",image(doing.browser), "   size=",pool.queue_size())
         cancelled := &null
         handle_req(doing)
         doing := &null
      }
   end

   public new(pool)
      self.pool := pool
      task := Dispatcher.new_task{run()}
      return
   end
end

class WorkerPool()
   private
      queue,
      workers
   private readable
      active,
      log_http_flag,
      cookies,
      user_agent,
      cache,
      authentications,
      authentication_function,
      scheme_handlers

   public set_log_http(s)
      self.log_http_flag := check_flag(s)
      return self
   end

   public initially()
      active := 1
      every (!workers).initially()
   end

   public finally()
      active := &null
      every (!workers).finally()
      clear(queue)
   end

   public cancel(client)
      local w
      delete(queue, client)
      every w := !workers do 
         if (\w.doing).client === client then
            w.cancel()
   end

   public get_worker(req)
      local w
      every w := !workers do 
         if w.doing === req then
            return w
   end

   public start_worker(req)
      local w, l
      if l := member(queue, req.client) then
         put(l, req)
      else
         insert(queue, req.client, [req])
      # Wake up a sleeping task if possible
      every w := !workers do 
         if w.task.is_sleeping() then {
            w.task.notify()
            break
         }
   end

   public queue_size()
      local i
      i := 0
      every i +:= *!queue
      return i
   end

   package queue_get()
      local l, r
      l := ?queue | fail
      r := get(l) | syserr("Empty list in queue table")
      if *l = 0 then
         delete(queue, r.client)
      return r
   end

   public count(client)
      local i, w
      i := *member(queue, client) | 0
      every w := !workers do 
         if (\w.doing).client === client then
            i +:= 1
      return i
   end

   public read(client)
      local i, w
      i := 0
      every w := !workers do 
         if (\w.doing).client === client then
            i +:= w.read()
      return i
   end

   public set_cookies(cookies)
      self.cookies := cookies
      return self
   end

   public set_authentications(m)
      self.authentications := m
      return self
   end

   public set_authentication_function(f)
      self.authentication_function := f
      return self
   end

   public set_cache(c)
      self.cache := c
      return self
   end

   public set_scheme_handlers(m)
      self.scheme_handlers := m
      return self
   end

   public add_scheme_handler(scheme, func)
      insert(scheme_handlers, scheme, func)
      return self
   end

   #
   # Set the user-agent identification
   #
   public set_user_agent(s)
      self.user_agent := s
      return self
   end

   public new(n)
      /n := 6
      queue := table()
      cookies := table()
      cache := Cache(8*1024*1024)
      authentications := table()
      scheme_handlers := table()
      workers := []
      every 1 to n do
         put(workers, Worker(self))
      return
   end
end

class Tbl(Border, HasMaxWidth, HasAscent)
   public get_max_width()
      local w1
      w1 := content.layout_delegate.get_max_width()  + border.get_total_width()
      return if \title then
         max(w1, title.get_max_width() + 2 * TITLE_OFFSET)
      else
         w1
   end

   public get_ascent(dw, dh)
      /title | return dh
      dw -:= border.get_total_width()
      return content.layout_delegate.get_ascent(dw) + border.get_t_inset() | dh
   end

   public new()
      cast(self,Border).new()
      set_content(Component(). 
                    set_layout(TableLayout()))
      set_border(NullBorder())
      return
   end
end

class Img(Label)
   private browser, img_url, link_url, wrote, imgw, imgh, img_data, img_name, form, map, held

   public got_data(res)
      if \res.err then
         set_paint(ImagePaint().set_cache("rpp.BROKEN_LINK"))
      else {
         set_paint(ImagePaint().
                      set_image(res.data).
                      set_max_size(imgw, imgh).
                      set_fill_dimensions(2))
         if /paint.win then
            set_paint(ImagePaint().set_cache("rpp.BROKEN_LINK"))
         else {
            img_name := res.fname
            img_data := res.data
         }
      }
   end

   private handle_rpress(e)
      local pm, pm_menu
      if pm_menu := browser.create_image_menu(img_url, img_name, img_data, wrote) then {
         pm := PopupMenu()
         pm.popup(parent_dialog, pm_menu, e.x, e.y)
      }
   end

   private handle_lrelease(e, src)
      if \wrote then
         browser.goto(wrote, browser.page_url, Worker.NORMAL)
   end

   private handle_mrelease(e)
      if \wrote then
         browser.link_mrelease(wrote)
   end

   private handle_form_lrelease(e, src)
      if in_region(e) then
         form.submit(e, src)
   end

   private handle_exit(e)
      if \wrote then {
         browser.clear_msg()
         wrote := &null
         set_pointer()
      }
   end

   private which_url(e)
      local m, u
      in_region(e) | fail
      if m := browser.get_map(\map) &
         u := m.over_url(e.x - x - border.get_l_inset(), 
                         e.y - y - border.get_t_inset()) then 
         return u
      return \link_url
   end

   private handle_lpress(e)
      held := wrote
   end

   private handle_ldrag(e)
      local u
      if u := which_url(e) & u === held then {
         if wrote ~=== u then {
            browser.msg(u.str())
            wrote := u
         }
      } else if \wrote then {
         browser.clear_msg()
         wrote := &null
      }
   end

   public get_pointer(e)
      if /form then
         handle_move(e)
      return \self.pointer
   end

   private handle_move(e)
      local u
      if u := which_url(e) then {
         if wrote ~=== u then {
            set_pointer("hand1")
            browser.msg(u.str())
            wrote := u
         }
      } else if \wrote then {
         browser.clear_msg()
         wrote := &null
         set_pointer()
      }
   end

   public new(browser, img_url, link_url, form, imgw, imgh, map)
      cast(self,Label).new()
      self.browser := browser
      self.imgw := imgw
      self.imgh := imgh
      self.img_url := img_url
      self.form := form
      self.link_url := link_url
      self.map := map
      if \form then {
         set_pointer("hand1")
         connect(self.handle_form_lrelease, Event.MOUSE_LEFT_RELEASE)
      } else if \map | \link_url then {
         connect(self.handle_move, Event.MOUSE_MOVEMENT)
         connect(self.handle_ldrag, Event.MOUSE_LEFT_DRAG)
         connect(self.handle_lpress, Event.MOUSE_LEFT_PRESS)
         connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE)
         connect(self.handle_mrelease, Event.MOUSE_MIDDLE_RELEASE)
         connect(self.handle_exit, Event.MOUSE_EXIT)
      }
      connect(self.handle_rpress, Event.MOUSE_RIGHT_PRESS)
      set_paint(NullPaint())
      set_border(NullBorder())
      return
   end
end

abstract class FormEntry()
   public 
      form_name, form_id, form_tabindex

   public reset_form() end
                  
   public get_save_key()
      return \form_name | \form_id
   end

   public get_save_subkey() end
   public get_save_value() end
   public restore_value(val) end

   public abstract get_value(ev, src, multipart_flag)
end

class FormToggle(ToggleTextButton, FormEntry)
   private const
      value,
      init_checked

   public reset_form()
      set_is_checked(init_checked)
   end

   public get_value(ev, src)
      if is_checked() then 
         return value
   end

   public get_save_subkey()
      return value
   end

   public get_save_value()
      return get_status()
   end

   public restore_value(val)
      set_is_checked(val)
   end

   public new(value, init_checked)
      cast(self,ToggleTextButton).new()
      self.value := value
      self.init_checked := init_checked
      set_is_checked(init_checked)
      return
   end
end

class FormButton(TextButton, FormEntry, HasAscent)
   private const
      value

   public get_value(ev, src)
      if src === self then
         return value
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset()
   end

   public new(value)
      cast(self,TextButton).new()
      self.value := value
      set_label(value)
      return
   end
end

class FormTblButton(Button, FormEntry, HasMaxWidth, HasAscent)
   public const
      tbl, value, form, type

   public get_value(ev, src)
      if src === self then
         return value
   end

   private handle_action(e, src)
      case type of { 
         "submit": form.submit(e, src)
         "reset": form.reset_form()
      }
   end

   public display()
      display_children()
      if \self.is_down then {
         Gui.style.down_rectangle(self.cbwin, self.x, self.y, self.w, self.h)
         tbl.border.draw_rev_rect(self.cbwin, self)
      }
      if self.has_focus() & self.is_unshaded() then
         tbl.border.draw_focus_rect(self.cbwin, self)
   end

   #
   # Prevent children from getting in the point chain.
   #
   public build_point_chain(l)
   end

   public get_default_width()
      return tbl.get_preferred_width()
   end

   public get_max_width()
      return tbl.get_max_width()
   end

   public get_default_height(dw)
      return tbl.get_preferred_height(dw)
   end

   public layout()
      tbl.x := x
      tbl.y := y
      tbl.w := w
      tbl.h := h
      tbl.layout()
   end

   public get_ascent(dw, dh)
      return tbl.get_ascent(dw, dh)
   end

   public new(form, value, type)
      cast(self,Button).new()
      tbl := Tbl().
         set_border(CompoundBorder().
                    set_outer(RaisedBorder()).
                    set_inner(EmptyBorder()))
      add(tbl)
      self.value := value
      self.form := form
      self.type := type
      # Although there is only one element in this Tbl, this flag
      # makes the ascent for the Tbl the ascent of the single
      # element.
      tbl.content.layout_delegate.set_align_baselines(&yes)
      connect(self.handle_action, Event.ACTION)
      return
   end
end

class Hidden(FormEntry)
   private const
      value

   public get_value()
      return value
   end

   public new(value)
      self.value := value
      return
   end
end

class FormLabel()
   public const
      id
   public
      comp

   public new(id)
      self.id := id
      return
   end
end

class FormBrowse(Component, FormEntry, HasAscent)
   private const
      tf,
      browser

   public get_value(ev, src, multipart_flag)
      return if /multipart_flag then
         tf.get_contents()
      else
         Files.file_to_string(tf.get_contents())
   end

   public get_filename()
      return FilePath(tf.get_contents()).get(-1)
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + Gui.Y_INSET
   end

   public reset_form()
      tf.set_contents(u"")
   end

   public get_save_value()
      return tf.get_contents()
   end

   public restore_value(val)
      tf.set_contents(val)
   end

   private on_browse()
      tf.set_contents(browser.browse_for_file())
   end

   public new(browser, tf_size)
      cast(self,Component).new()
      self.browser := browser
      set_layout(GridLayout().set_doi(0).set_dii(0))
      tf := TextField().set_size(tf_size).set_contents(u"")
      add(tf)
      add(TextButton().set_label("Browse...").connect(on_browse, Event.ACTION))
      return
   end
end

class FormImgX(FormEntry)
   private const
      img

   public get_value(ev, src)
      if src === img then
         return ev.x - img.x
   end

   public new(img)
      self.img := img
      return
   end
end

class FormImgY(FormEntry)
   private const
      img

   public get_value(ev, src)
      if src === img then
         return ev.y - img.y
   end

   public new(img)
      self.img := img
      return
   end
end

class FormTextField(TextField, FormEntry, HasAscent)
   private const
      init_val

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset()
   end

   public reset_form()
      set_contents(init_val)
   end

   public get_value()
      return get_contents()
   end

   public get_save_value()
      return get_contents()
   end

   public restore_value(val)
      set_contents(val)
   end

   public new(init_val)
      cast(self,TextField).new()
      self.init_val := init_val
      set_contents(init_val)
      return
   end
end

class FormEditableTextList(EditableTextList, FormEntry)
   private const
      init_val

   public reset_form()
      set_contents_str(init_val)
      set_cursor(1, 1)
   end

   public get_value()
      return get_contents_str()
   end

   public get_save_value()
      return get_contents()
   end

   public restore_value(val)
      set_contents(val)
   end

   public new(init_val)
      cast(self,EditableTextList).new()
      self.init_val := init_val
      set_contents_str(init_val)
      return
   end
end

class FormOption()
   public const
      txt, label, value, selected, disabled, optgroup

   public new(txt, label, value, selected, disabled, optgroup)
      self.txt := txt
      self.label := label
      self.value := value
      self.selected := selected
      self.disabled := disabled
      self.optgroup := optgroup
      return
   end
end

class FormOptionList(SelectableScrollArea, FormEntry)
   private const
      init_val

   public end_handle(e)
      local i
      every i := !selections do {
         if /contents[i].value then
            delete(selections, i)
      }
      cast(self,SelectableScrollArea).end_handle(e)
   end

   public get_value(ev, src)
      suspend \contents[!selections].value
   end

   public reset_form()
      set_selections(init_val)
   end

   public get_save_value()
      return get_selections()
   end

   public restore_value(val)
      set_selections(val)
   end

   public calculate_line_height()
      return view.cbwin.get_font_height()
   end

   public calculate_subject_width()
      local mw, o
      mw := 0
      every o := !contents do
         mw <:= view.cbwin.text_width(o.txt)
      return mw + 2 * Gui.TEXT_INSET
   end

   public draw_line_data(xp, yp, lh, i)
      local o, W
      o := contents[i]
      if \o.disabled then {
         use {
            W := view.cbwin.clone().set_fg("gray"),
            draw_string_ex(W, xp + Gui.TEXT_INSET, yp, o.txt)
         }
      } else 
         draw_string_ex(view.cbwin, xp + Gui.TEXT_INSET, yp, o.txt)
   end

   public new(init_val)
      cast(self,SelectableScrollArea).new()
      self.init_val := init_val
      return
   end
end

class FormList(gui.List, FormEntry, HasAscent)
   private const
      init_val

   public get_ascent() 
      return cbwin.get_font_ascent() + view.border.get_t_inset() + border.get_t_inset()
   end

   private find_value(seq, e)
      local i
      while i := @seq do {
         if \selection_list[i].value then {
            start_change(e)
            set_selection(i, e)
            end_change(e)
            break
         }
      }
   end

   public go_up(e)
      if /selection then
         find_value(create *selection_list to 1 by -1, e)
      else
         find_value(create (selection - 1 to 1 by -1) | (*selection_list to selection + 1 by -1), e)
   end

   public go_down(e)
      if /selection then
         find_value(create 1 to *selection_list, e)
      else
         find_value(create (1 + selection to *selection_list) | (1 to selection - 1), e)
   end

   public reset_form()
      set_selection(init_val)
   end

   public get_value(ev, src)
      return \object_get_selection().value
   end

   public get_save_value()
      return get_selection()
   end

   public restore_value(val)
      set_selection(val)
   end

   public create_popup()
      return FormOptionList()
   end

   public extract_selection()
      return self.selection_list[\self.selection].label
   end

   public get_default_width()
      local mw, o
      mw := 0
      every o := !selection_list do
         if \o.value then
            mw <:= view.cbwin.text_width(o.label)
      return border.get_total_width() + b.get_preferred_width() + mw + view.border.get_total_width()
   end

   public new(init_val)
      cast(self,gui.List).new()
      self.init_val := init_val
      return
   end
end

class Form()
   private readable
      key,
      url,
      browser,
      method,
      enctype,
      items,
      labels,   # table of FormLabels with ids set (the "for" attribute)
      cbgs,
      link_later   # Components with ids set ("id" attribute) which will be matched to entries in labels.

   private make_cgi_table(ev, src)
      local t, k, c, v, x
      t := table()
      every c := !items do {
         if k := \c.form_name then {
            every v := c.get_value(ev, src) do {
               (x := member(t, k)) | insert(t, k, x := [])
               put(x, v)
            }
         }
      }
      return t
   end

   private static escape_1521_value(s)
      local t
      t := u"\""
      s ? repeat {
         t ||:= tab(many(&uset -- '\"\\\r'))
         if pos(0) then
            break
         t ||:= u"\\" || move(1)
      }
      return t || u"\""
   end

   private make_cgi_message(ev, src)
      local k, v, c, m, mp, m2
      m := Message()
      mp := Multipart()
      every c := !items do {
         if k := \c.form_name then {
            every v := c.get_value(ev, src, 1) do {
               m2 := Message()
               if is(c, FormBrowse) then {
                  m2.set_header("Content-Disposition", 
                                "form-data; name=" || escape_1521_value(k) || 
                                "; filename=" || escape_1521_value(c.get_filename()))
                  m2.set_header("Content-Type", "application/octet-stream")
               } else 
                  m2.set_header("Content-Disposition", 
                                "form-data; name=" || escape_1521_value(k))
               m2.set_decoded_content(v)
               mp.add_part(m2)
            }
         }
      }
      m.set_header("Content-Type", "multipart/form-data")
      m.set_content_object(mp) | stop("Failed to set_content_object:",m.get_reason())
      return m
   end

   public reset_form()
      every (!items).reset_form()
   end

   public submit(ev, src)
      \url | fail
      if map(method) == "post" then {
         if map(enctype) == "multipart/form-data" then
            browser.goto(url, browser.page_url, Worker.NORMAL, make_cgi_message(ev, src))
         else 
            browser.goto(url, browser.page_url, Worker.NORMAL, make_cgi_table(ev, src))
      } else
         browser.goto(url.with_cgi_parameters(make_cgi_table(ev, src)), browser.page_url, Worker.NORMAL)
   end

   public add(name, item)
      put(items, item)
      item.form_name := name
   end

   public add_std(el, item)
      put(items, item)
      item.form_name := el.get_attribute(u"NAME")
      item.form_id := el.get_attribute(u"ID")
      item.form_tabindex := integer(el.get_attribute(u"TABINDEX"))
   end

   public add_label(l)
      insert(labels, l.id, l)
   end

   public link_label(context, comp)
      local l
      l := context.form_label
      # If we have a label in the context, and the for and id tags
      # make sense, link the comp to the label; otherwise put the comp
      # in ids so its id can be resolved at the end of the form.
      if \l & (/l.id | /comp.form_id | l.id == comp.form_id) then
         /l.comp := comp
      else if \comp.form_id then
         put(link_later, comp)
   end

   public resolve_link_labels()
      local c
      every c := !link_later do
         /member(labels, c.form_id).comp := c
   end

   public get_cbg(name)
      local x
      (x := member(cbgs, name)) | insert(cbgs, name, x := CheckBoxGroup())
      return x
   end

   public get_tab_children()
      local l, c
      l := []
      every c := !items do {
         if is(c, Component) then {
            if /c.form_tabindex | (c.form_tabindex >= 0) then
               put(l, c)
         }
      }
      return isort(l, tabindex_sort)
   end

   private tabindex_sort(c)
      return \c.form_tabindex | keyof(items, c)
   end

   public get_save_key()
      return \key
   end

   public new(browser, key, url, method, enctype)
      self.browser := browser
      self.key := key
      self.url := url
      self.method := method
      self.enctype := enctype
      self.items := []
      self.cbgs := table()
      self.labels := table()
      self.link_later := []
      return
   end
end

record TableContext(tbl, caption, x, y, occ, cell_border, tr, colgroups, curr_colgroup)
record TableColGroup(align, valign, width, span, cols)
record TableCol(align, valign, width, span)
record ListContext(tbl, index, root)
record DefListContext(tbl)
record FieldSetContext(legend)
record MapContext(map)
record SelectContext(options, optgroup)
record Context(base, form, form_label, url, fg, link_fg, font, align, pre, underline, strike, 
               face, size, bold, italic, kind, table, list, def_list, fieldset, select, map)

class MapArea()
   public const
      shape, coords, url

   public new(shape, coords, url)
      self.shape := shape
      self.coords := coords
      self.url := url
      return
   end
end

class Map()
   private const
      l

   public over_url(x, y)
      local e, co
      every e := !l do {
         co := e.coords
         case e.shape of {
            "rect": if (co[1] <= x <= co[3]) & (co[2] <= y <= co[4]) then
               return e.url
         }
      }
   end

   public add_area(area)
      put(l, area)
   end

   public new()
      l := []
      return
   end
end

record HistoryEntry(url,          # URL displayed (on a redirect may differ from that requested) 
                    referer,      # referer URL
                    form_values,  # Cached values of form components; updated when we move away from the page 
                    form_data,    # POST data used to get the page; on a redirect will always be null
                    area_x,
                    area_y
                    ) 

abstract class BrowserUI()
   public abstract msg(s, n)
   public abstract clear_msg()
   public abstract set_url_field(url)
   public abstract update_grey(gs)
   public abstract set_title(s)
   public abstract link_mrelease(url)
   public abstract create_link_menu(url)
   public abstract create_image_menu(url, img_name, img_data, link_url)
   public abstract browse_for_file()
end

record GreyState(prev, nxt, refresh, copy_page, save_page, stop)

class Browser(Component)
   private
      ui,
      worker_pool,
      shared_worker_pool_flag,
      top_panel,
      status_ticker,
      maps,
      forms,
      form_tab_children,
      curr_history_entry   # History entry currently being viewed.

   private readable
      history,
      history_pos,
      page_url,
      page_data,
      page_name,
      page_title,
      running

   public static const 
      COLORS,
      FACES,
      SIZES

   private static init()
      COLORS := table(,
                      "aqua", "#00FFFF",
                      "black", "#x000000",
                      "blue", "#0000CC",
                      "fuchsia", "#FF00FF",
                      "gray", "#808080",
                      "green", "#008000",
                      "lime", "#00FF00",
                      "maroon", "#800000",
                      "navy", "#000080",
                      "olive", "#808000",
                      "purple", "#800080",
                      "red", "#FF0000",
                      "silver", "#C0C0C0",
                      "teal", "#008080",
                      "white", "#FFFFFF",
                      "yellow", "#FFFF00")

      FACES := table(,
                     "serif", "serif",
                     "sans-serif", "sans",
                     "monospace", "mono",
                     "sans", "sans",
                     "mono", "mono",
                     "typewriter", "typewriter",
                     "cursive", "serif",
                     "fantasy", "serif",
                     "helvetica", "sans",
                     "arial", "sans",
                     "times", "serif",
                     "times new roman", "serif",
                     "courier", "typewriter")

      SIZES := [7,9,11,14,17,20,23]
      ImageCache.name_image("rpp.BROKEN_LINK", BROKEN_LINK)
   end

   public get_map(s)
      return member(maps, s)
   end

   private convert_color(el, name)
      local s
      if s := el.get_attribute(name) then {
         return if s[1] == "#" then
            s
         else
            member(COLORS, map(trim(string(s))))
      }
   end

   public traverse_tab_order()
      coact(top_panel)
      every (!self.form_tab_children).traverse_tab_order()
   end

   private synch_font(context)
      local s
      s := member(FACES, map(trim(separate(string(context.face))))) | "sans"
      if \context.bold then
         s ||:= ",bold"
      if \context.italic then
         s ||:= ",italic"
      s ||:= "," || SIZES[context.size]
      context.font := s
   end

   private status()
      local i, r, s
      repeat {
         status_ticker.sleep(200)
         i := worker_pool.count(self)
         if (i > 0) | (i ~=== running) then {
            if i = 0 then {
               msg("Done")
               page_fully_loaded()
            } else {
               r := worker_pool.read(self)
               s := i || " running requests"
               if r > 0 then
                  s ||:= ", read " || r || " bytes"
               msg(s)
            }
            if i ~=== running then {
               running := i
               do_update_grey()
            }
         }
      }
   end

   public link_mrelease(url)
      (\ui).link_mrelease(url)
      return self
   end

   public create_link_menu(url)
      return (\ui).create_link_menu(url)
   end

   public create_image_menu(url, img_name, img_data, link_url)
      return (\ui).create_image_menu(url, img_name, img_data, link_url)
   end

   public set_ui(ui)
      self.ui := ui
      return self
   end

   public msg(s, n)
      (\ui).msg(s, n)
      return self
   end

   public clear_msg()
      (\ui).clear_msg()
      return self
   end

   public set_url_field(url)
      (\ui).set_url_field(url)
      return self
   end

   public update_grey(gs)
      (\ui).update_grey(gs)
      return self
   end

   public set_title(s)
      (\ui).set_title(s)
      return self
   end

   public get_authentication(dom, realm)
      local d
      d := AuthenticationDialog(dom, realm)
      d.show_modal(parent_dialog)
      return \d.result
   end

   public do_update_grey()
      update_grey(GreyState(if history_pos > 1 then &no else &yes,
                            if history_pos < *history then &no else &yes,
                            if history[history_pos] then &no else &yes,
                            if \page_url then &no else &yes,
                            if \page_data then &no else &yes,
                            if \running > 0 then &no else &yes))
   end

   private page_fully_loaded()
      local xp, yp
      top_panel.
         reset_all_layouts().
         do_layout().
         invalidate()
      # Goto named anchor unless user has started to scroll page
      if top_panel.get_area_y() = top_panel.get_area_x() = 0 then {
         if yp := \curr_history_entry.area_y | (lookup_named_anchor(page_url.get_fragment()) - top_panel.view.y) then {
            top_panel.set_area_y(yp)
            if xp := \curr_history_entry.area_x then
               top_panel.set_area_x(xp)
         }
      }
      parent_dialog.resynch_pointer()
   end

   private lookup_named_anchor(name)
      local c, yp
      every c := Seq{top_panel.traverse_components_postorder()} do
         if is(c,TextFlow) & yp := c.lookup_named_anchor(name) then
            return yp
   end

   public initially()
      cast(self,Component).initially()
      if /shared_worker_pool_flag then
         worker_pool.initially()
      status_ticker.start()
      do_update_grey()
   end

   public finally()
      cast(self,Component).finally()
      if /shared_worker_pool_flag then
         worker_pool.finally()
      else
         worker_pool.cancel(self)
      running := 0
      status_ticker.stop()
   end

   public do_next()
      local he
      he := history[history_pos +:= 1] 
      goto(he.url, he.referer, Worker.NAVIGATE, he.form_data)
      do_update_grey()
      return self
   end

   public do_prev()
      local he
      he := history[history_pos -:= 1] 
      goto(he.url, he.referer, Worker.NAVIGATE, he.form_data)
      do_update_grey()
      return self
   end

   public do_refresh()
      local he
      he := history[history_pos] 
      goto(he.url, he.referer, Worker.REFRESH, he.form_data)
      do_update_grey()
      return self
   end

   public browse_for_file()
      return (\ui).browse_for_file()
   end

   public cancel()
      worker_pool.cancel(self)
   end

   private start_worker(req)
      worker_pool.start_worker(req)
      running := &null
   end

   private static is_image(ct, s)
      if (\ct).type == "image" then
         return
      return match("\x89PNG\x0D\x0A\x1A\x0A" |
                   "\xFF\xD8" |
                   "GIF87a" | "GIF89a", s)
   end

   private static is_html(ct, s)
      if (\ct).subtype == "html" then
         return
      s ? {
         while tab(upto('<')) do {
            if matchcl("<!doctype" | "<html" | "<meta") then
               return
            # Expect html comment (see htmlparser.icn)
            ="<!" | fail
            repeat {
               tab(upto('->'))
               if u">" then
                  break
               ="--" | fail
               tab(find("--")) | fail
               ="--"
            }
         }
      }
   end

   private convert_to_ucs(ct, s)
      return if (\ct).get_parameter("charset") == "ISO-8859-1" then
         Text.iso_8859_1_to_ucs(s)
      else
         Text.liberal_ucs(s)
   end

   private save_form_values()
      local f, c, name, t1, t2, fk, k
      t1 := table()
      every f := !forms do {
         if fk := f.get_save_key() then {
            t2 := table()
            insert(t1, fk, t2)
            every c := !f.items do {
               if name := c.get_save_key() then {
                  k := Class.get_name(c) || u":" || name
                  k ||:= u":" || c.get_save_subkey()
                  insert(t2, k, c.get_save_value())
               }
            }
         }
      }
      curr_history_entry.form_values := t1
   end

   private restore_form_values()
      local f, c, name, t1, t2, k
      t1 := \curr_history_entry.form_values | fail
      every f := !forms do {
         if t2 := member(t1, f.get_save_key()) then {
            every c := !f.items do {
               if name := c.get_save_key() then {
                  k := Class.get_name(c) || u":" || name
                  k ||:= u":" || c.get_save_subkey()
                  c.restore_value(member(t2, k))
               }
            }
         }
      }
   end

   private set_top_data(res)
      local doc, base, n, s, row, c
      if \curr_history_entry then {
         save_form_values()
         curr_history_entry.area_x := top_panel.get_area_x()
         curr_history_entry.area_y := top_panel.get_area_y()
      }
      top_panel.set_area_y(0).set_area_x(0)
      if \res.err then {
         s := u"<html><h1>Error:</h1>Getting " || res.url.str() || u"<br><br>" || res.err || u"</html>"
         page_data := &null
      } else {
         if is_html(res.content_type, res.data) then
            s := res.data
         else if is_image(res.content_type, res.data) then {
            # Try adding as an Image; if it isn't initialized
            # successfully, it will be taken out below and replaced with
            # a TextFlow with a problem message.
            row := Image().set_border(NullBorder()).set_image(res.data)
            top_panel.set_inner(row)
            if /row.win then {
               row := &null
               s := u"<html><h1>Problem:</h1>Displaying " || res.url.str() || u"<br><br>Unable to display that type of image</html>"
            }
         } else
            s := u"<html><h1>Problem:</h1>Displaying " || res.url.str() || u"<br><br>This does not seem to be an HTML document or an image</html>"
         page_data := res.data
      }
      page_name := res.fname
      page_url := res.url
      if res.kind = Worker.NORMAL then {
         # Reset history_pos, since we may have done a navigate
         # back/forward (changing history_pos), and cancelled it with
         # a normal click whist it was pending.
         history_pos := keyof(history, curr_history_entry)
         while *history > history_pos do
            pull(history)
         # Fields are set below
         put(history, HistoryEntry())
         history_pos +:= 1
      }
      do_update_grey()
      set_url_field(page_url)
      curr_history_entry := history[history_pos]
      # Note that the url/form_data may change even on a
      # navigate/refresh, if the server behaved differently (eg
      # redirect instead of error).
      curr_history_entry.url := page_url
      curr_history_entry.referer := res.referer
      curr_history_entry.form_data := res.form_data
      maps := table()
      forms := []
      form_tab_children := []
      if /row then {
         s := convert_to_ucs(res.content_type, s)
         doc := HtmlParser().parse(s)
         base := page_url
         if n := doc.get_root_element().search_tree(u"BASE") then
            base := URL(n.get_attribute(u"HREF"))

         row := TextFlow(self)
         page_title := &null
         c := Context()
         c.base := base
         c.face := "sans"
         c.fg := "black"
         c.link_fg := "blue"
         c.size := 3
         c.align := Align.L
         c.kind := res.kind   # Tells images whether to refresh or not
         synch_font(c)
         if n := doc.get_root_element().search_tree(u"BODY") then {
            row.set_bg(convert_color(n, u"BGCOLOR"))
            c.fg := convert_color(n, u"TEXT")
            c.link_fg := convert_color(n, u"LINK")
         }
         traverse(doc, row, c)
         if res.kind ~= Worker.REFRESH then
            restore_form_values()
         every form_tab_children |||:= (!forms).get_tab_children()
         top_panel.set_inner(row)
      } else
         page_title := page_name
      set_title(page_title)
      top_panel.layout()
      top_panel.invalidate()
      parent_dialog.resynch_pointer()
      setup_tabbing()
   end

   private focus_scroll(e, c)
      top_panel.ensure_visible(c)
   end

   private setup_tabbing()
      local c
      every c := Seq{(!self.form_tab_children).traverse_tab_order()} do
         c.connect(focus_scroll, Event.GOT_FOCUS)
   end

   private mk_link(context, s)
      return URL(s) | (\context.base).get_relative(s)
   end

   private traverse_a(e, p, context)
      local url, c, na
      if na := e.get_attribute(u"NAME") then {
         put(p.input, NamedAnchorCmd(na, context))
         traverse(e, p, context)
      }
      else if url := mk_link(context, e.get_attribute(u"HREF")) then {
         c := copy(context)
         c.url := url
         c.fg := c.link_fg
         traverse(e, p, c)
      }
   end

   private traverse_hN(e, p, context)
      local c
      put_para(p, context)
      c := copy(context)
      c.size := 7 - e.name[-1]
      c.bold := 1
      synch_font(c)
      traverse(e, p, c)
      put_para(p, c)
   end

   private parse_size(s, curr)
      local i
      i := if any('+\-', s[1]) then
         curr + integer(s)
      else
         integer(s)
      return (0 < \i <= 7, i)
   end

   private traverse_font(e, p, context)
      local c
      c := copy(context)
      c.fg := convert_color(e, u"COLOR")
      c.face := e.get_attribute(u"FACE")
      c.size := parse_size(e.get_attribute(u"SIZE"), c.size)
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_tt(e, p, context)
      local c
      c := copy(context)
      c.face := "mono"
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_big(e, p, context)
      local c
      c := copy(context)
      if c.size < 7 then {
         c.size +:= 1
         synch_font(c)
      }
      traverse(e, p, c)
   end

   private traverse_small(e, p, context)
      local c
      c := copy(context)
      if c.size > 1 then {
         c.size -:= 1
         synch_font(c)
      }
      traverse(e, p, c)
   end

   private traverse_sup(e, p, context)
      local c
      c := copy(context)
      if c.size > 1 then {
         c.size -:= 1
         synch_font(c)
      }
      put(p.input, SupStartCmd(c))
      traverse(e, p, c)
      put(p.input, SupEndCmd(c))
   end

   private traverse_sub(e, p, context)
      local c
      c := copy(context)
      if c.size > 1 then {
         c.size -:= 1
         synch_font(c)
      }
      put(p.input, SubStartCmd(c))
      traverse(e, p, c)
      put(p.input, SubEndCmd(c))
   end

   private traverse_b(e, p, context)
      local c
      c := copy(context)
      c.bold := 1
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_i(e, p, context)
      local c
      c := copy(context)
      c.italic := 1
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_address(e, p, context)
      local c
      c := copy(context)
      c.italic := 1
      synch_font(c)
      put_new_row(p, c)
      traverse(e, p, c)
      put_new_row(p, c)
   end

   private traverse_u(e, p, context)
      local c
      c := copy(context)
      c.underline := 1
      traverse(e, p, c)
   end

   private traverse_s(e, p, context)
      local c
      c := copy(context)
      c.strike := 1
      traverse(e, p, c)
   end

   private traverse_form(e, p, context)
      local m, c, t, url, key
      m := e.get_attribute(u"METHOD") | "get"
      t := e.get_attribute(u"ENCTYPE") | "application/x-www-form-urlencoded"
      url := mk_link(context, e.get_attribute(u"ACTION"))
      key := e.get_attribute(u"ID" | u"NAME") | (\url).str()
      c := copy(context)
      c.form := Form(self, key, url, m, t)
      put(forms, c.form)
      traverse(e, p, c)
      (\c.form).resolve_link_labels()
   end

   private traverse_label(e, p, context)
      local c, l, id
      \context.form | fail
      id := e.get_attribute(u"FOR")
      l := FormLabel(id)
      if \id then
         context.form.add_label(l)
      c := copy(context)
      c.form_label := l
      traverse(e, p, c)
   end

   private add_component(p, c, context, align)
      /align := "absbottom"
      put(p.input, ComponentCmd(c, context, align))
      p.add(c)
   end

   private traverse_button(e, p, context)
      local q, row, v, type
      \context.form | fail
      v := e.get_attribute(u"VALUE") | u""
      type := map(string(e.get_attribute(u"TYPE"))) | "submit"
      q := FormTblButton(context.form, v, type)
      if e.get_attribute(u"DISABLED") then
         q.set_is_shaded(&yes)
      else
         context.form.add_std(e, q)
      row := TextFlow(self)
      q.tbl.content.add(row)
      add_component(p, q, context, Align.B)
      traverse(e, row, context)
   end

   private traverse_img(e, p, context)
      local q, url, border, iw, ih, align, map, s
      if url := mk_link(context, e.get_attribute(u"SRC")) then {
         iw := (0 <= integer(e.get_attribute(u"WIDTH")))
         ih := (0 <= integer(e.get_attribute(u"HEIGHT")))
         if (s := e.get_attribute(u"USEMAP")) & (s[1] == u"#") then
            map := default.map(string(s[2:0]))
         q := Img(self, url, context.url,, iw, ih, map)
         border := (0 < integer(e.get_attribute(u"BORDER"))) | 0
         if border > 0 then
            q.set_border(PlainBorder().set_line_width(border))
         start_worker(Req(self, url, page_url, q.got_data, context.kind))
         align := convert_comp_align(e, u"ALIGN") | Align.B
         add_component(p, q, context, align)
      }
   end

   private traverse_select(e, p, context)
      local q, c, sc, size, mW, h, w, o, sel, sels, i, mode
      \context.form | fail
      sc := SelectContext()
      sc.options := []
      c := copy(context)
      c.select := sc
      traverse(e, p, c)
      sels := []
      every i := 1 to *sc.options do
         if \sc.options[i].selected then
            put(sels, i)
      if size := (1 < integer(e.get_attribute(u"SIZE"))) then {
         use {
            mW := cbwin.clone().set_font(context.font),
            {
               w := 0
               every o := !sc.options do
                  w <:= mW.text_width(o.txt)
               w +:= 2 * Gui.TEXT_INSET + 2 * Gui.BORDER_WIDTH
               h := (2 * Gui.BORDER_WIDTH + size * mW.get_font_height())
               if size < *sc.options then
                  w +:= ScrollArea.predict_scrollbar_size()
            }
         }
         if e.get_attribute(u"MULTIPLE") then
            mode := Select.MANY
         else {
            mode := Select.ONE
            while *sels > 1 do
               pull(sels)
         }
         q := FormOptionList(sels).
            set_contents(sc.options).
            set_size(w, h).
            set_select_mode(mode).
            set_selections(sels)
      } else {
         if *sels = 0 then {
            every i := 1 to *sc.options do
               if \sc.options[i].value then {
                  sel := i
                  break
               }
         } else
            sel := sels[1]
         q := FormList(sel).
            set_selection_list(sc.options).
            set_selection(sel)
      }
      q.set_font(context.font).set_fg(context.fg)
      if e.get_attribute(u"DISABLED") then
         q.set_is_shaded(&yes)
      else {
         context.form.add_std(e, q)
         context.form.link_label(context, q)
      }
      add_component(p, q, context, Align.B)
   end

   private traverse_option(e, p, context)
      local sc, v, txt, label, disabled, selected
      sc := \context.select | fail
      label := e.get_trimmed_string_content()
      if e.get_attribute(u"DISABLED") then
         disabled := 1
      else {
         v := e.get_attribute(u"VALUE") | label
         if e.get_attribute(u"SELECTED") then
            selected := 1
      }
      txt := if \sc.optgroup then
         u"    " || label
      else
         label
      put(sc.options, FormOption(txt, label, v, selected, disabled))
   end

   private traverse_optgroup(e, p, context)
      local sc, label
      sc := \context.select | fail
      /sc.optgroup := 1 | fail
      label := e.get_attribute(u"LABEL") | u""
      put(sc.options, FormOption(u"--- " || label || u" ---", label,,,, 1))
      traverse(e, p, context)
      sc.optgroup := &null
   end

   private traverse_textarea(e, p, context)
      local q, w, h, mW
      \context.form | fail
      use {
         mW := cbwin.clone().set_font(context.font),
         {
            w := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + mW.text_width(repl("x", e.get_attribute(u"COLS")))) | 200
            h := (2 * Gui.BORDER_WIDTH + e.get_attribute(u"ROWS") * mW.get_font_height()) | 100
         }
      }
      # The ucs conversion is used here since an empty node will return "" (not u"").
      q := FormEditableTextList(ucs(e.get_trimmed_string_content())).
         set_font(context.font).
         set_fg(context.fg).
         set_size(w, h)
      if e.get_attribute(u"DISABLED") then
         q.set_is_shaded(&yes)
      else {
         if e.get_attribute(u"READONLY") then
            q.set_is_editable(&no)
         context.form.add_std(e, q)
         context.form.link_label(context, q)
      }
      add_component(p, q, context)
   end

   private traverse_input(e, p, context)
      local q, s, k, v, size, mW, url, checked, align
      \context.form | fail
      s := string(map(e.get_attribute(u"TYPE"))) | "text"
      case s of {
         "file": {
            use {
               mW := cbwin.clone().set_font(context.font),
               size := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + mW.text_width(repl("x", e.get_attribute(u"SIZE")))) | 160
            }
            q := FormBrowse(self, size).
                  set_font(context.font).
                  set_fg(context.fg)
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else
               context.form.add_std(e, q)
            add_component(p, q, context, Align.B)
         }
         "submit" : {
            v := e.get_attribute(u"VALUE")
            if /v | (*v = 0) then
               v := u"Submit"
            q := FormButton(v).
                  set_font(context.font).
                  set_fg(context.fg).
                  connect(context.form.submit, Event.ACTION)
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else
               context.form.add_std(e, q)
            add_component(p, q, context, Align.B)
         }
         "button" : {
            v := e.get_attribute(u"VALUE") | u""
            q := FormButton(v).
                  set_font(context.font).
                  set_fg(context.fg)
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else
               context.form.add_std(e, q)
            add_component(p, q, context, Align.B)
         }
         "image" : {
            if url := mk_link(context, e.get_attribute(u"SRC")) then {
               q := Img(self, url,, context.form)
               start_worker(Req(self, url, page_url, q.got_data, context.kind))
               if e.get_attribute(u"DISABLED") then
                  q.set_is_shaded(&yes)
               else {
                  if k := e.get_attribute(u"NAME") then {
                     context.form.add(k || ".x", FormImgX(q))
                     context.form.add(k || ".y", FormImgY(q))
                  } else {
                     context.form.add("x", FormImgX(q))
                     context.form.add("y", FormImgY(q))
                  }
               }
               align := convert_comp_align(e, u"ALIGN") | Align.B
               add_component(p, q, context, align)
            }
         }
         "reset" : {
            v := e.get_attribute(u"VALUE")
            if /v | (*v = 0) then
               v := u"Reset"
            q := FormButton(v).
               set_font(context.font).
               set_fg(context.fg).
               connect(context.form.reset_form, Event.ACTION)
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else
               context.form.add_std(e, q)
            add_component(p, q, context, Align.B)
         }
         "hidden": {
            context.form.add(e.get_attribute(u"NAME"), Hidden(e.get_attribute(u"VALUE")))
         }
         "radio": {
            v := e.get_attribute(u"VALUE") | u"on"
            checked := if e.get_attribute(u"CHECKED") then &yes else &no
            q := FormToggle(v, checked).
               set_paint(ImagePaint().set_cache("gui.DIAMOND_UP")).
               set_paint_down(ImagePaint().set_cache("gui.DIAMOND_DOWN")).
               set_border(NullBorder())
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else {
               context.form.add_std(e, q)
               context.form.link_label(context, q)
            }
            add_component(p, q, context, Align.B)
            context.form.get_cbg(e.get_attribute(u"NAME")).add(q)
         }
         "checkbox": {
            v := e.get_attribute(u"VALUE") | u"on"
            checked := if e.get_attribute(u"CHECKED") then &yes else &no
            q := FormToggle(v, checked).
               set_paint(ImagePaint().set_cache("gui.BOX_UP")).
               set_paint_down(ImagePaint().set_cache("gui.BOX_DOWN")).
               set_border(NullBorder())
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else {
               context.form.add_std(e, q)
               context.form.link_label(context, q)
            }
            add_component(p, q, context, Align.B)
         }
         # Assume something textual; could be password, text, email etc.
         default: {
            v := e.get_attribute(u"VALUE") | u""
            use {
               mW := cbwin.clone().set_font(context.font),
               size := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + mW.text_width(repl("x", e.get_attribute(u"SIZE")))) | 160
            }
            q := FormTextField(v).
               set_fg(context.fg).
               set_font(context.font).
               set_size(size).
               connect(context.form.submit, Event.ACTION)
            if s == "password" then
               q.set_displaychar("*")
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else {
               if e.get_attribute(u"READONLY") then
                  q.set_is_editable(&no)
               context.form.add_std(e, q)
               context.form.link_label(context, q)
            }
            add_component(p, q, context, Align.B)
         }
      }
      traverse(e, p, context)
   end

   private show_parents(c)
      write("chain of ",image(c))
      while \c do {
         write("\tc=",image(c))
         c := c.parent
      }
   end

   private show_input(ii, l)
      local s,a
      case classof(ii) of {
         TextCmd: {
            s := ii.s
            if *s > 30 then 
               s[30:0] := "...("||*s||")"
            a := ""
            a ||:= "fg="|| \ii.attr.fg
            a ||:= " font="|| \ii.attr.font
            write(repl("   ",l), image(s),"  ",a) 
         }
         ComponentCmd: show_structure(ii.c, l)
         default: write(repl("   ",l),image(ii))
      }
   end

   private show_output(xo, l)
      local s,a
      s := "Text @"||xo.x||","||xo.y
      s ||:= xo.s
      if *s > 30 then 
         s[30:0] := "...("||*s||")"
      a := ""
      a ||:= "fg="|| \xo.attr.fg
      a ||:= " font="|| \xo.attr.font
      write(repl("   ",l), image(s),"  ",a) 
   end

   private show_structure(c, l)
      local s, v, short
      /l := 0
      short := s := ""
      short ||:= "w="||\c.w||" h="||\c.h
      if is(c, TextFlow) then short ||:= "  " || *c.input || " items"
      if c.get_constraint("eol") then s ||:= "eol "
      if \c.get_constraint("x_fill") then s ||:= "x_fill "
      if v := c.get_constraint("x_weight") then s ||:= "x_weight=" || v
      if v := c.get_constraint("x_align") then s ||:= "x_align=" || v
      write(repl("   ",l), image(c),short,"\t\t\t",s)
      if is(c, TextFlow) then {
         every show_input((!c.input), l+1)
      } else
         every show_structure((!c.children), l+1)
   end

   private traverse_div(e, p, context)
      put_new_row(p, context)
      traverse(e, p, context)
   end

   private traverse_br(e, p, context)
      local clear
      clear := case string(map(e.get_attribute(u"CLEAR"))) of {
         "left": Align.L
         "right": Align.R
         "all"|"both": "all"
      }
      put(p.input, BreakCmd(clear, context))
   end

   private traverse_hr(e, p, context)
      local l, c
      l := Line().
         set_width(5)
      do_width_param(e, l) | l.set_constraint("pct_w", 100)
      c := copy(context)
      put_new_row(p, c)
      c.align := convert_halign(e, u"ALIGN")
      add_component(p, l, c)
      put_new_row(p, c)
   end

   private traverse_q(e, p, context)
      put(p.input, TextCmd(u"\u201c", context))
      traverse(e, p, context)
      put(p.input, TextCmd(u"\u201d", context))
   end

   private traverse_p(e, p, context)
      local c
      c := copy(context)
      put_para(p, c)
      c.align := convert_halign(e, u"ALIGN")
      traverse(e, p, c)
      put_para(p, c)
   end

   private traverse_pre(e, p, context)
      local c
      put_para(p, context)
      c := copy(context)
      c.face := "mono"
      synch_font(c)
      c.pre := 1
      traverse(e, p, c)
      put_para(p, c)
   end

   private put_para(p, context)
      put(p.input, ParaCmd(context))
   end

   private put_new_row(p, context)
      put(p.input, NewRowCmd(context))
   end

   private traverse_center(e, p, context)
      local c
      c := copy(context)
      c.align := Align.C
      traverse(e, p, c)
   end

   private convert_valign(el, name)
      return case string(map(el.get_attribute(name))) of {
         "top": Align.T
         "middle": Align.C
         "bottom"|"baseline": Align.B
      }
   end

   private convert_halign(el, name)
      return case string(map(el.get_attribute(name))) of {
         "left": Align.L
         "center": Align.C
         "right": Align.R
      }
   end

   private convert_cap_align(el, name)
      return case string(map(el.get_attribute(name))) of {
         "left": Align.L
         "right": Align.R
         "top": Align.T
         "bottom": Align.B
      }
   end

   private convert_comp_align(el, name)
      return case map(string(el.get_attribute(name))) of {
         "left": Align.L
         "right": Align.R
         "baseline"|"bottom": Align.B
         "texttop"|"top": Align.T
         "middle" | "center" | "centre": Align.C
         "absbottom":  "absbottom"
         "absmiddle":  "absmiddle"
      }
   end

   private do_width_param(e, c, def_w)
      local width
      return if width := (e.get_attribute(u"WIDTH") | \def_w) then {
         if width := (0 <= integer(width)) then
            c.set_constraint("fix_w", width)
         else if width[-1] == "%" & width := (0 <= integer(width[1:-1])) then
            c.set_constraint("pct_w", width)
      }
   end

   private do_height_param(e, c)
      local height
      return if height := e.get_attribute(u"HEIGHT") then {
         if height := (0 <= integer(height)) then
            c.set_constraint("fix_h", height)
      }
   end

   private traverse_table(e, p, context)
      local ct, tbl, border, cellpadding, cellspacing, cell_border, align, c

      tbl := Tbl()
      do_width_param(e, tbl)
      do_height_param(e, tbl)
      border := integer(e.get_attribute(u"BORDER")) | 0
      cellpadding := integer(e.get_attribute(u"CELLPADDING")) | 0
      cellspacing := integer(e.get_attribute(u"CELLSPACING")) | 2
      tbl.content.layout_delegate.set_doi(cellspacing).set_dii(cellspacing/2)
      if border > 0 then
         tbl.set_border(PlainBorder().set_line_width(border))
      tbl.set_bg(convert_color(e, u"BGCOLOR"))

      cell_border := if border > 0 then
         CompoundBorder().
            set_outer(PlainBorder().set_line_width(1)).
            set_inner(EmptyBorder().set_insets(cellpadding, cellpadding, cellpadding, cellpadding))
         else
            EmptyBorder().set_insets(cellpadding, cellpadding, cellpadding, cellpadding)
      align := convert_comp_align(e, u"ALIGN") | Align.C

      c := copy(context)
      c.table := ct := TableContext()
      ct.tbl := tbl
      ct.x := ct.y := 1
      ct.occ := set()
      ct.cell_border := cell_border
      ct.colgroups := []
      traverse(e, p, c)

      if not(align === (Align.L | Align.R)) then
         put_new_row(p, c)
      if \c.table.caption then
         add_component(p, c.table.caption, context, align)
      else
         add_component(p, tbl, context, align)

      if not(align === (Align.L | Align.R)) then
         put_new_row(p, c)
   end

   private traverse_caption(e, p, context)
      local ct, cap, main, c, align
      ct := \context.table | fail
      /ct.caption | fail

      # A Tbl with two TextFlows; the caption and another containing just the table itself.
      ct.caption := Tbl()
      cap := TextFlow(self).set_dominant_width(TextFlow.PREFERRED_WIDTH)
      c := copy(context)
      c.align := Align.C
      traverse(e, cap, c)
      main := TextFlow(self)
      add_component(main, ct.tbl, context)
      align := convert_cap_align(e, u"ALIGN") | Align.T
      case align of {
         Align.T: {
            cap.set_constraint("eol", &yes)
            ct.caption.content.add(cap).add(main)
         }
         Align.B: {
            main.set_constraint("eol", &yes)
            ct.caption.content.add(main).add(cap)
         }
         Align.L: {
            ct.caption.content.add(cap).add(main)
         }
         Align.R: {
            ct.caption.content.add(main).add(cap)
         }
      }
   end

   private traverse_colgroup(e, p, context)
      local ct, cg
      ct := \context.table | fail
      cg := TableColGroup()
      cg.span := (0 < integer(e.get_attribute(u"SPAN"))) | 1
      cg.width := e.get_attribute(u"WIDTH")
      cg.valign := convert_valign(e, u"VALIGN")
      cg.align := convert_halign(e, u"ALIGN")
      cg.cols := []
      put(ct.colgroups, cg)
      ct.curr_colgroup := cg
      traverse(e, p, context)
      ct.curr_colgroup := &null
   end

   private traverse_col(e, p, context)
      local ct, cg, tc
      ct := \context.table | fail
      cg := \ct.curr_colgroup | fail
      tc := TableCol()
      tc.span := (0 < integer(e.get_attribute(u"SPAN"))) | 1
      tc.width := e.get_attribute(u"WIDTH") | cg.width
      tc.valign := convert_valign(e, u"VALIGN") | cg.valign
      tc.align := convert_halign(e, u"ALIGN") | cg.align
      put(cg.cols, tc)
   end

   private traverse_tr(e, p, context)
      local ct
      ct := \context.table | fail
      ct.tr := e
      if ct.x > 1 then {
         ct.x := 1
         ct.y +:= 1
      }
      traverse(e, p, context)
      if ct.x > 1 then {
         ct.x := 1
         ct.y +:= 1
      }
      ct.tr := &null
   end

   private get_col_info(ct, n)
      local i, e, f
      i := 0
      every e := !ct.colgroups do {
         if *e.cols > 0 then {
            every f := !e.cols do {
               if i + f.span >= n then
                  return f
               i +:= f.span
            }
         } else {
            if i + e.span >= n then
               return e
            i +:= e.span
         }
      }
   end

   private traverse_td(e, p, context)
      local ct, row, c, colspan, rowspan, valign, col, def_w
      ct := \context.table | fail
      while member(ct.occ, ct.x || "," || ct.y) do
         ct.x +:= 1
      col := get_col_info(ct, ct.x)
      valign := convert_valign(e | \ct.tr, u"VALIGN") | \ (\col).valign | Align.C
      row := TextFlow(self).
         set_constraint("x", ct.x). 
         set_constraint("y", ct.y).
         set_border(ct.cell_border).
         set_v_align(valign)
      colspan := (0 < integer(e.get_attribute(u"COLSPAN"))) | 1
      row.set_constraint("w", colspan)
      rowspan := (0 < integer(e.get_attribute(u"ROWSPAN"))) | 1
      row.set_constraint("h", rowspan)
      row.set_bg(convert_color(e | \ct.tr, u"BGCOLOR"))
      every insert(ct.occ, (ct.x to ct.x + colspan - 1) || "," || (ct.y to ct.y + rowspan - 1))
      if colspan = 1 then
         def_w :=  \ (\col).width
      do_width_param(e, row, def_w)
      do_height_param(e, row)
      ct.tbl.content.add(row)

      c := copy(context)
      if e.name == u"TH" then {
         c.bold := 1
         c.size := min(c.size + 1, 7)
         synch_font(c)
         c.align := convert_halign(e | \ct.tr, u"ALIGN") | \ (\col).align | Align.C
      } else
         c.align := convert_halign(e | \ct.tr, u"ALIGN") | \ (\col).align | Align.L
      ct.x +:= colspan

      traverse(e, row, c)
   end

   private traverse_list(e, p, context)
      local tbl, lc, c
      tbl := Tbl()
      tbl.content.layout_delegate.set_align_baselines(&yes)
      c := copy(context)
      lc := ListContext()
      lc.tbl := tbl
      lc.index := 0
      lc.root := e
      c.list := lc
      traverse(e, p, c)
      put_new_row(p, c)
      add_component(p, tbl, context, Align.B)
      put_new_row(p, c)
   end

   private traverse_li(e, p, context)
      local lc, row
      lc := \context.list | fail
      row := TextFlow(self)
      if lc.root.name == u"OL" then
         put(row.input, TextCmd((lc.index +:= 1) || u".\ua0\ua0\ua0", context))
      else
         put(row.input, TextCmd(u"\u2022\ua0\ua0\ua0", context))
      lc.tbl.content.add(row)
      row := TextFlow(self) .set_constraint("eol", &yes)
      lc.tbl.content.add(row)
      traverse(e, row, context)
   end

   private traverse_dl(e, p, context)
      local tbl, dc, c
      tbl := Tbl()
      tbl.content.layout_delegate.set_fix_col1(&yes).set_align_baselines(&yes)
      dc := DefListContext()
      dc.tbl := tbl
      c := copy(context)
      c.def_list := dc
      traverse(e, p, c)
      put_new_row(p, c)
      add_component(p, tbl, context, Align.B)
      put_new_row(p, c)
   end

   private traverse_dt(e, p, context)
      local dc, row
      dc := \context.def_list | fail
      row := TextFlow(self) .set_constraint("eol", &yes).set_constraint("w", 2)
      dc.tbl.content.add(row)
      traverse(e, row, context)
   end

   private traverse_dd(e, p, context)
      local dc, row
      dc := \context.def_list | fail
      row := TextFlow(self) .set_constraint("eol", &no)
      put(row.input, TextCmd(u"\u2022\ua0\ua0\ua0", context))
      dc.tbl.content.add(row)
      row := TextFlow(self) .set_constraint("eol", &yes)
      dc.tbl.content.add(row)
      traverse(e, row, context)
   end

   private traverse_blockquote(e, p, context)
      local tbl, row
      put_new_row(p, context)
      tbl := Tbl()
      add_component(p, tbl, context)
      row := TextFlow(self)
      put(row.input, TextCmd(u"\ua0\ua0\ua0\ua0", context))
      tbl.content.add(row)
      row := TextFlow(self) .set_constraint("eol", &yes)
      tbl.content.add(row)
      traverse(e, row, context)
      put_new_row(p, context)
   end

   private traverse_fieldset(e, p, context)
      local tbl, row, c, fc
      put_new_row(p, context)
      tbl := Tbl().set_border(CompoundBorder().
                              set_outer(SunkenBorder().set_line_width(1)).
                              set_inner(EmptyBorder()))
      add_component(p, tbl, context)
      row := TextFlow(self)
      tbl.content.add(row)
      fc := FieldSetContext()
      c := copy(context)
      c.fieldset := fc
      traverse(e, row, c)
      tbl.set_title(\fc.legend)
      put_new_row(p, context)
   end

   private traverse_legend(e, p, context)
      local fc
      fc := \context.fieldset | fail
      /fc.legend | fail
      fc.legend := TextFlow(self).
         set_dominant_width(TextFlow.MAX_WIDTH)
      traverse(e, fc.legend, context)
   end

   private traverse_map(e, p, context)
      local c, mc
      mc := MapContext()
      mc.map := ipl.browser.Map()
      c := copy(context)
      c.map := mc
      traverse(e, p, c)
      insert(maps, map(string(e.get_attribute(u"NAME"))), mc.map)
   end

   private traverse_area(e, p, context)
      local mc, s, coords
      mc := \context.map | fail
      if s := e.get_attribute(u"COORDS") then {
         coords := []
         every put(coords, integer(separate(s)))
         mc.map.add_area(MapArea(map(string(e.get_attribute(u"SHAPE"))), 
                                 coords,
                                 mk_link(context, e.get_attribute(u"HREF"))))
      }
   end

   private traverse_text(e, p, context)
      put(p.input, TextCmd(e, context))
   end

   private traverse_title(e, p, context)
      page_title := e.get_trimmed_string_content()
   end

   private traverse(n, p, context)
      local e, id
      every e := !n.children do {
         if text(e) then
            traverse_text(e, p, context)
         else if is(e, HtmlElement) then {
            if id := e.get_attribute(u"ID") then
               put(p.input, NamedAnchorCmd(id, context))
            case string(e.name) of {
               "META"|"LINK"|"SCRIPT"|"STYLE": {}
               "TITLE": traverse_title(e, p, context)
               "A": traverse_a(e, p, context)
               "FORM": traverse_form(e, p, context)
               "BUTTON": traverse_button(e, p, context)
               "LABEL": traverse_label(e, p, context)
               "FONT": traverse_font(e, p, context)
               "IMG": traverse_img(e, p, context)
               "SELECT": traverse_select(e, p, context)
               "OPTION": traverse_option(e, p, context)
               "OPTGROUP": traverse_optgroup(e, p, context)
               "TEXTAREA": traverse_textarea(e, p, context)
               "INPUT": traverse_input(e, p, context)
               "DIV": traverse_div(e, p, context)
               "BIG": traverse_big(e, p, context)
               "SMALL": traverse_small(e, p, context)
               "SAMP"|"KBD"|"CODE"|"TT": traverse_tt(e, p, context)
               "DFN"|"B": traverse_b(e, p, context)
               "EM"|"CITE"|"I": traverse_i(e, p, context)
               "ADDRESS": traverse_address(e, p, context)
               "BR": traverse_br(e, p, context)
               "HR": traverse_hr(e, p, context)
               "CENTER": traverse_center(e, p, context)
               "H" || (1 to 6): traverse_hN(e, p, context)
               "TABLE": traverse_table(e, p, context)
               "CAPTION": traverse_caption(e, p, context)
               "COLGROUP": traverse_colgroup(e, p, context)
               "COL": traverse_col(e, p, context)
               "TR": traverse_tr(e, p, context)
               "TD"|"TH": traverse_td(e, p, context)
               "DIR"|"MENU"|"OL"|"UL": traverse_list(e, p, context)
               "LI": traverse_li(e, p, context)
               "DL": traverse_dl(e, p, context)
               "DT": traverse_dt(e, p, context)
               "DD": traverse_dd(e, p, context)
               "BLOCKQUOTE": traverse_blockquote(e, p, context)
               "P": traverse_p(e, p, context)
               "Q": traverse_q(e, p, context)
               "INS"|"U": traverse_u(e, p, context)
               "DEL"|"STRIKE"|"S": traverse_s(e, p, context)
               "SUP": traverse_sup(e, p, context)
               "SUB": traverse_sub(e, p, context)
               "LISTING"|"PRE": traverse_pre(e, p, context)
               "FIELDSET": traverse_fieldset(e, p, context)
               "LEGEND": traverse_legend(e, p, context)
               "MAP": traverse_map(e, p, context)
               "AREA": traverse_area(e, p, context)
               default : traverse(e, p, context)
            }
         }
      }
   end

   public set_worker_pool(worker_pool)
      self.worker_pool := worker_pool
      self.shared_worker_pool_flag := 1
      return self
   end

   public set_shared_worker_pool(s)
      self.shared_worker_pool_flag := check_flag(s)
      return self
   end

   public goto(url, referer, kind, form_data)
      /kind := Worker.NORMAL
      cancel()
      start_worker(Req(self, url, referer, set_top_data, kind, form_data))
      return self
   end

   public new()
      cast(self,Component).new()
      worker_pool := WorkerPool().
         set_authentication_function(get_authentication)
      status_ticker := Dispatcher.new_task{status()}
      top_panel := ComponentScrollArea().
         set_inner(Component().set_size(10,10)).
         use_default_keys()
      set_layout(GridLayout().set_doi(0))
      add(top_panel)
      history := []
      history_pos := 0
      running := 0
      return
   end
end
