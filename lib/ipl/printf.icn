############################################################################
#
#       File:     printf.icn
#
#       Subject:  Procedures for printf-style formatting
#
#       Author:   William H. Mitchell
#
#       Date:     July 20, 2005
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#       Contributors:   Cheyenne Wills, Phillip Lee Thomas, Michael Glass
#
############################################################################

package ipl.printf

import
   io(stop, ewrites, writes, Files),
   util(Format),
   lang(to_string)

# See `printf`
procedure sprintf(format, args[])
   return doprnt(format, args)
end

# See `printf`
procedure fprintf(file, format, args[])
   return writes(file, doprnt(format, args))
end

# Like `printf`, but outputs to stderr.
procedure eprintf(format, args[])
   return ewrites(doprnt(format, args))
end

# Set `&why` from a `printf` format, and fail.
procedure whyf(format, args[])
   &why := doprnt(format, args)
end

# Call `stop()` with the result of a `printf` format.
procedure stopf(format, args[])
   stop(doprnt(format, args))
end

# Like `printf`, but the arguments are provided as a list.
procedure lprintf(format, args)
   return doprnt(format, copy(args))
end

# Provides C-style printf formatting.  The specifier format is
# ~
#     %<flags><width>.<precision><char>
# ~
#  <flags> can be :-
#  *   0 - pad fields with zeroes instead of spaces; this may
#          not give sensible results with some numerical formats,
#          eg signed numbers or left adjusted numbers.
#  *   ' - for formats d, r, e, use commas to separate thousands
#  *   - - left adjust fields instead of right adjust
#  *   S - for formats r, e, replace trailing fractional zeroes
#          with spaces
#  *   Z - for formats r, e, means drop trailing fractional
#          zeroes altogether
#  *   + - for numeric formats, add a leading + to positive
#          numbers
#
# The optional width specifies the field width.  It may be "*", in
# which case an argument is consumed to give the width.
#
# The optional precision (which may also be a "*") means :-
# *  for string formats (s, i, t) the maximum string length;
# *  for integer formats (d, x, X, o, b), the minimum number of
#    digits; leading zeroes are added if needed.
# *  for real formats (r, e), the number of digits in the
#    fractional part.
#
# The formats are :-
# *   %d  decimal number
# *   %s  string
# *   %x  hex lower case
# *   %X  hex upper case
# *   %o  octal
# *   %b  binary
# *   %i  image() result
# *   %t  to_string() result
# *   %r  real decimal
# *   %e  real in exponential format
# *   %n  platform-independent end-of-line string
# *   %w  the value of &why
#
procedure printf(format, args[])
   return writes(doprnt(format, args))
end

package procedure intparam(args)
   local a
   return if ="*" then {
      a := get(args)
      integer(a) | runerr(101, a)
   } else
      integer(tab(many(&digits)))
end

package procedure one(args)  
   local v, a, just, width, conv, prec, pad, flag
   move(1)     # Move over %
   flag := cset(tab(many('0\'\-+SZ'))) | ''
   # Convert flags to those used by Format.numeric_to_string
   if any(flag, "'") then flag ++:= ','
   if any(flag, "S") then flag ++:= 's'
   if any(flag, "Z") then flag ++:= 'z'
   just := if any(flag, "-") then left else right
   if any(flag, "0") then pad := "0"
   width := intparam(args)
   if ="." then prec := intparam(args)
   conv := move(1) | ""

   if any('dsxXobitre', conv) then {
      # Formats that take an argument.
      a := get(args)
      case string(conv) of {
         "d": v := decimal(a, prec, flag)
         "s": v := str(a, prec)
         "x": v := map(intstr(a, prec, flag))
         "X": v := intstr(a, prec, flag)
         "o": v := intstr(a, prec, flag, 8)
         "b": v := intstr(a, prec, flag, 2)
         "i": v := str(image(a), prec)
         "t": v := str(to_string(a), prec)
         "r": v := fixnum(a, prec, flag)
         "e": v := eformatstr(a, prec, flag)
      }
   } else {
      # Formats that don't take an argument.
      case string(conv) of {
         "n": v := str(Files.EOL, prec)
         "w": v := str(&why, prec)
         default: v := str(conv, prec)
      }
   }
   if \width & *v < width then
      v := just(v, width, pad)
   return v
end

package procedure doprnt(format, args)
   local out
   out := ""
   format ? repeat {
      out ||:= tab(upto('%') | 0)
      if pos(0) then
         break
      out ||:= one(args)
   }
   return out
end

package procedure str(x, prec)
   x := text(x) | runerr(129, x)
   return x[1:(\prec+1)|0]
end

package procedure intstr(x, prec, flag, base)
   local v
   x := integer(x) | runerr(101, x)
   v := Format.int_to_string(x, base, prec)
   if any(flag, "+") & x >= 0 then
      v := "+" || v
   return v
end

package procedure fixnum(x, prec, flag)
   /prec := 6
   x := real(x) | runerr(102, x)
   return Format.numeric_to_string(x, prec, flag)
end

package procedure decimal(x, prec, flag)
   x := integer(x) | runerr(101, x)
   # Limitation: if we have a precision (padded to min prec digits),
   # then we can't have commas.
   return if \prec then
      intstr(x, prec, flag, 10)
   else
      Format.numeric_to_string(x, 0, flag)
end

# e-format:  [-]m.ddddddE(+|-)xxx
#
package procedure eformatstr(x, prec, flag)
   /prec := 6
   x := real(x) | runerr(102, x)
   return Format.numeric_to_string(x, prec, flag ++ 'e')
end
