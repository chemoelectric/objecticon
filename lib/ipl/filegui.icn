package ipl.filegui

import
   ipl.sort,
   ipl.strings,
   ipl.wildcard,
   gui,
   io,
   xdg,
   util

class ListEntryWithIcon(ListEntry)
   package readable
      icon
end

class ColorFilesItemPaint(WithCloneItemPaint)
   protected make_clone(W)
      return W.clone()
   end

   public get_color(data)
      local st
      st := data.lstat
      return case st.mode_str[1] of {
         "d" : "purple"
         "l" : "cyan"
         "p" : "orange"
         "s" : "dark gray"
         "b" : "gray"
         "c" : "gray"
         default : {
            if st.mode_str[-7] == ("x" | "s") then
               "green"
            else case map(string(Files.get_extension(data.name))) of {
               "cmd"|"exe"|"com"|"btm"|"bat" : "green"
               "tar"|"tgz"|"arj"|"taz"|"lzh"|"zip"|"z"|"Z"|"gz"|"xz"|"bz2"|"rar" : "red"
               "jpg"|"jpeg"|"png"|"gif"|"bmp"|"xbm"|"xpm": "blue"
               "mp4"|"flv"|"avi"|"wmv"|"webm"|"3gp"|"mpeg"|"mpg"|"m4v"|"mkv": "pink" 
            }
         }
      } | "black"
   end

   public get_string(data)
      return data.name
   end

   public get_width(W, data)
      return W.text_width(get_string(data))
   end

   public get_constant_height(W)
      return W.get_font_height()
   end

   public get_size(W, data)
      return Size(get_width(W, data), W.get_font_height())
   end

   public draw(W, data, x, y)
      W := get_clone(W).set_fg(get_color(data))
      draw_string_ex(W, x, y, get_string(data))
   end
end

$load PDF_16 "fileicons/pdf.png"
$load IMAGE_16 "fileicons/image.png"
$load VIDEO_16 "fileicons/video.png"
$load ARCHIVE_16 "fileicons/archive.png"
$load AUDIO_16 "fileicons/audio.png"
$load EXE_16 "fileicons/exe.png"
$load CHARDEVICE_16 "fileicons/chardevice.png"
$load BLOCKDEVICE_16 "fileicons/blockdevice.png"
$load SYMLINK_16 "fileicons/symlink.png"
$load SOCKET_16 "fileicons/socket.png"
$load PIPE_16 "fileicons/pipe.png"
$load HTML_16 "fileicons/html.png"

class IconFilesItemPaint(ItemPaint)
   public static const ICON_SIZE

   private static init()
      ICON_SIZE := 16
      ImageCache.
         name_image("fi.PDF_16", PDF_16).
         name_image("fi.IMAGE_16", IMAGE_16).
         name_image("fi.VIDEO_16", VIDEO_16).
         name_image("fi.ARCHIVE_16", ARCHIVE_16).
         name_image("fi.AUDIO_16", AUDIO_16).
         name_image("fi.EXE_16", EXE_16).
         name_image("fi.CHARDEVICE_16", CHARDEVICE_16).
         name_image("fi.BLOCKDEVICE_16", BLOCKDEVICE_16).
         name_image("fi.SYMLINK_16", SYMLINK_16).
         name_image("fi.SOCKET_16", SOCKET_16).
         name_image("fi.PIPE_16", PIPE_16).
         name_image("fi.HTML_16", HTML_16)

      try_xdg("fi.folder", "folder", "gui.CLOSED_FOLDER")
      try_xdg("fi.symlink", "emblem-symbolic-link", "fi.SYMLINK_16")
      try_xdg("fi.exe", "application-x-executable", "fi.EXE_16")
   end

   private static try_xdg(key, icon, alt)
      ImageCache.copy_key(key, Xdg.find_icon_and_cache(icon, ICON_SIZE) | ImageCache.get_key(alt))
   end

   public get_width(W, data)
      return ICON_SIZE + Gui.TEXT_INSET + W.text_width(get_string(data))
   end

   public get_constant_height(W)
      return max(W.get_font_height(), ICON_SIZE)
   end

   public get_size(W, data)
      return Size(get_width(W, data), get_constant_height(W))
   end

   public get_string(data)
      return data.name
   end

$ifdef _PNG
   public get_xdg_for_file(f)
      local k, w
      k := Xdg.find_icon_for_file_and_cache(f, ICON_SIZE) | Xdg.find_icon_and_cache("text-x-generic", ICON_SIZE) | fail
      w := ImageCache.get(k)
      if w.get_width() > ICON_SIZE then
         k := ImageCache.get_key_with_resize(k, ICON_SIZE, ICON_SIZE)
      return k
   end

   public get_icon(data)
      local st, k
      st := data.lstat
      k := case st.mode_str[1] of {
         "d" : "fi.folder"
         "l" : "fi.symlink"
         "s" : "fi.SOCKET_16"
         "p" : "fi.PIPE_16"
         "b" : "fi.BLOCKDEVICE_16"
         "c" : "fi.CHARDEVICE_16"
         default : {
            if st.mode_str[-7] == ("x" | "s") then
               "fi.exe"
            else {
                get_xdg_for_file(data.name) | case map(string(Files.get_extension(data.name))) of {
                  "pdf": "fi.PDF_16"
                  "cmd"|"exe"|"com"|"btm"|"bat" : "fi.EXE_16"
                  "tar"|"tgz"|"arj"|"taz"|"lzh"|"zip"|"z"|"Z"|"gz"|"xz"|"bz2"|"rar" : "fi.ARCHIVE_16"
                  "jpg"|"jpeg"|"png"|"gif"|"bmp"|"xbm"|"xpm": "fi.IMAGE_16"
                  "mp4"|"flv"|"avi"|"wmv"|"webm"|"3gp"|"mpeg"|"mpg"|"m4v"|"mkv": "fi.VIDEO_16"
                  "mp3"|"wav"|"mid"|"rm": "fi.AUDIO_16"
                  "htm"|"html": "fi.HTML_16"
               }
            }
         }
      } | "gui.FILE"
      return ImageCache.get(k) | syserr("Bad cache key in IconFilesItemPaint")
   end
$else
   public get_icon(data)
      local k
      k := if data.stat.mode_str[1] == "d" then
         "gui.CLOSED_FOLDER"
      else
         "gui.FILE"
      return ImageCache.get(k) | syserr("Bad cache key in IconFilesItemPaint")
   end
$endif

   public draw(W, data, x, y, w, h)
      local i
      if not(i := \data.icon) then
         i := data.icon := get_icon(data)
      i.copy_to(,,,, W, x, y + (h - ICON_SIZE) / 2)
      x +:= ICON_SIZE + Gui.TEXT_INSET
      w -:= ICON_SIZE + Gui.TEXT_INSET
      draw_string_ex(W, x, y, limit_text(W, get_string(data), w))
   end
end

class FileSuggestField(SuggestField)
   public
      cwd,
      matches,
      prefix,
      dir_list,
      dir_list_name,
      directories_only_flag,
      pats

   public set_directories_only(s)
      self.directories_only_flag := check_flag(s)
      return self
   end

   public set_cwd(d)
      self.cwd := d
      return self
   end

   public set_filter(f)
      local pat
      pats := []
      f ? repeat {
         pat := tab(upto(';') | 0)
         put(pats, Wildcard(pat))
         move(1) | break
      }
      return self
   end

   private match_entry(e)
      local n
      n := e.name
      if e.stat.mode_str[1] == "d" then {
         if not Files.is_relative_dir(n) then
            return
      } else {
         if /directories_only_flag & (/pats | (!pats).match(n) = *n + 1) then
            return
      }
   end

   private do_dir_list(s)
      if dir_list_name === s then
         return dir_list
      dir_list := Files.ucs_list(s, ListEntryWithIcon) | fail
      dir_list := isort(dir_list, Files.name_key)
      dir_list_name := s
      return dir_list
   end

   #
   # Calculate the matches list and prefix string from the current
   # contents.  A new contents can then be calculated by simply
   # appending the prefix to the name of a member of the matches list.
   #
   private calc_matches()
      local path, s, t
      path := FilePath(contents)
      if not path.is_absolute() then
         path := FilePath(cwd).append(path)
      matches := []
      if *contents = 0 | contents[-1] == Files.PATH_SEPARATOR then {
         do_dir_list(path.str()) | fail
         every t := !dir_list do {
            if match_entry(t) then
               put(matches, t)
         }
         prefix := contents
      } else {
         do_dir_list(path.parent().str()) | fail
         s := path.get(-1)
         every t := !dir_list do {
            if match_entry(t) & match(s, t.name) then
               put(matches, t)
         }
         prefix := contents[1:-*s]
      }
      return
   end

   protected do_request()
      calc_matches() | fail
      # No point in a list which is a copy of what we already have
      if *matches = 1 & endswith(contents, matches[1].name) then
         return []
      return matches
   end

   public convert_element(o)
      if /directories_only_flag & o.stat.mode_str[1] == "d" then
         return prefix || text(o.name) || Files.PATH_SEPARATOR
      else
         return prefix || text(o.name)
   end

   public create_popup()
      return ItemPaintList().
         set_item_paint(IconFilesItemPaint()).
         set_item_border(EmptyBorder().
                            set_insets(Gui.TEXT_INSET, Gui.TEXT_INSET, 0, 0).
                            set_x_align(Align.L))
   end

   #
   # Get the longest common initial name from the matches list.  Eg if
   # we have ["mark", "mary", "marion"], we get "mar".
   #
   private get_longest_prefix()
      local i, s, t, e
      i := 1
      t := u""
      repeat {
         s := matches[1].name[1+:i] | break
         every e := !matches do
            e.name[1+:i] == s | break break
         t := s
         i +:= 1
      }
      return t
   end

   public handle_tab(e)
      local t
      if \tl then {
         # Calculate the string we could insert.  If not
         # directories-only, and we have a single directory, append
         # a /.  So for example
         # "/ho" + tab -> "/home/" rather than "/home"
         t := prefix || if /directories_only_flag & *matches = 1 & matches[1].stat.mode_str[1] == "d" then
            matches[1].name || Files.PATH_SEPARATOR
         else
            get_longest_prefix()

         # If the calculated string is longer than what we have,
         # insert it.  Otherwise, if we have selected from the list
         # then trigger a change to refresh the list.  If in
         # directories only mode, append a "/"; this will show the
         # next dir.  So for example "/ho", press tab, choose "/home",
         # press tab again to set to "/home/" and show its contents.

         if *contents < *t then
            assign_contents(t, e)
         else if *tl.get_selections() = 1 then {
            if /directories_only_flag then
               on_change(e)
            else
               assign_contents(contents || Files.PATH_SEPARATOR, e)
         }
      } else {
         # As above, calculate the string we could insert.
         calc_matches() | fail
         t := prefix || if /directories_only_flag & *matches = 1 & matches[1].stat.mode_str[1] == "d" then
            matches[1].name || Files.PATH_SEPARATOR
         else
            get_longest_prefix()

         #write("px=",image(px),  " contents=",image(contents)," t=",image(t),  " tl=",to_string(ipl.pdco.List{(!l).name}))

         # Again as above, insert the string if it's longer.
         # Otherwise trigger a change.  The only special case is if we
         # are in directories mode and press tab whilst contents is an
         # unambiguous directory; in this case append a /, which will
         # show its contents.  Eg "/home" + tab -> set to "/home/" and
         # list contents.
         if *contents < *t then
            assign_contents(t, e)
         else if *contents = *t & \directories_only_flag & *matches = 1 & matches[1].stat.mode_str[1] == "d" then
            assign_contents(t || Files.PATH_SEPARATOR, e)
         else
            on_change(e)
      }
   end

   public keeps(e)
      return
   end

   public handle_key(e)
      if e.code == "\t" then
         handle_tab(e)
      else
         cast(self,SuggestField).handle_key(e)
   end

   public new()
      cast(self,SuggestField).new()
      self.set_contents(u"")
      cwd := Files.getcwd()
      set_direction(Direction.DOWN)
      return
   end
end
