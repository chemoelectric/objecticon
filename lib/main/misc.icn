package util

import lang(Class)

#
# Succeed iff the sequence generated by {&features} contains the given
# string.
#
procedure has_feature(x)
   static s
   initial {
      s := set()
      every insert(s, &features)
   }
   return member(s, x)
end

#
# Convenient procedure to set {&why} to the given string and fail.
#
procedure error(s)
   &why := s
end

# This class just provides a simple constructor which initializes the
# instance fields in the order they were defined in the class, from
# the given parameters.  In other words, rather like a record
# constructor.  The fields in the subclass must of course be
# accessible to this class's constructor.
#
# @example
# @  class Abc(SimpleConstructor) public const a, b, c end
# @  ...
# @  x := Abc(1,2,3)  # Sets a,b,c to 1,2,3 respectively
#  
class SimpleConstructor()
   public new(a[])
      every Class.get(self, 1 to Class.get_n_instance_fields(self)) := pop(a)
      return
   end
end

# Invoke co-expression e, saving the value of {&handler} before,
# and restoring it afterwards.  This is potentially useful when using
# co-operating scheduled tasks (see {io.Task}), which switch from
# within a try block.
#
procedure save_handler(e)
   local sh, v
   sh := &handler
   if v := @e then {
      &handler := sh
      return v
   } else {
      &handler := sh
      fail
   }
end

# Like {save_handler}, but saves the value of {&why}
# instead.
#
procedure save_why(e)
   local sw, v
   sw := &why
   if v := @e then {
      &why := sw
      return v
   } else {
      &why := sw
      fail
   }
end


# Invoke co-expression e, saving the scanning environment first, and
# restoring it afterwards.  This is potentially useful when using
# co-operating scheduled tasks (see {io.Task}), which switch from
# within a scanning expression.
#
procedure save_scan(e)
   local ss, sp, v
   ss := &subject
   sp := &pos
   if v := @e then {
      &subject := ss
      &pos := sp
      return v
   } else {
      &subject := ss
      &pos := sp
      fail
   }
end
