/*
 * File: rxwin.ri - X11 system-specific graphics interface code.
 */

#ifdef Graphics

#define RootState IconicState+1
#define CONVERT_ANGLE(ang) (-(ang) * 180 / Pi * 64)

/*
 * Global variables specific to X
 */
wdp wdsplys;

/*
 * function prototypes
 */
static wcp alccontext(wbp w);
static wsp alcwinstate(void);
static void handle_misc(wdp display);
static void handle_config(wbp w, XConfigureEvent *event);
static void handle_exposures(wbp w, XExposeEvent *event);
static void handle_mouse(wbp w, XButtonEvent *event);
static void handle_keypress(wbp w, XKeyEvent *event);
static void wmap(wbp w);
static int convert_KeySym_to_code_point(KeySym k);
static char *convertspec(wdp wd, char *s);
#ifdef HAVE_LIBXFT
int xft_stringwidth(wbp w, char *s, int n);
#else
static char *findfont(wdp wd, char *fam, int size, int flags);
static int okfont(char *spec, int flags);
static int fontcmp(char *font1, char *font2, int size, int flags);
static int fieldcmp(char *font1, char *font2, char *value, int field);
static char *xlfd_field(char *s, int i);
static int xlfd_size(char *s, int n);
#endif
static wfp newfont(wdp wd, char *s);
static wdp alcdisplay (char *s);
static wfp loadfont(wdp wd, char *s);
static void resizePixmap(wbp w, int width, int height);
static void setclip(wbp w);
static void unsetclip(wbp w);

static stringint fillstyles[] = {
    {0, 3},
    {"masked", FillStippled },
    {"solid", FillSolid },
    {"textured", FillOpaqueStippled },
};

static stringint drawops[] = {
   { 0, 16},
   {"and",		GXand},
   {"andInverted",	GXandInverted},
   {"andReverse",	GXandReverse},
   {"clear",		GXclear},
   {"copy",		GXcopy},
   {"copyInverted",	GXcopyInverted},
   {"equiv",		GXequiv},
   {"invert",		GXinvert},
   {"nand",		GXnand},
   {"noop",		GXnoop},
   {"nor",		GXnor},
   {"or",		GXor},
   {"orInverted",	GXorInverted},
   {"orReverse",	GXorReverse},
   {"set",		GXset},
   {"xor",		GXxor},
};

static stringint linestyles[] = {
    {0, 5},
    {"dashed",      LineOnOffDash},
    {"doubledash",  LineDoubleDash},
    {"onoff",       LineOnOffDash},
    {"solid",       LineSolid},
    {"striped",     LineDoubleDash},
};

static stringint canvastypes[] = {
    {0, 6},
    {"hidden",      HiddenState},
    {"iconic",      IconicState},
    {"maximized",   MaximizedState},
    {"normal",      NormalState},
    {"popup",       PopupState},
    {"root",        RootState},
};

static stringint cursors[] = {
  { 0, NUMCURSORSYMS},
  {"X cursor",		XC_X_cursor},
  {"arrow",		XC_arrow},
  {"based arrow down",	XC_based_arrow_down},
  {"based arrow up",	XC_based_arrow_up},
  {"boat",		XC_boat},
  {"bogosity",		XC_bogosity},
  {"bottom left corner",XC_bottom_left_corner},
  {"bottom right corner",XC_bottom_right_corner},
  {"bottom side",	XC_bottom_side},
  {"bottom tee",	XC_bottom_tee},
  {"box spiral",	XC_box_spiral},
  {"center ptr",	XC_center_ptr},
  {"circle",		XC_circle},
  {"clock",		XC_clock},
  {"coffee mug",	XC_coffee_mug},
  {"cross",		XC_cross},
  {"cross reverse",	XC_cross_reverse},
  {"crosshair",		XC_crosshair},
  {"diamond cross",	XC_diamond_cross},
  {"dot",		XC_dot},
  {"dotbox",		XC_dotbox},
  {"double arrow",	XC_double_arrow},
  {"draft large",	XC_draft_large},
  {"draft small",	XC_draft_small},
  {"draped box",	XC_draped_box},
  {"exchange",		XC_exchange},
  {"fleur",		XC_fleur},
  {"gobbler",		XC_gobbler},
  {"gumby",		XC_gumby},
  {"hand1",		XC_hand1},
  {"hand2",		XC_hand2},
  {"heart",		XC_heart},
  {"icon",		XC_icon},
  {"iron cross",	XC_iron_cross},
  {"left ptr",		XC_left_ptr},
  {"left side",		XC_left_side},
  {"left tee",		XC_left_tee},
  {"leftbutton",	XC_leftbutton},
  {"ll angle",		XC_ll_angle},
  {"lr angle",		XC_lr_angle},
  {"man",		XC_man},
  {"middlebutton",	XC_middlebutton},
  {"mouse",		XC_mouse},
  {"pencil",		XC_pencil},
  {"pirate",		XC_pirate},
  {"plus",		XC_plus},
  {"question arrow",	XC_question_arrow},
  {"right ptr",		XC_right_ptr},
  {"right side",	XC_right_side},
  {"right tee",		XC_right_tee},
  {"rightbutton",	XC_rightbutton},
  {"rtl logo",		XC_rtl_logo},
  {"sailboat",		XC_sailboat},
  {"sb down arrow",	XC_sb_down_arrow},
  {"sb h double arrow",	XC_sb_h_double_arrow},
  {"sb left arrow",	XC_sb_left_arrow},
  {"sb right arrow",	XC_sb_right_arrow},
  {"sb up arrow",	XC_sb_up_arrow},
  {"sb v double arrow",	XC_sb_v_double_arrow},
  {"shuttle",		XC_shuttle},
  {"sizing",		XC_sizing},
  {"spider",		XC_spider},
  {"spraycan",		XC_spraycan},
  {"star",		XC_star},
  {"target",		XC_target},
  {"tcross",		XC_tcross},
  {"top left arrow",	XC_top_left_arrow},
  {"top left corner",	XC_top_left_corner},
  {"top right corner",	XC_top_right_corner},
  {"top side",		XC_top_side},
  {"top tee",		XC_top_tee},
  {"trek",		XC_trek},
  {"ul angle",		XC_ul_angle},
  {"umbrella",		XC_umbrella},
  {"ur angle",		XC_ur_angle},
  {"watch",		XC_watch},
  {"xterm",		XC_xterm},
  {"num glyphs",	XC_num_glyphs},
};


static int selection_debug = 0;

static struct SharedColor *new_sharedcolor(char *name, int r, int g, int b)
{
    struct SharedColor *res;
    GRFX_ALLOC(res, SharedColor);
    res->r = r;
    res->g = g;
    res->b = b;
    res->c = ((r/256)<<16) | ((g/256)<<8) | (b/256);
    res->name = salloc(name);
    return res;
}

static struct SharedColor *link_sharedcolor(struct SharedColor *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedcolor(struct SharedColor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        free(x->name);
        free(x);
    }
}

static char *atom_fmt(wsp ws,Atom a) {
    static int n = 0;
    static char buff[8][96];
    char *s, *r;
    r = buff[n];
    if (a == None)
        return "None(0)";

    s = XGetAtomName(ws->display->display, a);
    if (s) {
        sprintf(r, "%.64s(%ld)", s, (long)a);
        XFree(s);
    } else {
        sprintf(r, "?unknown atom(%ld)", (long)a);
    }

    n = (n + 1) % 8;
    return r;
}

/*
 * Get the string name of the given Atom into dest.  The string is
 * allocated in the string region.
 */
void get_atom_descriptor(wsp ws, Atom a, dptr dest)
{
    char *s = XGetAtomName(ws->display->display, a);
    cstr2string(s, dest);
    XFree(s);
}

Atom ConvertTarget(Display* display, Atom desired_target)
{
    /* Check for common cases. */
    if ( (desired_target == XInternAtom(display, "TIMESTAMP", False))    ||
         (desired_target == XInternAtom(display, "LIST_LENGTH", False) ) ||
         (desired_target == XInternAtom(display, "LENGTH", False) ) ) {
        return XA_INTEGER;
    }

    if ( desired_target == XInternAtom(display, "CHARACTER_POSITION", False) ) {
        return XInternAtom(display, "SPAN", False);
    }

    if ( desired_target == XInternAtom(display, "TARGETS", False) ) {
        return XA_ATOM;
    }

    if ( desired_target == XInternAtom(display, "CLIENT_WINDOW", False) ) {
        return XA_WINDOW;
    }

    if (( desired_target == XInternAtom(display, "HOST_NAME", False) ) ||
        ( desired_target == XInternAtom(display, "HOSTNAME", False) ) ||
        ( desired_target == XInternAtom(display, "NAME", False) ) ||
        ( desired_target == XInternAtom(display, "OWNER_OS", False) ) ||
        ( desired_target == XInternAtom(display, "USER", False) ) ) {
        return XA_STRING;
    }
    /* Otherwise, no need to convert target. */
    return desired_target;
}

char* PropertyToString(Display* display, Atom target, int number_items,
                       void* data)
{
    Atom            new_target;
    Atom            timestamp, span;
    unsigned long*  long_array;
    int*            int_array;
    char*           string0 = NULL;
    int             i, length;
    char            temp[100];
    char*           atom_name;

    /* Convert our atoms. */
    timestamp = XInternAtom(display, "TIMESTAMP", False);
    span      = XInternAtom(display, "SPAN", False);

    /* Convert target, if necessary. */
    new_target = ConvertTarget(display, target);

    if (new_target == XA_ATOM) {

        long_array = (unsigned long*) data;

        length = number_items * 30;
        MemProtect(string0 = malloc( length + 1 ));
        string0[0] = '\0';

        /* Convert to atom names. */
        for (i = 0; i < number_items; i++) {
            atom_name = XGetAtomName(display, long_array[i] );

            if (atom_name != NULL) {

                /* Check that space is available. */
                length -= strlen(atom_name);
 
                if (length > 1) {
                    strcat(string0, atom_name);
                    strcat(string0, "\n");
                }
                XFree(atom_name);
            }
        }
    }
    else if (new_target == XA_STRING) {
        MemProtect(string0 = malloc(number_items + 1));
        strcpy(string0, (char *)data);
    }
    else if ((new_target == XA_INTEGER) ||
             (new_target == span) ||
             (new_target == timestamp) ) {

        int_array = (int*) data;

        length = number_items * 20;
        MemProtect(string0 = malloc( length + 1 ));
        string0[0] = '\0';

        for (i = 0; i < number_items; i++) {
            sprintf(temp, "%d ", int_array[i]);

            /* Check that space is available. */
            length -= strlen(temp);
            if (length > 0) {
                strcat(string0, temp);
            }
        }
    }
    else if (new_target == XA_WINDOW) {

        long_array = (unsigned long*) data;

        length = number_items * 12;
        MemProtect(string0 = malloc( length + 1 ));
        string0[0] = '\0';

        for (i = 0; i < number_items; i++) {
            sprintf(temp, "0x%8.8lu ", long_array[i]);
            strcat(string0, temp);
        }

    }
    else {
        /* Add extra cases as necessary... */
    }

    return string0;

}

/*
 * handle_misc processes pending events on display.
 * if w is non-null, block until a returnable event arrives.
 * returns 1 on success, 0 on failure.
 */
static void handle_misc(wdp wd)
{
    XEvent event;
    Window evwin;
    wbp wb;
    wsp ws = 0;

    while (XPending(wd->display)) {

        XNextEvent(wd->display, &event);
        evwin = event.xexpose.window;  /* go ahead, criticize all you like */

/* could avoid doing this search every event by handling 1 window at a time */
        for (wb = wbndngs; wb; wb=wb->next) {
            ws = wb->window;
            if (ws->display == wd) {
                if (ws->win == evwin) break;
                if (ws->pix == evwin) break;
	    }
        }
        if (!wb) continue;

        switch (event.type) {
            case SelectionRequest: {
                tended struct descrip tmp;
                if (selection_debug)
                    printf("SelectionRequest event:\n\towner=%lx requestor=%lx "
                           "property=%s target=%s selection=%s\n",
                           (long)event.xselectionrequest.owner,
                           (long)event.xselectionrequest.requestor,
                           atom_fmt(ws, event.xselectionrequest.property),
                           atom_fmt(ws, event.xselectionrequest.target),
                           atom_fmt(ws, event.xselectionrequest.selection)
                        );

                MakeInt(SELECTIONREQUEST, &tmp);
                list_put(&ws->listp, &tmp);
                MakeInt((word)event.xselectionrequest.requestor, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselectionrequest.property, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselectionrequest.selection, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselectionrequest.target, &tmp);
                list_put(&ws->listp, &tmp);
                MakeInt(event.xselectionrequest.time, &tmp);
                list_put(&ws->listp, &tmp);
                break;
            }

            case SelectionClear: {
                tended struct descrip tmp;
                if (selection_debug)
                    printf("SelectionClear event win=%lx selection=%s\n",
                           (long)event.xselectionclear.window,
                           atom_fmt(ws, event.xselectionclear.selection));
                MakeInt(SELECTIONCLEAR, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselectionclear.selection, &tmp);
                list_put(&ws->listp, &tmp);
                break;
            }

            case SelectionNotify: {
                Atom actual_type, property;
                int actual_format;
                unsigned long bytes_after, nitems;
                unsigned char *prop;
                word bytes_read;
                tended struct descrip tmp;
                int status;
                char *conv_str;

                if (selection_debug)
                    printf("SelectionNotify: requestor=%lx selection=%s target=%s property=%s\n",
                           (long)event.xselection.requestor,
                           atom_fmt(ws, event.xselection.selection),
                           atom_fmt(ws, event.xselection.target),
                           atom_fmt(ws, event.xselection.property));

                MakeInt(SELECTIONRESPONSE, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselection.selection, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselection.target, &tmp);
                list_put(&ws->listp, &tmp);

                if (event.xselection.property == None) {
                    if (selection_debug)
                        printf("XGetWindowProperty xselection.property == None\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                property = XInternAtom(ws->display->display, "_OBJECTICON_PROP", False);

                status = XGetWindowProperty(ws->display->display,
                                            ws->win,
                                            property,
                                            0,
                                            8192,   /* Means we won't get back > 32kb of stuff */
                                            True,
                                            AnyPropertyType,
                                            &actual_type,
                                            &actual_format,
                                            &nitems,
                                            &bytes_after,
                                            &prop);

                if (status != Success) {
                    if (selection_debug)
                        printf("XGetWindowProperty failed\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                if (actual_type == None) {
                    if (selection_debug)
                        printf("XGetWindowProperty returned actual_type == None\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                /* Shouldn't ever happen */
                if (!prop) {
                    if (selection_debug)
                        printf("XGetWindowProperty set prop to null\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                bytes_read = nitems * (actual_format/8);
                if (selection_debug)
                    printf("Got %lu items x %d bits -> %ld bytes\n",nitems, actual_format, (long)bytes_read);

                conv_str = PropertyToString(ws->display->display,
                                            actual_type,
                                            nitems,
                                            prop);
                if (conv_str) {
                    /* Make an Icon string out of the data */
                    cstr2string(conv_str, &tmp);
                    free(conv_str);
                } else {
                    /* Make an Icon string out of the data */
                    bytes2string((char *)prop, bytes_read, &tmp);
                }
                list_put(&ws->listp, &tmp);

                XFree(prop);
                    
                break;
            }

            case KeyRelease: {
                if (ws->inputmask & IM_KEY_RELEASE)
                    handle_keypress(wb, (XKeyEvent *)&event);
                break;
            }
            case KeyPress:
                handle_keypress(wb, (XKeyEvent *)&event);
                break;
            case ButtonPress:
            case ButtonRelease:
            case MotionNotify:
                handle_mouse(wb, (XButtonEvent *)&event);
                break;
            case NoExpose:
                break;
            case Expose:
                handle_exposures(wb, (XExposeEvent *)&event);
                break;
            case UnmapNotify:
                wb->window->state = IconicState;
                break;
            case MapNotify:
                if ((ws->width != DisplayWidth(wd->display, wd->screen)) ||
                    (ws->height != DisplayHeight(wd->display, wd->screen)))
                    ws->state = NormalState;
                else
                    ws->state = MaximizedState;
                break;
            case ConfigureNotify:
                handle_config(wb, (XConfigureEvent *)&event);
                break;
            case ClientMessage: {
                /*
                 * only client message we handle at present are destroy requests
                 */
                if (event.xclient.data.l[0] == XInternAtom(ws->display->display, 
                                                           "WM_DELETE_WINDOW", False)) {
                    struct descrip d;
                    MakeInt(WINDOWCLOSED, &d);
                    qevent(wb->window, &d, -1, -1, 0, 0, 0, 0, 0);
                }
                break;
            }
            case DestroyNotify:
                if (!ISZOMBIE(wb))
                    fatalerr(141, NULL);
                /*
                 * first of all, we are done with this window
                 */
                ws->win = (Window) NULL;

                /*
                 * if there are no more references, we are done with the pixmap
                 *  too.  Free it and the colors allocated for this canvas.
                 */
                if (ws->refcount == 0) {
                    if (wb->window->pix) {
                        Display *d = ws->display->display;
                        XSync(d, False);
                        if (ws->pix)
                            XFreePixmap(d, ws->pix);
                        ws->pix = (Pixmap) NULL;
                    }
#ifdef HAVE_LIBXFT
                    if (ws->pixDraw) {
                        XftDrawDestroy(ws->pixDraw);
                        ws->pixDraw = NULL;
                    }
#endif
                }
                break;
            default:
                break;
        }
    }
}

/*
 * poll for available events on all opened displays.
 * this is where the interpreter calls into the X interface.
 */
void pollevent()
{
    wdp wd;
    for (wd = wdsplys; wd; wd = wd->next) {
        if (wd->program == curpstate)
            handle_misc(wd);
    }
}

/*
 * wclose - close a window.  If is a real on-screen window,
 * wait for a DestroyNotify event from the server before returning.
 */
void wclose(wbp w)
{
    STDLOCALS(w);

    XSync(stddpy, False);

    pollevent();

    /*
     * Force window to close (turn into a pixmap)
     */
    if (ws->win && ws->refcount > 1) {
        SETZOMBIE(w);
#ifdef HAVE_LIBXFT
        if (ws->winDraw) {
            XftDrawDestroy(ws->winDraw);
            ws->winDraw = NULL;
        }
#endif
        XDestroyWindow(stddpy,stdwin);
        XFlush(stddpy);
        while (ws->win)
            pollevent();
    }
}
/*
 * flush a window
 */
void wflush(wbp w)
{
    STDLOCALS(w);
    XFlush(stddpy);
}
/*
 * flush all windows
 */
void wflushall()
{
    wdp wd;
    for (wd = wdsplys; wd != NULL; wd = wd->next) {
        XFlush(wd->display);
    }
}
/*
 * sync all the servers
 */
void wsync(wbp w)
{
    wdp wd;
    if (w == NULL) {
        for (wd = wdsplys; wd != NULL; wd = wd->next) {
            XSync(wd->display, False);
        }
    }
    else
        XSync(w->window->display->display, False);
}

/*
 * open a window
 */
wbp wcreate(char *display, wbp parent)
{
    wbp w;
    wsp ws;
    w = alcwbinding();
    w->window = alcwinstate();
    if ((w->window->display = alcdisplay(display)) == NULL) {
        /* alcdisplay will have set &why */
        freewbinding(w);
        return 0;
    }
    ws = w->window;
    ws->vis = DefaultVisual(ws->display->display, ws->display->screen); 
    create_list(64, &ws->listp);

    if (parent)
        ws->transientfor = parent->window->win;

    /*
     * some attributes of the display and window are used in the context
     */
	
    w->context = alccontext(w);

    return w;
}

int wopen(wbp w)
{
    wsp ws = w->window;
    struct imgdata *imd;

    wmap(w);

    imd = &ws->initimage;
    if (imd->width) {
        drawimgdata(w, 0, 0, imd);
        freeimgdata(imd);
    }

    return Succeeded;
}


/*
 * Create a canvas.
 *  If a window, cause the window to actually become visible on the screen.
 */
static void wmap(wbp w)
{
    XWindowAttributes attrs;
    XGCValues gcv;
    unsigned long gcmask =
        GCFont | GCForeground | GCBackground | GCFillStyle | GCCapStyle;
    int i;
    int new_pixmap = 0;
    struct descrip progname;
    char *p, *s, sbuf[256];
    XWMHints wmhints;
    XClassHint clhints;
    STDLOCALS(w);

    /*
     *  Create a pixmap for this canvas if there isn't one already.
     */
    if (ws->pix == (Pixmap) NULL) {
        ws->pix = XCreatePixmap(stddpy, DefaultRootWindow(stddpy),
                                ws->width, ws->height,
                                DefaultDepth(stddpy,wd->screen));
        ws->pixwidth = ws->width;
        ws->pixheight = ws->height;
        new_pixmap = 1;
        stdpix = ws->pix;
    }

    /*
     * create the X window (or use the DefaultRootWindow if requested)
     */
    if (ws->state != HiddenState) {
        Atom WMDeleteWindow;
        XSetWindowAttributes attr;
        attr.background_pixel = wc->bg->c;

        switch (ws->state) {
            case RootState:
                ws->win = DefaultRootWindow(stddpy);
                break;
            case PopupState: {
                attr.override_redirect = True;
                ws->win = XCreateWindow(stddpy, DefaultRootWindow(stddpy),
                                        ws->x < 0 ? 0 : ws->x,
                                        ws->y < 0 ? 0 : ws->y, 
                                        ws->width, ws->height, 
                                        0,
                                        DefaultDepth(stddpy,wd->screen),
                                        InputOutput,
                                        CopyFromParent,
                                        CWBackPixel|CWOverrideRedirect,
                                        &attr);
                break;
            }
            default: {
                ws->win = XCreateWindow(stddpy, DefaultRootWindow(stddpy),
                                        ws->x < 0 ? 0 : ws->x,
                                        ws->y < 0 ? 0 : ws->y, 
                                        ws->width, ws->height, 
                                        0,
                                        DefaultDepth(stddpy,wd->screen),
                                        InputOutput,
                                        CopyFromParent,
                                        CWBackPixel,
                                        &attr);
                break;
            }
        }

        /* If the window has a parent, set the WM_TRANSIENT_FOR hint. */
        if (ws->transientfor)
            XSetTransientForHint(stddpy, ws->win, ws->transientfor);

        /* Turn off background; this prevents X filling the background on an expose
           and hence prevents unsightly flicker on a resize. */
        XSetWindowBackgroundPixmap(stddpy, ws->win, None);

        WMDeleteWindow = XInternAtom(ws->display->display, "WM_DELETE_WINDOW", False);
        XSetWMProtocols(ws->display->display, ws->win, &WMDeleteWindow, 1);

        stdwin = ws->win;
        XClearWindow(stddpy, stdwin);
    }

    /*
     * before creating the graphics context, construct a description
     * of any non-default initial graphics context values.
     */
    gcv.foreground = wc->fg->c;
    gcv.background = wc->bg->c;
#ifdef HAVE_LIBXFT
    gcv.font       = wd->xfont->fid;
#else
    gcv.font       = wc->font->fsp->fid;
#endif
    gcv.fill_style = wc->fillstyle->i;
    gcmask |= (GCLineWidth | GCLineStyle);
    gcv.line_width = wc->linewidth;
    gcv.line_style = wc->linestyle->i;
    if (wc->linewidth > 1) {
        gcv.dashes = 3 * wc->linewidth;
        gcmask |= GCDashList;
    }
    gcv.cap_style = CapProjecting;

    /*
     * Create a graphics context (or change an existing one to conform
     * with initial values).
     */
    if (stdgc == NULL) {
        wc->gc = XCreateGC(stddpy, stdpix, gcmask, &gcv);
        stdgc = wc->gc;
    }
    else
        XChangeGC(stddpy, stdgc, gcmask, &gcv);

    if (wc->clipw >= 0)
        setclip(w);

    if (new_pixmap) {
        XSetForeground(stddpy, stdgc, wc->bg->c);
        XFillRectangle(stddpy, ws->pix, stdgc, 0, 0, ws->width, ws->height);
        XSetForeground(stddpy, stdgc, wc->fg->c);
    }

    /* For RootState, need to fill since XClearWindow above fills with a pixmap */
    if (ws->state == RootState) {
        XSetForeground(stddpy, stdgc, wc->bg->c);
        XFillRectangle(stddpy, ws->win, stdgc, 0, 0, ws->width, ws->height);
        XSetForeground(stddpy, stdgc, wc->fg->c);
    }

    if (wc->patternname != NULL)
        setpattern(w, wc->patternname);

    /*
     *  if we are opening a pixmap, we are done at this point.
     */
    if (stdwin == (Window) NULL) 
        return;

    if (ws->state != RootState) {
        XSizeHints size_hints;
        size_hints.flags = PSize | PMinSize | PMaxSize;
        size_hints.width = ws->width;
        size_hints.height= ws->height;
        if (ws->x == -(INT_MAX)) 
            ws->x = 0;
        else
            size_hints.flags |= USPosition;
        if (ws->y == -(INT_MAX)) 
            ws->y = 0;
        else 
            size_hints.flags |= USPosition;
        size_hints.x = ws->x;
        size_hints.y = ws->y;
        if (ISRESIZABLE(w)) {
            size_hints.min_width = ws->minwidth;
            size_hints.min_height = ws->minheight;
            size_hints.max_width = ws->maxwidth;
            size_hints.max_height = ws->maxheight;
        }
        else {
            size_hints.min_width = size_hints.max_width = ws->width;
            size_hints.min_height = size_hints.max_height = ws->height;
        }
        XSetStandardProperties(stddpy, stdwin, ws->windowlabel, ws->windowlabel,
                               0,0,0, &size_hints);
        XSelectInput(ws->display->display, ws->win, 
                     ExposureMask | KeyPressMask | 
                     ButtonPressMask | ButtonReleaseMask | ButtonMotionMask |
                     StructureNotifyMask | PointerMotionMask | KeyReleaseMask);
    }

    wmhints.input = True;
    wmhints.flags = InputHint;
    if (ws->state != RootState) {
        wmhints.flags |= (ws->wmhintflags | StateHint);
        wmhints.initial_state = NormalState;
    }
    XSetWMHints(stddpy, stdwin, &wmhints);

    /*
     * Set the class hints that name the program (for reference by the
     * window manager) following conventions given in O'Reilly.
     */
    cnv:string(kywd_prog, progname);
    if (! (s = getenv("RESOURCE_NAME"))) {
        p = StrLoc(progname);
        s = p + StrLen(progname);
        while (s > p && s[-1] != '/')
            s--;				/* find tail of prog_name */
        clhints.res_name = sbuf;
        clhints.res_class = "IconProg";
        for (i=0; s < p+StrLen(progname); ) clhints.res_name[i++] = *s++;
        clhints.res_name[i] = '\0';
        XSetClassHint(stddpy, stdwin, &clhints);
    }
    XSync(stddpy, False);

    if (ws->state != RootState) {
        CLREXPOSED(w);
        XMapWindow(stddpy, stdwin);
    }

    XGetWindowAttributes(stddpy, stdwin, &attrs);
    ws->width = attrs.width;
    ws->height = attrs.height;
    resizePixmap(w, ws->width, ws->height);

    if (stdwin) {
        i = ws->cursor->i >> 1;
        if (!(wd->cursors[i]))
            wd->cursors[i] = XCreateFontCursor(stddpy, 2 * i);
        XDefineCursor(stddpy, stdwin, wd->cursors[i]);
    }

    CLRZOMBIE(w);

    XSetFunction(stddpy, stdgc, wc->drawop->i);
    XSync(stddpy, False);
}

void doconfig(wbp w, int status)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    XTextProperty textprop;

    if (status & C_CLIP) {
        if (wc->clipw >= 0)
            setclip(w);
        else
            unsetclip(w);
    }

    if (status & (C_POS | C_SIZE | C_MINSIZE | C_MAXSIZE | C_RESIZE)) {
        resizePixmap(w, ws->width, ws->height);

        if (ws->win) {
            if (status != C_POS) {
                XSizeHints size_hints;
                long t;

                /* Not just a move */

                XGetWMNormalHints(wd->display, ws->win, &size_hints, &t);
                if (ISRESIZABLE(w)) {
                    size_hints.min_width = ws->minwidth;
                    size_hints.min_height = ws->minheight;
                    size_hints.max_width = ws->maxwidth;
                    size_hints.max_height = ws->maxheight;
                }
                else {
                    size_hints.min_width = size_hints.max_width = ws->width;
                    size_hints.min_height = size_hints.max_height = ws->height;
                }
                XSetWMNormalHints(wd->display, ws->win, &size_hints);
            }

            switch (status & (C_POS|C_SIZE)) {
                case C_POS: {
                    XMoveWindow(wd->display, ws->win, ws->x, ws->y);
                    break;
                }
                case C_SIZE: {
                    XResizeWindow(wd->display, ws->win, ws->width, ws->height);
                    break;
                }
                case C_POS|C_SIZE: {
                    XMoveResizeWindow(wd->display, ws->win, ws->x, ws->y, ws->width, ws->height);
                    break;
                }
            }
            /* XSync is not enough because the window manager gets involved here. */
            XFlush(wd->display);			      /* force out request */
            XGetWMName(wd->display, ws->win, &textprop);    /* force WM round trip */
            XSync(wd->display, False);		      /* NOW sync */
        }
    }

    if (status & C_IMAGE) {
        struct imgdata *imd = &ws->initimage;
        if (imd->width) {
            drawimgdata(w, 0, 0, imd);
            freeimgdata(imd);
        }
    }
}

/*
 * Note that the three strings are pointers into the string space;
 * data is a safe pointer into a frame.
 */
int sendselectionresponse(wbp w, word requestor, char *property, char *selection, char *target, word time, dptr data)
{
    Atom property_atom, target_atom, selection_atom, XA_TARGETS, target_list[32];
    XEvent theevent;
    struct lgstate state;
    tended struct b_lelem *le;
    tended char *cstr_target;
    int target_cnt = 1;
    STDLOCALS(w);

    if (selection_debug)
        printf("sendselectionresponse:\n\trequestor=%lx "
               "property=%s target=%s selection=%s time=%ld\n",
               (long)requestor, property, target, selection, (long)time);

    property_atom = XInternAtom(ws->display->display, property, False);
    target_atom = XInternAtom(ws->display->display, target, False);
    selection_atom = XInternAtom(ws->display->display, selection, False);
    XA_TARGETS = XInternAtom(ws->display->display, "TARGETS", False);

    if (target_atom == XA_TARGETS) {
        if (!is:list(*data))
            ReturnErrVal(108, *data, Error);
        target_list[0] = XA_TARGETS;
        for (le = lgfirst(&ListBlk(*data), &state); le;
             le = lgnext(&ListBlk(*data), &state, le)) {
            if (!cnv:C_string(le->lslots[state.result], cstr_target))
                ReturnErrVal(148, le->lslots[state.result], Error);
            target_list[target_cnt++] = XInternAtom(ws->display->display, cstr_target, False);
            if (selection_debug)
                printf("\tAdding target:%s\n", cstr_target);
        }
        XChangeProperty(ws->display->display,
                        requestor,
                        property_atom,
                        target_atom,
                        32,
                        PropModeReplace,
                        (unsigned char *)target_list,
                        target_cnt);
        theevent.xselection.property = property_atom;
    } else if (is:null(*data)) {
        /* Can't handle this target type */
        if (selection_debug)
            printf("\tSetting property to None\n");
        theevent.xselection.property = None;
    } else {
        if (!cnv:string(*data, *data))
            ReturnErrVal(103, *data, Error);
        if (selection_debug)
            printf("\tSetting property to %d bytes of data\n", (int)StrLen(*data));
        XChangeProperty(ws->display->display,
                        requestor,
                        property_atom,
                        target_atom,
                        8,
                        PropModeReplace,
                        (unsigned char *)StrLoc(*data),
                        StrLen(*data));
        theevent.xselection.property = property_atom;
    }

    theevent.type = SelectionNotify;
    theevent.xselection.serial = 0; /*event.xselectionrequest.serial;*/
    theevent.xselection.send_event = True;
    theevent.xselection.requestor = requestor;
    theevent.xselection.selection = selection_atom;
    theevent.xselection.target = target_atom;
    theevent.xselection.time = time;

    XSendEvent(ws->display->display,
               requestor,
               False, NoEventMask, &theevent);

    return Succeeded;
}

int ownselection(wbp w, char *selname)
{
    Atom selection;
    Window curr;
    STDLOCALS(w);

    selection = XInternAtom(ws->display->display, selname, False);

    curr = XGetSelectionOwner(ws->display->display, selection);
    /* Check for no change in selection */
    if (curr == ws->win)
        return Succeeded;

    if (selection_debug)
        printf("Owner of selection %s set from %lx -> %lx\n", 
               atom_fmt(ws, selection),
               (long)curr,
               (long)ws->win);

    /*
     * X doesn't send a SelectionClear event to us when the selection
     * changes between our own windows, so if the current owner is one
     * our windows, send it a "clear" message.
     */
    if (curr) {
        wsp x;
        for (x = wstates; x; x = x->next) {
            if (x->win == curr) {
                tended struct descrip tmp;
                if (selection_debug)
                    printf("Enqueueing artificial SELECTIONCLEAR to current owner %lx\n",(long)curr);
                MakeInt(SELECTIONCLEAR, &tmp);
                list_put(&x->listp, &tmp);
                get_atom_descriptor(x, selection, &tmp);
                list_put(&x->listp, &tmp);
                break;
            }
        }
    }

    XSetSelectionOwner(ws->display->display, 
                       selection,
                       ws->win,
                       CurrentTime);

    return Succeeded;
}

int requestselection(wbp w, char *selname, char *targetname)
{
    Atom selection, property, target;
    STDLOCALS(w);

    selection = XInternAtom(ws->display->display, selname, False);
    property = XInternAtom(ws->display->display, "_OBJECTICON_PROP", False);
    target = XInternAtom(ws->display->display, targetname, False);
    if (selection_debug)
        printf("getselectioncontent: calling XConvertSelection selection=%s target=%s property=%s requestor=%lx\n",
               atom_fmt(ws, selection),
               atom_fmt(ws, target),
               atom_fmt(ws, property),
               (long)ws->win);

    XConvertSelection(ws->display->display,
                      selection, 
                      target, 
                      property, 
                      ws->win,
                      CurrentTime);

    return Succeeded;
}

int warppointer(wbp w, int x, int y)
{
    wsp ws = w->window;
    XWarpPointer(ws->display->display, None, ws->win, 0,0,0,0, x, y);
    return Succeeded;
}

/*
 * setwindowlabel
 */
int setwindowlabel(wbp w, char *s)
{
    wsp ws = w->window;
    if (ws->windowlabel)
        free(ws->windowlabel);
    ws->windowlabel = salloc(s);

    if (ws->display && ws->display->display && ws->win)
        XStoreName(ws->display->display, ws->win,
                   *ws->windowlabel ? ws->windowlabel : " ");    /* empty string fails */
    return Succeeded;
}



/*
 * setpointer() - define a mouse pointer shape
 */
int setpointer(wbp w, char *val)
{
    stringint *e;
    int i;
    STDLOCALS(w);
    e = stringint_lookup(cursors, val);
    if (!e)
        return Failed;
    ws->cursor = e;
    i = ws->cursor->i >> 1;
    if (!(wd->cursors[i]))
        wd->cursors[i] = XCreateFontCursor(stddpy, 2 * i);
    if (stdwin)
        XDefineCursor(stddpy, stdwin, wd->cursors[i]);
    return Succeeded;
}

/*
 * setdrawop() - set the drawing operation
 */
int setdrawop(wbp w, char *val)
{
    stringint *e;
    STDLOCALS(w);
    XSync(stddpy, False);
    e = stringint_lookup(drawops, val);
    if (!e)
        return Failed;
    wc->drawop = e;
    if (stdgc) XSetFunction(stddpy, stdgc, wc->drawop->i);
    return Succeeded;
}

/*
 * rebind() - bind w's context to that of w2.
 */
int rebind(wbp w, wbp w2)
{
    if (w->window->display != w2->context->display) return Failed;
    w->context = w2->context;
    return Succeeded;
}


static void setclip(wbp w)
{
    wcp wc = w->context;
    XRectangle rec;
    if (wc->gc) {
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XSetClipRectangles(wc->display->display, wc->gc, 0, 0, &rec, 1,Unsorted);
    }
}

static void unsetclip(wbp w)
{
    wcp wc = w->context;
    if (wc->gc) 
        XSetClipMask(wc->display->display, wc->gc, None);
}

char *getcanvas(wbp w)
{
    char *v = stringint_int2str(canvastypes, w->window->state);
    if (!v)
        syserr("Invalid value of state");
    return v;
}

/*
 *  Set the canvas type, either during open (pixmap is null, set a flag)
 *   or change an existing canvas to a different type.
 */
int setcanvas(wbp w, char *s)
{
    stringint *e;
    STDLOCALS(w);
    e = stringint_lookup(canvastypes, s);
    if (!e)
        return Failed;
    switch (e->i) {
        case IconicState: {
            if (ws->pix == (Pixmap) NULL) {
                ws->wmhintflags |= StateHint;
                ws->state = IconicState;
            }
            else {
                if (ws->state != IconicState) {
                    if (ws->win == (Window) NULL) {
                        ws->state = NormalState;
                        wmap(w);
                    }
                    XIconifyWindow(ws->display->display, ws->win, ws->display->screen);
                    XSync(stddpy, False);
                    while (ws->state != IconicState)
                        handle_misc(wd);
                }
            }
            break;
        }

        case NormalState: {
            if (ws->pix == (Pixmap) NULL) {
                ws->state = NormalState;
            }
            else {
                if (ws->win == (Window) NULL) {
                    ws->state = NormalState;
                    wmap(w);
                }
                else if (ws->state == IconicState) {
                    XMapWindow(stddpy, stdwin);
                    XSync(stddpy, False);
                    while (ws->state == IconicState)
                        pollevent();
                }
                else if (ws->state == MaximizedState) {
                    ws->x = ws->normalx;
                    ws->y = ws->normaly;
                    ws->width = ws->normalw;
                    ws->height = ws->normalh;
                    doconfig(w, C_POS | C_SIZE);
                    ws->state = NormalState;
                }
            }
            break;
        }

        case PopupState: {
            if (ws->win == (Window) NULL)  {
                ws->state = PopupState;
            }
            else {
                return Failed;
            }
            break;
        }

        case RootState: {
            if (ws->win == (Window) NULL)  {
                ws->state = RootState;
            }
            else {
                return Failed;
            }
            break;
        }

        case MaximizedState: {
            if (ws->state != MaximizedState) {
                int expect_config= (ws->width != DisplayWidth(stddpy, wd->screen)) ||
                    (ws->height != DisplayHeight(stddpy, wd->screen));
                ws->normalx = ws->x;
                ws->normaly = ws->y;
                ws->normalw = ws->width;
                ws->normalh = ws->height;
                ws->width = DisplayWidth(stddpy, wd->screen);
                ws->height= DisplayHeight(stddpy, wd->screen);
                if (ws->pix != (Pixmap) NULL) {
                    if (ws->win == (Window) NULL) {
                        ws->state = MaximizedState;
                        wmap(w);
                    }
                    else if (ws->state == IconicState) {
                        XMapWindow(stddpy, stdwin);
                        XSync(stddpy, False);
                        while (ws->state == IconicState)
                            pollevent();
                    }
                    else if (expect_config) {
                        ws->x = ws->y = 0;
                        doconfig(w, C_POS | C_SIZE);
                        pollevent();
                        ws->x = -ws->x;
                        ws->y = -ws->y;
                        doconfig(w, C_POS);
                    }
                }
                ws->state = MaximizedState;
            }
            break;
        }

        case HiddenState: {
            if (ws->pix == (Pixmap)NULL) {
                ws->state = HiddenState;
            }
            else {
                if (ws->win != (Window) NULL) {
                    if (ws->state == MaximizedState) {
                        ws->x = ws->normalx;
                        ws->y = ws->normaly;
                        ws->width = ws->normalw;
                        ws->height = ws->normalh;
                        ws->state = NormalState;
                    }
                    SETZOMBIE(w);
#ifdef HAVE_LIBXFT
                    if (ws->winDraw) {
                        XftDrawDestroy(ws->winDraw);
                        ws->winDraw = NULL;
                    }
#endif
                    XDestroyWindow(stddpy, stdwin);
                    XFlush(stddpy);
                    while (ws->win)
                        pollevent();
                    ws->state = HiddenState;
                }
            }
            break;
        }
        default:
            syserr("Unexpected canvas state");
    }
    XSync(ws->display->display, False);
    return Succeeded;
}


/*
 * Set the context's fill style by name.
 */
int setfillstyle(wbp w, char *val)
{
    stringint *e;
    STDLOCALS(w);
    e = stringint_lookup(fillstyles, val);
    if (!e)
        return Failed;
    wc->fillstyle = e;
    if (stdpix)
        XSetFillStyle(stddpy, stdgc, wc->fillstyle->i);
    return Succeeded;
}

char *getfillstyle(wbp w)
{
    return w->context->fillstyle->s;
}


/*
 * Set the context's line style by name.
 */
int setlinestyle(wbp w, char *val)
{
    stringint *e;
    STDLOCALS(w);
    e = stringint_lookup(linestyles, val);
    if (!e)
        return Failed;
    wc->linestyle = e;
    if (stdpix) 
        XSetLineAttributes(stddpy, stdgc,
                           wc->linewidth, wc->linestyle->i, CapProjecting, JoinMiter);
    return Succeeded;
}

/*
 * Set the context's line width
 */
int setlinewidth(wbp w, int linewid)
{
    unsigned long gcmask;
    XGCValues gcv;
    STDLOCALS(w);

    if (linewid < 0) return Error;
    wc->linewidth = linewid;
    if (stdpix) {
        gcv.line_width = linewid;
        gcv.line_style = wc->linestyle->i;
        if (linewid > 1)
            gcv.dashes = 3 * wc->linewidth;
        else
            gcv.dashes = 4;
        gcmask = GCLineWidth | GCLineStyle | GCDashList;
        XChangeGC(stddpy, stdgc, gcmask, &gcv);
    }
    return Succeeded;
}

int getlinewidth(wbp w)
{
    return w->context->linewidth;
}

/*
 * Set the context's foreground color by name.
 */
int setfg(wbp w, char *s)
{
    int r, g, b;
    wcp wc = w->context;
    if (!parsecolor(s, &r, &g, &b))
        return Failed;
    if (wc->fg)
        unlink_sharedcolor(wc->fg);
    wc->fg = new_sharedcolor(s, r, g, b);
    if (wc->gc)
        XSetForeground(wc->display->display, wc->gc, wc->fg->c);
    return Succeeded;
}


/*
 * Set the window context's background color by name.
 */
int setbg(wbp w, char *s)
{
    int r, g, b;
    wcp wc = w->context;
    if (!parsecolor(s, &r, &g, &b))
        return Failed;
    if (wc->bg)
        unlink_sharedcolor(wc->bg);
    wc->bg = new_sharedcolor(s, r, g, b);
    if (wc->gc)
        XSetBackground(wc->display->display, wc->gc, wc->bg->c);
    return Succeeded;
}

char *getdisplay(wbp w)
{
    char *tmp;
    wdp wd = w->window->display;
    if (!strcmp(wd->name, "")) {
        if ((tmp = getenv("DISPLAY")) != NULL)
            return tmp;
        else
            return "";
    }
    else return wd->name;
}

char *getwindowlabel(wbp w)
{
    return w->window->windowlabel;
}

int getdisplaysize(wbp w, int *width, int *height)
{
    *width = DisplayWidth(w->window->display->display, w->window->display->screen);
    *height = DisplayHeight(w->window->display->display, w->window->display->screen);
    return Succeeded;
}

int getdepth(wbp w, int *res)
{
    *res = DefaultDepth(w->window->display->display, w->window->display->screen);
    return Succeeded;
}

/*
 * getpos() - update the window state's notion of its current position
 */
int getpos(wbp w)
{
    Window garbage1, garbage2;
    int root_x, root_y, win_x, win_y;
    unsigned int key_buttons;
    STDLOCALS(w);
    if (!stdwin) return Failed;
    /*
     * This call is made because it is guaranteed to generate
     * a synchronous request of the server, not just ask Xlib
     * what the window position was last it knew.
     */
    if (XQueryPointer(stddpy, stdwin, &garbage1, &garbage2,
                      &root_x, &root_y, &win_x, &win_y, &key_buttons) ==
        False) {
        return Failed;
    }
    ws->x = root_x - win_x;
    ws->y = root_y - win_y;
    return Succeeded;
}

char *getpattern(wbp w)
{
    if (w->context->patternname)
        return w->context->patternname;
    else 
        return "black";
}

char *getfg(wbp w)
{
    return w->context->fg->name;
}

char *getbg(wbp w)
{
    return w->context->bg->name;
}

char *getlinestyle(wbp w)
{
    return w->context->linestyle->s;
}

char *getpointer(wbp w)
{
    return w->window->cursor->s;
}

char *getdrawop(wbp w)
{
    return w->context->drawop->s;
}

int grabpointer(wbp w)
{
    wsp ws = w->window;
    if (!ws->win)
        return Failed;
    if (XGrabPointer(ws->display->display, ws->win,False, 
                     ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | PointerMotionMask,
                     GrabModeAsync, GrabModeAsync, None, None, CurrentTime) == GrabSuccess)
        return Succeeded;
    else
        return Failed;
}

int ungrabpointer(wbp w)
{
    wsp ws = w->window;
    if (!ws->win)
        return Failed;
    XUngrabPointer(ws->display->display, CurrentTime);
    return Succeeded;
}

/*
 * Set the window's font by name.
 */
int setfont(wbp w, char *s)
{
    wfp tmp;
    STDLOCALS(w);

    tmp = loadfont(wd, s);
    if (!tmp)
        return Failed;
    wc->font = tmp;

#ifndef HAVE_LIBXFT
    if (stdgc != NULL)
        XSetFont(stddpy, stdgc, wc->font->fsp->fid);
#endif

    return Succeeded;
}

/*
 * callback procedures
 */

static void handle_exposures(wbp w, XExposeEvent *event)
{
    STDLOCALS(w);
    SETEXPOSED(w);
    if (stdwin && !ISZOMBIE(w)) {
        if (wc->drawop->i != GXcopy)
            XSetFunction(stddpy, stdgc, GXcopy);
        if (wc->clipw >= 0)
            unsetclip(w);
        XCopyArea(stddpy, stdpix, stdwin, stdgc, event->x,event->y,
                  event->width,event->height, event->x,event->y);
        if (wc->clipw >= 0)
            setclip(w);
        if (wc->drawop->i != GXcopy)
            XSetFunction(stddpy,stdgc,wc->drawop->i);
    }
}

/*
 * resizePixmap(w,width,height) -- ensure w's backing pixmap is at least
 * width x height pixels.
 *
 * Resizes the backing pixmap, if needed.  Called when X resize events
 * arrive, as well as when programs make explicit resize requests.
 *
 */
static void resizePixmap(wbp w, int width, int height)
{
    Pixmap p;
    STDLOCALS(w);
    if (ws->pix == (Pixmap) NULL) 
        return;
    if ((width > ws->pixwidth) || (height > ws->pixheight)) {
        int x = ws->pixwidth, y = ws->pixheight;

        ws->pixheight = Max(ws->pixheight, height);
        ws->pixwidth  = Max(ws->pixwidth, width);
        p = XCreatePixmap(stddpy, DefaultRootWindow(stddpy), ws->pixwidth,
                          ws->pixheight, DefaultDepth(stddpy,wd->screen));
        /*
         * This staggering amount of redudancy manages to make sure the new
         * pixmap gets initialized including areas not in the old pixmap.
         * The window is redrawn.
         */
        XSetForeground(stddpy, stdgc, wc->bg->c);
        if (wc->drawop->i != GXcopy)
            XSetFunction(stddpy, stdgc, GXcopy);
        if (wc->fillstyle != FillSolid)
            XSetFillStyle(stddpy, stdgc, FillSolid);
        if (wc->clipw >= 0)
            unsetclip(w);
	   
        if (width > x) {
            XFillRectangle(stddpy, p, stdgc, x, 0, width-x, ws->pixheight);
            if (stdwin != (Window) NULL)
                XFillRectangle(stddpy,stdwin,stdgc, x, 0, width-x, ws->pixheight);
        }
        if (height > y) {
            XFillRectangle(stddpy, p, stdgc, 0, y, x, height - y);
            if (stdwin != (Window) NULL)
                XFillRectangle(stddpy, stdwin, stdgc, 0, y, x, height - y);
        }
        XSetForeground(stddpy, stdgc, wc->fg->c);
        XCopyArea(stddpy, stdpix, p, stdgc, 0, 0, x, y, 0, 0);
        if (wc->drawop->i != GXcopy)
            XSetFunction(stddpy,stdgc,wc->drawop->i);
        if (wc->fillstyle->i != FillSolid)
            XSetFillStyle(stddpy, stdgc, wc->fillstyle->i);
        if (wc->clipw >= 0)
            setclip(w);

        XFreePixmap(stddpy, stdpix);	/* free old pixmap */
        ws->pix = p;
#ifdef HAVE_LIBXFT
        if (ws->pixDraw) {
            XftDrawDestroy(ws->pixDraw);
            ws->pixDraw = NULL;
        }
#endif
    }
}

/*
 * Resize operations are made as painless as possible, but the
 * user program is informed anyhow.  The integer coordinates are
 * the new size of the window, in pixels.
 */
static void handle_config(wbp w, XConfigureEvent *event)
{
    struct descrip d;
    STDLOCALS(w);

    /*
     * Update X-Icon's information about the window's configuration
     */

    ws->x = event->x;
    ws->y = event->y;

    /*
     * If this was not a resize, drop it
     */
    if ((event->width == ws->width) && (event->height == ws->height))
        return;

    ws->width = event->width;
    ws->height = event->height;

    resizePixmap(w, event->width, event->height);


    /*
     * The initial configure event generates no Icon-level "events"
     */
    if (!ISEXPOSED(w))
        return;

    MakeInt(RESIZED, &d);
    qevent(w->window, &d, -1, -1, 0, 0, 0, 0, 0);
}

/*
 * Queue up characters for keypress events.
 */
static void handle_keypress(wbp w, XKeyEvent *event)
{
    int i,j;
    char s[10];
    tended struct descrip d;
    KeySym k;

    /* First try to convert the event to a simple char string, and a KeySym */
    i = XLookupString(event, s, sizeof(s), &k, NULL);
    if (i > 0) {
        /* Found a char string, so generate string event(s) */
        StrLen(d) = 1;
        for (j = 0; j < i; j++) {
            StrLoc(d) = &allchars[s[j] & 0xFF];
            qevent(w->window, &d, event->x, event->y,
                   (uword)event->time, 
                   event->state & ControlMask,
                   event->state & Mod1Mask,
                   event->state & ShiftMask,
                   (event->type == KeyRelease) );
        }
        return;
    }

    /* Second try is to convert to a unicode char; if found generate a 1-char
     * ucs/string */
    i = convert_KeySym_to_code_point(k);
    if (i > 0) {
        if (i < 256) {
            StrLen(d) = 1;
            StrLoc(d) = &allchars[i];
        } else {
            d.dword = D_Ucs;
            BlkLoc(d) = (union block *)make_one_char_ucs_block(i);
        }
        qevent(w->window, &d, event->x, event->y,
               (uword)event->time,
               event->state & ControlMask,
               event->state & Mod1Mask,
               event->state & ShiftMask,
               (event->type == KeyRelease) );
        return;
    }

    /* Neither of those worked, so it must be a non-character key (cursor key, etc).
     * So just generate the numerical value of the KeySym as an integer.
     */
    MakeInt(k, &d);
    qevent(w->window, &d, event->x, event->y,
           (uword)event->time, 
           event->state & ControlMask,
           event->state & Mod1Mask,
           event->state & ShiftMask,
           (event->type == KeyRelease) );
}

#include "rxkeysyms.ri"

/*
 * Handle button presses and drag events.  In the case of drags, we should
 * really be looking at an XMotionEvent instead of an XButtonEvent, but
 * the structures are identical up to the button field (which we do not
 * examine for drag events).  Mouse coordinates are queued up after the event.
 */
static void handle_mouse(wbp w, XButtonEvent *event)
{
    int state = 0;
    if (event->state & Button1Mask) state |= 1;
    if (event->state & Button2Mask) state |= 2;
    if (event->state & Button3Mask) state |= 4;
    if (event->state & Button4Mask) state |= 8;
    if (event->state & Button5Mask) state |= 16;
    switch (event->type) {
        case ButtonPress: {
            switch (event->button) {
                case Button1: state |= 1; break;
                case Button2: state |= 2; break;
                case Button3: state |= 4; break;
                case Button4: state |= 8; break;
                case Button5: state |= 16; break;
            }
            break;
        }
        case ButtonRelease: {
            switch (event->button) {
                case Button1: state &= ~1; break;
                case Button2: state &= ~2; break;
                case Button3: state &= ~4; break;
                case Button4: state &= ~8; break;
                case Button5: state &= ~16; break;
            }
            break;
        }
    }
    qmouseevents(w->window, state, 
                 event->x, event->y, (uword)event->time, 
                 event->state & ControlMask,
                 event->state & Mod1Mask,
                 event->state & ShiftMask);
}


void drawarc(wbp w, int x, int y, int width, int height, double angle1, double angle2)
{
    XArc arc;
    STDLOCALS(w); 
    arc.x = x;
    arc.y = y;
    arc.width = width;
    arc.height = height;
    arc.angle1 = CONVERT_ANGLE(angle1);
    arc.angle2 = CONVERT_ANGLE(angle2);
    RENDER2(XDrawArcs,&arc,1);
}

void drawlines(wbp w, XPoint *points, int npoints)
{
    STDLOCALS(w); 
    RENDER3(XDrawLines,points,npoints,CoordModeOrigin);
}

void drawpoint(wbp w, int x, int y)
{
    XPoint p;
    STDLOCALS(w);
    p.x = x;
    p.y = y;
    RENDER3(XDrawPoints,&p,1,CoordModeOrigin);
}

void drawrectangle(wbp w, int x, int y, int width, int height)
{
   STDLOCALS(w);
   if (width > 0 && height > 0)
       RENDER4(XDrawRectangle,x,y,width-1,height-1);
}

void fillarc(wbp w, int x, int y, int width, int height, double angle1, double angle2)
{ 
    XArc arc;
    STDLOCALS(w); 
    arc.x = x;
    arc.y = y;
    arc.width = width;
    arc.height = height;
    arc.angle1 = CONVERT_ANGLE(angle1);
    arc.angle2 = CONVERT_ANGLE(angle2);
    RENDER2(XFillArcs, &arc, 1);
}

void fillpolygon(wbp w, XPoint *points, int npoints)
{
    STDLOCALS(w); 
    RENDER4(XFillPolygon, points, npoints, Complex, CoordModeOrigin);
}

/*
 * fill a rectangle
 */
void fillrectangle(wbp w, int x, int y, int width, int height)
{
    XRectangle rec;
    STDLOCALS(w);
    rec.x = x;
    rec.y = y;
    rec.width = width;
    rec.height = height;
    RENDER2(XFillRectangles, &rec, 1);
}

/*
 * erase an area
 */
void erasearea(wbp w, int x, int y, int width, int height)
{
    STDLOCALS(w);

    /*
     * if width >= window width or height >= window height, clear any
     * offscreen portion as well in order to allow the freeing of colors.
     */
    if (x + width  >= ws->width)  width  = ws->pixwidth - x;
    if (y + height >= ws->height) height = ws->pixheight - y;

    /*
     * fill the rectangle with the background color
     */
    XSetForeground(stddpy, stdgc, wc->bg->c);
    if (wc->drawop->i != GXcopy) XSetFunction(stddpy, stdgc, GXcopy);
    if (wc->fillstyle->i != FillSolid) XSetFillStyle(stddpy, stdgc, FillSolid);

    RENDER4(XFillRectangle, x, y, width, height);
    XSetForeground(stddpy, stdgc, wc->fg->c);
    if (wc->drawop->i != GXcopy) XSetFunction(stddpy, stdgc, wc->drawop->i);
    if (wc->fillstyle->i != FillSolid) XSetFillStyle(stddpy, stdgc, wc->fillstyle->i);
}

/*
 * copy an area
 */
void copyarea(wbp w, wbp w2, int x, int y, int width, int height, int x2, int y2)
{
    int lpad, rpad, tpad, bpad;
    Pixmap src;
    wsp ws1 = w->window;
    STDLOCALS(w2);

    if (w->window->display->display != w2->window->display->display) {
        wdp wd1 = ws1->display;
        int i, j;
        Display *d1 = wd1->display;
        XImage *xim;

        /*
         * Copying is between windows on two different displays.
         */
        if (x<0 || y<0 || x+width > ws1->pixwidth || y+height > ws1->pixheight)
            return;		/*#%#%# BOGUS, NEEDS FIXING */
        xim = XGetImage(d1, ws1->pix, x, y, width, height,
                        (1<<DefaultDepth(d1,wd1->screen))-1,XYPixmap);
        XSetFunction(stddpy, stdgc, GXcopy);
        for (i=0; i < width; i++) {
            for (j=0; j < height; j++) {
                XSetForeground(stddpy, stdgc, XGetPixel(xim, i, j));
                RENDER2(XDrawPoint, i + x2, j + y2);
	    }
        }
        XSetForeground(stddpy, stdgc, wc->fg->c);
        XSetFunction(stddpy, stdgc, wc->drawop->i);
        XSync(stddpy,False);
        XDestroyImage(xim);
    }
    else {
        /*
         * Copying is between windows on one display, perhaps the same window.
         */
        src = ws1->pix;
        XSetForeground(stddpy, stdgc, wc->bg->c);
        XSetFunction(stddpy, stdgc, GXcopy);

        if (x+width<0 || y+height<0 || x>=ws1->pixwidth || y>=ws1->pixheight) {
            /* source is entirely offscreen */
            RENDER4(XFillRectangle, x2, y2, width, height);
        }
        else {
            /*
             * Check for source partially offscreen, but copy first and
             * fill later in case the source and destination overlap.
             */
            lpad = rpad = tpad = bpad = 0;
            if (x < 0) {			/* source extends past left edge */
                lpad = -x;
                width -= lpad;
                x2 += lpad;
                x = 0;
            }
            if (x + width > ws1->pixwidth) {  /* source extends past right edge */
                rpad = x + width - ws1->pixwidth;
                width -= rpad;
            }
            if (y < 0) {			/* source extends above top edge */
                tpad = -y;
                height -= tpad;
                y2 += tpad;
                y = 0;
            }
            if (y + height > ws1->pixheight) {  /* source extends below bottom */
                bpad = y + height - ws1->pixheight;
                height -= bpad;
            }
            /*
             * Copy the area.
             */
            if (stdwin)
                XCopyArea(stddpy, src, stdwin, stdgc, x, y, width, height, x2, y2);
            XCopyArea(stddpy, src, stdpix, stdgc, x, y, width, height, x2, y2);
            /*
             * Fill any edges not provided by source.
             */
            if (lpad > 0)
                RENDER4(XFillRectangle, x2-lpad, y2-tpad, lpad, tpad+height+bpad);
            if (rpad > 0)
                RENDER4(XFillRectangle, x2+width, y2-tpad, rpad, tpad+height+bpad);
            if (tpad > 0)
                RENDER4(XFillRectangle, x2, y2-tpad, width, tpad);
            if (bpad > 0)
                RENDER4(XFillRectangle, x2, y2+height, width, bpad);
        }

        XSetForeground(stddpy,stdgc, wc->fg->c);
        XSetFunction(stddpy, stdgc, wc->drawop->i);
    }
}


/*
 * Client for producing pixels from a window
 */
void loadimgmem(wbp w, struct imgmem *imem, int copy)
{
    STDLOCALS(w);
    MemProtect(imem->im = XGetImage(stddpy, stdpix,
                                    imem->x, imem->y, imem->width, imem->height,
                                    AllPlanes, ZPixmap));
}

void getpixel(struct imgmem *imem, int *r, int *g, int *b)
{
    unsigned long c;
    c = XGetPixel(imem->im, imem->xoff, imem->yoff);
    *b = (c&0xff)*257;
    *g = ((c>>8)&0xff)*257;
    *r = ((c>>16)&0xff)*257;
}

void setpixel(struct imgmem *imem, int r, int g, int b)
{
    unsigned long c = ((r/256)<<16) | ((g/256)<<8) | (b/256);
    XPutPixel(imem->im, imem->xoff, imem->yoff, c);
}

void saveimgmem(wbp w, struct imgmem *imem)
{
    STDLOCALS(w);
    if (wc->drawop->i != GXcopy) XSetFunction(stddpy, stdgc, GXcopy);
    RENDER7(XPutImage, imem->im, 0, 0, imem->x, imem->y, imem->width, imem->height);
    if (wc->drawop->i != GXcopy) XSetFunction(stddpy, stdgc, wc->drawop->i);
}

void freeimgmem(struct imgmem *imem)
{
    XDestroyImage(imem->im);
    imem->im = 0;
}


int querypointer(wbp w, int *x, int *y)
{
    Display *theDisplay;
    Window theWindow;
    Window garbage1, garbage2;
    int root_x, root_y;
    unsigned int key_buttons;

    theDisplay = w->window->display->display;
    theWindow  = w->window->win;
    if (!theWindow)
        return Failed;

    XQueryPointer(theDisplay, theWindow, &garbage1, &garbage2,
                  &root_x, &root_y, x, y, &key_buttons);
    return Succeeded;
}

int queryrootpointer(wbp w, int *x, int *y)
{
    Display *theDisplay;
    Window theWindow;
    Window garbage1, garbage2;
    int win_x, win_y;
    unsigned int key_buttons;

    theDisplay = w->window->display->display;
    theWindow  = DefaultRootWindow(theDisplay);
    if (!theWindow)
        return Failed;
    XQueryPointer(theDisplay, theWindow, &garbage1, &garbage2,
                  x, y, &win_x, &win_y, &key_buttons);
    return Succeeded;
}

/*
 * setpattern
 */
int setpattern(wbp w, char *name)
{
    int i, j, v, width, height, *rowdata;
    Pixmap p;
    char *t, data[4 * MAX_PATTERN_HEIGHT];
    STDLOCALS(w);

    if (!parsepattern(name, &width, &height, &rowdata))
        return Failed;
    if (stdgc) {
        t = data;
        for(i = 0; i < height; i++) {
            v = rowdata[i];
            for(j = 0; j < width; j += 8) {
                *t++ = v;
                v >>= 8;
            }
        }
        p = XCreateBitmapFromData(stddpy, stdpix, data, width, height);
        XSetStipple(stddpy, stdgc, p);
        XSync(stddpy, False);
        XFreePixmap(stddpy, p);
    }

    t = salloc(name);
    if (wc->patternname)
        free(wc->patternname);
    wc->patternname = t;
   
    return Succeeded;
}

int raisewindow(wbp w)
{
    XEvent event;
    XWindowAttributes attr;

    wsp ws = w->window;
    if (ws->win) {
        XMapRaised(ws->display->display, ws->win);

        /* Wait for the window to become viewable before giving
           it the focus. */
        for (;;) {
            XGetWindowAttributes(ws->display->display, ws->win, &attr);
            if (attr.map_state == IsViewable)
                break;
            /* Not viewable yet, so wait for a MapNotify event. */
            XWindowEvent(ws->display->display, 
                         ws->win,
                         StructureNotifyMask, 
                         &event);
        }

        /* Now it is viewable, so give it the focus. */
        XSetInputFocus(ws->display->display, ws->win, RevertToParent, CurrentTime);
    }
    return Succeeded;
}

int lowerwindow(wbp w)
{
    if (w->window->win)
        XLowerWindow(w->window->display->display, w->window->win);
    return Succeeded;
}

int walert(wbp w, int volume)
{
    STDLOCALS(w);
    XBell(stddpy, volume);    
    XFlush(stddpy);
    return Succeeded;
}

#ifdef HAVE_LIBXFT
int textwidth(wbp w, char *s, int n)
{
    XGlyphInfo	extents; 

    XftTextExtents8 (w->window->display->display,
                     w->context->font->fsp,
                     (FcChar8 *)s,
                     n,
                     &extents);
    return extents.xOff;
}

int utf8width(wbp w, char *s, int n, int nchars)
{
    XGlyphInfo	extents; 

    XftTextExtentsUtf8 (w->window->display->display,
                        w->context->font->fsp,
                        (FcChar8 *)s,
                        n,
                        &extents);
    return extents.xOff;
}


void drawstring(wbp w, int x, int y, char *str, int slen)
{
    XftColor color;
    Region r;
    XRectangle rec;
    STDLOCALS(w);

    if (ws->win && !ws->winDraw)
        ws->winDraw = XftDrawCreate(ws->display->display,
                                    ws->win,
                                    ws->vis,
                                    ws->display->cmap);

    if (!ws->pixDraw)
        ws->pixDraw = XftDrawCreate(ws->display->display,
                                    ws->pix,
                                    ws->vis,
                                    ws->display->cmap);
    color.pixel = wc->fg->c;
    color.color.red = wc->fg->r;
    color.color.green = wc->fg->g;
    color.color.blue = wc->fg->b;
    color.color.alpha = 0xffff;

    if (wc->clipw >= 0 && wc->cliph >=0) {
        r = XCreateRegion();
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XUnionRectWithRegion(&rec, r, r);
        if (ws->winDraw) 
            XftDrawSetClip(w->window->winDraw, r);
        if (ws->pixDraw) 
            XftDrawSetClip(w->window->pixDraw, r);
        XDestroyRegion(r);
    } else {
        if (ws->winDraw) 
            XftDrawSetClip(w->window->winDraw, 0);
        if (ws->pixDraw) 
            XftDrawSetClip(w->window->pixDraw, 0);
    }

    if (ws->winDraw)
        XftDrawString8 (ws->winDraw,
                        &color,
                        wc->font->fsp,
                        x,
                        y,
                        (FcChar8 *)str,
                        slen);

    if (ws->pixDraw)
        XftDrawString8 (ws->pixDraw,
                        &color,
                        wc->font->fsp,
                        x,
                        y,
                        (FcChar8 *)str,
                        slen);
}

void drawutf8(wbp w, int x, int y, char *str, int slen, int nchars)
{
    XftColor color;
    Region r;
    XRectangle rec;
    STDLOCALS(w);

    if (ws->win && !ws->winDraw)
        ws->winDraw = XftDrawCreate(ws->display->display,
                                    ws->win,
                                    ws->vis,
                                    ws->display->cmap);

    if (!ws->pixDraw)
        ws->pixDraw = XftDrawCreate(ws->display->display,
                                    ws->pix,
                                    ws->vis,
                                    ws->display->cmap);
    color.pixel = wc->fg->c;
    color.color.red = wc->fg->r;
    color.color.green = wc->fg->g;
    color.color.blue = wc->fg->b;
    color.color.alpha = 0xffff;

    if (wc->clipw >= 0 && wc->cliph >=0) {
        r = XCreateRegion();
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XUnionRectWithRegion(&rec, r, r);
        if (ws->winDraw) 
            XftDrawSetClip(w->window->winDraw, r);
        if (ws->pixDraw) 
            XftDrawSetClip(w->window->pixDraw, r);
        XDestroyRegion(r);
    } else {
        if (ws->winDraw) 
            XftDrawSetClip(w->window->winDraw, 0);
        if (ws->pixDraw) 
            XftDrawSetClip(w->window->pixDraw, 0);
    }

    if (ws->winDraw)
        XftDrawStringUtf8 (ws->winDraw,
                           &color,
                           wc->font->fsp,
                           x,
                           y,
                           (FcChar8 *)str,
                           slen);

    if (ws->pixDraw)
        XftDrawStringUtf8 (ws->pixDraw,
                           &color,
                           wc->font->fsp,
                           x,
                           y,
                           (FcChar8 *)str,
                           slen);
}
#else
int textwidth(wbp w, char *s, int n)
{
    return XTextWidth(w->context->font->fsp, s, n);
}

int utf8width(wbp w, char *s, int n, int nchars)
{
    return textwidth(w, s, n);
}

void drawstring(wbp w, int x, int y, char *s, int slen)
{ 
    STDLOCALS(w); 
    RENDER4(XDrawString, x, y, s, slen); 
}
void drawutf8(wbp w, int x, int y, char *s, int slen, int nchars)
{
    STDLOCALS(w); 
    RENDER4(XDrawString, x, y, s, slen);
}
#endif            /* HAVE_LIBXFT */

/*
 * allocate a display on machine s
 */
static wdp alcdisplay(char *s)
{
    wdp wd;

    if (s == NULL) s = getenv("DISPLAY");
    if (s == NULL) s = "";
    for(wd = wdsplys; wd; wd = wd->next)
        if (wd->program == curpstate && !strcmp(wd->name,s)) {
            wd->refcount++;
            return wd;
        }

    GRFX_ALLOC(wd, _wdisplay);

    strcpy(wd->name,s);
    wd->program = curpstate;
    wd->display = XOpenDisplay((*s=='\0') ? NULL : s);
    if (wd->display == NULL) {
        LitWhy("Couldn't connect to display");
        free(wd);
        return NULL;
    }

    wd->screen = DefaultScreen(wd->display);
    wd->black = new_sharedcolor("black", 0, 0, 0);
    wd->white = new_sharedcolor("white", 65535, 65535, 65535);
    wd->cmap = DefaultColormap(wd->display, wd->screen);
    wd->defaultfont = loadfont(wd, getdefaultfont());
    if (wd->defaultfont == NULL) {
        unlink_sharedcolor(wd->white);
        unlink_sharedcolor(wd->black);
        free(wd);
        LitWhy("Couldn't load default font");
        return NULL;
    }
#ifdef HAVE_LIBXFT
    wd->xfont = XLoadQueryFont(wd->display, "fixed");
#endif
    GRFX_LINK(wd, wdsplys);
    return wd;
}

#ifdef HAVE_LIBXFT

/*
 * Convert a given font spec, which may or may not be in icon font spec format,
 * into fontconfig (used by Xft) style format.  The result is never null.
 * 
 * To avoid ambiguity, a spec can start with "fc:" to indicate it's in fontconfig
 * format; otherwise parsefont is called to decide the format.
 */
static char *convertspec(wdp wd, char *s)
{
    static char res[256];
    int flags, size;
    char family[MAXFONTWORD];
    XftPattern *p;

    if (!strncmp(s, "fc:", 3))
        return s + 3;

    if (!parsefont(s, family, &flags, &size))
        return s;

    p = XftPatternCreate();

    /*
     * Check first for special "standard" family names.
     */
    if (!strcmp(family, "fixed")) {
        XftPatternAddString(p, XFT_FAMILY, "Object Icon fixed");
        XftPatternAddString(p, XFT_FAMILY, "mono");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "mono")) {
        XftPatternAddString(p, XFT_FAMILY, "Object Icon mono");
        XftPatternAddString(p, XFT_FAMILY, "mono");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "typewriter")) {
        XftPatternAddString(p, XFT_FAMILY, "Object Icon typewriter");
        XftPatternAddString(p, XFT_FAMILY, "courier");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "sans")) {
        XftPatternAddString(p, XFT_FAMILY, "Object Icon sans");
        XftPatternAddString(p, XFT_FAMILY, "helvetica");
        flags |= FONTFLAG_PROPORTIONAL;
    }
    else if (!strcmp(family, "serif")) {
        XftPatternAddString(p, XFT_FAMILY, "Object Icon serif");
        XftPatternAddString(p, XFT_FAMILY, "times");
        flags |= FONTFLAG_PROPORTIONAL;
    }
    else
        XftPatternAddString(p, XFT_FAMILY, family);

    if (size > 0)
        XftPatternAddDouble(p, XFT_SIZE, (double)size);
    else {
        /* Only use a default font size if explicitly set via OIFONTSIZE */
        int t = getdefaultfontsize(-1);
        if (t > 0)
            XftPatternAddDouble(p, XFT_SIZE, (double)t);
    }
    if (flags & FONTFLAG_MEDIUM)
        XftPatternAddInteger(p, XFT_WEIGHT, XFT_WEIGHT_MEDIUM);
    else if ((flags & FONTFLAG_DEMI) && (flags & FONTFLAG_BOLD))
        XftPatternAddInteger(p, XFT_WEIGHT, XFT_WEIGHT_DEMIBOLD);
    else if (flags & FONTFLAG_BOLD)
        XftPatternAddInteger(p, XFT_WEIGHT, XFT_WEIGHT_BOLD);
    else if (flags & FONTFLAG_LIGHT)
        XftPatternAddInteger(p, XFT_WEIGHT, XFT_WEIGHT_LIGHT);

    if (flags & FONTFLAG_ITALIC)
        XftPatternAddInteger(p, XFT_SLANT, XFT_SLANT_ITALIC);
    else if (flags & FONTFLAG_OBLIQUE)
        XftPatternAddInteger(p, XFT_SLANT, XFT_SLANT_OBLIQUE);
    else if (flags & FONTFLAG_ROMAN)
        XftPatternAddInteger(p, XFT_SLANT, XFT_SLANT_ROMAN);

    if (flags & FONTFLAG_PROPORTIONAL)
        XftPatternAddInteger(p, XFT_SPACING, XFT_PROPORTIONAL);
    if (flags & FONTFLAG_MONO)
        XftPatternAddInteger(p, XFT_SPACING, XFT_MONO);

    XftNameUnparse(p, res, sizeof(res) - 1);
    XftPatternDestroy(p);

    return res;
}

#else /* HAVE_LIBXFT */

static char *convertspec(wdp wd, char *s)
{
    int flags, size;
    char *rv = 0;
    char family[MAXFONTWORD];
    char *stdfam;

    /* Explicit X11 font name */
    if (!strncmp(s, "x11:", 4))
        return s + 4;

    if (!parsefont(s, family, &flags, &size))
        return s;

    /*
     * This is a legal Icon font spec.  Check first for special
     * "standard" family names.
     */
    if (!strcmp(family, "fixed")) {
        stdfam = "fixed";
        flags |= FONTFLAG_MONO + FONTFLAG_SANS;
    } 
    else if (!strcmp(family, "mono")) {
        stdfam = "lucidatypewriter";
        flags |= FONTFLAG_MONO + FONTFLAG_SANS;
    }
    else if (!strcmp(family, "typewriter")) {
        stdfam = "courier";
        flags |= FONTFLAG_MONO + FONTFLAG_SERIF;
    }
    else if (!strcmp(family, "sans")) {
        stdfam = "helvetica";
        flags |= FONTFLAG_PROPORTIONAL + FONTFLAG_SANS;
    }
    else if (!strcmp(family, "serif")) {
        stdfam = "times";
        flags |= FONTFLAG_PROPORTIONAL + FONTFLAG_SERIF;
    }
    else stdfam = NULL;

    if (stdfam) {
        /*
         * Standard name: first try preferred family, then generalize.
         */
        rv = findfont(wd, stdfam, size, flags);
        if (!rv)
            rv = findfont(wd, "*", size, flags);
    }
    else {
        /*
         * Any other name: must match as specified.
         */
        rv = findfont(wd, family, size, flags);
    }
    if (rv)
        return rv;

    /*
     * Not found as an Icon name; may be an X font name.
     */
    return s;
}

/*
 * return pointer to field i inside XLFD (X Logical Font Description) s.
 */
static char *xlfd_field(char *s, int i)
{
    int j = 0;
    while (j < i) {
        if (*s == '\0') return "";	/* if no such field */
        if (*s++ == '-') j++;
    }
    return s;
}

/*
 * return size of font, treating a scalable font as having size n
 */
static int xlfd_size(char *s, int n)
{
    char *f;
    int z;

    f = xlfd_field(s, XLFD_Size);
    if (!*f)
        return 0;
    z = atoi(f);
    if (z != 0)
        return z;
    else
        return n;
}

/*
 * Find the best font matching a set of specifications.
 */
static char *findfont(wdp wd, char *family, int size, int flags)
{
    static char fontspec[MAXFONTWORD+100];
    char *p, *weight, *slant, *width, *spacing, **fontlist;
    int n, champ, challenger, bestsize;

    /*
     * Construct a font specification that enforces any stated requirements
     * of size, weight, slant, set width, or proportionality.
     */
    if (size > 0)
        bestsize = size;
    else
        bestsize = getdefaultfontsize(14);

    if (flags & FONTFLAG_MEDIUM)
        weight = "medium";
    else if ((flags & FONTFLAG_DEMI) && (flags & FONTFLAG_BOLD))
        weight = "demibold";
    else if (flags & FONTFLAG_BOLD)
        weight = "bold";
    else if (flags & FONTFLAG_DEMI)
        weight = "demi";
    else if (flags & FONTFLAG_LIGHT)
        weight = "light";
    else
        weight = "*";

    if (flags & FONTFLAG_ITALIC)
        slant = "i";
    else if (flags & FONTFLAG_OBLIQUE)
        slant = "o";
    else if (flags & FONTFLAG_ROMAN)
        slant = "r";
    else
        slant = "*";

    if (flags & FONTFLAG_NARROW)
        width = "narrow";
    else if (flags & FONTFLAG_CONDENSED)
        width = "condensed";
    else if (flags & FONTFLAG_NORMAL)
        width = "normal";
    else if (flags & FONTFLAG_WIDE)
        width = "wide";
    else if (flags & FONTFLAG_EXTENDED)
        width = "extended";
    else
        width = "*";

    if (flags & FONTFLAG_PROPORTIONAL)
        spacing = "p";
    else
        spacing = "*";			/* can't specify {m or c} to X */

    if (size > 0)
        sprintf(fontspec, "-*-%s-%s-%s-%s-*-%d-*-*-*-%s-*-*-*",
                family, weight, slant, width, size, spacing);
    else
        sprintf(fontspec, "-*-%s-%s-%s-%s-*-*-*-*-*-%s-*-*-*",
                family, weight, slant, width, spacing);

    /*
     * Get a list of matching fonts from the X server and find the best one.
     */
    fontlist = XListFonts(wd->display, fontspec, 2500, &n);
    champ = 0;
    while (champ < n && !okfont(fontlist[champ], flags))
        champ++;
    if (champ >= n) {
        XFreeFontNames(fontlist);
        return NULL;			/* nothing acceptable */
    }
    for (challenger = champ + 1; challenger < n; challenger++) 
        if (okfont(fontlist[challenger], flags)
            && fontcmp(fontlist[challenger], fontlist[champ], bestsize, flags) < 0)
            champ = challenger;

    /*
     * Set the scaling field, if needed, and load the font.
     */
    p = xlfd_field(fontlist[champ], XLFD_Size);
    if (p[0] == '0' && p[1] == '-')
        sprintf(fontspec, "%.*s%d%s", (int)(p - fontlist[champ]),
                fontlist[champ], bestsize, p + 1);
    else
        strcpy(fontspec, fontlist[champ]);
    XFreeFontNames(fontlist);
    return fontspec;
}

/*
 * check for minimum acceptability of a font
 * (things that couldn't be filtered by the XLFD pattern):
 * -- not monospaced (can't set pattern to match m or c but not p)
 */
static int okfont(char *spec, int flags)
{
    if ((flags & FONTFLAG_MONO) && xlfd_field(spec, XLFD_Spacing)[0] == 'p')
        return 0;			/* requested mono, but this isn't */
    return 1;
}

/*
 * rank two fonts based on whether XLFD field n matches a preferred value.
 * returns <0 if font1 is better, >0 if font2 is better, else 0.
 */
static int fieldcmp(char *font1, char *font2, char *value, int field)
{
    int len, r1, r2;

    len = strlen(value);
    r1 = (strncmp(xlfd_field(font1, field), value, len) == 0);
    r2 = (strncmp(xlfd_field(font2, field), value, len) == 0);
    return r2 - r1;			/* -1, 0, or 1 */
}

/*
 * rank two fonts.
 * returns <0 if font1 is better, >0 if font2 is better, else 0.
 *
 * Note that explicit requests for size, slant, weight, and width caused
 * earlier filtering in findfont(), so all those flags aren't checked
 * again here; normal values are just favored in case nothing was specified.
 */
static int fontcmp(char *font1, char *font2, int size, int flags)
{
    int n;

/* return if exactly one of the fonts matches value s in field n */
#define PREFER(s,n)                                                     \
    do { int r = fieldcmp(font1, font2, s, n); if (r != 0) return r; } while (0)

/* return if exactly one of the fonts does NOT match value s in field n */
#define SPURN(s,n)                                                      \
    do { int r = fieldcmp(font1, font2, s, n); if (r != 0) return -r; } while (0)

    /*
     * Prefer the font that is closest to the desired size.
     */
    n = abs(size - xlfd_size(font1, size)) - abs(size - xlfd_size(font2, size));
    if (n != 0)
        return n;

    /*
     * try to check serifs (though not always indicated in X font description)
     */
    if (flags & FONTFLAG_SANS) {
        PREFER("sans", XLFD_AddStyle);
        SPURN("serif", XLFD_AddStyle);
    }
    else if (flags & FONTFLAG_SERIF) {
        PREFER("serif", XLFD_AddStyle);
        SPURN("sans", XLFD_AddStyle);
    }

    /*
     * prefer normal values for other fields.  These only have an effect
     * for fields that were wildcarded when requesting the font list.
     */
    PREFER("r", XLFD_Slant);		/* prefer roman slant */
    PREFER("medium", XLFD_Weight);	/* prefer medium weight */
    SPURN("demi", XLFD_Weight);		/* prefer non-demi if no medium */
    PREFER("normal", XLFD_SetWidth);	/* prefer normal width */
    PREFER("iso8859", XLFD_CharSet);	/* prefer font of ASCII chars */
    SPURN("0", XLFD_AverageWidth);	/* prefer tuned font to scaled */
    PREFER("adobe", XLFD_Foundry);	/* these look better than others */

    /* no significant difference */
    return 0;
}


#endif /* HAVE_LIBXFT */


/*
 * load a font and return a font structure.
 */

static wfp loadfont(wdp wd, char *s)
{
    wfp rv;

    /*
     * Convert to a system font name (without the fc: or x11: prefix)
     */
    s = convertspec(wd, s);

    /*
     * see if the font is already loaded on this display
     */
    for(rv = wd->fonts; rv; rv = rv->next) {
#ifdef HAVE_LIBXFT
        if (!strcmp(s, rv->name + 3)) return rv;
#else
        if (!strcmp(s, rv->name + 4)) return rv;
#endif
    }

    /*
     * load a new font
     */
    rv = newfont(wd, s);
    if (rv == NULL)
        return NULL;

    /*
     * link the font into this display's fontlist
     */
    GRFX_LINK(rv, wd->fonts);
    return rv;
}

static wfp newfont(wdp wd, char *s)
{
    wfp rv;
    GRFX_ALLOC(rv, _wfont);
#ifdef HAVE_LIBXFT
    rv->fsp = XftFontOpenName(wd->display, wd->screen, s);
#else
    rv->fsp = XLoadQueryFont(wd->display, s);
#endif
    if (rv->fsp == NULL){
        free(rv);
        return NULL;
    }

#ifdef HAVE_LIBXFT
    MemProtect(rv->name = malloc(strlen(s) + 3 + 1));
    sprintf(rv->name, "fc:%s", s);
    {
        XGlyphInfo	extents; 
        /*
         * Xft seems to sometimes give too-small values in its font
         * ascent/descent fields; therefore calculate the GlyphInfo
         * for the first 256 chars and take the maximum ascent/descent
         * of the sample and the font's reported values.
         */
        XftTextExtents8 (wd->display,
                         rv->fsp,
                         (FcChar8 *)allchars,
                         256,
                         &extents);
        rv->ascent = Max(rv->fsp->ascent, extents.y);
        rv->descent = Max(rv->fsp->descent, extents.height - extents.y);
        rv->maxwidth = rv->fsp->max_advance_width;
    }
#else
    MemProtect(rv->name = malloc(strlen(s) + 4 + 1));
    sprintf(rv->name, "x11:%s", s);
    rv->ascent = rv->fsp->ascent;
    rv->descent = rv->fsp->descent;
    rv->maxwidth = rv->fsp->max_bounds.width;
#endif
    rv->height = rv->ascent + rv->descent;
    return rv;
}


/*
 * allocate a context.  Can't be called until w has a display and window.
 */
static wcp alccontext(wbp w)
{
    wcp wc;
    wdp wd = w->window->display;

    GRFX_ALLOC(wc, _wcontext);
    wc->display = wd;
    wd->refcount++;
    wc->bg = link_sharedcolor(wd->white);
    wc->fg = link_sharedcolor(wd->black);
    wc->font = wd->defaultfont;
    wc->drawop = stringint_lookup(drawops, "copy");
    wc->clipx = wc->clipy = 0;
    wc->clipw = wc->cliph = -1;
    wc->linewidth = 1;
    wc->fillstyle = stringint_lookup(fillstyles, "solid");
    wc->linestyle = stringint_lookup(linestyles, "solid");

    GRFX_LINK(wc, wcntxts);
    return wc;
}

/*
 * allocate a context, cloning attributes from an existing context
 */
wcp clonecontext(wbp w)
{
    wcp wc, rv;
    wdp wd;
    XGCValues gcv;
    XRectangle rec;
    unsigned long gcmask = GCFont | GCForeground | GCBackground |
        GCFillStyle | GCCapStyle | GCLineWidth | GCLineStyle;

    wc = w->context;
    wd = w->context->display;
    rv = alccontext(w);

    rv->dx = wc->dx;
    rv->dy = wc->dy;
    rv->clipx = wc->clipx;
    rv->clipy = wc->clipy;
    rv->clipw = wc->clipw;
    rv->cliph = wc->cliph;
    rv->fg = link_sharedcolor(wc->fg);
    rv->bg = link_sharedcolor(wc->bg);
    rv->font = wc->font;
    rv->fillstyle = wc->fillstyle;
    rv->linestyle = wc->linestyle;
    rv->linewidth = wc->linewidth;
    rv->drawop = wc->drawop;
    rv->bits = wc->bits;

    gcv.foreground = rv->fg->c;
    gcv.background = rv->bg->c;
#ifdef HAVE_LIBXFT
    gcv.font       = wd->xfont->fid;
#else
    gcv.font       = rv->font->fsp->fid;
#endif
    gcv.line_style = rv->linestyle->i;
    gcv.line_width = rv->linewidth;
    if (rv->linewidth > 1) {
        gcv.dashes = 3 * rv->linewidth;
        gcmask |= GCDashList;
    }
    gcv.fill_style = rv->fillstyle->i;
    gcv.cap_style  = CapProjecting;
    rv->gc = XCreateGC(w->window->display->display,w->window->pix,gcmask,&gcv);
    if (rv->clipw >= 0) {
        rec.x = rv->clipx;
        rec.y = rv->clipy;
        rec.width = rv->clipw;
        rec.height = rv->cliph;
        XSetClipRectangles(rv->display->display, rv->gc, 0, 0, &rec, 1,Unsorted);
    }
    if (wc->patternname)
        rv->patternname = salloc(wc->patternname);
    return rv;
}

/*
 * allocate a window state structure
 */
static wsp alcwinstate()
{
    wsp ws;
    GRFX_ALLOC(ws, _wstate);
    ws->listp = nulldesc;
    ws->buttonorder[0] = 1;
    ws->buttonorder[1] = 2;
    ws->buttonorder[2] = 4;
    ws->cursor = stringint_lookup(cursors, "left ptr");
    ws->state = NormalState;
    ws->x = ws->y = -INT_MAX;
    ws->minwidth = ws->minheight = 1;
    ws->maxwidth = ws->maxheight = INT_MAX;
#ifdef HAVE_LIBXFT
    ws->pixDraw = ws->winDraw = NULL;
#endif
    ws->height = 200;
    ws->width  = 200;
    ws->windowlabel = salloc(DEFAULT_WINDOW_LABEL);
    GRFX_LINK(ws, wstates);
    return ws;
}

/*
 * free a window state
 */
void freewindow(wsp ws)
{
    ws->refcount--;
    if(ws->refcount == 0) {
        struct imgdata *imd;

        ws->bits |= 1;			/* SETZOMBIE */
#ifdef HAVE_LIBXFT
        if (ws->winDraw) {
            XftDrawDestroy(ws->winDraw);
            ws->winDraw = NULL;
        }
        if (ws->pixDraw) {
            XftDrawDestroy(ws->pixDraw);
            ws->pixDraw = NULL;
        }
#endif
        if (ws->win != (Window) NULL) {
            XDestroyWindow(ws->display->display, ws->win);
            XFlush(ws->display->display);
            while (ws->win != (Window) NULL)
                pollevent();
        }
        else {
            /*
             * There was no XDestroyWindow, so it is necessary
             * to free the Pixmap here, as it won't be freed via
             * a DestroyNotify event.
             */
            if (ws->pix != (Pixmap) NULL) {
                Display *d = ws->display->display;
                XFreePixmap(d, ws->pix);
                ws->pix = (Pixmap) NULL;
            }
        }

        imd = &ws->initimage;
        if (imd->width) {
            free(imd->paltbl);
            free(imd->data);
            imd->width = 0;
        }

       if (ws->windowlabel) { 
           free(ws->windowlabel); 
           ws->windowlabel = 0;
       }

        GRFX_UNLINK(ws, wstates);
    }
}

/*
 * free a window context
 */
void freecontext(wcp wc)
{
    wc->refcount--;
    if(wc->refcount == 0) {
        if (wc->gc != NULL)
            XFreeGC(wc->display->display, wc->gc);
        if (wc->patternname)
            free(wc->patternname);
        if (wc->fg)
            unlink_sharedcolor(wc->fg);
        if (wc->bg)
            unlink_sharedcolor(wc->bg);
        GRFX_UNLINK(wc, wcntxts);
    }
}

int  readimagefileimpl(char *filename, struct imgdata *imd) 
{
    return NoCvt;
}

int  writeimagefileimpl(wbp w, char *filename, int x, int y, int width, int height)
{
    return NoCvt;
}


#endif            /* Graphics */
