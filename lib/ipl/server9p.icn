package ipl.plan9

import plan9, io, posix, ipl.options

procedure server_main_1(a, sess, run)
   local opts
   opts := options(a, "-v! -s!")
   if *a = 0 then
      stop("usage: ", Files.get_path(&progname).get(-1), " [opts] mountpt/srvpt")
   server_main(a[1], "", opts, sess, run)
end

procedure server_main_2(a, sess, run)
   local opts, attach
   opts := options(a, "-v! -s!")
   if (*a = 0) | (/opts["s"] & (*a < 2)) then
      stop("usage: ", Files.get_path(&progname).get(-1), " [opts] mountpt attach/srvpt")
   attach := a[2] | ""
   server_main(a[1], attach, opts, sess, run)
end

procedure server_main(where, attach, opts, sess, run)
   local p, pid, pname
   pname := Files.get_path(&progname).get(-1)
   /run := sess.io
   p := FileStream.pipe() | stop(&why)
   pid := System.fork(ior(ForkOpt.RFPROC, ForkOpt.RFFDG, ForkOpt.RFNAMEG, ForkOpt.RFNOTEG)) | stop(&why)
   if pid = 0 then {
      p[1].close()
      if \opts["v"] then 
         sess.set_verbose(&yes)
      run(p[2])
      if \opts["v"] then 
         sess.dump()
      ewrite(pname, ": exit")
      p[2].close()
   } else {
      sess := &null
      p[2].close()
      if \opts["s"] then {
         Files.string_to_file("/srv/" || where, p[1].get_fd()) | stop(&why)
         ewrite(pname, ": serving on /srv/", where)
      } else {
         Files.mount(p[1], &null, where, ior(MountOpt.MREPL, MountOpt.MCREATE), attach) | stop(&why)
         ewrite(pname, ": mounted on ", where)
      }
      p[1].close()
   }
   exit()
end

procedure async_sched_loop(sess, sched, f)
   local nb
   use {
      nb := NonBlockStream(f).set_close_underlying(&no),
      {
         sess.async_io(sched, nb)
         # Main loop
         until sched.empty() do
            sched.work() | delay(50)
      }
   }
end

# A file in which writes append to the end of the content, whilst
# reads consume from the start.  In both read and write, position is
# ignored.
#
class FifoFile9P(Regular9P)
   private readable
      data

   public open(mode)
      if iand(self.perm, Mode9.DMAPPEND) = 0 &
         iand(mode, FileOpt9.OTRUNC) ~= 0 then
         data := ""
      return self
   end

   public set_length(len)
      if len > *data then
         data ||:= repl("\0", len - *data)
      else
         data := data[1+:len]
      return self
   end

   public write(s, pos)
      data ||:= s
      return *s
   end

   public read(pos, count)
      local s
      data ? {
         s := move(count) | tab(0)
         data := tab(0)
      }
      return s
   end

   public get_length()
      return *data
   end

   public set_data(s)
      s := string(s) | runerr(103, s)
      data := s
      return self
   end

   public new()
      cast(self,Regular9P).new()
      data := ""
      return
   end
end

# A file in which the content is split into a queue of messages.
# Writes append to the end, whilst reads consume from the start.
# Reads never consume more than one messge in the queue.
#
class QueueFile9P(Regular9P)
   private
      q
   private readable
      len

   public open(mode)
      if iand(self.perm, Mode9.DMAPPEND) = 0 &
         iand(mode, FileOpt9.OTRUNC) ~= 0 then
         clear()
      return self
   end

   public write(s, pos)
      add(s)
      return *s
   end

   public read(pos, count)
      local s
      if *q = 0 then
         return
      s := pop(q)
      if *s > count then {
         s ? {
            s := move(count)
            push(q, tab(0))
         }
      }
      len -:= *s
      return s
   end

   public set_length(n)
      local s
      if n <= 0 then
         clear()
      else if n > len then
         add(repl("\0", n - len))
      else {
         while len - *q[-1] >= n do {
            s := pull(q)
            len -:= *s
         }
         if len > n then {
            # 0 < len-n  < *q[-1]
            q[-1][0 -: len - n] := ""
            len := n
         }
      }
      return self
   end

   public get_length()
      return .len
   end

   public clear()
      q := []
      len := 0
      return self
   end

   public get_queue_length()
      return *q
   end

   public get_content()
      local s
      s := ""
      every s ||:= !q
      return s
   end

   public add(s)
      s := string(s) | runerr(103, s)
      if *s > 0 then {
         len +:= *s
         put(q, s)
      }
      return self
   end

   public remove()
      local s
      if *q > 0 then {
         s := pop(q)
         len -:= *s
         return s
      }
   end

   public new()
      cast(self,Regular9P).new()
      clear()
      return
   end
end
