% -*-texinfo-*-
\input texinfo

@setfilename out

@copying
This documentation is in the public domain.
@end copying

@dircategory Programming Languages
@direntry
* Object Icon: (objecticon).       An object-oriented version of the Icon programming language
@end direntry

@finalout

@titlepage
@title Object Icon
@subtitle Introduction
@author R Parlett (r.parlett@@gmail.com)

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@ifnottex
@node Top
@top Object Icon

@unnumbered Object Icon
Object Icon is an object-oriented extension of the Icon programming
language. Some of the main features are :-

@itemize @bullet
@item Multiple inheritance
@item Static and instance variables and methods
@item Access modifiers: public, private, protected, package, final and readable.
@item Constants, with automatic initialization.
@item Package/namespace system
@end itemize
@end ifnottex
@menu
* Installation::                
* Overview::                    Read for a smoother start
* Classes and Objects::         Detailed info about the OO side of Object Icon
* Packages::                    Packaging several files together
* Runtime information about objects and classes::  
* Library::                     Object Icon libraries and the IPL
* Makefiles::                   
* Dynamically loading C/RTL code::  
* Dynamically loading Icon code::  
* Differences - Icon::          Differences between Object Icon and Icon
* Differences - Unicon::        Differences between Object Icon and Unicon

* Emacs mode::                  
* Key Index::                   Index of Vi and Ex Commands
* Function Index::              Index of Viper Functions
* Variable Index::              Index of Viper Variables
* Package Index::               Index of Packages Mentioned in this Document
* Concept Index::               Vi, Ex and Emacs concepts

* Acknowledgments::             
@end menu

@node Installation
@chapter Installation


Object Icon uses autoconf for its configuration.  


@menu
* Installing from the subversion source repository::  
* Installing from a .tar.gz file::  
* Compilation_::                
@end menu

@node Installing from the subversion source repository
@section Installing from the subversion source repository
To do this you need autoconf installed (at least version 2.61).

Use the following command to checkout a read-only copy of the source code :-

@code{svn co http://objecticon.googlecode.com/svn/trunk/ objecticon}

This will create a directory @code{objecticon} under the present
directory (you can change the last parameter to create a different
directory name if you want).

Then cd into that directory and run the command @code{autoconf}.  This will
create a @code{configure} script.

Then proceed just the same as if you had downloaded the .tar.gz file.
@node Installing from a .tar.gz file
@section Installing from a .tar.gz file
Extract the source code from the .tar.gz file with a command like
@code{tar xfz objecticon-1.0.tar.gz}.  This will create a directory
@code{objecticon-1.0} under the current directory.  Obviously the
version number may be different.

Change to the new directory and run @code{./configure}.  This
command accepts various options - run @code{./configure --help} to
see them.  The @code{./configure} script prints a summary of
the options when it finishes, for example.

@example
Summary:-
X11 graphics           : yes
jpeg library           : yes
Xft anti-aliased fonts : yes
Xpm                    : yes
zlib compression       : yes
dynamic loading        : yes
crypt lib              : yes
makeinfo >=4.8         : yes
mysql lib              : yes
context switch         : config/system/linux_x86/rswitch.s
@end example

The meaning of these various options is as follows.

@itemize @bullet
@item X11 graphics
Determines whether the Icon graphics facilities are built.  The
following three options only apply if this is 'yes'.
@item jpeg library
Allows loading of jpeg images.
@item Xft anti-aliased fonts
Fonts are drawn with smooth edges using the xft and freetype libraries.
This looks nice, but is considerably slower than using traditional X
bitmap fonts.
@item Xpm
Allows loading of xpm images.
@item zlib compression
Allows zlib compressed files (ie .gz files), to be read/written via the
"z" flag in the open function.  Also allows icode files to be compressed
with the -Z flag given to the @code{oit}.
@item dynamic loading
Allows shared library (.so) files containing native functions to be
loaded at runtime.
@item crypt lib
This just enables the builtin crypt() function.
@item mysql lib
Allows a dynamic library to be built which provides an interface to
mysql.  Has no effect either way on the runtime system proper.
@item makeinfo
This allows the texinfo and html documentation to be built.
@item context switch
This is a system-dependent source file which is used by co-expressions.  If the
value is @code{config/system/default/rswitch.c}, then co-expressions will not be
functional (activation will end with a runtime error).
@end itemize

@node Compilation_
@section Compilation_
GNU make is required for compilation.  Just run make (or gmake) in the
top-level directory.



@node Overview
@chapter Overview

@node Classes and Objects
@chapter Classes and Objects
@menu
* Classes and Objects - Introduction::  A brief intro 
* Fields::                      The different types of field in a class
* Inheritance::                 Inheritance in Object Icon
* Field modifiers::             Indicate access and other attributes of a field
* Method pointers::             How instance methods work
* Casts::                       Accessing overridden methods
* The init() method::           Called during class initialization 
* The new() method::            Called during object creation
* Deferred methods::            Methods with no body
@end menu
@node Classes and Objects - Introduction
@section Introduction
 
 The basic format for a class is
@example
[final] class <classname> ( <superclasses> )
        <field definitions>
end
@end example
The field definitions are either variables or methods.  Each definition
starts with the access modifiers, which specify who may access the
field, and how it may be accessed.  Typical variable declarations are :-
@example
private x, y                    # Private instance variables
public static const PI          # A constant, accessible anywhere
private readable z              # A private variable, but accessible read-only from outside
@end example
The meaning of the various modifiers is explained in detail later.
 
A method definition looks like :-
@example
# A public instance method
public set_loc(x, y)
   self.x := x
   self.y := y
end

# A static method accessible without an instance
public static origin()
   return Point(0,0)
end
@end example
To bring these things together, here is a simple class definition to represent an x,y point :-
@example
class Point()
   public const x, y
   public static const ORIGIN

   private static init()
      ORIGIN := Point(0, 0)
   end

   # Radius of a circle on which this point lies
   public radius()
      return sqrt(x * x + y * y)
   end

   # Distance between two points
   public static distance(p1, p2)
      return sqrt((p1.x - p2.x) ^ 2 + (p1.y - p2.y) ^ 2)
   end

   public new(x, y)
      self.x := x
      self.y := y
      return
   end
end
@end example
The static init() method is used to initialize any static variables.
It is called automatically the first time the class is referenced.  The
new() method is similar, but is used to initialize instances - it is
called automatically every time a new object is created.  Some examples
of using the class :-
@example 
p1 := Point(-2, -3)
p2 := Point(4, 3)
write(Point.distance(p1, p2))
write(p2.radius())
write(Point.distance(p2, Point.ORIGIN))
@end example
One thing to note about the @code{Point} class is that it is immutable.  That
means that its state does not change once it has been created.  This is
achieved by declaring its two instance variables as "const".  The
following attempts to change these variables' values would cause a
runtime error :-
@example
p1.x := 100
Point.ORIGIN.y := 1
p1.new(3, 4)
@end example
The static field @code{ORIGIN} is also declared const.  That means that any
attempt to change its value would also cause a runtime error :-
@example
Point.ORIGIN := 1    # Run-time error
@end example
Naturally these const variables have to be assignable at some point in
order to be initialized.  For static variables, they are assignable
during class initialization (when the init method is called), and for
instance variables during object initialization (when the new method is
called).  Thereafter, the variables become "locked", and are no longer
assignable.
@node Fields
@section Fields
Every class has a set of fields, each of which has a unique name.  Some
of the fields may be defined in the class itself, but other may be
inherited from the class's superclasses: @xref{Inheritance}.

The fields can be divided into four basic categories.  Here is a class
with one field of each sort.
@example
class X()
   public a

   public static b

   public c(v)
        self.a := v
   end

   public static d()
   end
end
@end example
The field @code{a} is an instance variable.  That is, every instance of
@code{X} will have its own value of the field, accessed as follows :-
@example
x1 := X()
x1.a := 100
x2 := X()
x2.a := 99   # Distinct from x1.a
@end example
The field @code{b} is a static variable.  This means that there is only one value of the
variable in existence, and it is accessed via the class itself, rather than via any
instance :-
@example
X.b := 101
@end example
The field @code{c} is an instance method.  It doesn't take up any space in the instance, but it
is accessed in the same way as an instance variable :-
@example
x1 := X()
x1.c(40)
@end example
An instance method has an implicit parameter @code{self}, which refers
to the instance which was used to invoke the method (in the above
example, @code{x1}).  The means by which this @code{self} parameter is
passed into the method is quite subtle, and is described in more detail
in the section on @ref{Method pointers}.

Finally, the field @code{d} is a static method.  It doesn't have an
implicit @code{self} parameter, and is invoked via the class, rather
than an instance.  Instance variables and methods cannot be accessed
from inside a static method (an error on linking will be produced).
@example
X.d()
@end example
@node Inheritance
@section Inheritance
@menu
* Inheritance restrictions:: What's allowed
* Field name clashes:: When names collide
* Implemented classes::         All the things a class is
@end menu
Classes can inherit from multiple parent classes.  Fields of the parent
classes are "merged" into the resulting class using a breadth first
search.  For example, in the following situation
@example 
class X(A,B,C)
        ...
end
@end example
The fields of A, B and C are taken first, then the parents of A, B and
C and then the parents of the parents, and so on.  If a class is
encountered more than once during this process, it is simply ignored on
the second and subsequent occasions.
@node Inheritance restrictions
@subsection
There are some restrictions on what can be inherited, as follows.
@itemize @bullet
@item
You cannot inherit from a superclass declared as final.  For example,
this is not allowed :-
@example
final class Parent()
end

class Child(Parent)
end
@end example
@item
You can't override a method which was declared final.  For example, this
is not allowed :-
@example
class Parent()
   public final f()
   end
end

class Child(Parent)
   public f()
   end
end
@end example
@item
It may also happen that there is a disallowed name clash - @xref{Field name clashes}.
@end itemize
@node Field name clashes
@subsection Field name clashes
It may be that a field name is encountered more than once whilst
traversing the parent classes.  If this happens, then the first occurence is
always the one that is inherited into the resulting class.  However, a
compilation error may also be signalled.  This will happen UNLESS
@itemize @bullet
@item
the second and subsequent occurences are static, OR
@item
both the first and the subsequent occurences are instance methods.
@end itemize
Looked at from another viewpoint, this table shows the permissible combinations, with
an 'X' meaning disallowed and a '+' meaning allowed.

@multitable @columnfractions 0.2 0.2 0.2 0.2 0.2
@headitem First def'n @tab Instance var @tab Static var @tab Instance method @tab Static method
@item Subsequent def'n
@item Instance var @tab X @tab X @tab X @tab X
@item Static var @tab + @tab + @tab + @tab +
@item Instance method @tab X @tab X @tab + @tab X
@item Static method @tab + @tab + @tab + @tab +
@end multitable

For an example of a permissible clash, consider the following:-
@example
class Parent()
   public static x

   private static init()
      x := 100    # Meaning Parent.x := 100
   end
end

class Child(Parent)
   public x

   public new()
      x := 99     # Meaning self.x := 99
      return
   end
end

procedure main()
   local z
   z := Child()
   write(z.x) # -> 99
   write(Parent.x) # -> 100
end
@end example
Here, Child inherits the instance field "x" from its own definition.
The second static "x" still resides within the space reserved for it in
Parent, so there is no problem.  However, if we swap the declarations
around, then a problem arises :-
@example 
class Parent()
   public x

   public new()
      x := 99   # Meaning self.x  ... not okay, Child's x is static
      return
   end
end

class Child(Parent)
   static public x

   private static init()
      x := 100  # Meaning Child.x ... okay
   end
end

procedure main()
   local z
   z := Child()
end
@end example
If this program were allowed to compile, it wouldn't work because Child
would have a static field @code{x}, but the reference to @code{x} in @code{x := 99}
would attempt to assign to @code{self.x}, ie a non-existent instance field.
This would cause a runtime error.
@node Implemented classes
@subsection Implemented classes


@node Field modifiers
@section Field modifiers
@menu
* private::                     Fields accessible in defining class only
* public::                      Fields accessible anywhere
* package::                     Fields accessible in same package
* protected::                   Fields accessible in same class hierarchy
* static::                      Fields with one instance only
* const::                       Constant read-only fields
* readable::                    Allow extra read-only access
* final::                       Prevents overriding
@end menu

Here are the various modifiers which can be applied to a field.

@node private
@subsection private access
A private field can only be accessed from within a method in the defining class.
@node public
@subsection public
A public field can be accessed anywhere.
@node package
@subsection package
A package field can only be accessed from within the same package.
@node protected
@subsection protected
This varies slightly depending on whether we are accessing an instance
field or a static field.  

In the case of an non-static field, the caller must be a
method in the implemented classes of the instance being accessed.  So,
for example, consider the following tree of superclasses :-
@example
   A
   |
   B    C
   \   / \
    \ /   \
     X     Y
@end example
Here, @code{X} has two superclasses, @code{B} and @code{C}.  @code{B} in
turn has a superclass @code{A}, so @code{X}'s implemented classes are
@code{X, B, C, A}.  This means that any protected instance field in
@code{X} could only be accessed from a method within those four classes.
A method in @code{Y}, would not be able to access the field in the
instance of @code{X}, even if the field were defined in @code{C}, the
common superclass of @code{X} and @code{Y} (in that case a method in
@code{Y} @emph{could} access that field on an instance of @code{Y}).
This little example program illustrates this.
@example
class C()
   protected f

   public new(f)
      self.f := f
      return
   end
end

class X(C)
end

class Y(C)
   public try(o)
      write(o.f)
   end
end

procedure main()
   local x, y
   x := X(100)
   y := Y(99)
   y.try(y)   # Okay, writes 99
   y.try(x)   # Will lead to a runtime error...
end
@end example
In the case of a static field, the field being accessed must be
in the implemented classes of the calling method's class.  So in the above
example a method in @code{X} could access static protected fields in any
of the classes @code{X, B, C, A}.
@node static
@subsection static
This declares the field as static - for more information on what this
means, @xref{Fields}.
@node const
@subsection const
Declaring a static field const means that it cannot be changed (ie, assigned to)
after the class has been initialized, which is just after the class's
static @code{init()} method has been called.  Therefore, static const fields
can be initialized in @code{init()} and thereafter treated as constants, with any
attempt to assign to them causing a runtime error.
@example
class Maths()
   public static const PI

   private static init()
      PI := 3.14
   end
end

procedure main()
   write(Maths.PI) # Write 3.14
   Maths.PI := 3   # Runtime error
end
@end example
A const instance field is similar, and can be assigned to during
instance initialization, but thereafter becomes fixed.  The class's
@code{new()} method can be used to set initial values of the field.
@example
class Employee()
   public const name, age

   public new(name, age)
      self.name := name
      self.age := age
      return
   end
end

procedure main()
   local e
   e := Employee("Mary", 30)
   write(e.name, ",", e.age)   # Writes Mary,30
   e.age := 25                 # Runtime error
end
@end example
A method cannot be declared const.
@node readable
@subsection readable
The readable modifier must always be specified together with either the @ref{private}, @ref{public},
or @ref{protected} modifier.  It indicates that the field is accessible in a read-only fashion, where
it would otherwise be inaccessible, based on that other modifier.

So for example, consider the following class :-
@example
class X()
   private readable v

   public f()
      v := 100
   end
end

procedure main()
   local x
   x := X()
   x.f()
   write(x.v)   # Okay, prints 100
   x.v := 101   # Runtime error
end
@end example
The field v can be read and assigned to within the @code{X}, but can
only be read from outside of @code{X}.  Without the @code{readable} modifier, it
would not be accessible at all outside of @code{X}, so the @code{write()} statement
in @code{main()} would give a runtime error.

Note that a @ref{public} field cannot be declared readable, because it
is already readable everywhere.  Nor can a method be declared readable.
@node final
@subsection final
Only an instance method can be declared final.  It indicates that the
method cannot be overridden.  So, for example, the following will give
an error during linking because the method @code{f()} in @code{Y}
overrides @code{f()} in @code{X}, which is marked @code{final}.
@example
class X()
   public final f()
   end
end

class Y(X)
   public f()
   end
end
@end example
A class can also be marked as @code{final}, and in this case it means that
the class cannot be subclassed by another class.  So for example, this is
not allowed :-
@example
final class X()
   public f()
   end
end

class Y(X)
end
@end example
A static method cannot be @code{final} because static methods cannot be
overridden, and a method cannot be marked @code{final} in a @code{final}
class, because such a declaration would obviously be superfluous.
@node Method pointers
@section Method pointers
When a static method field is accessed, the result is a procedure value.
For example :-
@example
class X()
   public static f()
   end
end

procedure main()
   local m
   m := X.f
   write("type=", type(m))
   write("image=", image(m))
end
@end example
This program writes :-
@example
type=procedure
image=method X.f
@end example
The value of @code{m} is just a procedure that can be invoked when
desired.

For an instance method, the situation is a little more involved, because
the instance needs to be kept to hand so that it can be passed to the
method as the value of the @code{self} parameter.  To achieve this, when
an instance method field is accessed, a small structure is created which
holds two things, namely the instance and the method's procedure.  This
structure is called a "methp" (short for "method pointer").

To illustrate this, consider the following :-
@example
class X()
   public g()
   end
end

procedure main()
   local i, m
   i := X()
   m := i.g
   write("type=", type(m))
   write("image=", image(m))
end
@end example
The output in this case is :-
@example
type=methp
image=methp(object X_1(0),method X.g)
@end example
The value @code{m} can now be used just like a procedure to invoke the
method :-
@example
m(1, 2, 3)
@end example
and the effect of this is to call the method @code{g} with the given
parameters, as well as the @code{self} parameter, which will have the
value of the instance @code{i}.

One other general point to note about methods is that access permissions
are checked when the field is accessed, not when the method is called,
which can be done at any later time from any location in the program.

Method pointers also allow some closure-like behaviour which would
otherwise be difficult or impossible to achieve.  For example, consider
the problem of writing a function which takes a parameter @code{n}, and
returns another function which adds @code{n} to its argument.  This can
be done as follows :-
@example
class X()
   private n

   private f(x)
      return x + n
   end

   private new(n)
      return self.n := n
   end

   public static adder(n)
      return X(n).f
   end
end


procedure main()
   local f
   f := X.adder(20)
   write(f(4))
   write(f(6))

   f := X.adder(100)
   write(f(5))
   write(f(10))
end
@end example
The output is
@example
24
26
105
110
@end example
@node Casts
@section Casts
Casts are small icon structures which are used to access overridden methods.
Consider the following program :-
@example
class X()
   public f()
      write("in X.f")
   end
end

class Y(X)
   public f()
      write("in Y.f")
   end
end

procedure main()
   local i
   i := Y()
   i.f()
   cast(i,X).f()
end
@end example
Here the method @code{Y.f()} overrides @code{X.f()}.  Without a cast, it
would be impossible to call the latter on an instance of class @code{Y}.
Note that @code{cast} is just a builtin function, and does not use any
special syntax.

The cast contains two things, namely an object and a target class, which
must be one of the object's @ref{Implemented classes}.  The result is
something that will use the cast class, rather than the object's class,
to resolve static and method field values.  Instance fields come from
the object in the normal way.  So in the above example
@code{cast(i,X).f()}, the value of @code{f} comes from the class
@code{X}, and hence the overridden method is invoked.  

Usually casts are used in a method which has overridden another method.
So for example, if the @code{Y.f()} needed to call @code{X.f()},
then it could do so as follows:-
@example
class Y(X)
   public f()
      write("in Y.f")
      cast(self,X).f()
   end
end
@end example
@node The init() method
@section The init() method
The @code{init()} method is used to initialize a class, and in
particular to initialize the values of any static variables.  It is
called automatically the first time that one of the class's (static)
fields is accessed, or when an instance of the class is created.

Some other points to note about @code{init} :-
@itemize @bullet
@item
A class's superclasses' @code{init} methods (if any) are called before the class's.
@item
An @code{init} method is only ever called once.
@item
The @code{init} method must be declared as a @ref{private} @ref{static}
method.
@item
It is not possible to access the @code{init} field via normal field
access, so the method can only ever be invoked by the runtime system
itself.
@end itemize
@node The new() method
@section The new() method
The @code{new()} method is used to initialize an object, ie an instance
of a particular class.  The method is not invoked explicitly however.  Rather,
in order to create an instance the class name is used like a function call,
and the @code{new()} method is invoked automatically.  So for example :-
@example
class X()
   public new(a, b)
      write("in new a=", a, " b=", b)
      return
   end
end

procedure main()
   local i
   i := X(3, 4)
end
@end example
This writes @code{"in new a=3 b=4"}.
Some other points to note about @code{new()} :-
@itemize @bullet
@item
A class doesn't have to have a @code{new} method.  If it is absent, then all the
instance variables are initially @code{&null}.
@item
A class can inherit (and override) a @code{new} method in a superclass, just like
any other method.
@item
The access modifier of the @code{new} method is respected.  So making
the @code{new} method private means that instances can only be created
from within the class itself (by necessity in a static method).
@item
After an object has been initialized, the @code{new()} method cannot be
accessed, and any attempt to do so gives a run-time error.  So in the example above,
the following would not be allowed :-
@example
procedure main()
   local i
   i := X(3, 4)
   i.new(5, 6)   # Runtime error
end
@end example
@item
If the @code{new()} method fails, then the creation of the object fails.
This gives @code{new()} extra control over the creation process, but
does mean that you have to remember to put a @code{return} in the
@code{new()} method somewhere.
@end itemize

@node Deferred methods
@section Deferred methods
A deferred method is one in which there is no body, and the actual functionality
of the method is defined elsewhere.  For example :-
@example
class X()
   public defer f()
end
@end example
Parameters can be declared if desired, but they are ignored by the
linker.

There are three possible ways to provide the functionality of a deferred
method.

@menu
* Deferred methods as abstract methods::  
* Deferred methods in the runtime system::  
* Deferred methods resolved at runtime::  
@end menu

@node Deferred methods as abstract methods
@subsection Deferred methods as abstract methods
These work just like abstract methods in other languages.  A subclass
overrides the deferred method :-
@example
class X()
   public defer f()
end

class Y(X)
   public f()
      write("in f()")
   end
end
@end example
Obviously this doesn't apply to static methods, which can't be
overridden.
@node Deferred methods in the runtime system
@subsection Deferred methods in the runtime system
This necessitates editing and re-building the C/RTL source code of the
runtime system and the translator.  

The first step is to convert the name of the deferred method to be
implemented into the name of the runtime function to be implemented, by
taking the fully qualified name of the class in which the method
resides, adding a "." and the method name, and then changing all dots to
underscores.  So, for example, say we were implementing method
@code{my_method} in class @code{MyClass} in package @code{my.package},
then we would write a runtime function named
@code{my_package_MyClass_my_method}.

The next step is to add this name to the file
@code{base/h/nativedefs.h}, ensuring that the file stays in ascending
ascii order.

Next, the function must be implemented somewhere in the runtime, as
an RTL function, which might look like this :-
@example
function@{1@} my_package_MyClass_my_method(x, y)
   ... RTL code
end
@end example
Note that for an instance method, the first parameter will be the
instance on which the method was invoked.  In this case, add a
@code{self} parameter to the parameter list :-
@example
function@{1@} my_package_MyClass_my_method(self, x, y)
   ... RTL code
end
@end example

Finally, both the translator and the runtime must be
re-compiled.  The easiest way to do this is to go into the @code{base}
directory and run
@example
make clean
make
make install
@end example

@node Deferred methods resolved at runtime
@subsection Deferred methods resolved at runtime
This involves setting an arbitrary procedure value to be the
implementation of the method, as the following example shows :-
@example
import lang(Class)

procedure myproc(self, x)
   write("in myproc self=", image(self), " x=", image(x))
end

class X()
   public defer f()

   private static init()
      Class.set_method("f", myproc)
   end
end

procedure main()
   local i
   i := X()
   i.f(33)
end
@end example
This prints "@code{in myproc self=object X_1(0) x=33}".

This example uses the static method @code{Class.set_method} in the
@code{lang} package to set the deferred method @code{f} to point to the
procedure @code{mproc}.  The result is that when @code{f} is invoked,
@code{mproc} is called, with the instance @code{i} as the first
parameter, and the value @code{33} as the second.  Note that unlike a
normal method, the @code{self} parameter has to be placed in the
parameter list.

There are some restrictions which @code{set_method} imposes :-

@itemize @bullet
@item
The method must be defined in the class from which @code{set_method} is
called.
@item
The method must be a deferred method.
@item
The procedure supplied may not be a method.  Nor can a procedure be set
as the implementation of more than one method.
@end itemize

Setting a normal procedure to be a deferred method's definition isn't
particularly useful, because you could always implement the method and
just call the procedure.  However, @code{set_method} does still have one
important use, and that is to set method implementations to procedures
loaded via the @code{loadfunc} function, which loads code from a dynamic
native library (.so or .dll).  This enables you to implement methods in
C and RTL without editing or re-compiling the runtime system itself.  In
this case, the init method might look like this :-
@example
   private static init()
      Class.set_method("f", loadfunc("mylib.so", "my_method"))
   end
@end example


@node Packages
@chapter Packages
Packages in Object Icon provide two functions :-
@itemize @bullet
@item
They group several source files into a single unit which can easily
be imported into a program.
@item
They provide a naming prefix for all the symbols in a package, so that
symbol name clashes between code in different libraries are avoided
@end itemize


@menu
* Declaring a package::         The package declaration
* Using a package::             The import declaration
@end menu

@node Declaring a package
@section Declaring a package
A file is declared to be in a package by simply adding a package declaration
at the top of the source file, such as the following :-
@example
package my.pack

procedure one()
   write("in my.pack.one")
end
@end example

This will have the effect of adding the file to the package
@code{"my.pack"}.  This information is stored in a file named
@code{"packages.txt"}, stored in the same directory as the ucode file.
The format of the file is very simple, and just maintains a list of
which files are in which package.

The other effect of the package statement is that the names of the
global symbols (procedures, records, classes and global variables)
declared in the file are prefixed automatically with the package name.
So, the procedure @code{one} in the above file is in fact named
@code{my.pack.one}.

@itemize @bullet
@item
A package name must be comprised of one or more identifiers separated by
dots.
@item
You can have several packages in the same directory of source files;
however you cannot spread a particular package over source files from
more than one directory.
@end itemize

@node Using a package
@section Using a package
A package is used in a program via the import statement.  For example :-
@example
import my.pack

procedure main()
   one()
end
@end example
The import statement causes the linker to search all the @code{packages.txt}
located on the linking path for the specified package.  When found, all of
the files in the package are linked into the program.

Note that the reference to the procedure @code{my.pack.one} is in the
shorter form, @code{one}.  This is allowed so long as there isn't
another symbol @code{one} which would make the reference ambiguous.  In
any case, the fully qualified form is also acceptable.

If there are several imports in one file it may become difficult to
discern which symbol came from which package.  For this reason, the
import statement lets you indicate which symbols are being used from a
particular package, as follows :-
@example
import my.pack(one, two, three)
@end example
This means the three given symbols are being used in the source file and
can be resolved to @code{my.pack.one}, @code{my.pack.two} and
@code{my.pack.three} respectively.  If there were another symbol in
@code{my.pack}, say @code{four}, then it would not be resolved by the
linker if it were encountered as @code{four}; rather an undeclared
identifier error would be raised.  If it were encountered as
@code{my.pack.four} however, that would not raise an error.  Note that
this form of the import statement still links all of the files in the
package into the program, regardless of which symbols are specified.

@node Runtime information about objects and classes
@chapter Runtime information about objects and classes

@menu
* classof()::                   
* is()::                        
* lang.Class::                  
@end menu

@node classof()
@section classof()
This builtin takes an object as a parameter and returns its class.

@node is()
@section is()
This builtin takes two parameters: an object and a class and succeeds
if the class is one of the object's implemented classes.

@node lang.Class
@section lang.Class
This class contains several static methods which can be used to retrieve
information about an object or a class.

@node Library
@chapter Library

@menu
* Environment Variables::       OIPATH and OLPATH
* Packages in the library::     
* IPL::                         
* Auto-generated documentation::  
@end menu

@node Environment Variables
@section Environment Variables
When a package is imported using the @code{import} statement, the linker
uses the @code{OIPATH} environment variable for directories to search
for a matching package.  Each directory's @code{package.txt} file is
loaded and examined for a matching package.  The @code{OIPATH} is also
used to resolve @code{link} declarations in source files too, and to
this extent serves the same purpose as Icon's @code{IPATH} variable.

The @code{OLPATH} variable is the path used by the preprocessor to
resolve @code{$include} directives, and serves the same purpose as
Icon's @code{LPATH} variable.

@node Packages in the library
@section Packages in the library

@node IPL
@section IPL
The library includes a slightly modified copy of Icon's extensive
program library.  The chief difference is that Object Icon's package
facility has been used to remove any potential clashes of symbol names
or filenames.  Nearly all the files have been placed in their own
package with the name @code{ipl.}@emph{filename}.  The only exceptions
are the graphics functions and the vidgets library, each of which group
several related files into the @code{ipl.graphics} and
@code{ipl.vidgets} packages respectively.

For example, to use the options procedure for processing command-line
options, whereas in Icon one would write @code{"link options"}, in Object
Icon use @code{"import ipl.options"}.

@node Auto-generated documentation
@section Auto-generated documentation
The distribution includes a program called @code{oidoc}, which can be
used to generate HTML format documentation from the source code in the
library.  It is not built by default because it creates rather a large
amount of data (about 25 MB).  To build it run @code{make libref} from
the docs directory.  The result is a directory, @code{libref}, which can
be copied or moved to any desired location.  The starting page is
@code{"index.html"} within that directory.

@node Makefiles
@chapter Makefiles
A useful file with some make definitions, @code{Makedefs} can be found
in the root directory of the source tree.  A similar file is generated
by the installation process, and can be found in the @code{objecticon}
subdirectory of the installation @code{lib} directory (eg
@code{/usr/local/lib/objecticon/Makedefs}).

The @code{Makedefs} file provides appropriate definitions for the
@code{OIPATH}, @code{OLPATH} and @code{PATH} environment variables, as
well as providing a simple pattern rule for translating .icn to .u
files.

Here are some example Makefiles which show how

@node Dynamically loading C/RTL code
@chapter Dynamically loading C/RTL code
Object Icon incorporates some enhancements to Icon's dynamic loading
facility which allow dynamically loaded functions to be written in RTL
rather than plain C.  This means that dynamically loaded code can take
the same form as builtin code, and can do the same things.

In order to develop a dynamic library it is necessary to have the source
distribution available, with its bin directory on your @code{PATH}.

@menu
* A sample RTL file::           
* Compilation::                 
* Loading the library::         
* External headers and symbols::  
@end menu

@node A sample RTL file
@section A sample RTL file
Here is a not-very-useful function to generate the bit positions of ones
in an integer (for example 6 is 110, so generates 2, 3).

@example
function@{*@} bits(v)
    if !cnv:C_integer(v) then
       runerr(101, v)
    body @{
       int i = 1;
       while (v) @{
           if (v & 1)
               suspend C_integer i;
           v /= 2;
           ++i;
       @}
       fail;
    @}
end
@end example

To create a dynamic library to use this function we would firstly place
it in a file with the suffix ".r", say @code{testlib.r}.

@node Compilation
@section Compilation

Next, create a Makefile to build the library.

@example
include $(OIHOME)/Makedefs

all:	testlib.so

clean :
	rm -f *.u *.o *.so

testlib.o : testlib.r
	rtt testlib.r
	$(CC) $(CPPFLAGS) $(CFLAGS) -fPIC -c xtestlib.c -o testlib.o

testlib.so : testlib.o
	$(CC) -shared -fPIC -o testlib.so testlib.o
@end example

Notes :-

@itemize @bullet
@item
In the first line the environment variable @code{$(OIHOME)} is assumed to point
to the root of the source code distribution.
@item
The Makedefs file defines various variables, in particular the flags for C
compilation.
@item
The flags to the @code{$(CC)} command may need to be tweaked.
@end itemize

@node Loading the library
@section Loading the library
Here is a sample program to load the library and run the @code{bits()}
function.

@example
procedure main()
   local p
   p := loadfunc("./testlib.so", "bits")
   write("okay, loaded ",image(p))
   every write(p(12345))
end
@end example

When compiled and run, the following output should result :-

@example
okay, loaded function bits
1
4
5
6
13
14
@end example

Note that the library name in the first parameter of @code{loadfunc} is
passed unaltered to the underlying system's dynamic load function (on
Unix, @code{dlopen}).  This means that the library must either be an
absolute path, relative to the current directory, or in one of the
places that the system normally looks for shared libraries.

There are some functions available to help search for files on paths.  In
particular see :-
@itemize @bullet
@item
@code{pathload()} and @code{pathfind()} in the package @code{ipl.io}
@item
@code{path_find()} in the package @code{parser}
@end itemize
@node External headers and symbols
@section External headers and symbols
It is possible that the RTL code in a dynamic library will need to refer
to another existing library and its associated C header files.  For
example, the mysql library needs to reference "mysql.h" and link to the
mysqlclient library.  These external header files are normally
@emph{not} processed by RTT - rather they are passed through RTT to be
processed by the C compiler.  For example

@example
#passthru #include "mysql.h"
@end example

This raises a problem of how RTT will recognise symbol and types defined
in the header concerned, which are then used in the RTL source.  For
example, @code{mysql.h} defines the type @code{MYSQL_RES}, and this is
used several times in @code{mysql.r}.  For code in the interpreter, a
separate header file, @code{grttin.h}, is processed specially by RTT in
order to allow such symbols to be declared with dummy types, typically
as @code{typedef int}.  This allows them to pass through RTT without
error.  For an dynamic library we naturally don't want to edit
@code{grttin.h}, so a new option, @code{-h} specifies an extra header
file to process immediately after @code{grttin.h}.  Here we can provide
the necessary dummy definitions of symbols like @code{MYSQL_RES}.  The
header for the mysql library looks like this :-

@example
typedef int MYSQL, MYSQL_FIELD, my_bool, MYSQL_RES,
    MYSQL_FIELD_OFFSET, MYSQL_ROW, MYSQL_ROW_OFFSET, my_ulonglong;
@end example

and is processed with the command :-

@example
rtt -h gmysql.h mysql.r
@end example
@node Dynamically loading Icon code
@chapter Dynamically loading Icon code
Object Icon includes a small enhancement to MT Icon which allows
procedures and classes to be loaded and invoked dynamically from other
icode files (ie executable files created by the linker).

To illustrate how this works, consider the following simple source file:-
@example
invocable X, p

class X()
   public hello()
      write("Hello")
   end
end

procedure p()
   write("Hello again")
end

procedure main()
end
@end example
If this were in the file @code{abc.icn}, then it could be compiled with
the command @code{oit abc.icn}.  Then its symbols could be loaded and
used dynamically as follows :-
@example
procedure main()
   local prog, x
   prog := load("abc") | stop("Couldn't load")

   # Create an instance of X, call hello method
   x := variable("X", prog)()
   x.hello()

   # Call procedure p
   variable("p", prog)()
end
@end example

@itemize @bullet
@item
The "library" program needs a dummy @code{main} procedure.  It also
needs to declare the procedure and class as invocable, so that the
linker doesn't discard them as unreferenced symbols.
@item
The class could also be accessed via @code{Class.for_name("X", prog)()}
(after importing @code{lang.Class}).
@item
The procedure could also be accessed via the call @code{proc("p",,prog)()}
@item
The loaded program retains its own separate set of global identifiers.
References to global identifiers in loaded procedures and methods always
refer to the enclosing loaded program.  Hence, several global
identifiers with the same name can co-exist at the same time in separate
programs.
@end itemize

@node Differences - Icon
@chapter Differences - Icon

@node Differences - Unicon
@chapter Differences - Unicon

@node Emacs mode
@chapter Emacs mode

@node Key Index
@chapter Key Index

@node Function Index
@chapter Function Index

@node Variable Index
@chapter Variable Index

@node Package Index
@chapter Package Index

@node Concept Index
@chapter Concept Index


@node Acknowledgments
@chapter


@bye
