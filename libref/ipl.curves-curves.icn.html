<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>curves.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     curves.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures to generate points on plain curves
<a name="6"/>#
<a name="7"/>#	Author:   Ralph E. Griswold
<a name="8"/>#
<a name="9"/>#	Date:     October 1, 1997
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#  This file links procedure files that generate traces of points on various
<a name="18"/>#  plain curves.
<a name="19"/>#
<a name="20"/>#  The first two parameters determine the defining position of the
<a name="21"/>#  curve:
<a name="22"/>#
<a name="23"/>#	x	x coordinate
<a name="24"/>#	y	y coordinate
<a name="25"/>#
<a name="26"/>#  The meaning of "definition position" depends on the curve.  In some
<a name="27"/>#  cases it is the position at which plotting starts.  In others, it
<a name="28"/>#  is a "center" for the curve.
<a name="29"/>#
<a name="30"/>#  The next arguments vary and generally refer to parameters of the
<a name="31"/>#  curve.  There is no practical way to describe these here.  If they
<a name="32"/>#  are not obvious, the best reference is
<a name="33"/>#
<a name="34"/>#	A Catalog of Special Plane Curves, J. Dennis Lawrence,
<a name="35"/>#	Dover Publications, Inc., New York, 1972.
<a name="36"/>#
<a name="37"/>#  This book, which is in print at the time of this writing, is a
<a name="38"/>#  marvelous source of information about plane curves and is inexpensive
<a name="39"/>#  as well.
<a name="40"/>#
<a name="41"/>#  The trailing parameters give the number of steps and the end points
<a name="42"/>#  (generally in angles) of the curves:
<a name="43"/>#  
<a name="44"/>#	steps	number of points, default varies
<a name="45"/>#	lo	beginning of plotting range, default varies
<a name="46"/>#	hi	end of plotting range, default varies
<a name="47"/>#
<a name="48"/>#  Because of floating-point roundoff, the number of steps
<a name="49"/>#  may not be exactly the number specified.
<a name="50"/>#
<a name="51"/>#  Note:  Some of the curves may be "upside down" when plotted on
<a name="52"/>#  coordinate systems in which the y axis increases in a downward direction.
<a name="53"/>#
<a name="54"/>#  Caution:  Some of these procedures generate very large values
<a name="55"/>#  in portions of their ranges.  These may cause run-time errors when
<a name="56"/>#  used in versions of Icon prior to 8.10.  One work-around is to
<a name="57"/>#  turn on error conversion in such cases.
<a name="58"/>#
<a name="59"/>#  Warning:  The procedures that follow have not been tested thoroughly.
<a name="60"/>#  Corrections and additions are most welcome.
<a name="61"/>#
<a name="62"/>#  These  procedures are, in fact, probably most useful for the parametric
<a name="63"/>#  equations they contain.
<a name="64"/>#
<a name="65"/>############################################################################
<a name="66"/>#
<a name="67"/>#  Links:  gobject, math, step
<a name="68"/>#
<a name="69"/>############################################################################
<a name="70"/>
<a name="71"/>package ipl.curves
<a name="72"/>
<a name="73"/>import
<a name="74"/>   ipl.gobject(Point),
<a name="75"/>   util(Math)
<a name="76"/>
<a name="77"/>procedure bullet_nose(x, y, a, b, steps, lo, hi)
<a name="78"/>   local incr, theta
<a name="79"/>
<a name="80"/>   /steps := 300
<a name="81"/>   lo := Math.dtor(\lo) | -Math.PI
<a name="82"/>   hi := Math.dtor(\hi) | Math.PI
<a name="83"/>   incr := (hi - lo) / steps
<a name="84"/>
<a name="85"/>   every theta := lo to hi by incr do
<a name="86"/>      suspend Point(
<a name="87"/>         x + a * Math.cos(theta),
<a name="88"/>         y + b * Math.tan(Math.PI / 2 - theta),
<a name="89"/>         0
<a name="90"/>         )
<a name="91"/>
<a name="92"/>end
<a name="93"/>
<a name="94"/>procedure cardioid(x, y, a, steps, lo, hi)
<a name="95"/>   local incr, theta, fact
<a name="96"/>
<a name="97"/>   /steps := 300
<a name="98"/>   lo := Math.dtor(\lo) | -Math.PI
<a name="99"/>   hi := Math.dtor(\hi) | Math.PI
<a name="100"/>   incr := (hi - lo) / steps
<a name="101"/>
<a name="102"/>   every theta := lo to hi by incr do {
<a name="103"/>      fact := 2 * a * (1 + Math.cos(theta))
<a name="104"/>      suspend Point(
<a name="105"/>         x + Math.cos(theta) * fact,
<a name="106"/>         y + Math.sin(theta) * fact,
<a name="107"/>         0
<a name="108"/>         )
<a name="109"/>      }
<a name="110"/>
<a name="111"/>end
<a name="112"/>
<a name="113"/>procedure cissoid_diocles(x, y, a, steps, lo, hi)
<a name="114"/>   local incr, theta, radius
<a name="115"/>
<a name="116"/>   /steps := 300
<a name="117"/>   lo := Math.dtor(\lo) | (-2 * Math.PI)
<a name="118"/>   hi := Math.dtor(\hi) | (2 * Math.PI)
<a name="119"/>   incr := (hi - lo) / steps
<a name="120"/>
<a name="121"/>   every theta := lo to hi by incr do {
<a name="122"/>      radius := a * Math.sin(theta) * Math.cos(theta)
<a name="123"/>      suspend Point(
<a name="124"/>         x + radius * Math.cos(theta),
<a name="125"/>         y + radius * Math.sin(theta),
<a name="126"/>         0
<a name="127"/>         )
<a name="128"/>      }
<a name="129"/>
<a name="130"/>end
<a name="131"/>
<a name="132"/>procedure cross_curve(x, y, a, b, steps, lo, hi)
<a name="133"/>   local incr, theta
<a name="134"/>
<a name="135"/>   /steps := 300
<a name="136"/>   lo := Math.dtor(\lo) | -Math.PI
<a name="137"/>   hi := Math.dtor(\hi) | Math.PI
<a name="138"/>   incr := (hi - lo) / steps
<a name="139"/>
<a name="140"/>   every theta := lo to hi by incr do
<a name="141"/>      suspend Point(
<a name="142"/>         x + a / Math.cos(theta),
<a name="143"/>         y + b / Math.sin(theta),
<a name="144"/>         0
<a name="145"/>         )
<a name="146"/>
<a name="147"/>end
<a name="148"/>
<a name="149"/>procedure cycloid(x, y, a, b, steps, lo, hi)
<a name="150"/>   local incr, theta
<a name="151"/>
<a name="152"/>   /steps := 100
<a name="153"/>   lo := Math.dtor(\lo) | 0
<a name="154"/>   hi := Math.dtor(\hi) | (8 * Math.PI)
<a name="155"/>   incr := (hi - lo) / steps
<a name="156"/>
<a name="157"/>   every theta := lo to hi by incr do
<a name="158"/>      suspend Point(
<a name="159"/>         x + a * theta - b * Math.sin(theta),
<a name="160"/>         y + a - b * Math.cos(theta),
<a name="161"/>         0
<a name="162"/>         )
<a name="163"/>
<a name="164"/>end
<a name="165"/>
<a name="166"/>procedure deltoid(x, y, a, steps, lo, hi)
<a name="167"/>   local incr, theta
<a name="168"/>
<a name="169"/>   /steps := 300
<a name="170"/>   lo := Math.dtor(\lo) | -Math.PI
<a name="171"/>   hi := Math.dtor(\hi) | Math.PI
<a name="172"/>   incr := (hi - lo) / steps
<a name="173"/>
<a name="174"/>   every theta := lo to hi by incr do
<a name="175"/>      suspend Point(
<a name="176"/>         x + a * (2 * Math.cos(theta) + Math.cos(2 * theta)),
<a name="177"/>         y + a * (2 * Math.sin(theta) - Math.sin(2 * theta)),
<a name="178"/>         0
<a name="179"/>         )
<a name="180"/>
<a name="181"/>end
<a name="182"/>
<a name="183"/>procedure ellipse(x, y, a, b, steps, lo, hi)
<a name="184"/>   local incr, theta
<a name="185"/>
<a name="186"/>   /steps := 300
<a name="187"/>   lo := Math.dtor(\lo) | -Math.PI
<a name="188"/>   hi := Math.dtor(\hi) | Math.PI
<a name="189"/>   incr := (hi - lo) / steps
<a name="190"/>
<a name="191"/>   every theta := lo to hi by incr do
<a name="192"/>      suspend Point(
<a name="193"/>         x + a * Math.cos(theta),
<a name="194"/>         y + b * Math.sin(theta),
<a name="195"/>         0
<a name="196"/>         )
<a name="197"/>
<a name="198"/>end
<a name="199"/>
<a name="200"/>procedure ellipse_evolute(x, y, a, b, steps, lo, hi)
<a name="201"/>   local incr, theta
<a name="202"/>
<a name="203"/>   /steps := 300
<a name="204"/>   lo := Math.dtor(\lo) | -Math.PI
<a name="205"/>   hi := Math.dtor(\hi) | Math.PI
<a name="206"/>   incr := (hi - lo) / steps
<a name="207"/>
<a name="208"/>   every theta := lo to hi by incr do
<a name="209"/>      suspend Point(
<a name="210"/>         x + a * Math.cos(theta) ^ 3,
<a name="211"/>         y + b * Math.sin(theta) ^ 3,
<a name="212"/>         0
<a name="213"/>         )
<a name="214"/>
<a name="215"/>end
<a name="216"/>
<a name="217"/>procedure epitrochoid(x, y, a, b, h, steps, lo, hi)
<a name="218"/>   local incr, theta, sum, fact
<a name="219"/>
<a name="220"/>   /steps := 300
<a name="221"/>   lo := Math.dtor(\lo) | -Math.PI
<a name="222"/>   hi := Math.dtor(\hi) | Math.PI
<a name="223"/>   incr := (hi - lo) / steps
<a name="224"/>
<a name="225"/>   sum := a + b
<a name="226"/>   fact := sum / b
<a name="227"/>
<a name="228"/>   every theta := lo to hi by incr do
<a name="229"/>      suspend Point(
<a name="230"/>         x + sum * Math.cos(theta) - h * Math.cos(fact * theta),
<a name="231"/>         y + sum * Math.sin(theta) - h * Math.sin(fact * theta),
<a name="232"/>         0
<a name="233"/>         )
<a name="234"/>
<a name="235"/>end
<a name="236"/>
<a name="237"/>procedure folium(x, y, a, b, steps, lo, hi)
<a name="238"/>   local incr, theta, radius
<a name="239"/>
<a name="240"/>   /steps := 300
<a name="241"/>   lo := Math.dtor(\lo) | -Math.PI
<a name="242"/>   hi := Math.dtor(\hi) | Math.PI
<a name="243"/>   incr := (hi - lo) / steps
<a name="244"/>
<a name="245"/>   every theta := lo to hi by incr do {
<a name="246"/>      radius := (3 * a * Math.sin(theta) * Math.cos(theta)) /
<a name="247"/>         (Math.sin(theta) ^ 2 + Math.cos(theta) ^ 2)
<a name="248"/>      suspend Point(
<a name="249"/>         x + radius * Math.cos(theta),
<a name="250"/>         y + radius * Math.sin(theta),
<a name="251"/>         0
<a name="252"/>         )
<a name="253"/>      }
<a name="254"/>
<a name="255"/>end
<a name="256"/>
<a name="257"/>procedure hippopede(x, y, a, b, steps, lo, hi)
<a name="258"/>   local incr, theta, mul
<a name="259"/>
<a name="260"/>   /steps := 300
<a name="261"/>   lo := Math.dtor(\lo) | -Math.PI
<a name="262"/>   hi := Math.dtor(\hi) | Math.PI
<a name="263"/>   incr := (hi - lo) / steps
<a name="264"/>
<a name="265"/>   every theta := lo to hi by incr do {
<a name="266"/>      mul := a * b - b ^ 2 * Math.sin(theta) ^ 2
<a name="267"/>      if mul &lt; 0 then next
<a name="268"/>      mul := 2 * Math.sqrt(mul)
<a name="269"/>      suspend Point(
<a name="270"/>         x + mul *  Math.cos(theta),
<a name="271"/>         y + mul *Math.sin(theta),
<a name="272"/>         0
<a name="273"/>         )
<a name="274"/>      }
<a name="275"/>
<a name="276"/>end
<a name="277"/>
<a name="278"/>procedure kampyle_exodus(x, y, a, b, steps, lo, hi)
<a name="279"/>   local incr, theta, fact
<a name="280"/>
<a name="281"/>   /steps := 300
<a name="282"/>   lo := Math.dtor(\lo) | (-Math.PI / 2)
<a name="283"/>   hi := Math.dtor(\hi) | (3 * Math.PI / 2)
<a name="284"/>   incr := (hi - lo) / steps
<a name="285"/>
<a name="286"/>   every theta := lo to hi by incr do {
<a name="287"/>      fact := a / Math.cos(theta)
<a name="288"/>      suspend Point(
<a name="289"/>         x + fact,
<a name="290"/>         y + fact * Math.tan(theta),
<a name="291"/>         0
<a name="292"/>         )
<a name="293"/>      }
<a name="294"/>
<a name="295"/>end
<a name="296"/>
<a name="297"/>procedure kappa(x, y, a, b, steps, lo, hi)
<a name="298"/>   local incr, theta, fact
<a name="299"/>
<a name="300"/>   /steps := 300
<a name="301"/>   lo := Math.dtor(\lo) | 0
<a name="302"/>   hi := Math.dtor(\hi) | (2 * Math.PI)
<a name="303"/>   incr := (hi - lo) / steps
<a name="304"/>
<a name="305"/>   every theta := lo to hi by incr do {
<a name="306"/>      fact := a * Math.cos(theta)
<a name="307"/>      suspend Point(
<a name="308"/>         x + fact / (0 ~= Math.tan(theta)),
<a name="309"/>         y + fact,
<a name="310"/>         0
<a name="311"/>         )
<a name="312"/>      }
<a name="313"/>
<a name="314"/>end
<a name="315"/>
<a name="316"/>procedure lemniscate_bernoulli(x, y, a, steps, lo, hi)
<a name="317"/>   local incr, theta, fact
<a name="318"/>
<a name="319"/>   /steps := 300
<a name="320"/>   lo := Math.dtor(\lo) | -Math.PI
<a name="321"/>   hi := Math.dtor(\hi) | Math.PI
<a name="322"/>   incr := (hi - lo) / steps
<a name="323"/>
<a name="324"/>   every theta := lo to hi by incr do {
<a name="325"/>      fact := a * Math.cos(theta) / (1 + Math.sin(theta) ^ 2)
<a name="326"/>      suspend Point(
<a name="327"/>         x + fact,
<a name="328"/>         y + fact * Math.sin(theta),
<a name="329"/>         0
<a name="330"/>         )
<a name="331"/>      }
<a name="332"/>
<a name="333"/>end
<a name="334"/>
<a name="335"/>procedure lemniscate_gerono(x, y, a, b, steps, lo, hi)
<a name="336"/>   local incr, theta, fact
<a name="337"/>
<a name="338"/>   /steps := 300
<a name="339"/>   lo := Math.dtor(\lo) | -Math.PI
<a name="340"/>   hi := Math.dtor(\hi) | Math.PI
<a name="341"/>   incr := (hi - lo) / steps
<a name="342"/>
<a name="343"/>   every theta := lo to hi by incr do {
<a name="344"/>      fact :=  a * Math.cos(theta)
<a name="345"/>      suspend Point(
<a name="346"/>         x + fact,
<a name="347"/>         y + Math.sin(theta) * fact,
<a name="348"/>         0
<a name="349"/>         )
<a name="350"/>      }
<a name="351"/>
<a name="352"/>end
<a name="353"/>
<a name="354"/>procedure limacon_pascal(x, y, a, b, steps, lo, hi)
<a name="355"/>   local incr, theta, fact
<a name="356"/>
<a name="357"/>   /steps := 300
<a name="358"/>   lo := Math.dtor(\lo) | -Math.PI
<a name="359"/>   hi := Math.dtor(\hi) | Math.PI
<a name="360"/>   incr := (hi - lo) / steps
<a name="361"/>
<a name="362"/>   every theta := lo to hi by incr do {
<a name="363"/>      fact := b + 2 * a * Math.cos(theta)
<a name="364"/>      suspend Point(
<a name="365"/>         x + fact * Math.cos(theta),
<a name="366"/>         y + fact * Math.sin(theta),
<a name="367"/>         0
<a name="368"/>         )
<a name="369"/>      }
<a name="370"/>
<a name="371"/>end
<a name="372"/>
<a name="373"/>procedure line(x, y, x1, y1, steps)
<a name="374"/>   local xincr, yincr
<a name="375"/>
<a name="376"/>   /steps := 100
<a name="377"/>
<a name="378"/>   xincr := (x1 - x)  / (steps - 1)
<a name="379"/>   yincr := (y1 - y) / (steps - 1)
<a name="380"/>
<a name="381"/>   every 1 to steps do {
<a name="382"/>      suspend Point(x, y, 0)
<a name="383"/>      x +:= xincr
<a name="384"/>      y +:= yincr
<a name="385"/>      }
<a name="386"/>
<a name="387"/>end
<a name="388"/>
<a name="389"/>procedure lissajous(x, y, a, b, r, delta, steps, lo, hi)
<a name="390"/>   local incr, theta
<a name="391"/>
<a name="392"/>   /steps := 300
<a name="393"/>   lo := Math.dtor(\lo) | 0
<a name="394"/>   hi := Math.dtor(\hi) | (16 * Math.PI)
<a name="395"/>   incr := (hi - lo) / steps
<a name="396"/>
<a name="397"/>   r := Math.dtor(r)
<a name="398"/>
<a name="399"/>   every theta := lo to hi by incr do
<a name="400"/>      suspend Point(
<a name="401"/>         x + a * Math.sin(r * theta + delta),
<a name="402"/>         y + b * Math.sin(theta),
<a name="403"/>         0
<a name="404"/>         )
<a name="405"/>
<a name="406"/>end
<a name="407"/>
<a name="408"/>procedure nephroid(x, y, a, steps, lo, hi)
<a name="409"/>   local incr, theta
<a name="410"/>
<a name="411"/>   /steps := 300
<a name="412"/>   lo := Math.dtor(\lo) | -Math.PI
<a name="413"/>   hi := Math.dtor(\hi) | Math.PI
<a name="414"/>   incr := (hi - lo) / steps
<a name="415"/>
<a name="416"/>   every theta := lo to hi by incr do
<a name="417"/>      suspend Point(
<a name="418"/>         x + a * (3 * Math.cos(theta) - Math.cos(3 * theta)),
<a name="419"/>         y + a * (3 * Math.sin(theta) - Math.sin(3 * theta)),
<a name="420"/>         0
<a name="421"/>         )
<a name="422"/>
<a name="423"/>end
<a name="424"/>
<a name="425"/>#  Needs to be checked out
<a name="426"/>
<a name="427"/>procedure parabola(x, y, a, steps, lo, hi)
<a name="428"/>   local incr, theta, denom, radius
<a name="429"/>
<a name="430"/>   /steps := 300
<a name="431"/>   lo := Math.dtor(\lo) | -Math.PI
<a name="432"/>   hi := Math.dtor(\hi) | Math.PI
<a name="433"/>   incr := (hi - lo) / steps
<a name="434"/>
<a name="435"/>   every theta := lo to hi by incr do {
<a name="436"/>      denom := 1 - Math.cos(theta)
<a name="437"/>      if denom = 0 then next
<a name="438"/>      radius := 2 * a / denom
<a name="439"/>      suspend Point(
<a name="440"/>         radius * Math.cos(theta),
<a name="441"/>         radius * Math.sin(theta),
<a name="442"/>         0
<a name="443"/>         )
<a name="444"/>      }
<a name="445"/>
<a name="446"/>end
<a name="447"/>
<a name="448"/>procedure piriform(x, y, a, b, steps, lo, hi)
<a name="449"/>   local incr, theta, fact
<a name="450"/>
<a name="451"/>   /steps := 300
<a name="452"/>   lo := Math.dtor(\lo) | (-Math.PI / 2)
<a name="453"/>   hi := Math.dtor(\hi) | (3 * Math.PI / 2)
<a name="454"/>   incr := (hi - lo) / steps
<a name="455"/>
<a name="456"/>   every theta := lo to hi by incr do {
<a name="457"/>      fact := 1 + Math.sin(theta)
<a name="458"/>      suspend Point(
<a name="459"/>         x + a * fact,
<a name="460"/>         y + b * Math.cos(theta) * fact,
<a name="461"/>         0
<a name="462"/>         )
<a name="463"/>      }
<a name="464"/>
<a name="465"/>end
<a name="466"/>
<a name="467"/>procedure trisectrix_catalan(x, y, a, steps, lo, hi)
<a name="468"/>   local incr, theta, radius
<a name="469"/>
<a name="470"/>   /steps := 300
<a name="471"/>   lo := Math.dtor(\lo) | (-2 * Math.PI)
<a name="472"/>   hi := Math.dtor(\hi) | (2 * Math.PI)
<a name="473"/>   incr := (hi - lo) / steps
<a name="474"/>
<a name="475"/>   every theta := lo to hi by incr do {
<a name="476"/>      radius := a / Math.cos(theta / 3) ^ 3
<a name="477"/>      suspend Point(
<a name="478"/>         x + radius * Math.cos(theta),
<a name="479"/>         y + radius * Math.sin(theta),
<a name="480"/>         0
<a name="481"/>         )
<a name="482"/>      }
<a name="483"/>
<a name="484"/>end
<a name="485"/>
<a name="486"/>procedure trisectrix_maclaurin(x, y, a, b, steps, lo, hi)
<a name="487"/>   local incr, theta, fact
<a name="488"/>
<a name="489"/>   /steps := 300
<a name="490"/>   lo := Math.dtor(\lo) | (-Math.PI / 2)
<a name="491"/>   hi := Math.dtor(\hi) | (Math.PI / 2)
<a name="492"/>   incr := (hi - lo) / steps
<a name="493"/>
<a name="494"/>   every theta := lo to hi by incr do {
<a name="495"/>      fact := a * (1 - 4 * Math.cos(theta) ^ 2)
<a name="496"/>      suspend Point(
<a name="497"/>         x + fact,
<a name="498"/>         y + fact * Math.tan(theta),
<a name="499"/>         0
<a name="500"/>         )
<a name="501"/>      }
<a name="502"/>
<a name="503"/>end
<a name="504"/>
<a name="505"/>procedure witch_agnesi(x, y, a, steps, lo, hi)
<a name="506"/>   local incr, theta, fact
<a name="507"/>
<a name="508"/>   /steps := 300
<a name="509"/>   lo := Math.dtor(\lo) | (-Math.PI /2)
<a name="510"/>   hi := Math.dtor(\hi) | (Math.PI / 2)
<a name="511"/>   incr := (hi - lo) / steps
<a name="512"/>
<a name="513"/>   fact := 2 * a
<a name="514"/>
<a name="515"/>   every theta := lo to hi by incr do
<a name="516"/>      suspend Point(
<a name="517"/>         x + fact * Math.tan(theta),
<a name="518"/>         y - fact * Math.cos(theta) ^ 2,
<a name="519"/>         0
<a name="520"/>         )
<a name="521"/>
<a name="522"/>end
</pre></body></html>
