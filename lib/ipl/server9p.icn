package ipl.plan9

import plan9, io, posix, ipl.options, util

package procedure usage_impl(s, opts)
   ewrite("Usage: ", FilePath(&progname).get(-1), s)
   if /opts then
      exit(1)
   else {
      options_help(opts)
      exit(0)
   }
end

procedure usage_1(opts)
   usage_impl(" [OPTIONS] [mountpt]", opts)
end

procedure usage_2(opts)
   usage_impl(" [OPTIONS] [mountpt attach]", opts)
end

procedure get_optl()
   return [Opt("v",, "Verbose mode"),
           Opt("s",string, "FILE#Don't mount, instead post the pipe in /srv/FILE"),
           Opt("a",, "Use the MAFTER flag when mounting"),
           Opt("b",, "Use the MBEFORE flag when mounting"),
           Opt("c",, "Use the MCREATE flag when mounting"),
           Opt("C",, "Use the MCACHE flag when mounting")]
end

procedure server_main_1(a, sess, run)
   local optl, opts, mountpt
   optl := get_optl()
   opts := options(a, optl, usage_1)
   if /opts["s"] then {
      if *a = 0 then
         usage_1()
      mountpt := a[1]
   }
   server_main(mountpt, "", opts, sess, run)
end

procedure server_main_2(a, sess, run)
   local optl, opts, mountpt, attach
   optl := get_optl()
   opts := options(a, optl, usage_2)
   if /opts["s"] then {
      if *a < 2 then
         usage_2()
      mountpt := a[1]
      attach := a[2]
   }
   server_main(mountpt, attach, opts, sess, run)
end

procedure server_main(mountpt, attach, opts, sess, run)
   local p, pid, pname, fl, s
   pname := FilePath(&progname).get(-1)
   /run := sess.io
   p := FileStream.pipe() | stop(&why)
   pid := System.fork(ior(ForkOpt.RFPROC, ForkOpt.RFFDG, ForkOpt.RFNAMEG, ForkOpt.RFNOTEG)) | stop(&why)
   if pid = 0 then {
      p[1].close()
      if \opts["v"] then 
         sess.set_verbose(&yes)
      run(p[2])
      p[2].close()
      if \opts["v"] then {
         sess.dump()
         system("cat /proc/" || System.getpid() || "/fd")
      }
      ewrite(pname, ": exit")
   } else {
      sess := &null
      p[2].close()
      if s := \opts["s"] then {
         Files.string_to_file("/srv/" || s, p[1].get_fd()) | stop(&why)
         ewrite(pname, ": serving on /srv/", s)
      } else {
         fl := if \opts["a"] then
            MountOpt.MAFTER
         else if \opts["b"] then
            MountOpt.MBEFORE
         else
            MountOpt.MREPL
         if \opts["c"] then
            fl := ior(fl, MountOpt.MCREATE)
         if \opts["C"] then
            fl := ior(fl, MountOpt.MCACHE)
         Files.mount(p[1], &null, mountpt, fl, attach) | stop(&why)
         ewrite(pname, ": mounted on ", mountpt)
      }
      p[1].close()
   }
   exit()
end

procedure async_sched_loop(sess, sched, f)
   local nb
   use {
      nb := NonBlockStream(f).set_close_underlying(&no),
      {
         sess.async_io(sched, nb)
         # Main loop
         until sched.empty() do
            sched.work() | delay(50)
      }
   }
end

# A file in which writes append to the end of the content, whilst
# reads consume from the start.  In both read and write, position is
# ignored.
#
class FifoFile9P(Regular9P)
   private readable
      data

   public open(mode)
      if iand(self.perm, Mode9.DMAPPEND) = 0 &
         iand(mode, FileOpt9.OTRUNC) ~= 0 then
         data := ""
      return self
   end

   public set_length(len)
      if len > *data then
         data ||:= repl("\0", len - *data)
      else
         data := data[1+:len]
      return self
   end

   public write(s, pos)
      data ||:= s
      return *s
   end

   public read(pos, count)
      local s
      data ? {
         s := move(count) | tab(0)
         data := tab(0)
      }
      return s
   end

   public get_length()
      return *data
   end

   public set_data(s)
      s := string(s) | runerr(103, s)
      data := s
      return self
   end

   public new()
      Regular9P.new()
      data := ""
      return
   end
end

# A file in which the content is split into a queue of messages.
# Writes append to the end, whilst reads consume from the start.
# Reads never consume more than one messge in the queue.
#
class QueueFile9P(Regular9P)
   private
      q
   private readable
      len

   public open(mode)
      if iand(self.perm, Mode9.DMAPPEND) = 0 &
         iand(mode, FileOpt9.OTRUNC) ~= 0 then
         clear()
      return self
   end

   public write(s, pos)
      add(s)
      return *s
   end

   public read(pos, count)
      local s
      if *q = 0 then
         return
      s := pop(q)
      if *s > count then {
         s ? {
            s := move(count)
            push(q, tab(0))
         }
      }
      len -:= *s
      return s
   end

   public set_length(n)
      local s
      if n <= 0 then
         clear()
      else if n > len then
         add(repl("\0", n - len))
      else {
         while len - *q[-1] >= n do {
            s := pull(q)
            len -:= *s
         }
         if len > n then {
            # 0 < len-n  < *q[-1]
            q[-1][0 -: len - n] := ""
            len := n
         }
      }
      return self
   end

   public get_length()
      return .len
   end

   public clear()
      q := []
      len := 0
      return self
   end

   public get_queue_length()
      return *q
   end

   public get_content()
      local s
      s := ""
      every s ||:= !q
      return s
   end

   public add(s)
      s := string(s) | runerr(103, s)
      if *s > 0 then {
         len +:= *s
         put(q, s)
      }
      return self
   end

   public remove()
      local s
      if *q > 0 then {
         s := pop(q)
         len -:= *s
         return s
      }
   end

   public new()
      Regular9P.new()
      clear()
      return
   end
end
