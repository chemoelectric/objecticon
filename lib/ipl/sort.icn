###########################################################################
#
#	File:     sort.icn
#
#	Subject:  Procedures for sorting
#
#	Authors:  Bob Alexander, Richard L. Goerwitz, and Ralph E. Griswold
#
#	Date:     September 10, 1998
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#	isort(x, p)
#		customized sort in which procedure p is used for
#		comparison.
#
#	sortff(L, fields[])
#		like sortf(), except takes an unlimited number of field
#		arguments.
#
#	sortgen(T, m)
#		generates sorted output in a manner specified by m:
#
#			"k+"	sort by key in ascending order
#			"k-"	sort by key in descending order
#			"v+"	sort by value in ascending order
#			"v-"	sort by value in descending order
#
#	sortt(T, i)
#		like sort(T, i) but produces a list of two-element records
#		instead of a list of two-element lists.
#
############################################################################
#
#  Customizable sort procedure for inclusion in Icon programs.
#
#       isort(x,keyproc,y)
#
#  Argument x can be any Icon data type that is divisible into elements
#  by the unary element generation (!) operator.  The result is a list
#  of the objects in sorted order.
#
#  The default is to sort elements in their natural, Icon-defined order.
#  However, an optional parameter (keyproc) allows a sort key to be
#  derived from each element, rather than the default of using the
#  element itself as the key.  Keyproc can be a procedure provided by
#  the caller, in which case the first argument to the key procedure is
#  the item for which the key is to be computed, and the second argument
#  is isort's argument y, passed unchanged.  The keyproc must produce
#  the extracted key.  Alternatively, the keyproc argument can be an
#  integer, in which case it specifies a subscript to be applied to each
#  item to produce a key.  Keyproc will be called once for each element
#  of structure x.
#
############################################################################

package ipl.sort

import lang(Class,Prog,Internal,Text), util(cvslice_def)

procedure isort(x,keyproc,y)
   local items,item,key,result
   if y := integer(keyproc) then
	 keyproc := Prog.get_operator("[]",2)
   else /keyproc := 1
   items := table()
   every item := !x do {
      key := keyproc(item,y)
      (/items[key] := [item]) | put(items[key],item)
      }
   items := sort(items,3)
   result := []
   while get(items) do every put(result,!get(items))
   return result
end

#
# sortff:  structure [x integer [x integer...]] -> structure
#          (L, fields...) -> new_L
#
#     Where L is any subscriptable structure, and fields are any
#     number of integer subscripts in any desired order.  Returns
#     a copy of structure L with its elements sorted on fields[1],
#     and, for those elements having an identical fields[1], sub-
#     sorted on field[2], etc.
#

# sort on multiple fields
procedure sortff(L, fields[])		
    *L <= 1 & { return copy(L) }
    return sortff_1(L, fields, 1, [])
end

package procedure sortff_1(L, fields, k, uniqueObject)

    local sortField, cachedKeyValue, i, startOfRun, thisKey

    sortField := fields[k]
    L := sortf(L, sortField)	# initial sort using fields[k]
    #
    #  If more than one sort field is given, use each field successively
    #  as the current key, and, where members in L have the same value for
    #  this key, do a subsort using fields[k+1].
    #
    if fields[k +:= 1] then {
        #
        #  Set the equal-key-run pointer to the start of the list and
        #  save the value of the first key in the run.
        #
	startOfRun := 1
	cachedKeyValue := L[startOfRun][sortField] | uniqueObject
	every i := 2 to *L do {
	    thisKey := L[i][sortField] | uniqueObject
	    if not (thisKey === cachedKeyValue) then {
	        #
	        # We have an element with a sort key different from the
	        # previous.  If there's a run of more than one equal keys,
	        # sort the sublist.
	        #
		if i - startOfRun > 1 then {
		    L := L[1:startOfRun] |||
			 sortff_1(L[startOfRun:i], fields, k, uniqueObject) |||
			 L[i:0]
		}
	        # Reset the equal-key-run pointer to this key and cache.
		startOfRun := i
		cachedKeyValue := L[startOfRun][sortField] | uniqueObject
            }
	}
	#
	#  Sort a final run if it exists.
	#
	if i - startOfRun > 0 then {
	    L := L[1:startOfRun] |||
		 sortff_1(L[startOfRun:0], fields, k, uniqueObject)
	}
    }

    return L

end

# generate by different sorting orders
procedure sortgen(T, m)		
   local L

   L := sort(T, case m of {
      "k+" | "k-":  1
      "v+" | "v-":  2
      })

   case m of {
      "k+" | "v+":  suspend !L
      "k-" | "v-":  suspend L[*L to 1 by -1]
      }

end

record element(key, value)

# sort to produce list of records
procedure sortt(T, i)		
   local result, k

   if not(integer(i) = (1 | 2)) then runerr(205, i)

   result := []

   every put(result, element(k := key(T), T[k]))

   return sortf(result, i)

end

# This is a comparison function that just reverses the order of the
# `Internal.compare` function.
#
procedure rev_internal_cmp(a, b)
   return Internal.compare(b, a)
end

# Implementation class for `combine_cmp`.
package class CombineCmp()
   private f, g

   public call(a, b)
      local i
      i := f(a, b)
      if i = 0 then
         i := g(a, b)
      return i
   end

   public new(f, g)
      self.f := f
      self.g := g
      return
   end
end

#
# Return a compare function which combines two other compare functions
# in such a way that the second, `g`, is only called if the first,
# `f`, produces a tie for a particular pair (ie returns 0).
#
# @example
# @ l := ["ABC",u"Abc",u"def",u"DEF",u"ABC","def",u"DEf","ABc"]
# @ mergesort(l, combine_cmp(cl_text_cmp, type_cmp))
# @ # gives ["ABC","ABc",u"Abc",u"ABC","def",u"def",u"DEF",u"DEf"]
# @ mergesort(l, combine_cmp(type_cmp, cl_text_cmp))
# @ # gives ["ABC","ABc","def",u"Abc",u"ABC",u"def",u"DEF",u"DEf"]
# @
procedure combine_cmp(f, g)
   return CombineCmp(f, g).call
end

# Implementation class for `index_cmp`.
package class IndexCmp()
   private f, i

   public call(a, b)
      return f(a[i], b[i]) | runerr("Invalid index given to index_cmp")
   end

   public new(i, f)
      self.i := i
      /f := Internal.compare
      self.f := f
      return
   end
end

#
# Return a compare function which applies the comparator function `f` to the
# `i`th field of each item.  `f` defaults to `Internal.compare`.
#
# @example
# @    l := [ [1,54,2], [4,56,23], [4325,1,23], [123,4576,23]]
# @    # sort by the middle element of each item
# @    qsort(l, index_cmp(2))
#
procedure index_cmp(i, f)
   return IndexCmp(i, f).call
end

# Implementation class for `field_cmp`.
package class FieldCmp()
   private f, q

   public call(a, b)
      return f(Class.get(a, q), Class.get(b, q))
   end

   public new(q, f)
      self.q := q
      /f := Internal.compare
      self.f := f
      return
   end
end

#
# A compare function that compares solely by type, using the same
# ordering as the internal sorting functions.
#
procedure type_cmp(a, b)
   return Internal.compare(Internal.order(a), Internal.order(b))
end

#
# Return a compare function which applies the comparator function `f` to the
# field named `q` in each item.  `f` defaults to `Internal.compare`.
#
# @example
# @    l := [Point(1,2),Point(34,4),Point(3,56),Point(23,55)]
# @    # sort by the x element of each item
# @    qsort(l, field_cmp("x"))
#
procedure field_cmp(q, f)
   return FieldCmp(q, f).call
end

# A numeric comparison function; unlike `Internal.compare`, reals and
# integers are sorted in their natural sort order.
#
procedure num_cmp(x, y)
   return if x < y then
      -1
   else if x > y then
      1
   else
      0
end

# A text comparison function; unlike `Internal.compare`, ucs and
# string are sorted together.
#
procedure text_cmp(x, y)
   x := string(x) | runerr(103, x)
   y := string(y) | runerr(103, y)
   return Internal.compare(x, y)
end

# A caseless version of `text_cmp`.
#
procedure cl_text_cmp(x, y)
   x := string(x) | runerr(103, x)
   y := string(y) | runerr(103, y)
   return Text.cl_compare(x, y)
end

# A caseless string comparator function with consistent ordering
# amongst items which compare caselessly equal, so that for example
# abc, aBc, ABC are always sorted in the same order.
#
# This function would not make much sense for use with a SortTable,
# since it would result in duplicate entries which are caselessly
# equal; rather the simpler `cl_text_cmp` should be used.
#
procedure consistent_cl_text_cmp(x, y)
   local i
   x := string(x) | runerr(103, x)
   y := string(y) | runerr(103, y)
   i := Text.cl_compare(x, y)
   if i = 0 then
      i := Internal.compare(x, y)
   return i
end

#
# The classic quick sort procedure.  The given list is sorted
# in-place, and returned.  If pos1 and pos2 are given, then only
# the sublist l[pos1:pos2] is sorted.
#
# @param l the list to sort
# @param cmp a comparator function, default `Internal.compare`
# @param pos1 the first slice index, default 1
# @param pos2 the second slice index, default 0
#
procedure qsort(l, cmp, pos1, pos2)
   local s
   s := cvslice_def(pos1, pos2, *l) | fail
   /cmp := Internal.compare
   return qsort1(l, cmp, s.lo, s.hi - 1)
end

package procedure qsort1(l, cmp, first, last)
   local i, j, pivot
   if last <= first then
      return l
   i := first
   j := last
   pivot := l[(i + j) / 2]
   repeat {
      while cmp(l[i], pivot) < 0 do i +:= 1
      while cmp(l[j], pivot) > 0 do j -:= 1
      if i <= j then {
         l[i] :=: l[j]
         i +:= 1
         j -:= 1
      }
      if i > j then
         break
   }
   if first < j then
      qsort1(l, cmp, first, j)
   if i < last then
      qsort1(l, cmp, i, last)
   return l
end

# A binary search algorithm.  If pos1 and pos2 are given, then only
# the sublist l[pos1:pos2] is searched.
#
# @param l the list to search
# @param val the value to search for
# @param cmp a comparator function, default `Internal.compare`
# @param pos1 the first slice index, default 1
# @param pos2 the second slice index, default 0
#
procedure bsearch(l, val, cmp, pos1, pos2)
   local s, m, c, first, last
   s := cvslice_def(pos1, pos2, *l) | fail
   /cmp := Internal.compare
   first := s.lo
   last := s.hi - 1
   while first <= last do {
      m := (first + last) / 2
      c := cmp(val, l[m])
      if c = 0 then
         return m
      if c > 0 then
         first := m + 1
      else # c < 0
         last := m - 1
   }
end

# A merge sort implementation.  Unlike `qsort`, this returns a sorted
# copy, leaving the original unchanged.  If pos1 and pos2 are given,
# then only the sublist l[pos1:pos2] is sorted, and that sublist is
# returned.
#
# @param l the list to sort
# @param cmp a comparator function, default `Internal.compare`
# @param pos1 the first slice index, default 1
# @param pos2 the second slice index, default 0
#
procedure mergesort(l, cmp, pos1, pos2)
   local s
   s := cvslice_def(pos1, pos2, *l) | fail
   /cmp := Internal.compare
   return mergesort1(l, cmp, s.lo, s.hi - 1)
end

package procedure mergesort1(l, cmp, first, last)
   local l1, l2, l3, m, v1
   if last <= first then
      return l[first:last+1]
   m := (first + last) / 2
   l1 := mergesort1(l, cmp, first, m)
   l2 := mergesort1(l, cmp, m+1, last)
   l3 := []
   every v1 := !l1 do {
      while cmp(v1, l2[1]) > 0 do
         put(l3, get(l2))
      put(l3, v1)
   }
   every put(l3, !l2)
   return l3
end
