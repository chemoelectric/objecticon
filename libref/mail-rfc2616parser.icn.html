<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>rfc2616parser.icn</title></head><body><pre>
<a name="1"/>package mail
<a name="2"/>
<a name="3"/>import 
<a name="4"/>   exception,
<a name="5"/>   ipl.scan,
<a name="6"/>   util
<a name="7"/>
<a name="8"/>record ExtValue(charset, language, value)
<a name="9"/>
<a name="10"/>class RFC2616Parser()
<a name="11"/>   public static const 
<a name="12"/>      CTL_CHAR,
<a name="13"/>      SEPARATORS,
<a name="14"/>      ATOM_CHAR,
<a name="15"/>      QTEXT_CHAR,
<a name="16"/>      LWSP_CHAR,
<a name="17"/>      MIME_CHARSET_CHAR,
<a name="18"/>      LANGUAGE_CHAR,
<a name="19"/>      ATTR_CHAR
<a name="20"/>
<a name="21"/>   private static init()
<a name="22"/>      CTL_CHAR := &amp;ascii[1:33] ++ &amp;ascii[128]
<a name="23"/>      SEPARATORS := '()&lt;&gt;@,;:\\\"/[]?={} \t'
<a name="24"/>      ATOM_CHAR := &amp;ascii -- CTL_CHAR -- SEPARATORS
<a name="25"/>      QTEXT_CHAR := &amp;cset -- '\"\\\r'
<a name="26"/>      LWSP_CHAR := ' \t'
<a name="27"/>      MIME_CHARSET_CHAR := &amp;letters ++ &amp;digits ++ '!#$%&amp;+\-^_/`{}/~'
<a name="28"/>      LANGUAGE_CHAR := &amp;letters ++ &amp;digits ++ '\-'
<a name="29"/>      ATTR_CHAR := ATOM_CHAR -- '*\'%'
<a name="30"/>   end
<a name="31"/>
<a name="32"/>   #
<a name="33"/>   # qtext = &lt;any CHAR excepting &lt;"&gt;, "\" &amp; CR, and including 
<a name="34"/>   #         linear-white-space&gt;
<a name="35"/>   # quoted-pair =  "\" CHAR
<a name="36"/>   # quoted-string = &lt;"&gt; *(qtext/quoted-pair) &lt;"&gt;
<a name="37"/>   #
<a name="38"/>   # Must be preceded by a call to next_token().  Returns the string
<a name="39"/>   # without the surrounding quotes, and any escape sequences
<a name="40"/>   # converted.
<a name="41"/>   #
<a name="42"/>   private parse_and_convert_quoted_string()
<a name="43"/>      local res
<a name="44"/>
<a name="45"/>      res := move(0)  # Empty string, same type as &amp;subject
<a name="46"/>      move(1)
<a name="47"/>
<a name="48"/>      repeat {
<a name="49"/>         if ="\\" then
<a name="50"/>            res ||:= move(1) | throw("Unterminated quoted string")
<a name="51"/>         else if any(QTEXT_CHAR) then
<a name="52"/>            res ||:= tab(many(QTEXT_CHAR))
<a name="53"/>         else if ="\"" then
<a name="54"/>            return res
<a name="55"/>         else
<a name="56"/>            # Missing closing quote or illegal char
<a name="57"/>            throw("Missing closing quote or illegal char")
<a name="58"/>      }
<a name="59"/>   end
<a name="60"/>
<a name="61"/>   #
<a name="62"/>   # Little utility function for quoting a string (if necessary).
<a name="63"/>   #
<a name="64"/>   public static escape_value(s)
<a name="65"/>      # If non-empty and all chars are atom chars, no quotes needed.
<a name="66"/>      return if many(ATOM_CHAR, s) = *s + 1 then
<a name="67"/>         s
<a name="68"/>      else
<a name="69"/>         RFC822Parser.quote_string(s, ~QTEXT_CHAR)
<a name="70"/>   end
<a name="71"/>
<a name="72"/>   #
<a name="73"/>   # atom        =  1*&lt;any CHAR except specials, SPACE and CTLs&gt;
<a name="74"/>   # ie one or more atom_char
<a name="75"/>   #
<a name="76"/>   # Must be preceded by a call to next_token()
<a name="77"/>   #
<a name="78"/>   private parse_atom()
<a name="79"/>      return tab(many(ATOM_CHAR)) | throw("Atom char expected")
<a name="80"/>   end
<a name="81"/>
<a name="82"/>   private next_token()
<a name="83"/>      tab(many(LWSP_CHAR))
<a name="84"/>   end
<a name="85"/>
<a name="86"/>   #
<a name="87"/>   #  value          = token | quoted-string
<a name="88"/>   #
<a name="89"/>   private parse_value()
<a name="90"/>      return if any('\"') then
<a name="91"/>         parse_and_convert_quoted_string()
<a name="92"/>      else
<a name="93"/>         parse_atom()
<a name="94"/>   end
<a name="95"/>   
<a name="96"/>   #
<a name="97"/>   #  type           = token
<a name="98"/>   #
<a name="99"/>   private parse_type()
<a name="100"/>      return parse_atom()
<a name="101"/>   end
<a name="102"/>
<a name="103"/>   #
<a name="104"/>   #  subtype        = token
<a name="105"/>   #
<a name="106"/>   private parse_subtype()
<a name="107"/>      return parse_atom()
<a name="108"/>   end
<a name="109"/>
<a name="110"/>   #
<a name="111"/>   #  parameter      = attribute "=" value
<a name="112"/>   #  attribute      = token
<a name="113"/>   #
<a name="114"/>   #  On success the resulting value is placed into o.
<a name="115"/>   #
<a name="116"/>   private parse_parameter(o)
<a name="117"/>      local key, val
<a name="118"/>      key := parse_atom()
<a name="119"/>      next_token()
<a name="120"/>      ="=" | throw("'=' expected")
<a name="121"/>      next_token()
<a name="122"/>      val := parse_value()
<a name="123"/>      o.set_parameter(key, val)
<a name="124"/>   end
<a name="125"/>
<a name="126"/>   #
<a name="127"/>   #  Content-Type   = "Content-Type" ":" media-type
<a name="128"/>   #  media-type     = type "/" subtype *( ";" parameter )
<a name="129"/>   #
<a name="130"/>   private parse_content_type_impl()
<a name="131"/>      local ty, st, ct
<a name="132"/>
<a name="133"/>      next_token()
<a name="134"/>
<a name="135"/>      ty := parse_type()
<a name="136"/>      next_token()
<a name="137"/>      ="/" | throw("'/' expected")
<a name="138"/>      next_token()
<a name="139"/>      st := parse_subtype()
<a name="140"/>      ct := ContentType(ty, st)
<a name="141"/>
<a name="142"/>      repeat {
<a name="143"/>         next_token()
<a name="144"/>         =";" | break
<a name="145"/>         next_token()
<a name="146"/>         parse_parameter(ct)
<a name="147"/>      }
<a name="148"/>
<a name="149"/>      return ct
<a name="150"/>   end
<a name="151"/>
<a name="152"/>   #
<a name="153"/>   # disposition-type    = "inline" | "attachment" | disp-ext-type
<a name="154"/>   #                      ; case-insensitive
<a name="155"/>   # disp-ext-type       = token
<a name="156"/>   #
<a name="157"/>   private parse_disposition_type()
<a name="158"/>      local s
<a name="159"/>
<a name="160"/>      if s := tab(caseless_match("inline" | "attachment")) then
<a name="161"/>         return s
<a name="162"/>
<a name="163"/>      return parse_atom()
<a name="164"/>   end
<a name="165"/>
<a name="166"/>   # ext-value     = charset  "'" [ language ] "'" value-chars
<a name="167"/>   #               ; like RFC 2231's &lt;extended-initial-value&gt;
<a name="168"/>   #               ; (see [RFC2231], Section 7)
<a name="169"/>   # 
<a name="170"/>   # language      = &lt;Language-Tag, defined in [RFC5646], Section 2.1&gt;
<a name="171"/>   # 
<a name="172"/>   private parse_ext_value()
<a name="173"/>      local s, lang, cs
<a name="174"/>      cs := parse_charset()
<a name="175"/>      next_token()
<a name="176"/>      ="'" | throw("' expected")
<a name="177"/>      next_token()
<a name="178"/>      lang := tab(many(LANGUAGE_CHAR))
<a name="179"/>      next_token()
<a name="180"/>      ="'" | throw("' expected")
<a name="181"/>      next_token()
<a name="182"/>      s := parse_value_chars()
<a name="183"/>      return ExtValue(cs, lang, s)
<a name="184"/>   end
<a name="185"/>
<a name="186"/>   # value-chars   = *( pct-encoded / attr-char )
<a name="187"/>   # 
<a name="188"/>   # pct-encoded   = "%" HEXDIG HEXDIG
<a name="189"/>   #               ; see [RFC3986], Section 2.1
<a name="190"/>   # 
<a name="191"/>   # attr-char     = ALPHA / DIGIT
<a name="192"/>   #               / "!" / "#" / "$" / "&amp;" / "+" / "-" / "."
<a name="193"/>   #               / "^" / "_" / "`" / "|" / "~"
<a name="194"/>   #               ; token except ( "*" / "'" / "%" )
<a name="195"/>   # 
<a name="196"/>   private parse_value_chars()
<a name="197"/>      local s
<a name="198"/>      # Always returns a string, not ucs.  (like URL.percent_decode)
<a name="199"/>      s := ""
<a name="200"/>      repeat {
<a name="201"/>         if any(ATTR_CHAR) then
<a name="202"/>            s ||:= string(tab(many(ATTR_CHAR)))
<a name="203"/>         else if ="%" then
<a name="204"/>            s ||:= char(Format.string_to_int(move(2))) | throw("Invalid % encoding")
<a name="205"/>         else
<a name="206"/>            return s
<a name="207"/>      }
<a name="208"/>   end
<a name="209"/>
<a name="210"/>   #
<a name="211"/>   # charset       = "UTF-8" / "ISO-8859-1" / mime-charset
<a name="212"/>   # mime-charset  = 1*mime-charsetc
<a name="213"/>   # mime-charsetc = ALPHA / DIGIT
<a name="214"/>   #               / "!" / "#" / "$" / "%" / "&amp;"
<a name="215"/>   #               / "+" / "-" / "^" / "_" / "`"
<a name="216"/>   #               / "{" / "}" / "~"
<a name="217"/>   #               ; as &lt;mime-charset&gt; in Section 2.3 of [RFC2978]
<a name="218"/>   #               ; except that the single quote is not included
<a name="219"/>   #               ; SHOULD be registered in the IANA charset registry
<a name="220"/>   #
<a name="221"/>   private parse_charset()
<a name="222"/>      return tab(many(MIME_CHARSET_CHAR)) | throw("Mime charset char expected")
<a name="223"/>   end
<a name="224"/>
<a name="225"/>   #  disposition-parm    = filename-parm | disp-ext-parm
<a name="226"/>   #
<a name="227"/>   #  filename-parm       = "filename" "=" value
<a name="228"/>   #                      | "filename*" "=" ext-value
<a name="229"/>   #
<a name="230"/>   #  disp-ext-parm       = token "=" value
<a name="231"/>   #                      | ext-token "=" ext-value
<a name="232"/>   #  ext-token           = &lt;the characters in token, followed by "*"&gt;
<a name="233"/>   #
<a name="234"/>   private parse_disposition_parm(cd)
<a name="235"/>      local key, val
<a name="236"/>      key := parse_atom()
<a name="237"/>      if key[-1] == "*" then {
<a name="238"/>         next_token()
<a name="239"/>         ="=" | throw("'=' expected")
<a name="240"/>         next_token()
<a name="241"/>         val := parse_ext_value()
<a name="242"/>      } else {
<a name="243"/>         next_token()
<a name="244"/>         ="=" | throw("'=' expected")
<a name="245"/>         next_token()
<a name="246"/>         val := parse_value()
<a name="247"/>      }
<a name="248"/>      cd.set_parameter(key, val)
<a name="249"/>   end
<a name="250"/>
<a name="251"/>   #
<a name="252"/>   # content-disposition = "Content-Disposition" ":"
<a name="253"/>   #                         disposition-type *( ";" disposition-parm )
<a name="254"/>   #
<a name="255"/>   private parse_content_disposition_impl()
<a name="256"/>      local ty, cd
<a name="257"/>
<a name="258"/>      next_token()
<a name="259"/>      ty := parse_disposition_type()
<a name="260"/>      cd := ContentDisposition(ty)
<a name="261"/>
<a name="262"/>      repeat {
<a name="263"/>         next_token()
<a name="264"/>         =";" | break
<a name="265"/>         next_token()
<a name="266"/>         parse_disposition_parm(cd)
<a name="267"/>      }
<a name="268"/>
<a name="269"/>      return cd
<a name="270"/>   end
<a name="271"/>
<a name="272"/>   private end_check(o)
<a name="273"/>      next_token()
<a name="274"/>      pos(0) | throw("Extraneous input: " || tab(0))
<a name="275"/>      return o
<a name="276"/>   end
<a name="277"/>
<a name="278"/>   public parse_content_disposition(s)
<a name="279"/>      return s ? try1{ end_check(parse_content_disposition_impl()) }
<a name="280"/>   end
<a name="281"/>
<a name="282"/>   public parse_content_type(s)
<a name="283"/>      return s ? try1{ end_check(parse_content_type_impl()) }
<a name="284"/>   end
<a name="285"/>end
</pre></body></html>
