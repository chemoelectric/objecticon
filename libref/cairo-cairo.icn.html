<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>cairo.icn</title></head><body><pre>
<a name="1"/>package cairo
<a name="2"/>
<a name="3"/>import graphics(Window,Point,Vector,Pixels,Rectangle,Size),
<a name="4"/>   lang, util, io, ipl.pdco(List)
<a name="5"/>
<a name="6"/>record DeviceOffset(x_offset, y_offset)
<a name="7"/>record DeviceScale(x_scale, y_scale)
<a name="8"/>record Circle(x, y, radius)
<a name="9"/>record ColorStop(offset, color)
<a name="10"/>
<a name="11"/># Succeed if the cairo library is available, or fail and set &amp;why if
<a name="12"/># it isn't.
<a name="13"/>#
<a name="14"/>procedure cairo_available()
<a name="15"/>   succeed \Context.LOADED | error(Context.WHY)
<a name="16"/>end
<a name="17"/>
<a name="18"/>package procedure to_cairo_color(col)
<a name="19"/>   local c
<a name="20"/>   c := Window.parse_color(col) | fail
<a name="21"/>   every !c /:= 65535.0
<a name="22"/>   return c
<a name="23"/>end
<a name="24"/>
<a name="25"/>package procedure to_icon_color(l)
<a name="26"/>   local s, i
<a name="27"/>   every i := 1 to 4 do
<a name="28"/>      l[i] := integer(l[i] * 65535.0)
<a name="29"/>   s := l[1] || "," || l[2] || "," || l[3]
<a name="30"/>   if l[4] ~= 65535 then
<a name="31"/>      s ||:= "," || l[4]
<a name="32"/>   return s
<a name="33"/>end
<a name="34"/>
<a name="35"/># A `PathElement` represents one element of a cairo path.  Note that
<a name="36"/># `PathElement`s don't wrap cairo objects.
<a name="37"/>#
<a name="38"/>abstract class PathElement()
<a name="39"/>   package static to_path_elements(t)
<a name="40"/>      local l
<a name="41"/>      l := []
<a name="42"/>      while put(l, case get(t) of {
<a name="43"/>         0 : MoveTo(get(t), get(t))
<a name="44"/>         1 : LineTo(get(t), get(t))
<a name="45"/>         2 : CurveTo(get(t), get(t), get(t), get(t), get(t), get(t))
<a name="46"/>         3 : ClosePath()
<a name="47"/>      })
<a name="48"/>      return l
<a name="49"/>   end
<a name="50"/>
<a name="51"/>   package static from_path_elements(l)
<a name="52"/>      local t, e
<a name="53"/>      t := []
<a name="54"/>      every e := !l do
<a name="55"/>         case classof(e) of {
<a name="56"/>            MoveTo: every put(t, 0 | e.x | e.y)
<a name="57"/>            LineTo: every put(t, 1 | e.x | e.y)
<a name="58"/>            CurveTo: every put(t, 2 | e.x1 | e.y1 | e.x2 | e.y2 | e.x3 | e.y3)
<a name="59"/>            ClosePath: put(t, 3)
<a name="60"/>         }
<a name="61"/>      return t
<a name="62"/>   end
<a name="63"/>end
<a name="64"/>
<a name="65"/># A class to represent a move-to operation.
<a name="66"/>#
<a name="67"/>class MoveTo(PathElement)
<a name="68"/>   public const x, y
<a name="69"/>
<a name="70"/>   public new(x, y)
<a name="71"/>      self.x := need_real(x)
<a name="72"/>      self.y := need_real(y)
<a name="73"/>      return
<a name="74"/>   end
<a name="75"/>end
<a name="76"/>
<a name="77"/># A class to represent a line-to operation.
<a name="78"/>#
<a name="79"/>class LineTo(PathElement)
<a name="80"/>   public const x, y
<a name="81"/>
<a name="82"/>   public new(x, y)
<a name="83"/>      self.x := need_real(x)
<a name="84"/>      self.y := need_real(y)
<a name="85"/>      return
<a name="86"/>   end
<a name="87"/>end
<a name="88"/>
<a name="89"/># A class to represent a curve-to operation.
<a name="90"/>#
<a name="91"/>class CurveTo(PathElement)
<a name="92"/>   public const x1, y1, x2, y2, x3, y3
<a name="93"/>
<a name="94"/>   public new(x1, y1, x2, y2, x3, y3)
<a name="95"/>      self.x1 := need_real(x1)
<a name="96"/>      self.y1 := need_real(y1)
<a name="97"/>      self.x2 := need_real(x2)
<a name="98"/>      self.y2 := need_real(y2)
<a name="99"/>      self.x3 := need_real(x3)
<a name="100"/>      self.y3 := need_real(y3)
<a name="101"/>      return
<a name="102"/>   end
<a name="103"/>end
<a name="104"/>
<a name="105"/># A class to represent a close-path operation.
<a name="106"/>#
<a name="107"/>class ClosePath(PathElement)
<a name="108"/>end
<a name="109"/>
<a name="110"/># This class represents a 2d transformation matrix.  It does not wrap
<a name="111"/># a cairo object.  Instances are immutable, so operations always
<a name="112"/># return a different new instance.
<a name="113"/>#
<a name="114"/>class Matrix()
<a name="115"/>   # The six elements of the matrix.
<a name="116"/>   #
<a name="117"/>   public const xx, yx, xy, yy, x0, y0
<a name="118"/>
<a name="119"/>   # The identity matrix
<a name="120"/>   #
<a name="121"/>   public static const I
<a name="122"/>
<a name="123"/>   private static init()
<a name="124"/>      I := Matrix(1.0, 0.0, 0.0, 1.0, 0.0, 0.0)
<a name="125"/>   end
<a name="126"/>
<a name="127"/>   # Create a new instance representing a translation.
<a name="128"/>   #
<a name="129"/>   public static from_translation(tx, ty)
<a name="130"/>      return Matrix(1.0, 0.0, 0.0, 1.0, tx, ty)
<a name="131"/>   end
<a name="132"/>
<a name="133"/>   # Create a new instance representing a rotation of `r` radians.
<a name="134"/>   #
<a name="135"/>   public static from_rotation(r)
<a name="136"/>      local c, s
<a name="137"/>      c := Math.cos(r)
<a name="138"/>      s := Math.sin(r)
<a name="139"/>      return Matrix(c, s, -s, c)
<a name="140"/>   end
<a name="141"/>
<a name="142"/>   # Return the determinant of the matrix.
<a name="143"/>   #
<a name="144"/>   public determinant()
<a name="145"/>      return xx * yy - yx * xy
<a name="146"/>   end
<a name="147"/>
<a name="148"/>   # Return a new `Matrix` which is the inverse of this one, or fail
<a name="149"/>   # if there is no inverse.
<a name="150"/>   #
<a name="151"/>   public inverse()
<a name="152"/>      local d
<a name="153"/>      d := determinant()
<a name="154"/>      if d = 0.0 then
<a name="155"/>         fail
<a name="156"/>      return Matrix(yy / d, -yx / d, -xy / d, xx / d, 
<a name="157"/>                    (yx * y0 - x0 * yy) / d, (x0 * xy - xx * y0) / d)
<a name="158"/>   end
<a name="159"/>
<a name="160"/>   # Create a new instance representing a scale.
<a name="161"/>   #
<a name="162"/>   public static from_scale(sx, sy)
<a name="163"/>      return Matrix(sx, 0.0, 0.0, sy, 0.0, 0.0)
<a name="164"/>   end
<a name="165"/>
<a name="166"/>   # Return a `Point` record, which is the result of multiplying this
<a name="167"/>   # matrix by the point `(x, y)`.
<a name="168"/>   #
<a name="169"/>   public multiply_point(x, y)
<a name="170"/>      return Point(xx * x + xy * y + x0, yx * x + yy * y + y0)
<a name="171"/>   end
<a name="172"/>
<a name="173"/>   # Return a `Vector` record, which is the result of multiplying this
<a name="174"/>   # matrix by `(dx, dy)`, but ignoring the transformation elements.
<a name="175"/>   #
<a name="176"/>   public multiply_distance(dx, dy)
<a name="177"/>      return Vector(xx * dx + xy * dy, yx * dx + yy * dy)
<a name="178"/>   end
<a name="179"/>
<a name="180"/>   # Return a new instance which is this instance rotated `r` radians.
<a name="181"/>   #
<a name="182"/>   public rotate(r)
<a name="183"/>      return multiply(from_rotation(r), self)
<a name="184"/>   end
<a name="185"/>
<a name="186"/>   # Return a new instance which is this instance translated by `tx`
<a name="187"/>   # and `ty`.
<a name="188"/>   #
<a name="189"/>   public translate(tx, ty)  
<a name="190"/>      return multiply(from_translation(tx, ty), self)
<a name="191"/>   end
<a name="192"/>
<a name="193"/>   # Return a new instance which is this instance scaled by `sx`
<a name="194"/>   # and `sy`.
<a name="195"/>   #
<a name="196"/>   public scale(sx, sy)
<a name="197"/>      return multiply(from_scale(sx, sy), self)
<a name="198"/>   end
<a name="199"/>
<a name="200"/>   # Return the product of the two given `Matrix` instances.
<a name="201"/>   #
<a name="202"/>   public static multiply(a, b)
<a name="203"/>      return Matrix(a.xx * b.xx + a.yx * b.xy,
<a name="204"/>                    a.xx * b.yx + a.yx * b.yy,
<a name="205"/>                    a.xy * b.xx + a.yy * b.xy,
<a name="206"/>                    a.xy * b.yx + a.yy * b.yy,
<a name="207"/>                    a.xx * b.x0 + a.yx * b.y0 + a.x0,
<a name="208"/>                    a.xy * b.x0 + a.yy * b.y0 + a.y0)
<a name="209"/>   end
<a name="210"/>
<a name="211"/>   # Create a new instance based on the given six elements.
<a name="212"/>   #
<a name="213"/>   public new(xx, yx, xy, yy, x0, y0)
<a name="214"/>      self.xx := need_real(xx)
<a name="215"/>      self.yx := need_real(yx)
<a name="216"/>      self.xy := need_real(xy)
<a name="217"/>      self.yy := need_real(yy)
<a name="218"/>      self.x0 := need_real(\x0) | 0.0
<a name="219"/>      self.y0 := need_real(\y0) | 0.0
<a name="220"/>      return
<a name="221"/>   end
<a name="222"/>end
<a name="223"/>
<a name="224"/># This class wraps a cairo pattern.  There can be several instances
<a name="225"/># wrapping the same cairo object.  Each one has a reference to the
<a name="226"/># underlying object and must be closed separately.
<a name="227"/>#
<a name="228"/>abstract class Pattern(NoCopy, HasClose)
<a name="229"/>   package ptr
<a name="230"/>
<a name="231"/>   private static init()
<a name="232"/>      Class.load_library(\Context.LOADED)
<a name="233"/>   end
<a name="234"/>
<a name="235"/>   package set_ptr(ptr)
<a name="236"/>      self.ptr := ptr
<a name="237"/>      link
<a name="238"/>   end
<a name="239"/>
<a name="240"/>   package static create_for_ptr(ptr)
<a name="241"/>      local c
<a name="242"/>      c := case get_type(ptr) of {
<a name="243"/>         1 : SolidPattern
<a name="244"/>         2 : SurfacePattern
<a name="245"/>         3 : LinearGradient
<a name="246"/>         4 : RadialGradient
<a name="247"/>         5 : MeshPattern
<a name="248"/>      }
<a name="249"/>      return c.create_for_ptr(ptr)
<a name="250"/>   end
<a name="251"/>
<a name="252"/>   private static native get_type(ptr)
<a name="253"/>
<a name="254"/>   # Set the transformation matrix to the identity matrix.
<a name="255"/>   #
<a name="256"/>   public identity_matrix()
<a name="257"/>      return set_matrix(Matrix.I)
<a name="258"/>   end
<a name="259"/>
<a name="260"/>   private native set_matrix_impl(xx, yx, xy, yy, x0, y0)
<a name="261"/>
<a name="262"/>   # Set the transformation matrix from the given `Matrix` instance.
<a name="263"/>   #
<a name="264"/>   public set_matrix(m)
<a name="265"/>      return set_matrix_impl(m.xx, m.yx, m.xy, m.yy, m.x0, m.y0)
<a name="266"/>   end
<a name="267"/>
<a name="268"/>   private native get_matrix_impl()
<a name="269"/>
<a name="270"/>   # Return the transformation matrix as a `Matrix` instance.
<a name="271"/>   #
<a name="272"/>   public get_matrix()
<a name="273"/>      return Matrix!get_matrix_impl()
<a name="274"/>   end
<a name="275"/>
<a name="276"/>   # Set the extend setting according to the given string; possible
<a name="277"/>   # values are "none", "pad", "reflect" and "repeat".  (See `Extend`
<a name="278"/>   # for symbolic constants).
<a name="279"/>   #
<a name="280"/>   public native set_extend(v)
<a name="281"/>
<a name="282"/>   # Get the extend setting as a string.
<a name="283"/>   #
<a name="284"/>   public native get_extend()
<a name="285"/>
<a name="286"/>   # Set the filter according to the given string; possible values are
<a name="287"/>   # "best", "bilinear", "fast", "gaussian", "good", and "nearest".
<a name="288"/>   # (See `Filter` for symbolic constants).
<a name="289"/>   #
<a name="290"/>   public native set_filter(v)
<a name="291"/>
<a name="292"/>   # Return the filter value.
<a name="293"/>   #
<a name="294"/>   public native get_filter()
<a name="295"/>
<a name="296"/>   # Close this instance, releasing the reference to the underlying
<a name="297"/>   # cairo object.
<a name="298"/>   #
<a name="299"/>   public override native close()
<a name="300"/>
<a name="301"/>   # This is a convenient method to create a `Pattern` instance from a
<a name="302"/>   # variety of objects.  `v` can be a `Surface`, a `Window`, a
<a name="303"/>   # `Pixels`, raw image data, or a filename of an image.
<a name="304"/>   #
<a name="305"/>   # Note that if a `Pixels` is given, then a copy is made, and future
<a name="306"/>   # changes to the `Pixels` have no effect on the `Pattern`.
<a name="307"/>   #
<a name="308"/>   public static to_pattern(v)
<a name="309"/>      local t
<a name="310"/>      return if is(v, Surface) then
<a name="311"/>         SurfacePattern(v)
<a name="312"/>      else if is(v, Window) then
<a name="313"/>         use {
<a name="314"/>            t := WindowSurface(v),
<a name="315"/>            SurfacePattern(t)
<a name="316"/>         }
<a name="317"/>      else if is(v, Pixels) then
<a name="318"/>         use {
<a name="319"/>            t := v.convert(ImageSurface.FORMAT),
<a name="320"/>            use {
<a name="321"/>               t := ImageSurface(t),
<a name="322"/>               SurfacePattern(t)
<a name="323"/>            }
<a name="324"/>         }
<a name="325"/>      else
<a name="326"/>         use {
<a name="327"/>            t := ImageSurface(v),
<a name="328"/>            SurfacePattern(t)
<a name="329"/>         }
<a name="330"/>   end
<a name="331"/>end
<a name="332"/>
<a name="333"/># The parent class for `LinearGradient` and `RadialGradient`.
<a name="334"/>#
<a name="335"/>abstract class Gradient(Pattern)
<a name="336"/>   private static init()
<a name="337"/>      Class.load_library(\Context.LOADED)
<a name="338"/>   end
<a name="339"/>
<a name="340"/>   package static create_for_ptr(ptr)
<a name="341"/>      return Class.create_instance().set_ptr(ptr)
<a name="342"/>   end
<a name="343"/>
<a name="344"/>   private native add_color_stop_rgba(offset, r, g, b, a)
<a name="345"/>
<a name="346"/>   # Adds a translucent color stop to this `Gradient`.  The offset
<a name="347"/>   # specifies the location along the gradient's control vector.
<a name="348"/>   # `col` is an icon colour string.
<a name="349"/>   #
<a name="350"/>   public add_color_stop(offset, col)
<a name="351"/>      local c
<a name="352"/>      c := to_cairo_color(col) | fail
<a name="353"/>      return add_color_stop_rgba(offset, c.red, c.green, c.blue, c.alpha)
<a name="354"/>   end
<a name="355"/>
<a name="356"/>   # Gets the number of color stops specified in this instance.
<a name="357"/>   #
<a name="358"/>   public native get_color_stop_count()
<a name="359"/>
<a name="360"/>   # Gets the color stop for stop number `num`, or fail if `num` is
<a name="361"/>   # out of range (`0` to `get_color_stop_count()` - `1`).  The
<a name="362"/>   # returned value is a `ColorStop` instance giving the offset and
<a name="363"/>   # colour in icon string format.
<a name="364"/>   #
<a name="365"/>   public get_color_stop(num)
<a name="366"/>      local l
<a name="367"/>      l := get_color_stop_impl(num) | fail
<a name="368"/>      return ColorStop(pop(l), to_icon_color(l))
<a name="369"/>   end
<a name="370"/>
<a name="371"/>   private native get_color_stop_impl(num)
<a name="372"/>end
<a name="373"/>
<a name="374"/># This class wraps a cairo linear gradient pattern.
<a name="375"/>final class LinearGradient(Gradient)
<a name="376"/>   private static init()
<a name="377"/>      Class.load_library(\Context.LOADED)
<a name="378"/>   end
<a name="379"/>
<a name="380"/>   package static create_for_ptr(ptr)
<a name="381"/>      return Class.create_instance().set_ptr(ptr)
<a name="382"/>   end
<a name="383"/>
<a name="384"/>   # Gets the gradient endpoints for this gradient, as a list of two
<a name="385"/>   # `Point`s.
<a name="386"/>   #
<a name="387"/>   public get_points()
<a name="388"/>      local l
<a name="389"/>      l := get_points_impl()
<a name="390"/>      return [Point(l[1], l[2]), Point(l[3], l[4])]
<a name="391"/>   end
<a name="392"/>   private native get_points_impl()
<a name="393"/>
<a name="394"/>   private static native new_impl()
<a name="395"/>
<a name="396"/>   # Create a new linear gradient along the line defined by `(x0, y0)`
<a name="397"/>   # and `(x1, y1)`. Before using the gradient pattern, a number of
<a name="398"/>   # color stops should be defined using `add_color_stop()`.
<a name="399"/>   #
<a name="400"/>   public new(x0, y0, x1, y1)
<a name="401"/>      cairo_available() | fail
<a name="402"/>      ptr := new_impl(x0, y0, x1, y1)
<a name="403"/>      return
<a name="404"/>   end
<a name="405"/>end
<a name="406"/>
<a name="407"/># This class wraps a cairo radial gradient pattern.
<a name="408"/>#
<a name="409"/>final class RadialGradient(Gradient)
<a name="410"/>   private static init()
<a name="411"/>      Class.load_library(\Context.LOADED)
<a name="412"/>   end
<a name="413"/>
<a name="414"/>   package static create_for_ptr(ptr)
<a name="415"/>      return Class.create_instance().set_ptr(ptr)
<a name="416"/>   end
<a name="417"/>
<a name="418"/>   # Gets the gradient endpoint circles for this radial gradient, as a
<a name="419"/>   # list of two `Circle` records.
<a name="420"/>   #
<a name="421"/>   public get_circles()
<a name="422"/>      local l
<a name="423"/>      l := get_circles_impl()
<a name="424"/>      return [Circle(l[1], l[2], l[3]), Circle(l[4], l[5], l[6])]
<a name="425"/>   end
<a name="426"/>   private native get_circles_impl()
<a name="427"/>
<a name="428"/>   private static native new_impl()
<a name="429"/>
<a name="430"/>   # Creates a new radial gradient between the two circles defined by
<a name="431"/>   # `(cx0, cy0, r0)` and `(cx1, cy1, r1)`. Before using the gradient
<a name="432"/>   # pattern, a number of color stops should be defined using
<a name="433"/>   # `add_color_stop()`.
<a name="434"/>   #
<a name="435"/>   public new(cx0, cy0, r0, cx1, cy1, r1)
<a name="436"/>      cairo_available() | fail
<a name="437"/>      ptr := new_impl(cx0, cy0, r0, cx1, cy1, r1)
<a name="438"/>      return
<a name="439"/>   end
<a name="440"/>end
<a name="441"/>
<a name="442"/># This class wraps a cairo surface pattern instance.
<a name="443"/>#
<a name="444"/>final class SurfacePattern(Pattern)
<a name="445"/>   private static init()
<a name="446"/>      Class.load_library(\Context.LOADED)
<a name="447"/>   end
<a name="448"/>
<a name="449"/>   package static create_for_ptr(ptr)
<a name="450"/>      return Class.create_instance().set_ptr(ptr)
<a name="451"/>   end
<a name="452"/>
<a name="453"/>   # Return the `Surface` used by this pattern; note that a new
<a name="454"/>   # wrapper is returned which must be closed separately to that used
<a name="455"/>   # when the pattern was created.
<a name="456"/>   #
<a name="457"/>   public get_surface()
<a name="458"/>      return Surface.create_for_ptr(get_surface_impl())
<a name="459"/>   end
<a name="460"/>
<a name="461"/>   private native get_surface_impl()
<a name="462"/>      
<a name="463"/>   private static native new_impl(sur)
<a name="464"/>
<a name="465"/>   # Create a new instance from the given `Surface`.
<a name="466"/>   #
<a name="467"/>   public new(sur)
<a name="468"/>      cairo_available() | fail
<a name="469"/>      ptr := new_impl(sur)
<a name="470"/>      return
<a name="471"/>   end
<a name="472"/>end
<a name="473"/>
<a name="474"/># A `Pattern` using a solid colour.
<a name="475"/>#
<a name="476"/>final class SolidPattern(Pattern)
<a name="477"/>   private static init()
<a name="478"/>      Class.load_library(\Context.LOADED)
<a name="479"/>   end
<a name="480"/>
<a name="481"/>   package static create_for_ptr(ptr)
<a name="482"/>      return Class.create_instance().set_ptr(ptr)
<a name="483"/>   end
<a name="484"/>
<a name="485"/>   # Return the icon colour string for this instance.
<a name="486"/>   #
<a name="487"/>   public get_color()
<a name="488"/>      return to_icon_color(get_rgba())
<a name="489"/>   end
<a name="490"/>   
<a name="491"/>   private native get_rgba()
<a name="492"/>
<a name="493"/>   private static native new_impl(r, g, b, a)
<a name="494"/>
<a name="495"/>   # Create a new instance with the given icon colour.  Fails if the
<a name="496"/>   # colour is invalid.
<a name="497"/>   #
<a name="498"/>   public new(col)
<a name="499"/>      local c
<a name="500"/>      cairo_available() | fail
<a name="501"/>      c := to_cairo_color(col) | fail
<a name="502"/>      ptr := new_impl(c.red, c.green, c.blue, c.alpha)
<a name="503"/>      return
<a name="504"/>   end
<a name="505"/>end
<a name="506"/>
<a name="507"/># A `Pattern` which wraps a cairo mesh pattern.
<a name="508"/>#
<a name="509"/>final class MeshPattern(Pattern)
<a name="510"/>   private static init()
<a name="511"/>      Class.load_library(\Context.LOADED)
<a name="512"/>   end
<a name="513"/>
<a name="514"/>   package static create_for_ptr(ptr)
<a name="515"/>      return Class.create_instance().set_ptr(ptr)
<a name="516"/>   end
<a name="517"/>
<a name="518"/>   # Begin a patch in this mesh pattern.
<a name="519"/>   #
<a name="520"/>   public native begin_patch()
<a name="521"/>
<a name="522"/>   # Indicates the end of the current patch in this mesh pattern.
<a name="523"/>   #
<a name="524"/>   public native end_patch()
<a name="525"/>
<a name="526"/>   # Define the first point of the current patch in this mesh pattern.
<a name="527"/>   #
<a name="528"/>   public native move_to(x, y)
<a name="529"/>
<a name="530"/>   # Adds a line to the current patch from the current point to
<a name="531"/>   # position `(x, y)` in pattern-space coordinates.
<a name="532"/>   #
<a name="533"/>   public native line_to(x, y)
<a name="534"/>
<a name="535"/>   # Adds a cubic Bézier spline to the current patch from the current
<a name="536"/>   # point to position `(x3, y3)` in pattern-space coordinates, using
<a name="537"/>   # `(x1, y1)` and `(x2, y2)` as the control points.
<a name="538"/>   #
<a name="539"/>   public native curve_to(x1, y1, x2, y2, x3, y3)
<a name="540"/>
<a name="541"/>   # Set an internal control point of the current patch.  Valid values
<a name="542"/>   # for `point_num` are from 0 to 3.
<a name="543"/>   #
<a name="544"/>   public native set_control_point(point_num, x, y)
<a name="545"/>
<a name="546"/>   # Sets the color of a corner of the current patch in a mesh
<a name="547"/>   # pattern.  Valid values for `corner_num` are from 0 to 3 and
<a name="548"/>   # identify the corners.  `col` is an icon colour string.
<a name="549"/>   #
<a name="550"/>   public set_corner_color(corner_num, col)
<a name="551"/>      local c
<a name="552"/>      c := to_cairo_color(col) | fail
<a name="553"/>      return set_corner_color_rgba(corner_num, c.red, c.green, c.blue, c.alpha)
<a name="554"/>   end
<a name="555"/>
<a name="556"/>   private native set_corner_color_rgba(corner_num, r, g, b, a)
<a name="557"/>
<a name="558"/>   # Gets the number of patches specified in this mesh pattern.
<a name="559"/>   #
<a name="560"/>   public native get_patch_count()
<a name="561"/>
<a name="562"/>   # Gets path defining the patch number `patch_num`. A list of
<a name="563"/>   # `PathElement` objects is returned.
<a name="564"/>   #
<a name="565"/>   public get_path(patch_num)
<a name="566"/>      return PathElement.to_path_elements(get_path_impl(patch_num))
<a name="567"/>   end
<a name="568"/>
<a name="569"/>   private native get_path_impl(patch_num)
<a name="570"/>
<a name="571"/>   # Gets the control point `point_num` of patch `patch_num` as a
<a name="572"/>   # `Point` record.
<a name="573"/>   #
<a name="574"/>   public get_control_point(patch_num, point_num)
<a name="575"/>      return get_control_point_impl(patch_num, point_num, Point)
<a name="576"/>   end
<a name="577"/>
<a name="578"/>   private native get_control_point_impl(patch_num, point_num, con)
<a name="579"/>
<a name="580"/>   # Gets the color information in corner `corner_num` of patch
<a name="581"/>   # `patch_num` as an icon colour string.
<a name="582"/>   #
<a name="583"/>   public get_corner_color(patch_num, corner_num)
<a name="584"/>      return to_icon_color(get_corner_color_rgba(patch_num, corner_num))
<a name="585"/>   end
<a name="586"/>
<a name="587"/>   private native get_corner_color_rgba(patch_num, corner_num)
<a name="588"/>
<a name="589"/>   private static native new_impl()
<a name="590"/>
<a name="591"/>   public new()
<a name="592"/>      cairo_available() | fail
<a name="593"/>      ptr := new_impl()
<a name="594"/>      return
<a name="595"/>   end
<a name="596"/>end
<a name="597"/>
<a name="598"/># This class wraps a cairo surface.  There can be several instances
<a name="599"/># wrapping the same cairo object.  Each one has a reference to the
<a name="600"/># underlying object and must be closed separately.
<a name="601"/>#
<a name="602"/>abstract class Surface(NoCopy, HasClose)
<a name="603"/>   package ptr
<a name="604"/>
<a name="605"/>   private static init()
<a name="606"/>      Class.load_library(\Context.LOADED)
<a name="607"/>   end
<a name="608"/>
<a name="609"/>   package set_ptr(ptr)
<a name="610"/>      self.ptr := ptr
<a name="611"/>      link
<a name="612"/>   end
<a name="613"/>
<a name="614"/>   package static create_for_ptr(ptr)
<a name="615"/>      local c
<a name="616"/>      c := case get_type(ptr) of {
<a name="617"/>         1 : WindowSurface
<a name="618"/>         2 : ImageSurface
<a name="619"/>         3 : SVGSurface
<a name="620"/>         4 : PostScriptSurface
<a name="621"/>         5 : PDFSurface
<a name="622"/>         6 : RecordingSurface
<a name="623"/>      }
<a name="624"/>      return c.create_for_ptr(ptr)
<a name="625"/>   end
<a name="626"/>
<a name="627"/>   private static native get_type(ptr)
<a name="628"/>
<a name="629"/>   # Sets an offset that is added to the device coordinates determined
<a name="630"/>   # by the CTM when drawing to this surface.
<a name="631"/>   #
<a name="632"/>   public native set_device_offset(x_offset, y_offset)
<a name="633"/>
<a name="634"/>   # Sets a scale that is multiplied to the device coordinates
<a name="635"/>   # determined by the CTM when drawing to this surface.
<a name="636"/>   #
<a name="637"/>   public native set_device_scale(x_scale, y_scale)
<a name="638"/>
<a name="639"/>   # Return the device offset set by `set_device_offset()`, as a
<a name="640"/>   # `DeviceOffset` record.
<a name="641"/>   #
<a name="642"/>   public get_device_offset()
<a name="643"/>      return get_device_offset_impl(DeviceOffset())
<a name="644"/>   end
<a name="645"/>
<a name="646"/>   # Return the device offset set by `set_device_scale()`, as a
<a name="647"/>   # `DeviceScale` record.
<a name="648"/>   #
<a name="649"/>   public get_device_scale()
<a name="650"/>      return get_device_scale_impl(DeviceScale())
<a name="651"/>   end
<a name="652"/>
<a name="653"/>   private native get_device_offset_impl(r)
<a name="654"/>   private native get_device_scale_impl(r)
<a name="655"/>
<a name="656"/>   # Close this instance, releasing the reference to the underlying
<a name="657"/>   # cairo object.
<a name="658"/>   #
<a name="659"/>   public override native close()
<a name="660"/>end
<a name="661"/>
<a name="662"/># A `Surface` which reads and writes to a `Window`.
<a name="663"/>#
<a name="664"/>final class WindowSurface(Surface)
<a name="665"/>   private static init()
<a name="666"/>      Class.load_library(\Context.LOADED)
<a name="667"/>   end
<a name="668"/>
<a name="669"/>   package static create_for_ptr(ptr)
<a name="670"/>      return Class.create_instance().set_ptr(ptr)
<a name="671"/>   end
<a name="672"/>
<a name="673"/>   # Get the width of the X Drawable underlying this surface in pixels.
<a name="674"/>   #
<a name="675"/>   public native get_width()
<a name="676"/>
<a name="677"/>   # Get the height of the X Drawable underlying this surface in pixels.
<a name="678"/>   #
<a name="679"/>   public native get_height()
<a name="680"/>
<a name="681"/>   # Get the number of bits used to represent each pixel value.
<a name="682"/>   #
<a name="683"/>   public native get_depth()
<a name="684"/>
<a name="685"/>   # Get the size, as a `Size` record.
<a name="686"/>   #
<a name="687"/>   public get_size()
<a name="688"/>      return Size(get_width(), get_height())
<a name="689"/>   end
<a name="690"/>
<a name="691"/>   private static native new_impl()
<a name="692"/>
<a name="693"/>   # Create a new instance from the given `Window`.
<a name="694"/>   #
<a name="695"/>   public new(win)
<a name="696"/>      cairo_available() | fail
<a name="697"/>      ptr := new_impl(win)
<a name="698"/>      return
<a name="699"/>   end
<a name="700"/>end
<a name="701"/>
<a name="702"/># A `Surface` which reads and writes from a `Pixels`.
<a name="703"/>#
<a name="704"/>final class ImageSurface(Surface)
<a name="705"/>   # The only supported format, as a `Pixels` format string.  This
<a name="706"/>   # will be `&amp;null` if cairo is not available.
<a name="707"/>   #
<a name="708"/>   public static const FORMAT
<a name="709"/>
<a name="710"/>   private static init()
<a name="711"/>      if Class.load_library(\Context.LOADED) then
<a name="712"/>         FORMAT := get_format()
<a name="713"/>   end
<a name="714"/>
<a name="715"/>   package static create_for_ptr(ptr)
<a name="716"/>      return Class.create_instance().set_ptr(ptr)
<a name="717"/>   end
<a name="718"/>
<a name="719"/>   # Get the width of the image surface in pixels.
<a name="720"/>   #
<a name="721"/>   public native get_width()
<a name="722"/>
<a name="723"/>   # Get the height of the image surface in pixels.
<a name="724"/>   #
<a name="725"/>   public native get_height()
<a name="726"/>
<a name="727"/>   # Get the size, as a `Size` record.
<a name="728"/>   #
<a name="729"/>   public get_size()
<a name="730"/>      return Size(get_width(), get_height())
<a name="731"/>   end
<a name="732"/>
<a name="733"/>   private static native get_format()
<a name="734"/>
<a name="735"/>   private static native new_impl(pix)
<a name="736"/>
<a name="737"/>   # Create a new instance.  If one parameter is given, then that may
<a name="738"/>   # be a `Pixels` instance, in which case it must have the format
<a name="739"/>   # `ImageSurface.FORMAT`, and the new `ImageSurface` wraps the
<a name="740"/>   # `Pixels` instance, and shares its data.  Otherwise, the parameter
<a name="741"/>   # may be raw image data, or a filename of an image, and a new
<a name="742"/>   # `ImageSurface` with initialized content is created.
<a name="743"/>   #
<a name="744"/>   # If two parameters are given, then they specify a width and
<a name="745"/>   # height, and a new blank `ImageSurface` is created.
<a name="746"/>   #
<a name="747"/>   public new(a[])
<a name="748"/>      local v, t
<a name="749"/>      cairo_available() | fail
<a name="750"/>      ptr := if *a = 1 then {
<a name="751"/>         v := a[1]
<a name="752"/>         if is(v, Pixels) then {
<a name="753"/>            # Wrap an existing Pixels
<a name="754"/>            v.get_format() == FORMAT | runerr("Invalid format", v)
<a name="755"/>            new_impl(v)
<a name="756"/>         } else {
<a name="757"/>            # Filename, image string, etc.
<a name="758"/>            use {
<a name="759"/>               t := Pixels(v),
<a name="760"/>               use {
<a name="761"/>                  t := t.convert(FORMAT),
<a name="762"/>                  new_impl(t)
<a name="763"/>               }
<a name="764"/>            } | fail
<a name="765"/>         }
<a name="766"/>      } else if *a = 2 then {
<a name="767"/>         # Width and height
<a name="768"/>         use {
<a name="769"/>            t := Pixels(a[1], a[2], FORMAT),
<a name="770"/>            new_impl(t)
<a name="771"/>         }         
<a name="772"/>      } else
<a name="773"/>         runerr("Incorrect number of parameters")
<a name="774"/>      return
<a name="775"/>   end
<a name="776"/>end
<a name="777"/>
<a name="778"/># Parent class of surfaces based on pages.
<a name="779"/>#
<a name="780"/>abstract class PagedSurface(Surface)
<a name="781"/>   private static init()
<a name="782"/>      Class.load_library(\Context.LOADED)
<a name="783"/>   end
<a name="784"/>
<a name="785"/>   # Emits the current page, but doesn't clear it, so that the
<a name="786"/>   # contents of the current page will be retained for the next page.
<a name="787"/>   #
<a name="788"/>   public native copy_page()
<a name="789"/>
<a name="790"/>   # Emits and clears the current page. Use `copy_page() if you don't
<a name="791"/>   # want to clear the page.
<a name="792"/>   #
<a name="793"/>   public native show_page()
<a name="794"/>end
<a name="795"/>
<a name="796"/># This class wraps a cairo svg surface object.
<a name="797"/>#
<a name="798"/>final class SVGSurface(PagedSurface)
<a name="799"/>   private static init()
<a name="800"/>      Class.load_library(\Context.LOADED)
<a name="801"/>   end
<a name="802"/>
<a name="803"/>   package static create_for_ptr(ptr)
<a name="804"/>      return Class.create_instance().set_ptr(ptr)
<a name="805"/>   end
<a name="806"/>
<a name="807"/>   private static native new_impl()
<a name="808"/>
<a name="809"/>   # Creates a SVG surface of the specified size in points to be
<a name="810"/>   # written to filename .
<a name="811"/>   #
<a name="812"/>   public new(filename, width, height)
<a name="813"/>      cairo_available() | fail
<a name="814"/>      ptr := new_impl(filename, width, height)
<a name="815"/>      return
<a name="816"/>   end
<a name="817"/>end
<a name="818"/>
<a name="819"/># This class wraps a cairo Postscript surface object.
<a name="820"/>#
<a name="821"/>final class PostScriptSurface(PagedSurface)
<a name="822"/>   private static init()
<a name="823"/>      Class.load_library(\Context.LOADED)
<a name="824"/>   end
<a name="825"/>
<a name="826"/>   package static create_for_ptr(ptr)
<a name="827"/>      return Class.create_instance().set_ptr(ptr)
<a name="828"/>   end
<a name="829"/>
<a name="830"/>   # Changes the size of a PostScript surface for the current (and
<a name="831"/>   # subsequent) pages.
<a name="832"/>   #
<a name="833"/>   public native set_size(width, height)
<a name="834"/>
<a name="835"/>   private static native new_impl()
<a name="836"/>
<a name="837"/>   public new(filename, width, height)
<a name="838"/>      cairo_available() | fail
<a name="839"/>      ptr := new_impl(filename, width, height)
<a name="840"/>      return
<a name="841"/>   end
<a name="842"/>end
<a name="843"/>
<a name="844"/># This class wraps a cairo PDF surface object.
<a name="845"/>#
<a name="846"/>final class PDFSurface(PagedSurface)
<a name="847"/>   private static init()
<a name="848"/>      Class.load_library(\Context.LOADED)
<a name="849"/>   end
<a name="850"/>
<a name="851"/>   package static create_for_ptr(ptr)
<a name="852"/>      return Class.create_instance().set_ptr(ptr)
<a name="853"/>   end
<a name="854"/>
<a name="855"/>   # Changes the size of a PDF surface for the current (and
<a name="856"/>   # subsequent) pages.
<a name="857"/>   #
<a name="858"/>   public native set_size(width, height)
<a name="859"/>
<a name="860"/>   private static native new_impl()
<a name="861"/>
<a name="862"/>   public new(filename, width, height)
<a name="863"/>      cairo_available() | fail
<a name="864"/>      ptr := new_impl(filename, width, height)
<a name="865"/>      return
<a name="866"/>   end
<a name="867"/>end
<a name="868"/>
<a name="869"/># This class wraps a cairo recording surface, which can be used to
<a name="870"/># record all drawing operations at the highest level (that is, the
<a name="871"/># level of paint, mask, stroke, fill and show_text_glyphs). The
<a name="872"/># recording surface can then be "replayed" against any target surface
<a name="873"/># by using it as a source to drawing operations.
<a name="874"/>#
<a name="875"/>final class RecordingSurface(Surface)
<a name="876"/>   private static init()
<a name="877"/>      Class.load_library(\Context.LOADED)
<a name="878"/>   end
<a name="879"/>
<a name="880"/>   package static create_for_ptr(ptr)
<a name="881"/>      return Class.create_instance().set_ptr(ptr)
<a name="882"/>   end
<a name="883"/>
<a name="884"/>   # Get the extents of the recording-surface, as a `Rectangle`
<a name="885"/>   # record.
<a name="886"/>   #
<a name="887"/>   public get_extents()
<a name="888"/>      return get_extents_impl(Rectangle)
<a name="889"/>   end
<a name="890"/>
<a name="891"/>   # Measures the extents of the operations stored within the
<a name="892"/>   # recording-surface.  A `Rectangle` record is returned.
<a name="893"/>   #
<a name="894"/>   public ink_extents()
<a name="895"/>      return ink_extents_impl(Rectangle())
<a name="896"/>   end
<a name="897"/>
<a name="898"/>   private native get_extents_impl(con)
<a name="899"/>   private native ink_extents_impl(r)
<a name="900"/>
<a name="901"/>   private static native new_impl()
<a name="902"/>
<a name="903"/>   # Create a recording surface with the given extents.  The extents
<a name="904"/>   # may be omitted, in which case the recording is unbounded.
<a name="905"/>   #
<a name="906"/>   public new(x, y, width, height)
<a name="907"/>      cairo_available() | fail
<a name="908"/>      ptr := new_impl(x, y, width, height)
<a name="909"/>      return
<a name="910"/>   end
<a name="911"/>end
<a name="912"/>
<a name="913"/># This class wraps a cairo drawing context.
<a name="914"/>#
<a name="915"/>final class Context(NoCopy, HasClose)
<a name="916"/>   private ptr
<a name="917"/>
<a name="918"/>   public static const LOADED, WHY
<a name="919"/>
<a name="920"/>   private static init()
<a name="921"/>      local t
<a name="922"/>      if t := Files.find_native_lib("objecticoncairolib") then {
<a name="923"/>         if Class.load_library(t) then
<a name="924"/>            LOADED := t
<a name="925"/>         else
<a name="926"/>            WHY := "Failed to load cairo library: " || &amp;why
<a name="927"/>      } else
<a name="928"/>         WHY := "Cairo library not found on OI_NATIVE path"
<a name="929"/>   end
<a name="930"/>
<a name="931"/>   # Begin a new sub-path. After this call the current point will be
<a name="932"/>   # `(x, y)`.
<a name="933"/>   #
<a name="934"/>   public native move_to(x, y)
<a name="935"/>
<a name="936"/>   # Begin a new sub-path. After this call the current point will
<a name="937"/>   # offset by `(dx, dy)`.
<a name="938"/>   #
<a name="939"/>   public native rel_move_to(dx, dy)
<a name="940"/>
<a name="941"/>   # Adds a line to the path from the current point to position `(x,
<a name="942"/>   # y)` in user-space coordinates. After this call the current point
<a name="943"/>   # will be `(x, y)`.
<a name="944"/>   #
<a name="945"/>   public native line_to(x, y)
<a name="946"/>
<a name="947"/>   # Adds a line to the path from the current point to a point that is
<a name="948"/>   # offset from the current point by `(dx, dy)` in user space. After
<a name="949"/>   # this call the current point will be offset by `(dx , dy)`.
<a name="950"/>   #
<a name="951"/>   public native rel_line_to(dx, dy)
<a name="952"/>
<a name="953"/>   # Adds a cubic Bézier spline to the path from the current point to
<a name="954"/>   # position `(x3, y3)` in user-space coordinates, using `(x1, y1)`
<a name="955"/>   # and `(x2, y2)` as the control points. After this call the current
<a name="956"/>   # point will be `(x3, y3)`.
<a name="957"/>   #
<a name="958"/>   public native curve_to(x1, y1, x2, y2, x3, y3)
<a name="959"/>
<a name="960"/>   # Adds a cubic Bézier spline to the path from the current point to
<a name="961"/>   # a point offset from the current point by `(dx3, dy3)`, using
<a name="962"/>   # points offset by `(dx1, dy1)` and `(dx2, dy2)` as the control
<a name="963"/>   # points. After this call the current point will be offset by
<a name="964"/>   # `(dx3, dy3)`.
<a name="965"/>   #
<a name="966"/>   public native rel_curve_to(dx1, dy1, dx2, dy2, dx3, dy3)
<a name="967"/>
<a name="968"/>   # This function strokes the current path according to the current
<a name="969"/>   # line width, line join, line cap, and dash settings. Afterwards,
<a name="970"/>   # the current path will be cleared from this `Context`.
<a name="971"/>   #
<a name="972"/>   public native stroke()
<a name="973"/>
<a name="974"/>   # Like `stroke()`, but preserves the path within the `Context`.
<a name="975"/>   #
<a name="976"/>   public native stroke_preserve()
<a name="977"/>
<a name="978"/>   # Sets the current line width within this `Context`.
<a name="979"/>   #
<a name="980"/>   public native set_line_width(w)
<a name="981"/>   
<a name="982"/>   # Set the line join according to the given string; possible values
<a name="983"/>   # are "bevel", "miter", and "round".  (See `LineJoin` for symbolic
<a name="984"/>   # constants).
<a name="985"/>   #
<a name="986"/>   public native set_line_join(v)
<a name="987"/>
<a name="988"/>   # Set the line join according to the given string; possible values
<a name="989"/>   # are "butt", "round", and "square".  (See `LineCap` for symbolic
<a name="990"/>   # constants).
<a name="991"/>   #
<a name="992"/>   public native set_line_cap(v)
<a name="993"/>
<a name="994"/>   # Set the line join according to the given string; possible values
<a name="995"/>   # are "even-odd" or "winding".  (See `FillRule` for symbolic
<a name="996"/>   # constants).
<a name="997"/>   #
<a name="998"/>   public native set_fill_rule(v)
<a name="999"/>
<a name="1000"/>   # Sets the dash pattern to be used by `stroke()`.  The `offset`
<a name="1001"/>   # specifies an offset into the pattern at which the stroke begins.
<a name="1002"/>   # A dash pattern is specified by `dashes`, a list of positive
<a name="1003"/>   # values.  Each value provides the length of alternate "on" and
<a name="1004"/>   # "off" portions of the stroke.
<a name="1005"/>   #
<a name="1006"/>   # To clear the dash setting, call `set_dash()` with no arguments.
<a name="1007"/>   #
<a name="1008"/>   public native set_dash(offset, dashes[])
<a name="1009"/>
<a name="1010"/>   # Set the font to use for drawing text; the value `f` is an icon
<a name="1011"/>   # font specification string.
<a name="1012"/>   #
<a name="1013"/>   public native set_font(f)
<a name="1014"/>
<a name="1015"/>   # Sets the current miter limit within this `Context`.  If the
<a name="1016"/>   # current line join style is set to "miter" (see
<a name="1017"/>   # `set_line_join()`), the miter limit is used to determine whether
<a name="1018"/>   # the lines should be joined with a bevel instead of a miter.
<a name="1019"/>   #
<a name="1020"/>   public native set_miter_limit(v)
<a name="1021"/>
<a name="1022"/>   # Sets the tolerance used when converting paths into trapezoids.
<a name="1023"/>   # The default value is 0.1. A larger value will give better
<a name="1024"/>   # performance, a smaller value, better appearance.
<a name="1025"/>   #
<a name="1026"/>   public native set_tolerance(v)
<a name="1027"/>
<a name="1028"/>   # Adds a circular arc of the given radius `r` to the current path.
<a name="1029"/>   # The arc is centered at `(xc, yc)`, begins at `angle1` and
<a name="1030"/>   # proceeds in the direction of increasing angles to end at
<a name="1031"/>   # `angle2`.
<a name="1032"/>   #
<a name="1033"/>   public native arc(xc, yc, r, angle1, angle2)
<a name="1034"/>   
<a name="1035"/>   # Adds a circular arc of the given radius `r` to the current
<a name="1036"/>   # path. The arc is centered at `(xc, yc)`, begins at `angle1` and
<a name="1037"/>   # proceeds in the direction of decreasing angles to end at
<a name="1038"/>   # `angle2`.
<a name="1039"/>   #
<a name="1040"/>   public native arc_negative(xc, yc, r, angle1, angle2)
<a name="1041"/>
<a name="1042"/>   # Adds a closed sub-path rectangle of the given size to the current
<a name="1043"/>   # path at position `(x, y)` in user-space coordinates.
<a name="1044"/>   #
<a name="1045"/>   public native rectangle(x, y, width, height)
<a name="1046"/>
<a name="1047"/>   # Fills the current path according to the current fill rule, (each
<a name="1048"/>   # sub-path is implicitly closed before being filled). After
<a name="1049"/>   # `fill()`, the current path will be cleared from this `Context`.
<a name="1050"/>   #
<a name="1051"/>   public native fill()
<a name="1052"/>
<a name="1053"/>   # Like `fill()`, but preserves the path in the `Context`.
<a name="1054"/>   #
<a name="1055"/>   public native fill_preserve()
<a name="1056"/>
<a name="1057"/>   # Paints the current source everywhere within the current clip region.
<a name="1058"/>   #
<a name="1059"/>   public native paint()
<a name="1060"/>
<a name="1061"/>   # Paints the current source everywhere within the current clip
<a name="1062"/>   # region using a mask of constant alpha value `alpha`.
<a name="1063"/>   #
<a name="1064"/>   public native paint_with_alpha(alpha)
<a name="1065"/>
<a name="1066"/>   # Paints the current source using the alpha channel of `Pattern`
<a name="1067"/>   # `pattern` as a mask. (Opaque areas of `pattern` are painted with
<a name="1068"/>   # the source, transparent areas are not painted).
<a name="1069"/>   #
<a name="1070"/>   public native mask(pattern)
<a name="1071"/>
<a name="1072"/>   # Paints the current source using the alpha channel of `Surface`
<a name="1073"/>   # `surface` as a mask. (Opaque areas of `surface` are painted with
<a name="1074"/>   # the source, transparent areas are not painted.)  `x` and `y` give
<a name="1075"/>   # the point at which to place the origin of `surface`.
<a name="1076"/>   #
<a name="1077"/>   public native mask_surface(surface, x, y)
<a name="1078"/>
<a name="1079"/>   # Add a path representing the given string `s`.
<a name="1080"/>   #
<a name="1081"/>   public native text_path(s)
<a name="1082"/>
<a name="1083"/>   # Return the logical extent of the given text were it to be
<a name="1084"/>   # rendered, as a `Size` record, in real user space units.
<a name="1085"/>   #
<a name="1086"/>   public text_size(s)
<a name="1087"/>      return text_size_impl(s, Size())
<a name="1088"/>   end
<a name="1089"/>
<a name="1090"/>   # Return the Pango baseline value for this context, as a real
<a name="1091"/>   # number of user space units.
<a name="1092"/>   #
<a name="1093"/>   public native get_baseline()
<a name="1094"/>
<a name="1095"/>   # Adds a line segment to the path from the current point to the
<a name="1096"/>   # beginning of the current sub-path, (the most recent point passed
<a name="1097"/>   # to `move_to()`), and closes this sub-path. After this call
<a name="1098"/>   # the current point will be at the joined endpoint of the sub-path.
<a name="1099"/>   #
<a name="1100"/>   public native close_path()
<a name="1101"/>
<a name="1102"/>   # Clears the current path. After this call there will be no path
<a name="1103"/>   # and no current point.
<a name="1104"/>   public native new_path()
<a name="1105"/>
<a name="1106"/>   # Begin a new sub-path. Note that the existing path is not
<a name="1107"/>   # affected. After this call there will be no current point.
<a name="1108"/>   public native new_sub_path()
<a name="1109"/>
<a name="1110"/>   # Close this instance, releasing the reference to the underlying
<a name="1111"/>   # cairo object.
<a name="1112"/>   #
<a name="1113"/>   public override native close()
<a name="1114"/>
<a name="1115"/>   # Set the drawing operator according to the given string; possible
<a name="1116"/>   # values are "atop", "clear", "dest", "dest atop", "dest in", "dest
<a name="1117"/>   # out", "dest over", "in", "out", "over", "source", and "xor".
<a name="1118"/>   # (See `DrawOp` for symbolic constants).
<a name="1119"/>   #
<a name="1120"/>   public native set_operator(op)
<a name="1121"/>
<a name="1122"/>   # Set the antialias setting according to the given string; possible
<a name="1123"/>   # values are "best", "default", "fast", "good", "gray", "none", and
<a name="1124"/>   # "subpixel". (See `Antialias` for symbolic constants).
<a name="1125"/>   #
<a name="1126"/>   public native set_antialias(v)
<a name="1127"/>
<a name="1128"/>   # Returns the current line width value exactly as set by `set_line_width()`.
<a name="1129"/>   #
<a name="1130"/>   public native get_line_width()
<a name="1131"/>
<a name="1132"/>   # Gets the current line join style, as set by `set_line_join()`.
<a name="1133"/>   #
<a name="1134"/>   public native get_line_join()
<a name="1135"/>
<a name="1136"/>   # Gets the current line cap style, as set by `set_line_cap()`.
<a name="1137"/>   #
<a name="1138"/>   public native get_line_cap()
<a name="1139"/>
<a name="1140"/>   # Gets the current fill rule, as set by `set_fill_rule()`.
<a name="1141"/>   #
<a name="1142"/>   public native get_fill_rule()
<a name="1143"/>
<a name="1144"/>   # Gets the current miter limit, as set by `set_miter_limit()`.
<a name="1145"/>   #
<a name="1146"/>   public native get_miter_limit()
<a name="1147"/>
<a name="1148"/>   # Gets the current tolerance value, as set by `set_tolerance()`.
<a name="1149"/>   #
<a name="1150"/>   public native get_tolerance()
<a name="1151"/>
<a name="1152"/>   # Gets the current shape antialiasing mode, as set by `set_antialias()`.
<a name="1153"/>   #
<a name="1154"/>   public native get_antialias()
<a name="1155"/>
<a name="1156"/>   # Gets the current compositing operator, as set by `set_operator()`.
<a name="1157"/>   #
<a name="1158"/>   public native get_operator()
<a name="1159"/>
<a name="1160"/>   # Get the dash offset, as set by `set_dash()`.
<a name="1161"/>   #
<a name="1162"/>   public native get_dash_offset()
<a name="1163"/>
<a name="1164"/>   # Return the list of dashes, set by `set_dash()`, or fail if
<a name="1165"/>   # dashing is not set.
<a name="1166"/>   #
<a name="1167"/>   public native get_dashes()
<a name="1168"/>
<a name="1169"/>   # Gets a copy of the current path.  A list of `PathElement` objects
<a name="1170"/>   # is returned.
<a name="1171"/>   public get_path()
<a name="1172"/>      return PathElement.to_path_elements(get_path_impl())
<a name="1173"/>   end
<a name="1174"/>
<a name="1175"/>   # Gets a flattened copy of the current path (ie one with curves
<a name="1176"/>   # approximated as lines).  A list of `PathElement` objects is
<a name="1177"/>   # returned.
<a name="1178"/>   public get_flat_path()
<a name="1179"/>      return PathElement.to_path_elements(get_flat_path_impl())
<a name="1180"/>   end
<a name="1181"/>
<a name="1182"/>   # Append the path onto the current path.  The given list `l` should
<a name="1183"/>   # be a list of `PathElement` objects.
<a name="1184"/>   public append_path(l)
<a name="1185"/>      return append_path_impl(PathElement.from_path_elements(l))
<a name="1186"/>   end
<a name="1187"/>
<a name="1188"/>   # Gets the current point of the current path, as a `Point` record,
<a name="1189"/>   # or fail if there is no defined current point.
<a name="1190"/>   public get_current_point()
<a name="1191"/>      return get_current_point_impl(Point)
<a name="1192"/>   end
<a name="1193"/>
<a name="1194"/>   # Makes a copy of the current state of this `Context` and saves it
<a name="1195"/>   # on an internal stack of saved states.  When `restore()` is
<a name="1196"/>   # called, the `Context` will be restored to the saved state.
<a name="1197"/>   #
<a name="1198"/>   public native save()
<a name="1199"/>
<a name="1200"/>   # Restores this instance to the state saved by a preceding call to
<a name="1201"/>   # `save()` and removes that state from the stack of saved states.
<a name="1202"/>   #
<a name="1203"/>   public native restore()
<a name="1204"/>
<a name="1205"/>   # Returns a `Rectangle` record, which is a bounding box in user
<a name="1206"/>   # coordinates covering the area that would be affected, (the
<a name="1207"/>   # "inked" area), by a `stroke()` operation given the current path
<a name="1208"/>   # and stroke parameters. If the current path is empty, returns an
<a name="1209"/>   # empty rectangle. Surface dimensions and clipping are not taken
<a name="1210"/>   # into account.
<a name="1211"/>   #
<a name="1212"/>   public get_stroke_extents()
<a name="1213"/>      return get_stroke_extents_impl(Rectangle())
<a name="1214"/>   end
<a name="1215"/>
<a name="1216"/>   # Returns a `Rectangle` record, which is a bounding box in user
<a name="1217"/>   # coordinates covering the area that would be affected, (the
<a name="1218"/>   # "inked" area), by a `fill()` operation given the current path and
<a name="1219"/>   # fill parameters. If the current path is empty, returns an empty
<a name="1220"/>   # rectangle. Surface dimensions and clipping are not taken into
<a name="1221"/>   # account.
<a name="1222"/>   #
<a name="1223"/>   public get_fill_extents()
<a name="1224"/>      return get_fill_extents_impl(Rectangle())
<a name="1225"/>   end
<a name="1226"/>
<a name="1227"/>   # Returns a `Rectangle` record, which is a bounding box in user
<a name="1228"/>   # coordinates covering the area inside the current clip.
<a name="1229"/>   #
<a name="1230"/>   public get_clip_extents()
<a name="1231"/>      return get_clip_extents_impl(Rectangle())
<a name="1232"/>   end
<a name="1233"/>
<a name="1234"/>   # Returns a `Rectangle` record, which is a bounding box in
<a name="1235"/>   # user-space coordinates covering the points on the current
<a name="1236"/>   # path. If the current path is empty, returns an empty
<a name="1237"/>   # rectangle. Stroke parameters, fill rule, surface dimensions and
<a name="1238"/>   # clipping are not taken into account.
<a name="1239"/>   #
<a name="1240"/>   public get_path_extents()
<a name="1241"/>      return get_path_extents_impl(Rectangle())
<a name="1242"/>   end
<a name="1243"/>
<a name="1244"/>   # Transform a coordinate from user space to device space by
<a name="1245"/>   # multiplying the given point by the current transformation matrix
<a name="1246"/>   # (CTM).  A `Point` record is returned.
<a name="1247"/>   #
<a name="1248"/>   public user_to_device(x, y)
<a name="1249"/>      return user_to_device_impl(x, y, Point())
<a name="1250"/>   end
<a name="1251"/>
<a name="1252"/>   # Transform a coordinate from device space to user space by
<a name="1253"/>   # multiplying the given point by the inverse of the current
<a name="1254"/>   # transformation matrix (CTM).  A `Point` record is returned.
<a name="1255"/>   #
<a name="1256"/>   public device_to_user(x, y)
<a name="1257"/>      return device_to_user_impl(x, y, Point())
<a name="1258"/>   end
<a name="1259"/>
<a name="1260"/>   # Transform a distance vector from user space to device space. This
<a name="1261"/>   # function is similar to `user_to_device()` except that the
<a name="1262"/>   # translation components of the CTM will be ignored when
<a name="1263"/>   # transforming `(dx, dy)`.  A `Vector` record is returned.
<a name="1264"/>   #
<a name="1265"/>   public user_to_device_distance(dx, dy)
<a name="1266"/>      return user_to_device_distance_impl(dx, dy, Vector())
<a name="1267"/>   end
<a name="1268"/>
<a name="1269"/>   # Transform a distance vector from device space to user space. This
<a name="1270"/>   # function is similar to `device_to_user()` except that the
<a name="1271"/>   # translation components of the inverse CTM will be ignored when
<a name="1272"/>   # transforming `(dx, dy)`.  A `Vector` record is returned.
<a name="1273"/>   #
<a name="1274"/>   public device_to_user_distance(dx, dy)
<a name="1275"/>      return device_to_user_distance_impl(dx, dy, Vector())
<a name="1276"/>   end
<a name="1277"/>
<a name="1278"/>   # Modifies the current transformation matrix (CTM) by translating
<a name="1279"/>   # the user-space origin by `(tx, ty)`.
<a name="1280"/>   #
<a name="1281"/>   public native translate(tx, ty)
<a name="1282"/>
<a name="1283"/>   # Modifies the current transformation matrix (CTM) by scaling the X
<a name="1284"/>   # and Y user-space axes by `sx` and `sy` respectively.
<a name="1285"/>   #
<a name="1286"/>   public native scale(sx, sy)
<a name="1287"/>
<a name="1288"/>   # Modifies the current transformation matrix (CTM) by rotating the
<a name="1289"/>   # user-space axes by `r` radians.
<a name="1290"/>   #
<a name="1291"/>   public native rotate(r)
<a name="1292"/>
<a name="1293"/>   # Establishes a new clip region by intersecting the current clip
<a name="1294"/>   # region with the current path as it would be filled by `fill()`
<a name="1295"/>   # and according to the current fill rule (see `set_fill_rule()`).
<a name="1296"/>   # After `clip()`, the current path will be cleared from the cairo
<a name="1297"/>   # context.
<a name="1298"/>   #
<a name="1299"/>   public native clip()
<a name="1300"/>
<a name="1301"/>   # Like `clip()`, but preserves the path.
<a name="1302"/>   #
<a name="1303"/>   public native clip_preserve()
<a name="1304"/>
<a name="1305"/>   # Reset the current clip region to its original, unrestricted state.
<a name="1306"/>   #
<a name="1307"/>   public native reset_clip()
<a name="1308"/>
<a name="1309"/>   # Gets the current clip region as a list of rectangles in user
<a name="1310"/>   # coordinates, or fails if the clip region is not so representable.
<a name="1311"/>   #
<a name="1312"/>   public get_clip_rectangles()
<a name="1313"/>      local l
<a name="1314"/>      l := get_clip_rectangles_impl() | fail
<a name="1315"/>      return List{Rectangle!(!l)}
<a name="1316"/>   end
<a name="1317"/>
<a name="1318"/>   # Succeeds if and only if the given point is inside the area that
<a name="1319"/>   # would be affected by a `stroke()` operation given the current
<a name="1320"/>   # path and stroking parameters. Surface dimensions and clipping are
<a name="1321"/>   # not taken into account.
<a name="1322"/>   #
<a name="1323"/>   public native in_stroke(x, y)
<a name="1324"/>
<a name="1325"/>   # Succeeds if and only if the given point is inside the area that
<a name="1326"/>   # would be affected by a `fill()` operation given the current path
<a name="1327"/>   # and filling parameters. Surface dimensions and clipping are not
<a name="1328"/>   # taken into account.
<a name="1329"/>   #
<a name="1330"/>   public native in_fill(x, y)
<a name="1331"/>
<a name="1332"/>   # Succeeds if and only if the given point is inside the area that
<a name="1333"/>   # would be visible through the current clip, i.e. the area that
<a name="1334"/>   # would be filled by a `paint()` operation.
<a name="1335"/>   #
<a name="1336"/>   public native in_clip(x, y)
<a name="1337"/>
<a name="1338"/>   # Temporarily redirects drawing to an intermediate surface known as
<a name="1339"/>   # a group. The redirection lasts until the group is completed by a
<a name="1340"/>   # call to `pop_group()` or `pop_group_to_source()`. These calls
<a name="1341"/>   # provide the result of any drawing to the group as a pattern,
<a name="1342"/>   # (either as an explicit object, or set as the source pattern).
<a name="1343"/>   #
<a name="1344"/>   # The `content` parameter is optional, and specifies the group's
<a name="1345"/>   # content type, as a string; possible values are "alpha", "color",
<a name="1346"/>   # and "color-alpha".  (See `Content` for symbolic constants).
<a name="1347"/>   #
<a name="1348"/>   public native push_group(content)
<a name="1349"/>
<a name="1350"/>   # Terminates the redirection begun by a call to `push_group()` and
<a name="1351"/>   # installs the resulting pattern as the source pattern in the given
<a name="1352"/>   # cairo context.
<a name="1353"/>   #
<a name="1354"/>   public native pop_group_to_source()
<a name="1355"/>
<a name="1356"/>   # Terminates the redirection begun by a call to `push_group()` and
<a name="1357"/>   # returns a new `Pattern` instance containing the results of all
<a name="1358"/>   # drawing operations performed to the group.
<a name="1359"/>   #
<a name="1360"/>   public pop_group()
<a name="1361"/>      return Pattern.create_for_ptr(pop_group_impl())
<a name="1362"/>   end
<a name="1363"/>
<a name="1364"/>   # Gets the current destination `Surface` for this `Context`. This is
<a name="1365"/>   # either the original target surface as passed to the constructor,
<a name="1366"/>   # or the target surface for the current group as started by the
<a name="1367"/>   # most recent call to `push_group()` or
<a name="1368"/>   # `push_group_with_content()`.
<a name="1369"/>   #
<a name="1370"/>   # A new `Surface` instance is returned in either case, and this
<a name="1371"/>   # must be closed by the caller.
<a name="1372"/>   #
<a name="1373"/>   public get_group_target()
<a name="1374"/>      return Surface.create_for_ptr(get_group_target_impl())
<a name="1375"/>   end
<a name="1376"/>
<a name="1377"/>   # Return the source `Pattern` used by this `Context`; note that a
<a name="1378"/>   # new wrapper is returned which must be closed separately from any
<a name="1379"/>   # other instance.
<a name="1380"/>   #
<a name="1381"/>   public get_source()
<a name="1382"/>      return Pattern.create_for_ptr(get_source_impl())
<a name="1383"/>   end
<a name="1384"/>
<a name="1385"/>   # Set the source to use.  `v` can be a `Pattern`.  If it is not,
<a name="1386"/>   # then `v` is passed to `Pattern.to_pattern()` to create a
<a name="1387"/>   # temporary pattern, which is then used as the source.
<a name="1388"/>   #
<a name="1389"/>   public set_source(v)
<a name="1390"/>      local t
<a name="1391"/>      return if is(v, Pattern) then
<a name="1392"/>         set_source_pattern(v)
<a name="1393"/>      else 
<a name="1394"/>         use {
<a name="1395"/>            t := Pattern.to_pattern(v),
<a name="1396"/>            set_source_pattern(t)
<a name="1397"/>         }
<a name="1398"/>   end
<a name="1399"/>
<a name="1400"/>   # Return the target `Surface`.  Note that this returns a new
<a name="1401"/>   # wrapper of the underlying cairo object, and must be closed
<a name="1402"/>   # separately from any other instance.
<a name="1403"/>   #
<a name="1404"/>   public get_target()
<a name="1405"/>      return Surface.create_for_ptr(get_target_impl())
<a name="1406"/>   end
<a name="1407"/>
<a name="1408"/>   # Set the source to a solid pattern with the given colour `col`,
<a name="1409"/>   # which is an icon colour string.
<a name="1410"/>   #
<a name="1411"/>   public set_fg(col)
<a name="1412"/>      local c
<a name="1413"/>      c := to_cairo_color(col) | fail
<a name="1414"/>      return set_source_rgba(c.red, c.green, c.blue, c.alpha)
<a name="1415"/>   end
<a name="1416"/>
<a name="1417"/>   # Set the transformation matrix to the identity matrix.
<a name="1418"/>   #
<a name="1419"/>   public identity_matrix()
<a name="1420"/>      return set_matrix(Matrix.I)
<a name="1421"/>   end
<a name="1422"/>
<a name="1423"/>   # Set the transformation matrix from the given `Matrix` instance.
<a name="1424"/>   #
<a name="1425"/>   public set_matrix(m)
<a name="1426"/>      return set_matrix_impl(m.xx, m.yx, m.xy, m.yy, m.x0, m.y0)
<a name="1427"/>   end
<a name="1428"/>
<a name="1429"/>   # Return the transformation matrix as a `Matrix` instance.
<a name="1430"/>   #
<a name="1431"/>   public get_matrix()
<a name="1432"/>      return Matrix!get_matrix_impl()
<a name="1433"/>   end
<a name="1434"/>
<a name="1435"/>   private native get_current_point_impl(con)
<a name="1436"/>   private native append_path_impl(l)
<a name="1437"/>   private native get_path_impl()
<a name="1438"/>   private native get_flat_path_impl()
<a name="1439"/>   private native get_stroke_extents_impl(r)
<a name="1440"/>   private native get_clip_extents_impl(r)
<a name="1441"/>   private native get_fill_extents_impl(r)
<a name="1442"/>   private native get_path_extents_impl(r)
<a name="1443"/>   private native user_to_device_impl(x, y, r)
<a name="1444"/>   private native device_to_user_impl(x, y, r)
<a name="1445"/>   private native user_to_device_distance_impl(dx, dy, r)
<a name="1446"/>   private native device_to_user_distance_impl(dx, dy, r)
<a name="1447"/>   private native get_clip_rectangles_impl()
<a name="1448"/>   private native set_source_rgba(r, g, b, a)
<a name="1449"/>   private native set_source_pattern(pat)
<a name="1450"/>   private native pop_group_impl()
<a name="1451"/>   private native get_source_impl()
<a name="1452"/>   private native get_group_target_impl()
<a name="1453"/>   private native get_target_impl()
<a name="1454"/>   private native set_matrix_impl(xx, yx, xy, yy, x0, y0)
<a name="1455"/>   private native get_matrix_impl()
<a name="1456"/>   private native text_size_impl(s, r)
<a name="1457"/>   private static native new_impl(sur)
<a name="1458"/>
<a name="1459"/>   # Create a new instance using a `Surface` based on `v`, which may
<a name="1460"/>   # be a `Window`, a `Pixels`, or an already-created `Surface`
<a name="1461"/>   # instance.
<a name="1462"/>   #
<a name="1463"/>   # In the case of a `Window` (or a `WindowSurface`) being used, the
<a name="1464"/>   # instance is initialized in a way which matches the given
<a name="1465"/>   # `Window`'s context.
<a name="1466"/>   #
<a name="1467"/>   public new(v)
<a name="1468"/>      local t
<a name="1469"/>      cairo_available() | fail
<a name="1470"/>      ptr := if is(v, Window) then
<a name="1471"/>         use {
<a name="1472"/>            t := WindowSurface(v),
<a name="1473"/>            new_impl(t)
<a name="1474"/>         }
<a name="1475"/>      else if is(v, Pixels) then
<a name="1476"/>         use {
<a name="1477"/>            t := ImageSurface(v),
<a name="1478"/>            new_impl(t)
<a name="1479"/>         }
<a name="1480"/>      else
<a name="1481"/>         new_impl(v)
<a name="1482"/>      return
<a name="1483"/>   end
<a name="1484"/>end
<a name="1485"/>
<a name="1486"/>final class SVG(NoCopy, HasClose)
<a name="1487"/>   private ptr
<a name="1488"/>
<a name="1489"/>   private static init()
<a name="1490"/>      Class.load_library(\Context.LOADED)
<a name="1491"/>   end
<a name="1492"/>
<a name="1493"/>   # Get the width of the document
<a name="1494"/>   #
<a name="1495"/>   public native get_width(id)
<a name="1496"/>
<a name="1497"/>   # Get the height of the document
<a name="1498"/>   #
<a name="1499"/>   public native get_height(id)
<a name="1500"/>
<a name="1501"/>   # Get the size, as a `Size` record.
<a name="1502"/>   #
<a name="1503"/>   public get_size(id)
<a name="1504"/>      return Size(get_width(id), get_height(id))
<a name="1505"/>   end
<a name="1506"/>
<a name="1507"/>   public native has_sub()
<a name="1508"/>   public native get_x(id)
<a name="1509"/>   public native get_y(id)
<a name="1510"/>   public native get_title()
<a name="1511"/>   public native get_desc()
<a name="1512"/>   public native get_metadata()
<a name="1513"/>
<a name="1514"/>   # Render to a cairo context.
<a name="1515"/>   #
<a name="1516"/>   public native render(context, id)
<a name="1517"/>
<a name="1518"/>   public override native close()
<a name="1519"/>
<a name="1520"/>   private static native new_impl()
<a name="1521"/>
<a name="1522"/>   public new(data)
<a name="1523"/>      cairo_available() | fail
<a name="1524"/>      ptr := new_impl(data) | fail
<a name="1525"/>      return
<a name="1526"/>   end
<a name="1527"/>end
<a name="1528"/>
<a name="1529"/># This class provides symbolic names for the drawing operations
<a name="1530"/># supported by `Context.set_operator()`.
<a name="1531"/>#
<a name="1532"/>final abstract class DrawOp()
<a name="1533"/>   public static const
<a name="1534"/>      ATOP,
<a name="1535"/>      CLEAR,
<a name="1536"/>      DEST,
<a name="1537"/>      DEST_ATOP,
<a name="1538"/>      DEST_IN,
<a name="1539"/>      DEST_OUT,
<a name="1540"/>      DEST_OVER,
<a name="1541"/>      IN,
<a name="1542"/>      OUT,
<a name="1543"/>      OVER,
<a name="1544"/>      SOURCE,
<a name="1545"/>      XOR,
<a name="1546"/>      ADD,
<a name="1547"/>      COLOR_BURN,
<a name="1548"/>      COLOR_DODGE,
<a name="1549"/>      DARKEN,
<a name="1550"/>      DIFFERENCE,
<a name="1551"/>      EXCLUSION,
<a name="1552"/>      HARD_LIGHT,
<a name="1553"/>      HSL_COLOR,
<a name="1554"/>      HSL_HUE,
<a name="1555"/>      HSL_LUMINOSITY,
<a name="1556"/>      HSL_SATURATION,
<a name="1557"/>      LIGHTEN,
<a name="1558"/>      MULTIPLY,
<a name="1559"/>      OVERLAY,
<a name="1560"/>      SATURATE,
<a name="1561"/>      SCREEN,
<a name="1562"/>      SOFT_LIGHT
<a name="1563"/>
<a name="1564"/>   private static init()
<a name="1565"/>      ATOP := "atop"
<a name="1566"/>      CLEAR := "clear"
<a name="1567"/>      DEST := "dest"
<a name="1568"/>      DEST_ATOP := "dest atop"
<a name="1569"/>      DEST_IN := "dest in"
<a name="1570"/>      DEST_OUT := "dest out"
<a name="1571"/>      DEST_OVER := "dest over"
<a name="1572"/>      IN := "in"
<a name="1573"/>      OUT := "out"
<a name="1574"/>      OVER := "over"
<a name="1575"/>      SOURCE := "source"
<a name="1576"/>      XOR := "xor"
<a name="1577"/>      ADD := "add"
<a name="1578"/>      COLOR_BURN := "color burn"
<a name="1579"/>      COLOR_DODGE := "color dodge"
<a name="1580"/>      DARKEN := "darken"
<a name="1581"/>      DIFFERENCE := "difference"
<a name="1582"/>      EXCLUSION := "exclusion"
<a name="1583"/>      HARD_LIGHT := "hard light"
<a name="1584"/>      HSL_COLOR := "hsl color"
<a name="1585"/>      HSL_HUE := "hsl hue"
<a name="1586"/>      HSL_LUMINOSITY := "hsl luminosity"
<a name="1587"/>      HSL_SATURATION := "hsl saturation"
<a name="1588"/>      LIGHTEN := "lighten"
<a name="1589"/>      MULTIPLY := "multiply"
<a name="1590"/>      OVERLAY := "overlay"
<a name="1591"/>      SATURATE := "saturate"
<a name="1592"/>      SCREEN := "screen"
<a name="1593"/>      SOFT_LIGHT := "soft light"
<a name="1594"/>   end
<a name="1595"/>end
<a name="1596"/>
<a name="1597"/># This class provides symbolic names for the line joins supported by
<a name="1598"/># `Context.set_line_join()`.
<a name="1599"/>#
<a name="1600"/>final abstract class LineJoin()
<a name="1601"/>   public static const
<a name="1602"/>      BEVEL,
<a name="1603"/>      MITER,
<a name="1604"/>      ROUND
<a name="1605"/>
<a name="1606"/>   private static init()
<a name="1607"/>      BEVEL := "bevel"
<a name="1608"/>      MITER := "miter"
<a name="1609"/>      ROUND := "round"
<a name="1610"/>   end
<a name="1611"/>end
<a name="1612"/>
<a name="1613"/># This class provides symbolic names for the line caps supported by
<a name="1614"/># `Context.set_line_cap()`.
<a name="1615"/>#
<a name="1616"/>final abstract class LineCap()
<a name="1617"/>   public static const
<a name="1618"/>      BUTT,
<a name="1619"/>      ROUND,
<a name="1620"/>      SQUARE
<a name="1621"/>
<a name="1622"/>   private static init()
<a name="1623"/>      BUTT := "butt"
<a name="1624"/>      ROUND := "round"
<a name="1625"/>      SQUARE := "square"
<a name="1626"/>   end
<a name="1627"/>end
<a name="1628"/>
<a name="1629"/># This class provides symbolic names for the fill rules supported by
<a name="1630"/># `Context.set_fill_rule()`.
<a name="1631"/>#
<a name="1632"/>final abstract class FillRule()
<a name="1633"/>   public static const
<a name="1634"/>      EVEN_ODD,
<a name="1635"/>      WINDING
<a name="1636"/>
<a name="1637"/>   private static init()
<a name="1638"/>      EVEN_ODD := "even-odd"
<a name="1639"/>      WINDING := "winding"
<a name="1640"/>   end
<a name="1641"/>end
<a name="1642"/>
<a name="1643"/># This class provides symbolic names for the settings supported by
<a name="1644"/># `Pattern.set_extend()`.
<a name="1645"/>#
<a name="1646"/>final abstract class Extend()
<a name="1647"/>   public static const
<a name="1648"/>      NONE,
<a name="1649"/>      PAD,
<a name="1650"/>      REFLECT,
<a name="1651"/>      REPEAT
<a name="1652"/>
<a name="1653"/>   private static init()
<a name="1654"/>      NONE := "none"
<a name="1655"/>      PAD := "pad"
<a name="1656"/>      REFLECT := "reflect"
<a name="1657"/>      REPEAT := "repeat"
<a name="1658"/>   end
<a name="1659"/>end
<a name="1660"/>
<a name="1661"/># This class provides symbolic names for the content settings
<a name="1662"/># supported by `Context.push_group()`.
<a name="1663"/>#
<a name="1664"/>final abstract class Content()
<a name="1665"/>   public static const
<a name="1666"/>      ALPHA,
<a name="1667"/>      COLOR,
<a name="1668"/>      COLOR_ALPHA
<a name="1669"/>
<a name="1670"/>   private static init()
<a name="1671"/>      ALPHA := "alpha"
<a name="1672"/>      COLOR := "color"
<a name="1673"/>      COLOR_ALPHA := "color-alpha"
<a name="1674"/>   end
<a name="1675"/>end
<a name="1676"/>
<a name="1677"/># This class provides symbolic names for the settings supported by
<a name="1678"/># `Context.set_antialias()`.
<a name="1679"/>#
<a name="1680"/>final abstract class Antialias()
<a name="1681"/>   public static const
<a name="1682"/>      BEST,
<a name="1683"/>      DEFAULT,
<a name="1684"/>      FAST,
<a name="1685"/>      GOOD,
<a name="1686"/>      GRAY,
<a name="1687"/>      NONE,
<a name="1688"/>      SUBPIXEL
<a name="1689"/>
<a name="1690"/>   private static init()
<a name="1691"/>      BEST := "best"
<a name="1692"/>      DEFAULT := "default"
<a name="1693"/>      FAST := "fast"
<a name="1694"/>      GOOD := "good"
<a name="1695"/>      GRAY := "gray"
<a name="1696"/>      NONE := "none"
<a name="1697"/>      SUBPIXEL := "subpixel"
<a name="1698"/>   end
<a name="1699"/>end
<a name="1700"/>
<a name="1701"/># This class provides symbolic names for the settings supported by
<a name="1702"/># `Pattern.set_filter()`.
<a name="1703"/>#
<a name="1704"/>final abstract class Filter()
<a name="1705"/>   public static const
<a name="1706"/>      BEST,
<a name="1707"/>      BILINEAR,
<a name="1708"/>      FAST,
<a name="1709"/>      GAUSSIAN,
<a name="1710"/>      GOOD,
<a name="1711"/>      NEAREST
<a name="1712"/>
<a name="1713"/>   private static init()
<a name="1714"/>      BEST := "best"
<a name="1715"/>      BILINEAR := "bilinear"
<a name="1716"/>      FAST := "fast"
<a name="1717"/>      GAUSSIAN := "gaussian"
<a name="1718"/>      GOOD := "good"
<a name="1719"/>      NEAREST := "nearest"
<a name="1720"/>   end
<a name="1721"/>end
</pre></body></html>
