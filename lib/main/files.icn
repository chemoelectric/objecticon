package io

import 
   lang,
   util,
   net,
   posix,
   ipl.random,
   ipl.scan

#
# This class has several static methods which provide
# system-independent access to the file system.
#
final abstract class Files()
   package static const 
      FS

   public static const 
      # The end-of-line sequence
      EOL,
      # The separator for elements of a path
      PATH_SEPARATOR,
      # A cset, being the non-filename characters which may appear in a path
      PATH_SPECIALS,
      # The separator for individual paths in a list of paths (such as the PATH
      # environment variable).
      PATHS_SEPARATOR,
      # Suffix for dynamic library
      LIB_SUFFIX,
      # Suffix for executable
      PROG_SUFFIX,
      # Name of null file
      NULL_FILE

   private static init()
$ifdef _UNIX
      EOL := "\n"
      PATH_SEPARATOR := "/"
      PATH_SPECIALS := '/'
      PATHS_SEPARATOR := ":"
      LIB_SUFFIX := ".so"
      PROG_SUFFIX := ""
      NULL_FILE := "/dev/null"
      FS := UnixFileSystem()
$elsifdef _MS_WIN32
      EOL := "\r\n"
      PATH_SEPARATOR := "\\"
      PATH_SPECIALS := ':\\/'
      PATHS_SEPARATOR := ";"
      LIB_SUFFIX := ".dll"
      PROG_SUFFIX := ".exe"
      NULL_FILE := "nul"
      FS := WindowsFileSystem()
$else
      runerr("Can't init_file_system: unknown o/s type")
$endif
   end

   #
   # Read the given directory returning a list of `ListEntry` objects,
   # each containing the name, lstat and stat values for each entry.
   #
   # `f` is an optional parameter, providing an alternative constructor for
   # the returned objects; by default it is `ListEntry`.
   #
   public static list(s, f)
      local p
      return use {
         p := DirStream(s),
         list1(FilePath(s), p, f, 1)
      }
   end

   #
   # Like `list`, but the filenames are converted to `ucs`; any that
   # can't be converted are skipped.
   #
   public static ucs_list(s, f)
      local p
      return use {
         p := DirStream(s),
         list1(FilePath(s), p, f, ucs)
      }
   end

   private static list1(path, p, f, g)
      local l, s, cs, lst, st
      /f := ListEntry
      l := []
      repeat {
         s := p.read_line() | fail
         if /s then
            return l
         cs := path.child(s).str()
         lst := lstat(cs) | next
         st := if lst.mode_str[1] == "l" then
            stat(cs) | next
         else
            lst
         put(l, f(g(s), lst, st))
      }
   end

   #
   # A useful function to help sort the result of the various list
   # functions.  Sorts by case-insensitive name.
   #
   public static name_cmp(d1, d2)
      return Text.consistent_compare(d1.name, d2.name)
   end

   #
   # A useful function to help sort the result of the various list
   # functions.  Sorts by size in bytes.
   #
   public static size_cmp(d1, d2)
      return d1.lstat.size - d2.lstat.size
   end

   #
   # A useful function to help sort the result of the various list
   # functions.  Sorts by modification time.
   #
   public static date_cmp(d1, d2)
      local t
      t := d1.lstat.mtime - d2.lstat.mtime
      return if t = 0 then d1.lstat.mtime_ns - d2.lstat.mtime_ns else t
   end

   #
   # Return the home directory.
   #
   public static get_home()
      return FS.get_home()
   end

   #
   # Return the temporary directory.
   #
   public static get_temp()
      return FS.get_temp()
   end

   #
   # Succeed iff the given file is hidden.
   #
   public static is_hidden(s)
      return FS.is_hidden(s)
   end

   #
   # Succeed iff the given file is a relative directory name (on Unix,
   # "." or "..").
   #
   public static is_relative_dir(s)
      return FS.is_relative_dir(s)
   end

   #
   # Get the roots of the file system.
   #
   public static get_roots()
      suspend FS.get_roots()
   end

   #
   # Split a list of paths (such as the $PATH variable) into its
   # constituent elements.
   #
   public static split_paths(s)
      suspend FS.split_paths(s)
   end

   #
   # Load a file into a string
   #
   public static file_to_string(fn)
      local f
      return use {
         f := FileStream(fn),
         f.read_all()
      }
   end

   #
   # Write a string to a file.
   #
   public static string_to_file(fn, s)
      local f
      return use {
         f := FileStream(fn, ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT)),
         f.writes1(s)
      }
   end

   #
   # Make a temporary filename.
   # @param prefix, by default empty
   # @param suffix, by default empty
   # @param path, the directory, by default {get_temp()}
   # @param len, the number of digits in the result, default 8
   #
   public static make_temp_filename(prefix, suffix, path, len)
      local p, name
      /prefix := ""
      /suffix := ""
      /path := get_temp()
      /len := 8
      randomize()
      p := FilePath(path)
      repeat {
         ?1                                # change &random
         name := p.child(prefix || left(&random, len, "0") || suffix).str()
         if not access(name) then {
            # Touch the filename to stop anyone else using it.
            use{ FileStream(name, ior(FileOpt.WRONLY, FileOpt.CREAT)) } | fail
            return name
         }
      }
   end

   #
   # Succeed iff the two given files have the same content.
   #
   public static equal_files(s1, s2)
      local f1, f2
      stat(s1).size = stat(s2).size | fail
      return use {
         f1 := FileStream(s1),
         use {
            f2 := FileStream(s2),
            equal_files1(f1, f2)
         }
      }
   end

   private static equal_files1(f1, f2)
      local b1, b2
      repeat {
         b1 := f1.in(1048576) | fail
         if /b1 then 
            break
         b2 := f2.read_exactly(*b1) | fail
         b1 === b2 | fail
      }
      # f1 is at eof, and a further read of f2 should be at eof.
      return /f2.in(1)
   end

   #
   # Succeed iff the given file is a directory.
   #
   public static is_directory(s)
      return stat(s).mode_str[1] == "d"
   end

   #
   # Move a file.  First, try to move it by renaming it.  If that
   # fails, try to copy the file then delete the original, or if that
   # fails, fail.
   #
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static move(s1, s2)
      if rename(s1, s2) then
         return
      copy(s1, s2) | fail
      return remove(s1)
   end

   #
   # Rename a file.
   #
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static native rename(s1, s2)

   #
   # Create a (hard) link to a file.
   #
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static native hardlink(s1, s2)

   #
   # Create a symlink to a file.
   #
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static native symlink(s1, s2)

   #
   # Read a symbolic link
   #
   # @param s the source filename
   #
   public static native readlink(s)

   #
   # Return the canonicalized absolute pathname as produced by the
   # POSIX realpath function.
   #
   # @param s a filename
   #
   public static native realpath(s)

   #
   # Changes the current directory to that specified in s.
   #
   # @param s the directory
   #
   public static native chdir(s)

   #
   # Get current working directory
   #
   public static native getcwd()

   #
   # Remove a regular file
   #
   # @param s the file
   #
   public static native remove(s)

   #
   # Remove an empty directory
   #
   # @param s the empty directory
   #
   public static native rmdir(s)

   #
   # Make a new directory
   #
   # @param s the directory path
   # @param perm the permission bits, defaults to rwxr-xr-x
   #
   public static native mkdir(s, perm)

   #
   # Truncate the given file to {len} bytes.
   #
   # @param s1 the source filename
   # @param len the desired length
   #
   public static native truncate(s, len)

   #
   # Obtain information about the given file
   #
   # @param s the file
   # @return a {Stat} object
   #
   public static stat(s)
      return Stat!stat_impl(s)
   end

   private static native stat_impl(s)

   #
   # Obtain information about the given file without following
   # symlinks.
   #
   # @param s the file
   # @return a {Stat} object
   #
   public static lstat(s)
      return Stat!lstat_impl(s)
   end

   private static native lstat_impl(s)

   #
   # Write selected attributes about a file.  If any of the parameters
   # are {&null}, they are left unchanged.
   #
   # @param s the file
   # @param mode the mode (an integer)
   # @param uid the owner id
   # @param gid the group id
   # @param atime the access time (an integer)
   # @param mtime the modification time (an integer)
   #
   public static native wstat(s, mode, uid, gid, atime, mtime)

   #
   # Check whether the given file can be accessed in the given mode.
   #
   public static native access(s, mode)

   #
   # Copy a file.
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static copy(s1, s2)
      local f1, f2
      return use {
         f1 := FileStream(s1),
         use {
            f2 := FileStream(s2, ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT)),
            f1.copy_to(f2)
         }
      }
   end

   #
   # Append file {s1} onto {s2}.
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static append(s1, s2)
      local f1, f2
      return use {
         f1 := FileStream(s1),
         use {
            f2 := FileStream(s2, ior(FileOpt.WRONLY, FileOpt.APPEND, FileOpt.CREAT)),
            f1.copy_to(f2)
         }
      }
   end

   #
   # Given a stem filename, return another unique filename based upon it.
   #
   public static ensure_unique_filename(stem)
      local i, p, s
      access(stem) | return stem
      i := 1
      p := backto('.', stem) - 1
      repeat {
         s := stem
         if /p then
            s ||:= "_" || i
         else
            s[p] := "_" || i || s[p]
         access(s) | return s
         i +:= 1
      }
   end

   #
   # Return the extension of a filename, or fail if there is none.
   #
   public static get_extension(f)
      local i                                                     
      if i := backto('.', f) then
         return "" ~== f[i:0]
   end

   #
   # This procedure searches for a file on a environment-defined path.
   # It follows the same logic as the C function pathfind() in
   # mlocal.c
   #
   # @param f the file to look for
   # @param n the name of the environment variable holding the path
   # @param cd the current directory; if &null then the "real" cd
   # @param mode the access mode to check for; by default {Access.F_OK}
   #
   public static path_find(f, n, cd, mode)
      local p, s
      /mode := Access.F_OK
      p := FilePath(f)

      # Don't search the path if we have an absolute file
      if p.is_absolute() then {
         s := p.str()
         if access(s, mode) then
            return s
         else
            fail
      }

      # Also don't search if we have a relative name; it is relative to
      # the cd
      if p.size() > 1 then {
         # Prepend cd if given
         s := FilePath(\cd).append(p).str() | p.str()
         if access(s, mode) then
            return s
         else
            fail
      }

      # Neither absolute nor relative.  Try current directory first
      s := FilePath(\cd).append(p).str() | p.str()
      if access(s, mode) then
         return s

      # Search all the elements in the path
      every s := FilePath(split_paths(System.getenv(\n))).append(p).str() do {
         if access(s, mode) then
            return s
      }
   end

   # Find absolute executable, searching $PATH (using POSIX 1003.2
   # rules) for executable name.  The method is similar to path_find above,
   # but a little more strict.  In particular, the cd isn't tried before
   # the directories on $PATH.
   #
   # @param n the name of the environment variable holding the path,
   # @        by default "PATH"
   # @param mode the access mode to check for; by default {Access.X_OK}
   public static find_exe(f, n, mode)
      local p, s, path

      /n := "PATH"
      /mode := Access.X_OK
      p := FilePath(f)

      # Anything with separators in, we just look up and ignore the
      # path.
      if p.is_absolute() | (p.size() > 1) then {
         s := p.str()
         if access(s, mode) then
            return s
         else
            fail
      }

      # Search all the elements in the path
      path := System.getenv(n) | ""
      every s := FilePath(split_paths(path)).append(p).str() do {
         if access(s, mode) then
            return s
      }
   end

   #
   # Search for a native library on the OI_NATIVE path.
   #
   public static find_native_lib(f)
      static seen
      local t
      initial
         seen := table()
      if t := member(seen, f) then
         return t
      if t := find_exe(f || LIB_SUFFIX, "OI_NATIVE") then {
         insert(seen, f, t)
         return t
      }
   end

   #
   # Succeed if the given `FileStream` represents a tty supporting links.
   #
   public static is_flowterm_tty(f)
      static flowterm
      initial
         flowterm := integer(System.getenv("FLOWTERM"))
      return case flowterm of {
         1 : f.isatty()
         2 : &null
      }
   end

   #
   # Return the opening escape sequence for an embedded link.  File f
   # must be a `URL` (properly url-encoded), or an absolute path.
   #
   public static begin_link(f, line)
      local s
      if is(f, URL) then
         return "\e[!\"" || f.str() || "\"L"
      s := "\e[!\"file://" || &host || URL.percent_encode(f, URL.UNRESERVED ++ '/')
      if \line then
         s ||:= "?line=" || line
      return s || "\"L"
   end

   #
   # Return the closing escape sequence for an embedded link
   #
   public static end_link()
      return "\e[!L"
   end

   #
   # Return the application name, based on the last path element of `&progname`
   #
   public static get_application_name()
      return FilePath(&progname).get(-1)
   end
end

#
# This class provides implementations of some of the methods in
# {Files} and {FilePath}.  It is not used directly by clients.
#
abstract class FileSystem()
   public abstract get_path_list(s)
   public abstract filepath_str(fp)
   public abstract filepath_is_absolute(fp)
   public abstract filepath_tidy(fp)
   public abstract filepath_absolute(fp)
   public abstract get_home()
   public abstract get_temp()
   public abstract is_hidden(s)
   public abstract is_relative_dir(s)
   public abstract get_roots()
   public abstract split_paths(s)

   package new()
      return
   end
end

#
# This class holds a result from the `Files.list` method.
#
class ListEntry()
   public const
      name,
      lstat,
      stat

   public new(name, lstat, stat)
      self.name := name
      self.lstat := lstat
      self.stat := stat
      return
   end
end

#
# This class manipulates file paths by treating them as a list of
# elements.
#
# Instances of this class are immutable.
#
class FilePath(ObjectOutput)
   package l

   #
   # Return the number of elements in the path.
   #
   public size()
      return *l
   end

   #
   # Return the {i}th element in the path.
   #
   public get(i)
      return .l[i]
   end

   #
   # Generate the elements in the path.
   #
   public gen()
      suspend .!l
   end

   #
   # Generate the elements in the path in reverse order
   #
   public back()
      suspend .default.back(l)
   end

   #
   # Return a new path consisting of elements i:j of the current path
   #
   public slice(i, j)
      /i := 1
      /j := 0
      return from_list(l[i:j])
   end

   #
   # Returns the path formed by appending the elements of this path to
   # the elements of `other`.  `other` must be a list or another
   #`FilePath`.
   #
   public append(other)
      return if is(other, FilePath) then
         from_list(l ||| other.l)
      else
         from_list(l ||| other)
   end

   #
   # Takes a variable arguments list, and returns the path formed by
   # appending the elements of this path to that list.
   #
   public walk(a[])
      return from_list(l ||| a)
   end

   #
   # Return the parent path, ie a path with everything but the last
   # element.  Fails if the path has no elements.
   #
   public parent()
      return from_list(l[1:-1])
   end

   private object_output(oo)
      oo.object_string(self, str())
   end

   #
   # Return the child path, ie a path with the same elements plus the
   # element {s}.
   #
   public child(s)
      return from_list(l ||| [s])
   end

   #
   # Return the sibling path, ie a path with the same elements, except the
   # last one, which is replaced by {s}.  Fails if the path has no elements.
   #
   public sibling(s)
      local t
      t := copy(l)
      t[-1] := s | fail
      return from_list(t)
   end

   #
   # Return a path which represents the absolute path of this
   # path.
   #
   public absolute()
      return if is_absolute() then
         self
      else
         Files.FS.filepath_absolute(self)
   end

   #
   # Convert the path back into a string.  The result is always a string, never ucs.
   #
   public str()
      return Files.FS.filepath_str(self)
   end

   #
   # Convenient method to give ucs(str()); may fail if str() is not convertible.
   #
   public ucs()
      return default.ucs(str())
   end

   #
   # Convenient method to give Text.liberal_ucs(str()); will never fail.
   #
   public liberal_ucs()
      return Text.liberal_ucs(str())
   end

   #
   # Succeed iff this path represents an absolute path.
   #
   public is_absolute()
      return Files.FS.filepath_is_absolute(self)
   end

   #
   # Canonicalize a path, which means trying to turn it into a
   # standard form.  This involves (at least) getting the absolute
   # path and removing any redundant path elements.
   #
   public canonical()
      return Files.FS.filepath_tidy(absolute())
   end

   #
   # Return another {FilePath} with the same elements, but as ucs
   # strings.  Fails if any part cannot be converted to ucs.
   #
   public ucs_path()
      local s, t
      t := []
      every s := !l do
         put(t, default.ucs(s)) | fail
      return from_list(t)
   end

   #
   # Create a new {FilePath} from the given list of path elements.
   #
   public static from_list(l)
      local i
      i := Class.create_instance()
      i.l := l
      return i
   end

   #
   # Create a new instance from the path represented by the given string.
   #
   public new(s)
      self.l := Files.FS.get_path_list(s) | fail
      return
   end
end

#
# This class represents file stat information.
#
class Stat()
   public const 
      dev,
      ino,
      mode,
      mode_str,
      nlink,
      uid,
      gid,
      rdev,
      size,
      blksize,
      blocks,
      atime,
      mtime,
      ctime,
      atime_ns,
      mtime_ns,
      ctime_ns

   package new(dev,
               ino,
               mode,
               mode_str,
               nlink,
               uid,
               gid,
               rdev,
               size,
               blksize,
               blocks,
               atime,
               mtime,
               ctime,
               atime_ns,
               mtime_ns,
               ctime_ns)
      self.dev := dev
      self.ino := ino
      self.mode := mode
      self.mode_str := mode_str
      self.nlink := nlink
      self.uid := uid
      self.gid := gid
      self.rdev := rdev
      self.size := size
      self.blksize := blksize
      self.blocks := blocks
      self.atime := atime
      self.mtime := mtime
      self.ctime := ctime
      self.atime_ns := atime_ns
      self.mtime_ns := mtime_ns
      self.ctime_ns := ctime_ns
      return
   end
end

class UnixFileSystem(FileSystem)
   public get_path_list(s)
      local l, t
      l := []
      s ? {
         put(l, =u"/")
         until pos(0) do {
            t := tab(upto('/') | 0)
            if *t > 0 then
               put(l, t)
            move(1)
         }
      }
      return l
   end

   public filepath_str(fp)
      local e, s
      s := ""
      every e := !fp.l do {
         if s[-1] ~== "/" then 
            s ||:= "/"
         s ||:= string(e)
      }
      return s
   end

   public filepath_is_absolute(fp)
      return fp.l[1] == "/"
   end

   public filepath_tidy(fp)
      local e, r
      r := []
      every e := !fp.l do {
         if e == "." then
            next
         else if e == ".." then {
            # /.. -> /
            if *r > 1 then
               pull(r)
         } else
            put(r, e)
      }
      return FilePath.from_list(r)
   end

   public filepath_absolute(fp)
      return FilePath(Files.getcwd()).append(fp)
   end

   public get_home()
      return System.getenv("HOME")
   end

   public get_temp()
      return System.getenv("TEMP") | "/tmp"
   end

   public is_hidden(s)
      return any('.', s)
   end

   public is_relative_dir(s)
      return s == ("." | "..")
   end

   public get_roots()
      return "/"
   end

   public split_paths(s)
      local t
      s ? repeat {
         t := tab(upto(':') | 0)
         if *t = 0 then
            t := "."
         suspend t
         move(1) | break
      }
   end
end

class WindowsFileSystem(FileSystem)
   public get_path_list(s)
      local l, t
      l := []
      s := map(s, "/", "\\")
      s ? {
         if &subject[2:4] == ":\\" then       # X:\
            put(l, move(3))
         else if &subject[2] == ":" then      # X:
            put(l, move(2))
         else if &subject[1:3] == "\\\\" then # \\X
            put(l, move(2))
         else if &subject[1] == "\\" then     # \X
            put(l, move(1))                
         until pos(0) do {
            t := tab(upto('\\') | 0)
            if *t > 0 then
               put(l, t)
            move(1)
         }
      }
      return l
   end

   public filepath_str(fp)
      local e, s
      s := ""
      every e := !fp.l do {
         if *s > 0 & not any("\\:", s[-1]) then
            s ||:= "\\"
         s ||:= string(e)
      }
      return s
   end

   public filepath_is_absolute(fp)
      return fp.l[1] == "\\\\" | fp.l[1][2:0] == ":\\"
   end

   public filepath_tidy(fp)
      local e, r
      r := []
      every e := !fp.l do {
         if e == "." then
            next
         else if e == ".." then {
            # Avoid, eg, c:\.. -> empty; c:\.. is in fact invalid.
            if *r > 1 then
               pull(r)
         } else
            put(r, map(e))
      }
      return FilePath.from_list(r)
   end

   public filepath_absolute(fp)
      local s
      if fp.l[1] == "\\" then
         return FilePath.from_list([Files.getcwd()[1:4]] ||| fp.l[2:0])
      if fp.l[1][2:0] == ":" then {
         s := getdcwd(fp.l[1][1]) | fp.l[1] || "\\"
         return FilePath(s).append(FilePath.from_list(fp.l[2:0]))
      }
      return FilePath(Files.getcwd()).append(fp)
   end

   private static native getdcwd(d)

   public get_home()
      return System.getenv("USERPROFILE") | get_temp()
   end

   public get_temp()
      # Conform with what the Windows function GetTempPath() does.
      return System.getenv("TMP" | "TEMP" | "USERPROFILE") | "C:\\WINDOWS\\TEMP"
   end

   public is_hidden(s)
   end

   public is_relative_dir(s)
      return s == ("." | "..")
   end

   public native get_roots()

   public split_paths(s)
      local t
      s ? repeat {
         t := tab(upto(';') | 0)
         if *t = 0 then
            t := "."
         suspend t
         move(1) | break
      }
   end
end
