<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>lineeditor.icn</title></head><body><pre>
<a name="1"/>package io
<a name="2"/>
<a name="3"/>import undo, util, lang, net, ipl.strings, ipl.io(get_null, run_prog2), gui(Conversion)
<a name="4"/>
<a name="5"/>package record Save(text, undo)
<a name="6"/>
<a name="7"/>class LineEditorStream(LineBasedInputStream, HasTask)
<a name="8"/>   package
<a name="9"/>      subj,
<a name="10"/>      pos
<a name="11"/>   private
<a name="12"/>      complete_function,
<a name="13"/>      history_limit,
<a name="14"/>      history,
<a name="15"/>      history_start_no,
<a name="16"/>      hpos,
<a name="17"/>      hmod,
<a name="18"/>      prompt,
<a name="19"/>      undo_manager,
<a name="20"/>      line_no,
<a name="21"/>      nlines,
<a name="22"/>      ctrl_d_flag,
<a name="23"/>      tty,
<a name="24"/>      isatty,
<a name="25"/>      dim,
<a name="26"/>      ti,
<a name="27"/>      buff_flag,
<a name="28"/>      buff
<a name="29"/>
<a name="30"/>   # Set the limit in lines for the command history.
<a name="31"/>   #
<a name="32"/>   public set_history_limit(n)
<a name="33"/>      self.history_limit := /n | need_integer(n, 0)
<a name="34"/>      limit_history()
<a name="35"/>      link
<a name="36"/>   end
<a name="37"/>
<a name="38"/>   # Set the history list.
<a name="39"/>   #
<a name="40"/>   public set_history(l)
<a name="41"/>      self.history := l
<a name="42"/>      self.history_start_no := 1
<a name="43"/>      limit_history()
<a name="44"/>      link
<a name="45"/>   end
<a name="46"/>
<a name="47"/>   # Set a function to generate completions when the tab key is
<a name="48"/>   # pressed.  The function is given subject and cursor position, and
<a name="49"/>   # should return a list of `gui.CompleteElement` instances.
<a name="50"/>   #
<a name="51"/>   public set_complete_function(f)
<a name="52"/>      self.complete_function := f
<a name="53"/>      link
<a name="54"/>   end
<a name="55"/>
<a name="56"/>   # Set the prompt to display.
<a name="57"/>   #
<a name="58"/>   public set_prompt(s)
<a name="59"/>      self.prompt := need_ucs(s)
<a name="60"/>      link
<a name="61"/>   end
<a name="62"/>
<a name="63"/>   # Return the history list.
<a name="64"/>   #
<a name="65"/>   public get_history()
<a name="66"/>      return .history
<a name="67"/>   end
<a name="68"/>
<a name="69"/>   # Return the given history number line.
<a name="70"/>   #
<a name="71"/>   public get_history_item(n)
<a name="72"/>      return .history[0 &lt; n - history_start_no + 1]
<a name="73"/>   end
<a name="74"/>
<a name="75"/>   # Get the history number of the first entry in the history.
<a name="76"/>   #
<a name="77"/>   public get_history_start_no()
<a name="78"/>      return .history_start_no
<a name="79"/>   end
<a name="80"/>
<a name="81"/>   public override get_mode()
<a name="82"/>      return READ
<a name="83"/>   end
<a name="84"/>
<a name="85"/>   private goto_hist(n)
<a name="86"/>      local d
<a name="87"/>      (1 &lt;= n &lt;= *history + 1) | fail
<a name="88"/>      if undo_manager.get_last() then
<a name="89"/>         insert(hmod, hpos, Save(subj, undo_manager))
<a name="90"/>      hpos := n
<a name="91"/>      if d := member(hmod, hpos) then {
<a name="92"/>         subj := d.text
<a name="93"/>         undo_manager := d.undo
<a name="94"/>      } else {
<a name="95"/>         subj := history[hpos] | u""
<a name="96"/>         undo_manager := UndoManager()
<a name="97"/>      }
<a name="98"/>      pos := *subj + 1
<a name="99"/>   end
<a name="100"/>
<a name="101"/>   private get_mod_hist(n)
<a name="102"/>      return member(hmod, n).text | history[n]
<a name="103"/>   end
<a name="104"/>
<a name="105"/>   private move_hist(n)
<a name="106"/>      goto_hist(hpos + n)
<a name="107"/>   end
<a name="108"/>
<a name="109"/>   private hist_search(dir)
<a name="110"/>      local i, s, c
<a name="111"/>      c := pos
<a name="112"/>      s := subj[1:c]
<a name="113"/>      every i := if dir &gt; 0 then (hpos + 1 to *history) | (1 to hpos - 1)
<a name="114"/>                            else (hpos - 1 to 1 by -1) | (*history to hpos + 1 by -1) do {
<a name="115"/>         if match(s, subj ~== get_mod_hist(i)) then {
<a name="116"/>            goto_hist(i)
<a name="117"/>            pos := c
<a name="118"/>            return
<a name="119"/>         }
<a name="120"/>      }
<a name="121"/>   end
<a name="122"/>
<a name="123"/>   private static dbg(a[])
<a name="124"/>      static f
<a name="125"/>      initial
<a name="126"/>         f := FileStream("/tmp/lineeditor_dbg.txt", ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT))
<a name="127"/>      (\f).write!a
<a name="128"/>      return
<a name="129"/>   end
<a name="130"/>
<a name="131"/>   public static get_console_size()
<a name="132"/>$if _UNIX
<a name="133"/>      local w, h
<a name="134"/>      # Could also use tput cols and tput lines to do this.
<a name="135"/>      return run_stty("size") ? {
<a name="136"/>         if h := integer(tab(many(&amp;digits))) &amp;
<a name="137"/>            tab(upto(&amp;digits)) &amp;
<a name="138"/>            w := integer(tab(many(&amp;digits))) then [w, h]
<a name="139"/>         else error("Couldn't interpret stty size output")
<a name="140"/>      }
<a name="141"/>$else
<a name="142"/>      error("Function not supported")
<a name="143"/>$endif
<a name="144"/>   end
<a name="145"/>
<a name="146"/>   public static get_console_width()
<a name="147"/>      return get_console_size()[1]
<a name="148"/>   end
<a name="149"/>
<a name="150"/>   private static run_stty(params[])
<a name="151"/>      local f, s
<a name="152"/>      if s := use {                         
<a name="153"/>         f := ProgInputStream("stty", params,,, get_null()),
<a name="154"/>         f.read_all()
<a name="155"/>      } &amp; f.succeeded() then
<a name="156"/>         return s
<a name="157"/>   end                                                      
<a name="158"/>
<a name="159"/>   private static read_terminfo_escape()
<a name="160"/>      local ch, v
<a name="161"/>      return case move(1) of {
<a name="162"/>         # ^? is a special case meaning DEL(127) - see terminfo(5)
<a name="163"/>         "^":  if ="?" then "\d" else char(iand(ord(move(1)), 8r37))
<a name="164"/>         "\\": {
<a name="165"/>            if any('0-7') &amp; (v := char(iand(0 &lt;= Format.string_to_int(move(3), 8), 8r377))) then
<a name="166"/>               v
<a name="167"/>            else case ch := move(1) of {
<a name="168"/>               "0": "\200"
<a name="169"/>               "E": "\e"
<a name="170"/>               "e": "\e"
<a name="171"/>               "n": "\n"
<a name="172"/>               "l": "\l"
<a name="173"/>               "r": "\r"
<a name="174"/>               "t": "\t"
<a name="175"/>               "b": "\b"
<a name="176"/>               "f": "\f"
<a name="177"/>               "s": " "
<a name="178"/>               default: ch
<a name="179"/>            }
<a name="180"/>         }
<a name="181"/>      }
<a name="182"/>   end
<a name="183"/>
<a name="184"/>   private static parse_terminfo(f)
<a name="185"/>      local desc, t, s, k, v
<a name="186"/>      t := table()
<a name="187"/>      every s := separate_lines(f) do {
<a name="188"/>         s ? {
<a name="189"/>            if any('#') then 
<a name="190"/>               next
<a name="191"/>            if /desc then {
<a name="192"/>               desc := s
<a name="193"/>               next
<a name="194"/>            }
<a name="195"/>            repeat {
<a name="196"/>               tab(many(' \t'))
<a name="197"/>               k := tab(upto(',=#')) | break
<a name="198"/>               if any(',') then
<a name="199"/>                  v := &amp;yes
<a name="200"/>               else if ="#" then
<a name="201"/>                  v := integer(tab(many(&amp;digits)))
<a name="202"/>               else {
<a name="203"/>                  move(1)
<a name="204"/>                  v := ""
<a name="205"/>                  repeat {
<a name="206"/>                     v ||:= tab(upto('\\^,')) | break
<a name="207"/>                     if any(',') then
<a name="208"/>                        break
<a name="209"/>                     v ||:= read_terminfo_escape()
<a name="210"/>                  }
<a name="211"/>               }
<a name="212"/>               =","
<a name="213"/>               insert(t, k, v)
<a name="214"/>            }
<a name="215"/>         }
<a name="216"/>      }
<a name="217"/>      return t
<a name="218"/>   end
<a name="219"/>
<a name="220"/>   public static read_terminfo(name)
<a name="221"/>      local params
<a name="222"/>      params := ["-L"]
<a name="223"/>      put(params, \name)
<a name="224"/>      return parse_terminfo(run_prog2("infocmp", params))
<a name="225"/>   end
<a name="226"/>
<a name="227"/>   protected override read_line_impl()
<a name="228"/>      local s
<a name="229"/>      if /isatty then {
<a name="230"/>         FileStream.stdout.writes1(prompt)
<a name="231"/>         s := tty.read_line() | fail
<a name="232"/>         if /s then
<a name="233"/>            return
<a name="234"/>         subj := Text.liberal_ucs(s)
<a name="235"/>         return got()
<a name="236"/>      }
<a name="237"/>      if \ctrl_d_flag then
<a name="238"/>         return
<a name="239"/>      return use {
<a name="240"/>         run_stty("-icanon",  "-echo"),
<a name="241"/>         use {
<a name="242"/>            # Enter/exit keyboard-transmit mode, see 
<a name="243"/>            # http://www.mpimf-heidelberg.mpg.de/~rohm/computing/mpimf/notes/terminal.html
<a name="244"/>            opt_write("keypad_xmit"),
<a name="245"/>            read_line_impl2(),
<a name="246"/>            opt_write("keypad_local")
<a name="247"/>         },
<a name="248"/>         run_stty("icanon",  "echo")
<a name="249"/>      }
<a name="250"/>   end
<a name="251"/>
<a name="252"/>   private opt_write(key, def)
<a name="253"/>      local s
<a name="254"/>      if s := \ti[key] | \def then
<a name="255"/>         return tty.writes1(s)
<a name="256"/>      else
<a name="257"/>         return
<a name="258"/>   end
<a name="259"/>
<a name="260"/>   private read1()
<a name="261"/>      local ch
<a name="262"/>      if /buff_flag &amp; (ch := buff[1]) then {
<a name="263"/>         buff := buff[2:0]
<a name="264"/>         return ch
<a name="265"/>      }
<a name="266"/>      choose_poll([tty, Poll.IN]) | fail
<a name="267"/>      ch := tty.in(1) | fail
<a name="268"/>      return \ch | error("Unexpected eof on tty")
<a name="269"/>   end
<a name="270"/>
<a name="271"/>   private limit_history()
<a name="272"/>      while *history &gt; \history_limit do {
<a name="273"/>         pop(history)
<a name="274"/>         history_start_no +:= 1
<a name="275"/>      }
<a name="276"/>   end
<a name="277"/>
<a name="278"/>   private got()
<a name="279"/>      if *subj &gt; 0 then {
<a name="280"/>         put(history, subj)
<a name="281"/>         limit_history()
<a name="282"/>      }
<a name="283"/>      return string(subj)
<a name="284"/>   end
<a name="285"/>
<a name="286"/>   private reset_term()
<a name="287"/>      subj := u""
<a name="288"/>      pos := 1
<a name="289"/>      hpos := *history + 1
<a name="290"/>      clear(hmod)
<a name="291"/>      undo_manager.clear()
<a name="292"/>   end
<a name="293"/>
<a name="294"/>   public insert_string(s)
<a name="295"/>      local ed
<a name="296"/>      s := need_text(s)
<a name="297"/>      if *s &gt; 0 then {
<a name="298"/>         ed := LineEditorInsertEdit(self, s)
<a name="299"/>         ed.doit()
<a name="300"/>         undo_manager.add_edit(ed)
<a name="301"/>      }
<a name="302"/>      link
<a name="303"/>   end
<a name="304"/>
<a name="305"/>   public assign_contents(x, pos, coalesce)
<a name="306"/>      local ed
<a name="307"/>      x := need_text(\x) | ""
<a name="308"/>      pos := need_integer(\pos, 1, *x + 1) | *x + 1
<a name="309"/>      need_flag(coalesce)
<a name="310"/>      if subj == x then {
<a name="311"/>         self.pos := pos
<a name="312"/>      } else {
<a name="313"/>         ed := LineEditorAssignEdit(self, x, pos, coalesce)
<a name="314"/>         ed.doit()
<a name="315"/>         undo_manager.add_edit(ed)
<a name="316"/>      }
<a name="317"/>      link
<a name="318"/>   end
<a name="319"/>
<a name="320"/>   public get_insertion(l)
<a name="321"/>      local e, t, s
<a name="322"/>      t := []
<a name="323"/>      every e := !l do {
<a name="324"/>         (subj[1:pos] == e.str[1:pos] &amp;
<a name="325"/>          subj[pos:0] == e.str[e.pos:0]) | fail
<a name="326"/>         put(t, e.str[pos:e.pos])
<a name="327"/>      }
<a name="328"/>      if s := ("" ~== coprefix(t)) then
<a name="329"/>         return Conversion(subj[1:pos] || s || subj[pos:0], pos + *s)
<a name="330"/>   end
<a name="331"/>
<a name="332"/>   private do_complete()
<a name="333"/>      local l, e, fl, cmd, v
<a name="334"/>      tty.is_flowterm_tty() | fail
<a name="335"/>      l := (\complete_function)(subj, pos) | fail
<a name="336"/>      if *l = 1 then
<a name="337"/>         assign_contents(l[1].str, l[1].pos)
<a name="338"/>      else if *l &gt; 0 then {
<a name="339"/>         if v := get_insertion(l) then {
<a name="340"/>            assign_contents(v.str, v.pos)
<a name="341"/>            if \line_no then 
<a name="342"/>               show()
<a name="343"/>         }
<a name="344"/>         tty.writes1("\e[!")
<a name="345"/>         every e := !l do {
<a name="346"/>            if \fl then
<a name="347"/>               tty.writes1(";")
<a name="348"/>            cmd := "\e[\"" || URL.percent_encode(e.str) || "\";\"" || e.pos || "\"Q"
<a name="349"/>            tty.writes("\"", 
<a name="350"/>                       URL.percent_encode(e.label), "\";\"", 
<a name="351"/>                       URL.percent_encode(cmd), "\"")
<a name="352"/>            fl := &amp;yes
<a name="353"/>         }
<a name="354"/>         tty.writes1("P")
<a name="355"/>      }
<a name="356"/>   end
<a name="357"/>
<a name="358"/>   private read_line_impl2()
<a name="359"/>      local ch, uch, p, n, ed, un, cmd, s
<a name="360"/>      reset_term()
<a name="361"/>      buff_flag := line_no := nlines := &amp;null
<a name="362"/>      dim := get_console_size() | fail
<a name="363"/>      # Request line_no
<a name="364"/>      tty.writes1("\e[6n")
<a name="365"/>      repeat {
<a name="366"/>         if \line_no then 
<a name="367"/>            show()
<a name="368"/>         ch := read1() | fail
<a name="369"/>         # Read a utf8 sequence into ch.  On gibberish, just go round and try again.
<a name="370"/>         un := Text.get_utf8_seq_len(ch) | next
<a name="371"/>         every 2 to un do
<a name="372"/>            ch ||:= read1() | fail
<a name="373"/>         uch := ucs(ch) | next
<a name="374"/>
<a name="375"/>         if ch == "\e" then {
<a name="376"/>            cmd := .ch || (ch := read1()) | fail
<a name="377"/>            p := []
<a name="378"/>            if ch == "O" then
<a name="379"/>               cmd ||:= read1() | fail
<a name="380"/>            else if ch == "[" then {
<a name="381"/>               repeat {
<a name="382"/>                  cmd ||:= (ch := read1()) | fail
<a name="383"/>                  if any('"', ch) then {
<a name="384"/>                     s := ""
<a name="385"/>                     repeat {
<a name="386"/>                        cmd ||:= (ch := read1()) | fail 
<a name="387"/>                        if any('"', ch) then
<a name="388"/>                           break
<a name="389"/>                        s ||:= ch
<a name="390"/>                     }
<a name="391"/>                     cmd ||:= (ch := read1()) | fail 
<a name="392"/>                     put(p, URL.percent_decode(s))
<a name="393"/>                  } else {
<a name="394"/>                     n := integer(ch) | break
<a name="395"/>                     repeat {
<a name="396"/>                        cmd ||:= (ch := read1()) | fail
<a name="397"/>                        n := 10 * n + integer(ch) | break
<a name="398"/>                     }
<a name="399"/>                     put(p, n)
<a name="400"/>                  }
<a name="401"/>                  ch == ";" | break
<a name="402"/>               }
<a name="403"/>            }
<a name="404"/>            # Line no request response
<a name="405"/>            if cmd[2] == "[" &amp; cmd[-1] == "R" then {
<a name="406"/>               line_no := p[1]
<a name="407"/>               if \buff_flag then
<a name="408"/>                  return got()
<a name="409"/>            } else if \buff_flag then
<a name="410"/>               buff ||:= cmd
<a name="411"/>            else if cmd[2] == "[" &amp; cmd[-1] == "Q" then
<a name="412"/>               assign_contents(ucs(p[1]), integer(p[2]))
<a name="413"/>            else case cmd of {
<a name="414"/>               ti["key_up"]: move_hist(-1)
<a name="415"/>               ti["key_down"]: move_hist(1)
<a name="416"/>               ti["key_right"]: pos := (*subj + 1 &gt;= pos + 1)
<a name="417"/>               ti["key_left"]: pos := (1 &lt;= pos - 1)
<a name="418"/>               ti["key_home"]: pos := 1
<a name="419"/>               ti["key_end"]: pos := *subj + 1
<a name="420"/>               ti["key_dc"]: {
<a name="421"/>                  if pos &lt;= *subj then {
<a name="422"/>                     ed := LineEditorDeleteRightEdit(self)
<a name="423"/>                     ed.doit()
<a name="424"/>                     undo_manager.add_edit(ed)
<a name="425"/>                  }
<a name="426"/>               }
<a name="427"/>            }
<a name="428"/>         } else if \buff_flag then
<a name="429"/>            buff ||:= ch
<a name="430"/>         else case ch of {
<a name="431"/>            "\^_": {
<a name="432"/>               if undo_manager.can_undo() then
<a name="433"/>                  undo_manager.undo()
<a name="434"/>            }
<a name="435"/>            "\^y": {
<a name="436"/>               if undo_manager.can_redo() then
<a name="437"/>                  undo_manager.redo()
<a name="438"/>            }
<a name="439"/>            "\^d": {
<a name="440"/>               ctrl_d_flag := &amp;yes
<a name="441"/>               if /line_no then
<a name="442"/>                  tty.write(prompt, subj)
<a name="443"/>               else {
<a name="444"/>                  # Since we may be on a multiline input, but not on
<a name="445"/>                  # the last line of it, move the cursor to the end of
<a name="446"/>                  # the subject before printing the new line.
<a name="447"/>                  pos := *subj + 1
<a name="448"/>                  show()
<a name="449"/>                  tty.write()
<a name="450"/>               }
<a name="451"/>               if *subj &gt; 0 then
<a name="452"/>                  return got()
<a name="453"/>               else
<a name="454"/>                  return
<a name="455"/>            }
<a name="456"/>            "\^a": pos := 1
<a name="457"/>            "\^e": pos := *subj + 1
<a name="458"/>            "\^g": reset_term()
<a name="459"/>            "\^k": {
<a name="460"/>               if pos &lt; *subj + 1 then {
<a name="461"/>                  ed := LineEditorDeleteToEndOfLineEdit(self)
<a name="462"/>                  ed.doit()
<a name="463"/>                  undo_manager.add_edit(ed)
<a name="464"/>               }
<a name="465"/>            }
<a name="466"/>            "\^p": goto_hist(integer(subj) - history_start_no + 1)
<a name="467"/>            "\^r": hist_search(-1)
<a name="468"/>            "\^t": hist_search(1)
<a name="469"/>            "\b" | "\d": {
<a name="470"/>               if pos &gt; 1 then {
<a name="471"/>                  ed := LineEditorDeleteLeftEdit(self)
<a name="472"/>                  ed.doit()
<a name="473"/>                  undo_manager.add_edit(ed)
<a name="474"/>               }
<a name="475"/>            }
<a name="476"/>            "\t": do_complete()
<a name="477"/>            "\n": {
<a name="478"/>               if /line_no then {
<a name="479"/>                  tty.write(prompt, subj)
<a name="480"/>                  # Buffer input until got line no request response, which is now out-of-date.
<a name="481"/>                  buff_flag := &amp;yes
<a name="482"/>               } else {
<a name="483"/>                  # See ^d above
<a name="484"/>                  pos := *subj + 1
<a name="485"/>                  show()
<a name="486"/>                  tty.write()
<a name="487"/>                  return got()
<a name="488"/>               }
<a name="489"/>            }
<a name="490"/>            default: {
<a name="491"/>               if any('\x20-\x7e\x80-\U10ffff', uch) then {
<a name="492"/>                  ed := LineEditorDefaultEdit(self, uch)
<a name="493"/>                  ed.doit()
<a name="494"/>                  undo_manager.add_edit(ed)
<a name="495"/>               }
<a name="496"/>            }
<a name="497"/>         }
<a name="498"/>      }
<a name="499"/>   end
<a name="500"/>
<a name="501"/>   private show()
<a name="502"/>      local n, cursor_line, cursor_col
<a name="503"/>      if \nlines then {
<a name="504"/>         # Clear the lines written the previous time show() was called
<a name="505"/>         every tty.writes("\e[",
<a name="506"/>                          line_no to line_no + nlines - 1,
<a name="507"/>                          ";1H", "\e[2K")
<a name="508"/>      }
<a name="509"/>
<a name="510"/>      # The number of lines needed to display this line.
<a name="511"/>      nlines := 1 + (*prompt + *subj) / dim[1]
<a name="512"/>
<a name="513"/>      # Check if we need to scroll some lines
<a name="514"/>      n := nlines + line_no - dim[2] - 1
<a name="515"/>
<a name="516"/>      if n &gt; 0 then {
<a name="517"/>         # Scroll n lines
<a name="518"/>         tty.writes("\e[", n ,"S")
<a name="519"/>         line_no -:= n
<a name="520"/>      }
<a name="521"/>      # Calculate position of cursor
<a name="522"/>      cursor_line := line_no + (*prompt + pos - 1) / dim[1]
<a name="523"/>      cursor_col := (*prompt + pos - 1) % dim[1] + 1
<a name="524"/>
<a name="525"/>      # First, goto line line_no, col 1, and write prompt, subj
<a name="526"/>      # Then put cursor at correct position.
<a name="527"/>      tty.writes("\e[", line_no, ";1H", prompt, subj,
<a name="528"/>                 "\e[", cursor_line, ";", cursor_col, "H")
<a name="529"/>   end
<a name="530"/>
<a name="531"/>   # Create a LineEditorStream.
<a name="532"/>   #
<a name="533"/>   # :Parameters :
<a name="534"/>   # : `notty` - a flag, implicitly set on non-Unix platforms.  If set,
<a name="535"/>   #             then the line editing facilities are disabled
<a name="536"/>   #
<a name="537"/>   # :  `f`    - a `Stream` to read from if line editing is disabled.
<a name="538"/>   #             If omitted, FileStream.stdin is used.
<a name="539"/>   #
<a name="540"/>   # Examples :-
<a name="541"/>   # ~
<a name="542"/>   #    # On Unix use line editing, on other platforms use stdin
<a name="543"/>   #    s := LineEditorStream()
<a name="544"/>   #
<a name="545"/>   #    # Don't use line editing; read from the default stdin.
<a name="546"/>   #    s := LineEditorStream(&amp;yes)
<a name="547"/>   #
<a name="548"/>   #    # Don't use line editing; read from the given stream.
<a name="549"/>   #    s := LineEditorStream(&amp;yes, 
<a name="550"/>   #                          TaskStream(FileStream.stdin, task))
<a name="551"/>   # ~
<a name="552"/>   #
<a name="553"/>   public override new(notty, f)
<a name="554"/>      LineBasedInputStream.new()
<a name="555"/>$if _UNIX
<a name="556"/>      if /notty then {
<a name="557"/>         run_stty() | fail
<a name="558"/>         ti := read_terminfo() | fail
<a name="559"/>         tty := FileStream.stdin
<a name="560"/>         isatty := &amp;yes
<a name="561"/>      } else
<a name="562"/>$endif
<a name="563"/>      tty := \f | FileStream.stdin
<a name="564"/>      undo_manager := UndoManager()
<a name="565"/>      hmod := table()
<a name="566"/>      history := []
<a name="567"/>      history_start_no := 1
<a name="568"/>      prompt := ""
<a name="569"/>      buff := ""
<a name="570"/>      return
<a name="571"/>   end
<a name="572"/>end
<a name="573"/>
<a name="574"/>abstract class LineEditorEdit(UndoableEdit)
<a name="575"/>   protected const
<a name="576"/>      parent
<a name="577"/>   protected
<a name="578"/>      pos
<a name="579"/>
<a name="580"/>   public doit()
<a name="581"/>      save()
<a name="582"/>      self.redo_impl()
<a name="583"/>   end
<a name="584"/>
<a name="585"/>   public override redo()
<a name="586"/>      restore()
<a name="587"/>      self.redo_impl()
<a name="588"/>   end
<a name="589"/>
<a name="590"/>   public override undo()
<a name="591"/>      self.undo_impl()
<a name="592"/>      restore()
<a name="593"/>   end
<a name="594"/>
<a name="595"/>   protected abstract redo_impl()
<a name="596"/>   protected abstract undo_impl()
<a name="597"/>
<a name="598"/>   private save()
<a name="599"/>      self.pos := parent.pos
<a name="600"/>   end
<a name="601"/>
<a name="602"/>   private restore()
<a name="603"/>      parent.pos := self.pos
<a name="604"/>   end
<a name="605"/>
<a name="606"/>   public new(parent)
<a name="607"/>      self.parent := parent
<a name="608"/>      return
<a name="609"/>   end
<a name="610"/>end
<a name="611"/>
<a name="612"/>class LineEditorDefaultEdit(LineEditorEdit)
<a name="613"/>   private s
<a name="614"/>
<a name="615"/>   public override add_edit(other)
<a name="616"/>      if is(other, LineEditorDefaultEdit) &amp;
<a name="617"/>         (other.pos = self.pos + *s) then {
<a name="618"/>            s ||:= other.s
<a name="619"/>            return
<a name="620"/>      }
<a name="621"/>   end
<a name="622"/>
<a name="623"/>   protected override redo_impl()
<a name="624"/>      parent.subj := parent.subj[1:parent.pos] || s || parent.subj[parent.pos:0]
<a name="625"/>      parent.pos +:= *s
<a name="626"/>   end
<a name="627"/>
<a name="628"/>   protected override undo_impl()
<a name="629"/>      parent.subj[self.pos +: *s] := ""
<a name="630"/>   end
<a name="631"/>
<a name="632"/>   public override new(parent, e)
<a name="633"/>      LineEditorEdit.new(parent)
<a name="634"/>      s := e
<a name="635"/>      return
<a name="636"/>   end
<a name="637"/>end
<a name="638"/>
<a name="639"/>class LineEditorDeleteLeftEdit(LineEditorEdit)
<a name="640"/>   private ch
<a name="641"/>
<a name="642"/>   public override add_edit(other)
<a name="643"/>      if is(other, LineEditorDeleteLeftEdit) &amp;
<a name="644"/>         (pos = other.pos + *ch) then
<a name="645"/>      {
<a name="646"/>         ch := other.ch || ch
<a name="647"/>         return
<a name="648"/>      }
<a name="649"/>   end
<a name="650"/>
<a name="651"/>   protected override redo_impl()
<a name="652"/>      parent.subj[parent.pos -: *ch] := ""
<a name="653"/>      parent.pos -:= *ch
<a name="654"/>   end
<a name="655"/>
<a name="656"/>   protected override undo_impl()
<a name="657"/>      if pos - *ch &gt; *parent.subj then
<a name="658"/>         parent.subj ||:= ch
<a name="659"/>      else
<a name="660"/>         parent.subj[pos - *ch] := ch || parent.subj[pos - *ch]
<a name="661"/>   end
<a name="662"/>
<a name="663"/>   public override new(parent)
<a name="664"/>      LineEditorEdit.new(parent)
<a name="665"/>      ch := parent.subj[parent.pos - 1]
<a name="666"/>      return
<a name="667"/>   end
<a name="668"/>end
<a name="669"/>
<a name="670"/>class LineEditorDeleteRightEdit(LineEditorEdit)
<a name="671"/>   private ch
<a name="672"/>
<a name="673"/>   public override add_edit(other)
<a name="674"/>      if is(other, LineEditorDeleteRightEdit) &amp;
<a name="675"/>         (pos = other.pos) then 
<a name="676"/>      {
<a name="677"/>         ch ||:= other.ch
<a name="678"/>         return
<a name="679"/>      }
<a name="680"/>   end
<a name="681"/>
<a name="682"/>   protected override redo_impl()
<a name="683"/>      parent.subj[parent.pos +: *ch] := ""
<a name="684"/>   end
<a name="685"/>
<a name="686"/>   protected override undo_impl()
<a name="687"/>      if pos &gt; *parent.subj then
<a name="688"/>         parent.subj ||:= ch
<a name="689"/>      else
<a name="690"/>         parent.subj[pos] := ch || parent.subj[pos]
<a name="691"/>   end
<a name="692"/>
<a name="693"/>   public override new(parent)
<a name="694"/>      LineEditorEdit.new(parent)
<a name="695"/>      ch := parent.subj[parent.pos]
<a name="696"/>      return
<a name="697"/>   end
<a name="698"/>end
<a name="699"/>
<a name="700"/>class LineEditorDeleteToEndOfLineEdit(LineEditorEdit)
<a name="701"/>   private del
<a name="702"/>
<a name="703"/>   protected override redo_impl()
<a name="704"/>      del := parent.subj[parent.pos:0]
<a name="705"/>      parent.subj[parent.pos:0] := ""
<a name="706"/>   end
<a name="707"/>
<a name="708"/>   protected override undo_impl()
<a name="709"/>      parent.subj[self.pos:0] := del
<a name="710"/>   end
<a name="711"/>end
<a name="712"/>
<a name="713"/>class LineEditorAssignEdit(LineEditorEdit)
<a name="714"/>   private s, p, pre
<a name="715"/>   private const coalesce
<a name="716"/>
<a name="717"/>   public override add_edit(other)
<a name="718"/>      if \coalesce &amp; is(other, LineEditorAssignEdit) &amp; \other.coalesce then {
<a name="719"/>         self.s := other.s
<a name="720"/>         self.p := other.p
<a name="721"/>         return
<a name="722"/>      }
<a name="723"/>   end
<a name="724"/>
<a name="725"/>   public override redo_impl()
<a name="726"/>      pre := parent.subj
<a name="727"/>      parent.subj := s
<a name="728"/>      parent.pos := p
<a name="729"/>   end
<a name="730"/>
<a name="731"/>   public override undo_impl()
<a name="732"/>      parent.subj := pre
<a name="733"/>   end
<a name="734"/>
<a name="735"/>   public override new(parent, s, p, coalesce)
<a name="736"/>      LineEditorEdit.new(parent)
<a name="737"/>      self.s := s
<a name="738"/>      self.p := p
<a name="739"/>      self.coalesce := coalesce
<a name="740"/>      return
<a name="741"/>   end
<a name="742"/>end
<a name="743"/>
<a name="744"/>class LineEditorInsertEdit(LineEditorEdit)
<a name="745"/>   private s
<a name="746"/>
<a name="747"/>   protected override redo_impl()
<a name="748"/>      parent.subj := parent.subj[1:parent.pos] || s || parent.subj[parent.pos:0]
<a name="749"/>      parent.pos +:= *s
<a name="750"/>   end
<a name="751"/>
<a name="752"/>   protected override undo_impl()
<a name="753"/>      parent.subj[self.pos +: *s] := ""
<a name="754"/>   end
<a name="755"/>
<a name="756"/>   public override new(parent, e)
<a name="757"/>      LineEditorEdit.new(parent)
<a name="758"/>      s := e
<a name="759"/>      return
<a name="760"/>   end
<a name="761"/>end
</pre></body></html>
