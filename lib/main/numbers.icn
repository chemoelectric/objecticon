package numbers

import lang, ipl.numbers(gcd), ipl.types, util, ipl.functional

# This class encapsulates options for rounding a decimal number.
#
class Round()
   public const
      # Set if rounding is to decimal places rather than a precision.
      dp_flag,
      # The number of digits to round to.
      digits,
      # The mode, indicating which direction to round
      mode

   public static const
      # Rounding mode to round away from zero.
      UP,
      # Rounding mode to round towards zero (ie, simple truncation).
      DOWN,
      # Rounding mode to round towards positive infinity.
      CEILING,
      # Rounding mode to round towards negative infinity.
      FLOOR,
      # Rounding mode to round towards "nearest neighbour" unless both
      # neighbours are equidistant, in which case round up.  This is
      # conventional rounding.
      HALF_UP,
      # Rounding mode to round towards "nearest neighbour" unless both
      # neighbours are equidistant, in which case round down.
      HALF_DOWN

   private static init()
      UP := "up"
      DOWN := "down"
      CEILING := "ceiling"
      FLOOR := "floor"
      HALF_UP := "half-up"
      HALF_DOWN := "half-down"
   end

   # Return another instance with the same settings, but with digits
   # set to `n`.
   #
   public with_digits(n)
      return need_Round(need_integer(n) || 
         (if \dp_flag then "dp " else " ") || mode)
   end

   # Convenient method to call `with_digits` with this instance's
   # digits setting plus n.
   public add(n)
      return with_digits(digits + n)
   end

   # Succeed if this mode's rounding is influenced by digits truncated
   # beyond the first truncated digit.  For example `HALF_UP` isn't
   # influenced; if we are rounding 6.5xxx to one digit then we don't
   # care what the digits xxx are; it will round to 7 regardless.  But for
   # `HALF_DOWN` it does matter; if xxx is zero then we get 6,
   # otherwise we get 7.
   #
   # In fact, only `HALF_UP` and `DOWN` don't care about these extra
   # truncated digits;
   #
   public uses_all_digits()
      return not( mode == (HALF_UP | DOWN) )
   end

   # Given a digit `n`, which is in the range -9 to +9, return -1, 0,
   # or 1 indicating how the associated number should be rounded.  `d`
   # indicates whether any digits beyond `n` have been truncated.  If
   # it is 0, then they haven't, otherwise it will have the sign of
   # the number being rounded.  For example, if rounding 1.235 to two
   # decimal places, n would be 5 and d would be 0; if we were
   # rounding 1.2350001, then n would be 5, and d would be >0, to
   # indicate that digits existed to the right of 5.
   #
   public round_dig(n, d)
      return case mode of {
         HALF_UP :  {
            if n <= -5 then -1
            else if n >= 5 then 1
            else 0
         }
         HALF_DOWN :  {
            if n = 5 then if d = 0 then 0 else 1
            else if n = -5 then if d = 0 then 0 else -1
            else if n < -5 then -1
            else if n > 5 then 1
            else 0
         }
         UP : {
            if (n|d) > 0 then 1
            else if (n|d) < 0 then -1
            else 0
         }
         DOWN: 0
         CEILING: if (n|d) > 0 then 1 else 0
         FLOOR: if (n|d) < 0 then -1 else 0
         default: syserr("Invalid rounding mode")
      }
   end

   private parse(x, m)
      local t
      x ? {
         tab_ws()
         digits := integer(tab(many(&digits ++ '+\-'))) | fail
         if ="dp" then
            dp_flag := &yes
         tab_ws()
         if pos(0) then
            mode := \m | HALF_UP
         else {
            t := map(tab(many(&letters ++ '\-'))) | fail
            mode := case t of {
               UP | "u" : UP
               DOWN | "d" | "t" | "trunc" : DOWN
               CEILING | "c": CEILING
               FLOOR | "f" : FLOOR
               HALF_UP | "hu" : HALF_UP
               HALF_DOWN | "hd" : HALF_DOWN
               default : fail
            }
            # Check at end
            tab_ws()
            pos(0) | fail
         }
      }
      return
   end

   # Create a new instance from string `s` and optional mode `m`.  The
   # mode may also be specified within the string if desired.  The
   # string is in the format
   #
   # ~
   #    <digits>["dp"] [mode]
   # ~
   #
   # Digits provides the digit setting; if followed immediately by
   # "dp", then this sets the dp_flag.  The mode follows after one or
   # more spaces, or alternatively may be given my the `m` parameter.
   # If neither is given, then the mode is `HALF_UP`.
   #
   # Within the string, possible mode strings are :-
   #
   # ~
   #     "up" or "u" : UP
   #     "down", "d", "t" or "trunc" : DOWN
   #     "ceiling" or "c" : CEILING
   #     "floor" or "f" : FLOOR
   #     "half-up" or "hu" : HALF_UP
   #     "half-down" or "hd" : HALF_DOWN
   # ~
   #
   # Examples :
   #
   # ~
   #      "8dp trunc"    -  truncate to 8 decimal places.
   #      "10 hd"        -  precision 10, with half down
   #                        rounding.
   #      10             -  precision 10, half up.
   #      Round(12, 
   #        Round.CEILING) - precision 10, ceiling.
   # ~
   public new(s, m)
      parse(s, m) | return error("Couldn't parse string to a Round")
      if /dp_flag & digits < 1 then
         return error("Number of rounding digits outside valid range (>= 1)")
      return
   end
end

# Abstract parent class for the three number types, `Cpx`, `Rat` and
# `Dec`.  The latter two are in fact subclasses via `RealNumber`.
#
abstract class Number(ObjectOutput)
   public static const
      # Precision used in converting to icon real type
      REAL_DIGS

   private static init()
      REAL_DIGS := 20
   end

   # Add this instance to another instance of the same type.
   public abstract add(x)

   # Multiply this instance to another instance of the same type.
   public abstract mul(x)

   # Divide this instance by another instance of the same type, with
   # optional rounding `rnd`, if applicable to the type concerned.
   public abstract div(x, rnd)

   # Return this instance negated.
   public abstract neg()

   # Return a simplified equivalent to this instance; for example a
   # `Rat` with denominator 1 returns its numerator.  If no
   # simplification is possible, `self` is returned.
   public abstract reduce()

   # Produce formatted string output.
   public abstract str(fmt, dp)

   # Subtract the other instance of the same type from this instance.
   public abstract sub(x)

   private object_output(oo)
      oo.object_string(self, str())
   end
end

# A class representing complex numbers.
#
# Instances are immutable and the real and imaginary parts are either
# `Rat` or `Dec` instances
#
class Cpx(Number)
   public const r, i

   public str(f, dp)
      return "r=" || r.str(f, dp) || " i=" || i.str(f, dp)
   end

   public add(x)
      x := need_Cpx(x)
      return Cpx(numbers.add(r, x.r), numbers.add(i, x.i))
   end

   public sub(x)
      return add(need_Cpx(x).neg())
   end

   public mul(x)
      x := need_Cpx(x)
      return Cpx(numbers.sub(numbers.mul(r, x.r), numbers.mul(i, x.i)),
                 numbers.add(numbers.mul(r, x.i), numbers.mul(i, x.r)))
   end

   public div(x, rnd)
      local denom
      x := need_Cpx(x)
      denom := numbers.add(numbers.mul(x.r,x.r), numbers.mul(x.i,x.i))
      return Cpx(numbers.div(numbers.add(numbers.mul(r, x.r), numbers.mul(i, x.i)), denom, rnd),
                 numbers.div(numbers.sub(numbers.mul(i, x.r), numbers.mul(r, x.i)), denom, rnd))
   end

   public neg()
      return Cpx(r.neg(), i.neg())
   end

   public reduce()
      return real_number() | self
   end

   # Convert to a `RealNumber`, returning the real part if and only if
   # the imaginary part is zero.
   public real_number()
      if i.sign() = 0 then
         return r
   end

   # Create a new `Cpx` instance with real part `x` and imaginary part
   # `y`.  Both parameters must be convertible to `Rat` or `Dec`.
   #
   public new(x, y)
      r := need_RealNumber(x)
      i := need_RealNumber(y)
      return
   end
end

# This class just lists operations common to its two subclasses, `Dec` and `Rat`.
#
abstract class RealNumber(Number)
   # Compare this instance to another of the same type using the
   # relational operator `f`.  For example,
   # ~
   #   x.cmp("<", y)
   # ~
   # succeeds iff `x < y`.
   #
   public cmp(f, x)
      if f(sub(x).sign(), 0) then
         return
   end

   # Return the absolute value of this number.
   public abs()
      return if sign() >= 0 then self else neg()
   end

   # Return the sign of this number (-1, 0 or 1, depending on whether
   # it is less than, equal to, or greater than zero).
   public abstract sign()

   # Subtract x from this instance and return the sign of the result.
   # This is useful for sorting; see `number_comparator()` below.
   #
   public sub_sign(x)
      return sub(x).sign()
   end

   # Convert to `Dec`, or fail if no rounding is specified and an
   # exact conversion is not possible.
   #
   public abstract decimal(rnd)

   # Convert to `Rat`
   #
   public abstract rational()

   # Convert to integer
   #
   public abstract integer()

   # Convert to real, or fail if that is not possible.
   #
   public abstract real()
end

# A class representing rational numbers.
#
# All instances are immutable and are stored in a normalized form, so
# that two instances representing the same number always have the same
# numerator and denominator.
#
class Rat(RealNumber)
   public const n, d

   private static commas(n, f)
      n := string(n)
      if any(f, ",") then
         every n[*n - 3 to 1 by -3] ||:= Format.THOUSANDS_SEPARATOR
      return n
   end

   #
   # Convert to a string.
   #
   # :Parameters :
   # :  `f` -  A cset of flags.  If c contains `','` then commas
   #           are introduced into the non-fractional part of the number;
   #           if c contains `'+'` then a leading + is added to positive
   #           numbers.  If c contains `'t'` then no whole number is output
   #           before the fractional part (eg 4/3 rather than 1 1/3).
   #
   public str(f)
      local i, s, n1
      n1 := default.abs(n)
      /f := ''
      f := need_cset(f)
      if d = 1 then
         s := commas(n1, f)
      else {
         s := if any(f, "t") | (i := n1 / d) = 0 then
            commas(n1, f) || "/" || commas(d, f)
         else
            commas(i, f) || " " || commas(n1 % d, f) || "/" || commas(d, f)
      }         
      if n < 0 then s := "-" || s
      else if any(f, "+") then s := "+" || s
      return s
   end

   # If the numerator is 0 or 1, then return the numerator; otherwise
   # return self.
   #
   public reduce()
      return if n = 0 | d = 1 then
         Dec(n)
      else
         self
   end

   # Try to convert to an equivalent `Dec` instance.  If `rnd` is
   # omitted, then this method only succeeds if this rational number
   # can be precisely expressed as a decimal.  If so, that a `Dec` is
   # returned, otherwise this method fails.  If `rnd` is given, then
   # this method always succeeds and returns a `Dec` with the division
   # calculated with that rounding.
   #
   public decimal(rnd)
      return Dec(n).div(Dec(d), rnd)
   end

   # Returns self
   public rational()
      return self
   end

   # Returns the integer whole number part of this rational.
   public integer()
      return n / d
   end

   # Returns a real number approximating this rational, or fails if
   # the result would be outside real's expressible range.
   public real()
      return decimal(REAL_DIGS).real()
   end

   public add(x)
      x := need_Rat(x)
      return Rat(n * x.d + x.n * d, d * x.d)
   end

   public sub(x)
      return add(need_Rat(x).neg())
   end

   public mul(x)
      x := need_Rat(x)
      return Rat(n * x.n, d * x.d)
   end

   public div(x)
      x := need_Rat(x)
      return Rat(n * x.d, d * x.n)
   end

   public neg()
      return Rat(-n, d)
   end

   public inv()
      return Rat(d, n)
   end

   public sign()
      return ipl.numbers.sign(n)
   end

   # Return the reciprocal of this rational.
   public reciprocal()
      return Rat(d, n)
   end

   private parse(x)
      local i, j
      x ? {
         tab_ws()
         # The first integer may be either the whole number ("1 2/3")
         # or the numerator ("2/3").
         i := default.integer(tab(many(&digits ++ '+\-'))) | fail
         tab_ws()
         if any(&digits) then {
            # It was the whole number, get the numerator
            j := default.integer(tab(many(&digits)))
            tab_ws()
         }
         if ="/" then {
            tab_ws()
            d := 0 ~= default.integer(tab(many(&digits))) | fail
            if /j then
               n := i
            else {
               if i < 0 then
                  j := -j
               n := j + i * d
            }
         } else {
            # Can't have a whole number and no /, eg "1 3" is rejected.
            /j | fail
            n := i
            d := 1
         }

         # Check at end
         tab_ws()
         pos(0) | fail
      }
      return
   end

   private normalize()
      local g
      if d = 0 then
         runerr(201)
      if d < 0 then {
         d := -d
         n := -n
      }
      g := gcd(n, d)
      n /:= g
      d /:= g
   end

   # Create a new instance.  If `x` and `y` are given, then they must
   # both be integers representing the numerator and denominator
   # respectively.  Otherwise, if only `x` is given, then `x` may be :-
   #
   # * an integer, which produces a `Rat` of corresponding value,
   #   with denominator 1.
   # * another `Rat`, which gives a copy of it
   # * a `Dec` instance, which produces the corresponding exact
   #   rational value.
   # * a string, which is parsed.  If it contains a ".", or an "e" or
   #   an "E" then it represents a decimal, which is parsed and then
   #   converted to a rational equivalent.  Otherwise it is parsed as
   #   a rational number, with a "/" separating numerator and
   #   denominator. If the string cannot be parsed, the constructor
   #   fails.
   #
   # On failure, `&why` is set indicating the reason.
   #
   public new(x, y)
      if \y then {
         n := need_integer(x)
         d := need_integer(y)
      } else case typeof(x) of {
         "integer" : {
            n := x
            d := 1
         }
         Cpx: {
            x := x.real_number().rational() | return error("Couldn't convert complex to a rational")
            n := x.n
            d := x.d
         }
         Rat: {
            n := x.n
            d := x.d
         }
         Dec: {
            x := x.rational()
            n := x.n
            d := x.d
         }
         default: {
            x := need_string(x)
            # The two tests are needed to stop the Rat and Dec
            # constructors calling one another endlessly.
            if probably_decimal(x) & not probably_rational(x) then {
               x := Dec(x).rational() | fail
               n := x.n
               d := x.d
            } else
               parse(x) | return error("Couldn't parse string as a rational")
         }
      }
      normalize()
      return
   end
end

# A class representing arbitrary precision decimal numbers.
#
# All instances are immutable and are stored in a normalized form, so
# that two instances representing the same number always have the same
# numerator and denominator.
#
class Dec(RealNumber, ObjectHash, ObjectEquals)
   public const m, e

   # Cached calculation of precision
   private cp

   private static const p10

   private static init()
      p10 := memoize1(lpb(10, "^"))
   end

   private object_equals(x)
      return m = x.m & e = x.e
   end

   private object_hash()
      return iand(m, 16rffff) + 37 * default.abs(e)
   end

   #
   # Convert to a string.
   #
   # :Parameters :
   # :  `f` -  A cset of flags.  If c contains `'e'` then the output is
   #           in scientific notation.  `'E'` is the same, but uses a
   #           a capital "E" in the result. If c contains `','` then commas
   #           are introduced into the non-fractional part of the number;
   #           if c contains `'+'` then a leading + is added to positive
   #           numbers.  If c contains `'s'` then trailing fractional
   #           zeroes are replaced with spaces, whilst `'z'` means drop
   #           such zeroes altogether.
   # :  `dp`   The number of decimal places to produce (default all
   #           significant places).
   #
   public str(f, dp)
      local s, m1, e1, t, zch, tp, ec
      /f := ''
      f := need_cset(f)
      if \dp then {
         dp := need_integer(dp, 0)
         if not any(f, "z") then
            zch := if any(f, "s") then " " else "0"
      }

      if any(f, ec := "e"|"E") then {
         if \dp then {
            # One place to the left of the point and dp to the right.
            t := round(dp + 1)
            m1 := t.m; e1 := t.e
            # Now *s below will be <= dp+1
         } else {
            m1 := m; e1 := e
         }
         s := string(default.abs(m1))
         e1 +:= *s - 1
         # Unless dp is > 0, express something like "3000" as "3e+3" rather
         # than "3.0e3".
         if *s > 1 | \dp > 0 then {
            s[1] ||:= Format.DECIMAL_POINT
            if *s = 2 then s ||:= "0"
            # Since to start with *s <= dp+1, we added a ".", so *s <= dp+2,
            # so dp + 2 - *s >= 0
            s ||:= repl(\zch, dp + 2 -*s)
         }
         s ||:= ec
         if e1 >= 0 then s ||:= "+"
         s ||:= e1
      } else {
         if \dp then {
            t := round_dp(dp)
            m1 := t.m; e1 := t.e
            # Now e1 >= -dp
         } else {
            m1 := m; e1 := e
         }
         s := string(default.abs(m1))
         if e1 >= 0 then {
            # Case 1, point to right of digits, eg 12340000
            s ||:= repl("0", e1)
            tp := *s + 1
            if \dp > 0 then {
               s ||:= Format.DECIMAL_POINT || "0"
               s ||:= repl(\zch, dp - 1)
            }
         } else if -e1 < *s then {
            # Case 2, point in middle of digits, eg 1234.5678
            s[e1 - 1] ||:= Format.DECIMAL_POINT
            tp := *s + e1
            # Since e1 >= -dp (by round_dp), dp + e1 >= 0
            s ||:= repl(\zch, dp + e1)
         } else {
            # Case 3, point to left of digits, eg 0.00001234
            s := "0" || Format.DECIMAL_POINT || repl("0", -e1 - *s) || s
            s ||:= repl(\zch, dp + e1)
         }
         if \tp & any(f, ",") then
            every s[tp - 4 to 1 by -3] ||:= Format.THOUSANDS_SEPARATOR
      }
      if m < 0 then s := "-" || s
      else if any(f, "+") then s := "+" || s
      return s
   end

   public add(x)
      local m1, e1, m2, e2
      x := need_Dec(x)
      m1 := self.m
      e1 := self.e
      m2 := x.m
      e2 := x.e
      return if e1 < e2 then
         Dec(m1 + m2 * p10(e2 - e1), e1)
      else
         Dec(m1 * p10(e1 - e2) + m2, e2)
   end

   public sub(x)
      return add(need_Dec(x).neg())
   end

   public neg()
      return Dec(-m, e)
   end

   public sign()
      return ipl.numbers.sign(m)
   end

   public mul(x)
      x := need_Dec(x)
      return Dec(m * x.m, e + x.e)
   end

   # Return the precision of this number, which is the number of
   # digits in the mantissa.
   #
   public precision()
      /cp := *default.abs(m)
      return cp
   end

   # Round to the given number of decimal places; for example 123.456
   # rounded to 1 decimal place would be 123.5
   #
   public round_dp(dp)
      return round(need_integer(dp) || "dp")
   end

   # Truncate to the given precision.
   #
   public trunc(prec)
      return round(need_integer(prec) || " t")
   end

   # Truncate to the given number of decimal places.
   #
   public trunc_dp(dp)
      return round(need_integer(dp) || "dp t")
   end

   # Round this decimal as indicated by the `Round` instance `r`.
   #
   public round(rnd)
      return round_impl(need_Round(rnd))
   end

   private round_impl(rnd, chop)
      local n, m1, i
      # Calculate the number of digits to shift right
      n := if /rnd.dp_flag then
         precision() - rnd.digits
      else
         -e - rnd.digits
      if n <= 0 then {
         # No shift needed, ie the number has less digits than the
         # round indicates.
         if /chop then
            return self
         # We chopped off some digits (in a previous division), so
         # adjustment may be necessary.  For example, dividing
         # 23267.7217 by 79727.39 (=0.2918410059579...), would give
         # m=291841,e=-6 with chop set.  We may need to adjust m and
         # e; if rounding to "6 up", n=0, we want m=291842; if "7 up"
         # then n = -1, we want m=291411.  In general we shift m left
         # by -n places and add any rounding digit.
         i := rnd.round_dig(0, m)
         # Nothing to add, so result stays the same
         if i = 0 then
            return self
         m1 := m * p10(-n) + i
      } else {
         # We need to shift right n places.  Firstly shift right n-1
         # places; the last shift place is needed for rounding.
         m1 := m / p10(n - 1)
         # If we have shifted right by one or more digits then, since
         # the mantissa is normalized, we must have chopped off some
         # digits.  (Unless m=0, in which case chop makes no
         # difference).
         if /chop & n > 1 then
            chop := &yes
         # Now do the last shift of one place, and add any rounding.
         m1 := m1 / 10 + rnd.round_dig(m1 % 10,
                                       if /chop then 0 else m)
      }
      return Dec(m1, e + n)
   end

   # Divide this number by another `Dec`.
   #
   # If `Round` `rnd` is given, then the result is rounded accordingly.
   # 
   # If `rnd` is omitted, and the division can be expressed exactly
   # without rounding, then the result is exact; otherwise this method
   # fails.
   # 
   # For example, `Dec(1234).div(Dec(1024))` can be expressed
   # precisely and results in `Dec(1.205078125)`, whereas
   # `Dec(1234).div(Dec(6))` cannot, and fails.  With a rounding
   # parameter of 5 however, it will succeed with `Dec(205.67)`.
   #
   public div(x, rnd)
      x := need_Dec(x)
      if x.m = 0 then
         runerr(201, x)
      return if /rnd then
         div_exact(x)
      else
         div_round(x, rnd)
   end

   # Return this number divided by `x` if it can be divided exactly,
   # or fail if it cannot.
   #
   private div_exact(x)
      local p, d
      # Work out if 1 / x.m is expressible as a decimal with finite
      # digits; it will be so if x.m's only factors are 2 and 5.
      # Each factor adds at most 1 to the number of decimal digits
      # in the answer.  We count this with p, and then know that
      # (10^p)/x.m does not lose any digits.
      d := default.abs(x.m)
      p := 1
      while d > 1 do {
         if d % 2 = 0 then
            d /:= 2
         else if d % 5 = 0 then
            d /:= 5
         else
            fail
         p +:= 1
      }
      return Dec((m * p10(p)) / x.m, e - x.e - p)
   end

   # Return this number divided by `x`, with rounding `rnd`.
   #
   private div_round(x, rnd)
      local m1, e1, m2, e2, n, d, chop
      rnd := need_Round(rnd)
      m1 := self.m
      e1 := self.e
      m2 := x.m
      e2 := x.e
      # Calculate the number of places to shift left to have
      # sufficient precision in the mantissa before the division.
      n := if /rnd.dp_flag then
         x.precision() - precision() + rnd.digits + 1
      else
         # The rhs here just ensures that m1>m2 in the division below.
         # This preserves the sign of m1/m2, which is needed for
         # round_impl().  If we didn't do this, then, eg, 1/20 rounded
         # to "0dp up" would give n=0, d=0, and would round to 0, not 1.
         max(e1 - e2 + rnd.digits + 1, x.precision() - precision() + 1)

      # Shift if necessary
      if n > 0 then {
         m1 *:= p10(n)
         e1 -:= n
      }
      d := m1 / m2
      # Note (if needed by the round mode) whether digits have been
      # chopped from the result.
      if rnd.uses_all_digits() & m1 % m2 ~= 0 then
         chop := &yes
      # Divide and round result.
      return Dec(d, e1 - e2).round_impl(rnd, chop)
   end

   # Convert to a `Rat`.
   public rational()
      return if e >= 0 then
         Rat(m * p10(e))
      else
         Rat(m, p10(-e))
   end

   # Convert to a real, or fail if the number is out of the allowable
   # range of that type.
   public real()
      return default.real(round(REAL_DIGS).str('e'))
   end

   # Returns self
   public decimal()
      return self
   end

   # Convert to an integer, truncating any fractional part.
   public integer()
      return if e >= 0 then
         m * p10(e)
      else
         m / p10(-e)
   end

   # Returns self
   public reduce()
      return self
   end

   private parse(x)
      local l, r, s
      x ? {
         tab_ws()
         s := tab(any('+\-'))
         if ="." then {
            l := 0
            # Note we don't convert to integer, since we use *r below and need any preceding "0"s.
            r := tab(many(&digits)) | fail
         } else {
            l := tab(many(&digits)) | fail
            r := if ="." then
               # Allow a trailing "." on its own
               tab(many(&digits)) | 0
            else
               0
         }
         m := l * p10(*r) + r
         if \s == "-" then
            m := -m
         e := -*r
         if any('eE') then {
            move(1)
            e +:= default.integer(tab(many(&digits ++ '+\-'))) | fail
         }
         # Check at end
         tab_ws()
         pos(0) | fail
      }
      return
   end

   private normalize()
      if m = 0 then
         e := 0
      else while m % 10 = 0 do {
         m /:= 10
         e +:= 1
      }
   end

   # Create a new instance.  If `x` and `y` are given, then they must
   # both be integers representing the mantissa and exponent
   # respectively.  Otherwise, if only `x` is given, then `x` may be :-
   #
   # * an integer, which produces a `Dec` of corresponding value, with
   #   a zero exponent.
   # * another `Dec`, which gives a copy of it
   # * a `Rat` instance, which produces the corresponding exact
   #   decimal value if the `Rat` is so expressible, but fails if it
   #   is not.
   # * a string, which is parsed.  If it contains a "/" then it
   #   represents a rational, which must be expressible as an exact
   #   decimal, or the constructor fails.  Otherwise it is parsed as a
   #   decimal number, possibly in scientific notation.  If the string
   #   cannot be parsed, the constructor fails.
   #
   # On failure, `&why` is set indicating the reason.
   #
   # Examples :-
   # ~~~
   #   Dec("1/4")      # ok, Dec(0.25)
   #   Dec("1/3")      # fails
   #   Dec("123e100")  # ok  1.23e+102
   #   Dec(123)        # ok
   #   Dec("rubbish")  # fails
   # ~~~
   #
   public new(x, y)
      if \y then {
         m := need_integer(x)
         e := need_integer(y)
      } else case typeof(x) of {
         "integer" : {
            m := x
            e := 0
         }
         Cpx: {
            x := x.real_number().decimal() | return error("Couldn't convert complex to an exact decimal")
            m := x.m
            e := x.e
         }
         Dec: {
            m := x.m
            e := x.e
         }
         Rat: {
            x := x.decimal() | return error("Couldn't convert rational to an exact decimal")
            m := x.m
            e := x.e
         }
         default: {
            x := need_string(x)
            # The two tests are needed to stop the Rat and Dec
            # constructors calling one another endlessly.
            if probably_rational(x) & not probably_decimal(x) then {
               x := Rat(x) | fail
               x := x.decimal() | return error("Couldn't convert rational to an exact decimal")
               m := x.m
               e := x.e
            }
            else 
               parse(x) | return error("Couldn't parse string as a decimal")
         }
      }
      normalize()
      return
   end
end

package procedure probably_decimal(s)
   return upto('.eE', s)
end

package procedure probably_rational(s)
   return upto('/', s)
end

package procedure tab_ws()
   return tab(many(' \t\n\r'))
end

# Convert an arbitrary value x into a `Rat`, `Dec` or `Cpx` instance,
# or fail if that can't be done.  Existing instances are just
# returned; integers and reals are converted to `Dec`.
#
# Other values are converted to string for parsing, and a runerr is produced
# if that conversion is not possible.
#
# The resulting string is parsed to a `Dec` if it contains a ".", "e"
# or "E", and a `Rat` otherwise.  If the parsing fails, this procedure
# fails.
#
procedure to_Number(x)
   x := case typeof(x) of {
      Rat|Dec|Cpx: x
      "integer"|"real": Dec(x)
      default: {
         x := need_string(x)
         if probably_decimal(x) then
            Dec(x)
         else
            Rat(x)
      }
   } | fail
   return x.reduce()
end

#
# Helper procedure to signal a runerr if `to_Number` fails.
#
procedure need_Number(x)
   return to_Number(x) | runerr("Number expected: " || &why, x)
end

#
# Helper procedure to signal a runerr if `to_Number` fails, or a `Cpx`
#
procedure need_RealNumber(x)
   x := need_Number(x)
   is(x, RealNumber) | runerr("Complex number not allowed", x)
   return x
end

# Helper procedure to convert x to a `Dec` (using its constructor),
# and signal a runerr if that is not possible.
#
procedure need_Dec(x)
   return if is(x,Dec) then x else Dec(x) | runerr("Decimal expected: " || &why, x)
end

# Helper procedure to convert x to a `Rat` (using its constructor),
# and signal a runerr if that is not possible.
#
procedure need_Rat(x)
   return if is(x,Rat) then x else Rat(x) | runerr("Rational expected: " || &why, x)
end

# Helper procedure to convert x to a `Cpx`, or raise a runerr.
#
procedure need_Cpx(x)
   return if is(x,Cpx) then x else Cpx(x, 0)
end

# Helper procedure to convert x to a `Round`, or raise a runerr.
#
procedure need_Round(x)
   return if is(x,Round) then x else Round(x) | runerr("Round expected: " || &why, x)
end

record Align(x, y)

# Take two arbitrary values and returns two equivalent values which are
# of the same class.  An `Align` record is returned.
#
# First `need` is used to convert `x` and `y` from simple types
# (integer and real) and strings into a `Dec`, `Rat` or `Cpx`.  Then,
# if the `x` and `y` aren't of the same resulting type, one of them is
# converted so their types are the same.  Any conversion made will be
# exact.
# 
procedure align(x, y)
   return align_impl(need_Number(x), need_Number(y))
end

# Like `align`, but accepts only real numbers (`Dec` or `Rat`), but not `Cpx`.
#
procedure align_real_numbers(x, y)
   return align_impl(need_RealNumber(x), need_RealNumber(y))
end

package procedure align_impl(x, y)
   if classof(x) === classof(y) then
      return Align(x, y)
   if is(x, Cpx) then
      return Align(x, Cpx(y, 0))
   if is(y, Cpx) then
      return Align(Cpx(x, 0), y)
   # Now x, y are both Rat or Dec, but different
   if is(x, Dec) then {
      # Dec, Rat; if x is not fractional prefer Rat, else prefer Dec if possible
      return if x.e >= 0 then
         Align(x.rational(), y)
      else
         Align(x, y.decimal()) | Align(x.rational(), y)
   }
   if is(y, Dec) then {
      # Rat, Dec; as above
      return if y.e >= 0 then
         Align(x, y.rational())
      else
         Align(x.decimal(), y) | Align(x, y.rational())
   }
   # Should never get here
   syserr("Unexpected arrival in align")
end

# Return the sum of `x` and `y`.  The two values are first converted
# and made the same type by `align()`.
#
procedure add(x, y)
   local c
   c := align(x, y)
   return c.x.add(c.y).reduce()
end

# Return 'y' subtracted from `x`.  The two values are first converted
# and made the same type by `align()`.
#
procedure sub(x, y)
   local c
   c := align(x, y)
   return c.x.sub(c.y).reduce()
end

# Return the product of `x` and `y`.  The two values are first converted
# and made the same type by `align()`.
#
procedure mul(x, y)
   local c
   c := align(x, y)
   return c.x.mul(c.y).reduce()
end

# Return `x` divided by `y` with optional rounding `rnd`.  The two
# values are first converted and made the same type by `align()`.
#
# If no rounding is given, and both are `Dec`, then an exact `Dec`
# division is tried first.  If that is not possible, an exact `Rat`
# division is used instead.  For example, div(1,1024) gives a `Dec`
# but div(1,1023) gives a `Rat`.  If a rounding were given to the
# latter division, a rounded `Dec` would result.
#
procedure div(x, y, rnd)
   local c, res
   c := align(x, y)
   res := if /rnd & is(c.x, Dec) then
      c.x.div(c.y) | c.x.rational().div(c.y.rational())
   else
      c.x.div(c.y, rnd)
   if \rnd & is(res, Rat) then
      res := res.decimal(rnd)
   return res.reduce()
end

#
# Compare `x` and `y` using the binary operator `f`.  The two values
# are first converted and made the same type by `align()`.
#
procedure cmp(x, f, y)
   local c
   c := align_real_numbers(x, y)
   return c.x.cmp(f, c.y)
end

# This procedure takes two `Rat` or `Dec` instances and returns -1, 0
# or 1 depending on whether `x` is less than, equal to, or greater
# than `y`, respectively.
#
# This procedure can also be used with sorting functions such as
# `ipl.sort.qsort()`.  For example :-
#
# ~
#     l := [Dec(100), Dec(2.3), Rat(1,3), Dec(99), Rat(32,7),
#           Dec(13),Rat(11,4) ]
#
#     qsort(l, number_comparator)
#
#     # Now l is [ Rat5(1/3), Dec(2.3), Rat(2 3/4), Rat(4 4/7),
#                  Dec4(13), Dec(99), Dec(100) ]
# ~
#
procedure number_comparator(x, y)
   local c
   c := align_real_numbers(x, y)
   return c.x.sub_sign(c.y)
end
