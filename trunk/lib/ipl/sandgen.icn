############################################################################
#
#	File:     sandgen.icn
#
#	Subject:  Procedures for "evaluation sandwiches" code
#
#	Author:   Ralph E. Griswold
#
#	Date:     November 19, 1997
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#  This program is designed to be linked with the output of the meta-
#  translator.  These procedures produce "evaluation sandwiches"
#  so that program execution can be monitored.
#
#  See "Evaluation Sandwiches", Icon Analyst 6, pp. 8-10, 1991.
#
############################################################################
#
#  Bug:  The invocable declaration is not handled properly.  "invocable all"
#        will get by, but some other forms produce syntax errors.  The
#        problem is in the meta-translator itself, not in this program.
#
############################################################################
#
#  Links:  strings
#
############################################################################

package ipl.sandgen

import
   io(write),
   ipl.strings(cat)

global code_gen

procedure main(Mp)

   code_gen := sandwich			# so it can be changed easily

   write("link prepost")		# link the sandwich slices

   Mp()					# call meta-procedure

end

# e1 | e2
procedure Alt(e1, e2)			

   return code_gen("(", e1, "|", e2, ")")

end

# e1 ! e2
procedure Apply(e1, e2)		

   return code_gen("(", e1, "!", e2, ")")

end

procedure Arg(e)

   return e

end

# e1 op e2
procedure Asgnop(op, e1, e2)		

   return code_gen("(", e1, " ", op, " ", e2, ")")

end

# e1 ?:= e2
procedure Augscan(e1, e2)		

   return code_gen("(", e1, " ?:= ", e2, ")")

end

# e1 & e2
procedure Bamper(e1, e2)		

   return code_gen("(", e1, " & ", e2, ")")

end

# e1 op e2
procedure Binop(op, e1, e2)		

   return code_gen("(", e1, " ",  op, " ",  e2, ")")

end

# procedure body
procedure Body(es[])			

   every write(!es)

   return

end

# break e
procedure Break(e)			

   return code_gen("break ", e)

end

# case e of { caselist }
procedure Case(e, clist)		

   return code_gen("case ", e, " of {", clist, "}")

end

# e1 : e2
procedure Cclause(e1, e2)		

   return code_gen(e1, " : ", e2, "\n")

end

# cclause1 ; cclause2
procedure Clist(cclause1, cclause2)		

   return code_gen(cclause1, ";", cclause2)

end

# 'c'
procedure Clit(c)			

   return image(c)

end

# { e1; e2; ... }
procedure Compound(es[])		
   local result

   if *es = 0 then return "{}\n"

   result := "{\n"
   every result ||:= !es || "\n"

   return code_gen(result, "}\n")

end

# create e
procedure Create(e)			

   return code_gen("create ", e)

end

# default: e
procedure Default(e)			

   return code_gen("default: ", e)

end

# end
procedure End()			

   write("end")

   return

end

# every e
procedure Every(e)			

   return code_gen("every ", e)

end

# every e1 do e2
procedure EveryDo(e1, e2)		

   return code_gen("every ", e1, " do ", e2)

end

# fail
procedure Fail()			

   return "fail"

end

# e . f
procedure Field(e, f)		

   return code_gen("(", e, ".", f, ")")

end

# global v1, v2, ...
procedure Global(vs[])		
   local result

   result := ""
   every result ||:= !vs || ", "

   write("global ", result[1:-2])
   
   return

end

# if e1 then e2
procedure If(e1, e2)			

   return code_gen("if ", e1, " then ", e2)

end

# if e1 then e2 else e3
procedure IfElse(e1, e2, e3)		

   return code_gen("if ", e1, " then ", e2, " else ", e3)

end

# i
procedure Ilit(i)			

   return i

end

# initial e
procedure Initial(e)			

   write("initial ", e)

   return

end

# invocable s1, s2, ... (problem)
procedure Invocable(ss[])		

   if \ss then write("invocable all")
   else write("invocable ", ss)

   return

end

# e(e1, e2, ...)
procedure Invoke(e, es[])		
   local result

   if *es = 0 then return code_gen(e, "()")

   result := ""
   every result ||:= !es || ", "

   return code_gen(e, "(", result[1:-2], ")")

end

# &s
procedure Key(s)			

   return code_gen("&", s)

end

# e1 \ e2
procedure Limit(e1, e2)		

   return code_gen("(", e1, "\\", e2, ")")

end

# link "v1, v2, ..."
procedure Link(vs[])			
   local result

   result := ""
   every result ||:= !vs || ", "

   write("link ", result[1:-2])

   return

end

# [e1, e2, ... ]
procedure List(es[])			
   local result

   if *es = 0 then return "[]"

   result := ""
   every result ||:= !es || ", "

   return code_gen("[", result[1:-2], "]")

end

# local v1, v2, ...
procedure Local(vs[])			
   local result

   result := ""
   every result ||:= !vs || ", "

   write("local ", result[1:-2])
   
   return

end

# next
procedure Next()			

   return "next"

end

# not e
procedure Not(e)			

   return code_gen("not(", e, ")")

end

# &null
procedure Null()			

   return ""

end

# (e1, e2, ... )
procedure Paren(es[])			
   local result

   if *es = 0 then return "()"

   result := ""
   every result ||:= !es || ", "

   return code_gen("(", result[1:-2], ")")

end

# e{e1, e2, ... }
procedure Pdco(e, es[])		
   local result

   if *es = 0 then return code_gen(e, "{}")

   result := ""
   every result ||:= !es || ", "

   return code_gen(e, "{", result[1:-2], "}")

end

# procedure n(v1, v2, ...)
procedure Proc(n, vs[])		
   local result, v

   if *vs = 0 then write("procedure ", n, "()")

   result := ""
   every v := !vs do
      if \v == "[]" then result[-2:0] := v || ", "
      else result ||:= (\v | "") || ", "

   write("procedure ", n, "(", result[1:-2], ")")

   return

end

# record n(f1, f2, ...)
procedure Record(n, fs[])		
   local result, field

   if *fs = 0 then write("record ", n, "()")

   result := ""
   every field := !fs do
      result ||:= (\field | "") || ", "

   write("record ", n, "(", result[1:-2], ")")

   return

end

# repeat e
procedure Repeat(e)			

   return code_gen("repeat ", e)

end

# return e
procedure Return(e)			

   return code_gen("return ", e)

end

# r
procedure Rlit(r)			

   return r

end

# e1 ? e2
procedure Scan(e1, e2)			

   return code_gen("(", e1 , " ? ", e2, ")")

end

# e1[e2 op  e3]
procedure Section(op, e1, e2, e3)	

   return code_gen(e1, "[", e2, op, e3, "]")

end

# "s"
procedure Slit(s)			

   return image(s)

end

# static v1, v2, ..
procedure Static(vs[])			
   local result

   result := ""
   every result ||:= !vs || ", "

   write("static ", result[1:-2])
   
   return

end

# e1[e2]
procedure Subscript(e1, e2)		

   return code_gen(e1, "[", e2, "]")

end

# suspend e
procedure Suspend(e)			

   return code_gen("suspend ", e)

end

# suspend e1 do e2
procedure SuspendDo(e1, e2)		

   return code_gen("suspend ", e1, " do ", e2)

end

# e1 to e2
procedure To(e1, e2)			

   return code_gen("(", e1, " to ", e2, ")")

end

# e1 to e2 by e3
procedure ToBy(e1, e2, e3)		

   return code_gen("(", e1, " to ", e2, " by ", e3, ")")

end

# |e
procedure Repalt(e)			

   return code_gen("(|", e, ")")

end

# op e
procedure Unop(op, e)			

   return code_gen("(", op, e, ")")

end

# until e
procedure Until(e)			

   return code_gen("until ", e)

end

# until e1 do e2
procedure UntilDo(e1, e2)		

   return code_gen("until ", e1, " do ", e2)

end

# v
procedure Var(v)			

   return v

end

# while e
procedure While(e)			

   return code_gen("while ", e)

end

# while e1 do e2
procedure WhileDo(e1, e2)		

   return code_gen("while ", e1, " do ", e2)

end

#  Generate "evaluation sandwich" code.

procedure sandwich(s[])

   push(s, "(pre(), post(")
   put(s, "))")

   return cat ! s

end
