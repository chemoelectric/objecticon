package io

import lang

# This stream wraps another stream (normally a {SocketStream}).  The
# {in} and {out} methods are invoked from the co-expression of the
# owning {Task}.  Those methods activate the {Task}'s {Scheduler}'s
# co-expression.  The stream's co-expression is re-activated only when
# the {Scheduler} determines the socket is ready for i/o (or has timed
# out).
#
class TaskStream(Stream)
   private readable
      timeout,
      other,
      task

   # Use the owning {Task} to poll for some i/o.  The given parameter
   # should be {Poll.IN} or {Poll.OUT} depending on whether we want to
   # be resumed on ready input or output respectively.
   #
   public poll(x)
      return task.poll(other, x, timeout)
   end

   public in(n)
      poll(Poll.IN) | fail
      return other.in(n)
   end

   public out(s)
      poll(Poll.OUT) | fail
      return other.out(s)
   end

   public close()
      return other.close()
   end

   public eof()
      return other.eof()
   end

   public get_mode()
      return other.get_mode()
   end

   public seek(offset)
      return other.seek(offset)
   end

   public tell()
      return other.tell()
   end

   public truncate(len)
      return other.truncate(len)
   end

   public new(other, task, timeout)
      self.other := other
      self.task := task
      self.timeout := timeout
      return
   end
end

class Task()
   public const
      scheduler
   private readable
      coex,
      sleep_until,
      last_sleep,
      poll_until,
      poll_stream,
      poll_for
   package readable
      state,
      active

   # If a task is currently sleeping, then this alters the time it
   # will sleep for, behaving as though the original call to {sleep}
   # had given {n} as its parameter.  Providing {0} as a parameter
   # will make the task ready to be activated again immediately.
   #
   public change_sleep(n)
      sleep_until := \last_sleep + n
   end

   # Succeed iff the task is currently active.
   #
   public is_active()
      return .\active
   end

   # Succeed iff the task is the current task.  Note that a task may
   # be active, but not the current task, since a task may itself
   # invoke {Scheduler.work} in order to activate another task, in a
   # nested fashion.  This may happen for example when a task shows a
   # modal dialog, and hence calls {Scheduler.work} via the dispatcher
   # event loop.
   #
   public is_current()
      return self === scheduler.curr_task
   end

   # Suspend this task, which must be the currently scheduled task
   # until the given stream is ready for i/o, or the timeout expires.
   # In the latter case, the method fails.  This method isn't normally
   # called directly, but rather is invoked automatically by using a
   # {TaskStream}.
   #
   # @param stream The stream to wait for, which must be suitable
   # @              as a parameter for {DescStream.poll()}.
   # @param for The event to wait for, either {Poll.IN} or {Poll.OUT}.
   # @param timeout The timeout.
   #
   public poll(stream, for, timeout)
      self === scheduler.curr_task | runerr("poll called on task which is not current")
      self.coex := &current
      self.poll_until := Prog.get_runtime_millis() + timeout
      self.poll_stream := stream
      self.poll_for := for
      return scheduler.now_poll(self)
   end

   # Suspend this task, which must be the currently scheduled task,
   # for {n} milliseconds.
   #
   # @param n The time to wait for.
   #
   public sleep(n)
      self === scheduler.curr_task | runerr("sleep called on task which is not current")
      self.coex := &current
      last_sleep := Prog.get_runtime_millis()
      sleep_until := last_sleep + n
      scheduler.now_sleep(self)
   end

   # Suspend this task, which must be the currently scheduled task,
   # but do not resume it.  Control reverts to the scheduler.  The
   # task may be subsequently restarted with {start}.  It is not
   # normally necessary to call this method, since it has the same
   # effect as suspending the task's co-expression using {suspend},
   # {fail}, or {return}.
   #
   public revert()
      self === scheduler.curr_task | runerr("sleep called on task which is not current")
      scheduler.now_revert()
   end

   # Start the task, which may not be currently active.  If the task
   # was previously stopped in a particular state (eg sleeping), then
   # it continues from that same state.
   #
   public start()
      /active | runerr("start called on a currently active task")
      scheduler.start(self)
   end

   # Stop the task, which may not be currently active.  This prevents
   # the scheduler from activating it.  Its present state is
   # remembered, and it may be started again in that state using
   # {start}.
   #
   public stop()
      /active | runerr("stop called on a currently active task")
      scheduler.stop(self)
   end

   #
   # Create a new {Task}.
   #
   # @param scheduler The {Scheduler} to use to activate the task.
   # @param coex The co-expression body of the task.
   #
   public new(scheduler, coex)
      self.coex := coex
      self.scheduler := scheduler
      return
   end
end

class Scheduler()
   private readable 
      coex,
      curr_task

   private
      ready,
      sleeping,
      polling,
      err_io,
      timeout_io
   
   public new()
      ready := set()
      sleeping := set()
      polling := set()
      err_io := set()
      timeout_io := set()
      return
   end

   package start(t)
      /t.state := ready
      insert(t.state, t)
   end

   package stop(t)
      delete(\t.state, t)
   end

   private set_state(t, x)
      delete(\t.state, t)
      t.state := x
      insert(t.state, t)
   end

   package now_sleep(t)
      \coex | syserr("now_sleep with null coex")
      set_state(t, sleeping)
      coact(, coex)
   end

   package now_poll(t)
      \coex | syserr("now_poll with null coex")
      set_state(t, polling)
      return coact(, coex)
   end

   package now_revert()
      \coex | syserr("now_revert with null coex")
      return coact(, coex)
   end

   #
   # Do some i/o work.  A maximum of {n} bits of work are done; the
   # default is 1.  If {n} is negative, work is done until no more is
   # ready.  Succeeds if any work was done; fails if no work was done.
   #
   public work(n)
      local r
      /n := 1
      until n = 0 do {
         do_work() | break
         r := 1
         n -:= 1
      }
      return \r
   end

   #
   # Test whether there are any tasks in the internal lists.
   #
   public empty()
      return not(*(ready | sleeping | polling | err_io | timeout_io) > 0)
   end

   private run(t, ff)
      local sc, st
      delete(t.state, t)
      t.state := &null
      sc := coex
      st := curr_task
      coex := &current
      curr_task := t
      t.active := 1
      coact(, t.coex, &current, ff)
      t.active := &null
      coex := sc
      curr_task := st
    end

   private do_work()
      local t, poll_l, r, curr_time, x
      repeat {
         if t := ?ready then {
            run(t)
            return
         }

         if *sleeping > 0 then {
            curr_time := Prog.get_runtime_millis()
            every t := !sleeping do {
               if curr_time >= t.sleep_until then
                  set_state(t, ready)
            }
            if *ready > 0 then
               next
         }

         if t := ?err_io then {
            &why := "Socket error"
            run(t, 1)
            return
         }

         if t := ?timeout_io then {
            &why := "Timeout"
            run(t, 1)
            return
         }

         if *polling > 0 then {
            # Time to do another poll()
            poll_l := []
            every t := !polling do {
               put(poll_l, t.poll_stream)
               put(poll_l, ior(t.poll_for,Poll.ERR))
            }
            curr_time := Prog.get_runtime_millis()
            r := DescStream.poll(poll_l, 0) | {
               ewrite("poll failed:",&why)
               fail
            }
            # Use the poll results
            every t := !copy(polling) do {
               x := pop(\r) | 0
               case x of {
                  t.poll_for: set_state(t, ready)
                  Poll.ERR: set_state(t, err_io)
                  0: {
                     if curr_time > t.poll_until then
                        set_state(t, timeout_io)
                  }
                  default: syserr("Odd value from poll:" || t)
               }
            }
            if *(ready | err_io | timeout_io) > 0 then
               next
         }
         fail
      }
   end
end
