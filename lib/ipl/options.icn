############################################################################
#
#	File:     options.icn
#
#	Subject:  Procedure to get command-line options
#
#	Authors:  Robert J. Alexander and Gregg M. Townsend
#
#	Date:     May 5, 2000
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#	options(arg, optstring,usage,errproc) removes command options
#	from the argument list of an Icon main procedure, returning a
#	table of option values.
#
############################################################################

package ipl.options

import
   io, lang, util, ipl.scan, ipl.lists

# The result of the `Opt.format` method.
record OptFormat(names, help)

class Opt()
   public const
      names, convert, multi, help, def, err

   # A utility function to help format an option string.
   public format()
      local f, ns, h, ph
      ns := ""
      every f := !names do
         ns ||:= "-" || f || ", "
      ns[-2:0] := ""
      h := \help | ""
      if \convert then {
         h ? {
            if ph := tab(upto('#')) then
               h := (move(1), tab(0))
            else
               ph := map(Proc.get_name(convert), &lcase, &ucase)
         }
         ns ||:= " " || ph
      }
      return OptFormat(ns, h)
   end

   # Create a new Opt instance.
   # :Parameters :
   # :  `s` - the name of the option; may be a list of several synonymous names 
   # :  `convert` - the conversion function to apply (eg `integer`,
   #         `real`, `string`, etc) to the option value; if omitted then the
   #          option takes no value.
   # :  `help` - a descriptive help string
   # :  `multi` - a flag value, set if multiple uses of the option are allowed.
   # :  `def` - a default value if a flag requiring a value doesn't specify one.
   #             Note that it is still subject to the `convert` function.
   # :  `err` - a string describing the type of parameter (for error output);
   #             by default the name of the `convert` procedure.
   #
   public new(s, convert, help, multi, def, err)
      names := if type(s) == "list" then
         s
      else
         [s]
      self.convert := convert
      self.multi := check_flag(multi)
      self.help := help
      self.def := def
      /err := Proc.get_name(\convert)
      self.err := err
      return
   end
end

# Output help for a list of `Opt`s.  This procedure may be useful if a
# custom "usage" procedure is provided to `options`.
#
# :Parameters :
# :  `opts` - a list of `Opt`s
procedure options_help(opts)
   local o, t
   every o := !opts do {
      t := o.format()
      help_line(t.names, t.help)
   }
end

# Output a formatted two column help line; this is also useful if a
# custom "usage" procedure is provided.
#
# :Parameters :
# :  `ns` - the left hand (option) column
# :  `h` - the descriptive help string.
procedure help_line(ns, h)
   static cols
   local i
   initial
      cols := LineEditorStream.get_console_width() | 80
   if /h then {
      repeat {
         if i := backto(' ', ns, 1, cols - 5) then {
            write(ns[1:i])
            ns := ns[i:0]
         } else {
            write(ns)
            break
         }
      }
   } else {
      if *ns > 18 then
         writes(ns, "\n", repl(" ", 20))
      else
         writes(left(ns, 20))
      repeat {
         if i := backto(' ', h, 1, cols - 25) then {
            writes(h[1:i], "\n", repl(" ", 20))
            h := h[i:0]
         } else {
            write(h)
            break
         }
      }
   }
end

#
# This is just a wrapper around stop(), which prints out the given
# message and a helpful line about the "-help" option.
#
procedure help_stop(msg)
   stop(msg, "\nUse the -help option for more information.") 
end

#
#     This procedure separates and interprets command options included in 
#  the main program argument list.  Option names and values are removed
#  from the argument list and returned in a table.
#
#     On the command line, options are introduced by a `-` character.
#  An option name is either a single printable character, as in `-n`
#  or `-?`, or a string of letters, numbers, and underscores, as in
#  `-geometry`.  Single-character options may appear in combination,
#  for example as `-qtv`.  If an option string is ambiguous, in that
#  it may either be interpreted as a single multi-character option, or
#  as several single-character options, then the former always has
#  precedence.
#
#     Some options require values.  Generally, the option name is one
#  argument and the value appears as the next argument, for example
#  `-F file.txt`.  However, with a single-character argument name (as
#  in that example), the value may be concatenated: `-Ffile.txt` is
#  accepted as equivalent.  In a combination of single character
#  options, the last option may take a parameter: `-qFfile.txt` or
#  `-qF file.txt`.
#
#     Options may be specified using an alternative format, starting
#  with `--`.  In this case, no combination of single character
#  options is recognised, and a parameter may follow an `=` sign, eg
#  `--width=100`.
#  
#     Options may be freely interspersed with non-option arguments.
#  An argument of `-` is treated as a non-option.  The special argument
#  `--` terminates option processing.  Non-option arguments are returned
#  in the original argument list for interpretation by the caller.
#
#     An argument of the form `@filename` (a `@` immediately followed
#  by a file name) causes options() to replace that argument with
#  arguments retrieved from the file `filename`.  Each line of the file
#  is taken as a separate argument, exactly as it appears in the file.
#  Arguments beginning with - are processed as options, and those
#  starting with `@` are processed as nested argument files.  An argument
#  of `--` causes all remaining arguments IN THAT FILE ONLY to be
#  treated as non-options (including `@filename` arguments).
#
#   :The parameters of `options` are:
#  
#   :   `arg` -     the argument list as passed to the main procedure.
#
#   :   `optstring` - a string specifying the allowable options.  This is
#                   a concatenation, with optional spaces between, of
#                   one or more option specs of the form `-name%`, where
#                    *   `-`     introduces the option
#                    *   `name`  is either a string of alphanumerics
#                               (any of `a-z`, `A-Z`, `0-9`, and `_`)
#                               or any single printable character
#                    *   `%`     is one of the following flag characters:  
#                               `!`       No value is required or allowed  
#                               `:`       A string value is required  
#                               `+`       An integer value is required  
#                               `.`       A real value is required
#
#                   If the string is followed by a `*` character, then
#                   the option may be specified multiple times.
#
#                   The leading `-` may be omitted for a single-character
#                   option.  The `!` flag may be omitted except when
#                   needed to terminate a multi-character name.
#                   Thus, the following optstrings are equivalent:
#                   ~~~
#                       -n+ -t -v -q -F: -geometry: -silent
#                       n+tvqF:-geometry:-silent
#                       -silent!n+tvqF:-geometry:
#                   ~~~
#
#   :   `usage` -   a procedure which will be called, with the list of
#                   `Opt` objects (see below), if the special `-help`
#                   option is given; by default the options are listed
#                   and `exit(0)` called.  A string may be given,
#                   which is printed before the options.
#
#   :   `errproc` - a procedure which will be called if an error is
#                   is detected in the command line options.  The
#                   procedure is called with one argument:  a string
#                   describing the error that occurred.  After `errproc()`
#                   is called, `options()` immediately returns the outcome
#                   of `errproc()`, without processing further arguments.
#                   Already processed arguments will have been removed
#                   from `arg`.  If `errproc` is omitted, stop() is
#                   called if an error is detected.
#  `
#     Instead of an option string, a list of `Opt` objects may be given
#  instead.  This allows a descriptive help string to be given for
#  each option.
#
#     Using an `Opt` also allows other conversion procedures to be
#  specified.  For example, a yes/no option might be specified as:
#  ~~~
#     import util(flag)
#
#      ...
#
#         Opt("f", flag, "Overwrite any existing files")
#  ~~~
#  This would allow `-f yes`, `--f=no`, etc.
#
#     `Opt` also allows a default parameter value to be specified.  In this case,
#  the option will never obtain a parameter from the next argument, but only
#  from within the option's own argument string.  For example:
#  ~~~
#         Opt("w", integer, "Width",, 200)
#  ~~~
#  In this case `-w30` or `--w=30` would give the result `"w"->30`,
#  whilst `-w` alone, or `-w anything` would give the result
#  `"w"->200`.
#
#     A table is returned containing the options that were specified.
#  The keys are the specified option names.  The assigned values are the
#  data values following the options converted to the specified type.  For
#  an option allowing multiple usages, a the assigned value is a list.
#  A value of `&yes` is stored for options that accept no values.
#  The table's default value is `&null`.
#
#     Upon return, the option arguments are removed from arg, leaving
#  only the non-option arguments.
#
procedure options(arg, opts, usage, errproc)
   local fList, fileArg, fn, ignore, optname, opttable, x,
      option, k, v, p, opt, opttype, convert
   #
   #  Initialize.
   #
   /errproc := help_stop
   option := table()
   fList := []
   opttable := table()

   if opts := text(opts) then {
      #
      #  Scan the option specification string.
      #
      opts ? {
         opts := []
         while optname := move(1) do {
            if optname == " " then next
            if optname == "-" then
               optname := tab(many(&letters ++ &digits ++ '_')) | move(1) | break
            opttype := tab(any('!:+.')) | "!"
            convert := case string(opttype) of {
               ":": string
               "+": integer
               ".": real
               default: &null
            }
            put(opts, Opt(optname, convert,, Yes{tab(any('*'))}))
         }
      }
   }

   every opt := !opts do
      every insert(opttable, string(!opt.names), opt)

   #
   #  Iterate over program invocation argument words.
   #
   while x := get(arg) do {
      if /x then ignore := &null     # if end of args from file, stop ignoring
      else if x == ("-help" | "--help") & not member(opttable, "help") then {
         /usage := "Usage: " || Files.get_program_name() || " [OPTIONS...]"
         if usage := text(usage) then {
            write(usage)
            options_help(opts)
            exit(0)
         } else {
            usage(opts)
            fail
         }
      } else x ? {
         if ="-" & not pos(0) & /ignore then {
            if ="-" then {
               if pos(0) then
                  ignore := &yes   # ignore following args if --
               else {
                  optname := tab(upto('=') | 0)
                  opt := member(opttable, string(optname)) |
                     return errproc("Unrecognized option: --" || optname)

                  if /opt.convert then
                     v := &yes
                  else {
                     p := if ="=" then
                        tab(0)
                     else if \arg[1] & /opt.def then
                        get(arg)
                     else
                        \opt.def | return errproc("No parameter following -" || optname)
                     v := opt.convert(p) | return errproc("-" || optname || " needs " ||  opt.err || " parameter")
                  }

                  k := opt.names[1]
                  if /opt.multi then
                     insert(option, k, v)
                  else
                     put(member(option, k), v) | insert(option, k, [v]) 
               }
            } else {
               tab(0) ? until pos(0) do {
                  opt := member(opttable, string(optname := ((pos(1),tab(0)) | move(1)))) | 
                     return errproc("Unrecognized option: -" || optname)

                  if /opt.convert then
                     v := &yes
                  else {
                     p := if not pos(0) then
                        tab(0)
                     else if \arg[1] & /opt.def then
                        get(arg)
                     else
                        \opt.def | return errproc("No parameter following -" || optname)
                     v := opt.convert(p) | return errproc("-" || optname || " needs " ||  opt.err || " parameter")
                  }
                  
                  k := opt.names[1]
                  if /opt.multi then
                     insert(option, k, v)
                  else
                     put(member(option, k), v) | insert(option, k, [v]) 
               }
            }
         }
         #
         #  If the argument begins with the character "@", fetch option
         #  words from lines of a text file.
         #
         else if ="@" & not pos(0) & /ignore then {
            fn := tab(0)
            fileArg := file2list(fn) |
               return errproc("Can't open " || fn || ": " || &why)
            # push null to signal end of args from file, followed by each line.
            every push(arg, &null | back(fileArg))
         }
         else put(fList,x)
      }
   }
   every push(arg, back(fList))
   return option
end
