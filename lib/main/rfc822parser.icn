#
# $Id$
#

package mail

import 
   util,
   ipl.caseless

class RFC822Parser()
   public static const 
      CTL_CHAR,
      SPACE,
      SPECIALS,
      ATOM_CHAR,
      CTEXT_CHAR,
      FIELD_NAME_CHARS,
      QTEXT_CHAR,
      DTEXT_CHAR,
      LWSP_CHAR,
      DAYS,
      MONTHS,
      TZ_CHARS,
      TSPECIALS,
      ATOM_CHAR_1521

   private static init()
      CTL_CHAR := &ascii[1:33] ++ &ascii[128]
      SPACE := ' '
      SPECIALS := '()<>@,;:\\\".[]'
      ATOM_CHAR := &ascii -- CTL_CHAR -- SPACE -- SPECIALS
      QTEXT_CHAR := &ascii -- '\"\\\r'
      DTEXT_CHAR := &ascii -- '[]\\\r'
      CTEXT_CHAR := &ascii -- '()\\\r'
      FIELD_NAME_CHARS := &ascii -- CTL_CHAR -- SPACE -- ':'
      LWSP_CHAR := ' \t'
      DAYS := ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
      MONTHS := ["Jan", "Feb",  "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
      TZ_CHARS := '+-' ++ &digits ++ &ucase
      # RCF 1521 defs
      TSPECIALS := '()<>@,;:\\\"/[]?='
      ATOM_CHAR_1521 := &ascii -- CTL_CHAR -- SPACE -- TSPECIALS
   end

   #
   # The first four parse objects are the fundamental lexical components, other
   # than inidividual special characters (see rfc822).  Therefore, they must
   # be preceded by a call to next_token, to move the position to the correct
   # point to parse them.
   #

   #
   # qtext = <any CHAR excepting <">, "\" & CR, and including 
   #         linear-white-space>
   # quoted-pair =  "\" CHAR
   # quoted-string = <"> *(qtext/quoted-pair) <">
   #
   # Must be preceded by a call to next_token()
   #
   # @param omit - if non-null, omit the quotes from the result
   #
   private parse_quoted_string(omit)
      local res

      if /omit then
         res := move(1)
      else {
         res := ""
         move(1)
      }

      repeat {
         if any('\\') then {
            res ||:= move(2) | return error("Unterminated quoted string")
         } else if any(QTEXT_CHAR) then
            res ||:= tab(many(QTEXT_CHAR))
         else if any('\"') then {
            if /omit then 
               res ||:= move(1)
            else
               move(1)
            return res
         } else
            # Missing closing quote or illegal char
            return error("Missing closing quote or illegal char")
      }
   end

   #
   # atom        =  1*<any CHAR except specials, SPACE and CTLs>
   # ie one or more atom_char
   #
   # Must be preceded by a call to next_token()
   #
   private parse_atom()
      return tab(many(ATOM_CHAR))
   end

   #
   # domain-literal =  "[" *(dtext / quoted-pair) "]"
   # dtext =  <any CHAR excluding "[","]", "\" & CR>
   #
   # Must be preceded by a call to next_token()
   #
   private parse_domain_literal()
      local res
      res := move(1)
      repeat {
         if any('\\') then
            res ||:= move(2) | return error("Premature end of field")
         else if any(DTEXT_CHAR) then
            res ||:= tab(many(DTEXT_CHAR))
         else if any(']') then 
            return res || move(1)
         else
            # Missing closing ] or illegal char
            return error("Missing closing ] or illegal char")
      }
   end

   #
   # comment     =  "(" *(ctext / quoted-pair / comment) ")"
   #
   private parse_comment()
      local res
      res := move(1)
      repeat {
         if any('\\') then
            res ||:= move(2) | return error("Premature end of field")
         else if any(CTEXT_CHAR) then
            res ||:= tab(many(CTEXT_CHAR))
         else if any('(') then
            res ||:= parse_comment() | fail
         else if any(')') then 
            return res || move(1)
         else
            # Missing closing ) or illegal char
            return error("Missing closing ) or illegal char")
      }
   end

   private next_token()
      repeat {
         tab(many(LWSP_CHAR))
         if any('(') then
            parse_comment() | fail
         else
            return
      }
   end

   #
   # word =  atom / quoted-string
   #
   private parse_word() 
      next_token() | fail
      if any('\"') then
         return parse_quoted_string()
      else
         return parse_atom()
   end

   #
   # local-part  =  word *("." word)             
   #
   private parse_local_part()
      local res
      res := parse_word() | fail
      while res ||:= ="." do
         res ||:= parse_word() | fail
      return res
   end

   #
   # domain      =  sub-domain *("." sub-domain)
   #
   private parse_domain()
      local res
      res := parse_sub_domain() | fail
      while res ||:= ="." do
         res ||:= parse_sub_domain() | fail
      return res
   end

   #
   # sub-domain  =  domain-ref / domain-literal
   # domain-ref  =  atom
   #
   private parse_sub_domain()
      next_token() | fail
      if any('[') then
         return parse_domain_literal()
      else
         return parse_atom()
   end

   #
   # phrase =  1*word
   # 
   # In fact this is parsed as just "*word".  This allows
   # parsing of mailboxes such as, for example "<rparlett@xyz.com>" and
   # groups such as :joe@soap.com;
   #
   private parse_phrase()
      local res
      res := ""
      next_token() | fail
      while any('\"' | ATOM_CHAR) do {
         # Single spaces between words
         if *res > 0 then
            res ||:= " "
         res ||:= parse_word() | fail
         next_token() | fail
      }

      # Strictly, this would be :-
      # if *res > 0 then
      #   return res

      return res
   end

   #
   # addr_spec = local-part "@" domain
   #
   private parse_addr_spec(mb)
      local t
      t := parse_local_part() | fail
      mb.set_local_part(t)
      next_token() | fail
      ="@" | return error("@ expected")
      t := parse_domain() | fail
      mb.set_domain(t)
      return
   end

   #
   # route       =  1#("@" domain) ":" 
   # where 1#X means '(X *("," X))' 
   #
   private parse_route(mb)
      local t
      t := []
      repeat {
         next_token() | fail
         ="@" | return error("@ expected")
         put(t, parse_domain()) | fail
         next_token() | fail
         ="," | break
         next_token() | fail
      }
      next_token() | fail
      =":" | return error(": expected")
      mb.set_route(t)
      return
   end

   #
   # route-addr  =  "<" [route] addr-spec ">"
   #
   private parse_route_addr(mb)
      ="<" | return error("< expected")
      next_token() | fail
      if any('@') then
         parse_route(mb) | fail
      else
         mb.set_route([])
      next_token() | fail
      parse_addr_spec(mb) | fail
      next_token() | fail
      =">" | return error("> expected")
      return
   end

   #
   # mailbox = addr-spec | phrase route-addr
   #
   private parse_mailbox_impl(mb)
      local x, t
      /mb := Mailbox()
      #
      # The lookahead is complex, so try parsing as a simple address
      # first, and if that fails try the more complex alternative.
      #
      x := &pos
      if parse_addr_spec(mb) then {
         mb.set_phrase("")
         mb.set_route([])
      } else {
         tab(x)
         t := parse_phrase() | fail
         mb.set_phrase(t)
         parse_route_addr(mb) | fail
      }

      return mb
   end

   #
   # group =  phrase ":" [#mailbox] ";"
   # #X means empty or X,X,X...
   #    
   private parse_group_impl(group)
      local mb, t

      /group := Group()
      t := parse_phrase() | fail
      group.set_phrase(t) 

      t := []
      next_token() | fail
      =":" | return error(": expected")
      next_token() | fail
      if any(';') then # empty group
         move(1)
      else {
         repeat {
            mb := parse_mailbox_impl() | fail
            put(t, mb)
            next_token() | fail
            ="," | break
         }
         =";" | return error("; expected")
      }
      group.set_mailboxes(t)

      return group
   end

   private parse_mailbox_or_group()
      local x, a

      x := &pos
      if a := parse_mailbox_impl() then
         return a
      tab(x)

      return parse_group_impl()
   end

   private parse_address_list_impl(can_be_empty)
      local l
      l := []

      if \can_be_empty then {
         next_token() | fail
         if pos(0) then
            return l
      }

      repeat {
         put(l, parse_mailbox_or_group()) | fail
         next_token() | fail
         ="," | return l
      }
   end

   private parse_mailbox_list_impl(can_be_empty)
      local l
      l := []

      if \can_be_empty then {
         next_token() | fail
         if pos(0) then
            return l
      }

      repeat {
         put(l, parse_mailbox_impl()) | fail
         next_token() | fail
         ="," | return l
      }
   end

   #
   # month =  "Jan"  /  "Feb" /  "Mar"  /  "Apr" /  "May"  /  "Jun" /  
   #         "Jul"  /  "Aug" /  "Sep"  /  "Oct" /  "Nov"  /  "Dec"
   #
   private parse_month()
      local i
      next_token() | fail
      every i := 1 to *MONTHS do
         if =MONTHS[i] then
            return i
   end

   private parse_day()
      local s
      next_token() | fail
      s := tab(many(&digits)) | return error("digit expected")
      if *s <= 2 then
         return integer(s)
      return error("invalid day: " || s)
   end

   private parse_year()
      local s
      next_token() | fail
      s := tab(many(&digits)) | return error("digit expected")
      if *s = (2 | 4) then
         return integer(s)
      return error("invalid year: " || s)
   end

   private parse_2dig()
      local s
      next_token() | fail
      s := tab(many(&digits)) | return error("digit expected")
      if *s = 2 then
         return integer(s)
      return error("2 digit field expected")
   end

   private parse_zone()
      next_token() | fail
      tab(upto(TZ_CHARS)) | return error("Expected tz char")
      return tab(many(TZ_CHARS)) | return error("Expected tz char")
   end

   #
   # date-time = [ day "," ] date time
   # day =  "Mon"  / "Tue" /  "Wed"  / "Thu"/  "Fri"  / "Sat" /  "Sun"
   # date =  1*2DIGIT month 2DIGIT        
   # time =  hour zone                    
   # hour =  2DIGIT ":" 2DIGIT [":" 2DIGIT]
   #
   private parse_date_time_impl()
      local d, m, y, s, t, hh, mm, ss, zz

      t := Time()

      next_token() | fail
      if =(!DAYS) then {
         next_token() | fail
         ="," | return error(", expected")
      }
      d := parse_day() | fail
      m := parse_month() | fail
      y := parse_year() | fail

      hh := parse_2dig() | fail
      next_token() | fail
      =":" | return error(": expected")
      mm := parse_2dig() | fail
      next_token() | fail
      if any(':') then {
         move(1)
         ss := parse_2dig() | fail
      } else
         ss := 0

      s := parse_zone() | fail
      zz := Timezone.get_known_timezone(s) | Timezone(0, s)

      t.set_fields(y, m, d, hh, mm, ss, zz)

      return t
   end

   #
   # field           =    field-name ":" [field-body] CRLF
   # field-name      =  1*<any CHAR, excluding CTLs, SPACE, and ":">
   # field-body      =   *text [CRLF LWSP-char field-body]
   #
   private parse_field_impl(message)
      local f, v
      next_token() | fail
      f := tab(many(FIELD_NAME_CHARS)) | return error("Expect fieldname chars")
      next_token() | fail
      =":" | return error(": expected")
      next_token() | fail
      v := tab(0)
      message.add_header(f, v)
      return
   end

   #
   # See rfc 2045 (formerly 1521)
   #
   #  encoding := "Content-Transfer-Encoding" ":" mechanism
   #
   #  mechanism := "7bit" / "8bit" / "binary" /
   #               "quoted-printable" / "base64" /
   #               ietf-token / x-token
   #               ; These values are not case sensitive
   #
   private parse_content_transfer_encoding_impl()
      local s

      if s := tab(matchcl("7bit"|"8bit"|"binary"|"quoted-printable"|"base64")) then
         return s

      if match("X-"|"x-") then
         return parse_extension_token()

      return parse_ietf_token()
   end

   #
   #  type := discrete-type / composite-type
   #  discrete-type := "text" / "image" / "audio" / "video" /
   #                   "application" / extension-token
   #
   #  composite-type := "message" / "multipart" / extension-token
   #
   #  extension-token := ietf-token / x-token
   #
   #  x-token := <The two characters "X-" or "x-" followed, with
   #              no intervening white space, by any token>
   #
   private parse_type()
      local s

      if s := tab(matchcl("application"|"audio"|"image"|"message"|"multipart"|"text"|"video")) then
         return s

      if match("X-"|"x-") then
         return parse_extension_token()

      return parse_ietf_token()
   end

   #
   # subtype := extension-token / iana-token
   #
   private parse_subtype()
      if match("X-"|"x-") then
         return parse_extension_token()

      return parse_iana_token()
   end

   #
   #  ietf-token := <An extension token defined by a
   #                 standards-track RFC and registered
   #                 with IANA.>
   #
   private parse_ietf_token()
      return parse_token_1521()
   end

   #
   #  iana-token := <A publicly-defined extension token. Tokens
   #                 of this form must be registered with IANA
   #                 as specified in RFC 2048   
   #
   private parse_iana_token()
      return parse_token_1521()
   end

   #
   # extension-token :=  x-token / iana-token
   #
   #     iana-token := <a publicly-defined extension token,
   #               registered with IANA, as specified in
   #               appendix E>
   #
   #     x-token := <The two characters "X-" or "x-" followed, with
   #                 no intervening white space, by any token>
   #
   private parse_extension_token()
      local s
      s := =("X-"|"x-") | return error("X- or x- expected")
      return s || parse_token_1521()
   end

   #
   # token  :=  1*<any (ASCII) CHAR except SPACE, CTLs,
   # or tspecials>
   #
   # tspecials :=  "(" / ")" / "<" / ">" / "@"
   #             /  "," / ";" / ":" / "\" / <">
   #             /  "/" / "[" / "]" / "?" / "="
   #            ; Must be in quoted-string,
   #            ; to use within parameter values
   #
   private parse_token_1521()
      return tab(many(ATOM_CHAR_1521)) | error("RFC1521 Token expected")
   end

   #
   #  value := token / quoted-string
   #
   private parse_value()
      if any('\"') then
         return parse_quoted_string(1)
      else
         return parse_token_1521()
   end

   #
   #  parameter := attribute "=" value
   #
   #  attribute := token
   #               ; Matching of attributes
   #               ; is ALWAYS case-insensitive.
   #
   #  On success the resulting value is placed into o.
   #
   private parse_parameter(o)
      local key, val
      key := parse_token_1521() | fail
      next_token() | fail
      ="=" | return error("= expected")
      next_token() | fail
      val := parse_value() | fail
      o.set_parameter(key, val)
      return
   end

   #
   # See rfc 2045 (formerly 1521)
   #
   #  content := "Content-Type" ":" type "/" subtype
   #             *(";" parameter)
   #             ; Matching of media type and subtype
   #             ; is ALWAYS case-insensitive.
   #
   #  attribute := token
   #               ; Matching of attributes
   #               ; is ALWAYS case-insensitive.
   #
   #  value := token / quoted-string
   #
   private parse_content_type_impl(ct)
      local ty, st

      next_token() | fail

      /ct := ContentType()

      ty := parse_type() | fail
      next_token() | fail
      ="/" | return error("/ expected")
      next_token() | fail
      st := parse_subtype() | fail
      ct.set_type(ty)
      ct.set_subtype(st)

      repeat {
         next_token() | fail
         =";" | break
         next_token() | fail
         parse_parameter(ct) | fail
      }

      return ct
   end

   #
   # disposition-type := "inline"
   #                       / "attachment"
   #                       / extension-token
   #                       ; values are not case-sensitive
   private parse_disposition_type()
      local s

      if s := tab(matchcl("inline"|"attachment"|"form-data")) then
         return s

      if match("X-"|"x-") then
         return parse_extension_token()

      return error("Unknown Content-disposition type")
   end

   #
   # See rfc 2183 (formerly 1806)
   #
   #  disposition := "Content-Disposition" ":"
   #                   disposition-type
   #                   *(";" disposition-parm)
   #
   #  disposition-type := "inline"
   #                       / "attachment"
   #                       / extension-token
   #                       ; values are not case-sensitive
   #
   #  NB - These are all parsed as 'parameter'; further parsing being done
   #  within the ContentDisposition class itself (thus they are treated the
   #  same as headers in a Message, ie stored a strings, but with get/set
   #  methods for the appropriate object types).
   #
   #  disposition-parm := filename-parm
   #                    / creation-date-parm
   #                    / modification-date-parm
   #                    / read-date-parm
   #                    / size-parm
   #                    / parameter
   #
   #  filename-parm := "filename" "=" value
   #
   #  creation-date-parm := "creation-date" "=" quoted-date-time
   #  modification-date-parm := "modification-date" "=" quoted-date-time
   #  read-date-parm := "read-date" "=" quoted-date-time
   #
   #  size-parm := "size" "=" 1*DIGIT
   #
   #  quoted-date-time := quoted-string
   #                   ; contents MUST be an RFC 822 `date-time'
   #                   ; numeric timezones (+HHMM or -HHMM) MUST be used
   #
   private parse_content_disposition_impl(cd)
      local ty

      next_token() | fail

      /cd := ContentDisposition()

      ty := parse_disposition_type() | fail
      cd.set_type(ty)

      repeat {
         next_token() | fail
         =";" | break
         next_token() | fail
         parse_parameter(cd) | fail
      }

      return cd
   end

   public parse_mailbox(s, mb)
      return s ? parse_mailbox_impl(mb)
   end

   public parse_group(s, group)
      return s ? parse_group_impl(group)
   end

   public parse_address_list(s, can_be_empty)
      return s ? parse_address_list_impl(can_be_empty)
   end

   public parse_mailbox_list(s, can_be_empty)
      return s ? parse_mailbox_list_impl(can_be_empty)
   end

   public parse_date_time(s)
      return s ? parse_date_time_impl()
   end

   public parse_field(s, message)
      return s ? parse_field_impl(message)
   end

   public parse_content_type(s, ct)
      return s ? parse_content_type_impl(ct)
   end

   public parse_content_disposition(s, ct)
      return s ? parse_content_disposition_impl(ct)
   end

   public parse_content_transfer_encoding(s)
      return s ? parse_content_transfer_encoding_impl()
   end
end
