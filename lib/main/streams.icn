package io

import
   util(error, check_flag, SetFields),
   lang(NoCopy),
   posix(System)

#
# This is the top-level stream class.  It is not instantiated
# directly.
#
class Stream()
   public static const
      # Constant indicating read capability
      READ,
      # Constant indicating write capability
      WRITE,
      # Constant indicating seek (and tell) capability
      SEEK,
      # Constant indicating truncate capability
      TRUNCATE,
      # Constant indicating read and write capability
      READ_WRITE,
      # Constant representing all capabilities (read, write, seek and
      # truncate).
      ALL

   protected
      eof_flag

   private static init()
      READ := 8r01
      WRITE := 8r02
      SEEK := 8r04
      TRUNCATE := 8r010
      READ_WRITE := READ + WRITE
      ALL := READ + WRITE + SEEK + TRUNCATE
   end

   #
   # Return at least one, and up to n characters from the stream, or
   # fail if either at end-of-file or on error.  After failure, the
   # {eof()} method can be used to check for end-of-file, and {&why} is
   # set in any case.
   #
   # @param n the maximum number of chars to read.
   #
   public defer in(n)

   #
   # Output the given string to the stream.  The number of characters
   # output is returned, which will always be greater than zero, but may
   # be less than {*s}.  Fails on an error, setting {&why}.
   #
   # @param s the string to write
   #
   public defer out(s)

   #
   # Seek to the given offset.  Icon-style offsets are used, so 1 is
   # the beginning of the stream, and 0 the end.  Not all types of stream
   # support {seek} - see {get_mode}.
   #
   # @param offset the position to seek to
   # @return the new position.
   #
   public defer seek(offset)

   #
   # Return the current position of the stream.
   #
   public defer tell()

   #
   # Truncate this stream to the given length, and set the position to the
   # new end of the stream (ie, len + 1).
   #
   public defer truncate(len)

   #
   # Return an integer indicating which functions the stream supports.
   # The possible bits which can be set are listed as constants above.
   # If the integer has the {READ} bit set, the stream is readable;
   # {WRITE} indicates the stream is writable, {SEEK} indicates that
   # it is seekable (and supports {tell} too), and {TRUNCATE} that it
   # is truncatable.
   #
   public defer get_mode()

   #
   # Close the stream.  After being closed, any further calls on the
   # stream may stop with a runtime error.
   #
   public defer close()

   #
   # After an attempt to read from the stream (by calling {in},
   # {read}, or {reads}) has failed, this method can be used to see if
   # the failure was because the stream was at the end-of-file.  Note
   # that this flag does not convey any meaningful information if the
   # read succeeded, or at any other time.
   #
   public eof()
      return \.eof_flag
   end

   #
   # Succeed iff the stream's mode has all the flags in {c}
   #
   public can(c)
      return iand(get_mode(), c) = c
   end

   #
   # Read a complete line from the stream, reading up to the next "\n"
   # or end-of-file.  In the former case, the "\n" and also any "\r"
   # immediately before it is stripped from the result.
   #
   public read()
      local s, c
      s := ""
      repeat {
         if c := in(1) then {
            if c == "\n" then {
               if s[-1] == "\r" then
                  s[-1] := ""
               return s
            } else
               s ||:= c
         } else {
            if eof() & (*s > 0) then
               return s
            else
               fail
         }
      }
   end

   #
   # Read {n} chars from the stream.  The only difference between this
   # and {in} is that this method will try and return exactly {n}
   # characters, and will only return less because of reaching the
   # end-of-file.
   #
   public reads(n)
      local s, t
      s := ""
      while n > 0 do {
         if t := in(n) then {
            s ||:= t
            n -:= *t
         } else {
            if eof() & (*s > 0) then
               return s
            else
               fail
         }
      }
      return s
   end

   #
   # This writes each parameter to the stream.  Each parameter is
   # guaranteed to be completely output, except on error, in which
   # case the method fails and sets &why.
   #
   public writes(a[])
      local e, n
      every e := !a do {
         e := string(e) | runerr(103, e)
         while *e > 0 do {
            n := out(e) | fail
            e := e[n + 1:0]
         }
      }
      return
   end

   #
   # This behaves just like {writes}, except that a newline is
   # appended after all the parameters are output.
   #
   public write(a[])
      local e, n
      every e := !a | Files.EOL do {
         e := string(e) | runerr(103, e)
         while *e > 0 do {
            n := out(e) | fail
            e := e[n + 1:0]
         }
      }
      return
   end

   #
   # Read from this stream until end-of-file, collecting the result as
   # a string.
   #
   public read_all()
      local s
      s := ""
      while s ||:= in(1048576)
      eof() | fail
      return s
   end

   #
   # Read from this stream until end-of-file, copying the result to the
   # given stream {f}.
   #
   public copy_to(f)
      local s
      while s := in(1048576) do
         f.writes(s) | fail
      eof() | fail
      return
   end
end

#
# This is a stream based on an Icon string.  An initial string can be
# provided to the constructor.  Reading from the stream will be quite
# efficient, but writing will be relatively slow, particularly if the
# string is long.  For a much faster alternative, see {RamStream}.
#
class StringStream(Stream)
   private 
      subj,
      pos

   public in(n)
      local t, e
      if pos > *subj then {
         eof_flag := 1
         return error("End of file")
      }
      e := min(pos + n, *subj + 1)
      t := subj[pos:e]
      pos := e
      return t
   end

   public out(s)
      local e
      s := string(s) | runerr(103, s)
      if pos > *subj then {
         subj ||:= repl("\0", pos - *subj - 1) || s
         pos := *subj + 1
      } else {
         e := min(pos + *s, *subj + 1)
         subj[pos:e] := s
         pos +:= *s
      }
      return *s
   end

   public seek(offset)
      return if offset > 0 then
         pos := offset
      else if -offset <= *subj then
         pos := *subj + 1 + offset
      else
         error("Seek out of range")
   end

   public tell()
      return pos
   end

   public close()
      return
   end

   public get_mode()
      return ALL
   end

   public truncate(len)
      if len > *subj then
         subj ||:= repl("\0", len - *subj)
      else
         subj := subj[1:len + 1]
      pos := *subj + 1
      return
   end

   public str()
      return .subj
   end

   #
   # Create a new {StringStream}, with initial value of {subj}.
   #
   # @param subj the initial value of the stream; defaults to empty 
   # @      string.
   #
   public new(subj)
      /subj := ""
      self.subj := string(subj) | runerr(103, subj)
      self.pos := 1
      return
   end
end

#
# This is a stream that mimics /dev/null.  Writes always succeed with
# no effect, and reads always fail with end of file.
#
class NullStream(Stream)
   public in(n)
      eof_flag := 1
      return error("End of file")
   end

   public out(s)
      s := string(s) | runerr(103, s)
      return *s
   end

   public seek(offset)
      return 1
   end

   public tell()
      return 1
   end

   public close()
      return
   end

   public get_mode()
      return ALL
   end

   public truncate(len)
      return
   end
end

#
# This is a stream that mimics /dev/zero.  Writes always succeed with
# no effect, and reads return however many zero bytes were requested.
#
class ZeroStream(Stream)
   public in(n)
      return repl("\0", n)
   end

   public out(s)
      s := string(s) | runerr(103, s)
      return *s
   end

   public seek(offset)
      return 1
   end

   public tell()
      return 1
   end

   public close()
      return
   end

   public get_mode()
      return ALL
   end

   public truncate(len)
      return
   end
end

#
# This class takes another stream and provides read/write buffers so
# that input/output to the inner stream tends to take place in larger
# chunks.
#
# @field buff_size=integer : see {set_buff_size}
# @field flush_on_nl=flag : see {set_flush_on_nl}
#
class BufferStream(Stream, SetFields)
   private
      other,
      rpos,
      wbuff,
      wbuff_len,
      rbuff,
      flush_on_nl_flag,
      buff_size

   #
   # If set, the stream is flushed whenever a newline is written.
   #
   public set_flush_on_nl(s)
      self.flush_on_nl_flag := check_flag(s)
   end

   #
   # Set the buffer size to use.
   #
   public set_buff_size(n)
      self.buff_size := n
   end

   public read()
      local t
      eof_flag := &null
      flush() | fail
      repeat {
         rbuff ? {
            if t := tab(upto('\n')) then {
               t ||:= move(1)
               rbuff := tab(0)
               \rpos +:= *t
               break
            }
         }
         if *rbuff = 0 & other.can(SEEK) then
            rpos := other.tell() | fail
         rbuff ||:= other.in(buff_size) | {
            other.eof() | fail
            t := rbuff
            rbuff := ""
            rpos := &null
            break
         }
      }
      if *t = 0 then {
         # other.in should've set &why
         eof_flag := 1
         fail
      }
      if t[-1] == "\n" then {
         t[-1] := ""
         if t[-1] == "\r" then
            t[-1] := ""
      }
      return t
   end

   public in(n)
      local t
      eof_flag := &null
      flush() | fail
      if *rbuff > 0 then {
         rbuff ? {
            t := move(n) | tab(0)
            rbuff := tab(0)
            \rpos +:= *t
         }
      } else if n < buff_size then {
         if other.can(SEEK) then
            rpos := other.tell() | fail
         rbuff := other.in(buff_size) | {
            if other.eof() then
               eof_flag := 1
            fail
         }
         rbuff ? {
            t := move(n) | tab(0)
            rbuff := tab(0)
            \rpos +:= *t
         }
      } else {
         t := other.in(n) | {
            if other.eof() then
               eof_flag := 1
            fail
         }
      }
      return t
   end

   public out(s)
      s := string(s) | runerr(103, s)
      unbuff() | fail
      put(wbuff, s)
      wbuff_len +:= *s
      if wbuff_len > buff_size | (\flush_on_nl_flag & upto('\n', s)) then
         flush() | fail
      return *s
   end

   #
   # Flush the write buffer.
   #
   public flush()
      local n, s
      if *wbuff = 0 then
         return
      s := ""
      every s ||:= !wbuff
      wbuff := []
      wbuff_len := 0
      while *s > 0 do {
         n := other.out(s) | fail
         s := s[n + 1:0]
      }
      return
   end

   #
   # Un-buffer the read buffer.  For a seekable stream this involves
   # discarding the read buffer and seeking to the position
   # corresponding to the start of the buffer.  For a non-seekable
   # stream, this call has no effect.
   #
   public unbuff()
      if *rbuff > 0 & \rpos & other.can(SEEK) then {
         other.seek(rpos) | fail
         rbuff := ""
         rpos := &null
      }
      return
   end

   #
   # Calls {unbuff} and {flush}
   #
   public synch()
      unbuff() | fail
      flush() | fail
      return
   end

   public close()
      local f
      flush() | (f := 1)
      other.close() | (f := 1)
      return /f
   end

   public seek(offset)
      synch() | fail
      return other.seek(offset)
   end

   public tell()
      synch() | fail
      return other.tell()
   end

   public truncate(len)
      synch() | fail
      return other.truncate(len)
   end

   public get_mode()
      return other.get_mode()
   end

   protected set_one(f)
      case f.attr of {
         "buff_size" : set_buff_size(f.int_val())
         "flush_on_nl" : set_flush_on_nl(f.flag_val())
         default: fail
      }
      return
   end

   public new(other, a[])
      self.other := other
      self.rbuff := ""
      self.wbuff := []
      self.wbuff_len := 0
      self.buff_size := 1024
      set_fields(a)
      return
   end
end

#
# This is the parent class of streams based on a posix-style
# integer-based file descriptor.
#
class DescStream(Stream, NoCopy)
   protected 
      fd,
      mode

   #
   # Return the integer file descriptor.
   #
   public get_fd()
      return .fd
   end

   public get_mode()
      return .mode
   end

   #
   # Performs a select on the given lists of streams, each of which
   # must be a {DescStream}.  The lists are changed by the method,
   # and the modified lists indicate which streams are ready to read,
   # write or have an error.
   # 
   # On an error this method fails and sets {&why}.  On a timeout it
   # returns 0, with all lists empty.
   #
   # @param rl the read list of streams
   # @param wl the write list of streams
   # @param el the error list of streams
   # @param timeout the timeout; if omitted waits indefinitely
   # @return the number of items in the three lists, always >= 0.
   #
   public static defer select(rl, wl, el, timeout)

   #
   # Performs a poll on one or more streams, each of which must be a
   # {DescStream}.  The parameter {l} is a list of pairs.  Each pair
   # is a {Stream} followed by flags, which should be selected from
   # those constants in the {Poll} class.  The last argument is the
   # optional timeout. The result is a list of the flags corresponding
   # to each {Stream} provided.  This method fails on error, setting
   # {&why} accordingly.  On a timeout, it succeeds and returns
   # {&null}.
   #
   public static defer poll(l, timeout)

   #
   # Turn the specified flags on or off, and return the new set of
   # flags.  The flags should be selected from the constants in
   # {FileOpt}.
   # @param on the flags to turn on
   # @param off the flags to turn off
   # @return the new flags
   #
   public defer flag(on, off)

   #
   # Turn the specified descriptor flags on or off, and return the new
   # set of flags.  The flags should be selected from the constants in
   # {FileDescOpt}.
   # @param on the flags to turn on
   # @param off the flags to turn off
   # @return the new flags
   #
   public defer dflag(on, off)

   #
   # Invokes the system function dup2(oldfd, newfd), with oldfd set to
   # this instance's {fd}, and newfd set to the given parameter's {fd}.
   #
   # On error this method fails and sets {&why}.  On success, it sets
   # the mode of the target to this instances's mode (since they both
   # now point to the same file), and returns {&null}.
   #
   # @param other - a {DescStream}
   # @example
   # @ f := FileStream.open("/tmp/xyz", 
   # @     ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT)) | stop(&why)
   # @ f.dup2(FileStream.stdout) | stop(&why)
   # @ f.close()
   # @ write("hello world")  # writes to /tmp/xyz
   #
   public dup2(other)
      dup2_impl(other) | fail
      other.mode := self.mode
      return
   end

   private defer dup2_impl()

   #
   # Return a {Stat} object with info about this file.
   #
   public stat()
      return Stat!stat_impl()
   end

   private defer stat_impl()

   #
   # Write selected attributes about a file.  If any of the parameters
   # are {&null}, they are left unchanged.
   #
   # @param mode the mode (an integer)
   # @param uid the owner name
   # @param gid the group name
   #
   public defer wstat(mode, uid, gid)

   protected new(fd, mode)
      self.fd := fd
      self.mode := mode
      return
   end
end

#
# This procedure emulates the old Icon builtin function of the same
# name.  It always returns a {BufferStream} or fails and sets {&why}.
# 
# @param name The file name
# @param mode The mode; possible values are :-
# @    "r" - {FileStream.open} with {FileOpt.RDONLY}
# @    "w" - {FileStream.open} with {FileOpt.WRONLY}, {FileOpt.TRUNC}, {FileOpt.CREAT}
# @    "b"|"rw"|"r+" - {FileStream.open} with {FileOpt.RDWR}
# @    "crw"|"w+" - {FileStream.open} with {FileOpt.RDWR}, {FileOpt.TRUNC}, {FileOpt.CREAT}
# @    "a" - {FileStream.open} with {FileOpt.WRONLY}, {FileOpt.APPEND}, {FileOpt.CREAT}
# @    "a+" - {FileStream.open} with {FileOpt.RDWR}, {FileOpt.APPEND}, {FileOpt.CREAT}
# @    "p"|"pr" - {ProgInputStream}, using shell interpreter
# @    "pw" - {ProgOutputStream}, using shell interpreter
#
procedure open(name, mode)
   return BufferStream(case mode of {
      &null | "r" : FileStream.open(name, FileOpt.RDONLY)
      "w" : FileStream.open(name, ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT))
      "b"|"rw"|"r+" : FileStream.open(name, FileOpt.RDWR)
      "crw"|"w+" : FileStream.open(name, ior(FileOpt.RDWR, FileOpt.TRUNC, FileOpt.CREAT))
      "a" : FileStream.open(name, ior(FileOpt.WRONLY, FileOpt.APPEND, FileOpt.CREAT))
      "a+" : FileStream.open(name, ior(FileOpt.RDWR, FileOpt.APPEND, FileOpt.CREAT))
$ifdef _UNIX
      "p"|"pr" : ProgInputStream("/bin/sh", ["-c", name])
      "pw" : ProgOutputStream("/bin/sh", ["-c", name])
$else
      "p"|"pr"|"pw" : error("Mode not supported")
$endif
      default: runerr("Invalid mode flag: " || mode)
   })
end

#
# Convenient method to call {write} with standard error as output.
#
procedure ewrite(a[])
   return write!push(a, FileStream.stderr)
end

#
# Convenient method to call {writes} with standard error as output.
#
procedure ewrites(a[])
   return writes!push(a, FileStream.stderr)
end

#
# This procedure emulates the old Icon builtin {write} function.
#
procedure write(a[])
   local e, f, r, n
   r := a[-1]
   if is(a[1], Stream) then
      f := pop(a)
   else
      f := FileStream.stdout
   every e := \!a | Files.EOL do {
      if is(e, Stream) then {
         f.out(Files.EOL) | fail
         f := e
      } else {
         e := string(e) | runerr(103, e)
         while *e > 0 do {
            n := f.out(e) | fail
            e := e[n + 1:0]
         }
      }
   }
   return r
end

#
# This procedure emulates the old Icon builtin {writes} function.
#
procedure writes(a[])
   local e, f, r, n
   r := a[-1]
   if is(a[1], Stream) then
      f := pop(a)
   else
      f := FileStream.stdout
   every e := \!a do {
      if is(e, Stream) then {
         f := e
      } else {
         e := string(e) | runerr(103, e)
         while *e > 0 do {
            n := f.out(e) | fail
            e := e[n + 1:0]
         }
      }
   }
   return r
end

#
# This procedure emulates the old Icon builtin {stop} function.
#
procedure stop(a[])
   write!push(a, FileStream.stderr)
   exit(1)
end

#
# This procedure emulates the old Icon builtin {read} function.
#
procedure read(f)
   /f := FileStream.stdin
   return f.read()
end

#
# This procedure emulates the old Icon builtin {reads} function.
#
procedure reads(f, n)
   /f := FileStream.stdin
   /n := 1
   return f.reads(n)
end

#
# This procedure emulates the old Icon builtin {close} function.
#
procedure close(f)
   f.close() | fail
   return f
end

#
# This procedure is used to automatically close a {Stream} or other
# resource.  The first expression {e1} produces the resource, the
# second {e2} uses it, and the third expression {e3} then closes it.
# The result of {e2} is returned, if all three expressions succeed,
# otherwise the procedure fails.
#
# {e3} is optional and defaults to calling {close} on the resource.
#
# @example
# @   s := use { f := open("some.txt"),
# @              do_something_with(f) }
procedure use(e1, e2, e3)
   local f, r
   f := @e1 | fail
   /e3 := create f.close()
   r := @e2 | {
      @e3
      fail
   }
   @e3 | fail
   return r
end

#
# This class represents a stream based on a local file.
#
class FileStream(DescStream)
   public static const
      # A {FileStream} representing standard input
      stdin, 
      # A {FileStream} representing standard output
      stdout,
      # A {FileStream} representing standard error
      stderr

   #
   # Open a new {FileStream} using the underlying system open
   # function.
   # @param name the file name
   # @param flags the flags, selected from {FileOpt}
   # @param perm the create permissions to use if a file is
   # @      created, selected from {Mode}.
   # @param mode the resulting {Stream}'s mode; if omitted
   # @      this is deduced from {flags} parameter and the
   # @      type of file being opened.
   #
   public static open(name, flags, perm, mode)
      if \mode then
         return FileStream(open_impl(name, flags, perm), mode)

      #
      # Set the READ/WRITE mode flags based on the FileOpt flags.
      #
      if iand(flags, FileOpt.WRONLY) ~= 0 then
         mode := WRITE
      else if iand(flags, FileOpt.RDWR) ~= 0 then
         mode := READ_WRITE
      else
         mode := READ

      return create_and_set_mode(open_impl(name, flags, perm), mode)
   end

   #
   # Create a new FileStream instance, and then adjust its mode based
   # on the file type returned by stat().  If it is a regular file,
   # add SEEK capability, and TRUNCATE too for a writable file.
   #
   private static create_and_set_mode(fd, mode)
      local f
      f := FileStream(fd, mode)
      if f.stat().mode_str[1] == "-" then {
         if f.can(WRITE) then
            f.mode := ior(f.mode, TRUNCATE)
         f.mode := ior(f.mode, SEEK)
      }
      return f
   end

   private static defer open_impl(path, flags, perm)

   private static init()
      stdin := create_and_set_mode(0, READ)
      stdout := create_and_set_mode(1, WRITE)
      stderr := create_and_set_mode(2, WRITE)
   end

   #
   # Create a pair of {FileStream}s using the pipe system call.
   #
   public static pipe()
      local t
      t := pipe_impl() | fail
      return [FileStream(t[1], READ), FileStream(t[2], WRITE)]
   end

   private static defer pipe_impl()

   #
   # Return a {FileStream} which, when read, will produce the given string.
   #
   public static from_string(s)
      local l, pid
      l := pipe() | fail
      pid := System.fork() | {
         l[1].close()
         l[2].close()
         fail
      }
      if pid > 0 then {
         # Parent
         l[2].close()
         return l[1]
      } else {
         # Child
         l[1].close()
         l[2].writes(s)
         l[2].close()
         exit(0)
      }
   end

   public defer in(n)

   public defer out(s)

   public defer seek(offset)

   public defer tell()

   public defer truncate(len)

   public defer chdir()

   public defer close()
end

#
# This class represents a stream based on a socket.
#
class SocketStream(DescStream)
   #
   # Create a socket with the given domain and type.
   #
   # @param domain from {ProtocolFormat}.  The default is
   # @    {ProtocolFormat.INET} 
   # @param typ the type from {SocketType}.  The default is
   # @    {SocketType.STREAM}.
   #
   public static socket(domain, typ)
      return SocketStream(socket_impl(domain, typ), READ_WRITE)
   end

   #
   # Create a pair of sockets of the given type
   #
   # @param typ the type from {SocketType}.  The default is
   # {SocketType.STREAM}.
   #
   public static socketpair(typ)
      local t
      t := socketpair_impl(typ) | fail
      return [SocketStream(t[1], READ_WRITE), SocketStream(t[2], READ_WRITE)]
   end

   public defer in(n)

   #
   # Connect a socket previously created with {Socket} to the given
   # address.  The address is a string in the form "unix:<filename>"
   # for an {AF_UNIX} address, or "inet:<host>:<port>" for an
   # {AF_INET} address.  The host can be "INADDR_ANY" if desired.
   #
   public defer connect(addr)

   #
   # Bind a socket to the given address, which is in the same form as
   # for {connect}.
   #
   public defer bind(addr)

   #
   # Listen for connections with the given backlog.
   #
   public defer listen(backlog)

   #
   # Accept a new connection, returning a new {SocketStream}.
   #
   public accept()
      return SocketStream(accept_impl(), READ_WRITE)
   end

   private defer accept_impl()

   public defer out(s)

   public defer close()

   private static defer socketpair_impl(typ)

   private static defer socket_impl(domain, typ)
end

#
# This class is used to read directory contents.
#
class DirStream(Stream, NoCopy)
   private 
      dd,
      line

   public read()
      local t
      if *line > 0 then {
         t := line[1:-1]
         line := ""
         return t
      }
      return read_impl()
   end

   public in(n)
      local t
      if (*line > 0) | (line := read_impl() || Files.EOL) then {
         line ? {
            t := move(n) | tab(0)
            line := tab(0)
         }
         return t
      }
   end

   private defer read_impl()

   public defer close()

   public get_mode()
      return READ
   end

   private static defer new_impl(path)

   public new(path)
      self.dd := new_impl(path) | fail
      self.line := ""
      return
   end
end

#
# Common superclass of {Stream}s which use a background process.
#
class BgProc()
   protected
      pid,
      exit_info

   protected do_wait()
      exit_info := System.wait(pid)
   end

   #
   # Return {ExitInfo} of the child process
   #
   public get_exit_info()
      return .\exit_info
   end

   #
   # Return process id of the child process
   #
   public get_pid()
      return .pid
   end
end


#
# This stream represents a pipe to a command running in a forked child
# process.
#
class ProgInputStream(FileStream, BgProc)
   #
   # Close the stream.  This waits for the child process to terminate.
   #
   public close()
      cast(self,FileStream).close()
      do_wait()
      return
   end

   # Open a new readable {Stream} based on the given command.  The
   # first three parameters are the same as for the method
   # {posix.System.exec};  the last two optionally give the standard
   # input and standard error of the command; by default the command
   # inherits these from the parent.  If the stderr param is the string
   # "pipe", then stderr is sent to the pipe along with stdout.
   # @example
   # @   g := FileStream.open("/tmp/data",FileOpt.RDONLY) | stop(&why)
   # @   f := ProgInputStream("wc", ["-l"],,g) | stop(&why)
   # @   g.close()
   # @   while write(f.read())   # writes the number of lines in /tmp/data
   # @   f.close()
   #
   public new(cmd, args, env, stdin, stderr)
      local l
      l := pipe() | fail
      pid := System.fork() | {
         l[1].close()
         l[2].close()
         fail
      }
      if pid > 0 then {
         # Parent
         l[2].close()
         return cast(self,FileStream).new(l[1].get_fd(), READ)
      } else {
         # Child
         if \stdin then
            stdin.dup2(FileStream.stdin) | stop(&why)
         if \stderr then {
            if stderr === "pipe" then
               l[2].dup2(FileStream.stderr) | stop(&why)
            else
               stderr.dup2(FileStream.stderr) | stop(&why)
         }
         l[2].dup2(FileStream.stdout) | stop(&why)
         l[1].close()
         l[2].close()
         System.exec(cmd, args, env) | stop(&why)
         syserr("Not reached")
      }
   end
end

#
# This stream represents a pipe from a command running in a forked child
# process.
#
class ProgOutputStream(FileStream, BgProc)
   #
   # Close the stream.  This waits for the child process to terminate.
   #
   public close()
      cast(self,FileStream).close()
      do_wait()
      return
   end

   # Open a new writeable {Stream} based on the given command. The
   # first three parameters are the same as for the method
   # {posix.System.exec}; the last two optionally give the standard
   # output and standard error of the command; by default the command
   # inherits these from the parent.
   # @example
   # @    g := FileStream.open("/tmp/result",ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT)) | stop(&why)
   # @    f := ProgOutputStream("wc", ["-l"],,g) | stop(&why)
   # @    g.close()
   # @    f.write("data")
   # @    f.close()
   # @    # Now /tmp/result contains "1" (ie, the output of wc -l applied to the data written to f)
   #
   public new(cmd, args, env, stdout, stderr)
      local l
      l := pipe() | fail
      (l[2].dflag(FileDescOpt.CLOEXEC) &
       pid := System.fork()) | {
          l[1].close()
          l[2].close()
          fail
       }
      if pid > 0 then {
         # Parent
         l[1].close()
         return cast(self,FileStream).new(l[2].get_fd(), WRITE)
      } else {
         if \stdout then
            stdout.dup2(FileStream.stdout) | stop(&why)
         if \stderr then
            stderr.dup2(FileStream.stderr) | stop(&why)
         l[1].dup2(FileStream.stdin) | stop(&why)
         l[1].close()
         l[2].close()
         System.exec(cmd, args, env) | stop(&why)
         syserr("Not reached")
      }
   end
end

#
# This stream filters output written to it through a background
# process and outputs the results to an arbitrary sink {Stream}.
#
# @example
# @ # Encode s, putting the result in a RamStream
# @ r := RamStream()
# @ g := FilterOutputStream(r, "gzip", ["-c"])
# @ g.write(s)
#
class FilterOutputStream(Stream, BgProc)
   private 
      sink,
      cin,
      cout,
      buff
   
   public out(s)
      local x, t
      s := string(s) | runerr(103, s)
      repeat {
         x := DescStream.poll([cin, Poll.IN, cout, Poll.OUT]) | fail
         if iand(x[1], icom(Poll.HUP)) = Poll.IN then {
            buff ||:= cin.in(1048576) | fail
            t := sink.out(buff) | fail
            buff := buff[t + 1:0]
         } else if x[2] = Poll.OUT then
            return cout.out(s)
         else
            return error("filter: child command i/o failed")
      }
   end

   #
   # Close the stream.  This waits for the child process to terminate, flushing any remaining
   # output to {sink}.  NB: {sink} is not closed.
   #
   public close()
      local f
      cout.close()
      sink.writes(buff) | (f := 1)
      if /f then {
         cin.flag(,FileOpt.NONBLOCK)
         cin.copy_to(sink) | (f := 1)
      }
      cin.close()
      do_wait()
      return /f
   end

   public get_mode()
      return WRITE
   end

   #
   # Create a new instance.
   #
   # @param sink the {Stream} to which data is output from the command                                    
   # @param cmd the name of the command                                    
   # @param args the arg list                                              
   # @param env the env list                                               
   # @param stderr optional standard error of the command; if "pipe" then
   # @      stderr is sent to the same pipe as stdout.
   public new(sink, cmd, args, env, stderr)
      local l
      self.sink := sink
      self.buff := ""
      l := SocketStream.socketpair() | fail
      (l |||:= SocketStream.socketpair() &
       l[1].flag(FileOpt.NONBLOCK) & 
       l[4].dflag(FileDescOpt.CLOEXEC) &
       l[4].flag(FileOpt.NONBLOCK) & 
       pid := System.fork()) | {
          every (!l).close()
          fail
       }
      if pid > 0 then {
         # Parent
         cin := l[1]
         cout := l[4]
         l[2].close()
         l[3].close()
         return
      } else {
         # Child
         if \stderr then {
            if stderr === "pipe" then
               l[2].dup2(FileStream.stderr) | stop(&why)
            else {
               stderr.dup2(FileStream.stderr) | stop(&why)
               stderr.close()
            }
         }
         l[2].dup2(FileStream.stdout) | stop(&why)
         l[3].dup2(FileStream.stdin) | stop(&why)
         every (!l).close()
         System.exec(cmd, args, env) | stop(&why)
         syserr("Not reached")
      }
   end
end

#
# This stream filters data taken from an arbitrary source {Stream}
# through a background process.  The output from that process can then
# be read as this {Stream}'s output.
#
# @example
# @ g := FilterInputStream(StringStream(s), "gzip", ["-c"])
# @ # Reading from g will give the compressed value of the string s.
# @ res := g.read_all()
#
class FilterInputStream(Stream, BgProc)
   private 
      source,
      cin,
      cout,
      buff

   public in(n)
      local x, t
      if /cout then
         return read_cin(n)
      repeat {
         x := DescStream.poll([cin, Poll.IN, cout, Poll.OUT]) | fail
         if iand(x[1], icom(Poll.HUP)) = Poll.IN then
            return read_cin(n)
         else if x[2] = Poll.OUT then {
            if *buff = 0 then {
               buff := source.in(1048576) | {
                  source.eof() | fail
                  cout.close()
                  cout := &null
                  cin.flag(,FileOpt.NONBLOCK) | fail
                  return read_cin(n)
               }
            }
            t := cout.out(buff) | fail
            buff := buff[t + 1:0]
         } else
            return error("filter: child command i/o failed")
      }
   end

   private read_cin(n)
      local s
      if s := cin.in(n) then
         return s
      if cin.eof() then
         eof_flag := 1
   end

   #
   # Close the stream.  This waits for the child process to terminate.
   # NB: {source} is not closed.
   #
   public close()
      (\cout).close()
      cin.close()
      do_wait()
      return
   end

   public get_mode()
      return READ
   end
   
   #
   # Create a new instance.
   #
   # @param source the {Stream} from which data is given to the command                                    
   # @param cmd the name of the command                                    
   # @param args the arg list                                              
   # @param env the env list                                               
   # @param stderr optional standard error of the command; if "pipe" then
   # @      stderr is sent to the same pipe as stdout.
   public new(source, cmd, args, env, stderr)
      local l
      self.source := source
      self.buff := ""
      l := SocketStream.socketpair() | fail
      (l |||:= SocketStream.socketpair() &
       l[1].flag(FileOpt.NONBLOCK) & 
       l[4].dflag(FileDescOpt.CLOEXEC) &
       l[4].flag(FileOpt.NONBLOCK) & 
       pid := System.fork()) | {
          every (!l).close()
          fail
       }
      if pid > 0 then {
         # Parent
         cin := l[1]
         cout := l[4]
         l[2].close()
         l[3].close()
         return
      } else {
         # Child
         if \stderr then {
            if stderr === "pipe" then
               l[2].dup2(FileStream.stderr) | stop(&why)
            else {
               stderr.dup2(FileStream.stderr) | stop(&why)
               stderr.close()
            }
         }
         l[2].dup2(FileStream.stdout) | stop(&why)
         l[3].dup2(FileStream.stdin) | stop(&why)
         every (!l).close()
         System.exec(cmd, args, env) | stop(&why)
         syserr("Not reached")
      }
   end
end

#
# This class provides a {Stream} which stores its data in memory.  It
# can be used to efficiently concatenate together many strings, or as
# a convenient temporary stream.
#
class RamStream(Stream, NoCopy)
   private
      ptr

   public defer in(n)

   public defer out(s)

   public defer seek(offset)

   public defer tell()

   public defer truncate(len)

   #
   # Return the current content of the {RamStream} as a string.
   #
   public defer str()

   public defer close()

   #
   # Close the stream and return the finished content as a string.
   #
   public done()
      local s
      s := str()
      close()
      return s
   end

   private static defer new_impl(s, wiggle)

   public get_mode()
      return ALL
   end

   #
   # Create a new {RamStream}, with initial value of {s}.
   #
   # @param s the initial value of the stream; defaults to empty 
   # @      string.
   # @param wiggle the extra space to reserve for growth of the buffer,
   # @      default is 512 bytes.
   #
   public new(s, wiggle)
      ptr := new_impl(s, wiggle)
      return
   end
end

#
# A very simple SSL stream, using the openssl library.
#
class SslStream(Stream, NoCopy)
   private
      ptr,
      other

   public defer in(n)

   public defer out(s)

   public defer close()

   public get_mode()
      return other.get_mode()
   end

   private static defer new_impl(other, verify_host)

   #
   # Create a new SslStream.
   #
   # @param other an already connected {SocketStream} over which the connection
   #              will operate
   # @param verify_host if set, the remote host's certificate will be verified
   #              and its hostname checked against this value.
   public new(other, verify_host)
      ptr := new_impl(other, verify_host) | fail
      self.other := other
      return
   end
end
