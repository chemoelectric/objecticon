#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

import util, lang, graphics

#
# This class represents a tree object.  A {Event.TREE_NODE_EXPANSION} event occurs when
# a node is expanded/contracted.  Also, the events generated by the parent class
# {SelectableScrollArea} are inherited.
#
class Tree(SelectableScrollArea)
   public 
      root_node,
      default_images,
      col_w,
      img_w,
      img_h,
      plus,
      minus,
      little_h,
      little_w,
      last_expanded,
      show_root_flag,
      show_root_handles_flag

   public calculate_line_height()
      local res
      res:= view.cbwin.attrib("fheight")
      #
      # Ensure the line height is slightly greater than the
      # bitmap height
      #
      res <:= \img_h + 4
      return res
   end

   public calculate_subject_width()
      local mw, n
      mw := 0
      every n := !self.contents do
         mw <:= col_w * n.depth + col_w + view.cbwin.text_width(n.label)
      return mw + 2 * Gui.TEXT_INSET
   end

   public get_node_data_width(n)
      return view.cbwin.text_width(n.label) + 2 * Gui.TEXT_INSET
   end

   public draw_node_data(n, xp, yp)
      draw_string_ex(view.cbwin, 
                   xp + Gui.TEXT_INSET,
                   yp + (self.line_height - view.cbwin.attrib("fheight")) / 2,
                   n.label)
   end

   public initially()
      # Ensure we start off with an up-to-date representation.
      tree_structure_changed()
      cast(self,Component).initially()
   end

   #
   # Set the little plus/minus images to use; they must be the same size.
   #
   public set_handle_images(i1, i2)
      self.plus := i1
      self.minus := i2
      self.little_w := image_width(i1) = image_width(i2) | fatal(self, "Image widths differ")
      self.little_h := image_height(i1) = image_height(i2) | fatal(self, "Image heights differ")
   end

   #
   # Expand all the nodes in the {Tree}.
   #
   public expand()
      if \root_node then {
         root_node.expand()
         tree_structure_changed()
      }
   end

   #
   # Set the default bitmaps for each {Node} in the {Tree}.  The parameters should be
   # three bitmaps;  see {Node} above for an explanation.
   #
   public set_default_images(i1, i2, i3)
      self.default_images := [i1, i2, i3]
   end
   
   #
   # Set the root node of the {Tree}.
   #
   public set_root_node(r)
      root_node := r
      if /r then
         set_contents([])
      else {
         root_node.is_expanded_flag := 1
         compute_img_wh()
         set_contents(flatten())
         set_selections([])
      }
      return root_node
   end

   #
   # Get the root node of the tree
   #
   public get_root_node()
      return root_node
   end

   public tree_structure_changed()
      local sels
      if /root_node then
         return
      sels := object_get_selections()
      set_contents(flatten())
      object_set_selections(sels)
   end

   #
   # Set whether root handles are shown (default yes).
   #
   public set_show_root_handles(s)
      self.show_root_handles_flag := to_flag(s)
      self.tree_structure_changed()
   end

   #
   # Set whether the root is shown (default yes).
   #
   public set_show_root(s)
      self.show_root_flag := to_flag(s)
      self.tree_structure_changed()
   end

   public compute_img_wh()
      local n, imgs
      img_w := img_h := 0

      every n := root_node.generate_all_preorder() do {
         imgs := \n.imgs | default_images
         img_w <:= image_width(imgs[1])
         img_w <:= image_width(imgs[2])
         img_w <:= image_width(imgs[3])
         img_h <:= image_height(imgs[1])
         img_h <:= image_height(imgs[2])
         img_h <:= image_height(imgs[3])
      }

      #
      # The column width is slightly wider than the bitmap width
      #
      col_w := img_w + 4
   end

   #
   # This method returns a flat list of all the {Nodes} in the tree that are
   # currently displayed.
   # @return  A list of nodes.
   #
   public flatten()
      local l, sub
      l := []
      if \self.show_root_flag then {
         if \self.show_root_handles_flag then
            flatten2(l, root_node, "n")
         else
            flatten2(l, root_node, "")
      } else {
         if \self.show_root_handles_flag then {
            if *root_node.children = 1 then {
               flatten2(l, root_node.children[1], "n")
            } else {
               flatten2(l, root_node.children[1], "d")
               every sub := root_node.children[2 to *root_node.children - 1] do 
                  flatten2(l, sub, "f")
               flatten2(l, root_node.children[-1], "u")
            }
         } else {
            every flatten2(l, !root_node.children, "")
         }
      }

      return l
   end

   public flatten2(l, n, dl)
      local sub
      n.draw_line := dl
      n.depth := *dl
      put(l, n)
      if n.is_expanded() then {
         every sub := n.children[1 to *n.children - 1] do 
            flatten2(l, sub, dl || "f")
         flatten2(l, n.children[-1], dl || "u")
      }
   end

   public handle_lpress(e)
      local l, l_off, N, curr_sel, curr_cursor, yp, xp
      if l := get_line_under_pointer(e) then {
         l_off := get_cum_line_height(l - 1) - get_area_y()
         N := self.contents[l]
         if (N.depth > 0) & (*N.children > 0) | \N.always_expandable_flag then {
            #
            # Check for click on little +/- icon.
            #
            yp := self.view.y + get_height_for_line(l) / 2 + l_off - little_h / 2
            xp := self.get_left_pos() + (N.depth - 1) * col_w + little_w / 2
            if (xp <= e.x < xp + little_w) & (yp <= e.y < yp + little_h) then {
               #
               # Clicking on the little icon ends the sequence, and sets the selection
               # to the given node.
               #
               curr_sel := *get_selections()
               curr_cursor := self.cursor
               N.toggle_expanded()
               self.last_expanded := N
               tree_structure_changed()
               parent_dialog.release(self.view, Mouse.LEFT_PRESS)
               if curr_cursor ~=== self.cursor then
                  fire(Event.CURSOR_MOVED, e)
               # Just monitor the number of selections to detect a change.
               if *get_selections() ~=  curr_sel then
                  fire(Event.SELECTION_CHANGED, e)
               fire(Event.TREE_NODE_EXPANSION, e)
               return
            }
         }
      }
      cast(self,SelectableScrollArea).handle_lpress(e)
   end

   public get_last_expanded()
      return self.last_expanded
   end

   public draw_line(xp, yp, lh, i, r, selection_cw, cursor_cw, highlight_cw)
      local N, dashed, lp, j, imgs, img, little, y0

      y0 := yp + lh / 2

      N := contents[i]
      dashed := view.cbwin.clone("pattern=gray", "fillstyle=textured")
      lp := xp
      every j := 1 to N.depth - 1 do {
         if N.draw_line[j] == ("f"|"d") then
            dashed.draw_line(lp + col_w / 2, yp, lp + col_w / 2, yp + lh - 1)
         
         lp +:= col_w
      }
      if N.depth > 0 then {
         if N.draw_line[N.depth] == "d" then
            dashed.draw_line(lp + col_w / 2, y0, lp + col_w / 2, yp + lh - 1)
         else if N.draw_line[N.depth] == "f" then
            dashed.draw_line(lp + col_w / 2, yp, lp + col_w / 2, yp + lh - 1)
         else if N.draw_line[N.depth] == "u" then
            dashed.draw_line(lp + col_w / 2, yp, lp + col_w / 2, y0)

         dashed.draw_line(lp + col_w / 2, y0, lp + col_w + col_w / 2, y0)

         lp +:= col_w
      }

      imgs := \N.imgs | default_images
      if (*N.children = 0) & /N.always_expandable_flag then
         img := imgs[3]
      else {
         if \N.is_expanded_flag then {
            img := imgs[2]
            little := minus
            if *N.children > 0 then
               dashed.draw_line(lp + col_w / 2, y0, lp + col_w / 2, yp + lh - 1)
         } else {
            img := imgs[1]
            little := plus
         }
         # Erase first as the little +/- are not opaque images, and we may have drawn a line here.
         view.cbwin.erase_area(lp - col_w / 2 - little_w / 2, y0 - little_h / 2, little_w, little_h)
         draw_image_ex(view.cbwin, lp - col_w / 2 - little_w / 2, y0 - little_h / 2, little)
      }
      draw_image_ex(view.cbwin, lp + col_w / 2 - img_w / 2, y0 - img_h / 2, \img)
      draw_node_data(N, lp + col_w, yp, lh)

      if \selection_cw then
         selection_cw.fill_rectangle(lp + col_w,
                                     yp, get_node_data_width(N), lh)

      if \cursor_cw then
         rectangle(cursor_cw, lp + col_w,
                   yp, get_node_data_width(N), lh)

      if \highlight_cw then
         rectangle(highlight_cw, lp + col_w,
                   yp, get_node_data_width(N), lh)

      dashed.uncouple()
   end

   public set_one(f)
      case f.attr of {
         "show_root" : set_show_root(f.flag_val())
         "show_root_handles" :  set_show_root_handles(f.flag_val())
         "root_node" : set_root_node(f.object_val(gui.TreeNode))
         "default_images" : set_default_images!(f.string_list_val(3))
         "handle_images" : set_handle_images!(f.string_list_val(2))
         default: return cast(self,SelectableScrollArea).set_one(f)
      }
      return
   end

   public new(a[])
      cast(self,SelectableScrollArea).new()
      set_handle_images(Icon.PLUS, Icon.MINUS)
      set_default_images(Icon.CLOSED_FOLDER, 
                         Icon.OPEN_FOLDER,
                         Icon.FILE)
      show_root_flag := show_root_handles_flag := 1
      set_fields(a)
      return
   end
end




