#
# $Id$
#

package datastruct

import ipl.pdco(Length,Index), lang, util

#
# This is a common superclass for a set-like data structure.
#
abstract class Set(HasMode, ObjectOutput, ObjectHash, ObjectEquals)
   public static const
      # An empty set instance
      EMPTY_SET,
      # Constant indicating insert capability
      INSERT,
      # Constant indicating delete capability
      DELETE,
      # Constant indicating entries are stored in order
      ORDER

   private static init()
      EMPTY_SET := EmptySet()
      INSERT := 2
      DELETE := 4
      ORDER := 8
   end

   #
   # Insert a new member.  Always succeeds and returns `self`.  Only
   # implemented with INSERT capability.
   #
   public optional insert(x)

   #
   # Succeed with `x` if it is a member of the set.
   #
   public abstract member(x)

   #
   # Delete `x` from the set.  Fails if the key was not present,
   # otherwise succeeds and returns `self`.  Only implemented with
   # DELETE capability.
   #
   public optional delete(x)

   #
   # Return a sorted list of members.
   #
   public sort()
      local l
      l := member_list()
      return if can(ORDER) then l else default.sort(member_list())
   end

   #
   # Generate the members.
   #
   public abstract gen()

   #
   # Generate the entries in reverse order.  Only implemented with
   # ORDER capability.
   #
   public optional back()

   #
   # Return the rank of the given entry, ie its order number in the
   # set; fails if there is no matching entry in the set.  Only
   # implemented for sets with ORDER capability.
   #
   public optional rank(x)

   #
   # Return the `i`th entry, in order, in the set.  Fails if `i` is
   # out of range, using standard icon indexing semantics.  Only
   # implemented for sets with ORDER capability.
   #
   public select(i)
      can(ORDER) | runerr("Set doesn't have ORDER capability", self)
      return Index{gen(), cvpos_item(i, size())}
   end

   #
   # Return the size of the set.
   #
   public size()
      return Length{gen()}
   end

   #
   # Succeed iff the size is zero.
   #
   public empty()
      succeed size() = 0
   end

   #
   # Clear the set of all elements. Always succeeds and returns
   # `self`.  Only implemented with DELETE capability.
   #
   public clear()
      while size() > 0 do
         delete(gen())
      link
   end

   #
   # Return a list of the members, in the order produced by `gen()`.
   #
   public member_list()
      return ipl.pdco.List{gen()}
   end

   #
   # Custom equals mirrors the `equals()` behaviour for builtin sets.
   #
   private override object_equals(other, seen)
      other.size() = self.size() | fail
      return hash_and_check(other.member_list(), self.member_list(), seen)
   end

   #
   # Custom hash mirrors the `hash()` behaviour for builtin sets.
   #
   private override object_hash(depth)
      local n
      n := size()
      if depth > 1 then
         every n +:= hash(gen(), depth - 1)
      return n
   end

   #
   # Output object
   #
   private override object_output(oo)
      local elements, e, sep
      elements := sort()
      if oo.simple{!elements} then {
         oo.object_start(self)
         every e := !elements do {
            if \sep then
               oo.writes1(",")
            oo.traverse(e)
            sep := &yes
         }
         oo.object_end(self)
      } else {
         oo.nl().
            object_start(self).
            iplus()
         every e := !elements do {
            if \sep then
               oo.writes1(",")
            oo.nl().
               traverse(e)
            sep := &yes
         }
         oo.iminus().
            nl().
            object_end(self)
      }
   end
end

#
# A class to provide an unmodifiable view of another set.
#
class UnmodifiableSet(Set)
   private const s

   public override member(x)
      return s.member(x)
   end

   public override sort()
      return s.sort()
   end

   public override gen()
      suspend s.gen()
   end

   public override back()
      suspend s.back()
   end

   public override rank(x)
      return s.rank(x)
   end

   public override select(i)
      return s.select(i)
   end

   public override size()
      return s.size()
   end

   public override get_mode()
      return iand(ORDER, s.get_mode())
   end

   public new(s)
      self.s := s
      return
   end
end

#
# A Set which is a view of the keys of a `Table`.
#
class TableSet(Set)
   private const t

   public override insert(x)
      t.insert(x, t.def)
      link
   end

   public override member(x)
      if t.member(x) then
         return x
   end

   public override delete(x)
      link t.delete(x)
   end

   public override sort()
      return t.key_sort()
   end

   public override gen()
      suspend t.key()
   end

   public override back()
      suspend t.back_key()
   end

   public override rank(x)
      return t.rank(x)
   end

   public override select(i)
      return t.select(i)
   end

   public override size()
      return t.size()
   end

   public override clear()
      t.clear()
      link
   end

   public override get_mode()
      return iand(INSERT + DELETE + ORDER, t.get_mode())
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `t` - either the `Table` to wrap, or a class indicating the class of
   #     a new `Table`, which will be instantiated by calling its
   #     constructor with no parameters.
   # :  `entries` - initial entries to insert.
   #
   public new(t, entries[])
      if type(t) == "class" then
         t := t()
      self.t := t
      every insert(!entries)
      return
   end
end

#
# Convenient subclass of `TableSet`, which uses an `EqTable`, to
# provide a set with membership based on `equals()`.
#
class EqSet(TableSet)
   public override new(entries[])
      push(entries, EqTable)
      TableSet.new!entries
      return
   end
end

package class EmptySet(Set, SelfClone)
   public override member(x)
   end

   public override gen()
   end

   public override size()
      return 0
   end

   public override get_mode()
      return 0
   end

   package new()
      return
   end
end

#
# A `Set` that is just a wrapper around a builtin set
#
class BuiltinSet(Set)
   private const s

   public override insert(x)
      default.insert(s, x)
      link
   end

   public override member(x)
      return default.member(s, x)
   end

   public override delete(x)
      link default.delete(s, x)
   end

   public override sort()
      return default.sort(s)
   end

   public override gen()
      suspend !s
   end

   public override size()
      return *s
   end

   public override clear()
      default.clear(s)
      link
   end

   public override get_mode()
      return INSERT + DELETE
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `s` - the set to wrap; if omitted a new set is created.
   #
   public new(s)
      /s := set()
      self.s := s
      return
   end
end

# A convenient equivalent to wrapping a BuiltinSet in an
# UnmodifiableSet.
#
class UnmodifiableBuiltinSet(Set)
   private const s

   public override member(x)
      return default.member(s, x)
   end

   public override sort()
      return default.sort(s)
   end

   public override gen()
      suspend !s
   end

   public override size()
      return *s
   end

   public override get_mode()
      return 0
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `s` - the set to wrap
   #
   public new(s)
      self.s := s
      return
   end
end
