<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>process.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: process.icn 8834 2021-01-12 14:58:37Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package util
<a name="10"/>
<a name="11"/>import lang, posix, io, ipl.printf
<a name="12"/>
<a name="13"/># This class is a convenient way of creating a sub-process in a
<a name="14"/># program.  It sets up a socket connection between the parent and
<a name="15"/># child processes to allow them to communicate in a bi-directional
<a name="16"/># fashion.
<a name="17"/>#
<a name="18"/>class Process(HasTask, HasBgProc, HasClose)
<a name="19"/>   private
<a name="20"/>      e
<a name="21"/>   private readable
<a name="22"/>      sock
<a name="23"/>
<a name="24"/>   #
<a name="25"/>   # Called by the parent process to start the child
<a name="26"/>   #
<a name="27"/>   public start()
<a name="28"/>      local l
<a name="29"/>      /pid | runerr("start() called out of sequence")
<a name="30"/>      l := SocketStream.socketpair() | fail
<a name="31"/>      unless
<a name="32"/>         l[1].dflag(DescOpt.CLOEXEC) &amp;
<a name="33"/>         l[2].dflag(DescOpt.CLOEXEC) &amp;
<a name="34"/>         pid := System.fork()
<a name="35"/>      then {
<a name="36"/>         save_why{ lclose(l) }
<a name="37"/>         fail
<a name="38"/>      }
<a name="39"/>      if pid &gt; 0 then {
<a name="40"/>         # Parent
<a name="41"/>         sock := l[2]
<a name="42"/>         l[1].close()
<a name="43"/>         e := &amp;null
<a name="44"/>         link
<a name="45"/>      } else {
<a name="46"/>         # Child
<a name="47"/>         pid := task := &amp;null
<a name="48"/>         sock := l[1]
<a name="49"/>         l[2].close()
<a name="50"/>         @e
<a name="51"/>         close_sock()
<a name="52"/>         exit(0)
<a name="53"/>      }
<a name="54"/>   end
<a name="55"/>
<a name="56"/>   #
<a name="57"/>   # Send an object to the other process.
<a name="58"/>   # 
<a name="59"/>   public send(obj)
<a name="60"/>      local s
<a name="61"/>      # The message format is &lt;len&gt;&lt;nl&gt;&lt;encoded-data&gt;; knowing the
<a name="62"/>      # length in advance lets us potentially get all the encoded data
<a name="63"/>      # in one low-level socket read, which is much faster.
<a name="64"/>      s := encode(obj, &amp;yes) | fail
<a name="65"/>      link sock.writes(*s, "\n", s)
<a name="66"/>   end
<a name="67"/>
<a name="68"/>   #
<a name="69"/>   # Receive an object from the other process.
<a name="70"/>   #
<a name="71"/>   public receive()
<a name="72"/>      local s, n
<a name="73"/>      s := sock.read() | fail
<a name="74"/>      n := integer(s) | return error("Expected integer size, got: " || s)
<a name="75"/>      s := sock.reads(n) | fail
<a name="76"/>      (*s = n) | return error("Failed to read expected number of bytes")
<a name="77"/>      return decode(s)
<a name="78"/>   end
<a name="79"/>
<a name="80"/>   #
<a name="81"/>   # Attempt to get an object from the socket, failing if one is not
<a name="82"/>   # ready immediately.
<a name="83"/>   #
<a name="84"/>   public attempt()
<a name="85"/>      return poll(0)
<a name="86"/>   end
<a name="87"/>
<a name="88"/>   #
<a name="89"/>   # Poll the socket for some available data, waiting for `t`
<a name="90"/>   # milliseconds.  If data becomes available then return it, else
<a name="91"/>   # fail.
<a name="92"/>   #
<a name="93"/>   public poll(t)
<a name="94"/>      local r
<a name="95"/>      r := do_poll(Poll.IN, t) | fail
<a name="96"/>      return if /r then
<a name="97"/>         error("Timeout")
<a name="98"/>      else if DescStream.poll_in_test(r[1]) then
<a name="99"/>         receive()
<a name="100"/>      else {
<a name="101"/>         sock.improve_why()
<a name="102"/>         whyf("Error reading from socket: %w")
<a name="103"/>      }
<a name="104"/>   end
<a name="105"/>
<a name="106"/>   #
<a name="107"/>   # Do a `poll` on the socket.
<a name="108"/>   #
<a name="109"/>   public do_poll(for, timeout)
<a name="110"/>      return choose_poll([sock, for], timeout)
<a name="111"/>   end
<a name="112"/>
<a name="113"/>   #
<a name="114"/>   # Return the socket
<a name="115"/>   #
<a name="116"/>   public get_sock()
<a name="117"/>      return .\sock
<a name="118"/>   end
<a name="119"/>
<a name="120"/>   private close_sock()
<a name="121"/>      sock.shutdown(Shut.RDWR)
<a name="122"/>      sock.close()
<a name="123"/>      sock := &amp;null
<a name="124"/>   end
<a name="125"/>
<a name="126"/>   #
<a name="127"/>   # Called by the parent.  The method waits for the child to terminate.  The
<a name="128"/>   # child process will no longer exist after this call, so it resets pid to
<a name="129"/>   # &amp;null and closes the socket.
<a name="130"/>   #
<a name="131"/>   public override close()
<a name="132"/>      do_wait()
<a name="133"/>      close_sock()
<a name="134"/>      link
<a name="135"/>   end
<a name="136"/>
<a name="137"/>   #
<a name="138"/>   # Called by the parent to kill the child.  Then the `close` method is invoked.
<a name="139"/>   #
<a name="140"/>   public stop()
<a name="141"/>      \pid | runerr("stop() called out of sequence")
<a name="142"/>      # kill should never fail (even if the child crashed).
<a name="143"/>      System.kill(pid, Signal.SIGTERM) | syserr("System.kill failed unexpectedly: " || &amp;why)
<a name="144"/>      close()
<a name="145"/>      link
<a name="146"/>   end
<a name="147"/>
<a name="148"/>   # Create a new instance, with the given co-expression as the body
<a name="149"/>   # of the child process.
<a name="150"/>   #
<a name="151"/>   public new(e)
<a name="152"/>      self.e := need_coexpression(e)
<a name="153"/>      return
<a name="154"/>   end
<a name="155"/>end
</pre></body></html>
