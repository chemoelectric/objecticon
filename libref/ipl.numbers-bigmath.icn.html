<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>bigmath.icn</title></head><body><pre>
<a name="1"/>package ipl.numbers
<a name="2"/>
<a name="3"/>import numbers, util(Math), ipl.functional
<a name="4"/>
<a name="5"/>package abstract class SeriesCalculator()
<a name="6"/>   private calculateInPairs, factors, factors_coex
<a name="7"/>
<a name="8"/>   public new(calculateInPairs)
<a name="9"/>      self.calculateInPairs := calculateInPairs
<a name="10"/>      factors := []
<a name="11"/>      factors_coex := create gen_factors()
<a name="12"/>      return
<a name="13"/>   end
<a name="14"/>
<a name="15"/>   public calculate(x, prec)
<a name="16"/>      local sum, acceptableError, powerCoex, i, factor, step, step2, xToThePower
<a name="17"/>
<a name="18"/>      powerCoex := create gen_powers(x, prec)
<a name="19"/>      sum := BigMath.ZERO
<a name="20"/>      i := 0
<a name="21"/>      repeat {
<a name="22"/>         factor := getFactor(i)
<a name="23"/>         xToThePower := @powerCoex
<a name="24"/>         step := Dec(factor.n).mul(xToThePower).div(Dec(factor.d), prec)
<a name="25"/>         i +:= 1
<a name="26"/>         if \calculateInPairs then {
<a name="27"/>            xToThePower := @powerCoex
<a name="28"/>            factor := getFactor(i)
<a name="29"/>            step2 := Dec(factor.n).mul(xToThePower).div(Dec(factor.d), prec)
<a name="30"/>            step := step.add(step2)
<a name="31"/>            i +:= 1
<a name="32"/>         }
<a name="33"/>         sum := sum.add(step, prec)
<a name="34"/>         acceptableError := BigMath.calcAcceptableError(sum, prec)
<a name="35"/>
<a name="36"/>         step.abs().cmp("&gt;", acceptableError) | break
<a name="37"/>      }
<a name="38"/>
<a name="39"/>      return sum.round(prec)
<a name="40"/>   end
<a name="41"/>
<a name="42"/>   public getFactor(index)
<a name="43"/>      local factor
<a name="44"/>      while *factors &lt;= index do {
<a name="45"/>         factor := @factors_coex
<a name="46"/>         put(factors, factor)
<a name="47"/>      }
<a name="48"/>      return factors[index + 1]
<a name="49"/>   end
<a name="50"/>
<a name="51"/>   public abstract gen_factors()
<a name="52"/>
<a name="53"/>   public abstract gen_powers(x, prec)
<a name="54"/>end
<a name="55"/>
<a name="56"/>package class SinCalculator(SeriesCalculator)
<a name="57"/>   public override new()
<a name="58"/>      SeriesCalculator.new(&amp;yes)
<a name="59"/>      return
<a name="60"/>   end
<a name="61"/>
<a name="62"/>   public override gen_factors()
<a name="63"/>      local factorial2nPlus1, factor, n
<a name="64"/>      factorial2nPlus1 := Rat(1)
<a name="65"/>      n := 0
<a name="66"/>      repeat {
<a name="67"/>         factor := factorial2nPlus1.reciprocal()
<a name="68"/>         if n % 2 = 1 then
<a name="69"/>            factor := factor.neg()
<a name="70"/>         suspend factor
<a name="71"/>         n +:= 1
<a name="72"/>         factorial2nPlus1 := factorial2nPlus1.mul(Rat((2 * n) * (2 * n + 1)))
<a name="73"/>      }
<a name="74"/>   end
<a name="75"/>
<a name="76"/>   public override gen_powers(x, prec)
<a name="77"/>      suspend PowerTwoNPlusOneIterator(x, prec)
<a name="78"/>   end
<a name="79"/>end
<a name="80"/>
<a name="81"/>package class CosCalculator(SeriesCalculator)
<a name="82"/>   public override new()
<a name="83"/>      SeriesCalculator.new(&amp;yes)
<a name="84"/>      return
<a name="85"/>   end
<a name="86"/>
<a name="87"/>   public override gen_factors()
<a name="88"/>      local factorial2n, factor, n
<a name="89"/>      factorial2n := Rat(1)
<a name="90"/>      n := 0
<a name="91"/>      repeat {
<a name="92"/>         factor := factorial2n.reciprocal()
<a name="93"/>         if n % 2 = 1 then
<a name="94"/>            factor := factor.neg()
<a name="95"/>         suspend factor
<a name="96"/>         n +:= 1
<a name="97"/>         factorial2n := factorial2n.mul(Rat((2 * n - 1) * (2 * n)))
<a name="98"/>      }
<a name="99"/>   end
<a name="100"/>
<a name="101"/>   public override gen_powers(x, prec)
<a name="102"/>      suspend PowerTwoNIterator(x, prec)
<a name="103"/>   end
<a name="104"/>end
<a name="105"/>
<a name="106"/>package class SinhCalculator(SeriesCalculator)
<a name="107"/>   public override new()
<a name="108"/>      SeriesCalculator.new(&amp;yes)
<a name="109"/>      return
<a name="110"/>   end
<a name="111"/>
<a name="112"/>   public override gen_factors()
<a name="113"/>      local factorial2nPlus1, factor, n
<a name="114"/>      factorial2nPlus1 := Rat(1)
<a name="115"/>      n := 0
<a name="116"/>      repeat {
<a name="117"/>         factor := factorial2nPlus1.reciprocal()
<a name="118"/>         suspend factor
<a name="119"/>         n +:= 1
<a name="120"/>         factorial2nPlus1 := factorial2nPlus1.mul(Rat((2 * n) * (2 * n + 1)))
<a name="121"/>      }
<a name="122"/>   end
<a name="123"/>
<a name="124"/>   public override gen_powers(x, prec)
<a name="125"/>      suspend PowerTwoNPlusOneIterator(x, prec)
<a name="126"/>   end
<a name="127"/>end
<a name="128"/>
<a name="129"/>package class CoshCalculator(SeriesCalculator)
<a name="130"/>   public override new()
<a name="131"/>      SeriesCalculator.new(&amp;yes)
<a name="132"/>      return
<a name="133"/>   end
<a name="134"/>
<a name="135"/>   public override gen_factors()
<a name="136"/>      local factorial2n, factor, n
<a name="137"/>      factorial2n := Rat(1)
<a name="138"/>      n := 0
<a name="139"/>      repeat {
<a name="140"/>         factor := factorial2n.reciprocal()
<a name="141"/>         suspend factor
<a name="142"/>         n +:= 1
<a name="143"/>         factorial2n := factorial2n.mul(Rat((2 * n - 1) * (2 * n)))
<a name="144"/>      }
<a name="145"/>   end
<a name="146"/>
<a name="147"/>   public override gen_powers(x, prec)
<a name="148"/>      suspend PowerTwoNIterator(x, prec)
<a name="149"/>   end
<a name="150"/>end
<a name="151"/>
<a name="152"/>package class ExpCalculator(SeriesCalculator)
<a name="153"/>   public override gen_factors()
<a name="154"/>      local oneOverFactorialOfN, n
<a name="155"/>      oneOverFactorialOfN := Rat(1)
<a name="156"/>      n := 0
<a name="157"/>      repeat {
<a name="158"/>         suspend oneOverFactorialOfN
<a name="159"/>         n +:= 1
<a name="160"/>         oneOverFactorialOfN := oneOverFactorialOfN.div(Rat(n));
<a name="161"/>      }
<a name="162"/>   end
<a name="163"/>
<a name="164"/>   public override gen_powers(x, prec)
<a name="165"/>      suspend PowerNIterator(x, prec)
<a name="166"/>   end
<a name="167"/>end
<a name="168"/>
<a name="169"/>package class AsinCalculator(SeriesCalculator)
<a name="170"/>   public override gen_factors()
<a name="171"/>      local factorial2n, factorialN, fourPowerN, factor, n
<a name="172"/>
<a name="173"/>      factorial2n := factorialN := fourPowerN := Rat(1)
<a name="174"/>      n := 0
<a name="175"/>      repeat {
<a name="176"/>         factor := factorial2n.div(fourPowerN.mul(factorialN).mul(factorialN).mul(Rat(2 * n + 1)))
<a name="177"/>         suspend factor
<a name="178"/>         n +:= 1
<a name="179"/>         factorial2n := factorial2n.mul(Rat((2 * n - 1) * (2 * n)))
<a name="180"/>         factorialN := factorialN.mul(Rat(n))
<a name="181"/>         fourPowerN := fourPowerN.mul(Rat(4))
<a name="182"/>      }
<a name="183"/>   end
<a name="184"/>
<a name="185"/>   public override gen_powers(x, prec)
<a name="186"/>      suspend PowerTwoNPlusOneIterator(x, prec)
<a name="187"/>   end
<a name="188"/>end
<a name="189"/>
<a name="190"/>package procedure PowerNIterator(x, prec)
<a name="191"/>   local powerOfX
<a name="192"/>   powerOfX := BigMath.ONE
<a name="193"/>   repeat {
<a name="194"/>      suspend powerOfX
<a name="195"/>      powerOfX := powerOfX.mul(x, prec)
<a name="196"/>   }
<a name="197"/>end
<a name="198"/>
<a name="199"/>package procedure PowerTwoNPlusOneIterator(x, prec)
<a name="200"/>   local xPowerTwo
<a name="201"/>   xPowerTwo := x.mul(x)
<a name="202"/>   repeat {
<a name="203"/>      x := x.round(prec)
<a name="204"/>      suspend x
<a name="205"/>      x := x.mul(xPowerTwo)
<a name="206"/>   }
<a name="207"/>end
<a name="208"/>
<a name="209"/>package procedure PowerTwoNIterator(x, prec)
<a name="210"/>   local xPowerTwo, powerOfX
<a name="211"/>   xPowerTwo := x.mul(x)
<a name="212"/>   powerOfX := BigMath.ONE
<a name="213"/>   repeat {
<a name="214"/>      suspend powerOfX
<a name="215"/>      powerOfX := powerOfX.mul(xPowerTwo, prec)
<a name="216"/>   }
<a name="217"/>end
<a name="218"/>
<a name="219"/># This class provides static methods to calculate some common
<a name="220"/># mathematical functions using the arbitrary precision `Dec` class.
<a name="221"/># They are based on Eric Oberm√ºhlner's BigDecimalMath java library.
<a name="222"/># See :-
<a name="223"/>#
<a name="224"/># &lt;http://obermuhlner.ch/wordpress/2016/06/02/bigdecimalmath/&gt;
<a name="225"/>#
<a name="226"/>final abstract class BigMath()
<a name="227"/>   public static const 
<a name="228"/>      EXPECTED_INITIAL_PRECISION,
<a name="229"/>      ROUGHLY_TWO_PI,
<a name="230"/>      TWO,
<a name="231"/>      ONE,
<a name="232"/>      ZERO
<a name="233"/>
<a name="234"/>   private static init()
<a name="235"/>      TWO := Dec(2)
<a name="236"/>      ONE := Dec(1)
<a name="237"/>      ZERO := Dec(0)
<a name="238"/>      EXPECTED_INITIAL_PRECISION := 15
<a name="239"/>      ROUGHLY_TWO_PI := TWO.mul(Dec("3.141592653589793"))
<a name="240"/>   end
<a name="241"/>
<a name="242"/>   # Return Pi to the requested precision and rounding.
<a name="243"/>   #
<a name="244"/>   # :Parameters :
<a name="245"/>   # :  `rnd` - something convertible to a `Round`.
<a name="246"/>   #
<a name="247"/>   public static pi(rnd)
<a name="248"/>      static memoized_pi
<a name="249"/>      initial memoized_pi := memoize1(piChudnovski)
<a name="250"/>      rnd := need_Round(rnd)
<a name="251"/>      return if rnd.mode == Round.HALF_UP then
<a name="252"/>         memoized_pi(rnd.digits)
<a name="253"/>      else
<a name="254"/>         memoized_pi(rnd.digits + 6).round(rnd)
<a name="255"/>   end
<a name="256"/>
<a name="257"/>   # Return `e` to the requested precision and rounding.
<a name="258"/>   #
<a name="259"/>   # :Parameters :
<a name="260"/>   # :  `rnd` - something convertible to a `Round`.
<a name="261"/>   #
<a name="262"/>   public static e(rnd)
<a name="263"/>      static memoized_e
<a name="264"/>      initial memoized_e := memoize1(lpartial(exp, ONE))
<a name="265"/>      rnd := need_Round(rnd)
<a name="266"/>      return if rnd.mode == Round.HALF_UP then
<a name="267"/>         memoized_e(rnd.digits)
<a name="268"/>      else
<a name="269"/>         memoized_e(rnd.digits + 6).round(rnd)
<a name="270"/>   end
<a name="271"/>
<a name="272"/>   # Calculates the natural exponent of `x`.
<a name="273"/>   #
<a name="274"/>   # :Parameters :
<a name="275"/>   # :  `x` - something convertible to a `Dec`.
<a name="276"/>   # :  `rnd` - something convertible to a `Round`.
<a name="277"/>   #
<a name="278"/>   public static exp(x, rnd)
<a name="279"/>      local integralPart, fractionalPart, mc, z, t, result
<a name="280"/>      x := need_Dec(x)
<a name="281"/>      rnd := need_Round(rnd)
<a name="282"/>      if x.sign() = 0 then
<a name="283"/>         result := ONE
<a name="284"/>      else {
<a name="285"/>         integralPart := integral_part(x)
<a name="286"/>
<a name="287"/>         if integralPart.sign() = 0 then
<a name="288"/>            return expTaylor(x, rnd)
<a name="289"/>
<a name="290"/>         fractionalPart := x.sub(integralPart)
<a name="291"/>         mc := rnd.digits + 10
<a name="292"/>         z := ONE.add(fractionalPart.div(integralPart, mc))
<a name="293"/>         t := expTaylor(z, mc)
<a name="294"/>
<a name="295"/>         result := powi(t, integralPart.integer(), mc)
<a name="296"/>      }
<a name="297"/>        
<a name="298"/>      return result.round(rnd)
<a name="299"/>   end
<a name="300"/>
<a name="301"/>   private static expTaylor(x, rnd)
<a name="302"/>      static ec
<a name="303"/>      local mc, result
<a name="304"/>      initial ec := ExpCalculator()
<a name="305"/>      rnd := need_Round(rnd)
<a name="306"/>      mc := rnd.digits + 6
<a name="307"/>      x := x.div(256, mc)
<a name="308"/>      result := ec.calculate(x, mc)
<a name="309"/>      result := powi(result, 256, mc)
<a name="310"/>      return result.round(rnd)
<a name="311"/>   end
<a name="312"/>
<a name="313"/>   # Calculates `x` raised to the power of `y`.
<a name="314"/>   #
<a name="315"/>   # :Parameters :
<a name="316"/>   # :  `x` - something convertible to a `Dec`.
<a name="317"/>   # :  `y` - something convertible to a `Dec`.
<a name="318"/>   # :  `rnd` - something convertible to a `Round`.
<a name="319"/>   #
<a name="320"/>   public static pow(x, y, rnd)
<a name="321"/>      local i, mc, result
<a name="322"/>      x := need_Dec(x)
<a name="323"/>      y := need_Dec(y)
<a name="324"/>      rnd := need_Round(rnd)
<a name="325"/>
<a name="326"/>      if y.sign() = 0 then       # x^0 = 1
<a name="327"/>         result := ONE
<a name="328"/>      else if y.cmp("=", ONE) then   # x^1 = x
<a name="329"/>         result := x
<a name="330"/>      else if x.sign() = 0 then {
<a name="331"/>         if y.sign() &lt; 0 then  # 0^n, n&lt;0 -&gt; error
<a name="332"/>            runerr(209)
<a name="333"/>         # y.sign() = 1;  0^n = 0, n&gt;0
<a name="334"/>         return ZERO
<a name="335"/>      } else if i := exact_integer(y) then
<a name="336"/>         return powi(x, i, rnd)
<a name="337"/>      else {
<a name="338"/>         mc := rnd.digits + 6
<a name="339"/>         result := exp(y.mul(log(x, mc)), mc)
<a name="340"/>      }
<a name="341"/>
<a name="342"/>      return result.round(rnd)
<a name="343"/>   end
<a name="344"/>
<a name="345"/>   private static powi(x, y, rnd)
<a name="346"/>      local mc, result
<a name="347"/>
<a name="348"/>      rnd := need_Round(rnd)
<a name="349"/>      mc := rnd.digits + 10
<a name="350"/>
<a name="351"/>      if y &lt; 0 then
<a name="352"/>         return ONE.div(powi(x, -y, mc), rnd)
<a name="353"/>
<a name="354"/>      result := ONE
<a name="355"/>      repeat {
<a name="356"/>         if y % 2 = 1 then {
<a name="357"/>            result := result.mul(x, mc)
<a name="358"/>            y -:= 1
<a name="359"/>         }
<a name="360"/>         if y = 0 then
<a name="361"/>            break
<a name="362"/>         x := x.mul(x, mc)
<a name="363"/>         y /:= 2
<a name="364"/>      }
<a name="365"/>
<a name="366"/>      return result.round(rnd)
<a name="367"/>   end
<a name="368"/>
<a name="369"/>   # Calculates the natural logarithm of `x`.
<a name="370"/>   #
<a name="371"/>   # :Parameters :
<a name="372"/>   # :  `x` - something convertible to a `Dec`.
<a name="373"/>   # :  `rnd` - something convertible to a `Round`.
<a name="374"/>   #
<a name="375"/>   public static log(x, rnd)
<a name="376"/>      local mc, result, exponent, mantissa
<a name="377"/>
<a name="378"/>      x := need_Dec(x)
<a name="379"/>      rnd := need_Round(rnd)
<a name="380"/>
<a name="381"/>      if x.sign() &lt;= 0 then
<a name="382"/>         runerr(205, x)
<a name="383"/>
<a name="384"/>      if x.cmp("=", ONE) then
<a name="385"/>         return ZERO
<a name="386"/>
<a name="387"/>      mc := rnd.digits * 2
<a name="388"/>
<a name="389"/>      exponent := x.precision() + x.e - 1
<a name="390"/>      mantissa := Dec(x.i, 1 - x.precision())
<a name="391"/>
<a name="392"/>      # Now mantissa*10^exponent = x, since mantissa = x.i*10^(1-x.precision()) and
<a name="393"/>      # x.i*10^(1-x.precision())*10^(x.precision() + x.e - 1) = x.i*10^x.e = x
<a name="394"/>      #
<a name="395"/>
<a name="396"/>      result := logUsingNewton(mantissa, mc)
<a name="397"/>      if exponent ~= 0 then
<a name="398"/>         result := result.add(Dec(exponent).mul(logTen(mc)))
<a name="399"/>
<a name="400"/>      return result.round(rnd)
<a name="401"/>   end
<a name="402"/>
<a name="403"/>   # Calculates the logarithm of `x` to the base 10.
<a name="404"/>   #
<a name="405"/>   # :Parameters :
<a name="406"/>   # :  `x` - something convertible to a `Dec`.
<a name="407"/>   # :  `rnd` - something convertible to a `Round`.
<a name="408"/>   #
<a name="409"/>   public static log10(x, rnd)
<a name="410"/>      local mc
<a name="411"/>      x := need_Dec(x)
<a name="412"/>      rnd := need_Round(rnd)
<a name="413"/>      mc := rnd.digits + 6
<a name="414"/>      return log(x, mc).div(logTen(mc), mc).round(rnd)
<a name="415"/>   end
<a name="416"/>
<a name="417"/>   # Return ln(10) to the given precision.
<a name="418"/>   private static logTen(prec)
<a name="419"/>      static memoized_logTen
<a name="420"/>      initial memoized_logTen := memoize1(calcLogTen)
<a name="421"/>      return memoized_logTen(prec)
<a name="422"/>   end
<a name="423"/>
<a name="424"/>   private static calcLogTen(prec)
<a name="425"/>      return logUsingNewton(Dec(10), prec).round(prec)
<a name="426"/>   end
<a name="427"/>
<a name="428"/>   private static logUsingNewton(x, prec)
<a name="429"/>      local maxPrecision, acceptableError, result, adaptivePrecision, step, expY
<a name="430"/>
<a name="431"/>      if x.cmp("=", ONE) then
<a name="432"/>         return ZERO
<a name="433"/>
<a name="434"/>      maxPrecision := prec + 20
<a name="435"/>
<a name="436"/>      result := Dec(Math.log(x.real())) | syserr("logUsingNewton, x not convertible to real")
<a name="437"/>      adaptivePrecision := EXPECTED_INITIAL_PRECISION
<a name="438"/>      acceptableError := calcAcceptableError(result, prec)
<a name="439"/>
<a name="440"/>      repeat {
<a name="441"/>         adaptivePrecision *:= 3
<a name="442"/>         adaptivePrecision &gt;:= maxPrecision
<a name="443"/>
<a name="444"/>         expY := exp(result, adaptivePrecision)
<a name="445"/>
<a name="446"/>         step := TWO.mul(x.sub(expY)).div(x.add(expY), adaptivePrecision)
<a name="447"/>         result := result.add(step, prec + 10)
<a name="448"/>
<a name="449"/>         (adaptivePrecision &lt; maxPrecision | step.abs().cmp("&gt;", acceptableError)) | break
<a name="450"/>      }
<a name="451"/>
<a name="452"/>      return result
<a name="453"/>   end
<a name="454"/>
<a name="455"/>   package static calcAcceptableError(result, mc)
<a name="456"/>      return Dec(1, -(mc + 1) + result.e + result.precision())
<a name="457"/>   end
<a name="458"/>
<a name="459"/>   # Calculates the n'th root of `x`.
<a name="460"/>   #
<a name="461"/>   # :Parameters :
<a name="462"/>   # :  `x` - something convertible to a `Dec`.
<a name="463"/>   # :  `n` - something convertible to a `Dec`.
<a name="464"/>   # :  `rnd` - something convertible to a `Round`.
<a name="465"/>   #
<a name="466"/>   public static root(x, n, rnd)
<a name="467"/>      local maxPrecision, acceptableError, result, adaptivePrecision, step, mc, hi, lo, p, d
<a name="468"/>      x := need_Dec(x)
<a name="469"/>      n := need_Dec(n)
<a name="470"/>      rnd := need_Round(rnd)
<a name="471"/>
<a name="472"/>      case x.sign() of {
<a name="473"/>         0: return ZERO
<a name="474"/>         -1: runerr(205, x)
<a name="475"/>      }
<a name="476"/>
<a name="477"/>      mc := rnd.digits + 6
<a name="478"/>
<a name="479"/>      if not(n := exact_integer(n)) | n &lt; 2 | n &gt; 50 then
<a name="480"/>         return pow(x, ONE.div(n, mc), rnd)
<a name="481"/>
<a name="482"/>      # Now n is integer type, 50 &gt;= n &gt;= 2.
<a name="483"/>
<a name="484"/>      maxPrecision := mc + 4
<a name="485"/>      if n = 2 &amp; hi := lo := Dec(Math.sqrt(x.real())) then
<a name="486"/>         adaptivePrecision := EXPECTED_INITIAL_PRECISION
<a name="487"/>      else {
<a name="488"/>         # Calculate upper and lower bounds for the result.  If
<a name="489"/>         # x=d*10^p, (0&lt;d&lt;10, p=x.precision() + x.e - 1, and
<a name="490"/>         # d=x.i*10^(1-x.precision()) - see log() above).
<a name="491"/>         # then
<a name="492"/>         # 1*10^floor(p/n) &lt; x^(1/n) &lt; d*10^ceil(p/n) = x.i*10^
<a name="493"/>         #                    (ceil(p/n) + 1-x.precision())
<a name="494"/>         #
<a name="495"/>         p := x.precision() + x.e - 1
<a name="496"/>         hi := Dec(x.i, ceil2(p, n) + 1 - x.precision())
<a name="497"/>         lo := Dec(1, floor2(p, n))
<a name="498"/>
<a name="499"/>         adaptivePrecision := 1
<a name="500"/>      }
<a name="501"/>
<a name="502"/>      # Start with the result set to hi; this ensures good newton
<a name="503"/>      # behaviour since the function gets ugly to the left of the
<a name="504"/>      # result.
<a name="505"/>      result := hi
<a name="506"/>
<a name="507"/>      # Calculate the error bound relative to lo
<a name="508"/>      acceptableError := calcAcceptableError(lo, mc + 1)
<a name="509"/>
<a name="510"/>      repeat {
<a name="511"/>         adaptivePrecision *:= 3
<a name="512"/>         adaptivePrecision &gt;:= maxPrecision
<a name="513"/>         d := if n = 2 then result else powi(result, n - 1, adaptivePrecision)
<a name="514"/>         step := x.div(d, adaptivePrecision).sub(result, adaptivePrecision).div(n, adaptivePrecision)
<a name="515"/>         result := result.add(step, mc + 6)
<a name="516"/>         (adaptivePrecision &lt; maxPrecision | step.abs().cmp("&gt;", acceptableError)) | break
<a name="517"/>      }
<a name="518"/>
<a name="519"/>      return result.round(rnd)
<a name="520"/>   end
<a name="521"/>
<a name="522"/>   private static exact_integer(x)
<a name="523"/>      return x.e &gt;= 0 &amp; x.integer()
<a name="524"/>   end
<a name="525"/>
<a name="526"/>   private static integral_part(x)
<a name="527"/>      return x.round("0dp t")
<a name="528"/>   end
<a name="529"/>
<a name="530"/>   private static fractional_part(x)
<a name="531"/>      return x.sub(integral_part(x))
<a name="532"/>   end
<a name="533"/>
<a name="534"/>   private static remainder(x, y)
<a name="535"/>      return x.sub(x.div(y,"0dp t").mul(y))
<a name="536"/>   end
<a name="537"/>
<a name="538"/>   private static mod2pi(x, prec)
<a name="539"/>      local twoPi
<a name="540"/>      if x.abs().cmp("&gt;", ROUGHLY_TWO_PI) then {
<a name="541"/>         twoPi := TWO.mul(pi(prec))
<a name="542"/>         x := remainder(x, twoPi)
<a name="543"/>      }
<a name="544"/>      return x
<a name="545"/>   end
<a name="546"/>
<a name="547"/>   # Calculates the sine (sinus) of `x`.
<a name="548"/>   #
<a name="549"/>   # :Parameters :
<a name="550"/>   # :  `x` - something convertible to a `Dec`.
<a name="551"/>   # :  `rnd` - something convertible to a `Round`.
<a name="552"/>   #
<a name="553"/>   public static sin(x, rnd)
<a name="554"/>      static sc
<a name="555"/>      local mc
<a name="556"/>      initial sc := SinCalculator()
<a name="557"/>
<a name="558"/>      x := need_Dec(x)
<a name="559"/>      rnd := need_Round(rnd)
<a name="560"/>      mc := rnd.digits + 6
<a name="561"/>      x := mod2pi(x, mc)
<a name="562"/>
<a name="563"/>      return sc.calculate(x, mc).round(rnd)
<a name="564"/>   end
<a name="565"/>
<a name="566"/>   # Calculates the cosine of `x`.
<a name="567"/>   #
<a name="568"/>   # :Parameters :
<a name="569"/>   # :  `x` - something convertible to a `Dec`.
<a name="570"/>   # :  `rnd` - something convertible to a `Round`.
<a name="571"/>   #
<a name="572"/>   public static cos(x, rnd)
<a name="573"/>      static cc
<a name="574"/>      local mc
<a name="575"/>      initial cc := CosCalculator()
<a name="576"/>
<a name="577"/>      x := need_Dec(x)
<a name="578"/>      rnd := need_Round(rnd)
<a name="579"/>      mc := rnd.digits + 6
<a name="580"/>      x := mod2pi(x, mc)
<a name="581"/>
<a name="582"/>      return cc.calculate(x, mc).round(rnd)
<a name="583"/>   end
<a name="584"/>
<a name="585"/>   # Calculates the tan of `x`.
<a name="586"/>   #
<a name="587"/>   # :Parameters :
<a name="588"/>   # :  `x` - something convertible to a `Dec`.
<a name="589"/>   # :  `rnd` - something convertible to a `Round`.
<a name="590"/>   #
<a name="591"/>   public static tan(x, rnd)
<a name="592"/>      local mc
<a name="593"/>      x := need_Dec(x)
<a name="594"/>      rnd := need_Round(rnd)
<a name="595"/>      if x.sign() = 0 then
<a name="596"/>         return ZERO
<a name="597"/>      mc := rnd.digits + 4
<a name="598"/>      return sin(x, mc).div(cos(x, mc), mc).round(rnd)
<a name="599"/>   end
<a name="600"/>
<a name="601"/>   # Calculates the arc sine (inverted sine) of `x`
<a name="602"/>   #
<a name="603"/>   # :Parameters :
<a name="604"/>   # :  `x` - something convertible to a `Dec`.
<a name="605"/>   # :  `rnd` - something convertible to a `Round`.
<a name="606"/>   #
<a name="607"/>   public static asin(x, rnd)
<a name="608"/>      static sc
<a name="609"/>      local mc, xTransformed, result
<a name="610"/>      initial sc := AsinCalculator()
<a name="611"/>
<a name="612"/>      x := need_Dec(x)
<a name="613"/>      rnd := need_Round(rnd)
<a name="614"/>      if x.abs().cmp("&gt;", ONE) then
<a name="615"/>         runerr(205, x)
<a name="616"/>
<a name="617"/>      mc := rnd.digits + 6
<a name="618"/>
<a name="619"/>      result := if x.sign() &lt; 0 then
<a name="620"/>         asin(x.neg(), mc).neg()
<a name="621"/>      else if x.cmp("&gt;=", Dec("0.707107")) then {
<a name="622"/>         xTransformed := sqrt(ONE.sub(x.mul(x)), mc)
<a name="623"/>         acos(xTransformed, mc)
<a name="624"/>      } else
<a name="625"/>         sc.calculate(x, mc)
<a name="626"/>
<a name="627"/>      return result.round(rnd)
<a name="628"/>   end
<a name="629"/>
<a name="630"/>   # Calculates the arc cosine (inverted cosine) of `x`
<a name="631"/>   #
<a name="632"/>   # :Parameters :
<a name="633"/>   # :  `x` - something convertible to a `Dec`.
<a name="634"/>   # :  `rnd` - something convertible to a `Round`.
<a name="635"/>   #
<a name="636"/>   public static acos(x, rnd)
<a name="637"/>      local mc, result
<a name="638"/>      x := need_Dec(x)
<a name="639"/>      rnd := need_Round(rnd)
<a name="640"/>      if x.abs().cmp("&gt;", ONE) then
<a name="641"/>         runerr(205, x)
<a name="642"/>      mc := rnd.digits + 6
<a name="643"/>      result := pi(mc).div(TWO).sub(asin(x, mc))
<a name="644"/>      return result.round(rnd)
<a name="645"/>   end
<a name="646"/>
<a name="647"/>   # Calculates the arc tangent (inverted tangent) of `x`
<a name="648"/>   #
<a name="649"/>   # :Parameters :
<a name="650"/>   # :  `x` - something convertible to a `Dec`.
<a name="651"/>   # :  `rnd` - something convertible to a `Round`.
<a name="652"/>   #
<a name="653"/>   public static atan(x, rnd)
<a name="654"/>      local mc, result
<a name="655"/>      x := need_Dec(x)
<a name="656"/>      rnd := need_Round(rnd)
<a name="657"/>      mc := rnd.digits + 6
<a name="658"/>      x := x.div(sqrt(ONE.add(x.mul(x)), mc), mc)
<a name="659"/>      result := asin(x, mc)
<a name="660"/>      return result.round(rnd)
<a name="661"/>   end
<a name="662"/>
<a name="663"/>   # Calculates the hyperbolic sine of `x`.
<a name="664"/>   #
<a name="665"/>   # :Parameters :
<a name="666"/>   # :  `x` - something convertible to a `Dec`.
<a name="667"/>   # :  `rnd` - something convertible to a `Round`.
<a name="668"/>   #
<a name="669"/>   public static sinh(x, rnd)
<a name="670"/>      static sc
<a name="671"/>      local mc
<a name="672"/>      initial sc := SinhCalculator()
<a name="673"/>
<a name="674"/>      x := need_Dec(x)
<a name="675"/>      rnd := need_Round(rnd)
<a name="676"/>      mc := rnd.digits + 4
<a name="677"/>
<a name="678"/>      return sc.calculate(x, mc).round(rnd)
<a name="679"/>   end
<a name="680"/>
<a name="681"/>   # Calculates the hyperbolic cosine of `x`.
<a name="682"/>   #
<a name="683"/>   # :Parameters :
<a name="684"/>   # :  `x` - something convertible to a `Dec`.
<a name="685"/>   # :  `rnd` - something convertible to a `Round`.
<a name="686"/>   #
<a name="687"/>   public static cosh(x, rnd)
<a name="688"/>      static cc
<a name="689"/>      local mc
<a name="690"/>      initial cc := CoshCalculator()
<a name="691"/>
<a name="692"/>      x := need_Dec(x)
<a name="693"/>      rnd := need_Round(rnd)
<a name="694"/>      mc := rnd.digits + 4
<a name="695"/>
<a name="696"/>      return cc.calculate(x, mc).round(rnd)
<a name="697"/>   end
<a name="698"/>
<a name="699"/>   # Calculates the hyperbolic tangent of `x`.
<a name="700"/>   #
<a name="701"/>   # :Parameters :
<a name="702"/>   # :  `x` - something convertible to a `Dec`.
<a name="703"/>   # :  `rnd` - something convertible to a `Round`.
<a name="704"/>   #
<a name="705"/>   public static tanh(x, rnd)
<a name="706"/>      local mc
<a name="707"/>      x := need_Dec(x)
<a name="708"/>      rnd := need_Round(rnd)
<a name="709"/>      mc := rnd.digits + 6
<a name="710"/>      return sinh(x, mc).div(cosh(x, mc), mc).round(rnd)
<a name="711"/>   end
<a name="712"/>
<a name="713"/>   # Calculates the arc tangent (inverted tangent) of `y / x` in the range -pi to pi.
<a name="714"/>   #
<a name="715"/>   # :Parameters :
<a name="716"/>   # :  `x` - something convertible to a `Dec`.
<a name="717"/>   # :  `y` - something convertible to a `Dec`.
<a name="718"/>   # :  `rnd` - something convertible to a `Round`.
<a name="719"/>   #
<a name="720"/>   public static atan2(y, x, rnd)
<a name="721"/>      local mc
<a name="722"/>      x := need_Dec(x)
<a name="723"/>      y := need_Dec(y)
<a name="724"/>      rnd := need_Round(rnd)
<a name="725"/>      mc := rnd.digits + 3
<a name="726"/>      return if x.sign() &gt; 0 then # x &gt; 0
<a name="727"/>         atan(y.div(x, mc), rnd)
<a name="728"/>      else if x.sign() &lt; 0 then {
<a name="729"/>         if y.sign() &gt; 0 then  # x &lt; 0 &amp;&amp; y &gt; 0
<a name="730"/>            atan(y.div(x, mc), mc).add(pi(mc), rnd)
<a name="731"/>         else if y.sign() &lt; 0 then  # x &lt; 0 &amp;&amp; y &lt; 0
<a name="732"/>            atan(y.div(x, mc), mc).sub(pi(mc), rnd)
<a name="733"/>         else #  x &lt; 0 &amp;&amp; y = 0
<a name="734"/>            pi(rnd)
<a name="735"/>      } else {
<a name="736"/>         if y.sign() &gt; 0 then # x = 0 &amp;&amp; y &gt; 0
<a name="737"/>            pi(mc).div(TWO, rnd)
<a name="738"/>         else if y.sign() &lt; 0 then # x = 0 &amp;&amp; y &lt; 0
<a name="739"/>            pi(mc).div(TWO, rnd).negate()
<a name="740"/>         else
<a name="741"/>            runerr(205, y)
<a name="742"/>      }
<a name="743"/>   end
<a name="744"/>
<a name="745"/>   # Calculates the square root of `x`.
<a name="746"/>   #
<a name="747"/>   # :Parameters :
<a name="748"/>   # :  `x` - something convertible to a `Dec`.
<a name="749"/>   # :  `rnd` - something convertible to a `Round`.
<a name="750"/>   #
<a name="751"/>   public static sqrt(x, rnd)
<a name="752"/>      return root(x, 2, rnd)
<a name="753"/>   end
<a name="754"/>
<a name="755"/>   private static piChudnovski(prec)
<a name="756"/>      local valueDivisor, mc, sumA, sumB, a, b, dividendTerm1, dividendTerm2,
<a name="757"/>         dividendTerm3, kPower3, iterationCount, k, valueK, dividend,
<a name="758"/>         divisor, factor, pi
<a name="759"/>
<a name="760"/>      mc := prec + 10
<a name="761"/>      valueDivisor := Dec(640320^3).div(Dec(24), mc)
<a name="762"/>
<a name="763"/>      a := sumA := ONE
<a name="764"/>      sumB := ZERO
<a name="765"/>
<a name="766"/>      dividendTerm1 := 5         # -(6*k - 5)
<a name="767"/>      dividendTerm2 := -1        #  2*k - 1
<a name="768"/>      dividendTerm3 := -1        # 6*k - 1
<a name="769"/>      kPower3 := ZERO
<a name="770"/>      
<a name="771"/>      iterationCount := (mc + 13) / 14
<a name="772"/>
<a name="773"/>      every k := 1 to iterationCount do {
<a name="774"/>         valueK := Dec(k)
<a name="775"/>         dividendTerm1 +:= -6
<a name="776"/>         dividendTerm2 +:= 2
<a name="777"/>         dividendTerm3 +:= 6
<a name="778"/>
<a name="779"/>         dividend := Dec(dividendTerm1).mul(dividendTerm2).mul(dividendTerm3)
<a name="780"/>         kPower3 := Dec(k^3)
<a name="781"/>
<a name="782"/>         divisor := kPower3.mul(valueDivisor)
<a name="783"/>         a := a.mul(dividend).div(divisor, mc)
<a name="784"/>         b := valueK.mul(a)
<a name="785"/>			
<a name="786"/>         sumA := sumA.add(a)
<a name="787"/>         sumB := sumB.add(b)
<a name="788"/>      }
<a name="789"/>
<a name="790"/>      factor := Dec(426880).mul(sqrt(10005, mc))
<a name="791"/>      pi := factor.div(Dec(13591409).mul(sumA).add(Dec(545140134).mul(sumB)), mc)
<a name="792"/>		
<a name="793"/>      return pi.round(prec);
<a name="794"/>   end
<a name="795"/>end
</pre></body></html>
