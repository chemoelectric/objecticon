<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>io.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     io.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures for input and output
<a name="6"/>#
<a name="7"/>#	Author:   Ralph E. Griswold
<a name="8"/>#
<a name="9"/>#	Date:     October 6, 2000
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#  Contributors:  Paul Abrahams, Bob Alexander, Will Evans, David A. Gamey,
<a name="18"/>#		  Richard L. Goerwitz, Will Menagarini, Charles Sharstis,
<a name="19"/>#		  and Gregg Townsend.
<a name="20"/>#
<a name="21"/>############################################################################
<a name="22"/>#
<a name="23"/>#  They provide facilities for handling input, output, and files.
<a name="24"/>#
<a name="25"/>#  There are other modules in the Icon program library that deal with
<a name="26"/>#  input and output.  They are not included here because they conflict
<a name="27"/>#  with procedures here or each other.
<a name="28"/>#
<a name="29"/>############################################################################
<a name="30"/>#
<a name="31"/>#  Links:  random, strings
<a name="32"/>#
<a name="33"/>############################################################################
<a name="34"/>#
<a name="35"/>#  Reading and writing files:
<a name="36"/>#
<a name="37"/>#	filetext(f)	reads the lines of f into a list and returns that
<a name="38"/>#			list
<a name="39"/>#
<a name="40"/>#	readline(file)	assembles backslash-continued lines from the specified
<a name="41"/>#			file into a single line.  If the last line in a file
<a name="42"/>#			ends in a backslash, that character is included in the
<a name="43"/>#			last line read.
<a name="44"/>#
<a name="45"/>#	splitline(file, line, limit)
<a name="46"/>#			splits line into pieces at first blank after
<a name="47"/>#			the limit, appending a backslash to identify split
<a name="48"/>#			lines (if a line ends in a backslash already, that's
<a name="49"/>#			too bad). The pieces are written to the	specified file.
<a name="50"/>#
<a name="51"/>############################################################################
<a name="52"/>#
<a name="53"/>#  Buffered input and output:
<a name="54"/>#
<a name="55"/>#	 ClearOut()	remove contents of output buffer without writing
<a name="56"/>#	 Flush()	flush output buffer
<a name="57"/>#	 GetBack()	get back line writen
<a name="58"/>#	 LookAhead()	look ahead at next line
<a name="59"/>#	 PutBack(s)	put back a line
<a name="60"/>#	 Read()		read a line
<a name="61"/>#	 ReadAhead(n)	read ahead n lines
<a name="62"/>#	 Write(s)	write a line
<a name="63"/>#
<a name="64"/>############################################################################
<a name="65"/>
<a name="66"/>package ipl.io
<a name="67"/>
<a name="68"/>import
<a name="69"/>   io(Files, close, open, read,
<a name="70"/>      write)
<a name="71"/>
<a name="72"/>global buffer_in, buffer_out, Eof
<a name="73"/>
<a name="74"/># remove contents of output buffer
<a name="75"/>procedure ClearOut()			
<a name="76"/>
<a name="77"/>   buffer_out := []
<a name="78"/>
<a name="79"/>end
<a name="80"/>
<a name="81"/># flush output buffer
<a name="82"/>procedure Flush()			
<a name="83"/>
<a name="84"/>   while write(pull(buffer_out))
<a name="85"/>
<a name="86"/>   return
<a name="87"/>
<a name="88"/>end
<a name="89"/>
<a name="90"/># get back line written
<a name="91"/>procedure GetBack()			
<a name="92"/>
<a name="93"/>   return get(buffer_out)
<a name="94"/>
<a name="95"/>end
<a name="96"/>
<a name="97"/># look at next line
<a name="98"/>procedure LookAhead()			
<a name="99"/>
<a name="100"/>   return buffer_in[1]
<a name="101"/>
<a name="102"/>end
<a name="103"/>
<a name="104"/># put back line read
<a name="105"/>procedure PutBack(s)			
<a name="106"/>
<a name="107"/>   push(buffer_in,s)
<a name="108"/>
<a name="109"/>   return
<a name="110"/>
<a name="111"/>end
<a name="112"/>
<a name="113"/># read a line in buffered mode
<a name="114"/>procedure Read()			
<a name="115"/>
<a name="116"/>   initial{
<a name="117"/>      buffer_in := []
<a name="118"/>      }
<a name="119"/>
<a name="120"/>   if *buffer_in = 0 then
<a name="121"/>      put(buffer_in,read()) | (Eof := 1)
<a name="122"/>   return get(buffer_in)
<a name="123"/>
<a name="124"/>end
<a name="125"/>
<a name="126"/># read ahead
<a name="127"/>procedure ReadAhead(n)			
<a name="128"/>
<a name="129"/>   while *buffer_in &lt; n do
<a name="130"/>      unless put(buffer_in,read()) then {
<a name="131"/>         Eof := 1
<a name="132"/>         fail
<a name="133"/>         }
<a name="134"/>
<a name="135"/>   return
<a name="136"/>
<a name="137"/>end
<a name="138"/>
<a name="139"/># write in buffered mode
<a name="140"/>procedure Write(s)			
<a name="141"/>
<a name="142"/>   initial buffer_out := []
<a name="143"/>
<a name="144"/>   push(buffer_out,s)
<a name="145"/> 
<a name="146"/>   return s
<a name="147"/>
<a name="148"/>end
<a name="149"/>
<a name="150"/># open file on DPATH
<a name="151"/>procedure dopen(s)
<a name="152"/>   return open(Files.path_find(s, "DPATH"))
<a name="153"/>end
<a name="154"/>
<a name="155"/># read file into list
<a name="156"/>procedure filetext(f)			
<a name="157"/>   local input, text
<a name="158"/>
<a name="159"/>   input := open(f) | fail
<a name="160"/>
<a name="161"/>   text := []
<a name="162"/>
<a name="163"/>   while put(text,read(input))
<a name="164"/>
<a name="165"/>   close(input)
<a name="166"/>
<a name="167"/>   return text
<a name="168"/>
<a name="169"/>end
<a name="170"/>
<a name="171"/># assemble backslash-continued lines
<a name="172"/>procedure readline(file)		
<a name="173"/>   local line
<a name="174"/>
<a name="175"/>   line := read(file) | fail
<a name="176"/>
<a name="177"/>   while line[-1] == "\\" do
<a name="178"/>      line := line[1:-1] || read(file) | break
<a name="179"/>
<a name="180"/>   return line
<a name="181"/>
<a name="182"/>end
<a name="183"/>
<a name="184"/># split line into pieces
<a name="185"/>procedure splitline(file,line,limit)	
<a name="186"/>   local i, j
<a name="187"/>
<a name="188"/>   if *line = 0 then {			# don't fail to write empty line
<a name="189"/>      write(file,line)
<a name="190"/>      return
<a name="191"/>      }
<a name="192"/>   while *line &gt; limit do {
<a name="193"/>      line ?:= {
<a name="194"/>         i := j := 0
<a name="195"/>         every i := find(" ") do {	# find a point to split
<a name="196"/>            if i &gt;= limit then break
<a name="197"/>            else j := i
<a name="198"/>            }
<a name="199"/>         if j = 0 then {		# can't split
<a name="200"/>            write(file,line)
<a name="201"/>            return
<a name="202"/>            }
<a name="203"/>         write(file,tab(j + 1),"\\")
<a name="204"/>         tab(0)				# update line
<a name="205"/>         }
<a name="206"/>      }
<a name="207"/>   if *line &gt; 0 then write(file,line)	# the rest
<a name="208"/>
<a name="209"/>   return
<a name="210"/>
<a name="211"/>end
</pre></body></html>
