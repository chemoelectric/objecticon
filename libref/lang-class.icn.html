<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>class.icn</title></head><body><pre>
<a name="1"/>package lang
<a name="2"/>
<a name="3"/>import util(need_string)
<a name="4"/>
<a name="5"/>#
<a name="6"/># This class contains various helpful methods to get information about
<a name="7"/># a class at runtime.
<a name="8"/>#
<a name="9"/>final abstract class Class()
<a name="10"/>   public static const 
<a name="11"/>      Method,        # Integer flag for a method
<a name="12"/>      Private,       # Integer flag for a private field
<a name="13"/>      Public,        # Integer flag for a public field
<a name="14"/>      Protected,     # Integer flag for a protected field
<a name="15"/>      Package,       # Integer flag for a package field
<a name="16"/>      Static,        # Integer flag for a static field
<a name="17"/>      Const,         # Integer flag for a constant field
<a name="18"/>      Readable,      # Integer flag for a readable field
<a name="19"/>      Optional,      # Integer flag for an optional method
<a name="20"/>      Final,         # Integer flag for a final method or class
<a name="21"/>      Special,       # Integer flag for a special method, ie init or new.
<a name="22"/>      Abstract,      # Integer flag for an abstract class/method.
<a name="23"/>      Native,        # Integer flag for a native method.
<a name="24"/>      Removed,       # Integer flag for a removed method.
<a name="25"/>      Override       # Integer flag for an override method.
<a name="26"/>
<a name="27"/>   private static init()
<a name="28"/>      Method := 8r01
<a name="29"/>      Private := 8r02
<a name="30"/>      Public := 8r04
<a name="31"/>      Protected := 8r010
<a name="32"/>      Package := 8r020
<a name="33"/>      Static := 8r040
<a name="34"/>      Const := 8r0100
<a name="35"/>      Readable := 8r0200
<a name="36"/>      Optional := 8r0400
<a name="37"/>      Final := 8r01000
<a name="38"/>      Special := 8r02000
<a name="39"/>      Abstract := 8r04000
<a name="40"/>      Native := 8r010000
<a name="41"/>      Removed := 8r020000
<a name="42"/>      Override := 8r040000
<a name="43"/>   end
<a name="44"/>
<a name="45"/>   # This method creates a new instance of the class from which the
<a name="46"/>   # method is called.  The `new()` method is not invoked.  The new
<a name="47"/>   # object has all its instance fields set to &amp;null, and is in an
<a name="48"/>   # initializing state, meaning that `new()` may be invoked upon it,
<a name="49"/>   # and `const` fields are assignable.  After the instance is
<a name="50"/>   # initialized by the caller, `complete_raw_instance` must be called
<a name="51"/>   # to place it into the initialized state.
<a name="52"/>   #
<a name="53"/>   public static native create_raw_instance()
<a name="54"/>
<a name="55"/>   # This method creates a new instance of the class from which the
<a name="56"/>   # method is called.  The `new()` method is not invoked.  The new
<a name="57"/>   # object has all its instance fields set to &amp;null, and is in an
<a name="58"/>   # initialized state, meaning that `new()` cannot be invoked upon
<a name="59"/>   # it, and `const` fields are not assignable.
<a name="60"/>   #
<a name="61"/>   public static native create_instance()
<a name="62"/>
<a name="63"/>   private static native create_raw_instance_of(c)
<a name="64"/>
<a name="65"/>   # This completes the initialization of a raw instance by setting
<a name="66"/>   # its state to initialized.
<a name="67"/>   #
<a name="68"/>   public static native complete_raw_instance(o)
<a name="69"/>
<a name="70"/>   # Return the name of the class
<a name="71"/>   #
<a name="72"/>   public static native get_name(c)
<a name="73"/>
<a name="74"/>   # Return the class of the object
<a name="75"/>   #
<a name="76"/>   public static native get_class(c)
<a name="77"/>
<a name="78"/>   # Return the program this class resides in.  The program's &amp;main
<a name="79"/>   # co-expression is returned.
<a name="80"/>   #
<a name="81"/>   public static native get_program(c)
<a name="82"/>
<a name="83"/>   # Return the name of the package in which this class resides; fails
<a name="84"/>   # if the class is not in a package.
<a name="85"/>   #
<a name="86"/>   public static get_package(c)
<a name="87"/>      return extract_package(get_name(c))
<a name="88"/>   end
<a name="89"/>
<a name="90"/>   # Return the source location of the class
<a name="91"/>   # :Returns :
<a name="92"/>   # :  a `Location` instance
<a name="93"/>   #
<a name="94"/>   public static get_location(c)
<a name="95"/>      return Prog.get_global_location(get_name(c), get_program(c))
<a name="96"/>   end
<a name="97"/>
<a name="98"/>   # Generate the superclasses of the class `c`
<a name="99"/>   #
<a name="100"/>   public static native get_supers(c)
<a name="101"/>
<a name="102"/>   # Generate the implemented classes of the class `c`
<a name="103"/>   #
<a name="104"/>   public static native get_implemented_classes(c)
<a name="105"/>
<a name="106"/>   # Succeed iff the class `c` implements the class `target`.  This is
<a name="107"/>   # similar to the builtin is() function, but takes a class as its
<a name="108"/>   # first argument, whereas is() takes an object (or fails).
<a name="109"/>   #
<a name="110"/>   public static native implements(c, target)
<a name="111"/>
<a name="112"/>   # This is similar to the builtin is() function.  However, if obj is
<a name="113"/>   # in a different program to cl, then the class with the same name
<a name="114"/>   # as cl is looked up in obj's program.  Then is(obj, cl) is invoked
<a name="115"/>   # and the result returned.
<a name="116"/>   #
<a name="117"/>   public static is_by_name(obj, cl)
<a name="118"/>      local p
<a name="119"/>      p := get_program(obj) 
<a name="120"/>      if p ~=== get_program(cl) then
<a name="121"/>         cl := for_name(get_name(cl), p) | fail
<a name="122"/>      return is(obj, cl)
<a name="123"/>   end
<a name="124"/>
<a name="125"/>   # Generate the field names of the class `c`.  The instance fields
<a name="126"/>   # come first, followed by the class fields.
<a name="127"/>   #
<a name="128"/>   public static get_field_names(c)
<a name="129"/>      suspend get_field_name(c, 1 to get_n_fields(c))
<a name="130"/>   end
<a name="131"/>
<a name="132"/>   # Return the number of fields in the class `c`.
<a name="133"/>   #
<a name="134"/>   public static get_n_fields(c)
<a name="135"/>      return get_n_instance_fields(c) + get_n_class_fields(c)
<a name="136"/>   end
<a name="137"/>
<a name="138"/>   # Return the flags for the class `c`, which can include
<a name="139"/>   # `Abstract` or `Final`.
<a name="140"/>   #
<a name="141"/>   public static native get_class_flags(c)
<a name="142"/>
<a name="143"/>   # Generate the field names of the class fields of class `c`.
<a name="144"/>   #
<a name="145"/>   public static get_class_field_names(c)
<a name="146"/>      suspend get_field_name(c, get_n_instance_fields(c) + 1 to get_n_fields(c))
<a name="147"/>   end
<a name="148"/>
<a name="149"/>   # Return the number of class fields of class `c`.
<a name="150"/>   #
<a name="151"/>   public static native get_n_class_fields(c)
<a name="152"/>
<a name="153"/>   # Generate the field names of the instance fields of class `c`.
<a name="154"/>   #
<a name="155"/>   public static get_instance_field_names(c)
<a name="156"/>      suspend get_field_name(c, 1 to get_n_instance_fields(c))
<a name="157"/>   end
<a name="158"/>
<a name="159"/>   # Return the number of instance fields of class `c`.
<a name="160"/>   #
<a name="161"/>   public static native get_n_instance_fields(c)
<a name="162"/>
<a name="163"/>   # Return the flags of the given field in class`c`.
<a name="164"/>   # :Parameters :
<a name="165"/>   # :  `c` - the class
<a name="166"/>   # :  `field` - either a field name or number
<a name="167"/>   # :Returns :
<a name="168"/>   # :  an integer, being the OR of all the flags
<a name="169"/>   # :Fails :
<a name="170"/>   # :  if the field is unknown
<a name="171"/>   #
<a name="172"/>   public static native get_field_flags(c, field)
<a name="173"/>
<a name="174"/>   # Return the field index number of the given field in class`c`.
<a name="175"/>   # :Parameters :
<a name="176"/>   # :  `c` - the class
<a name="177"/>   # :  `field` - either a field name or number
<a name="178"/>   # :Returns :
<a name="179"/>   # :  an integer, being the index
<a name="180"/>   # :Fails :
<a name="181"/>   # :  if the field is unknown
<a name="182"/>   #
<a name="183"/>   public static native get_field_index(c, field)
<a name="184"/>
<a name="185"/>   # Return the field name of the given field in class`c`.
<a name="186"/>   # :Parameters :
<a name="187"/>   # :  `c` - the class
<a name="188"/>   # :  `field` - either a field name or number
<a name="189"/>   # :Returns :
<a name="190"/>   # :  the field name
<a name="191"/>   # :Fails :
<a name="192"/>   # :  if the field is unknown
<a name="193"/>   #
<a name="194"/>   public static native get_field_name(c, field)
<a name="195"/>
<a name="196"/>   # Return the source location of the given field in class`c`.
<a name="197"/>   # :Parameters :
<a name="198"/>   # :  `c` - the class
<a name="199"/>   # :  `field` - either a field name or number
<a name="200"/>   # :Returns :
<a name="201"/>   # :  a `Location` instance
<a name="202"/>   # :Fails :
<a name="203"/>   # :  if the field is unknown
<a name="204"/>   #
<a name="205"/>   public static get_field_location(c, field)
<a name="206"/>      return Location!get_field_location_impl(c, field)
<a name="207"/>   end
<a name="208"/>
<a name="209"/>   private static native get_field_location_impl(c, field)
<a name="210"/>
<a name="211"/>   # Return the class in which the given field is defined.
<a name="212"/>   # :Parameters :
<a name="213"/>   # :  `c` - the class
<a name="214"/>   # :  `field` - either a field name or number
<a name="215"/>   # :Returns :
<a name="216"/>   # :  the defining class of the field
<a name="217"/>   # :Fails :
<a name="218"/>   # :  if the field is unknown
<a name="219"/>   #
<a name="220"/>   public static native get_field_defining_class(c, field)
<a name="221"/>
<a name="222"/>   # Return the object part of a method pointer.
<a name="223"/>   # :Parameters :
<a name="224"/>   # :  `mp` - a methp structure
<a name="225"/>   # :Returns :
<a name="226"/>   # :  an object
<a name="227"/>   #
<a name="228"/>   private static native get_methp_object(mp)
<a name="229"/>
<a name="230"/>   # Return the procedure part of a method pointer.
<a name="231"/>   # :Parameters :
<a name="232"/>   # :  `mp` - a methp structure
<a name="233"/>   # :Returns :
<a name="234"/>   # :  a procedure object (which will be an instance method)
<a name="235"/>   #
<a name="236"/>   private static native get_methp_proc(mp)
<a name="237"/>
<a name="238"/>   # Set the component parts of a methp.
<a name="239"/>   # :Parameters :
<a name="240"/>   # :  `mp` - a methp structure
<a name="241"/>   # :  `obj` - the object part
<a name="242"/>   # :  `proc` - the proc part
<a name="243"/>   # :Returns :
<a name="244"/>   # :  the methp
<a name="245"/>   #
<a name="246"/>   private static native set_methp(mp, obj, proc)
<a name="247"/>
<a name="248"/>   # Get the value of the field in `x`, behaving in exactly the same way
<a name="249"/>   # as though the "." operation had been invoked with equivalent values.
<a name="250"/>   #
<a name="251"/>   # :Parameters :
<a name="252"/>   # :  `x` - either a record, class or object
<a name="253"/>   # :  `field` - either a field name or number
<a name="254"/>   # :Returns :
<a name="255"/>   # :  the field value
<a name="256"/>   # :Runtime error :
<a name="257"/>   # :  if the field is unknown or access is not permitted
<a name="258"/>   #
<a name="259"/>   public static native get(x, field)
<a name="260"/>
<a name="261"/>   # This behaves in exactly the same way as `get` above, but fails
<a name="262"/>   # rather than stops with a runtime error, if the field is unknown
<a name="263"/>   # or access is denied.  On failure, `&amp;why` is set to an appropriate
<a name="264"/>   # message.
<a name="265"/>   #
<a name="266"/>   # :Parameters :
<a name="267"/>   # :  `x` - either a record, class or object
<a name="268"/>   # :  `field` - either a field name or number
<a name="269"/>   # :Returns :
<a name="270"/>   # :  the field value
<a name="271"/>   # :Fails :
<a name="272"/>   # :  if the field is unknown or access is not permitted
<a name="273"/>   #
<a name="274"/>   public static native getf(x, field)
<a name="275"/>
<a name="276"/>   # This behaves in exactly the same way as `getf` above, but
<a name="277"/>   # doesn't set `&amp;why` on failure.
<a name="278"/>   #
<a name="279"/>   # :Parameters :
<a name="280"/>   # :  `x` - either a record, class or object
<a name="281"/>   # :  `field` - either a field name or number
<a name="282"/>   # :Returns :
<a name="283"/>   # :  the field value
<a name="284"/>   # :Fails :
<a name="285"/>   # :  if the field is unknown or access is not permitted
<a name="286"/>   #
<a name="287"/>   public static native getq(x, field)
<a name="288"/>
<a name="289"/>   # This method tries to resolve all the unresolved deferred methods
<a name="290"/>   # declared in the class from which is called, from the dll `lib`.
<a name="291"/>   # Methods are matched to functions in the dll using the same scheme
<a name="292"/>   # for native methods in the main runtime interpreter, namely by
<a name="293"/>   # using the form "&lt;class&gt;_&lt;method&gt;", with all dots in &lt;class&gt;
<a name="294"/>   # replaced by underscores.  Any methods not found are simply
<a name="295"/>   # ignored.  If the library cannot be found, the call fails and sets
<a name="296"/>   # `&amp;why` to the message reported by dlerror.
<a name="297"/>   # 
<a name="298"/>   # :Parameters :
<a name="299"/>   # :  `lib` - the name of the dll
<a name="300"/>   # :Fails :
<a name="301"/>   # :  if the library cannot be found.
<a name="302"/>   #
<a name="303"/>   public static native load_library(lib)   
<a name="304"/>
<a name="305"/>   # Lookup a class by name
<a name="306"/>   # 
<a name="307"/>   # :Parameters :
<a name="308"/>   # :  `s` - a class name
<a name="309"/>   # :  `ce` - a coexpression, representing a loaded program, defaults
<a name="310"/>   #   to the main program
<a name="311"/>   # :Returns :
<a name="312"/>   # :  a class
<a name="313"/>   # :Fails :
<a name="314"/>   # :  if the class is unknown
<a name="315"/>   #
<a name="316"/>   public static for_name(s, ce)
<a name="317"/>      local t
<a name="318"/>      s := need_string(s)
<a name="319"/>      if not(integer(s)) &amp;
<a name="320"/>         t := Prog.get_named_global(s, ce) &amp;
<a name="321"/>         type(t) == "class" then
<a name="322"/>         return t
<a name="323"/>   end
<a name="324"/>
<a name="325"/>   # Initialize a class, by calling its static init method.  Has no
<a name="326"/>   # effect if the class has already been initialized.
<a name="327"/>   #
<a name="328"/>   public static native ensure_initialized(c)
<a name="329"/>end
</pre></body></html>
