<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>tasks.icn</title></head><body><pre>
<a name="1"/>package ipl.tasks
<a name="2"/>
<a name="3"/>import 
<a name="4"/>   ipl.lists(ldel1),
<a name="5"/>   util(need_integer, need_list)
<a name="6"/>
<a name="7"/>#
<a name="8"/># A semaphore implementation using `io.Task`s.
<a name="9"/>#
<a name="10"/>class Semaphore()
<a name="11"/>   private readable 
<a name="12"/>      n
<a name="13"/>   private const
<a name="14"/>      wl
<a name="15"/>
<a name="16"/>   #
<a name="17"/>   # Perform a wait on the semaphore.
<a name="18"/>   #
<a name="19"/>   # If the semaphore `n` is positive, then it is decremented and the
<a name="20"/>   # method succeeds immediately.
<a name="21"/>   #
<a name="22"/>   # Otherwise, if `t` is null, then the method fails immediately.
<a name="23"/>   #
<a name="24"/>   # If `t` is not null, then it specifies an `io.Task`, which will be
<a name="25"/>   # put to sleep with the given timeout (which may be null), to wait
<a name="26"/>   # for the semaphore to become available.  After the task awakes,
<a name="27"/>   # the method succeeds if the caller now holds the semaphore, but
<a name="28"/>   # fails otherwise (for example if the sleep timed out).
<a name="29"/>   #
<a name="30"/>   # :Parameters :
<a name="31"/>   # : `t` - the optional, current `io.Task` which may be put to sleep.
<a name="32"/>   # : `timeout` - the optional sleep timeout; ignored if `t` is null.
<a name="33"/>   #
<a name="34"/>   public wait(t, timeout)
<a name="35"/>      if n &gt; 0 then
<a name="36"/>         n -:= 1
<a name="37"/>      else if /t then
<a name="38"/>         fail
<a name="39"/>      else {
<a name="40"/>         put(wl, t)
<a name="41"/>         t.sleep(timeout)
<a name="42"/>         if ldel1(wl, t) then
<a name="43"/>            # Interrupted/timeout
<a name="44"/>            fail
<a name="45"/>      }
<a name="46"/>      link
<a name="47"/>   end
<a name="48"/>
<a name="49"/>   #
<a name="50"/>   # Perform a signal on the semaphore.
<a name="51"/>   #
<a name="52"/>   public signal()
<a name="53"/>      local t
<a name="54"/>      if t := get(wl) then
<a name="55"/>         t.notify()
<a name="56"/>      else
<a name="57"/>         n +:= 1
<a name="58"/>      link
<a name="59"/>   end
<a name="60"/>
<a name="61"/>   #
<a name="62"/>   # This is similar to `wait`, but waits for one of a list of
<a name="63"/>   # semaphores to become available.  On success, the semaphore
<a name="64"/>   # obtained is returned.  Note that the order of `l` is important,
<a name="65"/>   # with earlier entries having preference over later ones.
<a name="66"/>   #
<a name="67"/>   # :Parameters :
<a name="68"/>   # : `l` - the list of `Semaphore`s to wait for.
<a name="69"/>   # : `t` - the optional, current `io.Task` which may be put to sleep.
<a name="70"/>   # : `timeout` - the optional sleep timeout; ignored if `t` is null.
<a name="71"/>   #
<a name="72"/>   public static poll(l, t, timeout)
<a name="73"/>      local e, r
<a name="74"/>      need_list(l)
<a name="75"/>      # Check for one which is immediately available
<a name="76"/>      every e := !l do {
<a name="77"/>         if e.wait() then
<a name="78"/>            return e
<a name="79"/>      }
<a name="80"/>      if /t then
<a name="81"/>         fail
<a name="82"/>      # Add the task to each wait queue
<a name="83"/>      every e := !l do
<a name="84"/>         put(e.wl, t)
<a name="85"/>      t.sleep(timeout)
<a name="86"/>      every e := !l do
<a name="87"/>         # If ldel1 fails, then we obtained the semaphore.  Note just
<a name="88"/>         # the first so obtained in r, and signal others to release
<a name="89"/>         # them again.
<a name="90"/>         ldel1(e.wl, t) | (/r := e) | e.signal()
<a name="91"/>      return \r
<a name="92"/>   end
<a name="93"/>
<a name="94"/>   #
<a name="95"/>   # Return the number of tasks queued, waiting for the semaphore.
<a name="96"/>   #
<a name="97"/>   public queuing()
<a name="98"/>      return *wl
<a name="99"/>   end
<a name="100"/>
<a name="101"/>   #
<a name="102"/>   # Create a new semaphore with initial value `n`, default 0.
<a name="103"/>   #
<a name="104"/>   public new(n)
<a name="105"/>      self.n := need_integer(\n) | 0
<a name="106"/>      wl := []
<a name="107"/>      return
<a name="108"/>   end
<a name="109"/>end
</pre></body></html>
