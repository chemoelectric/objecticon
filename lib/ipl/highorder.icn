package ipl.functional

import
   lang(Class),
   ipl.callable(callable),
   ipl.lists(lreverse_mod),
   ipl.pdco(List,Parallel),
   datastruct(EqTable)

#
# Implementation class for `partial`
#
package class Partial()
   private
      f, spec, v

   public call(a[])
      local e, c, r
      e := create !v
      r := []
      every c := !spec do {
         case c of {
            "v": put(r, @e)
            "V": while put(r, @e)
            "a": put(r, get(a))
            "A": while put(r, get(a))
            "-": get(a)
            default: runerr("invalid spec char to partial", c)
         }
      }
      suspend f!r
   end

   public new(f, spec, v)
      self.f := f
      self.spec := spec
      self.v := v
      return
   end
end

# Returns a function which modifies its arguments according to `spec`,  before applying them
# to f.  The modification is specified by the following characters in spec:-
#    "v": add the next value (which follow the spec parameter).
#    "V": add the remaining values.
#    "a": add the next argument.
#    "A": add the remaining arguments.
#    "-": skip the next argument.
#
# Example :-
# ~
#     f := partial(write, "vvvAV", "a", "b", "c", "p", "q", "r")
#     f("x","y","z")   # writes abcxyzpqr
# ~
procedure partial(f, spec, l[])
   return Partial(f, spec, l).call
end

#
# Implementation class for `lpartial` and `lpartial1`
#
package class LPartial()
   private
      f, x

   public call(a[])
      suspend f!(x ||| a)
   end

   public call1(a)
      suspend f(x, a)
   end

   public new(f, x)
      self.f := f
      self.x := x
      return
   end
end

#
# Partial application to function f, prepending l to the arguments.
#
procedure lpartial(f, l[])
   return LPartial(f, l).call
end

# Partial application of the first parameter to the two-parameter
# function f.  The result is the same as using the more general
# function `lpartial`, but avoids the creation of temporary lists on
# each invocation of the resulting function.
#
procedure lpartial1(f, x)
   return LPartial(f, x).call1
end

#
# Implementation class for `rpartial` and `rpartial1`
#
package class RPartial()
   private
      f, x

   public call(a[])
      suspend f!(a ||| x)
   end

   public call1(a)
      suspend f(a, x)
   end

   public new(f, x)
      self.f := f
      self.x := x
      return
   end
end

#
# Partial application to function f, appending l to the arguments.
#
procedure rpartial(f, l[])
   return RPartial(f, l).call
end

# Partial application of the second parameter to the two-parameter
# function f.  The result is the same as using the more general
# function `rpartial`, but avoids the creation of temporary lists on
# each invocation of the resulting function.
#
procedure rpartial1(f, x)
   return RPartial(f, x).call1
end

#
# Implementation class for `compose`
#
package class Compose()
   private
      f, g

   public call(a[])
      suspend f(g!a)
   end

   public new(f, g)
      self.f := f
      self.g := g
      return
   end
end

#
# Compose functions f and g
#
procedure compose(f, g)
   return Compose(f, g).call
end

# Convenient function to get the named binary operator, partially
# applied with x as the left argument.  For example lpb(2, "*")
# returns a function which doubles its argument, whilst lpb(0, "<")
# returns a function which succeeds and returns its argument if it is
# greater than 0.
#
procedure lpb(x, s)
   return lpartial1(callable(s, 2), x)
end

# Convenient function to get the named binary operator, partially
# applied with x, using rpartial.  For example rpb("/", 2) returns a
# function which halves its argument.
#
procedure rpb(s, x)
   return rpartial1(callable(s, 2), x)
end

#
# Implementation class for `methodf`
#
package class Methodf()
   private field

   public call(obj, a[])
      suspend Class.get(obj, field)!a
   end

   public new(field)
      self.field := field
      return
   end
end

# Returns a function that takes its first argument, obtains the given
# field from it, and then applies the remaining arguments to the
# resulting method.
#
# Example :-
# ~
#   f := methodf("abc")
#   f(obj, 1, 2, 3)   # invokes obj.abc(1, 2, 3)
# ~
procedure methodf(field)
   return Methodf(field).call
end

#
# Implementation class for `coexf`
#
package class Coexf()
   private e

   public call()
      return @e
   end

   public new(e)
      self.e := e
      return
   end
end

#
# Given a co-expression `e`, this returns a function which produces @e
# on each evaluation.  Arguments to the function are discarded.
#
procedure coexf(e)
   return Coexf(e).call
end

#
# Implementation class for `exprf`
#
package class Exprf()
   private e

   public call()
      suspend !e
   end

   public new(e)
      self.e := e
      return
   end
end

#
# Given a co-expression `e`, this returns a function which generates !e
# on each evaluation.  Arguments to the function are discarded.
#
procedure exprf(e)
   return Exprf(e).call
end

# Implementation class for `flip`.
package class Flip()
   private f

   public call(a, b)
      suspend f(b, a)
   end

   public new(f)
      self.f := f
      return
   end
end

# This function takes a binary function and returns another function
# which invokes the original, but swapping its two arguments.
#
procedure flip(f)
   return Flip(f).call
end

# Implementation class for `revargs`.
package class RevArgs()
   private f

   public call(a[])
      suspend f!lreverse_mod(a)
   end

   public new(f)
      self.f := f
      return
   end
end

# This function takes a function and returns another function which
# invokes the original, but reversing all its arguments.  This is like
# `flip` above, but more general (and slower).
#
procedure revargs(f)
   return RevArgs(f).call
end

# Implementation class for `memoize`.
package class Memoize()
   private f, t

   public call(a[])
      local l
      (l := t.member(a)) | t.insert(a, l := List{f!a})
      suspend .!l
   end

   public new(f)
      self.f := f
      self.t := EqTable()
      return
   end
end

# This procedure returns a function which memoizes the passed
# function.  Subsequent arguments to and results from this function
# are cached in an `EqTable` so that the underlying function is only
# called for parameters that haven't been seen before.
#
procedure memoize(f)
   return Memoize(f).call
end

# Implementation class for `adjoin`.
package class Adjoin()
   private f, t

   private mk(f, a)
      return create f!a
   end

   public call(a[])
      suspend Parallel!List{mk(!f, a)}
   end

   public new(f)
      self.f := f
      return
   end
end

# This procedure puts several functions together and returns another
# function.  When the returned function is called, the results of the
# individual functions are generated in parallel, and a sequence of
# lists containing those results is generated.
#
procedure adjoin(f[])
   return Adjoin(f).call
end

