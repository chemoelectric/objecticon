package parser

import lang, util

class ErrorDetail()
   public const src, line, msg

   #
   # Produce a string version of the message in the same form
   # as produced by the compiler.
   #
   public str()
      local s
      s := "Line " || line || " # " || msg
      if \src then
         s := "File " || src || "; " || s
      return s
   end

   package final new(src, line, msg)
      self.src := src
      self.line := line
      self.msg := msg
      return
   end
end

class Parser(Connectable, Error)
   public
      preproc_sym_table,preproc_if_stack,preproc_file_stack,preproc_if_state,
      preproc_file,preproc_filename,preproc_line,preproc_print_line,
      preproc_word_chars,preproc_nest_level,preproc_include_name,
      preproc_include_set,preproc_print_filename,preproc_command,
      preproc_err_count, parser_fname

   public static const DEFAULT_SYMBOLS, PREPROCESSOR_ERROR_EVENT, PARSER_ERROR_EVENT

   private static init()
      local s
      PREPROCESSOR_ERROR_EVENT := "preprocessor error"
      PARSER_ERROR_EVENT := "parser error"
      DEFAULT_SYMBOLS := table()
      # reverse engineer the predefined symbols list from our predefined symbols
      DEFAULT_SYMBOLS["_V9"] := 1
      every s := &features do {
         DEFAULT_SYMBOLS[case s of {
            "Macintosh":"_MACINTOSH"
            "MS Windows NT":"_MS_WINDOWS_NT"
            "UNIX":"_UNIX"
            "POSIX":"_POSIX"
            "DBM":"_DBM"
            "SQL connectivity":"_SQL"
            "ASCII":"_ASCII"
            "co-expressions":"_CO_EXPRESSIONS"
            "dynamic loading":"_DYNAMIC_LOADING"
            "event montoring":"_EVENT_MONITOR"
            "large integers":"_LARGE_INTEGERS"
            "multiple programs":"_MULTITASKING"
            "pipes":"_PIPES"
            "system function":"_SYSTEM_FUNCTION"
            "graphics":"_GRAPHICS"
            "X Windows":"_X_WINDOW_SYSTEM"
            "MS Windows":"_MS_WINDOWS"
            "Win32":"_WIN32"
         }] := "1"
      }
   end

   public parse(s)
      parser_fname := &null
      return do_parse(s)
   end

   public parse_file(fname, predefined_syms)
      parser_fname := fname
      return do_parse(preprocess(fname, predefined_syms))
   end

   private do_parse(s)
      yyin := s
      parser.yyerror := yyerror
      yylex_reinit()
      yyparse()
      if yynerrs = 0 then
         return Prog(yyval)
   end

   public yyerror(s)
      local ed
      static t
      initial {
         t := table(table("syntax error"))
         t[0] := table("invalid declaration")
         t[26] := table("left parenthesis expected to start class fieldlist")
         t[26,257] := "left parenthesis expected to start class fieldlist"
         t[26,372] := "fieldlist starts with left *parenthesis*, not curly brace!"
         t[47] := table("missing identifier")
         t[73] := table("invalid while control expression")
         t[246] := table("missing operand after |||")
         t[246,307] := "missing operand after |||"
         t[246,317] := "illegal space inside |||:="
         t[10] := table("link list expected")
         t[188] := table("unclosed parenthesis")
         t[41] := table("method expected")
         t[62] := table("invalid case control expression")
         t[130] := table("missing fieldname or right parenthesis")
         t[151] := table("missing \"of\" in case expression")
         t[72] := table("invalid until control expression")
         t[135] := table("missing comma or unclosed class field arguments")
         t[135,282] := "unclosed class field arguments"
         t[135,257] := "missing comma or unclosed class field arguments"
         t[245] := table("missing operand after ||")
         t[245,307] := "missing operand after ||"
         t[245,317] := "illegal space inside ||:="
         t[376] := table("parenthesis is required for method invocation")
         t[444] := table("unclosed parenthesis")
         t[9] := table("invocable list expected")
         t[51] := table("parameter name expected")
         t[56] := table("unclosed literal or missing operator")
         t[255] := table("missing or invalid second argument to !")
         t[276] := table("parameter modifier must be a (atomic) literal or a convertor")
         t[370] := table("unclosed parenthesis")
         t[3] := table("global, class, or link expected")
         t[3,306] := "global, class, or link expected"
         t[3,282] := "method declaration outside any class"
         t[24] := table("missing semicolon")
         t[24,274] := "semicolon expected"
         t[24,271] := "missing semicolon"
         t[66] := table("invalid if control expression")
         t[265] := table("invalid local declaration")
         t[375] := table("missing \"do\" or some such keyword earlier, or expected a comma or right brace here")
         t[118] := table("missing operator or \"do\" keyword")
         t[39] := table("missing parameter list in procedure declaration")
         t[191] := table("missing operator or unbalanced parenthesis/bracket")
         t[259] := table("field name expected")
         t[301] := table("missing } somewhere before \"end\"")
         t[23] := table("procedure not allowed within a class")
         t[107] := table("too many closing curly braces")
         t[107,365] := "semicolon or operator expected"
         t[107,373] := "too many closing curly braces"
         t[154] := table("missing then")
         t[154,369] := "missing then"
         t[154,363] := "spurious close-parenthesis"
         t[264] := table("invalid initial expression")
         t[7] := table("unexpected end of file")
         t[28] := table("invalid global declaration")
         t[75] := table("bad keyword name or bogus & precedes this token")
         t[12] := table("procedure name expected")
         t[101] := table("invalid compound expression")
         t[101,271] := "invalid compound expression"
         t[101,317] := "assignment missing its left operand"
         t[127] := table("invalid procedure body")
         t[148] := table("a ; or \\n is missing between method header and body")
         t[190] := table("unclosed list")
         t[190,369] := "unclosed list"
         t[190,271] := "missing operator or closing bracket"
         t[64] := table("invalid every control expression")
         t[195] := table("expression expected, or need to move declaration to top of procedure or method")
         t[69] := table("invalid repeat control expression")
         t[74] := table("invalid argument to unary !")
         t[247] := table("missing or invalid second argument to +")
         t[252] := table("missing or invalid second argument to *")
         t[294] := table("missing then-part")
         t[37] := table("invalid link declaration")
         t[100] := table("unclosed list")
         t[147] := table("procedure not allowed within a class")
         t[278] := table("parameter name expected")
         t[435] := table("malformed case expression")
         t[63] := table("invalid create expression")
      }

      if s == "syntax error" then
         s := t[statestk[1], yychar]

      ed := ErrorDetail(parser_fname, yylineno, image(yytext) || ": " || s)
      fire(PARSER_ERROR_EVENT, ed)
      get_reason() | error(ed.str())

      return
   end

   #
   # Handles an error.
   #
   private preproc_error(msg)
      local ed
      ed := ErrorDetail(preproc_filename, preproc_line, msg)
      fire(PREPROCESSOR_ERROR_EVENT, ed)
      get_reason() | error(ed.str())
      preproc_err_count +:= 1
      return
   end

   #
   # Preprocess a file to a string.  Fails on any errors, or returns
   # the string.
   #
   public preprocess(fname, predefined_syms)
      local sb
      sb := StringBuff()
      every sb.add(preprocess_gen(fname, predefined_syms))
      if preproc_err_count = 0 then
         return sb.get_string("\n")
   end

   #
   # Preprocesses a file, generating output lines.
   #
   private preprocess_gen(fname, predefined_syms)
      local line
      static nonpunctuation
      initial {
         nonpunctuation := &letters ++ &digits ++ ' \t\f\r'
      }

      preproc_new(fname, predefined_syms)
      
      while line := preproc_read() do line ? {
         if match("#line") then {
            next
         }
         preproc_space()
         if ="$" & any(nonpunctuation) then {
            suspend preproc_scan_directive()
         } else {
            &pos := 1
            suspend preproc_scan_text()
         }
      }
      preproc_line +:= 1
      suspend preproc_sync_lines()
      close(preproc_file)
      preproc_done()
   end

   #
   # a_Initializes the preprocessor "object".
   #
   private preproc_new(fname,predefined_syms)
      if not(preproc_file := open(fname)) then {
         fatal(self, "cannot open " || image(fname))
      }
      clear_error()
      preproc_sym_table := \predefined_syms | copy(DEFAULT_SYMBOLS)
      preproc_if_stack := []
      preproc_file_stack := []
      preproc_include_set := set([fname])
      preproc_if_state := &null
      preproc_word_chars := &letters ++ &digits ++ '_'
      preproc_filename := preproc_include_name := fname
      preproc_line := preproc_print_line := 0
      preproc_print_filename := &null
      preproc_nest_level := 0
      preproc_err_count := 0
      return
   end

   #
   # Clears the values of certain space-consuming variables.
   #
   private preproc_done()
      preproc_sym_table := preproc_if_stack := preproc_file_stack :=
         preproc_filename := preproc_print_filename :=
         preproc_file := preproc_include_set := &null
      return
   end

   #
   # a_Scans a preprocessor directive.
   #
   private preproc_scan_directive()
      local sym,value,new_file,new_filename,new_line,path_list,old
      preproc_space()
      preproc_command := preproc_word()
      if \preproc_if_state then {
         if match("if",preproc_command) then {
            preproc_command := "$if"
         }
      }
      preproc_space()
      case preproc_command of {
         "define": {
            if /preproc_if_state then {
               if sym := preproc_word() &
                  value := preproc_scan_define_value() then {
                     if \(old := preproc_sym_table[sym]) ~=== value then {
                        preproc_error("redefinition of " || sym || " = " ||
                                      old)
                     } else {
                        preproc_sym_table[sym] := value
                     }
            } else {
               preproc_error()
            }
         }
      }
      "undef": {
         if /preproc_if_state then {
            if sym := preproc_word() &
               preproc_at_end() then {
                  delete(preproc_sym_table,sym)
               } else {
                  preproc_error()
               }
         }
      }
      "ifdef" | "ifndef": {
         push(preproc_if_stack,preproc_if_state)
         if sym := preproc_word() &
            preproc_at_end() then {
               if /preproc_if_state then {
                  value := (\preproc_sym_table[sym] & &null) | "false"
                  if match("n",preproc_command,3) then {
                     value := (\value & &null) | "false"
                  }
                  preproc_if_state := value
               } else {
                  preproc_if_state := "off"
               }
            } else {
               preproc_if_state := "off"
               preproc_error()
            }
      }
      "$if": {    # handles if... command in "if'd-out" code
         push(preproc_if_stack,preproc_if_state)
         preproc_if_state := "off"
      }
      "else": {
         if preproc_at_end() then {
            if *preproc_if_stack <= preproc_nest_level then {
               preproc_error("no corresponding $if...")
            } else {
               #preproc_if_state := (\preproc_if_state & &null) | "done"
               preproc_if_state := {
                  case preproc_if_state of {
                     "false": &null
                     "off": "off"
                     default: "false"
                  }
               }
            }
         } else {
            preproc_error()
         }
      }
      "endif": {
         if preproc_at_end() then {
            (*preproc_if_stack >= preproc_nest_level &
             preproc_if_state := pop(preproc_if_stack)) |
               preproc_error("no corresponding $if...")
         } else {
            *preproc_if_stack >= preproc_nest_level &
               preproc_if_state := pop(preproc_if_stack)
            preproc_error()
         }
      }
      "include": {
         if /preproc_if_state then {
            path_list := preproc_get_path_list()
            if sym := preproc_qword() & *sym > 0 &
               preproc_at_end() then {
                  if member(preproc_include_set,sym) then {
                     preproc_error("circular reference to " || image(sym))
                  } else {
                     if new_file := open(new_filename := sym | 
                                         Files.get_path(!path_list).get_child(sym).str())
                     then {
                        push(preproc_file_stack,
                             preproc_file,preproc_filename,
                             preproc_include_name,preproc_line,
                             preproc_nest_level)
                        preproc_filename := new_filename
                        preproc_include_name := sym
                        preproc_file := new_file
                        preproc_line := 0
                        preproc_nest_level := *preproc_if_stack
                        insert(preproc_include_set,sym)
                     } else {
                        preproc_error("cannot open " || image(sym))
                     }
                  }
               } else {
                  preproc_error()
               }
         }
      }
      "line": {
         #if /preproc_if_state then {
         if new_line := integer(tab(many(&digits))) &
            preproc_opt_space() &
            (new_filename := preproc_qword() | &null) \ 1 &
            (/new_filename | *new_filename > 0) \ 1 &
            preproc_at_end() then {
               preproc_filename := \new_filename
               preproc_line := new_line
            } else {
               preproc_error()
            }
         #}
      }
      "error": {
         if /preproc_if_state then {
            preproc_space()
            preproc_error(trim(tab(find("#") | 0),' \t\f\r'))
         }
      }
      "ITRACE": {
         if /preproc_if_state then {
            if value := integer(tab(many(&digits ++ "-"))) &
               preproc_at_end() then {
                  &trace := value
               } else {
                  preproc_error()
               }
         }
      }
      default: {
         if /preproc_if_state then {
            preproc_error("unknown preprocessor directive")
         }
      }
   }
      preproc_command := &null
   end

   #
   # a_Scans and make substitutions in a text line.
   #
   private preproc_scan_text(done_set)
      local q,result,p,interesting_in_quotes,ident,value
      static interesting_chars
      initial {
         interesting_chars := '#"\'_' ++ &letters
      }
      if /preproc_if_state then {
         if *preproc_sym_table > 0 then {
            &pos := q := 1
            result := ""
            while tab(upto(interesting_chars)) do {
               case move(1) of {
                  "#": {
                     move(-1)
                     tab(0)
                  }
                  "\"" | "'": {
                     interesting_in_quotes := '\\' ++ &subject[&pos - 1]
                     repeat {
                        while tab(upto(interesting_in_quotes)) do {
                           case move(1) of {
                              "\\": move(1)
                              default: {
                                 break break
                              }
                           }
                        }
                        suspend preproc_sync_lines()
                        suspend if q = 1 then .&subject else
                           result || &subject[q:0]
                        if not match("_",,-1) then {
                           break
                        }
                        &subject := preproc_read() | fail
                        preproc_print_line := preproc_line
                        preproc_line +:= 1
                        result := ""
                     }
                  }
                  default: {
                     move(-1)
                     p := &pos
                     ident := tab(many(preproc_word_chars))
                     if value := \preproc_sym_table[ident] then {
                        if /done_set |
                        {type(done_set) == "string" &
                            done_set := set([done_set])
                         not member(done_set,ident)} then {
                            value ? value :=
                               preproc_scan_text(insert(copy(\done_set),
                                                        ident) | ident)
                            result ||:= &subject[q:p] || value
                            q := &pos
                         }
                     }
                  }
               }
            }
            if /done_set then {
               suspend preproc_sync_lines()
            }
            suspend if q = 1 then .&subject else result || &subject[q:0]
         }
         else {
            suspend preproc_sync_lines()
            suspend .&subject
            #suspend image(preproc_filename) || ":" ||
            #       preproc_line || " " || &subject
         }
         preproc_print_line := preproc_line
      }
   end

   #
   # Reads an input line.  Manages end-of-file and reverting to including
   # file if appropriate, failing at end-of-input.
   #
   private preproc_read()
      local result
      until result := read(preproc_file) do {
         if *preproc_if_stack ~= preproc_nest_level then {
            preproc_error("$if(s) without $endif(s): " ||
                          *preproc_if_stack - preproc_nest_level)
            until *preproc_if_stack <= preproc_nest_level do
               preproc_if_state := pop(preproc_if_stack)
         }
         close(preproc_file)
         delete(preproc_include_set,preproc_include_name)
         (preproc_nest_level := pop(preproc_file_stack) &
          preproc_line := pop(preproc_file_stack) &
          preproc_include_name := pop(preproc_file_stack) &
          preproc_filename := pop(preproc_file_stack) &
          preproc_file := pop(preproc_file_stack)) | fail
      }
      preproc_line +:= 1
      #write(&errout,"+++ ",image(preproc_filename),":",
      #             preproc_line," (",preproc_if_state,"): ",result)
      return result
   end

   #
   # a_Scans an identifier.
   #
   private preproc_word()
      static word_starters
      initial {
         word_starters := &letters ++ '_'
      }
      suspend any(word_starters) & tab(many(preproc_word_chars))
   end

   #
   # a_Scans a possibly-quoted word (e.g. a file name).
   #
   private preproc_qword()
      local result
      suspend (="\"" &
               result := tab(find("\"")) &
               not match("\\",,&pos - 1) &
               move(1) & preproc_istring(result)) |
         preproc_word()
   end

   #
   # a_Scans the value of a $define.
   #
   private preproc_scan_define_value()
      local q,interesting_in_quotes
      static interesting_chars
      initial interesting_chars := '#"\''

      if ="(" then {
         fail      # "$define name(" is specifically prohibited; needs whitespace
      }
      preproc_space()
      q := &pos
      (while tab(upto(interesting_chars)) do {
         case move(1) of {
            "#": {
               move(-1)
               break
            }
            default: {
               interesting_in_quotes := '\\' ++ &subject[&pos - 1]
               repeat {
                  while tab(upto(interesting_in_quotes)) do {
                     case move(1) of {
                        "\\": move(1)
                        default: {
                           break break
                        }
                     }
                  }
                  fail # end of line inside quotes!!
               }
            }
         }
      }) | tab(0)
      return trim(&subject[q:&pos],' \t\f\r')
   end

   #
   # a_Scans white space.
   #
   private preproc_space()
      suspend tab(many(' \t\f\r'))
   end

   #
   # a_Scans optional white space.
   #
   private preproc_opt_space()
      local i
      suspend if i := many(' \t\f\r') then tab(i) else ""
   end

   #
   # Tests for &pos at the logical end of a preprocessor directive.
   #
   private preproc_at_end()
      preproc_space()
      return pos(0) | match("#")
   end

   #
   # a_Returns the list of directories in the OLPATH environment variable.
   #
   private preproc_get_path_list()
      local s
      static the_list
      initial {
         s := getenv("OLPATH") | ""
         the_list := path_list(s)
      }
      return the_list
   end

   #
   # Determines if a "#lines" is called for and generates one if so.
   #
   private preproc_sync_lines()
      local delta
      if preproc_filename ~=== preproc_print_filename then {
         suspend "#line " || preproc_line - 1 || " " || image(preproc_filename)
         preproc_print_filename := preproc_filename
      }
      else {
         delta := preproc_line - preproc_print_line
         #write(&errout,"+++++ preproc_line = ",image(preproc_line),
         #  "; preproc_print_line = ",image(preproc_print_line),
         #  "; delta = ",image(delta))
         if delta ~= 1 then {
            if delta < 20 then {
               suspend 2 to delta & ""
            } else {
               suspend "#line " || preproc_line - 1 || " " ||
                  image(preproc_filename)
            }
         }
      }
      preproc_print_line := preproc_line
   end

   #
   # Makes escape-sequence substitutions in an Icon-type string literal.
   #
   private preproc_istring(s)
      local r,c
      r := ""
      s ? {
         while r ||:= tab(upto('\\')) do {
            move(1)
            r ||:= case c := map(move(1)) of {
               "b": "\b"       # backspace
               "d": "\d"       # delete (rubout)
               "e": "\e"       # escape (altmode)
               "f": "\f"       # formfeed
               "l": "\l"       # linefeed (newline)
               "n": "\n"       # newline (linefeed)
               "r": "\r"       # carriage return
               "t": "\t"       # horizontal tab
               "v": "\v"       # vertical tab
               "x": preproc_istring_radix(16,2)# hexadecimal code
               "^": char(ord(move(1)) % 32) | break # control code
               default: {      # either octal code or non-escaped character
                  if any('01234567',c) then { # if octal digit
                     move(-1)
                     preproc_istring_radix(8,3)
                  }
                  else c          # else non-escaped character
               } | break
            }
         }
         r ||:= tab(0)
      }
      return r
   end

   #
   # Handles character-code specification in string literal.
   #
   private preproc_istring_radix(r,max)
      local n,d,i,c
      d := "0123456789abcdef"[1:r + 1]
      n := 0
      every 1 to max do {
         c := move(1) | break
         if not (i := find(map(c),d) - 1) then {
            move(-1)
            break
         }
         n := n * r + i
      }
      return char(n)
   end
end
