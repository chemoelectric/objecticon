package parser

import 
   util(Connectable, error, check_flag, env_string), 
   lang(),
   io

abstract class Symbol()
   public const
      scanned_file,
      obj,
      name

   public get_package()
      return \scanned_file.pack
   end

   # Return the fully-qualified name of the Symbol.
   public abstract get_fq_name()

   # Return the fully-qualified name of the Symbol, but
   # symbols not in a package are prefixed with "default.".
   public abstract get_fq_name_default()

   package new(scanned_file, obj, name)
      self.scanned_file := scanned_file
      self.obj := obj
      self.name := name
      return
   end
end

abstract class TopLevelSymbol(Symbol)
   public abstract has_package_flag()

   public get_fq_name()
      return (\scanned_file.pack || "." || name) | name
   end

   public get_fq_name_default()
      return (\scanned_file.pack || "." || name) | ("default." || name)
   end
end

class ProcedureSymbol(TopLevelSymbol)
   public has_package_flag()
      if is(obj, Tree) then
         return obj.get_package_flag()
      else
         return \obj.package_flag
   end
end

class BuiltinSymbol(TopLevelSymbol)
   public has_package_flag()
   end

   package new(name)
      self.name := name
      return
   end
end

class RecordSymbol(TopLevelSymbol)
   public has_package_flag()
      if is(obj, Tree) then
         return obj.get_package_flag()
      else
         return \obj.package_flag
   end
end

class GlobalSymbol(TopLevelSymbol)
   public const
      decl_obj

   public has_package_flag()
      # Check the "global" node (rather than the ident node).
      if is(decl_obj, Tree) then
         return decl_obj.get_package_flag()
      else
         return \decl_obj.package_flag
   end

   public has_readable_flag()
      # Check the "global" node (rather than the ident node).
      if is(decl_obj, Tree) then
         return decl_obj.get_readable_flag()
      else
         return \decl_obj.readable_flag
   end

   package new(scanned_file, obj, name, decl_obj)
      Symbol.new(scanned_file, obj, name)
      self.decl_obj := decl_obj
      return
   end
end

class ClassSymbol(TopLevelSymbol)
   package
      fields,
      supers,
      resolved_supers, 
      implemented_fields,
      implemented_classes

   public get_supers()
      suspend .!supers
   end

   public add_super(s)
      put(supers, s)
      return self
   end

   public get_resolved_supers()
      suspend .!resolved_supers
   end

   package add_resolved_super(c)
      put(self.resolved_supers, c)
      return self
   end

   public get_implemented_fields()
      suspend .!self.implemented_fields
   end

   public get_implemented_field(n)
      return member(implemented_fields, n)
   end

   public get_implemented_classes()
      suspend .!self.implemented_classes
   end

   package add_implemented_class(c)
      local f
      put(self.implemented_classes, c)
      every f := !c.fields do
         member(implemented_fields, f.name) | insert(implemented_fields, f.name, f)
   end

   public get_field(n)
      return member(fields, n)
   end

   public get_fields()
      suspend .!self.fields
   end

   package add_field(f)
      insert(fields, f.name, f)
      return self
   end

   public has_package_flag()
      if is(obj, Tree) then
         return obj.get_package_flag()
      else
         return \obj.package_flag
   end

   public is_final()
      if is(obj, Tree) then
         return obj.get_access().gen().str() == "final"
      else
         return iand(obj.flags, Class.Final) ~= 0
   end

   public is_abstract()
      if is(obj, Tree) then
         return obj.get_access().gen().str() == "abstract"
      else
         return iand(obj.flags, Class.Abstract) ~= 0
   end

   package new(scanned_file, obj, name)
      Symbol.new(scanned_file, obj, name)
      self.fields := table()
      self.supers := []
      self.resolved_supers := []
      self.implemented_fields := table()
      self.implemented_classes := []
      return
   end
end

class ClassField(Symbol)
   public const
      defining_class

   public get_fq_name()
      return defining_class.get_fq_name() || "." || name
   end

   public get_fq_name_default()
      return defining_class.get_fq_name_default() || "." || name
   end

   package new(defining_class, obj, name)
      Symbol.new(defining_class.scanned_file, obj, name)
      self.defining_class := defining_class
      return
   end
end

class ClassVariable(ClassField)
   public const
      decl_obj

   package new(defining_class, obj, name, decl_obj)
      ClassField.new(defining_class, obj, name)
      self.decl_obj := decl_obj
      return
   end
end

class ClassMethod(ClassField)
end

class ScannedFile()
   public const
      filename

   private readable
      obj,
      strinv

   private const
      imports,
      invocables,
      resolved_invocables,
      symbols

   private readable
      pack

   package set_obj(obj)
      self.obj := obj
      return self
   end

   package set_package(pack)
      self.pack := pack
      return self
   end
      
   package add_symbol(sym)
      insert(symbols, sym.name, sym)
      return self
   end

   public get_symbol(name)
      return member(symbols, name)
   end

   public get_symbols()
      suspend .!symbols
   end

   package add_import(i)
      insert(imports, i.name, i)
      return self
   end

   public get_import(name)
      return member(imports, name)
   end

   public get_imports()
      suspend .!imports
   end

   public get_resolved_invocables()
      suspend .!resolved_invocables
   end

   package add_resolved_invocable(sym)
      put(resolved_invocables, sym)
      return self
   end

   public get_invocables()
      suspend .!invocables
   end

   package add_invocable(sym)
      put(invocables, sym)
      return self
   end

   package set_strinv(v)
      self.strinv := check_flag(v)
      return self
   end

   public convert_dottedidentexpr(n)
      local ls
      if is(n, Token) then
         return n.s
      ls := Util.dottedid2string(n.child(1))
      if (ls == (\pack | "default")) | member(imports, ls) then
         return ls || "." || n.child(3).s
      return convert_dottedidentexpr(n.child(1))
   end

   package new(filename)
      self.filename := filename
      self.imports := table()
      self.symbols := table()
      self.invocables := []
      self.resolved_invocables := []
      return
   end
end

class ImportDec()
   public const
      qualified,
      name

   private const 
      syms

   package add(sym)
      insert(syms, sym)
   end

   public has(sym)
      return member(syms, sym)
   end

   package new(name, qualified)
      self.name := name
      self.qualified := qualified
      self.syms := set()
      return
   end
end

class SymbolTable(Connectable)
   private
      pparser,
      package_db,
      symbol_table, 
      scanned_files,
      scanned_packages,
      file_mode

   public static const
      SCANNING_EVENT,
      PREFER_SRC,
      PREFER_U,
      ALWAYS_SRC,
      ALWAYS_U

   private static const
      BUILTINS

   private static init()
      SCANNING_EVENT := "scanning"
      PREFER_SRC := "prefer_src"
      PREFER_U := "prefer_u"
      ALWAYS_SRC := "always_src"
      ALWAYS_U := "always_u"
      BUILTINS := set()
      every insert(BUILTINS, lang.Proc.get_name(lang.Prog.get_functions()))
   end

   private parse(f)
      local prog
      prog := pparser.parse_file(f) | fail
      return prog
   end

   public dump()
      local e, f
      every e := !sort(symbol_table) do {
         write(e[1],"->",lang.Class.get_name(e[2]), " in file ", (\e[2].scanned_file).filename | "-")
         if is(e[2], ClassSymbol) then {
            every f := !sort(\e[2].implemented_fields) do {
               write("\t", f[1], "->", lang.Class.get_name(f[2]), " from ", f[2].defining_class.name)
            }
         }
      }
   end

   private add_symbol(sym)
      local k
      k := sym.get_fq_name()
      if \symbol_table[k] then
         return error("Symbol " || k || " already defined in " || symbol_table[k].scanned_file.filename)
      symbol_table[k] := sym
      sym.scanned_file.add_symbol(sym)
      return self
   end

   private get_stem(f)
      if map(f[-4:0]) == ".icn" then
         return f[1:-4]
      if map(f[-2:0]) == ".u" then
         return f[1:-2]
      return f
   end

   private match_stem(f)
      local fu, fi
      fu := f || ".u"
      fi := f || ".icn"
      case file_mode of {
         PREFER_SRC : {
            if Files.access(fi, Access.R_OK) then 
               return fi
            if Files.access(fu, Access.R_OK) then
               return fu
         }
         PREFER_U : {
            if Files.access(fu, Access.R_OK) then
               return fu
            if Files.access(fi, Access.R_OK) then 
               return fi
         }
         ALWAYS_SRC : {
            if Files.access(fi, Access.R_OK) then 
               return fi
         }
         ALWAYS_U : {
            if Files.access(fu, Access.R_OK) then
               return fu
         }
      }
   end

   private scan(f)
      local sf, i, g
      # Standardize by getting rid of the extension
      f := get_stem(f)
      if member(scanned_files, f) then
         return self
      g := match_stem(f) | return error("No .icn or .u file at " || f)
      fire(SCANNING_EVENT, g)
      sf := ScannedFile(g)
      scanned_files[f] := sf
      if map(g[-4:0]) == ".icn" then
         scan_src(sf) | fail
      else
         scan_u(sf) | fail
      if \sf.pack then
         scan_package(sf.pack) | fail
      every i := sf.get_imports() do
         scan_package(i.name) | fail

      return self
   end

   private scan_src(sf)
      local c, d, e, f, s, i, prog

      prog := parse(sf.filename) | fail
      sf.set_obj(prog)

      # Optional package
      sf.set_package(prog.get_package().get_name().str())

      # Any imports
      every e := prog.get_imports().gen().gen() do {
         if is(e, Id) then
            sf.add_import(ImportDec(e.str()))
         else {
            s := e.get_package().str()
            if not(i := sf.get_import(s)) then {
               i := ImportDec(s, 1)
               sf.add_import(i)
            }
            every i.add(e.gen().str())
         }
      }

      # All other decs.
      every d := prog.get_body().gen() do {
         case classof(d) of {
            Global : {
               every s := d.gen() do
                  add_symbol(GlobalSymbol(sf, s, s.str(), d)) | fail
            }
            Procedure : add_symbol(ProcedureSymbol(sf, d, d.get_name().str())) | fail
            Class : {
               c := ClassSymbol(sf, d, d.get_name().str())
               every c.add_super(d.get_supers().gen().str())
               every e := d.get_members().gen() do {
                  case classof(e) of {
                     FieldList: {
                        every f := e.gen() do
                           c.add_field(ClassVariable(c, f, f.str(), e))
                     }
                     DeferredMethod | Method:
                        c.add_field(ClassMethod(c, e, e.get_name().str()))
                  }
               }
               add_symbol(c) | fail
            }

            Record : add_symbol(RecordSymbol(sf, d, d.get_name().str())) | fail
            Invocable : {
               every e := d.gen() do {
                  if is(e, Id) then {
                     s := e.str()
                     if s == "all" then
                        sf.set_strinv(&yes)
                     else {
                        if s[1] == "\"" then
                           s := s[2:-1]
                        sf.add_invocable(s)
                     }
                  }
               }
            }
            default : syserr("Unknown global dec type:" || d)
         }
      }
      return
   end

   private scan_u(sf)
      local s, r, uf, d, c, e
      s := Files.file_to_string(sf.filename) | return error("Couldn't read " || sf.filename)
      r := UReader()
      uf := (s ? r.scan_decls()) | return error("Couldn't scan ufile: " || &why)
      sf.set_obj(uf)
      sf.set_package(uf.pack)
      every sf.add_import(uf.get_imports())
      sf.set_strinv(uf.strinv)
      every sf.add_invocable(uf.get_invocables())
      every d := uf.get_symbols() do {
         case classof(d) of {
            UGlobal : add_symbol(GlobalSymbol(sf, d, d.name, d)) | fail
            UProcedure : add_symbol(ProcedureSymbol(sf, d, d.name)) | fail
            UClass : {
               c := ClassSymbol(sf, d, d.name)
               every c.add_super(d.get_supers())
               every e := d.get_fields() do {
                  case classof(e) of {
                     UMethod :
                        c.add_field(ClassMethod(c, e, e.name))
                     UVariable :
                        c.add_field(ClassVariable(c, e, e.name, e))
                     default :
                        syserr("Unknown type:" || e)
                  }
               }
               add_symbol(c) | fail
            }
            URecord : add_symbol(RecordSymbol(sf, d, d.name)) | fail
            default : syserr("Unknown ufile type:" || d)
         }
      }
      return
   end

   public scan_file(f)
      return scan(FilePath(f).canonical().standard_case().str())
   end

   private ensure_package_db()
      local d, p, s, f
      if \package_db then
         return
      package_db := table()
      every d := Files.getcwd() | Files.split_paths(env_string("OI_PATH")) do {
         p := FilePath(d).canonical().standard_case()
         s := p.str()
         if /package_db[s] then {
            if f := open(p.child("packages.txt").str(), "r") then {
               package_db[s] := scan_packtxt(f) | {
                  f.close()
                  fail
               }
               f.close()
            } else
               package_db[s] := table()
         }
      }
      return
   end

   private scan_packtxt(f)
      local s, t, u
      t := table()
      while s := read(f) do {
         if s == ">package" then {
            s := read(f) | return error("corrupt - package name expected following package")
            if member(t, s) then
               return error("corrupt - duplicate package entry")
            insert(t, s, u := set())
         } else
            insert(\u, s) | return error("corrupt - package expected")
      }
      return t
   end

   public get_all_packages()
      ensure_package_db() | fail
      suspend key(!package_db)
   end

   public scan_package(p)
      local d, fs, seen, f
      if member(scanned_packages, p) then
         return self
      insert(scanned_packages, p)
      ensure_package_db() | fail
      every d := key(package_db) do {
         if fs := \package_db[d, p] then {
            if \seen then
               return error("located package " || p || " in multiple directories")
            every f := FilePath(d).child(!fs).str()  do
               scan(f) | fail
            seen := 1
         }
      }
      if /seen then
         return error("cannot resolve package " || p)
      return self
   end

   public gen_symbol_names()
      suspend key(symbol_table)
   end

   public gen_symbols()
      suspend .!symbol_table
   end

   public add_builtins()
      local x
      every x := !BUILTINS do
         insert(symbol_table, x, BuiltinSymbol(x))
      return self
   end

   public gb_locate(name)
      local x
      if x := glocate(name) then
         return x
      if member(BUILTINS, name) then {
         insert(symbol_table, name, x := BuiltinSymbol(name))
         return x
      }
   end

   public glocate(name)
      return member(symbol_table, name)
   end

   public get_scanned_file(f)
      return member(scanned_files, get_stem(FilePath(f).canonical().standard_case().str()))
   end

   private static check_package_access(sf, sym)
      if sym.has_package_flag() &
         not(is(sym, GlobalSymbol) & sym.has_readable_flag()) &
         sf.pack ~=== "lang" &
         sf.pack ~=== sym.scanned_file.pack then
         fail
      return sym
   end

   public resolve_n(sf, name)
      local r, i, g

      r := []
      name ? if upto('.') then {
         if ="default." then
            name := tab(0)
         put(r, check_package_access(sf, gb_locate(name)))
         return r
      }
      if \sf.pack then
         put(r, glocate(sf.pack || "." || name))
      else
         put(r, gb_locate(name))
      every i := sf.get_imports() do {
         if /i.qualified | i.has(name) then
            put(r, check_package_access(sf, glocate(i.name || "." || name)))
      }
      if \sf.pack & (*r = 0) then {
         if g := gb_locate(name) & is(g, BuiltinSymbol) then
            put(r, g)
      }
      return r
   end

   public resolve(sf, name)
      local l
      l := resolve_n(sf, name) | fail
      if *l = 0 then
         return error("Couldn't resolve symbol " || name)
      if *l > 1 then
         return error("Ambiguous symbol " || name)
      return l[1]
   end

   public resolve_classes()
      resolve_invocables() | fail
      resolve_supers() | fail
      compute_inheritance() | fail
      return self
   end

   public gen_type(c)
      local e
      every e := !symbol_table do
         if is(e, c) then
            suspend e
   end

   private resolve_invocables()
      local sf, s, x
      every sf := !scanned_files do {
         every s := sf.get_invocables() do {
            x := resolve(sf, s) | fail
            sf.add_resolved_invocable(x)
         }
      }
      return
   end

   private resolve_supers()
      local c, sup_name, sup
      every c := gen_type(ClassSymbol) do {
         every sup_name := c.get_supers() do {
            sup := resolve(c.scanned_file, sup_name) | fail
            is(sup, ClassSymbol) | return error("Superclass of " || c.name || " not a class")
            c.add_resolved_super(sup)
         }
      }
      return
   end

   private compute_inheritance()
      local c, queue, seen, x
      every c := gen_type(ClassSymbol) do {
         seen := set()
         queue := [c]
         while x := pop(queue) do {
            if member(seen, x) then
               next
            insert(seen, x)
            c.add_implemented_class(x)
            every put(queue, !x.resolved_supers)
         }
      }
      return
   end

   public set_file_mode(s)
      self.file_mode := s
      return self
   end

   public new()
      Connectable.new()
      symbol_table := table()
      scanned_files := table()
      scanned_packages := set()
      file_mode := PREFER_SRC
      pparser := Parser()
      return
   end
end
