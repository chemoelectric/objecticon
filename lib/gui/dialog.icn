#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

import 
   graphics(Window,Mouse,Key,Selection,Canvas),
   lang,
   ipl.sets,
   ipl.lists,
   ipl.pdco,
   util

#
#
# This is the parent class of a dialog window.
#
class Dialog(Component)
   public static const
      # Table of window attribs applied to all dialogs
      ROOT_WATTRIBS, 
      # Default top-level mouse pointer
      POINTER,
      # Default dnd negative pointer
      DND_NEGATIVE_POINTER,
      # Default dnd positive pointer
      DND_POSITIVE_POINTER,
      # Repeat event delays
      DOUBLE_CLICK_DELAY,
      # Mouse distance tolerance for double clicks
      DOUBLE_CLICK_TOLERANCE,
      # Distance before drag begins
      DRAG_GESTURE_OFFSET,
      # Default tooltip delays
      TOOLTIP_START_DELAY,
      TOOLTIP_END_DELAY,
      TOOLTIP_CONTINUE_DELAY,
      TOOLTIP_X_OFFSET,
      TOOLTIP_Y_OFFSET,
      # Set of additional events (other than shift-tab) to move focus up
      FOCUS_UP,
      # Set of additional events (other than tab) to move focus down
      FOCUS_DOWN

   private readable
      # The dialog's window.
      win,
      # For a popup dialog, this points to the `Dialog` controlling events
      # and other delegated things.  For normal dialogs, it is set to self.
      popup_manager,
      # The parent dialog, from the perspective of the windowing system.
      owning_dialog,
      # The child dialogs, from the perspective of the windowing system.
      child_dialogs,
      # Remember size on closing
      remember_size_flag,
      # Set if this dialog is currently blocked for input.
      is_blocked_flag

   private
      # Table of mouse event codes to components held
      # down for that code.
      held,

      # Do we have a menu open?  If so, this is the governing
      # component.
      menu_mode,
      menu_mode_stack,

      # Popup dialogs managed by this dialog
      popups,
      # Component with current focus
      focus,

      # Is the focus out of the window?
      focus_out_flag,

      # Mouse click count
      click_count,
      crossing,

      # Rectangles that need validation
      invalid_rects,

      # Flag tracking whether mouse has entered the dialog window.
      entered,

      # Components containing current event
      point_chain,
      # Event used to create point_chain
      point_chain_source,

      # Various tooltip processing variables
      tooltip_ticker,
      tooltip_last_obj, 
      tooltip_last_tip, 
      tooltip_last_event, 
      tooltip_state,
      tooltip_start_time,
      tooltip_end_time,
      tooltip_continue_time,
      tooltip_component,

      # Start position of a drag gesture
      drag_gesture_x,
      drag_gesture_y,

      # Drag and drop state variables.
      curr_drag,
      curr_drag_holder,
      curr_drop,
      tried_drag,

      # Current pointer set in win.
      curr_pointer,
      # Previous event for tracking click counts.
      click_event,
      # Table of selections to `SelectionRequest`s
      selection_requests,
      # Table of selections to selection owners.
      selections

   public needs_validate()
      succeed \invalid_rects
   end

   public validate()
      local r, rs

      # Copy invalid_rects just in case invoke_display invalidates something (and hence
      # changes invalid_rects unexpectedly).
      rs := invalid_rects
      invalid_rects := &null

      every r := !\rs do {
         win.hold()
         self.invoke_display(r.x, r.y, r.w, r.h)
         win.restore(r.x, r.y, r.w, r.h)
      }

      link
   end

   #
   # Invalidate the given `Rect`, meaning that area will subsequently be redrawn.
   #
   public invalidate_rect(r)
      local t, i
      unless r.empty() then {
         /invalid_rects := []
         every t := invalid_rects[i := 1 to *invalid_rects] do {
            if t.touches(r) then {
               invalid_rects[i] := t.union(r)
               link
            }
         }
         put(invalid_rects, r)
      }
      link
   end

   # Succeed if the dialog is blocked.
   #
   public is_blocked()
      succeed \self.is_blocked_flag
   end

   # Succeed if the dialog isn't blocked.
   #
   public is_unblocked()
      succeed /self.is_blocked_flag
   end

   # Succeed if the dialog doesn't have the window system focus (see `is_focus_in()`).
   #
   public is_focus_out()
      succeed \self.focus_out_flag
   end

   # Succeed if the dialog has the window system focus.  Note that
   # this is assumed to be the case when a dialog is shown, and the
   # state is thereafter monitored by focus in/out events.
   #
   public is_focus_in()
      succeed /self.focus_out_flag
   end

   # Succeed if the dialog is a popup, managed by another dialog.
   #
   public is_popup()
      succeed popup_manager ~=== self
   end

   # Return the menu mode component, if menu mode is active.
   #
   public get_menu_mode()
      return \popup_manager.menu_mode
   end

   # Return the point chain
   #
   public get_point_chain()
      return \popup_manager.point_chain
   end

   # Return the point chain source, namely the event used to create
   # the point chain.
   #
   public get_point_chain_source()
      return \popup_manager.point_chain_source
   end

   # If a drag is active, return the current drag.
   #
   public get_curr_drag()
      return \popup_manager.curr_drag
   end

   # Succeed iff the sequence of events indicates the mouse is over the
   # dialog.
   public is_entered()
      succeed \popup_manager.entered
   end

   # Set whether the dialog is blocked to mouse/keyboard events.
   #
   public set_is_blocked(s)
      local c, e
      need_flag(s)
      if is_popup() then
         runerr("Cannot use set_is_blocked() on a popup")
      if is_blocked_flag ~===:= s then {
         get_focus().focus_changed()
         e := if /s then Event.RESUMED else Event.INTERRUPTED
         every c := Seq{traverse_postorder()} do
            c.fire(e)
      }
      link
   end

   public on_interrupted()
      if popup_manager === self then {
         exit_menu_mode()
         point_chain := point_chain_source := &null
         clear(crossing)
         clear(held)
         exit_dnd()
         change_pointer()
      }
   end

   # Restore the window, meaning try to de-iconify it, raise it and
   # give it focus all in one go.
   #
   public restore_win()
      link if win.get_canvas() == "iconic" then
         win.set_canvas("normal")
      else
         win.raise().focus()
   end

   #
   # Raise the window
   #
   public raise_win()
      link win.raise()
   end

   #
   # Lower the window
   #
   public lower_win()
      link win.lower()
   end

   #
   # Focus the window
   #
   public focus_win()
      link win.focus()
   end

   #
   # Returns the number of mouse clicks that have occurred
   # consecutively, with each click in the sequence being less
   # than `DOUBLE_CLICK_DELAY` milliseconds apart.  That variable is by default 500
   # milliseconds, but it may be altered by changing `DOUBLE_CLICK_DELAY`.
   #
   public get_click_count()
      return \popup_manager.click_count
   end

   public override compute_absolutes()
      self.x := -self.win.get_dx()
      self.y := -self.win.get_dy()
      self.w := self.win.get_width()
      self.h := self.win.get_height()
   end

   #
   # Change pointer to `s`, which defaults to `POINTER`.
   #
   public change_pointer(s)
      # If we have a popup manager, then we are in mouse grab mode;
      # this means that the pointer for the whole screen comes from
      # the popup manager's window, so we must delegate.
      if popup_manager ~=== self then
         popup_manager.change_pointer(s)
      else {
         /s := POINTER
         if curr_pointer ~===:= s then
            win.set_pointer(curr_pointer)
      }
      link
   end

   #
   # Displays the dialog as a modal dialog.  In other words, window
   # events to any other open dialogs are blocked until the dialog is
   # closed, although the actual dialogs to block is configurable.
   # This method doesn't return until the dialog is closed.
   #
   # :Parameters :
   # :  `d` - The parent dialog.
   # :  `l` - A list of other dialogs to block; defaults to all
   #            currently unblocked dialogs.
   #
   public show_modal(d, l)
      local e
      /l := Dispatcher.list_unblocked()
      # Exit menu mode from all dialogs in l
      every e := !l do {
         if \e.win then
            e.exit_menu_mode()
      }
      # Reduce l to any remaining open windows.
      l := ipl.pdco.List{ ( e := !l, \e.win, e ) }
      self.show(d)
      every (!l).set_is_blocked(&yes)
      Dispatcher.message_loop(self)
      every (!l).set_is_blocked(&no)
      link
   end

   #
   # Called from a `Task`, this method calls `show`, and then
   # waits until the dialog is closed before returning.
   #
   # :Parameters :
   # :  `task` - The current task
   # :  `d` - This optional parameter specifies the parent dialog.
   #
   public show_and_wait(task, d)
      connect_n(create task.notify(), Event.DIALOG_DISPOSED)
      show(d)
      while \win do
         task.sleep()
      link
   end

   #
   # Returns the Icon window associated with the dialog, or fail if unset.
   #
   public get_win()
      return \self.win
   end

   # If this flag is set, then the dialog remembers its size when it
   # is disposed; if it is shown again it will open using the
   # remembered size.
   #
   public set_remember_size(s)
      self.remember_size_flag := need_flag(s)
      link
   end

   # Resize the dialog to the given dimensions.  No events are
   # generated (unless the window system limits the size).
   #
   public resize_win(w, h)
      win.set_size(w, h)
      resize_win_impl()
      link
   end

   public override initially()
      local k
      parent_dialog := self
      effective_is_hidden_flag := is_hidden_flag
      effective_is_shaded_flag := is_shaded_flag
      Gui.style.polish(self)
      held := table()
      crossing := set()
      selections := table()
      selection_requests := table()
      effective_wattribs := table()
      every k := key(wattribs) do {
         if Gui.is_context_attrib(k) then
            effective_wattribs[k] := wattribs[k]
      }
      compute_z_order()
      compute_tab_order()
      cbwin := clone_win_with(win,
                              effective_wattribs)
      every (!children).initially()
   end

   public open_buffer_win()
      local t, k
      # Just set the bare minimum attributes.  dx and dy must be set
      # so that they are propagated into the cbwins.  Drawing
      # attributes like "bg" must not be set, since we may remove them
      # later, and call reset().  We wouldn't then want "bg=blue" to
      # still be stuck in the root buffer window's context.
      t := table()
      every k := WAttrib.DISPLAY | WAttrib.DX | WAttrib.DY do
         t[k] := get_wattrib(k)
      self.win := open_win_with(t)
   end

   #
   # Ensure we have size attributes, setting from the preferred width/height if
   # absent
   # 
   private ensure_size(t)
      local tw
      if member(t, WAttrib.SIZE | WAttrib.GEOMETRY) | (member(t, WAttrib.WIDTH) & member(t, WAttrib.HEIGHT)) then
         fail

      if tw := member(t, WAttrib.WIDTH) then 
         # Got width, need height
         t[WAttrib.HEIGHT] := get_preferred_height(tw)
      else if member(t, WAttrib.HEIGHT) then
         # Got height, need width
         t[WAttrib.WIDTH] :=  get_preferred_width()
      else
         # Need both
         t[WAttrib.SIZE] := [tw := get_preferred_width(), get_preferred_height(tw)]
   end

   public open_visible_win()
      local t, k, pw
      # Apply other attributes to the window before making it visible,
      # in particular the size.  Graphic attributes are excluded (see
      # the comment in open_buffer_win() above).
      t := table()
      every k := key(wattribs) do
         Gui.is_context_attrib(k) | (t[k] := wattribs[k])
      ensure_size(t)
      if pw := (\owning_dialog).win then
         t[WAttrib.TRANSIENT_FOR] := pw
      /t[WAttrib.CANVAS] := "normal"
      apply_window_table(win, t)
   end

   public close_win()
      local t
      t := win.get_references()
      if t[1] ~= 1 then
         runerr("Dialog close_win(): canvas reference count not 1")
      if t[2] ~= 1 then
         runerr("Dialog close_win(): context reference count not 1")
      if \remember_size_flag then
         set_size!win.get_size()
      self.win.close()
      self.win := &null
   end

   #
   # Enter menu mode, with `c` as the controlling component, which
   # must implement the `MenuMode` interface.
   #
   public enter_menu_mode(c)
      if popup_manager ~=== self then
         popup_manager.enter_menu_mode(c) | fail
      else {
         while \menu_mode & not(menu_mode.allow_nested(c)) do
            menu_mode.close_all()
         if \menu_mode then
            put(menu_mode_stack, menu_mode)
         else {
            win.grab_pointer() | fail
            unless win.grab_keyboard() then {
               win.ungrab_pointer()
               fail
            }
            popups := []
         }
         self.menu_mode := c
      }
      link
   end

   # Exit the menu mode formerly begun with `MenuMode` instance `c`.
   # If `c` is `&null`, all menu_modes are exited.
   #
   public exit_menu_mode(c)
      if popup_manager ~=== self then
         popup_manager.exit_menu_mode(c)
      else {
         until c === menu_mode do {
            \menu_mode | runerr("Inconsistent menu mode passed to exit_menu_mode", c)
            menu_mode.close_all()
         }
         if c := pull(menu_mode_stack) then
            menu_mode := c
         else if \menu_mode then {
            win.ungrab_pointer()
            win.ungrab_keyboard()
            menu_mode := popups := &null
         }
      }
      link
   end

   public add_popup(d)
      if popup_manager ~=== self then
         popup_manager.add_popup(d)
      else {
         \popups | runerr("add_popup(), but not  in menu mode.")
         d.popup_manager := self
         push(popups, d)
      }
      link
   end

   public remove_popup(d)
      if popup_manager ~=== self then
         popup_manager.remove_popup(d)
      else {
         \popups | runerr("remove_popup(), but not  in menu mode.")
         d.popup_manager := d
         ldel(popups, d)
      }
      link
   end

   #
   # Return the current keyboard focus of the dialog, or fail if there is no
   # current focus.
   #
   public get_focus()
      return \popup_manager.focus
   end

   #
   # Sets keyboard focus to the given component.
   #
   public set_focus(c, e)
      if popup_manager ~=== self then
         popup_manager.set_focus(c, e)
      else if self.focus ~=== c then {
         (\self.focus).lost_focus(e)
         self.focus := c
         (\self.focus).got_focus(e)
      }
      link
   end

   #
   # Clear the keyboard focus.
   #
   public clear_focus(e)
      return set_focus(, e)
   end

   #
   # This empty method is invoked just after the dialog is displayed for the first time.
   #
   public init_dialog()
   end

   #
   # This empty method may be overridden to add components to the
   # dialog.  Alternatively, components may be added in the
   # dialog's `initially` method.
   #
   public component_setup()
   end

   #
   # This empty method may be overridden.  It is invoked just
   # before the dialog window is closed.
   #
   public end_dialog()
   end

   #
   # Opens the dialog and returns immediately.
   #
   # :Parameters :
   # :  `d` - This optional parameter specifies the parent dialog.
   #   When a parent dialog is closed, its child dialogs are automatically closed.
   #
   public show(d)
      /win | runerr("show() called on open Dialog")
      if \d then {
         insert(d.child_dialogs, self)
         self.owning_dialog := d
      }
      self.component_setup()
      self.open_buffer_win()
      self.initially()
      self.open_visible_win()
      self.resize()
      self.invalidate()
      self.tooltip_init()
      self.init_dialog()
      Dispatcher.add_dialog(self)
      fire(Event.DIALOG_SHOWN)
      link
   end

   public dispose()
      \win | runerr("dispose() called on closed Dialog")
      # If menu_mode is set, then we are the popup manager and a menu is active,
      # so close all menus.
      if \menu_mode then
         exit_menu_mode()
      exit_dnd()
      self.end_dialog()
      every (!child_dialogs).dispose()
      self.dispose_selections()
      self.tooltip_dispose()
      self.finally()
      self.close_win()
      Dispatcher.remove_dialog(self)
      if \self.owning_dialog then {
         delete(self.owning_dialog.child_dialogs, self)
         self.owning_dialog.restore_win()
         self.owning_dialog := &null
      }
      self.point_chain := self.point_chain_source := self.held := 
         self.click_event := self.invalid_rects := self.crossing := 
         self.selections := self.selection_requests := self.focus_out_flag :=
         self.click_count := self.entered := &null
      fire(Event.DIALOG_DISPOSED)
      link
   end

   # Refresh the point chain and pointer, using point_chain_source.
   # This is useful, for example, if a component in the point chain
   # has been removed.
   #
   public resynch_pointer() 
      if popup_manager ~=== self then
         popup_manager.resynch_pointer() | fail
      else if \point_chain_source then {
         # Fail if we have a button currently held down.
         *held = 0 | fail
         create_point_chain(point_chain_source)
         generate_crossing_events(point_chain_source) 
         synch_pointer(point_chain_source)
      }
      link
   end

   private create_point_chain(e)
      local p

      (popup_manager === self) | syserr("popup_manager wrong")

      point_chain := []
      point_chain_source := e
      
      # If we're not "entered" then we have an empty point chain,
      # since the pointer is outside the window (or over an obscured
      # part).
      if /entered | is_hidden() then
         fail

      every p := !\popups do {
         if p.inside(e.x, e.y) then {
            p.build_point_chain(point_chain, e)
            put(point_chain, p)
            break
         }
      }

      # If we have a popup in the point chain, then include the top
      # dialog in the chain (so it is notionally always under the
      # popup).  This ensures that the dialog's tooltips and pointer
      # work consistently.
      if inside(e.x, e.y) | (*point_chain > 0) then {
         if *point_chain = 0 then
            build_point_chain(point_chain, e)
         put(point_chain, self)
      }
   end

   private dispose_selections()
      every (!selections).lost_ownership()
      clear(selections)
   end

   private process_selection_request(l)
      local c, data, target
      target := l[5]
      if c := member(selections, l[4]) then {
         data := case target of {
            Selection.TARGETS_TARGET:
               ipl.pdco.List{ c.get_targets() | Selection.TIMESTAMP_TARGET }
            Selection.TIMESTAMP_TARGET:
               c.get_timestamp()
            default: {
               if c.get_targets() == target then 
                  c.get_content(target)
            }
         }
      }
      win.send_selection_response(l[2], l[3], l[4], l[5], l[6], data)
   end

   private process_selection_clear(l)
      local c
      if c := member(selections, l[2]) then {
         c.lost_ownership()
         delete(selections, l[2])
      }
   end

   private process_selection_response(l)
      local req
      if req := member(selection_requests, l[2]) then {
         if /l[4] | (l[3] ~== req.target_types[1]) then {
            # Null data (indicating failure), or mismatch in type.  Pop off
            # the last requested type.
            pop(req.target_types)
            if *req.target_types > 0 then
               # Try next type
               win.request_selection(l[2], req.target_types[1])
            else {
               # Notify of failure by invoking callback with null data
               delete(selection_requests, l[2])
               req.proc(l[3], &null)
            }
         } else {
            # Success; invoke callback procedure
            delete(selection_requests, l[2])
            req.proc(l[3], l[4])
         }
      }
   end

   private process_invoke_later(l)
      @l[2]
   end

   public own_selection(selection, obj)
      local curr
      if popup_manager ~=== self then
         popup_manager.own_selection(selection, obj)
      else {
         if curr := member(selections, selection) then {
            # Check if current owner is asserting selection.
            if curr ~=== obj then {
               curr.lost_ownership()
               insert(selections, selection, obj)
            }
         } else
            insert(selections, selection, obj)
         obj.set_timestamp(win.own_selection(selection))
      }
      link
   end

   public request_selection(selection, target_types, proc)
      # We copy target_types since process_selection_response() may edit that list.
      insert(selection_requests, selection, SelectionRequest(copy(target_types), proc))
      win.request_selection(selection, target_types[1])
      link
   end

   private check_entered(e)
      # Theoretically, we should only need Mouse.ENTER in the first
      # list here; the others are backups in case the window system
      # doesn't send the ENTER message.
      #
      # Note that we shouldn't get exit events if we have popups,
      # since we are in grab mode, although that isn't the case in
      # win32.
      #
      case e.code of {
         Mouse.MOVEMENT |
            Mouse.LEFT_PRESS |
            Mouse.MIDDLE_PRESS |
            Mouse.RIGHT_PRESS |
            Mouse.ENTER :
            entered := &yes
         Mouse.EXIT :
            entered := &no
      }
   end

   private set_focus_out(f)
      if focus_out_flag ~===:= f then
         get_focus().focus_changed()
      link
   end

   private process_focus_in(l)
      set_focus_out(&no)
      fire(l[1])
   end

   private process_focus_out(l)
      # X is too chatty with focus events for this to be used here.
$if ~ _X_WINDOW_SYSTEM
      exit_menu_mode()
$endif
      set_focus_out(&yes)
      fire(l[1])
   end

   public process_event(l)
      local e
      case l[1] of {
         Selection.REQUEST: process_selection_request(l)
         Selection.CLEAR: process_selection_clear(l)
         Selection.RESPONSE: process_selection_response(l)
         Window.INVOKE_LATER: process_invoke_later(l)
         Window.RESIZE: process_resize(l)
         Window.CLOSE_BUTTON |
            Window.MOVE |
            Window.STATE : fire(l[1])
         Window.FOCUS_IN : process_focus_in(l)
         Window.FOCUS_OUT: process_focus_out(l)

         default: {
            # A popup shouldn't normally get events, but if it does
            # forward the event to the manager.
            (popup_manager === self) |
               return popup_manager.process_event(l)
            e := WinEvent!l
            check_entered(e)
            check_click_count(e)
            create_point_chain(e)

            while \menu_mode do {
               if menu_mode.should_close(e) then {
                  menu_mode.close_all()
                  create_point_chain(e)
               } else
                  break
            }

            if /self.curr_drag then 
               check_dnd(e)
            if \self.curr_drag then
               process_dnd(e)
            else
               process_normal(e)
         }
      }
   end

   #
   # Normal event processing - not dnd
   # 
   private process_normal(e)
      local c, ec, old_n_held

      ec := e.code

      old_n_held := *held
      if member(Mouse.PRESS, ec) then {
         set_focus_out(&no)
         # Note the position of the start of a potential drag
         drag_gesture_x := e.x
         drag_gesture_y := e.y
         if c := (!point_chain).find_focus(e) then
            set_focus(c, e)
      }
      else if /e.release & type(ec) == ("string" | "ucs") then {
         set_focus_out(&no)
         if \e.meta then {
            if c := (!\popups | self).find_accel(ec) then {
               c.handle_accel(e)
               # The handler may have called dispose() or blocked the dialog.
               if /point_chain then
                  fail
            }
         }
      }

      generate_crossing_events(e) 

      #
      # Set the processing flag and re-create the point chain.  This
      # gives fine control to a component that wishes to filter out
      # particular types of events at this stage of processing; for
      # example ComponentScrollArea filters out wheel events under
      # certain circumstances.
      #
      e.processing := &yes
      create_point_chain(e)
      generate_events(e)
      e.processing := &no

      fire(Event.ICON, e)

      #
      # If a handler closed or blocked this dialog, do no more.
      #
      if /point_chain then
         fail

      #
      # Check for focus keyboard movement, but not in menu mode; this would get muddled up
      # with the menu's cursor movement.
      #
      if /e.release & /menu_mode then {
         if ((ec === "\t" & /e.shift) | member(FOCUS_DOWN, ec)) &
            (/focus | 
             focus.is_hidden() |
             focus.is_shaded() | 
             not(focus.keeps(e)))
         then 
            set_focus(find_next_focus(e), e)
         else if ((ec === "\t" & \e.shift) | member(FOCUS_UP, ec)) &
            (/focus | 
             focus.is_hidden() |
             focus.is_shaded() | 
             not(focus.keeps(e)))
         then 
            set_focus(find_previous_focus(e), e)
      }

      #
      # The event may have changed what's above the cursor, eg a menu may have
      # closed revealing something below, so re-create the point chain.
      #
      create_point_chain(e)
      generate_crossing_events(e)
      process_tooltip_event(e)

      #
      # Synch the pointer if either there were no buttons down before or after
      # this event.  This means we synch at the start and end of a drag, but not
      # during a drag.
      #
      if (old_n_held | *held) = 0 then
         synch_pointer(e)
   end

   #
   # Artificially "hold" a component down.
   # :Parameters :
   # :  `c` - The component
   # :  `ec` - The simulated mouse event code
   #
   public hold(c, ec)
      if popup_manager ~=== self then
         popup_manager.hold(c, ec) | fail
      else {
         held[ec] := copy(member(held, ec)) | fail
         put(held[ec], c)
      }
      link
   end

   #
   # Artificially "release" a component which is held.
   # :Parameters :
   # :  `c` - The component
   # :  `ec` - The simulated mouse event code
   #
   public release(c, ec)
      if popup_manager ~=== self then
         popup_manager.release(c, ec) | fail
      else {
         held[ec] := copy(member(held, ec)) | fail
         ldel(held[ec], c)
      }
      link
   end

   #
   # Return the number of buttons presently held down.
   #
   public get_held_count()
      return *popup_manager.held
   end

   #
   # Return the list of components held for the given mouse event.
   #
   public get_held(e)
      return member(popup_manager.held, e)
   end

   private generate_crossing_events(e) 
      local t
      t := crossing
      crossing := elementset(point_chain)
      fire_list(t -- crossing, Event.MOUSE_EXIT, e)
      fire_list(crossing -- t, Event.MOUSE_ENTER, e)
      fire_list(point_chain, Event.IN_POINT_CHAIN, e)      
   end

   private generate_events(e)
      local ec, t
      ec := e.code
      if integer(ec) < 0 then {
         # Mouse event
         if member(Mouse.WHEEL, ec) then {
            fire_list(point_chain, ec, e)
         } else if member(Mouse.PRESS, ec) then {
            held[ec] := point_chain
            fire_list(point_chain, ec, e)
         } else if ec === Mouse.DRAG then {
            every t := key(held) do {
               fire_list(point_chain, 200 - t, e)
               fire_list(held[t], 10 - t, e)
            }
         } else if ec === Mouse.MOVEMENT then {
            fire_list(point_chain, ec, e)
         } else if member(Mouse.RELEASE, ec) then {
            if t := member(held, ec + 3) then {
               delete(held, ec + 3)
               fire_list(point_chain, 200 - ec, e)
               fire_list(t, ec, e)
            }
         }
      } else {
         # Keyboard event
         fire_list([\menu_mode | \focus] \ 1,
                   if \e.release then Event.KEY_RELEASE else Event.KEY_PRESS,
                   e)
      }
   end

   private fire_list(l, t, p)
      local c
      every c := !l do {
         if c.is_initialized() & c.is_unshaded() & c.is_unhidden() then
            c.fire(t, p)
      }
   end

   #
   # Initialize the tooltip state and ticker.
   # 
   private tooltip_init()
      if popup_manager === self then
         tooltip_ticker.start()
   end

   #
   # Cleanup the tooltip settings.
   # 
   private tooltip_dispose()
      self.tooltip_ticker.stop()
      reset_tooltip_state()
   end

   #
   # Show the tooltip at the given event position.  If e is null, then we update
   # the current tooltip based on its current location.
   # 
   private show_tooltip(obj, tip, e)
      local d, dim, ox, oy, rs
      if \self.tooltip_component then {
         ox := tooltip_component.x
         oy := tooltip_component.y
         hide_tooltip()
      }
      self.tooltip_component := obj.create_tooltip_component(tip)
      if /e then  
         self.tooltip_component.set_pos(ox + win.get_dx(),
                                        oy + win.get_dy())
      else
         self.tooltip_component.set_pos(e.x + win.get_dx() + TOOLTIP_X_OFFSET, 
                                        e.y + win.get_dy() + TOOLTIP_Y_OFFSET)
      self.tooltip_component.set_z(get_top_z())
      self.add(self.tooltip_component)
      self.tooltip_component.resize()

      dim := win.get_display_size()
      # Screen rectangle, in adjusted co-ordinates
      rs := Rect(-win.get_x() - win.get_dx(), -win.get_y() - win.get_dy(), dim.width, dim.height)

      #
      # Ensure it's in area; adjust and resize again if not.
      #
      if self.tooltip_component.x + self.tooltip_component.w > rs.x + rs.w then {
         tooltip_component.set_x(if /e then win.get_dx() + max(rs.x, rs.x + rs.w - self.tooltip_component.w)
                                 else win.get_dx() + max(rs.x, e.x - TOOLTIP_X_OFFSET - self.tooltip_component.w)).
                           resize()
      }
      if self.tooltip_component.y + self.tooltip_component.h > rs.y + rs.h then {
         tooltip_component.set_y(if /e then win.get_dy() + max(rs.y, rs.y + rs.h - self.tooltip_component.h)
                                 else win.get_dy() + max(rs.y, e.y - TOOLTIP_Y_OFFSET - self.tooltip_component.h)).
                           resize()
      }

      # Note that if we have popups, we use a popup for a tooltip, so that it won't appear
      # below the other popup window.
      if Gui.allow_internal_popups() &
         contains(tooltip_component) & (/popups | *popups = 0) then {
         self.tooltip_component.invalidate()
      } else {
         self.remove(self.tooltip_component)
         d := PureDialog().
            set_canvas(Canvas.POPUP).
            set_width( self.tooltip_component.w).
            set_height(self.tooltip_component.h).
            set_dx(-self.tooltip_component.x).
            set_dy(-self.tooltip_component.y).
            set_x(win.get_x() + win.get_dx() + self.tooltip_component.x).
            set_y(win.get_y() + win.get_dy() + self.tooltip_component.y).
            copy_wattrib(WAttrib.DISPLAY, self).
            add(self.tooltip_component)
         self.tooltip_component.set_pos(0, 0)
         d.show()
      }
   end

   #
   # Hide the tooltip label.
   # 
   private hide_tooltip()
      if self.tooltip_component.parent_dialog === self then {
         self.tooltip_component.invalidate()
         self.remove(self.tooltip_component)
      } else {
         self.tooltip_component.parent_dialog.dispose()
      }
      self.tooltip_component := &null
   end

   #
   # Reset the tooltip state, hiding the tooltip if necessary.
   #
   private reset_tooltip_state()
      if tooltip_state = 2 then
         hide_tooltip()
      tooltip_state := 0
      tooltip_last_obj := tooltip_last_tip := tooltip_last_event := &null
   end

   #
   # Tooltip processing on a tick.
   # 
   private process_tooltip_tick()
      local t
      repeat {
         (popup_manager === self) | syserr("Shouldn't have a tooltip ticker in a popup")

         if \is_blocked_flag then
            # See notes as to why this is better than just hiding & setting state to 0.
            reset_tooltip_state()
         else {
            t := Prog.get_runtime_millis()
            case self.tooltip_state of {
               1 : 
                  if t >= self.tooltip_start_time then {
                     show_tooltip(self.tooltip_last_obj, self.tooltip_last_tip, self.tooltip_last_event)
                     self.tooltip_state := 2
                     self.tooltip_end_time := (t + \self.tooltip_last_obj.get_tooltip_end_delay()) | &null
                  }

               2 :
                  if t >= \self.tooltip_end_time then {
                     hide_tooltip()
                     self.tooltip_state := 0
                     self.tooltip_continue_time := t + TOOLTIP_CONTINUE_DELAY
                  }

               3 : 
                  if t >= self.tooltip_continue_time then
                     self.tooltip_state := 0
            }
         }
         tooltip_ticker.sleep(200)
      }
   end

   #
   # Tooltip processing during an event.
   # 
   private process_tooltip_event(e)
      local obj, c, tip, t

      # We should in fact not get events in the blocked state.
      if \is_blocked_flag then
         fail
      unless (e.code === Mouse.MOVEMENT) | (*held = 0 & member(Mouse.CROSSING, e.code)) then {
         if tooltip_state = 2 then
            hide_tooltip()
         tooltip_state := 0
         fail
      }

      # Get current tip/object, if any.  If mouse over current tip
      # component, retain current object and tip.
      #
      if (\tooltip_component).in_region(e) then {
         tip := tooltip_last_tip
         obj := tooltip_last_obj
      } else {
         every c := !point_chain do {
            if tip := c.get_tooltip(e) then {
               obj := c
               break
            }
         }
      }

      t := Prog.get_runtime_millis()
      case self.tooltip_state of {
         0 : {
            if (\obj ~=== self.tooltip_last_obj) |
               (\tip ~=== self.tooltip_last_tip) then {
               self.tooltip_start_time := t + obj.get_tooltip_start_delay()
               self.tooltip_state := 1
            }
         }
         1 : {
            if (obj ~=== self.tooltip_last_obj) | 
               (tip ~=== self.tooltip_last_tip) then {
               if /obj then
                  self.tooltip_state := 0
               else
                  self.tooltip_start_time := t + obj.get_tooltip_start_delay()
            }
         }
         2 : {
            if obj ~=== self.tooltip_last_obj then {
               if /obj then {
                  hide_tooltip()
                  self.tooltip_state := 3
                  self.tooltip_continue_time := t + TOOLTIP_CONTINUE_DELAY
               } else {
                  show_tooltip(obj, tip, e)
                  self.tooltip_end_time := (t + \obj.get_tooltip_end_delay()) | &null
               }
            } else if tip ~=== self.tooltip_last_tip then {
               show_tooltip(obj, tip, e)
               self.tooltip_end_time := (t + \obj.get_tooltip_end_delay()) | &null
            }
         }
         3 : {
            if \obj ~=== self.tooltip_last_obj then {
               show_tooltip(obj, tip, e)
               self.tooltip_state := 2
               self.tooltip_end_time := (t + \obj.get_tooltip_end_delay()) | &null
            }
         }
      }

      self.tooltip_last_obj := obj
      self.tooltip_last_tip := tip
      self.tooltip_last_event := e
   end

   #
   # Synch the mouse cursor pointer with the component it's over.
   #
   public synch_pointer(e)
      local c, ptr
      if popup_manager ~=== self then
         popup_manager.synch_pointer(e)
      else {
         every c := !\point_chain do {
            if c.is_unshaded() & (ptr := c.get_pointer(e)) then
               break
         }
         # ptr may now be null, in which case it defaults to POINTER
         change_pointer(ptr)
      }
      link
   end

   #
   # Exit dnd mode.
   #
   private exit_dnd(e)
      \curr_drag | fail
      (\curr_drag_holder).drag_reset(e)
      curr_drag_holder := curr_drop := curr_drag := &null
      if \e then {
         generate_crossing_events(e)
         if member(held, -1) then
            change_pointer()
         else
            synch_pointer(e)
      }
   end

   #
   # Drag & drop mode processing
   # 
   private process_dnd(e)
      local ec

      ec := e.code
      #
      # Wheel events are treated normally and then passed on as though
      # they were a drag event, in order to keep the drag holder
      # display in synch.
      #
      if member(Mouse.WHEEL, ec) then {
         # For consistency, mimic what happens in process_normal()
         e.processing := &yes
         create_point_chain(e)
         fire_list(point_chain, ec, e)
         e.processing := &no
         create_point_chain(e)
      }

      if (ec === Mouse.DRAG) | member(Mouse.WHEEL, ec) then {
         # Try the drag holder's drag_event method first...
         unless (\curr_drag_holder).drag_event(curr_drag, e) then {
            # No luck with the drag holder, so try to search for a new drag holder.
            curr_drag_holder := invoke_drag_event(curr_drag, e) | &null
         }
         update_drop(e)
      } else if ec === curr_drag.button - 3 then {
         # If we have a prospective drop from can_drop, try to perform it.
         if (\curr_drop).get_source().perform_drop(curr_drag, curr_drop, e) then
            curr_drag.get_source().end_drag(curr_drag, curr_drop, e)
         delete(held, ec + 3)
         exit_dnd(e)
      } else if /e.release & (ec === "\e") then {
         held[curr_drag.button] := []            # Replace held entry for current drag button
         exit_dnd(e)
      } else if member(Mouse.PRESS, ec) then          # Keep held consistent if other mouse
         held[ec] := []                               # buttons are pressed/released during the drag
      else if member(Mouse.RELEASE, ec) then
         delete(held, ec + 3)

      fire(Event.ICON, e)
   end

   #
   # This method can be invoked to update the current drag in respect
   # of whether or not there is a current drop.  The mouse pointer is
   # updated accordingly.  This may be necessary if a component
   # changes whether a drop is available independent of an drag event
   # (eg on a scrolling ticker).
   #
   # :Parameters :
   # :  `e` - The event concerned, if any.
   #
   public update_drop(e)
      local o
      if popup_manager ~=== self then
         popup_manager.update_drop(e)
      else {
         # If we have a drag holder, see if it can drop here.
         if o := (\curr_drag_holder).can_drop(curr_drag, e) then {
            change_pointer("dnd positive")
            curr_drop := Drag(curr_drag_holder, o, e, curr_drag.button)
         } else {
            change_pointer("dnd negative")
            curr_drop := &null
         }
      }
      link
   end

   #
   # Check whether we should start a dnd (by setting curr_drag)
   # 
   private check_dnd(e)
      \self.win | fail
      #
      # There must be only one button held, and the event must be
      # a drag.
      #
      if (*self.held = 1) & (e.code === Mouse.DRAG) then {
         if /self.tried_drag &
            (abs(e.x - \drag_gesture_x) > DRAG_GESTURE_OFFSET |
             abs(e.y - \drag_gesture_y) > DRAG_GESTURE_OFFSET ) then {
                # Try to begin a drag.
                self.curr_drag := self.invoke_can_drag(e) 
                self.tried_drag := &yes
                if \self.curr_drag then {
                   self.curr_drag.get_source().define_dnd_pointers(self.curr_drag)
                   change_pointer("dnd negative")
                }
             }
      } else
         self.tried_drag := &null
   end

   private invoke_can_drag(ev)
      local c, o, kc
      kc := key(held)   # The only button pressed
      every c := !held[kc] do
         if c.is_unshaded() & \c.allow_drag_flag & o := c.can_drag(ev) then
            return Drag(c, o, ev, kc)
   end

   private invoke_drag_event(d, ev)
      local c
      every c := !self.point_chain do
         if c.is_unshaded() & \c.allow_drop_flag & c.drag_event(d, ev) then
            return c
   end

   private resize_win_impl()
      resize()
      invalidate()
   end

   #
   # Process a resize 
   # 
   private process_resize(l)
      resize_win_impl()
      fire(l[1])
   end

   #
   # Maybe increment or clear the click count
   # 
   private check_click_count(e)
      if member(Mouse.PRESS, e.code) then {
         if e.code = (\click_event).code & 
            abs(click_event.x - e.x) < DOUBLE_CLICK_TOLERANCE &
            abs(click_event.y - e.y) < DOUBLE_CLICK_TOLERANCE & 
            e.time - click_event.time < DOUBLE_CLICK_DELAY then
            click_count +:= 1
         else
            click_count := 1
         click_event := e
      } else if e.code ~=== Mouse.MOVEMENT & *held = 0 then
         click_count := click_event := &null
   end

   private get_focus_list(e)
      local l, c
      l := []
      every c := Seq{traverse_tab_order()} do {
         if c === self.focus | (c.accepts_focus(e) & c.is_unhidden() & c.is_unshaded()) then
            put(l, c)
      }
      return l
   end

   private find_next_focus(e)
      local l, i
      l := get_focus_list(e)
      every i := 1 to *l - 1 do {
         if l[i] === self.focus then
            return l[i + 1]
      }
      return l[1]
   end

   private find_previous_focus(e)
      local l, i
      l := get_focus_list(e)
      every i := 2 to *l do {
         if l[i] === self.focus then
            return l[i - 1]
      }
      return l[-1]
   end

   #
   # This method adds an otherwise meaningless event to the window's event
   # queue.  When that event comes to be processed, the given co-expression
   # is activated.
   #
   # This is useful if you need to take some action from within an event
   # handler method, but that action has to take place after the current
   # event has completed processing.
   #
   # :Parameters :
   # :  `coex` - The co-expression to activate
   #
   public invoke_later(coex)
      put_n(win.pending(), Window.INVOKE_LATER, coex)
      link
   end

   #
   # This is like `invoke_later`, except that the event is pushed on
   # the front of the event queue, rather than at the back.  Thus, the
   # event will be processed before, rather than after, any other
   # events currently on the queue.
   #
   # :Parameters :
   # :  `coex` - The co-expression to activate
   #
   public invoke_sooner(coex)
      push_n(win.pending(), Window.INVOKE_LATER, coex)
      link
   end

   #
   # Set the `WAttrib.LABEL` attribute; see `set_wattrib()`.
   #
   public set_label(v)
      return set_wattrib(WAttrib.LABEL, v)
   end

   #
   # Set the `WAttrib.CANVAS` attribute; see `set_wattrib()`.
   #
   public set_canvas(v)
      return set_wattrib(WAttrib.CANVAS, v)
   end

   #
   # Set the `WAttrib.X` attribute; see `set_wattrib()`.
   #
   public override set_x(v)
      return set_wattrib(WAttrib.X, v)
   end

   #
   # Set the `WAttrib.POS` attribute; see `set_wattrib()`.
   #
   public override set_pos(v1, v2)
      return set_wattrib(WAttrib.POS, [v1, v2])
   end

   #
   # Set the `WAttrib.Y` attribute; see `set_wattrib()`.
   #
   public override set_y(v)
      return set_wattrib(WAttrib.Y, v)
   end

   #
   # Set the `WAttrib.RESIZE` attribute; see `set_wattrib()`.
   #
   public set_resize(v)
      return set_wattrib(WAttrib.RESIZE, v)
   end

   #
   # Set the `WAttrib.SIZE` attribute; see `set_wattrib()`.
   #
   public override set_size(v1, v2)
      return set_wattrib(WAttrib.SIZE, [v1, v2])
   end

   #
   # Set the `WAttrib.HEIGHT` attribute; see `set_wattrib()`.
   #
   public override set_height(v)
      return set_wattrib(WAttrib.HEIGHT, v)
   end

   #
   # Set the `WAttrib.WIDTH` attribute; see `set_wattrib()`.
   #
   public override set_width(v)
      return set_wattrib(WAttrib.WIDTH, v)
   end

   #
   # Set the `WAttrib.DISPLAY` attribute; see `set_wattrib()`.
   #
   public set_display(v)
      return set_wattrib(WAttrib.DISPLAY, v)
   end

   #
   # Set the `WAttrib.ICON` attribute; see `set_wattrib()`.
   #
   public set_icon(v)
      return set_wattrib(WAttrib.ICON, v)
   end

   #
   # Set the `WAttrib.GEOMETRY` attribute; see `set_wattrib()`.
   #
   public override set_geometry(v1, v2, v3, v4)
      return set_wattrib(WAttrib.GEOMETRY, [v1, v2, v3, v4])
   end

   #
   # Set the `WAttrib.DX` attribute; see `set_wattrib()`.
   #
   public set_dx(v)
      return set_wattrib(WAttrib.DX, v)
   end

   #
   # Set the `WAttrib.DY` attribute; see `set_wattrib()`.
   #
   public set_dy(v)
      return set_wattrib(WAttrib.DY, v)
   end

   #
   # Set the `WAttrib.MIN_WIDTH` attribute; see `set_wattrib()`.
   #
   public set_min_width(v)
      return set_wattrib(WAttrib.MIN_WIDTH, v)
   end

   #
   # Set the `WAttrib.MIN_HEIGHT` attribute; see `set_wattrib()`.
   #
   public set_min_height(v)
      return set_wattrib(WAttrib.MIN_HEIGHT, v)
   end

   #
   # Set the `WAttrib.MIN_SIZE` attribute; see `set_wattrib()`.
   #
   public set_min_size(v1, v2)
      return set_wattrib(WAttrib.MIN_SIZE, [v1, v2])
   end

   #
   # Set the `WAttrib.MAX_WIDTH` attribute; see `set_wattrib()`.
   #
   public set_max_width(v)
      return set_wattrib(WAttrib.MAX_WIDTH, v)
   end

   #
   # Set the `WAttrib.MAX_HEIGHT` attribute; see `set_wattrib()`.
   #
   public set_max_height(v)
      return set_wattrib(WAttrib.MAX_HEIGHT, v)
   end

   #
   # Set the `WAttrib.MAX_SIZE` attribute; see `set_wattrib()`.
   #
   public set_max_size(v1, v2)
      return set_wattrib(WAttrib.MAX_SIZE, [v1, v2])
   end

   #
   # Set the `WAttrib.BASE_WIDTH` attribute; see `set_wattrib()`.
   #
   public set_base_width(v)
      return set_wattrib(WAttrib.BASE_WIDTH, v)
   end

   #
   # Set the `WAttrib.BASE_HEIGHT` attribute; see `set_wattrib()`.
   #
   public set_base_height(v)
      return set_wattrib(WAttrib.BASE_HEIGHT, v)
   end

   #
   # Set the `WAttrib.BASE_SIZE` attribute; see `set_wattrib()`.
   #
   public set_base_size(v1, v2)
      return set_wattrib(WAttrib.BASE_SIZE, [v1, v2])
   end

   #
   # Set the `WAttrib.INCREMENT_WIDTH` attribute; see `set_wattrib()`.
   #
   public set_increment_width(v)
      return set_wattrib(WAttrib.INCREMENT_WIDTH, v)
   end

   #
   # Set the `WAttrib.INCREMENT_HEIGHT` attribute; see `set_wattrib()`.
   #
   public set_increment_height(v)
      return set_wattrib(WAttrib.INCREMENT_HEIGHT, v)
   end

   #
   # Set the `WAttrib.INCREMENT_SIZE` attribute; see `set_wattrib()`.
   #
   public set_increment_size(v1, v2)
      return set_wattrib(WAttrib.INCREMENT_SIZE, [v1, v2])
   end

   #
   # Set the `WAttrib.MAX_ASPECT_RATIO` attribute; see `set_wattrib()`.
   #
   public set_max_aspect_ratio(v)
      return set_wattrib(WAttrib.MAX_ASPECT_RATIO, v)
   end

   #
   # Set the `WAttrib.MIN_ASPECT_RATIO` attribute; see `set_wattrib()`.
   #
   public set_min_aspect_ratio(v)
      return set_wattrib(WAttrib.MIN_ASPECT_RATIO, v)
   end

   private static init()
      ROOT_WATTRIBS := table()
      insert(ROOT_WATTRIBS, WAttrib.BG,  env_color("OI_DIALOG_ROOT_BG"))
      insert(ROOT_WATTRIBS, WAttrib.FG,  env_color("OI_DIALOG_ROOT_FG"))
      insert(ROOT_WATTRIBS, WAttrib.FONT,  env_font("OI_DIALOG_ROOT_FONT"))
      insert(ROOT_WATTRIBS, WAttrib.LEADING,  env_real("OI_DIALOG_ROOT_LEADING", 0.0))
      DOUBLE_CLICK_DELAY := env_int("OI_DIALOG_DOUBLE_CLICK_DELAY", 1) | 500
      DOUBLE_CLICK_TOLERANCE := env_scale("OI_DIALOG_DOUBLE_CLICK_TOLERANCE") | Gui.UNIT
      TOOLTIP_START_DELAY := env_int("OI_DIALOG_TOOLTIP_START_DELAY", 1) | 1000
      TOOLTIP_END_DELAY := env_int("OI_DIALOG_TOOLTIP_END_DELAY", 1) | 4000
      TOOLTIP_CONTINUE_DELAY := env_int("OI_DIALOG_TOOLTIP_CONTINUE_DELAY", 1) | 1500
      TOOLTIP_X_OFFSET := env_scale("OI_DIALOG_TOOLTIP_X_OFFSET") | scale(5)
      TOOLTIP_Y_OFFSET := env_scale("OI_DIALOG_TOOLTIP_Y_OFFSET") | scale(25)
      DRAG_GESTURE_OFFSET := env_scale("OI_DIALOG_DRAG_GESTURE_OFFSET") | scale(4)
      POINTER := env_pointer("OI_DIALOG_POINTER") | "left ptr"
      DND_NEGATIVE_POINTER := env_pointer("OI_DIALOG_DND_NEGATIVE_POINTER") | "circle"
      DND_POSITIVE_POINTER := env_pointer("OI_DIALOG_DND_POSITIVE_POINTER") | "hand2"
      FOCUS_UP := set(Key.LEFT, Key.UP)
      FOCUS_DOWN := set(Key.RIGHT, Key.DOWN)
   end

   public override new()
      Component.new()
      self.set_all_wattribs(ROOT_WATTRIBS)
      self.child_dialogs := set()
      self.menu_mode_stack := []
      self.tooltip_ticker := Dispatcher.new_task{self.process_tooltip_tick()}
      self.tooltip_state := 0
      self.popup_manager := self
      connect(on_interrupted, Event.INTERRUPTED)
      return
   end
end

#
# This is just a `Dialog` which doesn't have its set of window attribs
# initialized to `Dialog.ROOT_WATTRIBS`; rather it starts with an
# empty set of attribs.
#
class PureDialog(Dialog)
   public override new()
      Dialog.new()
      self.clear_wattribs()
      return
   end
end

class WinEvent(Point)
   public
      code,
      shift,
      lock,
      ctrl,
      meta,
      meta2,
      meta3,
      meta4,
      meta5,
      release,
      time,
      processing

   public override new(code, x, y, time, mod)
      self.code := code
      self.x := x
      self.y := y
      self.time := time
      if mod ~= 0 then {
         self.shift := if iand(mod, Key.MOD_SHIFT) = Key.MOD_SHIFT then &yes
         self.lock := if iand(mod, Key.MOD_LOCK) = Key.MOD_LOCK then &yes
         self.ctrl := if iand(mod, Key.MOD_CTRL) = Key.MOD_CTRL then &yes
         self.meta := if iand(mod, Key.MOD_META) = Key.MOD_META then &yes
         self.meta2 := if iand(mod, Key.MOD_META2) = Key.MOD_META2 then &yes
         self.meta3 := if iand(mod, Key.MOD_META3) = Key.MOD_META3 then &yes
         self.meta4 := if iand(mod, Key.MOD_META4) = Key.MOD_META4 then &yes
         self.meta5 := if iand(mod, Key.MOD_META5) = Key.MOD_META5 then &yes
         self.release := if iand(mod, Key.MOD_RELEASE) = Key.MOD_RELEASE then &yes
      }
      return
   end
end

class SelectionRequest()
   public const
      proc,
      target_types

   public new(target_types, proc)
      self.proc := proc
      self.target_types := target_types
      return
   end
end

abstract class SelectionOwner()
   private timestamp

   public get_timestamp()
      return .timestamp
   end

   public set_timestamp(t)
      timestamp := need_integer(t)
      link
   end

   public abstract get_content(target)
   public abstract lost_ownership()
   public abstract get_targets()
end

abstract class TextSelectionOwner(SelectionOwner)
   protected abstract get_text()

   public override get_targets()
      suspend Selection.STRING_TARGET | Selection.UTF8_STRING_TARGET
   end

   public override get_content(target)
      return case target of {
         Selection.STRING_TARGET: text_convert(get_text(), "string")
         Selection.UTF8_STRING_TARGET: text_convert(get_text(), "ucs")
      }
   end
end

class StaticTextSelectionOwner(TextSelectionOwner)
   private const s

   protected override get_text()
      return s
   end

   public override lost_ownership()
   end

   public new(s)
      self.s := need_text(s)
      return
   end
end

class URLSelectionOwner(SelectionOwner)
   private const
      urls

   public override get_content(target)
      return case target of {
         Selection.URI_LIST_TARGET :
            text_guess_convert(String{ (!urls).str() || "\r\n" }, "ucs")
         Selection.STRING_TARGET :
            text_guess_convert(String{ (!urls).str(), "\N" }, "string")
         Selection.UTF8_STRING_TARGET:
            text_guess_convert(String{ (!urls).str(), "\N" }, "ucs")
      }
   end

   public override lost_ownership()
   end

   public override get_targets()
      suspend Selection.STRING_TARGET | Selection.UTF8_STRING_TARGET | Selection.URI_LIST_TARGET
   end

   public new(urls)
      self.urls := urls
      return
   end
end

#
# This is a helpful component which has zero size, but reacts to accelerator keys
# by firing an action event.
#
# Example :-
# ~
#    # dispose on alt-x
#    add(Accelerator().set_accel("x").connect(dispose, Event.ACTION))
# ~
class Accelerator(Component)
   public override handle_accel(e)
      fire(Event.ACTION, e)
   end

   public override new()
      Component.new()
      self.x_spec := self.y_spec := self.w_spec := self.h_spec := 0
      return
   end
end

#
# This component provides window control buttons (close and iconify) for
# systems that don't provide such controls themselves.
#
class WindowControl(Component)
   private static init()
      local sz
      sz := scale(16)
      ImageCache.copy_key_with_resize("gui.WINDOW_ICONIFY", "gui.WINDOW_ICONIFY_16", sz, sz)
      ImageCache.copy_key_with_resize("gui.WINDOW_CLOSE", "gui.WINDOW_CLOSE_16", sz, sz)
   end

   private close_window()
      push(parent_dialog.win.pending(), Window.CLOSE_BUTTON)
   end

   private iconify_window()
      parent_dialog.win.set_canvas("iconic")
   end

   public override new()
      Component.new()
      set_layout(GridLayout().set_doi(0).set_dii(0))
      set_pos("100%","0")
      set_align("r","t")
      add(IconButton().
          set_paint(ImagePaint().set_cache("gui.WINDOW_ICONIFY")).
          set_border(NullBorder()).
          set_accepts_focus(&no).
          set_tooltip("Iconify").
          connect(iconify_window, Event.ACTION))
      add(IconButton().
          set_paint(ImagePaint().set_cache("gui.WINDOW_CLOSE")).
          set_border(NullBorder()).
          set_accepts_focus(&no).
          set_tooltip("Close").
          connect(close_window, Event.ACTION))
      return
   end
end

#
# This class is implemented by all components which popup a menu or
# similar object.
#
abstract class MenuMode()
   # Succeed if the given `WinEvent` `e` should cause this menu to
   # close; for example a mouse press outside of a popup menu's
   # region.
   public abstract should_close(e)

   # Close this menu.  This should close the menu component, and then
   # call `Dialog.exit_menu_mode`.
   public abstract close_all()

   # Generate the `Component`s which make up the transient visible
   # parts of the popup (if any).
   public abstract gen_popup_components()

   # Return the `Component` which this popup notionally appears on.
   # For example, a text field's popup menu would return the text
   # field.  This is used by some components to determine whether or
   # not to allow a nested popup.
   public abstract get_nesting_component()

   # Given another `MenuMode` `c`, which wishes to enter menu mode,
   # succeed if we allow `c` to appear "on top" of this menu mode.
   # Otherwise, this menu mode is closed before `c` is entered.
   public abstract allow_nested(c)
end
