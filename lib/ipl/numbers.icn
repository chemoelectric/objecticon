############################################################################
#
#	File:     numbers.icn
#
#	Subject:  Procedures related to numbers
#
#	Author:   Ralph E. Griswold
#
#	Date:     June 10, 2001
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#	Contributors:  Robert J. Alexander, Richard Goerwitz
#	   Tim Korb, and Gregg M. Townsend
#
############################################################################
#
#	These procedures deal with numbers in various ways:
#
#	adp(i)		additive digital persistence of i
#
#	adr(i)		additive digital root of i (same as digred())
#
#	amean ! L	returns arithmetic mean of numbers in L.
#
#	ceil(x)		given a real number x, round towards positive infinity.
#
#	commas(s)	inserts commas in s to separate digits into groups of
#			three.
#
#	decimal(i, j)	decimal expansion of i / j; terminates when expansion
#			terminates or the end of a recurring period is reached.
#			The format of the returned value is <integer>.<seq>,
#			where <seq> is a string a decimal digits if the
#			expansion is finite but <pre>[<recurr>] if it
#			is not, where <pre> is a string of decimal digits
#			(possibly empty) before the recurring part.
#
#	decipos(r, i, j)
#			positions decimal point at i in real number r in
#			field of width j.
#
#	digprod(i)	product of digits of i
#
#	digred(i)	reduction of number by adding digits until one digit is
#			reached.
#
#	digroot(i)	same as digred().
#
#	digsum(i)	sum of digits in i.
#
#	distseq(i, j)	generates i to j in distributed order.
#
#	div(i, j)	produces the result of real division of i by j.
#
#	fix(i, j, w, d)	formats i / j as a real (floating-point) number in
#			a field of width w with d digits to the right of
#			the decimal point, if possible. j defaults to 1,
#			w to 8, and d to 3. If w is less than 3 it is set
#			to 3. If d is less than 1, it is set to 1. The
#			function fails if j is 0 or if the number cannot
#			be formatted.
#
# 	floor(x)	given a real number x, round towards negative infinity.
#
#	frn(r, w, d)    format real number r into a string with d digits
#			after the decimal point; a result narrower than w
#			characters is padded on the left with spaces.
#			Fixed format is always used; there is no exponential
#			notation.  Defaults:  w 0, d  0
#
#	gcd(i, j)	returns greatest common divisor of i and j.
#
#	gcdl ! L	returns the greatest common division of the integers
#			list L.
#
#	gmean ! L	returns geometric mean of numbers in L.
#
#	hmean ! L	returns harmonic mean of numbers in L.
#
#	lcm(i, j)	returns the least common multiple of i and j.
#
#	lcml ! L	returns the least common multiple of the integers
#			in the list L.
#
#	mantissa(r)	mantissa (fractional part) of r.
#
#	mdp(i)		multiplicative digital persistence of i
#
#	mdr(i)		multiplicative digital root of i
#
#	mod1(i, m)	residue for 1-based indexing.
#
#	npalins(n)	generates palindromic n-digit numbers.
#
#	residue(i, m, j)
#			residue for j-based indexing.
#
#	roman(i)	converts i to Roman numerals.
#
#	round(r)	returns nearest integer to r.
#
#	sigma(i)	synonym for digroot(i)
#
#	sign(r)		returns sign of r.
#
#	sum ! L		sum of numbers in list L
#
#	trunc(r)	returns nearest integer to r toward 0
#
#	unroman(s)	converts Roman numerals to integers.
#
############################################################################
#
#	Links:  factors, strings
#	
############################################################################

package ipl.numbers

import
   ipl.strings(palins),
   util(Format, Math, need_integer, need_real, need_string)

# additive digital persistence
procedure adp(i)		
   local j

   j := 0

   until *i = 1 do {
      i := digsum(i)
      j +:= 1
      }

   return j

end

# additive digital root
procedure adr(i)		

   until *i = 1 do
      i := digsum(i)

   return i

end

# arithmetic mean
procedure amean(L[])		
   local m

   if *L = 0 then fail

   m := 0.0
   every m +:= !L

   return m / *L

end

# Given a real number x, round away from zero.
procedure up(x)
   local i
   i := integer(x)
   return if x = i then i else if x >= 0 then i + 1 else i - 1
end

# Given integers x and y, return the value of x รท y rounded away from
# zero.
procedure up2(x, y)
   local i
   i := x / y
   return if x % y = 0 then i else if (sign(x) * sign(y) >= 0) then i + 1 else i - 1
end

# Given a real number x, round towards negative infinity.
procedure floor(x) 
   local i
   i := integer(x)
   return if x = i | x >= 0 then i else i - 1
end

# Given integers x and y, return the value of x รท y rounded towards
# negative infinity.
procedure floor2(x, y) 
   local i
   i := x / y
   return if (x % y = 0) | (sign(x) * sign(y) >= 0) then i else i - 1
end

# Given a real number x, round towards positive infinity.
procedure ceil(x) 
   local i
   i := integer(x)
   return if x = i | x < 0 then i else i + 1
end

# Given integers x and y, return the value of x รท y rounded towards
# positive infinity.
procedure ceil2(x, y) 
   local i
   i := x / y
   return if (x % y = 0) | (sign(x) * sign(y) < 0) then i else i + 1
end

# insert commas in number
procedure commas(s)		

   local s2, sign

   # Don't bother if s is already comma-ized.
   if type(s) == "string" & find(",",  s) then fail

   # Take sign.  Save chars after the decimal point (if present).
   if s := abs(0 > s)
   then sign := "-" else sign := ""
   s ? {
      s := tab(find(".")) & ="." &
      not pos(0) & s2 := "." || tab(0)
      }

   /s2 := ""
   integer(s) ? {
      tab(0)
      while s2 := "," || move(-3) || s2
      if pos(1)
      then s2 ?:= (move(1), tab(0))
      else s2 := tab(1) || s2
      }

   return sign || s2

end

# decimal expansion of rational
procedure decimal(i, j)		
   local head, tail, numers, count

   head := (i / j) || "."
   tail := ""
   numers := table()

   i %:= j
   count := 0

   while i > 0 do {
      numers[i] := count
      i *:= 10
      tail ||:= i / j
      i %:= j
      if \numers[i] then	# been here; done that
	 return head || (tail ? (move(numers[i]) || "[" || tab(0) || "]"))
      count +:= 1
      }

   return head || tail

end

# position decimal point
procedure decipos(r, i, j)	
   local head, tail

   /i := 3
   /j := 5

   r := need_real(r)

   if i < 1 then fail

   r ? {
      head := tab(upto('.eE')) | fail
      move(1)
      tail := tab(0)
      return left(right(head, i - 1) || "." || tail, j)
      }

end

# sum digits of integer repeated to one digit
procedure digred(i)		

   return digroot(i)

end

# digital root
procedure digroot(i)		

   if i = 0 then return 1

   i %:= 9
   
   return if i = 0 then 9 else i

end

# product of digits
procedure digprod(i)		
   local j

   if upto('0', i) then return 0

   else j := 1

   every j *:= !i

   return j

end

# sum of digits
procedure digsum(i)		
   local j

   i := integer(i) | fail

   repeat {
      j := 0
      every j +:= !i
      suspend j
      if *j > 1 then i := j else fail
      }

end

#  distseq() generates a range of integers in a deterministic order that is
#  "most uniformly distributed" in Knuth's terminology (vol3, 1/e, p. 511).
#  Each integer in the range is produced exactly once.

# generate low to high nonsequentially
procedure distseq(low, high)		
   local n, start, incr, range

   low := need_integer(low)
   high := need_integer(high)
   if low > high then fail
   range := high - low + 1
   start := n := range / 2

   suspend low + n

   incr := integer(range / Math.PHI ^ 2 + 0.5)
   if incr <= 1 then 
      incr := 1
   else while gcd(incr, range) > 1 do
      incr +:= 1

   repeat {
      n := (n + incr) % range
      if n = start then fail
      suspend low + n
      }

end

# real division
procedure realdiv(i, j)		

   return i / real(j)

end

# format real number
procedure fix(i, j, w, d)	
   local r

   /j := 1
   /w := 8
   /d := 3
   if j = 0 then fail
   w <:= 3
   d <:= 1
   r := need_real(i) / j

   return frn(r, w, d)
end

# format real number
procedure frn(r, w, d)		
   local s
   r := need_real(r)
   /d := 0
   s := Format.numeric_to_string(r, d)
   s := right(s, *s < \w)
   return s
end

# greatest common divisor
procedure gcd(i,j)		
   local r

   i := abs(i)
   j := abs(j)
   if (i | j) = 0 then
      return max(i, j)

   repeat {
      r := i % j
      if r = 0 then return j
      i := j
      j := r
      }
end

# greatest common divisor of list
procedure gcdl(L[])		
   local i, j

   i := get(L) | fail

   while j := get(L) do
      i := gcd(i, j)

   return i

end
   
# geometric mean
procedure gmean(L[])		
   local m

   if *L = 0 then fail

   m := 1.0
   every m *:= !L
   m := abs(m)
   if m > 0.0 then
      return Math.exp (Math.log(m) / *L)
   else
      fail
end
   
# harmonic mean
procedure hmean(L[])		
   local m, r

   if *L = 0 then fail

   m := 0.0

   every r := !L do {
      if r = 0.0 then fail
      else m +:= 1.0 / r
      }

   return *L / m

end

# least common multiple
procedure lcm(i, j)		

   if (i =  0) | (j = 0) then return 0	# ???

   return abs(i * j) / gcd(i, j)

end

# least common multiple of list
procedure lcml(L[])		
   local i, j

   i := get(L) | fail

   while j := get(L) do
      i := lcm(i, j)

   return i

end

# mantissa (fractional part)
procedure mantissa(r)		
   local fpart

   r := real(r)

   fpart := r - integer(r)

   fpart ?:= {
      tab(upto('.') + 1)
      tab(0)
      }

   fpart ? {
      if fpart := tab(upto('Ee')) then {
         move(1)
         if = "+" then fpart := "0"
         else {
            move(1)
            fpart := repl("0", tab(0) - 1) || fpart
            }
         }
      }

   return "." || fpart

end

# multiplicative digital persistence
procedure mdp(i)		
   local j

   j := 0

   until *i = 1 do {
      i := digprod(i)
      j +:= 1
      }

   return j

end

# multiplicative digital root
procedure mdr(i)		

   until *i = 1 do
      i := digprod(i)

   return i

end

# modulus for 1-based integers
procedure mod1(i, m)		

   i %:= m

   if i < 1 then i +:= m

   return i

end

# palindromic numbers
procedure npalins(n)		
   local i

   every i := palins(&digits, n) do
      if i[1] ~== "0" then suspend i	# can't start with zero

end

# residue for j-based integers
procedure residue(i, m, j)		

   /j := 0

   i %:= m

   if i < j then i +:= m

   return i

end

#  This procedure is based on a SNOBOL4 function written by Jim Gimpel.
#
# convert integer to Roman numeral
procedure roman(n)		
   local arabic, result
   static equiv

   initial equiv := ["","I","II","III","IV","V","VI","VII","VIII","IX"]

   n := need_integer(n)
   (0 < n < 4000) | fail
   result := ""
   every arabic := !n do
      result := map(result,"IVXLCDM","XLCDM**") || equiv[arabic + 1]
   return result

end

# Return the nth element of the sequence
#       A,B,C,...Z,AA,AB,...,AZ,BA,... etc
#
procedure alphaseq(n)
   local r
   n := (0 < need_integer(n)) | fail
   r := ""
   while n > 0 do {
      r := &ucase[(n - 1) % 26 + 1] || r
      n := (n - 1) / 26
   }
   return r
end

# round real
procedure round(r)		

   return if r > 0 then integer(r + 0.5) else -integer(0.5 - r)

end

# synonym for digroot()
procedure sigma(i)		

   sigma := digroot

   return sigma(i)

end

# sign
procedure sign(r)		

   return if r = 0 then 0
   else if r < 0 then -1
   else 1

end

# sum of numbers
procedure sum(values[])		
   local result

   result := 0

   every result +:= !values

   return result

end

# truncate real
procedure trunc(r)		

   return integer(r)

end

# convert Roman numeral to integer
procedure unroman(s)		
   local nbr,lastVal,val,c

   s := map(need_string(s))
   nbr := lastVal := 0

   every c := !s do {
      val := case c of {
	 "m": 1000
	 "d": 500
	 "c": 100
	 "l": 50
	 "x": 10
	 "v": 5
	 "i": 1
         default: fail
	 }
      nbr +:= if val <= lastVal then val else val - 2 * lastVal
      lastVal := val
      }
   return nbr

end
