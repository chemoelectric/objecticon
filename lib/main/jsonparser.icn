package json

import 
   util,
   exception

class JSONParser()
   public static const 
      WS_CHAR,
      UNESCAPED_CHAR

   private
      utf8_flag,
      true,
      false,
      null

   private static init()
      WS_CHAR := ' \t\n\r'
      UNESCAPED_CHAR := '\x20-\x21\x23-\x5B\x5D-\U10FFFF'
   end

   public set_true(x)
      self.true := x
      return self
   end

   public set_false(x)
      self.false := x
      return self
   end

   public set_null(x)
      self.null := x
      return self
   end

   private parse_number()
      local s
      s := (=u"-" | "") || 
         (=u"0" | (tab(any('123456789')) || (tab(many(&digits)) | ""))) ||
         ((=u"." || tab(many(&digits))) | "") ||
         ((=u"e" || (tab(any('+\-')) | "") || tab(many(&digits))) | "") | throw("Invalid number")
      return numeric(s) | throw("Number out of range")
   end

   private parse_string()
      local s, t, ch, i
      =u"\""
      s := ""
      repeat {
         s ||:= tab(many(UNESCAPED_CHAR))
         if pos(0) then
            throw("Unclosed quote")
         if =u"\"" then
            break
         if =u"\\" then {
            ch := move(1) | throw("Unclosed quote")
            s ||:= case string(ch) of {
               "\"": "\""
               "\\": "\\"
               "/": "/"
               "b": "\b"
               "f": "\f"
               "n": "\n"
               "r": "\r"
               "t": "\t"
               "u": {
                  many(&digits ++ 'ABCDEFabcdef', t := move(4)) = 5 | throw("Invalid \\u escape")
                  i := integer("16r" || t)
                  if \utf8_flag then
                     uchar(i | 63)
                  else
                     char(i | 63)
               }
               default: throw("Invalid escape char in string: " || ch)
            }
         } else
            throw("Invalid char in string:" || image(&subject[&pos]))
      }
      return s
   end

   private parse_value()
      return if =u"false" then
         false
      else if =u"true" then
         true
      else if =u"null" then
         null
      else if any('[') then
         parse_array()
      else if any('{') then
         parse_object()
      else if any('-' ++ &digits) then
         parse_number()
      else if any('\"') then
         parse_string()
      else
         throw("Unexpected char: " || &subject[&pos])
   end

   private next_token()
      tab(many(WS_CHAR))
   end

   private parse_array()
      local res
      res := []
      =u"["
      next_token()
      if =u"]" then
         return res
      repeat {
         put(res, parse_value())
         next_token()
         if =u"]" then
            return res
         =u"," | throw(", expected")
         next_token()
      }
      return res
   end

   private parse_object()
      local res, m, v
      res := table()
      =u"{"
      next_token()
      if =u"}" then
         return res
      repeat {
         m := parse_string()
         next_token()
         =u":" | throw(": expected")
         next_token()
         v := parse_value()
         next_token()
         insert(res, m, v)
         if =u"}" then
            return res
         =u"," | throw(", expected")
         next_token()
      }
      return res
   end

   private end_check(o)
      next_token()
      pos(0) | throw("Extraneous input:" || tab(0))
      return o
   end

   private parse_impl()
      next_token()
      return if any('[') then
         parse_array()
      else if any('{') then
         parse_object()
      else
         throw("[ or { expected")
   end

   public parse(s)
      utf8_flag := Yes{ type(s) == "ucs" }
      return s ? try1{ end_check(parse_impl()) }
   end

   public new()
      true := &yes
      false := &no
      return
   end
end
