static int inited;
static vlong startup_time;
static wfp fonts, new_context_font;
static Rectangle max_rect;
static struct Cursor cursor_data[];
static int use_win;
static int bintime_fd;

static int open_winfile(wsp ws, char *s, int mode);
static wsp alcwinstate(void);
static wcp alccontext(wbp w);
static wfp alcfont(wbp w, char **s);
static void synch_pattern_image(struct SharedPattern *pat, int fg_rgb, int bg_rgb, int style);
static int configure_canvas(wbp w);
static void mouse_loop(int in_fd, int out_fd);
static Rune *utf8_to_runes(char *str, int nchars);
static void cons_loop(int in_fd, int out_fd);
static void flush_event_pipe(wsp ws);
static wfp load_font(char *s);
static void synch_cursor(wsp ws);
static vlong get_time(void);
static int open_screen_win(wsp ws);
static Image *any_other_win(Image *win);
static void close_screen_win(wsp ws);
static void open_pix_win(wsp ws);
static Image *get_draw_img(wcp wc);
static void close_pix_win(wsp ws);
static void resize_pix_win(wbp w);
static void handle_resize(wsp ws);
static void init_window_system(void);
static void clear_pix_win(wbp wb);
static void clear_win(wbp wb);
static void clip(wcp wc, Image *i);
static void unclip(wcp wc, Image *i);
static struct SharedColor *new_sharedcolor(char *name, int rgb);
static struct SharedColor *link_sharedcolor(struct SharedColor *i);
static void unlink_sharedcolor(struct SharedColor *i);
static struct SharedPattern *new_sharedpattern(int width, int height, int *rowdata, char *name);
static struct SharedPattern *link_sharedpattern(struct SharedPattern *x);
static void unlink_sharedpattern(struct SharedPattern *x);
static int limit_size(wsp ws, int *width, int *height);
static void synch_pos(wsp ws);
static void note_time(char *s);

#define EMAXMSG 128+8192     /* size of 9p header+data */
#define WINDOW_MOUNT_ROOT "/tmp/oi_windowmounts"

#define NormalCanvas 1
#define HiddenCanvas 2
#define IconicCanvas 3

#define FillSolid     1
#define FillMasked    2
#define FillTextured  3

#if 0
static int n_open;
static int myopen(char *s,int mode)
{
    int fd = open(s,mode);
    if (fd >= 0)
        ++n_open;
    return fd;
}
static myclose(int fd)
{
    close(fd);
    --n_open;
    print("n_open now %d\n",n_open);
}
#define open myopen
#define close myclose
#endif

static stringint fillstyles[] = {
    {0, 3},
    {"masked", FillMasked },
    {"solid", FillSolid },
    {"textured", FillTextured },
};

static stringint canvastypes[] = {
    {0, 3},
    {"hidden",      HiddenCanvas},
    {"iconic",      IconicCanvas},
    {"normal",      NormalCanvas},
};

static stringint cursors[] = {
    { 0, 78},
    {"X cursor",          25},
    {"arrow",             16},
    {"based arrow down",  -1},
    {"based arrow up",    -1},
    {"boat",              -1},
    {"bogosity",          -1},
    {"bottom left corner", 12},
    {"bottom right corner",10},
    {"bottom side",        11},
    {"bottom tee",         17},
    {"box spiral",        -1},
    {"center ptr",         18},
    {"circle",             19},
    {"clock",             -1},
    {"coffee mug",        -1},
    {"cross",             20},
    {"cross reverse",     21},
    {"crosshair",         22},
    {"diamond cross",     23},
    {"dot",               24},
    {"dotbox",            -1},
    {"double arrow",      -1},
    {"draft large",       -1},
    {"draft small",       -1},
    {"draped box",        -1},
    {"exchange",          29},
    {"fleur",             15},
    {"gobbler",           -1},
    {"gumby",             -1},
    {"hand1",             -1},
    {"hand2",             28},
    {"heart",             -1},
    {"icon",              -1},
    {"iron cross",        -1},
    {"left ptr",          -1},
    {"left side",          13},
    {"left tee",          -1},
    {"leftbutton",        -1},
    {"ll angle",          -1},
    {"lr angle",          -1},
    {"man",               -1},
    {"middlebutton",      -1},
    {"mouse",             -1},
    {"pencil",            -1},
    {"pirate",            -1},
    {"plus",              -1},
    {"question arrow",     5},
    {"right ptr",         -1},
    {"right side",         9},
    {"right tee",         -1},
    {"rightbutton",       -1},
    {"rtl logo",          -1},
    {"sailboat",          -1},
    {"sb down arrow",     -1},
    {"sb h double arrow", 26},
    {"sb left arrow",     -1},
    {"sb right arrow",    -1},
    {"sb up arrow",       -1},
    {"sb v double arrow", 27},
    {"shuttle",           -1},
    {"sizing",            -1},
    {"spider",            -1},
    {"spraycan",          -1},
    {"star",              -1},
    {"target",             0},
    {"tcross",            -1},
    {"top left arrow",    -1},
    {"top left corner",    6},
    {"top right corner",   8},
    {"top side",           7},
    {"top tee",           -1},
    {"trek",              -1},
    {"ul angle",          -1},
    {"umbrella",          -1},
    {"ur angle",          -1},
    {"watch",             30},
    {"xterm",             14},
    {"num glyphs",        -1},
};

static struct SharedColor *black, *white;
static int window_count;
static struct SharedPattern *black_pattern;

static int open_winfile(wsp ws, char *s, int mode)
{
    char buff[128];
    int fd;
    sprintf(buff, "%s/%s", ws->mount_dir, s);
    fd = open(buff, mode);
    return fd;
}

static struct SharedColor *new_sharedcolor(char *name, int rgb)
{
    struct SharedColor *res;
    GRFX_ALLOC(res, SharedColor);
    res->name = salloc(name);
    res->rgb = rgb;
    MemProtect(res->i = allocimage(display, Rect(0, 0, 1, 1), RGB24, 1, rgb));
    return res;
}

static struct SharedColor *link_sharedcolor(struct SharedColor *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedcolor(struct SharedColor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        free(x->name);
        freeimage(x->i);
        free(x);
    }
}

static struct SharedPattern *new_sharedpattern(int width, int height, int *rowdata, char *name)
{
    struct SharedPattern *res;
    GRFX_ALLOC(res, SharedPattern);
    res->i = 0;
    res->name = salloc(name);
    res->width = width;
    res->height = height;
    memcpy(res->rowdata, rowdata, height * sizeof(int));
    res->fg_rgb = res->bg_rgb = 0;
    return res;
}

static struct SharedPattern *link_sharedpattern(struct SharedPattern *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedpattern(struct SharedPattern *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        free(x->name);
        if (x->i)
            freeimage(x->i);
        free(x);
    }
}

static void draw_error(Display *d, char *s)
{
    fprintf(stderr, "Draw error on display %p: %s\n", d, s);
}

static void show_square(Image *dest, Rectangle r)
{
    Point p[5];
    Image *red = allocimage(display, Rect(0, 0, 1, 1), screen->chan, 1, DRed);
    p[0] = r.min;
    p[1] = Pt(r.max.x, r.min.y);
    p[2] = r.max;
    p[3] = Pt(r.min.x, r.max.y);
    p[4] = p[0];
    poly(dest, p, 5, Endsquare, Endsquare, 0, red, ZP);
    freeimage(red);
    flushimage(display, 1);
}

wbp wcreate(char *display, wbp parent)
{
    wbp w;
    wsp ws;

    if (!inited) {
        init_window_system();
        inited = 1;
    }

    w = alcwbinding();
    ws = w->window = alcwinstate();
    if (display)
        ws->wsys = salloc(display);
    else {
        ws->wsys = getenv("wsys");
        if (!ws->wsys) {
            LitWhy("wsys environment variable not set");
            freewbinding(w);
            return 0;
        }
    }
    w->context = alccontext(w);
    create_list(64, &ws->listp);
    return w;
}

int wopen(wbp w)
{
    wsp ws = w->window;
    struct imgdata *imd;

    open_pix_win(ws);
    /* Fill pixmap with bg color */
    clear_pix_win(w);

    if (configure_canvas(w) != Succeeded)
        return Failed;

    imd = &ws->initimage;
    if (imd->width) {
        drawimgdata(w, 0, 0, imd);
        freeimgdata(imd);
    }

    return Succeeded;
}

static void clear_pix_win(wbp w)
{
    wsp ws = w->window;
    gendraw(ws->pix, ws->pix->r, w->context->bg->i, ZP, 0, ZP);
}

static void clear_win(wbp w)
{
    wsp ws = w->window;
    gendraw(ws->win, ws->win->r, w->context->bg->i, ZP, 0, ZP);
}

static void copy_to(Image *dest, Image *src)
{
    Rectangle t = Rect(dest->r.min.x, 
                       dest->r.min.y,
                       dest->r.min.x + (src->r.max.x - src->r.min.x),
                       dest->r.min.y + (src->r.max.y - src->r.min.y));
    gendraw(dest, t, src, src->r.min, 0, ZP);
}

static void pix_to_win(wsp ws)
{
    copy_to(ws->win, ws->pix);
    flushimage(display, 1);
}

static void win_to_pix(wsp ws)
{
    copy_to(ws->pix, ws->win);
    flushimage(display, 1);
}

static int limit_size(wsp ws, int *width, int *height)
{
    int limw, limh, dispw, disph, rv = 0;
    if (*width < ws->minwidth) {
        *width = ws->minwidth;
        rv = 1;
    }
    if (*width > ws->maxwidth) {
        *width = ws->maxwidth;
        rv = 1;
    }
    if (*height < ws->minheight) {
        *height = ws->minheight;
        rv = 1;
    }
    if (*height > ws->maxheight) {
        *height = ws->maxheight;
        rv = 1;
    }
    /* Ensure size within permissible limits for a rio window.  If we don't keep within
     * these limits, mount and resize requests fail with an error.  See goodrect() in 
     * rio/wctl.c */
    limw = 100 - 2 * Borderwidth;
    if (*width < limw) {
        *width = limw;
        rv = 1;
    }
    limh = 3*font->height - 2 * Borderwidth;
    if (*height < limh) {
        *height = limh;
        rv = 1;
    }
    /* Unfortunately there seems to be no way to find the dimensions of the rio window in which
     * we are running, only the top-level display size */
    dispw = Dx(display->image->r);
    disph = Dy(display->image->r);
    limw = dispw - 2 * Borderwidth;
    limh = disph - 2 * Borderwidth;
    if (*width >= limw && *height >= limh) {
        *width = limw - 1;
        *height = limh - 1;
        rv = 1;
    }

    return rv;
}

static int configure_canvas(wbp w)
{
    wsp ws = w->window;

    if (ws->desired_canvas == HiddenCanvas) {
        if (ws->win) {
            win_to_pix(ws);
            close_screen_win(ws);
        }
    } else {
        if (!ws->win) {
            if (limit_size(ws, &ws->width, &ws->height))
                resize_pix_win(w);
            if (open_screen_win(ws) == Failed)
                return Failed;
            pix_to_win(ws);
        }
        if (ws->desired_canvas == IconicCanvas)
            fprint(ws->wctl_fd, "hide");
        else
            fprint(ws->wctl_fd, "unhide");
    }
    return Succeeded;
}

static void mouse_loop(int in_fd, int out_fd)
{
    char buf[EMAXMSG + 9];
    int r;

    buf[0] = 'M';
    while ((r = read(in_fd, buf + 9, EMAXMSG)) > 0) {
        read(bintime_fd, &buf[1], 8);
        if (write(out_fd, buf, r + 9) != r + 9)
            break;
    }
    _exits(0);
}

static void cons_loop(int in_fd, int out_fd) 
{
    Rune r;
    char buf[11], in[10];

    buf[0] = 'C';
    while (read(in_fd, in, sizeof in) > 0) {
        read(bintime_fd, &buf[1], 8);
        chartorune(&r, in);
        buf[9] = r;
        buf[10] = r>>8;
        if (write(out_fd, buf, 11) != 11)
            break;
    }
    _exits(0);
}

static wbp find_first_wbp_for(wsp ws)
{
    wbp wb;
    for (wb = wbndngs; wb; wb = wb->next)
        if (wb->window == ws)
            return wb;
    syserr("Couldn't find wbp for wsp");
    return 0;  /* not reached */
}

/*
 * Synch the x, y variables with rio's values.
 */
static void synch_pos(wsp ws)
{
    ws->x = ws->win->r.min.x;
    ws->y = ws->win->r.min.y;
}

static void resize_pix_win(wbp w)
{
    wsp ws = w->window;
    Image *t;
    if (Dx(ws->pix->r) >= ws->width &&
        Dy(ws->pix->r) >= ws->height)
        return;
    MemProtect(t = allocimage(display, ws->pix->r, screen->chan, 1, DNofill));
    copy_to(t, ws->pix);
    close_pix_win(ws);
    open_pix_win(ws);
    clear_pix_win(w);
    copy_to(ws->pix, t);
    freeimage(t);
}

static void handle_resize(wsp ws)
{
    char buff[128];
    wbp w;
    int tw, th;
    sprintf(buff, "%s/winname", ws->mount_dir);
    /*fprintf(stderr,"reconnecting to %s repl=%d\n",buff, ws->pix->repl);fflush(stderr);*/
    if (gengetwindow(display, buff, &ws->win, &ws->screen, Refnone) < 0)
        syserr("Failed to reconnect to window on a resize");

    tw = ws->win->r.max.x - ws->win->r.min.x;
    th = ws->win->r.max.y - ws->win->r.min.y;
    /*print("resize: %d x %d   flag=%d\n",tw,th,ws->bits&128);*/

    if (tw == ws->width && th == ws->height) {
        /*
         * If the new size matches the existing canvas size, just copy the
         * pix win and adjust the pos.  Don't fire an event.
         */
        synch_pos(ws);
        pix_to_win(ws);
    }
    else if ((ws->bits & 128) == 0)   /* If resizable flag off */
        /* 
         * If the resize flag is off, veto the resize by just resetting the size
         * to the canvas size.  We then go through the previous if branch when that
         * resize is processed.
         */
        fprint(ws->wctl_fd, "resize  -dx %d -dy %d", ws->width + 2*Borderwidth, ws->height + 2*Borderwidth);
    else if (limit_size(ws, &tw, &th)) 
        /*
         * Similarly, if the resize is too big we veto it and set to the limited size.
         */
        fprint(ws->wctl_fd, "resize  -dx %d -dy %d", tw + 2*Borderwidth, th + 2*Borderwidth);
    else {
        /*
         * Here we accept the resize, resize the pix win, copy it to the visible
         * win and fire an event.
         */
        struct descrip d;
        ws->width = tw;
        ws->height = th;
        synch_pos(ws);
        w = find_first_wbp_for(ws);

        /* Fill the win with the bg of the first context */
        clear_win(w);
        resize_pix_win(w);
        pix_to_win(ws);
        MakeInt(RESIZED, &d);
        qevent(ws, &d, -1, -1, 0, 0, 0, 0, 0);
    }
}

#define swap(a,b) { tmp = a; a = b; b = tmp; }

static void flush_event_pipe(wsp ws)
{
    Dir *st;
    vlong length;
    int n;
    uchar ebuf[EMAXMSG + 1];
    tended struct descrip d;

    /* Check if pipe open */
    if (!ws->win || ws->event_pipe[0] < 0)
        return;

    for (;;) {
        /* Check if anything to read */
        st = dirfstat(ws->event_pipe[0]);
        if (!st)
            syserr("Couldn't stat event pipe");
        length = st->length;
        free(st);
        if (length == 0)
            return;

        n = read(ws->event_pipe[0], ebuf, sizeof(ebuf));
        if (n <= 0)
            return;

        switch (ebuf[0]) {
            case 'C' : {
                int i;
                vlong now;
                uword time;
                if (n != 11)
                    syserr("bad console data in event pipe");
                be2vlong(&now, &ebuf[1]);
                time = (now - startup_time) / 1000000;
                i = ebuf[9] + (ebuf[10]<<8);
                if (i == 10) i = 13;   /* Hack: convert \n to \r */
                if (i < 256) {
                    /* Found a char string, so generate string event(s) */
                    StrLen(d) = 1;
                    StrLoc(d) = &allchars[i & 0xFF];
                } else if (i < 60000) {
                    d.dword = D_Ucs;
                    BlkLoc(d) = (union block *)make_one_char_ucs_block(i);
                } else 
                    MakeInt(i, &d);
                qevent(ws, &d, ws->last_mouse_x, ws->last_mouse_y, time, 0, 0, 0, 0);
                break;
            }
            case 'M': {
                if (n < 10+2*12)
                    syserr("bad mouse data in event pipe");
                if (ebuf[9] == 'r')
                    handle_resize(ws);
                else {
                    int x, y, state, tmp;
                    vlong now;
                    uword time;
                    be2vlong(&now, &ebuf[1]);
                    time = (now - startup_time) / 1000000;
                    x = atoi((char*)ebuf+10+0*12) - ws->win->r.min.x;
                    y = atoi((char*)ebuf+10+1*12) - ws->win->r.min.y;
                    state = atoi((char*)ebuf+10+2*12);
                    ws->last_mouse_x = x;
                    ws->last_mouse_y = y;
                    qmouseevents(ws, state, x, y, time, 0, 0, 0);
                }
                break;
            }
        }
    }
}

int grabpointer(wbp w)
{
    return Failed;
}

int ungrabpointer(wbp w)
{
    return Failed;
}

int walert(wbp w, int volume)
{
    return Succeeded;
}

static void impl_copyarea(wcp wc, Image *dest, Image *src,int x,int y,int w,int h,int x2,int y2)
{
    clip(wc, dest);

    if (x + w < 0 || y + h < 0 || x >= Dx(src->r) || y >= Dy(src->r)) {
        /* source is entirely offscreen, fill dest with bg */
        gendraw(dest, 
                Rect(dest->r.min.x + x2, 
                     dest->r.min.y + y2,
                     dest->r.min.x + x2 + w,
                     dest->r.min.y + y2 + h), 
                wc->bg->i, ZP, 0, ZP);
    } else {
        int lpad, rpad, tpad, bpad;
        lpad = rpad = tpad = bpad = 0;
        if (x < 0) {			/* source extends past left edge */
            lpad = -x;
            w -= lpad;
            x2 += lpad;
            x = 0;
        }
        if (x + w > Dx(src->r)) {  /* source extends past right edge */
            rpad = x + w - Dx(src->r);
            w -= rpad;
        }
        if (y < 0) {			/* source extends above top edge */
            tpad = -y;
            h -= tpad;
            y2 += tpad;
            y = 0;
        }
        if (y + h > Dy(src->r)) {  /* source extends below bottom */
            bpad = y + h - Dy(src->r);
            h -= bpad;
        }

        gendraw(dest,
                Rect(dest->r.min.x + x2, 
                     dest->r.min.y + y2,
                     dest->r.min.x + x2 + w,
                     dest->r.min.y + y2 + h),
                src,
                Pt(src->r.min.x + x, 
                   src->r.min.y + y), 
                0, ZP);
        if (lpad > 0)
            gendraw(dest,
                    Rect(dest->r.min.x + x2 - lpad, 
                         dest->r.min.y + y2 - tpad,
                         dest->r.min.x + x2,
                         dest->r.min.y + y2 + h + bpad),
                    wc->bg->i, ZP, 0, ZP);

        if (rpad > 0)
            gendraw(dest,
                    Rect(dest->r.min.x + x2 + w, 
                         dest->r.min.y + y2 - tpad,
                         dest->r.min.x + x2 + w + rpad,
                         dest->r.min.y + y2 + h + bpad),
                    wc->bg->i, ZP, 0, ZP);

        if (tpad > 0)
            gendraw(dest,
                    Rect(dest->r.min.x + x2, 
                         dest->r.min.y + y2 - tpad,
                         dest->r.min.x + x2 + w,
                         dest->r.min.y + y2),
                    wc->bg->i, ZP, 0, ZP);

        if (bpad > 0)
            gendraw(dest,
                    Rect(dest->r.min.x + x2, 
                         dest->r.min.y + y2 + h,
                         dest->r.min.x + x2 + w,
                         dest->r.min.y + y2 + h + bpad),
                    wc->bg->i, ZP, 0, ZP);
    }
    unclip(wc, dest);
}

void copyarea(wbp w1,wbp w2,int x,int y,int w,int h,int x2,int y2)
{
    wsp ws1 = w1->window;
    wsp ws2 = w2->window;
    wcp wc = w2->context;
    if (ws2->win)
        impl_copyarea(wc, ws2->win, ws1->pix, x, y, w, h, x2, y2);
    impl_copyarea(wc, ws2->pix, ws1->pix, x, y, w, h, x2, y2);
    flushimage(display, 1);
}

int rebind(wbp w, wbp w2)
{
    w->context = w2->context;
    return Succeeded;
}

static void impl_drawarc(wcp wc, Image *dest, int x, int y, int width, int height, double angle1, double angle2)
{
    int alpha, phi;
    clip(wc, dest);
    x += width/2;
    y += height/2;
    width /= 2;
    height /= 2;
    alpha = -angle1 * 180 / Pi;
    phi = -angle2 * 180 / Pi;
    arc(dest, 
        Pt(dest->r.min.x + x, dest->r.min.y + y),
        width, height,
        wc->thick,
        get_draw_img(wc), 
        ZP,
        alpha, phi);
        
    unclip(wc, dest);
}

void drawarc(wbp w, int x, int y, int width, int height, double angle1, double angle2)
{
    wsp ws = w->window;
    wcp wc = w->context;
    if (ws->win)
        impl_drawarc(wc, ws->win, x, y, width, height, angle1, angle2);
    impl_drawarc(wc, ws->pix, x, y, width, height, angle1, angle2);
    flushimage(display, 1);
}

void drawlines(wbp w, XPoint *points, int npoints)
{
    int i, term;
    wsp ws = w->window;
    wcp wc = w->context;

    /* Hack - if line thickness is 1, and we are drawing a horizontal or vertical line, then
     * Endsquare omits the last pixel (eg 0,0->0,1 just draws a single dot at 0,0).
     */
    term = wc->thick == 1 ? Enddisc:Endsquare;

    clip(wc, ws->pix);
    poly(ws->pix, points, npoints, term, term, wc->thick, 
         get_draw_img(wc), ZP);
    unclip(wc, ws->pix);

    if (ws->win) {
        for (i = 0; i < npoints; ++i) {
            points[i].x += ws->win->r.min.x;
            points[i].y += ws->win->r.min.y;
        }
        clip(wc, ws->win);
        poly(ws->win, points, npoints, term, term, wc->thick, 
             get_draw_img(wc), ZP);
        unclip(wc, ws->win);
    }

    flushimage(display, 1);
}

void drawpoint(wbp w, int x, int y)
{
    fillrectangle(w, x, y, 1, 1);
}

static void impl_drawrectangle(wcp wc, Image *dest, int x, int y, int width, int height)
{
    Point p[5];
    p[0] = addpt(dest->r.min, Pt(x, y));
    p[1] = Pt(p[0].x + width - 1, p[0].y);
    p[2] = Pt(p[0].x + width - 1, p[0].y + height - 1);
    p[3] = Pt(p[0].x, p[0].y + height - 1);
    p[4] = p[0];
    clip(wc, dest);
    poly(dest, p, 5, Endsquare, Endsquare, wc->thick, get_draw_img(wc), ZP);
    unclip(wc, dest);
}

void drawrectangle(wbp w, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    if (ws->win)
        impl_drawrectangle(wc, ws->win, x, y, width, height);
    impl_drawrectangle(wc, ws->pix, x, y, width, height);
    flushimage(display, 1);
}

void fillpolygon(wbp w, XPoint *points, int npoints)
{
    int i;
    wsp ws = w->window;
    wcp wc = w->context;

    clip(wc, ws->pix);
    fillpoly(ws->pix, points, npoints, 0, get_draw_img(wc), ZP);
    unclip(wc, ws->pix);

    for (i = 0; i < npoints; ++i) {
        points[i].x += ws->win->r.min.x;
        points[i].y += ws->win->r.min.y;
    }
    clip(wc, ws->win);
    fillpoly(ws->win, points, npoints, 0, get_draw_img(wc), ZP);
    unclip(wc, ws->win);

    flushimage(display, 1);
}

static void clip(wcp wc, Image *i)
{
    if (wc->clipw >= 0)
        replclipr(i, 0, Rect(i->r.min.x + wc->clipx, 
                             i->r.min.y + wc->clipy, 
                             i->r.min.x + wc->clipx + wc->clipw, 
                             i->r.min.y + wc->clipy + wc->cliph));
}

static void unclip(wcp wc, Image *i)
{
    if (wc->clipw >= 0)
        replclipr(i, 0, max_rect);
}

static void impl_drawstring(wcp wc, Image *dest, int x, int y, char *str, int slen)
{
    clip(wc, dest);
    stringn(dest, 
            Pt(dest->r.min.x + x,
               dest->r.min.y + y - wc->font->font->ascent),
            get_draw_img(wc), ZP, wc->font->font, str, slen);
    unclip(wc, dest);
}

void drawstring(wbp w, int x, int y, char *str, int slen)
{
    wsp ws = w->window;
    wcp wc = w->context;
    if (ws->win)
        impl_drawstring(wc, ws->win, x, y, str, slen);
    impl_drawstring(wc, ws->pix, x, y, str, slen);
    flushimage(display, 1);
}

static Rune *utf8_to_runes(char *str, int nchars)
{
    Rune *r;
    int i, j;
    MemProtect(r = malloc(nchars * sizeof(Rune)));
    for (i = 0; i < nchars; ++i) {
        j = chartorune(&r[i], str);
        str += j;
    }
    return r;
}

static void impl_drawutf8(wcp wc, Image *dest, int x, int y, Rune *str, int len)
{
    clip(wc, dest);
    runestringn(dest, 
                Pt(dest->r.min.x + x,
                   dest->r.min.y + y - wc->font->font->ascent),
                get_draw_img(wc), ZP, wc->font->font, str, len);
    unclip(wc, dest);
}

void drawutf8(wbp w, int x, int y, char *str, int slen, int nchars)
{
    wsp ws = w->window;
    wcp wc = w->context;
    Rune *r = utf8_to_runes(str, nchars);
    if (ws->win)
        impl_drawutf8(wc, ws->win, x, y, r, nchars);
    impl_drawutf8(wc, ws->pix, x, y, r, nchars);
    flushimage(display, 1);
    free(r);
}

static void impl_erasearea(wcp wc, Image *dest, int x, int y, int width, int height)
{
    Rectangle t = Rect(dest->r.min.x + x, 
                       dest->r.min.y + y,
                       dest->r.min.x + x + width,
                       dest->r.min.y + y + height);
    clip(wc, dest);
    gendraw(dest, t, wc->bg->i, ZP, 0, ZP);
    unclip(wc, dest);
}

void erasearea(wbp w, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    if (ws->win)
        impl_erasearea(wc, ws->win, x, y, width, height);
    impl_erasearea(wc, ws->pix, x, y, width, height);
    flushimage(display, 1);
}

void wsync (wbp w)
{
}

void pollevent(void)
{
    wsp ws;
    for (ws = wstates; ws; ws = ws->next) {
        if (ws->program == curpstate)
            flush_event_pipe(ws);
    }
}

int setfg(wbp w, char *val)
{
    int r, g, b, n;
    wcp wc = w->context;
    if (!parsecolor(val, &r, &g, &b))
        return Failed;
    if (wc->fg)
        unlink_sharedcolor(wc->fg);
    r /= 256;
    g /= 256;
    b /= 256;
    n = (r << 24) | (g << 16) | (b << 8) | 0xff;
    wc->fg = new_sharedcolor(val, n);
    return Succeeded;
}

char *getpattern(wbp w)
{
    return w->context->pattern->name;
}

char *getfg(wbp w)
{
    return w->context->fg->name;
}

int setbg(wbp w, char *val)
{
    int r, g, b, n;
    wcp wc = w->context;
    if (!parsecolor(val, &r, &g, &b))
        return Failed;
    if (wc->bg)
        unlink_sharedcolor(wc->bg);
    r /= 256;
    g /= 256;
    b /= 256;
    n = (r << 24) | (g << 16) | (b << 8) | 0xff;
    wc->bg = new_sharedcolor(val, n);
    return Succeeded;
}

char *getbg(wbp w)
{
    return w->context->bg->name;
}

#passthru #undef fillarc

static void impl_fillarc(wcp wc, Image *dest, int x, int y, int width, int height, double angle1, double angle2)
{
    int alpha, phi;
    clip(wc, dest);
    x += width/2;
    y += height/2;
    width /= 2;
    height /= 2;
    alpha = -angle1 * 180 / Pi;
    phi = -angle2 * 180 / Pi;
    fillarc(dest, 
            Pt(dest->r.min.x + x, dest->r.min.y + y),
            width, height,
            get_draw_img(wc),
            ZP,
            alpha, phi);
    unclip(wc, dest);
}

#passthru #define fillarc oi_fillarc        

void fillarc(wbp w, int x, int y, int width, int height, double angle1, double angle2)
{
    wsp ws = w->window;
    wcp wc = w->context;
    if (ws->win)
        impl_fillarc(wc, ws->win, x, y, width, height, angle1, angle2);
    impl_fillarc(wc, ws->pix, x, y, width, height, angle1, angle2);
    flushimage(display, 1);
}

static Image *get_draw_img(wcp wc)
{
    if (wc->fillstyle->i == FillSolid) {
        return wc->fg->i;
    } else {
        synch_pattern_image(wc->pattern, wc->fg->rgb, wc->bg->rgb, wc->fillstyle->i);
        return wc->pattern->i;
    }
}

static void impl_fillrectangle(wcp wc, Image *dest, int x, int y, int width, int height)
{
    Rectangle t = Rect(dest->r.min.x + x, 
                       dest->r.min.y + y,
                       dest->r.min.x + x + width,
                       dest->r.min.y + y + height);
    clip(wc, dest);
    gendraw(dest, t, get_draw_img(wc), ZP, 0, ZP);
    unclip(wc, dest);
}

void fillrectangle(wbp w, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    if (ws->win)
        impl_fillrectangle(wc, ws->win, x, y, width, height);
    impl_fillrectangle(wc, ws->pix, x, y, width, height);
    flushimage(display, 1);
}

static char *convert_spec(char *s)
{
    int flags, size;
    char family[MAXFONTWORD+1], *r;
    static char buff[256];

    if (*s == '/')
        return s;

    if (!strncmp(s, "p9:", 3))
        return s + 3;

    if (!parsefont(s, family, &flags, &size))
        return s;

    /*
     * Check for special "standard" family names.
     */
    if (!strcmp(family, "fixed"))
        r = "fixed/unicode.8x13.font";
    else if (!strcmp(family, "mono"))
        r = "courier/latin1.5.font";
    else if (!strcmp(family, "typewriter"))
        r = "courier/latin1.5.font";
    else if (!strcmp(family, "sans"))
        r = "lucidasans/latin1.7.font";
    else if (!strcmp(family, "serif"))
        r = "times/latin1.7.font";
    else
        r = "times/latin1.7.font";
            
    sprintf(buff, "/lib/font/bit/%s", r);
    return buff;
}

static wfp load_font(char *s)
{
    wfp rv;
    Font *f;

    /*
     * Convert to a font path name (without the p9: prefix)
     */
    s = convert_spec(s);

    /*
     * See if the font is already loaded.
     */
    for(rv = fonts; rv; rv = rv->next) {
        if (!strcmp(s, rv->name + 3))
            return rv;
    }

    f = openfont(display, s);
    if (!f) {
        f = display->defaultfont;
        s = "default font";
    }

    GRFX_ALLOC(rv, _wfont);
    MemProtect(rv->name = malloc(strlen(s) + 3 + 1));
    sprint(rv->name, "p9:%s", s);
    rv->ascent = f->ascent;               /* font dimensions */
    rv->descent = f->height - f->ascent;
    rv->height = f->height;
    rv->maxwidth = f->width;               /* max width of one char */
    rv->font = f;
    GRFX_LINK(rv, fonts);
    return rv;
}

int setfont(wbp w, char *s)
{
    w->context->font = load_font(s);
    return Succeeded;
}

int lowerwindow (wbp w)
{
    wsp ws = w->window;
    if (!ws->win)
        return Failed;
    fprint(ws->wctl_fd, "bottom");
    return Succeeded;
}

static void synch_pattern_image(struct SharedPattern *pat, int fg_rgb, int bg_rgb, int style)
{
    int i, j, k, v;
    unsigned char data[MAX_PATTERN_WIDTH * MAX_PATTERN_HEIGHT * 4];

    if (pat->i && pat->fg_rgb == fg_rgb && pat->bg_rgb == bg_rgb && pat->style == style)
        return;

    if (style == FillTextured) {
        /*
         * Textured style means no transparency; on bits are fg rgb, off bits
         * are bg rgb.
         */
        k = 0;
        for(i = 0; i < pat->height; i++) {
            v = pat->rowdata[i];
            for(j = 0; j < pat->width; j++) {
                int bit = (v & 1);
                if (bit) {
                    data[k++] = (fg_rgb>>8) & 0xff;
                    data[k++] = (fg_rgb>>16) & 0xff;
                    data[k++] = (fg_rgb>>24) & 0xff;
                } else {
                    data[k++] = (bg_rgb>>8) & 0xff;
                    data[k++] = (bg_rgb>>16) & 0xff;
                    data[k++] = (bg_rgb>>24) & 0xff;
                }
                v /= 2;
            }
        }

        if (pat->i)
            freeimage(pat->i);
        MemProtect(pat->i = allocimage(display, Rect(0, 0, pat->width, pat->height), RGB24, 1, DNofill));
    } else {
        /*
         * Masked style means off bits are transparent and on bits have the rgb of the
         * foreground.
         */
        k = 0;
        for(i = 0; i < pat->height; i++) {
            v = pat->rowdata[i];
            for(j = 0; j < pat->width; j++) {
                int bit = (v & 1);
                if (bit) {
                    data[k++] = 0xff;
                    data[k++] = (fg_rgb>>8) & 0xff;
                    data[k++] = (fg_rgb>>16) & 0xff;
                    data[k++] = (fg_rgb>>24) & 0xff;
                } else {
                    data[k++] = 0x00;
                    data[k++] = 0x00;
                    data[k++] = 0x00;
                    data[k++] = 0x00;
                }
                v /= 2;
            }
        }

        if (pat->i)
            freeimage(pat->i);
        MemProtect(pat->i = allocimage(display, Rect(0, 0, pat->width, pat->height), RGBA32, 1, DNofill));
    }

    loadimage(pat->i, pat->i->r, data, k);
    pat->fg_rgb = fg_rgb;
    pat->bg_rgb = bg_rgb;
    pat->style = style;
}

int setpattern(wbp w, char *name)
{
    int width, height, *rowdata;
    wcp wc = w->context;

    if (!parsepattern(name, &width, &height, &rowdata))
        return Failed;
    if (wc->pattern)
        unlink_sharedpattern(wc->pattern);
    wc->pattern = new_sharedpattern(width, height, rowdata, name);
    return Succeeded;
}

void loadimgmem(wbp w, struct imgmem *imem, int copy)
{
    wsp ws = w->window;
    MemProtect(imem->im = allocimage(display, Rect(0, 0, imem->width, imem->height), RGB24, 1, DNofill));
    imem->len = imem->width * imem->height * 3;
    MemProtect(imem->data = malloc(imem->len));
    if (copy) {
        /* Copy from pix to the tmp win */
        gendraw(imem->im, imem->im->r, ws->pix, Pt(imem->x, imem->y), 0, ZP);
        /* Get the pixels */
        unloadimage(imem->im, imem->im->r, imem->data, imem->len);
    }
}

void getpixel(struct imgmem *imem, int *r, int *g, int *b)
{
    uchar *p;
    p = &imem->data[3 * (imem->yoff*imem->width + imem->xoff)];
    *b = 257 * *p++;
    *g = 257 * *p++;
    *r = 257 * *p++;
}

void setpixel(struct imgmem *imem, int r, int g, int b)
{
    uchar *p = &imem->data[3 * (imem->yoff*imem->width + imem->xoff)];
    *p++ = b / 256;
    *p++ = g / 256;
    *p++ = r / 256;
}

static void impl_saveimgmem(wcp wc, Image *dest, struct imgmem *imem)
{
    clip(wc, dest);
    gendraw(dest,
            Rect(dest->r.min.x + imem->x, 
                 dest->r.min.y + imem->y,
                 dest->r.min.x + imem->x + imem->width,
                 dest->r.min.y + imem->y + imem->height),
            imem->im, ZP,
            0, ZP);
    unclip(wc, dest);
}

void saveimgmem(wbp w, struct imgmem *imem)
{
    wcp wc = w->context;
    wsp ws = w->window;
    /* Put the altered pixels back in the image */
    loadimage(imem->im, imem->im->r, imem->data, imem->len);
    /* Copy tmp image back to screen */
    if (ws->win)
        impl_saveimgmem(wc, ws->win, imem);
    impl_saveimgmem(wc, ws->pix, imem);
    flushimage(display, 1);
}

void freeimgmem(struct imgmem *imem)
{
    free(imem->data);
    freeimage(imem->im);
}

int queryrootpointer(wbp w, int *x, int *y)
{
    return Failed;
}

int raisewindow(wbp w)
{
    wsp ws = w->window;
    if (!ws->win)
        return Failed;
    fprint(ws->wctl_fd, "unhide");
    fprint(ws->wctl_fd, "top");
    fprint(ws->wctl_fd, "current");
    return Succeeded;
}

int textwidth(wbp w, char *s, int n)
{
    wcp wc = w->context;
    return stringnwidth(wc->font->font, s, n);
}

int utf8width(wbp w, char *s, int n, int nchars)
{
    wcp wc = w->context;
    int width;
    Rune *r = utf8_to_runes(s, nchars);
    width = runestringnwidth(wc->font->font, r, nchars);
    free(r);
    return width;
}

void doconfig(wbp w, int status)
{
    wsp ws = w->window;

    /* Move/resize of window if open */
    if (ws->win) {
        /* Limit size, if changed */
        if (status & (C_SIZE|C_MAXSIZE|C_MINSIZE)) {
            if (limit_size(ws, &ws->width, &ws->height))
                status |= C_SIZE;
        }
        if (status & C_POS)
            fprint(ws->wctl_fd, "move  -minx %d -miny %d", ws->x, ws->y);
        if (status & C_SIZE)
            fprint(ws->wctl_fd, "resize  -dx %d -dy %d", 
                   ws->width + 2*Borderwidth, 
                   ws->height + 2*Borderwidth);
    }
    if (status & C_SIZE)
        resize_pix_win(w);

    if (status & C_IMAGE) {
        struct imgdata *imd = &ws->initimage;
        if (imd->width) {
            drawimgdata(w, 0, 0, imd);
            freeimgdata(imd);
        }
    }
}

void wflush(wbp w)
{
}

int ownselection(wbp w, char *selection)
{
    wsp ws = w->window;
    tended struct descrip tmp;

    /* Note - could filter out selections to use CLIPBOARD only, ie ^C, not drag */
    MakeInt(SELECTIONREQUEST, &tmp);
    list_put(&ws->listp, &tmp);
    list_put(&ws->listp, &zerodesc);/* req id */
    LitStr("none", &tmp);           /* property */
    list_put(&ws->listp, &tmp);
    cstr2string(selection, &tmp);   /* selection */
    list_put(&ws->listp, &tmp);
    LitStr("UTF8_STRING", &tmp);    /* type */
    list_put(&ws->listp, &tmp);
    list_put(&ws->listp, &zerodesc); /* time */
    return Succeeded;
}

int requestselection(wbp w, char *selection, char *target)
{
    wsp ws = w->window;
    tended struct descrip tmp;
    int snarf_len = 0;
    char *snarf = 0;

    if (strcmp(target, "UTF8_STRING") == 0) {
        int fd, n_read;
        char buff[512];
        /* Note - could filter out selections to use CLIPBOARD only, ie ^C, not drag */
        if ((fd = open("/dev/snarf", OREAD)) < 0) {
            whyf("Can't open snarf file: %r");
            return Failed;
        }
        while ((n_read = read(fd, buff, sizeof buff)) > 0) {
            MemProtect(snarf = realloc(snarf, snarf_len + n_read));
            memcpy(snarf + snarf_len, buff, n_read);
            snarf_len += n_read;
        }
        close(fd);
    }

    MakeInt(SELECTIONRESPONSE, &tmp);
    list_put(&ws->listp, &tmp);
    cstr2string(selection, &tmp);   /* selection */
    list_put(&ws->listp, &tmp);
    cstr2string(target, &tmp);      /* target */
    list_put(&ws->listp, &tmp);
    if (snarf) {
        bytes2string(snarf, snarf_len, &tmp);
        list_put(&ws->listp, &tmp);
        free(snarf);
    } else
        list_put(&ws->listp, &nulldesc);

    return Succeeded;
}

int sendselectionresponse(wbp w, word requestor, char *property, 
                          char *selection, char *target, word time, dptr data)
{
    int fd;
    /* data is &null if the selection doesn't support what we asked for (UTF8_STRING) */
    if (is:null(*data))
        return Succeeded;

    if (!cnv:string(*data, *data))
        ReturnErrVal(103, *data, Error);
    if ((fd = open("/dev/snarf", OWRITE)) < 0) {
        whyf("Can't open snarf file: %r");
        return Failed;
    }
    /*print("setting snarf to %.*s\n",StrLen(*data),StrLoc(*data));*/
    write(fd, StrLoc(*data), StrLen(*data));
    close(fd);
    return Succeeded;
}

static void kill_proc(int id)
{
    postnote(PNPROC, id, "kill");
    free(waitforpid(id));
}

static int open_screen_win(wsp ws)
{
    char buff[256];
    int fd;

    ws->using_win = use_win;

    if (ws->using_win) {
        strcpy(ws->mount_dir, "/dev");

        if ((ws->wctl_fd = open_winfile(ws, "wctl", OWRITE)) < 0) {
            whyf("Can't open wctl file: %r");
            close_screen_win(ws);
            return Failed;
        }

        fprint(ws->wctl_fd, "resize  -dx %d -dy %d", 
               ws->width + 2*Borderwidth, ws->height + 2*Borderwidth);

        if (ws->x != -INT_MAX && ws->y != -INT_MAX)
            fprint(ws->wctl_fd, "move  -minx %d -miny %d", ws->x, ws->y);

        use_win = 0;
    } else {
        ws->wsys_fd = open(ws->wsys, ORDWR);
        if (ws->wsys_fd < 0) {
            whyf("Can't open $wsys(%s): %r", ws->wsys);
            close_screen_win(ws);
            return Failed;
        }
        sprintf(ws->mount_dir, "%s/%d", WINDOW_MOUNT_ROOT, ++window_count);
        if (mkdir(ws->mount_dir, 0777) < 0) {
            whyf("Can't make window mount dir (%s): %r", ws->mount_dir);
            close_screen_win(ws);
            return Failed;
        }
        /* If either x or y unset, let rio place the window */
        if (ws->x == -INT_MAX || ws->y == -INT_MAX)
            sprintf(buff, "new -dx %d -dy %d",
                    ws->width + 2*Borderwidth, 
                    ws->height + 2*Borderwidth);
        else
            sprintf(buff, "new -r %d %d %d %d",
                    ws->x, ws->y, ws->x + ws->width + 2*Borderwidth, 
                    ws->y + ws->height + 2*Borderwidth);
        if (ws->desired_canvas == IconicCanvas)
            strcat(buff, " -hide");
        if (mount(ws->wsys_fd, -1, ws->mount_dir, MREPL, buff) < 0) {
            whyf("Can't mount new window: %r");
            close_screen_win(ws);
            return Failed;
        }
        if ((ws->wctl_fd = open_winfile(ws, "wctl", OWRITE)) < 0) {
            whyf("Can't open wctl file: %r");
            close_screen_win(ws);
            return Failed;
        }
    }

    sprintf(buff, "%s/winname", ws->mount_dir);
    if (gengetwindow(display, buff, &ws->win, &ws->screen, Refnone) < 0) {
        whyf("gengetwindow failed: %r");
        close_screen_win(ws);
        return Failed;
    }
    synch_pos(ws);

    /* Ensure size matches the opened window */
    ws->width =  ws->win->r.max.x - ws->win->r.min.x;
    ws->height = ws->win->r.max.y - ws->win->r.min.y;
    resize_pix_win(find_first_wbp_for(ws));

    if ((fd = open_winfile(ws, "label", OWRITE)) < 0) {
        whyf("Can't open label file %r");
        close_screen_win(ws);
        return Failed;
    }
    write(fd, ws->windowlabel, strlen(ws->windowlabel));
    close(fd);

    if (pipe(ws->event_pipe) < 0) {
        whyf("Couldn't init event pipe: %r");
        close_screen_win(ws);
        return Failed;
    }

    if ((ws->mouse_fd = open_winfile(ws, "mouse", ORDWR|OCEXEC)) < 0) {
        whyf("Can't open mouse file: %r");
        close_screen_win(ws);
        return Failed;
    }

    if ((ws->cons_fd = open_winfile(ws, "cons", OREAD)) < 0) {
        whyf("Can't open cons file: %r");
        close_screen_win(ws);
        return Failed;
    }

    if ((ws->consctl_fd = open_winfile(ws, "consctl", OWRITE|OCEXEC)) < 0) {
        whyf("Can't open consctl file: %r");
        close_screen_win(ws);
        return Failed;
    }
    write(ws->consctl_fd, "rawon", 5);

    if ((ws->cursor_fd = open_winfile(ws, "cursor", OWRITE|OCEXEC)) < 0) {
        whyf("Can't open cursor file: %r");
        close_screen_win(ws);
        return Failed;
    }
    synch_cursor(ws);

    switch (ws->mouse_pid = rfork(RFPROC|RFMEM)) {
        case 0: {
            mouse_loop(ws->mouse_fd, ws->event_pipe[1]);
            break;
        }
        case -1: {
            whyf("rfork failed: %r");
            close_screen_win(ws);
            return Failed;
        }
    }

    switch (ws->cons_pid = rfork(RFPROC|RFMEM)) {
        case 0: {
            cons_loop(ws->cons_fd, ws->event_pipe[1]);
            break;
        }
        case -1: {
            whyf("rfork failed: %r");
            close_screen_win(ws);
            return Failed;
        }
    }

    return Succeeded;
}

static Image *any_other_win(Image *win)
{
    wsp ws;
    for (ws = wstates; ws; ws = ws->next)
        if (ws->win && ws->win != win)
            return ws->win;
    return 0;
}

static void close_screen_win(wsp ws)
{
    if (!ws->using_win) {
        unmount(0, ws->mount_dir);
        remove(ws->mount_dir);
    }
    if (ws->event_pipe[0] >= 0)
        close(ws->event_pipe[0]);
    if (ws->event_pipe[1] >= 0)
        close(ws->event_pipe[1]);
    if (ws->consctl_fd >= 0)
        close(ws->consctl_fd);
    if (ws->cursor_fd >= 0)
        close(ws->cursor_fd);
    if (ws->mouse_fd >= 0)
        close(ws->mouse_fd);
    if (ws->cons_fd >= 0)
        close(ws->cons_fd);
    if (ws->mouse_pid >= 0)
        kill_proc(ws->mouse_pid);
    if (ws->cons_pid >= 0)
        kill_proc(ws->cons_pid);
    if (ws->wsys_fd >= 0)
        close(ws->wsys_fd);
    /* 
     * See the source for gengetwindow for the sequence of
     * freeing the bits of the images/screens.
     */
    if (ws->win) {
        /* Avoid reference to freed window remaining in display structure (although it doesn't
         * seem to be used).
         */
        if (ws->win == display->screenimage)
            display->screenimage = any_other_win(ws->win);
        freeimage(ws->win);
        ws->win = 0;
    }
    if (ws->screen) {
        freeimage(ws->screen->image);
        freescreen(ws->screen);
        ws->screen = 0;
    }
    if (ws->wctl_fd >= 0)
        close(ws->wctl_fd);

    ws->mount_dir[0] = 0;
    ws->event_pipe[0] = ws->event_pipe[1] = ws->mouse_fd = ws->cons_fd = ws->consctl_fd =
        ws->cursor_fd = ws->mouse_pid = ws->cons_pid = ws->wsys_fd = ws->wctl_fd = -1;
}

static void open_pix_win(wsp ws)
{
    MemProtect(ws->pix = allocimage(display, Rect(0, 0, ws->width, ws->height), screen->chan, 1, DNofill));
}

static void close_pix_win(wsp ws)
{
    if (ws->pix) {
        freeimage(ws->pix);
        ws->pix = 0;
    }
}

void wclose(wbp w)
{
    wsp ws = w->window;
    pollevent();
    if (ws->win && ws->refcount > 1) {
        /* Turn into pixmap */
        ws->desired_canvas = HiddenCanvas;
        configure_canvas(w); 
    }
}

void freewindow(wsp ws)
{
   ws->refcount--;
   if (ws->refcount == 0) {
       struct imgdata *imd;
       if (ws->win)
           close_screen_win(ws);
       if (ws->pix)
           close_pix_win(ws);
       if (ws->windowlabel) { 
           free(ws->windowlabel); 
           ws->windowlabel = 0;
       }
       imd = &ws->initimage;
       if (imd->width) {
           free(imd->paltbl);
           free(imd->data);
           imd->width = 0;
       }
       if (ws->wsys) {
           free(ws->wsys);
           ws->wsys = 0;
       }
       GRFX_UNLINK(ws, wstates);
   }
}

void freecontext(wcp wc)
{
    wc->refcount--;
    if (wc->refcount == 0) {
        if (wc->fg)
            unlink_sharedcolor(wc->fg);
        if (wc->bg)
            unlink_sharedcolor(wc->bg);
        if (wc->pattern)
            unlink_sharedpattern(wc->pattern);
        GRFX_UNLINK(wc, wcntxts);
    }
}

int setinputmask(wbp w, char *val)
{
    wsp ws = w->window;
    int t;
    if (!parseinputmask(val, &t))
        return Failed;
    ws->inputmask = t;
    return Succeeded;
}

int setcanvas(wbp w, char *s)
{
    stringint *e;
    wsp ws = w->window;
    e = stringint_lookup(canvastypes, s);
    if (!e)
        return Failed;
    ws->desired_canvas = e->i;

    /* 
     * If the window is already open, call configure_canvas now;
     * otherwise it is called from wopen.
     */
    if (ws->pix) {
        if (configure_canvas(w) == Failed)
            return Failed;
    }

    return Succeeded;
}

int setwindowlabel(wbp w, char *val)
{
    wsp ws = w->window;
    if (ws->windowlabel) 
        free(ws->windowlabel);
    ws->windowlabel = salloc(val);
    if (ws->win) {
        int fd;
        if ((fd = open_winfile(ws, "label", OWRITE)) < 0) {
            whyf("Can't open label file %r");
            return Failed;
        }
        write(fd, val, strlen(val));
        close(fd);
    }
    return Succeeded;
}

int setfillstyle(wbp w, char *val)
{
    wcp wc = w->context;
    stringint *e = stringint_lookup(fillstyles, val);
    if (!e)
        return Failed;
    wc->fillstyle = e;
    return Succeeded;
}

char *getfillstyle(wbp w)
{
    return w->context->fillstyle->s;
}

int setlinestyle(wbp w, char *val)
{
    if (strcmp(val, "solid") != 0)
        return Failed;
    return Succeeded;
}

int setlinewidth(wbp w, int linewid)
{
    wcp wc = w->context;
    wc->thick = linewid / 2;
    return Succeeded;
}

int getlinewidth(wbp w)
{
    return 1 + w->context->thick * 2;
}

static void synch_cursor(wsp ws)
{
    if (ws->cursor->i == -1)
        write(ws->cursor_fd, "", 0);
    else
        write(ws->cursor_fd, &cursor_data[ws->cursor->i], sizeof(struct Cursor));
}

int setpointer(wbp w, char *val)
{
    wsp ws = w->window;
    stringint *e = stringint_lookup(cursors, val);
    if (!e)
        return Failed;
    ws->cursor = e;
    if (ws->win)
        synch_cursor(ws);
    return Succeeded;
}

int setdrawop(wbp w, char *val)
{
    if (strcmp(val, "copy") != 0)
        return Failed;
    return Succeeded;
}

int warppointer(wbp w, int x, int y)
{
    return Failed;
}

char *getdisplay(wbp w)
{
    return w->window->wsys;
}

int getpos(wbp w)
{
    wsp ws = w->window;
    if (!ws)
        return Failed;
    synch_pos(ws);
    return Succeeded;
}

char *getlinestyle(wbp w)
{
    return "solid";
}

int querypointer(wbp w, int *x, int *y)
{
    wsp ws = w->window;
    *x = ws->last_mouse_x;
    *y = ws->last_mouse_y;
    return Succeeded;
}

char *getpointer(wbp w)
{
    return w->window->cursor->s;
}

char *getdrawop(wbp w)
{
    return "copy";
}

char *getcanvas(wbp w)
{
    wsp ws = w->window;
    if (ws->win) {
        char buff[256];
        int fd;
        buff[0] = 0;
        if ((fd = open_winfile(ws, "wctl", OREAD)) >= 0) {
            int n = read(fd, buff, sizeof(buff) - 1);
            if (n > 0)
                buff[n] = 0;
            close(fd);
        }
        if (strstr(buff, "hidden"))
            return "iconic";
        else
            return "normal";
    } else
        return "hidden";
}

int getdisplaysize(wbp w, int *width, int *height)
{
    Rectangle r = display->image->r;
    *width = Dx(r);
    *height = Dy(r);
    return Succeeded;
}

int getdepth(wbp w, int *res)
{
    *res = w->window->pix->depth;
    return Succeeded;
}

char *getwindowlabel(wbp w)
{
    return w->window->windowlabel;
}

static wsp alcwinstate()
{
    wsp ws;
    GRFX_ALLOC(ws, _wstate);
    ws->serial = ++canvas_serial;
    ws->program = curpstate;
    ws->listp = nulldesc;    /* set to [] after linked into global context list */
    ws->buttonorder[0] = 1;
    ws->buttonorder[1] = 2;
    ws->buttonorder[2] = 4;
    ws->event_pipe[0] = ws->event_pipe[1] = ws->mouse_fd = ws->cons_fd = ws->consctl_fd =
        ws->cursor_fd = ws->mouse_pid = ws->cons_pid = ws->wsys_fd = ws->wctl_fd = -1;
    ws->cursor = stringint_lookup(cursors, "left ptr");
    ws->height = 200;
    ws->width  = 200;
    ws->x = ws->y = -INT_MAX;
    ws->minwidth = ws->minheight = 1;
    ws->maxwidth = ws->maxheight = INT_MAX;
    ws->desired_canvas = NormalCanvas;
    ws->windowlabel = salloc(DEFAULT_WINDOW_LABEL);
    GRFX_LINK(ws, wstates);
    return ws;
}

wcp clonecontext(wbp w)
{
    wcp src, wc;
    src = w->context;
    GRFX_ALLOC(wc, _wcontext);
    wc->serial = ++context_serial;
    wc->dx = src->dx;
    wc->dy = src->dy;
    wc->clipx = src->clipx;
    wc->clipy = src->clipy;
    wc->clipw = src->clipw;
    wc->cliph = src->cliph;
    wc->fg = link_sharedcolor(src->fg);
    wc->bg = link_sharedcolor(src->bg);
    wc->pattern = link_sharedpattern(src->pattern);
    wc->font = src->font;
    wc->thick = src->thick;
    wc->fillstyle = src->fillstyle;
    GRFX_LINK(wc, wcntxts);
    return wc;
}

static int black_pattern_data[] =  {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

static wcp alccontext(wbp w)
{
    wcp wc;
    GRFX_ALLOC(wc, _wcontext);
    wc->serial = ++context_serial;
    wc->clipx = wc->clipy = 0;
    wc->clipw = wc->cliph = -1;
    wc->fg = link_sharedcolor(black);
    wc->bg = link_sharedcolor(white);
    wc->pattern = link_sharedpattern(black_pattern);
    wc->font = new_context_font;
    wc->fillstyle = stringint_lookup(fillstyles, "solid");
    GRFX_LINK(wc, wcntxts);
    return wc;
}

static char Ebad[] = "something bad happened";

static void fscreate(Req *r)
{
    File *f;
    if (f = createfile(r->fid->file, r->ifcall.name, r->fid->uid, r->ifcall.perm, nil)){
        r->fid->file = f;
        r->ofcall.qid = f->qid;
        respond(r, nil);
        return;
    }
    respond(r, Ebad);
}

Srv win_fs;

static void close_window_system(void)
{
    wsp ws;
    int fd;
    for (ws = wstates; ws; ws = ws->next) {
       if (ws->win)
           close_screen_win(ws);
    }
    unmount(0, WINDOW_MOUNT_ROOT);
    closedisplay(display);
    if ((fd = open("/dev/wctl", OWRITE)) >= 0) {
        fprint(fd, "top"); 
        fprint(fd, "current");
        close(fd);
    }
    close(bintime_fd);
}

static struct Cursor cursor_data[] = {
    #include "p9cursors/bullseye"          /*  0 */
    #include "p9cursors/crosscursor"       /*  1 */
    #include "p9cursors/boxcursor"         /*  2 */
    #include "p9cursors/sightcursor"       /*  3 */
    #include "p9cursors/whitearrow"        /*  4 */
    #include "p9cursors/query"             /*  5 */
    #include "p9cursors/top_left_corner"   /*  6 */
    #include "p9cursors/top_side"          /*  7 */
    #include "p9cursors/top_right_corner"  /*  8 */
    #include "p9cursors/right_side"        /*  9 */
    #include "p9cursors/bottom_right_corner"/* 10 */
    #include "p9cursors/bottom_side"       /* 11 */
    #include "p9cursors/bottom_left_corner"/* 12 */
    #include "p9cursors/left_side"         /* 13 */
    #include "p9cursors/xterm"             /* 14 */
    #include "p9cursors/fleur"             /* 15 */
    #include "p9cursors/arrow"             /* 16 */
    #include "p9cursors/bottom_tee"        /* 17 */
    #include "p9cursors/center_ptr"        /* 18 */
    #include "p9cursors/circle"            /* 19 */
    #include "p9cursors/cross"             /* 20 */
    #include "p9cursors/cross_reverse"     /* 21 */
    #include "p9cursors/crosshair"         /* 22 */
    #include "p9cursors/diamond_cross"     /* 23 */
    #include "p9cursors/dot"               /* 24 */
    #include "p9cursors/x_cursor"          /* 25 */
    #include "p9cursors/sb_h_double_arrow" /* 26 */
    #include "p9cursors/sb_v_double_arrow" /* 27 */
    #include "p9cursors/hand2"             /* 28 */
    #include "p9cursors/exchange"          /* 29 */
    #include "p9cursors/watch"             /* 30 */
};

static void init_window_system(void)
{
    Dir *fs;

    if ((bintime_fd = open("/dev/bintime", OREAD)) < 0)
        ffatalerr("Can't open /dev/bintime: %r");

    if (initdraw(draw_error, 0, 0) < 0)
        ffatalerr("Couldn't initialize window system: %r");

    /* Keep mounts private */
    rfork(RFNAMEG); 

    /* Ensure the window mount root exists */
    mkdir(WINDOW_MOUNT_ROOT, 0777);
    fs = dirstat(WINDOW_MOUNT_ROOT);
    if (!fs || !(fs->mode & DMDIR))
        ffatalerr("Couldn't initialize window mount directory: %r");
    free(fs);

    win_fs.tree = alloctree(0, 0, DMDIR | 0777, 0);
    win_fs.create = fscreate;
    postmountsrv(&win_fs, 0, WINDOW_MOUNT_ROOT, MREPL | MCREATE);
    atexit(close_window_system);

    /* Bug workaround which prevents accessing rio's mounted window dir if it is the only
     * entry in the directory */
    mkdir(WINDOW_MOUNT_ROOT "/JUNK", 0777);

    black = new_sharedcolor("black", 0x000000ff);
    white = new_sharedcolor("white", 0xffffffff);
    black_pattern = new_sharedpattern(8, 8, black_pattern_data, "black");
    max_rect = Rect(-1073741823, -1073741823, 1073741823, 1073741823);
    startup_time = get_time();
    new_context_font = load_font("fixed");
    use_win = (getenv("OIUSEWIN") != 0);

    memimageinit();
}

static vlong get_time()
{
    uchar b[8];
    vlong t;
    read(bintime_fd, b, sizeof(b));
    be2vlong(&t, b);
    return t;
}

static void note_time(char *s)
{
    static vlong prev;
    if (prev) {
        int t = (get_time() - prev) / 1000000;
        fprint(2, "%d: - %s\n", t, s);
    }
    prev = get_time();
}

int readimagefileimpl(char *filename, struct imgdata *imd)
{
    Memimage *m;
    int pid, pip[2], fd, ndata, format;
    char *cmd;
    struct fileparts *fp = fparse(filename);
    if (strcasecmp(fp->ext, ".png") == 0)
        cmd = "png -9 -3";
    else if (strcasecmp(fp->ext, ".jpg") == 0 || strcasecmp(fp->ext, ".jpeg") == 0)
        cmd = "jpg -9 -3";
    else if (strcasecmp(fp->ext, ".gif") == 0)
        cmd = "gif -9 -3";
    else
        return NoCvt;
    if ((fd = open(filename, OREAD)) < 0) {
        whyf("Couldn't open %s: %r", filename);
        return Failed;
    }
    if (pipe(pip) < 0) {
        whyf("Couldn't make pipe: %r");
        close(fd);
        return Failed;
    }
    switch (pid = fork()) {
        case -1: {
            whyf("Couldn't fork: %r");
            close(fd);
            close(pip[0]);
            close(pip[1]);
            return Failed;
        }
        case 0: {
            int nf;
            dup(fd, 0);
            dup(pip[0], 1);
            if ((nf = open("/dev/null", OWRITE)) >= 0) {
                dup(nf, 2);
                close(nf);
            }
            close(fd);
            close(pip[0]);
            close(pip[1]);
            execl("/bin/rc", "rc", "-c", cmd, 0);
            _exits(0);
        }
    }

    close(pip[0]);
    close(fd);
    m = readmemimage(pip[1]);
    close(pip[1]);
    free(waitforpid(pid));

    if (!m) {
        whyf("Failed to readmemimage on file %s: %r", filename);
        return Failed;
    }
    switch (m->chan) {
        case RGB24: {
            format = IMGDATA_BGR24;
            break;
        }
        case RGBA32: {
            format = IMGDATA_ABGR32;
            break;
        }
        case GREY8: {
            format = IMGDATA_G8;
            break;
        }
        case CHAN2(CGrey, 8, CAlpha, 8): {
            format = IMGDATA_AG16;
            break;
        }
        default: {
            char buf[10];
            chantostr(buf,m->chan);
            whyf("Unknown channel format %s from command %s <%s", 
                 buf, cmd, filename);
            freememimage(m);
            return Failed;
        }
    }
    imd->width = Dx(m->r);
    imd->height = Dy(m->r);
    imd->paltbl = 0;
    imd->format = format;
    ndata = imd->width * imd->height * m->nchan;
    MemProtect(imd->data = malloc(ndata));
    unloadmemimage(m, m->r, imd->data, ndata);
    freememimage(m);
    return Succeeded;
}

int writeimagefileimpl(wbp w, char *filename, int x, int y, int width, int height)
{
    Memimage *m;
    int pip[2], pid, fd, ndata;
    char *cmd;
    uchar *data;
    struct imgmem imem;
    struct fileparts *fp = fparse(filename);

    if (strcasecmp(fp->ext, ".png") == 0)
        cmd = "topng";
    else if (strcasecmp(fp->ext, ".gif") == 0)
        cmd = "togif";
    else
        return NoCvt;

    if ((fd = create(filename, OWRITE, 0777)) < 0) {
        whyf("Couldn't open %s: %r", filename);
        return Failed;
    }
    if (pipe(pip) < 0) {
        whyf("Couldn't make pipe: %r");
        close(fd);
        return Failed;
    }

    ndata = 3 * width * height;
    MemProtect(data = malloc(ndata));
    if (initimgmem(w, &imem, 1, 0, x, y, width, height)) {
        int i, j;
        uchar *p = data;
        for (j = y; j < y + height; j++) {
            for (i = x; i < x + width; i++) {
                if (gotopixel(&imem, i, j)) {
                    int r, g, b;
                    getpixel(&imem, &r, &g, &b);
                    *p++ = b / 256;
                    *p++ = g / 256;
                    *p++ = r / 256;
                } else {
                    *p++ = 0;
                    *p++ = 0;
                    *p++ = 0;
                }
            }
        }
    } else
        memset(data, 0, ndata);

    MemProtect(m = allocmemimage(Rect(0, 0, width, height), RGB24));
    loadmemimage(m, m->r, data, ndata);
    free(data);

    switch (pid = fork()) {
        case -1: {
            whyf("Couldn't fork: %r");
            freememimage(m);
            close(fd);
            close(pip[0]);
            close(pip[1]);
            return Failed;
        }
        case 0: {
            dup(pip[0], 0);
            dup(fd, 1);
            close(fd);
            close(pip[0]);
            close(pip[1]);
            execl("/bin/rc", "rc", "-c", cmd, 0);
            _exits(0);
        }
    }
    close(pip[0]);
    close(fd);
    writememimage(pip[1], m);
    free(waitforpid(pid));
    freememimage(m);
    close(pip[1]);
    return Succeeded;
}
