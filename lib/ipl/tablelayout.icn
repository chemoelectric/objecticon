package ipl.browser

import 
   util, 
   lang,
   ipl.sort,
   io,
   gui,
   ipl.graphics

class TableCellInfo(Insets)
   public 
      obj,            # An arbitrary object 
      grid,           # The grid we're in
      ax,             # Actual computed pixel location and size,
      ay,             # within insets, ie where to draw the thing
      aw,             # inside the cell.
      ah,
      s,              # Identifying string for print_layout
      x,              # Location, size in grid units.
      y, 
      w, 
      h, 
      pct_w,
      fix_w,
      fix_h,
      max_w,
      pw,             # Preferred cell width excluding insets
      ph,
      ph_calc_w,      # Width used to calc ph
      ascent,         # Ascent of first row
      ascent_adj      # Adjustment needed to align baselines
   #
   # Output object
   #
   private object_output(oo)
      local t
      t := s || ": "
      t ||:= " pos=" || self.x || "," || self.y || " dim=" || self.w || "," || self.h ||
         " component pref width=" || pw ||" max width=" || max_w
      t ||:= "\n\theight=" || ph || " calculated from width " || ph_calc_w
      t ||:= "\n\tcell desired size=" || pw + l_inset + r_inset || "," || 
         ph + ascent_adj + t_inset + b_inset
      t ||:= " located to=" || \ax || "," || \ay || " size set to " || \aw || "," || \ah
      t ||:= " pct_w=" || \pct_w
      oo.object_string(self, t)
   end
end

class TableGrid()
   public 
      gw,           # Grid width, height in cells
      gh, 
      p_col_max_w,   # Max column widths
      p_col_w,      # Preferred column widths/row heights
      p_row_h,
      pct_col_w,
      a_col_w,      # Actual column widths/row heights after extra
      a_row_h,      # space has been allocated
      col_x,        # Actual row x and y values
      row_y,
      info,         # List of CellInfo for each component being laid out
      dii,          # Default inner padding, ie not at edge of grid
      doi,          # Default outer padding
      id_str,       # For generating CellInfo string ids for debug
      add_x,        # For auto-computing cell position and sizes.
      add_y,
      add_row_h,
      fix_col1_flag

   public create_cell(t)
      local ci
      ci := TableCellInfo()
      ci.grid := self
      ci.s := id_str[1]
      id_str[1] := ""
      self.add_x +:= Grid.validate_int(t, "x_tab")
      if self.add_y +:= Grid.validate_int(t, "y_tab") then
         add_row_h := 0
      ci.x := Grid.validate_int(t, "x", add_x)
      ci.y := Grid.validate_int(t, "y", add_y)
      ci.w := Grid.validate_int(t, "w", 1)
      ci.h := Grid.validate_int(t, "h", 1)
      add_row_h <:= ci.h
      if /Grid.validate_flag(t, "eol") then {
         add_x := ci.x + ci.w
         add_y := ci.y
      } else {
         add_x := 1
         add_y +:= add_row_h
         add_row_h := 0
      }
      ci.ascent_adj := 0
      ci.pct_w := Grid.validate_int(t, "pct_w", 0)
      ci.fix_w := Grid.validate_int(t, "fix_w")
      ci.fix_h := Grid.validate_int(t, "fix_h")
      put(info, ci)

      return ci
   end

   public dimension()
      local ci

      # Work out grid width/height
      gw := gh := 0
      every ci := !info do {
         gw <:= ci.x + ci.w - 1
         gh <:= ci.y + ci.h - 1
      }

      # Fill in final defaults now we have the grid dimensions.
      every ci := !info do {
         ci.l_inset := if ci.x = 1 then self.doi else self.dii
         ci.t_inset := if ci.y = 1 then self.doi else self.dii
         ci.r_inset := if ci.x + ci.w = gw + 1 then self.doi else self.dii
         ci.b_inset := if ci.y + ci.h = gh + 1 then self.doi else self.dii
      }
   end

   public static dist_equally(start, span, extra, l, flag)
      local left, i, a
      if span = 0 then
         fail
      if \flag & start = 1 & span > 1 then {
         start := 2
         span -:= 1
         #write(start,",",span,",",extra)
      }
      a := extra / span
      left := extra
      every i := start to start + span - 1 do {
         l[i] +:= a
         left -:= a
      }
      l[i] +:= left
   end

   public compute_preferred_col_widths()
      local i, need, l
      p_col_w := list(gw, 0)
      p_col_max_w := list(gw, 0)
      pct_col_w := list(gw, 0)
      l := isort(info, cell_width_sort)

      # Compute sizes
      every i := !l do {
         need := i.pw + i.l_inset + i.r_inset - Grid.slice(i.x, i.w, p_col_w)
         if need > 0 then
            dist_equally(i.x, i.w, need, p_col_w, fix_col1_flag)

         need := i.max_w + i.l_inset + i.r_inset - Grid.slice(i.x, i.w, p_col_max_w)
         if need > 0 then
            dist_equally(i.x, i.w, need, p_col_max_w, fix_col1_flag)

         need := i.pct_w - Grid.slice(i.x, i.w, pct_col_w)
         if need > 0 then
            dist_equally(i.x, i.w, need, pct_col_w, fix_col1_flag)
      }

      compute_pct_widths()
   end

   # Adjust the p_col_max_w based on any column % widths; preferred
   # widths are not affected.
   private compute_pct_widths()
      local pe, n, i, ppp, tot
      tot := Grid.total(pct_col_w)
      if tot = 0 then
         fail

      if tot < 100 then {
         # Total <100%, so allocate residue to any columns without a %
         # specified (pct_col_w = 0%).
         n := 0
         every i := !pct_col_w do
            if i = 0 then n +:= 1
         if n > 0 then {
            pe := (100 - tot) / n
            every i := 1 to *pct_col_w do
               if pct_col_w[i] = 0 then
                  pct_col_w[i] := pe
         }
      }

      # Now calculate the maximum pixels-per-percentage value
      ppp := 0
      every i := 1 to gw do
         ppp <:= real(p_col_max_w[i]) / (0 < pct_col_w[i])

      # Expand column max widths, based on the % and the pixels-per-percentage
      every i := 1 to gw do
         p_col_max_w[i] <:= integer(ppp * pct_col_w[i])
   end

   public compute_preferred_row_heights()
      local i, need, l
      p_row_h := list(gh, 0)
      l := isort(info, cell_height_sort)

      # Compute sizes
      every i := !l do {
         need := i.ph + i.ascent_adj + i.t_inset + i.b_inset - Grid.slice(i.y, i.h, p_row_h)
         if need > 0 then 
            dist_equally(i.y, i.h, need, p_row_h)
      }
   end

   private static cell_width_sort(i)
      return i.w
   end

   private static cell_height_sort(i)
      return i.h
   end

   public print_layout()
      local x, y, t, i, s

      write("Grid dimensions:", gw, ",",gh)
      t := table()
      every t[(1 to gw)||","||(1 to gh)] := " "

      every i := !info do
         every t[(i.x to i.x + i.w - 1)||","||(i.y to i.y + i.h - 1)] := i.s

      write(s := repl("+-", gw) || "+")
      every y := 1 to gh do {
         every x := 1 to gw do
            writes("|", t[x||","||y])
         write("|\n",s)
      }

      write("----- Items ------")
      every write(to_string(!info))

      write("----- Data -------")
      write("p_col_w=", to_string(p_col_w))
      write("p_col_max_w=", to_string(p_col_max_w))
      if \self.a_col_w then {
         write("a_col_w=", to_string(a_col_w))
         write("\textra width in a_col_w:", Grid.total(a_col_w)-Grid.total(p_col_w))
      }
      write("p_row_h=", to_string(p_row_h))
      if \self.a_row_h then {
         write("a_row_h=", to_string(a_row_h))
         write("\textra height in a_row_h:", Grid.total(a_row_h)-Grid.total(p_row_h))
      }

      write("\nPreferred size gives:", get_preferred_width(),",",get_preferred_height())
   end

   public set_fix_col1(s)
      self.fix_col1_flag := check_flag(s)
      return self
   end

   public get_preferred_width()
      return Grid.total(p_col_w)
   end

   public get_max_width()
      return Grid.total(p_col_max_w)
   end

   public get_preferred_height()
      return Grid.total(p_row_h)
   end

   public compute_actual_col_widths(w1)
      local left, i, a, n, done

      a_col_w := copy(p_col_w)

      # Extra width
      left := w1 - Grid.total(p_col_w)

      n := *a_col_w
      done := list(*a_col_w)
      while n > 0 do {
         a := integer(left / n)
         if a = 0 then
            break
         every i := 1 to *a_col_w do {
            if \done[i] then next
            if a_col_w[i] + a > p_col_max_w[i] then {
               left -:= p_col_max_w[i] - a_col_w[i]
               a_col_w[i] := p_col_max_w[i]
               done[i] := 1
               n -:= 1
            } else {
               a_col_w[i] +:= a
               left -:= a
            }
         }
      }
      dist_equally(1, *a_col_w, left, a_col_w)

      # Set cell width values
      every i := !info do
         i.aw := Grid.slice(i.x, i.w, a_col_w) - i.l_inset - i.r_inset
   end

   public compute_actual_col_positions(x1)
      local i, x, w

      col_x := []
      x := x1
      every w := !a_col_w do {
         put(col_x, x)
         x +:= w
      }

      every i := !info do
         i.ax := col_x[i.x] + i.l_inset
   end

   public compute_actual_row_heights(h1)
      local i, eh

      a_row_h := copy(p_row_h)

      # Extra height.
      eh := h1 - Grid.total(p_row_h)
      dist_equally(1, *a_row_h, eh, a_row_h)

      every i := !info do
         i.ah := Grid.slice(i.y, i.h, a_row_h) - i.t_inset - i.b_inset
   end

   public compute_actual_row_positions(y1)
      local i, y, h

      row_y := []
      y := y1
      every h := !a_row_h do {
         put(row_y, y)
         y +:= h
      }

      every i := !info do
         i.ay := row_y[i.y] + i.t_inset + i.ascent_adj
   end

   #
   # Set the default inner inset
   #
   public set_dii(n)
      self.dii := n
      return self
   end

   #
   # Set the default outer inset
   #
   public set_doi(n)
      self.doi := n
      return self
   end

   public new()
      self.dii := self.doi := 0
      self.id_str := string(&ucase)
      self.add_y := self.add_x := 1
      self.add_row_h := 0
      self.info := []
      return
   end
end

class TableLayout(Layout)
   public 
      g,
      dii,          # Default inner padding, ie not at edge of grid
      doi,          # Default outer padding
      fix_col1_flag,
      align_baselines_flag,
      debug

   public reset()
      g := &null
   end

   public ensure_grid()
      local c, ci

      if \g then
         return

      g := TableGrid()
      g.set_dii(dii)
      g.set_doi(doi)
      g.set_fix_col1(fix_col1_flag)

      every c := !parent.children do {
         if /c.x_spec then {
            ci := g.create_cell(c.constraints)
            ci.pw := c.get_preferred_width()
            ci.max_w := c.get_max_width()
            if \ci.fix_w then
               ci.pw := ci.max_w := max(ci.fix_w, ci.pw)
            ci.obj := c
         }
      }
      g.dimension()
      g.compute_preferred_col_widths()
   end

   public get_preferred_width()
      ensure_grid()
      return g.get_preferred_width()
   end

   public get_max_width()
      ensure_grid()
      return g.get_max_width()
   end

   public adjust_preferred_heights()
     local i, adj
     every i := !g.info do {
        if i.ph_calc_w ~=== i.aw then {
           i.ph_calc_w := i.aw
           i.ph := i.obj.get_preferred_height(i.ph_calc_w)
           i.ph <:= \i.fix_h
           i.ascent := i.obj.get_first_row_ascent(i.ph_calc_w)
           adj := 1
        }
     }
     if \adj | /i then {
        if \align_baselines_flag then
           align_baselines()
        g.compute_preferred_row_heights()
     }
   end

   private align_baselines()
     local i, j, ma, row, y
     row := []
     every i := !g.info do {
        if i.y === y then {
           put(row, i)
           ma <:= i.ascent
        } else {
           every j := !row do
              j.ascent_adj := ma - j.ascent
           row := [i]
           ma := i.ascent
           y := i.y
        }
     }
     every j := !row do
        j.ascent_adj := ma - j.ascent
   end

   public get_preferred_height(pw)
      ensure_grid()
      g.compute_actual_col_widths(pw)
      adjust_preferred_heights()
      return g.get_preferred_height()
   end

   public get_ascent(pw)
      local i
      if /align_baselines_flag then
         fail
      ensure_grid()
      g.compute_actual_col_widths(pw)
      adjust_preferred_heights()
      return if i := g.info[1] then i.ascent + i.ascent_adj + i.t_inset else 0
   end

   public set_fix_col1(s)
      self.fix_col1_flag := check_flag(s)
      return self
   end

   public set_align_baselines(s)
      self.align_baselines_flag := check_flag(s)
      return self
   end

   public display()
      local i, cw
      ensure_grid()
      cw := bev_lookup(self.parent.cbwin).shadow.clone().set_fill_style("masked").set_pattern("gray")

      cw.draw_rectangle(parent.x, parent.y, parent.w, parent.h)

      every i := !g.info do {
         cw.draw_rectangle(g.col_x[i.x],
                           g.row_y[i.y],
                           Grid.slice(i.x, i.w, g.a_col_w),
                           Grid.slice(i.y, i.h, g.a_row_h))
      }

      cw.uncouple()
   end

   public layout()
      local c, i

      every c := !parent.children do {
         if \c.x_spec then
            c.compute_absolutes()
      }

      ensure_grid()

      g.compute_actual_col_widths(parent.w)
      g.compute_actual_col_positions(parent.x)
      adjust_preferred_heights()
      g.compute_actual_row_heights(parent.h)
      g.compute_actual_row_positions(parent.y)

      every i := !g.info do {
         i.obj.x := i.ax
         i.obj.y := i.ay
         i.obj.w := i.aw
         i.obj.h := i.ah
      }

      if \debug then
         g.print_layout()
   end

   public set_debug(s)
      self.debug := check_flag(s)
      return self
   end

   public set_dii(n)
      self.dii := n
      return self
   end

   public set_doi(n)
      self.doi := n
      return self
   end

   public new()
      self.dii := 0
      self.doi := 0
      return
   end
end


