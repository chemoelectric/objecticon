#summary Native methods
<wiki:toc max_depth="3" />
= Native methods =
A native method is one in which there is no body, and the actual functionality of the method is defined elsewhere, typically in a function written in C.  For example :-

{{{
class X()
   public native f()
end
}}}

Parameters can be declared if desired, but they are ignored by the linker.

There are two possible ways to provide the functionality of a native method.

 * [NativeMethods#Native_methods_in_the_runtime_system Native methods in the runtime system] 
 * [NativeMethods#Native_methods_resolved_at_runtime Native methods resolved at runtime]

== Native methods in the runtime system ==
This necessitates editing and re-building the C/RTL source code of the runtime system and the translator.

The first step is to add a line to the file `base/h/nativedefs.h` defining the class, method and name of the implementing RTL function.  By convention, the name of the RTL function is the class followed by an underscore, followed by the method name, with dots in the class name being replaced by underscores.  So, for example, say we were implementing method `my_method` in class `MyClass` in package `my.package`, then we would write a runtime function named `my_package_MyClass_my_method` and add a line to `nativedefs.h`
{{{
NativeDef(my.package.MyClass,my_method,my_package_MyClass_my_method)
}}}

Next, the function must be implemented somewhere in the runtime, as an RTL function, which might look like this :-

{{{
function my_package_MyClass_my_method(x, y)
   ... RTL code
end
}}}

Note that for an instance method, the first parameter will be the instance on which the method was invoked.  In this case, add a `self` parameter to the parameter list :-

{{{
function my_package_MyClass_my_method(self, x, y)
   ... RTL code
end
}}}

Finally, both the translator and the runtime must be re-compiled.  The easiest way to do this is to go into the `base` directory and run

{{{
make clean all
}}}

If you have previously installed the distribution, you then need to go to the top-level directory and run

{{{
make install
}}}

again.

== Native methods resolved at runtime ==
This involves writing a dynamic library (a ".so" file) of RTL/C code.  The contents are loaded and the functions in the library are matched to the corresponding native methods by the `Class.load_library` method.  This is explained in more detail [DynamicLoadC here].

For working examples, see the source files `lib/main/mysql.icn` and `lib/main/cairo.icn` and their corresponding RTL source files in `lib/native`.
