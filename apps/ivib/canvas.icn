#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

import lang, gui, io, graphics, util, 
   ipl.pdco, ipl.numbers

class BorderOfCanvas(Component)
   public
      canvas,
      is_resizing,             # Flag indicating Canvas being resized
      orig_w, 
      orig_h, 
      drag_x_offset,           # Offsets used for smooth dragging
      drag_y_offset

   public set_canvas(c)
      self.canvas := c
      self.canvas.set_pos(Canvas.EDGE, Canvas.EDGE)
      self.add(self.canvas)
   end

   public get_pointer(e)
      if in_resize_corner(e) then
         return "bottom right corner"
   end

   public handle_lpress(e)
      if in_resize_corner(e) then {
         #
         # Save for possible push onto undo list.
         #
         canvas.tmp_dup := canvas.dup()

         #
         # Save current size.
         #
         orig_w := self.w
         orig_h := self.h

         #
         # The cursor is over the canvas's resize corner.
         #
         self.is_resizing := &yes

         #
         # Set offsets.
         #
         self.drag_x_offset := e.x - (self.x + self.w)
         self.drag_y_offset := e.y - (self.y + self.h)
      }
   end

   public handle_ldrag(e)
      local x1, y1, w_new, h_new
      if \self.is_resizing then {
         #
         # Compute adjust x, y cursor position.
         #
         x1 := e.x - self.drag_x_offset
         y1 := e.y - self.drag_y_offset

         #
         # Adjust within acceptable range.
         #
         x1 >:= self.parent_dialog.w - Canvas.EDGE
         x1 <:= self.x + canvas.min_width() + 2 * Canvas.EDGE
         y1 >:= self.parent_dialog.h - Canvas.EDGE
         y1 <:= self.y + canvas.min_height() + 2 *Canvas.EDGE

         w_new := x1 - self.x
         h_new := y1 - self.y

         #
         # Resize.
         #
         canvas.dialog_iw := w_new - 2 *Canvas.EDGE
         canvas.dialog_ih := h_new - 2*Canvas.EDGE
         canvas.synch_size()
      }
   end

   public handle_lrelease()
      if \self.is_resizing then {
         # 
         # Finished resizing whole canvas.
         #
         if orig_w ~= self.w | orig_h ~= self.h then {         
            self.parent_dialog.push_onto_undo(canvas.tmp_dup)            
            canvas.set_modified()
         }

         #
         # Clear flag.
         #
         is_resizing := &null
      }
   end

   #
   # Return whether the pointer is on the resize corner in the bottom right hand corner.
   #
   public in_resize_corner(e)
      return ((self.x + self.w - Canvas.EDGE <= e.x < self.x + self.w) & 
              (self.y + self.h - Canvas.RSW <= e.y < self.y + self.h)) | 
         ((self.x + self.w - Canvas.RSW <= e.x < self.x + self.w) & 
          (self.y + self.h - Canvas.EDGE <= e.y < self.y + self.h)) 
   end

   public display()
      local cw, i
      #
      # Draw the border.
      #
      use {
         cw := self.cbwin.clone().set_fg("black"),
         {
            cw.draw_rectangle(x, y, w, h, Canvas.EDGE)
            #
            # Draw the resizing corner in the bottom right hand corner.
            #
            cw.set_fg("red")
            every i := 0 to Canvas.EDGE - 1 do
               cw.draw_line(self.x + self.w - Canvas.EDGE - 1 - Canvas.RSW, self.y + self.h - Canvas.EDGE + i, 
                            self.x + self.w - Canvas.EDGE + i, self.y + self.h - Canvas.EDGE + i, 
                            self.x + self.w - Canvas.EDGE + i, self.y + self.h - Canvas.EDGE - 1 - Canvas.RSW)
         }
      }
      display_children()
   end

   public new()
      Component.new()
      connect(self.handle_lpress, Event.MOUSE_LEFT_PRESS)
      connect(self.handle_ldrag, Event.MOUSE_LEFT_DRAG)
      connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE)
      return
   end
end


#
# Canvas class.
#
class Canvas(Component,SelectiveObjectCodec)
   public 
      layout_filename,         # Layout file, or null if in source file
      superclass_name,         # Class name of superclass
      import_name,             # Name of import file
      selections,              # Items currently selected
      selected,                # Item currently selected and highlighted
      held_flag,               # Flag indicating whether left button held over item
      drag_x_offset,           # Offsets used for smooth dragging
      drag_y_offset, 
      resize_mode,             # Flag indicating how an item is being resized/moved
      button_groups,           # Set of ButtonGroup objects (see groups.iol)
      checkbox_groups,         # Set of CheckBoxGroup objects
      dialog_struct,           # A _Dialog object corresponding to the Canvas
      new_file_flag,           # Flag indicating if filename is a new file (ie provided
                               # via the command line, but didn't exist).
      filename,                # File name of Canvas
      modified,                # Flag indicating whether is modified
      moving,                  # Item being moved
      tmp_dup,                 # Temporary undo variable
      orig_x,                  # Original pos/size of an item being resized/moved
      orig_y, 
      orig_w, 
      orig_h, 
      orig_x_spec,             # Original pos/size spec of an item being resized/moved
      orig_y_spec, 
      orig_w_spec, 
      orig_h_spec, 
      x_new,                   # New pos/size spec of an item being resized/moved
      y_new,
      h_new,
      w_new,
      arrow_flag,              # Flag for co-ordinating undo on keypad movement
      initial_focus,           # Component which will have intitial focus in dialog
      name,                    # Class name of Canvas
      is_component,            # Is it a Component (rather than a Dialog)?
      gen_main,                # Flags regarding code generation options.
      gen_component_setup,
      gen_constructor,
      gen_init_dialog,
      gen_indent,
      event_handlers,          # List of event, handler pairs
      scale_dimensions_flag,   # Apply scale() to dimensions on output
      edit_scale,              # The scale the canvas was edited at
      dialog_iw,               # Initial size to set dialog; may be null if
      dialog_ih,               # default is to be used.
      dialog_w,                # Actual size of dialog
      dialog_h,                #
      parent_Canvas

   public static const
      DEFAULT_WIDTH,
      DEFAULT_HEIGHT,
      SURROUND,
      RSW,
      EDGE

   private static init()
      DEFAULT_WIDTH := scale(500)
      DEFAULT_HEIGHT := scale(350)
      SURROUND := scale(30)
      # Length of resize line at bottom right corner
      RSW := scale(12)
      # Width of the border around the Canvas.
      EDGE := scale(4)
   end

   public push_undo()
      self.parent_dialog.push_undo()
   end

   #
   # Set the class name, ie the name of the Dialog class in the generated  code
   #
   public set_name(x)
      self.name := x
      return self
   end

   #
   # Return the name
   #
   public get_name()
      return self.name
   end

   public get_parent_dialog()
      return dialog_struct
   end

   public synch_size()
      self.dialog_w := \self.dialog_iw | layout_delegate.get_preferred_width()
      self.dialog_h := \self.dialog_ih | layout_delegate.get_preferred_height(self.dialog_w)
      set_size(self.dialog_w, self.dialog_h)
      parent.set_size(self.dialog_w + 2 * EDGE, self.dialog_h + 2 * EDGE)
      if self.parent.is_live() then {
         self.parent.resize()
         self.parent.parent.invalidate()
      }
   end

   #
   # Return the list of event handlers
   #
   public get_event_handlers()
      return event_handlers
   end

   public imagex(s)
      return if /s then "&null" else s
   end

   #
   # Update the position label.
   #
   public update_pos_label()
      if \self.selected then
         self.parent_dialog.pos_label.set_label(imagex(self.selected.x_spec) || "," || 
                                                imagex(self.selected.y_spec) || " : " || 
                                                imagex(self.selected.w_spec) || "," || 
                                                imagex(self.selected.h_spec) || " (" || 
                                                self.selected.x_align || "," ||
                                                self.selected.y_align || ")")
      else
         self.parent_dialog.pos_label.set_label("")
   end

   #
   #
   # Determine whether all selections are in the same container.
   #
   public same_container()
      local c, e
      c := selected.parent
      every e := !self.selections do
         if e.parent ~=== c then
            return alert_error(parent_dialog, "Selections must be in same container")
      return
   end

   #
   # Check whether something is selected.
   #
   public something_selected()
      if *self.selections = 0 then {
         self.parent_dialog.info_label.set_label("Nothing selected")
         fail
      }
      return
   end

   public no_layouts()
      if \(!self.selections).parent.layout_delegate then {
         self.parent_dialog.info_label.set_label("Not allowed with a layout manager")
         fail
      }
      return
   end

   #
   # Clear the current selections.
   #
   public clear_selections()
      self.parent_dialog.pos_label.set_label("")
      self.selections := []
      self.selected := &null
      self.parent_dialog.update_grey()
      synch_tree()
      invalidate()
   end

   public set_selections(l)
      selections := l
      selected := l[1] | &null
      synch_tree()
      invalidate()
      return self
   end

   #
   # Save the component
   #
   public component_save_selection()
      something_selected() | fail
      component_save(self.selected)
   end

   public do_reset_all_layouts()
      self.reset_all_layouts()
      self.synch_size()
      self.update_pos_label()
   end

   public component_paste_response(target_type, s, cc)
      local c

      if /s then
         return alert_error(parent_dialog, "Nothing in clipboard")

      c := lang.decode(s) | return alert_error(parent_dialog, "Invalid file format")

      push_undo()

      c.change_canvas(self)
      if /cc.layout_delegate then
         c.set_pos(10, 10)
      else
         c.layout_safe()
      cc.add(c)
      c.unique_name()
      self.set_modified()
      self.do_reset_all_layouts()
   end

   #
   # Paste the clipboard contents into cc
   #
   public component_paste(cc)
      parent_dialog.request_selection(Selection.CLIPBOARD, 
                                      [Ivib.IVIB_COMPONENT_TARGET], 
                                      component_paste_response, 
                                      cc)
   end

   #
   # Save the component
   #
   public component_save(cc)
      local fd, s, c

      fd := FileDialog().
         set_directory(Ivib.last_layout_dir).
         set_existing_file_mode(FileDialog.WARN).
         show_modal(parent_dialog)
      s := fd.get_result() | fail
      Ivib.last_layout_dir := fd.get_directory()

      c := cc.dup()
      c.change_canvas(&null)

      encode_to_file(s, c) | return alert_error(parent_dialog, ["Couldn't encode:", &why])
   end

   #
   # Load a component into cc
   #
   public component_load(cc)
      local fd, s, c
      fd := FileDialog().
         set_directory(Ivib.last_layout_dir).
         set_existing_file_mode(FileDialog.REQUIRE).
         show_modal(parent_dialog)
      s := fd.get_result() | fail
      Ivib.last_layout_dir := fd.get_directory()

      c := decode_from_file(s) |
         return alert_error(parent_dialog, ["Couldn't decode:", &why])

      push_undo()

      c.change_canvas(self)
      if /cc.layout_delegate then
         c.set_pos(10, 10)
      else
         c.layout_safe()
      cc.add(c)
      c.unique_name()
      self.set_modified()
      self.do_reset_all_layouts()
   end

   #
   # Centre all the current selections horizontally.
   #
   public centre_horiz_selections()
      local e
      (something_selected() & no_layouts()) | fail

      push_undo()

      every e := !self.selections do {
         e.x_spec := "50%"
         e.x_align := "c"
         e.x_fixed := &yes
         e.resize()
      }

      self.set_modified()
      self.do_reset_all_layouts()
   end

   #
   # Centre all the current selections vertically.
   #
   public centre_vert_selections()
      local e
      (something_selected() & no_layouts()) | fail

      push_undo()

      every e := !self.selections do {
         e.y_spec := "50%"
         e.y_align := "c"
         e.y_fixed := &yes
         e.resize()
      }

      self.set_modified()
      self.do_reset_all_layouts()
   end

   #
   # Align the selections horizontally with the highlighted item.
   #
   public align_horiz_selections()
      local e
      (something_selected() & same_container() & no_layouts()) | fail

      push_undo()

      every e := !self.selections do {
         e.x_spec := selected.x_spec
         e.x_align := selected.x_align
         e.x_fixed := selected.x_fixed
         e.resize()
      }

      self.set_modified()
      self.do_reset_all_layouts()
   end

   #
   # Align the selections vertically with the highlighted item.
   #
   public align_vert_selections()
      local e
      (something_selected() & same_container() & no_layouts()) | fail

      push_undo()

      every e := !self.selections do {
         e.y_spec := selected.y_spec
         e.y_align := selected.y_align
         e.y_fixed := selected.y_fixed
         e.resize()
      }

      self.set_modified()
      self.do_reset_all_layouts()
   end

   #
   # Equalize the selections' widths
   #
   public equalize_width_selections()
      local e
      (something_selected() & same_container() & no_layouts()) | fail

      push_undo()

      every e := (selected ~=== !self.selections) do {
         e.w_spec := selected.w_spec
         e.w_fixed := selected.w_fixed
         e.resize()
      }

      self.set_modified()
      self.do_reset_all_layouts()
   end

   #
   # Equalize the selections' heights
   #
   public equalize_height_selections()
      local e
      (something_selected() & same_container() & no_layouts()) | fail

      push_undo()

      every e := (selected ~=== !self.selections) do {
         e.h_spec := selected.h_spec
         e.h_fixed := selected.h_fixed
         e.resize()
      }

      self.set_modified()
      self.do_reset_all_layouts()
   end

   #
   # Lay out selections end-to-end
   #
   public end_to_end_selections_horizontally()
      local e, x1
      (something_selected() & same_container() & no_layouts()) | fail

      push_undo()

      x1 := selected.x - selected.parent.x + selected.w

      every e := self.selections[2 to *self.selections] do {
         e.x_spec := x1
         e.x_align := "l"
         e.resize()
         x1 +:= e.w
      }

      self.set_modified()
      self.do_reset_all_layouts()
   end

   #
   # Lay out selections end-to-end
   #
   public end_to_end_selections_vertically()
      local e, y1

      (something_selected() & same_container() & no_layouts()) | fail

      push_undo()

      y1 := selected.y - selected.parent.y + selected.h

      every e := self.selections[2 to *self.selections] do {
         e.y_spec := y1
         e.y_align := "t"
         e.resize()
         y1 +:= e.h
      }
      self.set_modified()
      self.do_reset_all_layouts()
   end

   #
   # Copy attributes from first selected to others
   #
   public copy_attribs()
      local e
      something_selected() | fail

      push_undo()

      every e := !self.selections do {
         e.wattribs := copy(selected.wattribs)
         e.reset()
      }

      self.set_modified()
      self.do_reset_all_layouts()
   end

   public duplicate_component(cc)
      local c
      static copy_count
      initial copy_count := 0

      push_undo()
      c := cc.dup_to(self)
      if /cc.parent.layout_delegate then {
         #
         # Not in layout - set pos of new object. 
         #           
         c.x_spec :=  c.get_x_alignment_offset() + 10 + 7 * (copy_count % 4) + cc.x - cc.parent.x
         c.y_spec :=  c.get_y_alignment_offset() + 10 + 7 * (copy_count % 4) + cc.y - cc.parent.y
      }
      cc.parent.add(c)
      c.rename()
      self.set_modified()
      copy_count +:= 1
      self.do_reset_all_layouts()
   end

   #
   # Place the selected items in a grid (see also grid.iol).
   #
   public gridify(obj)
      local rows, cols, e, r, c, i, tab, last, layout

      push_undo()

      #
      # Construct two GridSets.  Each item will go into each set.
      #
      rows := GridSet("h")
      cols := GridSet("v")

      every e := !obj.children do {
         #
         # Put it into both GridSets.
         #
         rows.enter(e)
         cols.enter(e)
      }
      #rows.print("rows")
      #cols.print("cols")

      layout := CanvasGridLayout()
      layout.change_canvas(self)
      layout.rename()

      # Guess whether it should be flush or not.
      if is(obj,  CanvasPanel | 
                  CanvasOverlayItem |
                  CanvasSplitContent) then 
      {
         layout.doi_val := 0
         layout.set_doi(0)
      }

      obj.set_layout(layout)
      if obj === self then
         obj.dialog_iw := obj.dialog_ih := &null
      else
         obj.w_spec := obj.h_spec := &null

      # Clear the children, they will be re-added in a new order.
      obj.remove_all()

      every r := !rows.lines do {
         tab := 0
         (\last).set_constraint("eol", 1)
         every c := !cols.lines do {
            i := r.elements ** c.elements
            if *i = 0 then
               tab +:= 1
            else {
               every e := !i do {
                  if tab > 0 then {
                     e.set_constraint("x_tab", tab)
                     tab := 0
                  } else
                     e.remove_constraint("x_tab")
                  e.remove_constraint("eol")
                  e.layout_safe()
                  last := e
                  obj.add(e)
               }
            }
         }
      }

      self.set_modified()
      self.do_reset_all_layouts()
   end

   public op_set_constraint(obj, name, val)
      push_undo()
      obj.set_constraint(name, val)
      self.set_modified()
      self.do_reset_all_layouts()
   end

   public op_remove_constraint(obj, name)
      push_undo()
      obj.remove_constraint(name)
      self.set_modified()
      self.do_reset_all_layouts()
   end

   #
   # Reorder the items in the selection order.
   #
   public reorder_selections()
      local t, u, e
      (something_selected() & same_container()) | fail

      push_undo()

      t := []
      while put(t, pop(selected.parent.children))
      u := copy(selections)
      every e := !t do {
         if keyof(selections, e) then
            put(selected.parent.children, pop(u))
         else
            put(selected.parent.children, e)
      }
      self.set_modified()
      self.do_reset_all_layouts()
   end

   #
   # Move the selected item up one in the container order.
   #
   public move_selection_up_order()
      local i, p
      something_selected() | fail
      push_undo()
      p := selected.parent
      i := p.get_index(selected)
      p.remove(selected)
      if i = 1 then
         p.add(selected)
      else
         p.add(selected, i - 1)
      self.set_modified()
      self.do_reset_all_layouts()
   end

   #
   # Move the selected item down one in the container order.
   #
   public move_selection_down_order()
      local i, p
      something_selected() | fail
      push_undo()
      p := selected.parent
      i := p.get_index(selected)
      p.remove(selected)
      if i = *p.children + 1 then
         p.add(selected, 1)
      else
         p.add(selected, i + 1)
      self.set_modified()
      self.do_reset_all_layouts()
   end

   #
   # Set the tab_ord field of the selections so that they are tab
   # ordered in the same order they were selected.
   #
   public set_tab_order_from_selections()
      local i
      (something_selected() & same_container()) | fail
      push_undo()
      every i := 1 to *selections do {
         selections[i].set_tab_ord(i)
         selected.parent.compute_tab_order()
      }
      self.set_modified()
   end

   #
   # Set the z field of the selections so that they are z
   # ordered in the same order they were selected.
   #
   public set_z_order_from_selections()
      local i
      (something_selected() & same_container()) | fail
      push_undo()
      every i := 1 to *selections do {
         selections[i].set_z(i)
         selected.parent.compute_z_order()
      }
      self.set_modified()
      invalidate()
   end

   public ensure_all_names_unique()
      local o, seen, cn, i
      seen := set()
      every o := Seq{gen_cos().traverse_tree()} do {
         cn := o.get_name()
         if member(seen, cn) then {
            while any(&digits ++ "_", cn[-1]) do
               cn[-1] := ""
            cn ||:= "_"
            i := 1
            while member(seen, cn || i) do
               i +:= 1
            cn ||:= i
            #write("renamed ", o.get_name(), "->", cn)
            o.set_name(cn)
         }
         insert(seen, cn)
      }
   end

   #
   # Get a unique name based on the given root.
   #
   public get_new_name(cn)
      local i, s

      while any(&digits ++ "_", cn[-1]) do
         cn[-1] := ""
      cn ||:= "_"

      i := 0
      every s := Seq{gen_cos().traverse_tree()}.get_name() do {
         s ? {
            if =cn then
               i <:= integer(tab(0))
         }
      }
      return cn || (i + 1)
   end      

   public find_name(name)
      local o
      every o := Seq{gen_cos().traverse_tree()} do {
         if o.get_name() == name then
            suspend o
      }
   end

   #
   # Generate code output (see also code.iol).
   #
   public gen_code()
      local c, i, m, a

      #
      # Create a Code object to contain the generated code.
      #
      c := Code()
      c.set_parent_Canvas(self)

      #
      # Dialog attribs.
      #
      m := copy(dialog_struct.wattribs)
      every default.delete(m, WAttrib.HEIGHT | WAttrib.WIDTH | WAttrib.SIZE)
      if /is_component & 
         \ (dialog_iw | dialog_ih) then 
      {
         if /dialog_iw then
            insert(m, WAttrib.HEIGHT, dialog_ih)
         else if /dialog_ih then
            insert(m, WAttrib.WIDTH, dialog_iw)
         else
            insert(m, WAttrib.SIZE, [dialog_iw, dialog_ih])
      }
      every a := !sort(m) do
         c.line("self.set_" || a[1] || "(" || c.scale_and_stringify_wattrib(a[1], a[2]) || ")")

      #
      # Generate code for all the items.
      #
      every i := !self.children do {
         i.gen_code(c)
         c.line("self.add(" || i.name || ")")
      }

      c.add_self_event_handlers(\self.event_handlers)

      if \self.layout_delegate then {
         self.layout_delegate.gen_code(c)
         c.line("self.set_layout(" || self.layout_delegate.name || ")")
      }

      c.line("self.set_focus(" || (\self.parent_Canvas.initial_focus).name || ".find_focus())")

      every (!self.button_groups).gen_code(c)
      every (!self.checkbox_groups).gen_code(c)

      c.add_import(self.import_name, self.superclass_name)

      return c
   end

   public rescale()
      local c, k, f
      f := Gui.SCALE / edit_scale

      every c := Seq{ gen_cos().traverse_tree_postorder() }  do
         c.rescale(f)

      every k := WAttrib.HEIGHT | WAttrib.WIDTH | WAttrib.MIN_WIDTH | WAttrib.MIN_HEIGHT | WAttrib.MAX_WIDTH | WAttrib.MAX_HEIGHT do {
         if c := dialog_struct.get_wattrib(k) then
            dialog_struct.set_wattrib(k, round(c * f))
      }
      every k := WAttrib.SIZE | WAttrib.MAX_SIZE | WAttrib.MIN_SIZE do {
         if c := dialog_struct.get_wattrib(k) then
            dialog_struct.set_wattrib(k, [round(c[1] * f), round(c[2] * f)])
      }
      dialog_iw := round(\dialog_iw * f)
      dialog_ih := round(\dialog_ih * f)
      synch_size()
      set_modified()
      reset()
      do_reset_all_layouts()
      edit_scale := Gui.SCALE
      parent_dialog.update_grey()
   end

   #
   # Minimum width of canvas.
   #
   public min_width()
      return 20
   end

   #
   # Minimum height of canvas.
   #
   public min_height()
      return 20
   end

   #
   # Called if the canvas has been modified. 
   #
   public set_modified()
      if /self.modified then {
         self.modified := &yes
         self.parent_dialog.update_grey()
         self.parent_dialog.set_filename_label()
      }
      synch_tree()
   end

   #
   # The canvas is no longer modified, ie it has been saved.
   #
   public clear_modified()
      if \self.modified then {
         self.modified := &null
         self.parent_dialog.update_grey()
         self.parent_dialog.set_filename_label()
      }
   end

   #
   # Set the filename.
   #
   public set_filename(s)
      self.filename := s
      self.parent_dialog.set_filename_label()
      return self
   end
   
   public get_template()
      suspend ["SuperClass Name", "superclass_name"] |
              ["Import Name", "import_name"] |
              ["Button Groups", "button_groups"] |
              ["Checkbox Groups", "checkbox_groups"] |
              ["Gen Indent", "gen_indent"] |
              ["Gen Main", "gen_main"] |
              ["Gen Component Setup", "gen_component_setup"] |
              ["Gen Init Dialog", "gen_init_dialog"] |
              ["Gen Constructor", "gen_constructor"] |
              ["Dialog Struct", "dialog_struct"] |
              ["Name", "name"] |
              ["Is Component", "is_component"] |
              ["Width", "dialog_iw"] |
              ["Height", "dialog_ih"] |
              ["Children", "children"] |
              ["Initial Focus", "initial_focus"] |
              ["Event Handlers", "event_handlers"] |
              ["Layout delegate", "layout_delegate"] |
              ["Scale Dimensions Flag", "scale_dimensions_flag"] |
              ["Edit Scale", "edit_scale"]
   end

   #
   # Return a copy of the Canvas.
   #
   public dup()
      local c, t, e1, e2, o
      c := Canvas()
      c.gen_indent := self.gen_indent
      c.gen_main := self.gen_main
      c.gen_component_setup := self.gen_component_setup
      c.gen_init_dialog := self.gen_init_dialog
      c.gen_constructor := self.gen_constructor
      c.filename := self.filename
      c.layout_filename := self.layout_filename
      c.new_file_flag := self.new_file_flag
      c.modified := self.modified
      c.dialog_struct := CDialog()
      c.dialog_struct.wattribs := copy(self.dialog_struct.wattribs)
      c.name := self.name
      c.is_component := self.is_component
      c.superclass_name := self.superclass_name
      c.import_name := self.import_name
      c.scale_dimensions_flag := self.scale_dimensions_flag
      c.edit_scale := self.edit_scale
      c.event_handlers := copy(\self.event_handlers)
      c.set_pos(self.x_spec, self.y_spec)
      c.dialog_iw := self.dialog_iw
      c.dialog_ih := self.dialog_ih
      if \self.layout_delegate then
         c.set_layout(self.layout_delegate.dup_to(c))

      c.button_groups := []
      every put(c.button_groups, (!self.button_groups).dup_to(c))

      c.checkbox_groups := []
      every put(c.checkbox_groups, (!self.checkbox_groups).dup_to(c))

      # 
      # Copy the items.
      #
      c.children := []
      every c.add((!self.children).dup_to(c))

      c.parent_dialog := self.parent_dialog

      # Create a table mapping current objects to duplicated ones.
      t := table()
      e1 := []
      every put(e1, Seq{gen_cos().traverse_tree()})
      e2 := []
      every put(e2, Seq{c.gen_cos().traverse_tree()})
      while insert(t, pop(e1), pop(e2))
      *e1 = *e2 = 0 | stop("internal duplication error.")

      # Fixup selections and initial focus.
      c.selected := t[\self.selected]
      c.selections := []
      every put(c.selections, t[!self.selections])
      c.initial_focus := t[\self.initial_focus]

      # Checkbox groups and button groups.
      every o := !self.checkbox_groups do
         t[o].which_one := t[o.which_one]
      every o := key(t) do {
         if is(o, gui.Toggle) then
            t[o].parent_check_box_group := t[o.parent_check_box_group]
         if is(o, gui.Button) then
            t[o].parent_button_group := t[o.parent_button_group]
      }

      return c
   end

   public gen_cos()
      suspend \self.layout_delegate | !button_groups | !checkbox_groups | !self.children
   end

   # 
   # Open the preferences dialog.
   #
   public dialog()
      return CanvasPreferencesDialog(self)
   end

   public initially()
      local k
      # Copy the attribs from the dialog struct (the wattrib ancestor is set to
      # Gui.EMPTY_WATTRIB_ANCESTOR in the constructor below).
      clear_wattribs()
      every k := key(dialog_struct.wattribs) do
         if Gui.is_context_attrib(k) then
            set_wattrib(k, dialog_struct.wattribs[k])
      Component.initially()
   end

   public show_moving()
      local cw
      use {
         cw := cbwin.clone(),
         {
            cw.set_fg("red").
               draw_rectangle(moving.mx, moving.my, moving.mw, moving.mh, Gui.FINE_WIDTH)
         }
      }
   end

   #
   # Display the canvas.
   #
   public display()
      #
      # Draw and highlight the items.
      #
      display_children()

      every (!selections).do_highlight(cbwin)

      if \moving then
         show_moving()

      (\layout_delegate).display()
   end

   #
   # Prevent children in the canvas from getting in the point chain.
   #
   public build_point_chain(l)
   end

   public keeps(e)
      # This component keeps all events.
      return
   end

   public handle_key(e)
      local ec

      ec := e.code
      if \self.held_flag then {
         if ec === "\e" then {
            moving := held_flag := resize_mode := &null
            parent_dialog.change_pointer()
            self.invalidate()
         }
      } else {
         case ec of {
            "\r":
               parent_dialog.op_dialog()

            Key.UP | Key.DOWN | Key.LEFT | Key.RIGHT : 
               handle_move_key(e)
         }
      }
   end

   private handle_move_key(e)
      local ec

      something_selected() | fail
      ec := e.code
      moving := selected
      #
      # Save original pos and size.
      #
      moving.mx := orig_x := moving.x
      moving.my := orig_y := moving.y
      moving.mw := orig_w := moving.w
      moving.mh := orig_h := moving.h
      x_new := orig_x_spec := moving.x_spec
      y_new := orig_y_spec := moving.y_spec
      w_new := orig_w_spec := moving.w_spec
      h_new := orig_h_spec := moving.h_spec

      if \e.shift then {
         case ec of {
            Key.UP : resize_down(orig_y + orig_h - 1)
            Key.DOWN : resize_down(orig_y + orig_h + 1)
            Key.LEFT : resize_right(orig_x + orig_w - 1)
            Key.RIGHT : resize_right(orig_x + orig_w + 1)
         }
      } else {
         case ec of {
            Key.UP : move_vertically(orig_y - 1)
            Key.DOWN : move_vertically(orig_y + 1)
            Key.LEFT : move_horizontally(orig_x - 1)
            Key.RIGHT : move_horizontally(orig_x + 1)
         }
      }

      if orig_x_spec ~=== x_new | orig_y_spec ~=== y_new | orig_w_spec ~=== w_new | 
            orig_h_spec ~=== h_new then {
         if /self.arrow_flag then {
            push_undo()
            self.arrow_flag := &yes
         }
         self.relocate()
      }

      moving := &null
   end

   public move_vertically(y1)
      if /moving.y_fixed then {
         y_new := moving.get_y_alignment_offset() + y1 - moving.parent.y
         moving.my := y1
      }
   end

   public move_horizontally(x1)
      if /moving.x_fixed then {
         x_new := moving.get_x_alignment_offset() + x1 - moving.parent.x
         moving.mx := x1
      }
   end

   public resize_up(y1)
      if /moving.h_fixed then {
         if moving.y_align == "c" then {
            y1 >:= orig_y + (orig_h - moving.min_height()) / 2
            moving.mh := h_new := orig_h + 2 * (orig_y - y1)
         } else if /moving.y_fixed  | moving.y_align ~== "t" then {
            y1 >:= orig_y + orig_h - moving.min_height()
            moving.mh := h_new := orig_h + (orig_y - y1)
            if moving.y_align == "t" then 
               y_new := y1 - moving.parent.y
         }
         moving.my := y1
      }
   end

   public resize_down(y1)
      if /moving.h_fixed then {
         if moving.y_align == "c" then {
            y1 <:= orig_y + orig_h - (orig_h - moving.min_height()) / 2
            moving.mh := h_new := orig_h + 2 * (y1 - (orig_y + orig_h))
         }  else if /moving.y_fixed | moving.y_align ~== "b" then {
            y1 <:= orig_y + moving.min_height()
            moving.mh := h_new := orig_h + (y1 - (orig_y + orig_h))
            if moving.y_align == "b" then
               y_new := y1 - moving.parent.y
         }
         moving.my := y1 - moving.mh
      }
   end

   public resize_right(x1)
      if /moving.w_fixed then {
         if moving.x_align == "c" then {
            x1 <:= orig_x + orig_w - (orig_w - moving.min_width()) / 2
            moving.mw := w_new := orig_w + 2 * (x1 - (orig_x + orig_w))
         } else if /moving.x_fixed | moving.x_align ~== "r" then {
            x1 <:= orig_x + moving.min_width()
            moving.mw := w_new := orig_w + (x1 - (orig_x + orig_w))
            if moving.x_align == "r" then
               x_new := x1 - moving.parent.x
         }
         moving.mx := x1 - moving.mw
      }
   end

   public resize_left(x1)
      if /moving.w_fixed then {
         if moving.x_align == "c" then {
            #
            # x won't change; work out new width. 
            #
            x1 >:= orig_x + (orig_w - moving.min_width()) / 2
            moving.mw := w_new := orig_w + 2 * (orig_x - x1)
         } else if /moving.x_fixed | moving.x_align ~== "l" then {
            #
            # Work out new width, and if appropriate x.
            #
            x1 >:= orig_x + orig_w - moving.min_width()
            moving.mw := w_new := orig_w + (orig_x - x1)
            if moving.x_align == "l"  then
               x_new := x1 - moving.parent.x
         }
         moving.mx := x1
      }
   end

   #
   # Move components to a new parent.
   #
   public move_components(l, new_parent)
      local cc
      push_undo()
      every cc := !l do {
         # Can't move onto a child or current parent.
         if new_parent === (cc.parent | Seq{cc.traverse_tree()}) then
            next
         if /new_parent.layout_delegate then
            cc.set_pos(10, 10)
         else
            cc.layout_safe()
         cc.parent.remove(cc)
         new_parent.add(cc)            
      }
      self.do_reset_all_layouts()
      self.set_modified()
   end

   #
   # Invoked after an interactive move (drag or cursor keys) on a component.
   #
   public relocate()
      local obj

      #
      # Set new size/pos specs; these may be changed below by the existing/new
      # container.
      #
      moving.set_pos(x_new, y_new)         
      moving.set_size(w_new, h_new)

      #
      # Compute which object the moving item is in (may be canvas itself
      # if not in anything else).
      #
      obj := self.is_inside(moving)

      #
      # If already in obj then inform the containing object
      #
      if moving.parent === obj then
         moving.parent.still_inside(moving)
      else {
         #
         # Not in old container.  Post a message.
         #
         self.parent_dialog.info_label.set_label(
            if obj === self then "Placed back in canvas" 
            else "Placed inside container")

         #
         # Take it out of the one it's currently in ...
         #
         moving.parent.remove(moving)

         #
         # ... and put it in the new one.
         #
         obj.place_inside(moving)            
      } 

      #
      # Redisplay canvas & label
      #
      self.do_reset_all_layouts()
      self.set_modified()
   end

   public get_pointer(e)
      local i
      if \self.moving then {
         i := self.resize_mode
         if /i then
            return "fleur"
      } else
         i := self.which_cursor_over(e).in_resize_region(e)
      return case i of {
         1 : "top left corner"
         2 : "top right corner"
         3 : "bottom left corner" 
         4 : "bottom right corner"
      }
   end

   public handle_move()
      self.arrow_flag := &null
   end

   #
   # Handle left button press.
   #
   public handle_lpress(e)
      #
      # If the cursor is over an object...
      #
      if moving := self.which_cursor_over(e) then {
         #
         # Select this object.
         #
         self.select(moving, e.ctrl)

         #
         # Save for possible push onto undo list.
         #
         self.tmp_dup := self.dup()

         #
         # Reset flags.
         #
         self.held_flag := &yes

         #
         # Determine which corner the cursor is over; resize_mode null implies
         # moving not resizing.
         #
         self.resize_mode := moving.in_resize_region(e)

         #
         # Display into buffer
         #
         self.invalidate()

         #
         # Set up the offsets depending on what we're doing; also change
         # the pointer to an appropriate image.
         #
         case self.resize_mode of {
            #
            # Resizing from top left corner
            #
            1 : {
               self.drag_x_offset := e.x - moving.x
               self.drag_y_offset := e.y - moving.y
            }
            #
            # Resizing from top right corner
            #
            2 : {
               self.drag_x_offset := e.x - (moving.x + moving.w)
               self.drag_y_offset := e.y - moving.y
            }
            #
            # Resizing from bottom left corner
            #
            3 : {
               self.drag_x_offset := e.x - moving.x
               self.drag_y_offset := e.y - (moving.y + moving.h)
            }
            #
            # Resizing from bottom right corner
            #
            4 : {
               self.drag_x_offset := e.x - (moving.x + moving.w)
               self.drag_y_offset := e.y - (moving.y + moving.h)
            }                              
            #
            # Moving, not resizing.
            #
            &null : {
               self.drag_x_offset := e.x - moving.x
               self.drag_y_offset := e.y - moving.y
            }
         }
         
         #
         # Save original pos and size.
         #
         moving.mx := orig_x := moving.x
         moving.my := orig_y := moving.y
         moving.mw := orig_w := moving.w
         moving.mh := orig_h := moving.h
         x_new := orig_x_spec := moving.x_spec
         y_new := orig_y_spec := moving.y_spec
         w_new := orig_w_spec := moving.w_spec
         h_new := orig_h_spec := moving.h_spec
      } else if self.in_region(e) then {
         #
         # Not over anything but in canvas.  De-select all.
         #
         self.clear_selections()
      }
      self.arrow_flag := &null
   end

   #
   # Mouse left drag.
   #
   public handle_ldrag(e)
      local x1, y1
      if \self.held_flag then {
         #
         # Moving or resizing an object.
         #

         #
         # Adjust cursor position using offsets.
         #
         x1 := e.x - self.drag_x_offset
         y1 := e.y - self.drag_y_offset

         #
         # Calculate new x position and width
         #  
         case self.resize_mode of {
            #
            # Resizing x from left hand side of object.
            #
            1 | 3 : resize_left(x1)

            #
            # Resizing x from right hand side of object.
            #
            2 | 4 : resize_right(x1)

            #
            # Moving
            #
            default : move_horizontally(x1)
         }   

         #
         # Calculate new y position and height
         #  
         case self.resize_mode of {
            #
            # Resizing y from top of object.
            #
            1 | 2 : resize_up(y1)
            
            #
            # Resizing y from bottom
            #
            3 | 4 : resize_down(y1)
            
            #
            # Moving
            #
            default : move_vertically(y1)
         }

         self.invalidate()
      } 
      self.arrow_flag := &null
   end

   # 
   # Left button released.
   #
   public handle_lrelease()
      if \self.held_flag then {
         if orig_x_spec ~=== x_new | orig_y_spec ~=== y_new | 
            orig_w_spec ~=== w_new | orig_h_spec ~=== h_new then 
         {
            self.parent_dialog.push_onto_undo(self.tmp_dup)            
            relocate()
         }

         #
         # Clear flags.
         #
         moving := held_flag := resize_mode := &null
         self.invalidate()
      }
   end

   #
   # Handle right button press.  Same as left button press, but without
   # the resizing or moving functionality.
   #
   public handle_rpress(e)
      local i, pm

      /self.held_flag | fail
      if i := self.which_cursor_over(e) then {
         self.select(i, e.ctrl)
         if not(\e.ctrl) then {
            pm := PopupMenu()
            pm.popup(self.parent_dialog, i.create_menu(), e.x, e.y)
         }
      } else if self.in_region(e) then {
         self.clear_selections()
         if not(\e.ctrl) then {
            pm := PopupMenu()
            pm.popup(self.parent_dialog, self.create_menu(), e.x, e.y)
         }
      }
      self.arrow_flag := &null
   end

   #
   # Fix the selected objects
   #
   public fix_selections()
      local e
      push_undo()
      every e := !self.selections do
         e.y_fixed := e.x_fixed := e.h_fixed := e.w_fixed := &yes
      self.set_modified()
   end

   #
   # Unfix the selected objects. 
   #
   public unfix_selections()
      local e
      push_undo()
      every e := !self.selections do
         e.y_fixed := e.x_fixed := e.h_fixed := e.w_fixed := &null
      self.set_modified()
   end

   #
   # Which object is the item c in?
   #
   public is_inside(c)
      local e, o
      every e := back(self.z_children) do
         if o := e.is_inside(c) then
            return o
      #
      # Not in any other item, therefore in Canvas itself.
      #
      return self
   end

   #
   # Place c back into the Canvas
   #
   public place_inside(c)
      self.add(c)

      if \self.layout_delegate then {
         #
         # Make c suitable for use within a layout.
         #
         c.layout_safe()
      } else {
         #
         # Set c's x and y position specs
         #
         c.x_spec := c.get_x_alignment_offset() + c.mx - self.x
         c.y_spec := c.get_y_alignment_offset() + c.my - self.y
      }

      #
      # Reset c.
      #
      #c.reset()
   end

   #
   # Called after a move or resize.
   #
   public still_inside(c)
      if \self.layout_delegate then {
         #
         # Keep x and y to null - the layout will set them.
         #
         c.x_spec := c.y_spec := &null
      }
   end

   #
   # Select c
   #
   public select(c, add)
      if \add then {
         if not(keyof(selections, c)) then
            put(selections, c)
         /selected := c
      } else {
         selected := c
         selections := [c]
      }

      self.parent_dialog.update_grey()
      self.update_pos_label()
      synch_tree()
      invalidate()
      return
   end

   public synch_tree()
      (\parent_dialog).synch_tree()
   end

   #
   # Which item, if any, is the cursor over?
   #
   public which_cursor_over(e)
      local i, o

      if self.in_region(e) then {
         #
         # Search in reverse order so that the item displayed on top
         # will be found first.
         #
         every i := back(self.z_children) do
            if o := i.which_cursor_over(e) then
               return o
      }
   end

   #
   # Operation to create a CheckBoxGroup from the current selections.
   #
   public selections_to_cbg()
      local e, n
      something_selected() | fail

      #
      # Check all selections are CheckBoxes.
      #
      every e := !selections do {
         if not is(e, CanvasButton) then
            return alert_error(parent_dialog, "You can only have subclasses of Button in a CheckBoxGroup")
      }

      push_undo()

      #
      # Create a new group
      #
      n := new_checkbox_group()

      #
      # For all selections...
      #
      every e := !selections do {
         #
         # Set the object's check_box_group field.
         #
         e.set_parent_check_box_group(n)

         #
         # If it's checked, clear it.
         #
         e.set_is_checked(&no)

         #
         # Reset the element as the size may have changed.
         #
         e.reset()
      }

      self.set_modified()

      #
      # As we may have changed the size of the objects, we must re-display whole.
      #
      self.do_reset_all_layouts()
   end

   #
   # Operation to create a ButtonGroup from the current selections.
   #
   public selections_to_bg()
      local e, n
      something_selected() | fail

      #
      # Check all selections are buttons.
      #
      every e := !selections do {
         if not is(e, CanvasButton) then
            return alert_error(parent_dialog, "You can only have subclasses of Button in a ButtonGroup")
      }

      push_undo()

      #
      # Create a new button group.   
      #
      n := new_button_group()

      #
      # Set all the selections' pointers to the new group.
      #
      every e := !selections do
         e.set_parent_button_group(n)

      self.set_modified()
   end

   #
   # Operation to delete the current selections.
   #
   public delete_selections()
      local e
      something_selected() | fail

      push_undo()

      #
      # For all selections...
      #
      every e := !selections do {
         if \e.cbwin then {
            #
            # Take it out of its container, effectively disconnecting it.
            #
            e.parent.remove(e)
         }

         if initial_focus === e then
            initial_focus := &null
      }

      #
      # Clear selections. 
      #
      self.clear_selections()

      self.set_modified()

      #
      # Re-display.
      #
      self.do_reset_all_layouts()
   end

   #
   # Operation to delete the given object.
   #
   public delete(cc)
      push_undo()

      if \cc.cbwin then {
         #
         # Take it out of its container, effectively disconnecting it.
         #
         cc.parent.remove(cc)
      }

      if initial_focus === cc then
         initial_focus := &null

      #
      # Clear selections. 
      #
      self.clear_selections()

      self.set_modified()

      #
      # Re-display.
      #
      self.do_reset_all_layouts()
   end

   public op_dialog()
      parent_dialog.op_preferences()
   end

   public op_gridify()
      self.gridify(self)
   end

   public op_save()
      parent_dialog.op_save_button()
   end

   public op_load_component()
      self.component_load(self)
   end

   public op_paste()
      self.component_paste(self)
   end

   public create_menu()
      local m, i

      m := Menu()
      i := TextMenuItem().set_label("Dialog")
      i.connect(self.op_dialog, Event.ACTION)
      m.add(i)

      if /self.layout_delegate then {
         i := TextMenuItem().set_label("Gridify")
         i.connect(self.op_gridify, Event.ACTION)
         m.add(i)
      }

      i := TextMenuItem().set_label("Paste")
      i.connect(self.op_paste, Event.ACTION)
      m.add(i)

      if \self.modified | /self.filename then {
         i := TextMenuItem().set_label("Save")
         i.connect(self.op_save, Event.ACTION)
         m.add(i)
      }

      i := TextMenuItem().set_label("Load")
      i.connect(self.op_load_component, Event.ACTION)
      m.add(i)

      return m
   end

   #
   # Add a new CheckBoxGroup
   #
   public new_checkbox_group()
      local n
      n := CanvasCheckBoxGroup()
      n.change_canvas(self)
      n.rename()
      put(checkbox_groups, n)
      return n
   end

   #
   # Add a new ButtonGroup
   #
   public new_button_group()
      local n
      n := CanvasButtonGroup()
      n.change_canvas(self)
      n.rename()
      put(button_groups, n)
      return n
   end

   private pre_decode()
      new()
   end

   public new()
      Component.new()
      set_wattrib_ancestor(Gui.EMPTY_WATTRIB_ANCESTOR)
      self.parent_Canvas := self
      gen_main := gen_component_setup := gen_constructor := gen_init_dialog := &yes
      self.gen_indent := 3
      self.name := "Untitled"
      self.superclass_name := "Dialog"
      self.import_name := "gui"
      self.selections := []
      self.children := []
      self.button_groups := []
      self.checkbox_groups := []
      self.dialog_struct := CDialog()
      self.dialog_iw := Canvas.DEFAULT_WIDTH
      self.dialog_ih := Canvas.DEFAULT_HEIGHT
      self.edit_scale := Gui.SCALE
      set_accepts_focus(&yes)
      connect(self.handle_move, Event.MOUSE_MOVEMENT)
      connect(self.handle_lpress, Event.MOUSE_LEFT_PRESS)
      connect(self.handle_rpress, Event.MOUSE_RIGHT_PRESS)
      connect(self.handle_ldrag, Event.MOUSE_LEFT_DRAG)
      connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE)
      connect(self.handle_key, Event.KEY_PRESS)
      return
   end
end
