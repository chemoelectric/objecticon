#
# Support procedures for ieval.
#

package ipl.ieval

import io, gui-(List), lang, xdg, ipl.columnize, parser(Parser,Token), eval, util,
   ipl.pdco, ipl.sort, ipl.termdialog, ipl.lists, ipl.scan, net, ipl.options

$load IEVAL_LOGO "rpp.IEVAL_LOGO.png"

package record Activation(coex, info)
package record NamePair(long, short)

class IevalTermDialog(TermDialog, MinimalObjectOutput)
end

class Ieval(MinimalObjectOutput)
   private 
      input, output, error, vars, ev, quiet_flag, par, consts,
      oos, trace_flag, parse_flag, last_runerr, ee, hlim,
      elim, llim, imports, files, opts, history, is_flowterm

   private show_env()
      local p
      every p := !sort(vars) do {
         output.writes(p[1], " = ")
         oos.show(p[2])
         output.write()
      }
   end

   private show_help()
      output.
         write("!env        Show the values stored in the environment, excluding these predefined").
         write("            values.").
         write("!help       Show help.").
         write("!parse      Toggle parse mode, in which just the syntax structure of the command is").
         write("            printed.").
         write("!trace      Toggle tracing.").
         write("!wglob      Toggle the write-globals flag.").
         write("!traceback  Show the traceback of the last command that gave a runtime error.").
         write("!quiet      Don't force evaluation of all of the values in the expression, and don't").
         write("            output any expression value.").
         write("dir(x,l)    With no parameter, show all global variables.  With a parameter, show").
         write("            information about it.  If l is non-null, show class field locations.").
         write("!hist       Show the command line history.").
         write("!cls        Clear the screen.").
         write("old(s)      Search history for commands containing string s.").
         write("hlim(n)     Set the history limit to n.").
         write("elim(n)     Set the expression limit to n (min 10).").
         write("llim(n)     Set the gui log area line limit to n (min 10).").
         write("load(s)     Load the given prog, and set its error handler.").
         write("gg(s,p)     Get the given global from the the given prog (shorthand for").
         write("            Prog.get_global).").
         write("oos         The ObjectOutputStream used to output results.").
         write("out         The OutputStream of the terminal.")
   end

   private get_screen_width()
      return if is(output, TermDialog) then
         output.get_term_width()
      else
         LineEditorStream.get_console_width() | 80
   end

   private output_columns(l)
      every output.write(columnize_gen(qsort(l, Text.consistent_compare), get_screen_width(),,, text_link))
   end

   private list_syms()
      local l, e
      l := []
      every e := get_accessible_global_names() do
         if e ? ((not upto('.')) | (=!imports & ="." & (not upto('.')))) then
            put(l, e)
      output_columns(l)
   end

   private list_prog_syms(prog)
      output_columns(List{ get_accessible_global_names(prog) })
   end

   private show_parse(x, level)
      /level := 0
      if is(x, Token) then
         output.write(repl("\t", level), x.s)
      else
         every show_parse(x.gen(), level + 1)
   end

   private flags_string(f)
      local s
      s := ""
      if iand(f, Class.Method) ~= 0 then
         s ||:= "Method "
      if iand(f, Class.Private) ~= 0 then
         s ||:= "Private "
      if iand(f, Class.Public) ~= 0 then
         s ||:= "Public "
      if iand(f, Class.Protected) ~= 0 then
         s ||:= "Protected "
      if iand(f, Class.Package) ~= 0 then
         s ||:= "Package "
      if iand(f, Class.Static) ~= 0 then
         s ||:= "Static "
      if iand(f, Class.Const) ~= 0 then
         s ||:= "Const "
      if iand(f, Class.Readable) ~= 0 then
         s ||:= "Readable "
      if iand(f, Class.Defer) ~= 0 then
         s ||:= "Defer "
      if iand(f, Class.Abstract) ~= 0 then
         s ||:= "Abstract "
      if iand(f, Class.Native) ~= 0 then
         s ||:= "Native "
      if iand(f, Class.Final) ~= 0 then
         s ||:= "Final "
      if iand(f, Class.Special) ~= 0 then
         s ||:= "Special "
      if iand(f, Class.Removed) ~= 0 then
         s ||:= "Removed "
      s[-1] := ""
      return s
   end

   private comma_string(e)
      local s
      s := ""
      while s ||:= @e || ", "
      s[-2:0] := ""
      return s
   end

   private supers_string(c)
      return comma_string{Class.get_name(Class.get_supers(c))} 
   end

   private implements_string(c)
      return comma_string{text_link(Class.get_name(Class.get_implemented_classes(c)))}
   end

   private fields_string(c)
      return comma_string{Constructor.get_field_names(c)}
   end

   private text_link(s)
      return if /is_flowterm then s else 
         "\e[!\"text:" || URL.percent_encode(s, URL.UNRESERVED) || "\"L" || s || "\e[!L" 
   end

   private locn_string(l)
      return if /is_flowterm then
         "line " || l.line || " in " || l.file
      else
         Files.begin_link(l.file, l.line) || "line " || l.line || " in " || l.file || Files.end_link()
   end

   private abbr_locn_string(l)
      return if /is_flowterm then
         "line " || l.line || " in " || FilePath(l.file).get(-1)
      else
         Files.begin_link(l.file, l.line) || "line " || l.line || " in " || FilePath(l.file).get(-1) || Files.end_link()
   end

   private kind_string(f)
      return case f of {
         Proc.Procedure: "Procedure"
         Proc.Function: "Function"
         Proc.Keyword: "Keyword"
         Proc.Operator: "Operator"
         Proc.Internal: "Internal"
      }
   end

   private var_string(f)
      return case f of {
         Proc.Argument: "Argument"
         Proc.Dynamic: "Dynamic"
         Proc.Static: "Static"
      }
   end

   private args_string(f)
      local s
      s := Proc.get_n_arguments(f)
      if Proc.has_varargs(f) then
         s ||:= "[]"
      return s
   end

   private print_table(t, links)
      local w, widths, col, row
      /links := set()
      widths := []
      every col := 1 to *t[1] - 1 do {
         w := 0
         every w <:= *(!t)[col]
         put(widths, w)
      }
      every row := !t do {
         every col := 1 to *t[1] do {
            output.writes1(if member(links, col) then text_link(row[col]) else row[col])
            if col < *t[1] then
               output.writes1(repl(" ", 4 + widths[col] - *row[col]))
         }
         output.write()
      }
   end

   private dir(a[])
      local f, t, c, s
      if *a = 0 then
         list_syms()
      else case type(c := a[1]) of {
         "object"|"cast"|"class": {
            s := map(flags_string(Class.get_class_flags(c)))
            if *s > 0 then
               output.writes(s, " ")
            output.write("class ", Class.get_name(c), "(", supers_string(c), ")")
            output.write("   at ", locn_string(Class.get_location(c))) 
            output.write("   implements ", implements_string(c))
            t := []
            every f := Class.get_field_names(c) do {
               put(t, [f, 
                       Class.get_name(Class.get_field_defining_class(c, f)), 
                       right(Class.get_field_index(c, f), *Class.get_n_fields(c)),
                       flags_string(Class.get_field_flags(c, f)) ])
               if \a[2] then
                  put(t[-1], abbr_locn_string(Class.get_field_location(c, f)))
            }
            t := qsort(t, index_cmp(1, Text.consistent_compare))
            print_table(t, set(1))
         }
         "procedure"|"methp": {
            output.write(map(kind_string(Proc.get_kind(c))), " ", Proc.get_name(c), "(", args_string(c), ")")
            output.write("   at ", locn_string(Proc.get_location(c))) 
            output.write("   method of ", text_link(Class.get_name(Proc.get_defining_class(c))))
            t := []
            every f := Proc.get_local_names(c) do
               put(t, [f,
                       var_string(Proc.get_local_kind(c, f))])
            print_table(t)
         }
         "record"|"constructor": {
            output.write("constructor ",
                         Constructor.get_name(c), "(", fields_string(c), ")")
            output.write("   at ", locn_string(Constructor.get_location(c))) 
         }
         "co-expression": {
            if Coexpression.is_main(c) then
               list_prog_syms(c)
            else {
               oos.show(c)
               output.write()
            }
         }
         default: {
            oos.show(c)
            output.write()
         }
      }
   end

   private cls()
      if is(output, DescStream) then
         output.writes1("\e[2J\e[H")
      else
         output.clear_text()
   end

   private hist(s)
      local i, e
      /s := u""
      s := map(need_ucs(s))
      i := input.get_history_start_no()
      every e := !input.get_history() do {
         if find(s, map(e)) then
            output.write(right(i, 4), "  ", e)
         i +:= 1
      }
   end

   private wglob()
      ee.set_write_globals(toggle_flag(ee.write_globals_flag))
      return ee.write_globals_flag
   end

   private set_elim(n)
      if \n then {
         (elim := (10 <= n)) | {
            error.write("Parameter to elim() out of range")
            fail
         }
      }
      return .elim
   end

   private set_hlim(n)
      if \n then {
         if hlim := (10 <= n) then
            input.set_history_limit(hlim)
         else {
            error.write("Parameter to hlim() out of range")
            fail
         }
      }
      return .hlim
   end

   private set_llim(n)
      if \n then {
         if llim := (0 <= n) then {
            if is(input, TermDialog) then
               input.set_log_limit(llim)
         } else {
            error.write("Parameter to llim() out of range")
            fail
         }
      }
      return .llim
   end

   private load_handler(prog)
      local s, i
      coact()
      repeat {
         if s := Prog.eval_keyword("&errortext", prog) then {
            if i := Prog.eval_keyword("&errornumber", prog) then
               error.write("Runtime error ", i, ": ", s)
            else
               error.write("Runtime error: ", s)
            error.write("Offending value: ", image(Prog.eval_keyword("&errorvalue", prog)))
            last_runerr := Prog.eval_keyword("&errorcoexpr", prog)
            errorclear(prog)
         }
         cofail(&handler)
      }
   end

   private load(s)
      local p, e
      p := Prog.load(s) | fail
      e := create load_handler(p)
      @e
      Prog.eval_keyword("&handler", p) := e
      return p
   end

   private traceback()
      local act_chain, depth, fe2, LIMIT, ae, fe, ce
      
      # Produce similar output to:-
      #    Coexpression.traceback(\last_runerr, &yes)

      ce := \last_runerr | fail
      act_chain := []
      until (!act_chain).coex === ce do {
         push(act_chain, Activation(ce, Coexpression.get_stack_info(ce)))
         ce := Coexpression.get_activator(ce) | break
      }

      depth := 0
      every depth +:= *(!act_chain).info

      LIMIT := 100
      output.write("Traceback:")
      every ae := !act_chain do {
         if depth - LIMIT >= *ae.info then
            depth -:= *ae.info
         else {
            if ce := Coexpression.get_activator(ae.coex) then
               output.write("co-expression#", serial(ae.coex), " activated by co-expression#", serial(ce))
            else
               output.write("co-expression#", serial(ae.coex), "  (never activated)")
            if depth > LIMIT then {
               if depth = LIMIT + 1 then
                  depth := LIMIT
               else
                  output.write("   ... ", depth - LIMIT, " calls omitted")
            }
            fe2 := &null
            every fe := back(ae.info) do {
               if depth <= LIMIT then {
                  output.writes("   ", fe.proc, "(", list2str(fe.args), ")")
                  if \fe2 then
                     output.write(" from ", abbr_locn_string(fe2))
                   else
                     output.write()
               }
               depth -:= 1
               fe2 := fe
            }
            if \fe2 then
               output.write("   at ", abbr_locn_string(fe2))
         }
      }
   end

   public new(imports, files, opts)
      self.imports := imports
      self.files := files
      self.opts := opts
      par := Parser()
      vars := table()
      consts := table()
      ee := DefaultEvaluatorEnv(vars, consts)
      if \opts["wglob"] then
         ee.set_write_globals(&yes)
      ev := Evaluator().
         set_env(ee).
         set_imports(imports)
      if hlim := \opts["hlim"] then
         (10 <= hlim) | help_stop("Invalid value of hlim")
      else
         hlim := 500
      if llim := \opts["llim"] then
         (0 <= llim) | help_stop("Invalid value of llim")
      else
         llim := 600
      if elim := \opts["elim"] then
         (10 <= elim) | help_stop("Invalid value of elim")
      else
         elim := 35
      return
   end

   public run()
      local hfile
      is_flowterm := Yes{ \opts["g"] | FileStream.stdout.is_flowterm_tty() }
      if \opts["z"] then
         do_nothing()
      else {
         hfile := FilePath(BaseDir.ensure_data_home()).child("ieval").str() | stop("Couldn't access data dir: ", &why)
         history := decode_from_file(hfile) | []
         if \opts["g"] then
            do_gui()
         else
            do_line_editor()
         encode_to_file(hfile, input.get_history()) | stop("Couldn't encode to history file ", hfile, ": ", &why)
      }
      write("Ciao")
   end

   private prelim()
      local f, s, n
      consts["env"] := create show_env()
      consts["help"] := create show_help()
      consts["trace"] := create trace_flag := toggle_flag(trace_flag)
      consts["parse"] := create parse_flag := toggle_flag(parse_flag)
      consts["quiet"] := create quiet_flag := toggle_flag(quiet_flag)
      consts["wglob"] := create wglob()
      consts["dir"] := dir
      consts["hist"] := create hist()
      consts["cls"] := create cls()
      consts["old"] := hist
      consts["elim"] := set_elim
      consts["hlim"] := set_hlim
      consts["llim"] := set_llim
      consts["load"] := load
      consts["gg"] := Prog.get_global
      consts["traceback"] := create traceback()
      consts["oos"] := oos := ObjectOutputStream(output).set_indent(3)
      consts["out"] := output

      f := FilePath(BaseDir.ensure_config_home()).child("ieval").str() | stop("Couldn't access config dir: ", &why)
      if Files.access(f) then
         push(files, f)
      every f := !files do {
         s := Files.file_to_string(f) | stop("Couldn't load ", f, ": ", &why)
         n := par.parse_expression(s) | stop("Couldn't parse ", f,  ": ", &why)
         ev.set_node(n) | stop("Couldn't parse ", f,  ": ", &why) 
         Safe{ev.eval()}
         if &errortext then {
            if &errornumber then
               ewrite("Runtime error ", &errornumber, ": ", &errortext)
            else
               ewrite("Runtime error: ", &errortext)
            ewrite("Offending value: ", image(&errorvalue))
            last_runerr := &errorcoexpr
            errorclear()
            break
         }
      }
   end

   private body(s)
      local n, i, v, run

      run := create save_state(create ev.eval(), 
                               States(TraceState(if /trace_flag then 0 else -1), HandlerState(&current)))
      if n := par.parse_expression(s, "UTF-8") then {
         if \parse_flag & s ~== "!parse" then
            show_parse(n)
         else {
            if ev.set_node(n) then {
               if \quiet_flag then
                  !run
               else {
                  i := elim
                  every v := !run do {
                     i -:= 1
                     if i < 0 then {
                        output.write(".... (result sequence truncated)")
                        break
                     }
                     oos.show(v)
                     output.write()
                  }
               }
               if &errortext then {
                  if &errornumber then
                     error.write("Runtime error ", &errornumber, ": ", &errortext)
                  else
                     error.write("Runtime error: ", &errortext)
                  error.write("Offending value: ", image(&errorvalue))
                  last_runerr := &errorcoexpr
                  errorclear()
               }
            } else
               error.write("Couldn't parse: ", &why)
         }
      } else
         error.write("Couldn't parse: ", &why)
   end

   private static complete_keyword(p, subj, pos)
      local l, e
      l := []
      every e := Proc.get_name(Prog.get_keywords()) do {
         if match(p, e) then
            put(l, simple_insert(e, p, subj, pos))
      }
      return l
   end

   private static simple_insert(e, p, subj, pos)
      return CompleteElement(e, subj[1:pos - *p] || e || subj[pos:0], pos - *p + *e)
   end

   private lookup_global(p)
      return Safe1{ ee.get(string(p), ev) }
   end

   private static get_accessible_global_names(P)
      local n, i
      every n := 1 to Prog.get_n_globals(P) do {
         i := Prog.get_global_flags(n, P)
         if iand(i, Prog.Package) = 0 |
            iand(i, Prog.Readable) ~= 0
         then
            suspend Prog.get_global_name(n, P)
      }
   end

   private gen_package_global_names(p)
      local e
      if p == u"default" then {
         every e := get_accessible_global_names() do
            upto('.', e) | suspend "default." || e
         suspend "default." || key(consts | vars)
      } else if member(imports, string(p)) then {
         every e := get_accessible_global_names() do
            e ? if =p & ="." & (not upto('.')) then
               suspend e
      }
   end

   private dot_candidates(h, t)
      local v, f, i
      suspend !imports || "." | gen_package_global_names(h)
      if v := lookup_global(h) then {
         case type(v) of {
            "class": {
               every f := Class.get_class_field_names(v) do {
                  i := Class.get_field_flags(v, f)
                  if iand(i, Class.Static) ~= 0 & 
                     iand(i, Class.Public + Class.Readable) ~= 0
                  then
                     suspend h || "." || f
               }
            }
            "object": {  
               every f := Class.get_field_names(v) do {
                  i := Class.get_field_flags(v, f)
                  if iand(i, Class.Static) = 0 &
                     iand(i, Class.Public + Class.Readable) ~= 0
                  then
                     suspend h || "." || f
               }
            }
            "record": 
               suspend h || "." || Constructor.get_field_names(v)
         }
      }
   end

   private complete_ident_dot(p, h, t, subj, pos)
      local c
      every c := dot_candidates(h, t) do
         if match(p, c) then
            suspend simple_insert(c, p, subj, pos)
   end

   private complete_ident_no_dot(p, subj, pos)
      local e, l, t, v

      l := []
      every e := !imports || "." | "default." do
         if match(p, e) then
            put(l, NamePair(e, e))
      every e := key(consts | vars) do
         if match(p, e) & not Prog.get_global_name(e) then
            put(l, NamePair("default." || e, e))
      every e := Prog.get_global_names() do
         if not upto('.', e) & match(p, e) then
            put(l, NamePair("default." || e, e))
      every e := get_accessible_global_names() do
         e ? if =!imports & ="." & (not upto('.')) & match(p) then
            put(l, NamePair(e, tab(0)))

      # Note any ambiguities
      t := table(0)
      every t[(!l).short] +:= 1

      every e := !l do {
         v := if t[e.short] > 1 then e.long else e.short
         suspend simple_insert(v, p, subj, pos)
      }
   end

   private complete_ident(p, subj, pos)
      local l, i
      l := []
      if i := backto('.', p) then
         every put(l, complete_ident_dot(p, p[1: i - 1], p[i:0], subj, pos))
      else
         every put(l, complete_ident_no_dot(p, subj, pos))
      return l
   end

   private complete(subj, pos)
      local p, l
      subj ? {
         tab(pos)
         l := if p := tab(rev_many0(&letters,,, 1)) & rev_any('&',,, 1) then
            complete_keyword(u"&" || p, subj, pos)
         else if p := tab(rev_many(&letters ++ &digits ++ '_.',,, 1)) & any(&letters ++ '_', p[1]) then
            complete_ident(p, subj, pos)
         else
            []
      }
      if *l = 1 & l[1].str == subj then
         pop(l)
      return qsort(l, cmp_CompleteElement)
   end

   private do_gui()
      local s, t, prompt

      input := IevalTermDialog().
         set_complete_function(complete).
         set_label("ieval").
         set_icon(IEVAL_LOGO).
         set_history_limit(hlim).
         set_log_limit(llim).
         set_history(history)

      if \opts["a"] then
         input.set_popup_on_tab(&no)

      error := output := input
      s := ""
      prompt := "> "
      input.connect(create {
         t := input.line
         output.write(prompt, t)
         s ||:= t
         if s[-1] == "\\" then {
            s[-1] := ""
            prompt := ">> "
         } else {
            body(s)
            prompt := "> "
            s := ""
         }
      }, Event.ACTION)
      # Do prelim() after showing the TermDialog, since output to
      # it will be discarded before it is live.
      input.show()
      prelim()
      Dispatcher.message_loop(input)
   end

   private do_nothing()
      output := FileStream.stdout
      error := FileStream.stderr
      prelim()
   end

   private do_line_editor()
      local s, t, prompt
      input := LineEditorStream(opts["s"]).
         set_complete_function(complete).
         set_history_limit(hlim).
         set_history(history) | stop("Failed to create LineEditorStream: ", &why)

      do_nothing()

      s := ""
      prompt := "> "
      repeat {
         input.set_prompt(prompt)
         t := input.read_line() | stop("Failed to read input: ", &why)
         if /t then break
         s ||:= t
         if s[-1] == "\\" then {
            s[-1] := ""
            prompt := ">> "
         } else {
            body(s)
            prompt := "> "
            s := ""
         }
      }
   end
end
