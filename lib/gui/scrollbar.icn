#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

import util, lang

#
# Component representing the bar area
#
class BarArea(Component)
   public  
      bar_x,                   #             
      bar_y,                   #             
      bar_w,                   #             
      bar_h

   public display()
      Gui.style.draw_raised_rectangle(self.cbwin, self.bar_x, self.bar_y, 
                                  self.bar_w, self.bar_h, 
                                  Gui.BORDER_WIDTH)
   end
end


#
# This class provides horizontal and vertical scroll bars.
#
# There are two ways to use a scroll bar.  The first way is to
# set a total_size (represented by the whole bar), a page_size
# (represented by the draggable button) and an increment_size
# (being the amount added/subtracted when the top/bottom
# button is pressed).  The value will then range from zero to
# (total_size - page_size) inclusive.  An initial value must
# be set with the {set_value()} method.
# @example
# @ vb := ScrollBar()
# @ vb.set_pos("85%", "25%")      
# @ vb.set_size(20, "40%")
# @ vb.set_total_size(130)
# @ vb.set_page_size(30)
# @ vb.set_increment_size(1)
# @ vb.set_value(0)
# @ self.add(vb)
#
# Alternatively, a scroll bar can be used as a slider which
# ranges over a given range of values.  In this case, the
# range is set with {set_range()}.  It is still necessary to set
# the increment size and the initial value, as above, but
# page_size and total_size should not be set.
#
# Real numbers as opposed to integers can be used for the
# range settings if desired.
# @example
# @ vb := ScrollBar()
# @ vb.set_pos("85%", "25%")      
# @ vb.set_size(20, "40%")
# @ vb.set_range(2, 25)
# @ vb.set_value(10)
# @ vb.set_increment_size(1)
# @ self.add(vb)
#
# A Event.VALUE_CHANGED, which is fired whenever the value changes.
#
class ScrollBar(Component)
   public 
      value,                   #             
      old_value,
      page_size,               #                 
      increment_size,          #                      
      wheel_factor,
      wheel_component,
      total_size,              #                  
      hi,                      #          
      lo,                      #          
      bar_down,                #                
      is_paging,               #
      bar_down_offset,         #                       
      bar_area,                #
      b1,                      #          
      b2,                      #          
      is_horizontal_flag,      #                          
      bar_pos,                 #  Orientation independent bar pos
      bar_size,                #                
      bar_area_pos,            #  Orientation independent bararea pos
      bar_area_size,           #                     
      is_range_flag,           
      wu_listener,
      wd_listener,
      repeat_ticker,
      repeat_delay

   public static DEFAULT_INNER_SIZE, DEFAULT_WHEEL_FACTOR, MIN_BAR_SIZE

   private static init()
      DEFAULT_INNER_SIZE := 16
      DEFAULT_WHEEL_FACTOR := 4
      MIN_BAR_SIZE := 8
   end

   #
   # Configure the orientation (default is vertical).
   #
   public set_is_horizontal(s)
      self.is_horizontal_flag := check_flag(s)
      return self
   end

   #
   # Set the total size which the scroll bar area represents.
   # @param x   The total size
   #
   public set_total_size(x)
      self.total_size := x
      self.reconfigure()
      return self
   end

   #
   # Return the total size.
   #
   public get_total_size()
      return self.total_size
   end

   #
   # Set the size which the bar in the scroll bar area represents.
   # @param x   The size.
   #
   public set_page_size(x)
      self.page_size := x
      self.reconfigure()
      return self
   end

   #
   # Get the page size.
   #
   public get_page_size()
      return self.page_size
   end

   #
   # Get the value.
   # @return The value
   #
   public get_value()
      return self.value
   end

   #
   # Set the value representing the top of the bar in the scroll
   # bar.  The value is forced into range if it is not in range already.
   # @param x   The value.
   #
   public set_value(x)
      if is_live() then {
         self.move_value(x)
         self.set_pos_from_value()
      } else
         self.value := x
      return self
   end

   #
   # Set the amount to increase the value by when one of the
   # buttons is pressed.
   # @param x   The increment size.
   #
   public set_increment_size(x)
      self.increment_size := x
      return self
   end

   #
   # Set the range of the scroll bar.  The values may
   # be integer or real.
   # @param lo  The lower bound
   # @param hi  The upper bound
   #
   public set_range(lo, hi)
      self.is_range_flag := 1
      self.lo := lo
      self.hi := hi
      self.reconfigure()
      return self
   end

   #
   # Set the component in whose region we will detect wheel events.
   # Setting to &null disables wheel activity.
   #
   public set_wheel_component(c)
      (\self.wheel_component).disconnect(wu_listener)
      (\self.wheel_component).disconnect(wd_listener)
      self.wheel_component := c
      if /self.wheel_component then 
         wu_listener := wd_listener := &null
      else {
         wu_listener := self.wheel_component.connect_and_return(self.handle_wheel_up, Event.MOUSE_WHEEL_UP)
         wd_listener := self.wheel_component.connect_and_return(self.handle_wheel_down, Event.MOUSE_WHEEL_DOWN)
      }
      return self
   end

   #
   # Set the wheel factor, being the number of increments to
   # move on a wheel press; by default is {DEFAULT_WHEEL_FACTOR}
   #
   public set_wheel_factor(n)
      self.wheel_factor := n
      return self
   end

   #
   # Get the wheel_factor
   #
   public get_wheel_factor()
      return self.wheel_factor
   end

   public move_bar_pos(x)
      x <:= self.bar_area_pos
      x >:= self.bar_area_pos + self.bar_area_size - self.bar_size
      (self.bar_pos ~=== x) | fail
      self.bar_pos := x
      if /self.is_horizontal_flag then
         self.bar_area.bar_y := self.bar_pos
      else
         self.bar_area.bar_x := self.bar_pos        
      self.bar_area.invalidate()
   end

   public move_value(x)
      self.value := x
      self.value <:= self.lo
      self.value >:= self.hi
   end

   public set_pos_from_value()
      if self.hi ~= self.lo then
         self.move_bar_pos(self.bar_area_pos + integer(((self.get_value() - self.lo) * 
                                                        (self.bar_area_size - self.bar_size)) / (self.hi - self.lo)))
      else
         self.move_bar_pos(self.bar_area_pos)
   end

   public set_value_from_pos()
      if self.bar_area_size ~= self.bar_size then
         self.move_value(self.lo + ((self.hi - self.lo) * (self.bar_pos - self.bar_area_pos)) / 
                         (self.bar_area_size - self.bar_size))
      else
         self.move_value(self.lo)
   end

   public get_default_height()
      if \self.is_horizontal_flag then
         return DEFAULT_INNER_SIZE + border.get_total_height()
   end

   public get_default_width()
      if /self.is_horizontal_flag then
         return DEFAULT_INNER_SIZE + border.get_total_width()
   end

   public handle_lpress(e)
      start_handle(e)
      if (self.bar_area.bar_x <= e.x < self.bar_area.bar_x + self.bar_area.bar_w) & 
         (self.bar_area.bar_y  <= e.y < self.bar_area.bar_y + self.bar_area.bar_h) then {
         #
         # Click on bar; set flag and save offset between top of bar and pointer position
         #
         self.bar_down := 1
         if /self.is_horizontal_flag then
            self.bar_down_offset := e.y - self.bar_area.bar_y
         else
            self.bar_down_offset := e.x - self.bar_area.bar_x
      } else if (/self.is_horizontal_flag & (self.bar_area.y  <= e.y < self.bar_area.bar_y)) | 
         (self.bar_area.x  <= e.x < self.bar_area.bar_x) then {
         self.move_value(self.get_value() - self.page_size)
         self.set_pos_from_value()
         start_paging(-1)
      } else  if (/self.is_horizontal_flag &
                  (self.bar_area.bar_y + self.bar_area.bar_h  <= e.y <  self.bar_area.y + self.bar_area.h)) | 
          (self.bar_area.bar_x + self.bar_area.bar_w  <= e.x <  self.bar_area.x + self.bar_area.w) then {
         self.move_value(self.get_value() + self.page_size)
         self.set_pos_from_value()
         start_paging(1)
      }
      end_handle(e)
   end

   public handle_lrelease(e)
      start_handle(e)
      self.bar_down := &null
      stop_paging()
      end_handle(e)
   end

   public repeat_tick()
      repeat {
         if Prog.get_runtime_millis() > self.repeat_delay then {
            start_handle()
            self.move_value(self.get_value() + self.is_paging * self.page_size)
            self.set_pos_from_value()
            end_handle()
         }
         repeat_ticker.sleep(Gui.REPEAT_RATE)
      }
   end

   public start_paging(n)
      self.is_paging := n
      self.repeat_delay := Prog.get_runtime_millis() + Gui.REPEAT_DELAY
      repeat_ticker.start()
   end

   public stop_paging()
      self.is_paging := &null
      repeat_ticker.stop()
   end

   public start_handle(e)
      old_value := value
   end

   public end_handle(e)
      if old_value ~=== value then
         fire(Event.VALUE_CHANGED, e)
   end

   public handle_wheel_up(e)
      /self.bar_down | fail
      start_handle(e)
      self.move_value(self.get_value() - self.wheel_factor * self.increment_size)
      self.set_pos_from_value()
      end_handle(e)
   end

   public handle_wheel_down(e)
      /self.bar_down | fail
      start_handle(e)
      self.move_value(self.get_value() + self.wheel_factor * self.increment_size)
      self.set_pos_from_value()
      end_handle(e)
   end

   public handle_button_up(e)
      start_handle(e)
      #
      # Button up clicked
      #
      self.move_value(self.get_value() - self.increment_size)
      self.set_pos_from_value()
      end_handle(e)
   end

   public handle_button_down(e)
      start_handle(e)
      #
      # Button down clicked
      #
      self.move_value(self.get_value() + self.increment_size)
      self.set_pos_from_value()
      end_handle(e)
   end

   public handle_ldrag(e)
      \self.bar_down | fail

      start_handle(e)
      #
      # Bar dragged; compute new position
      #
      if /self.is_horizontal_flag then
         self.move_bar_pos(e.y - self.bar_down_offset)
      else
         self.move_bar_pos(e.x - self.bar_down_offset)
      self.set_value_from_pos()
      end_handle(e)
   end

   public display()
      border.draw_rect(self.cbwin, self)
      display_children()
   end

   public reconfigure()
      # Don't do anything if we haven't been positioned yet.
      is_live() | fail

      # Check sensible values
      if /self.is_range_flag then {
         if self.page_size <= 0 then
            runerr("Invalid page size", self.page_size)
      } else {
         if \self.lo >= \self.hi then
            runerr("Invalid range")
      }

      if /self.is_range_flag then {
         #
         # Not a range; compute lo, hi and bar_size.
         #
         self.lo := 0
         if self.total_size > self.page_size then {
            self.hi := self.total_size - self.page_size
            self.bar_size := integer((self.bar_area_size * self.page_size) / self.total_size)
         } else {
            #
            # Total <= page; these settings produce an immovable full size bar.
            #
            self.hi := 0
            self.bar_size := self.bar_area_size 
         }
      } else {
         #
         # Range; set bar size proportional to button size, but leave room if bar_area_size is small.
         #
         self.bar_size := (b1.w * 3) / 2
         self.bar_size >:= self.bar_area_size - 8
      }
      #
      # Ensure bar size in range not less than MIN_BAR_SIZE, but must be within
      # bar_area_size.
      #
      self.bar_size <:= MIN_BAR_SIZE
      self.bar_size >:= self.bar_area_size

      if \self.is_range_flag then {
         #
         # For a slider, we still need the page size for clicks in the bar.
         #
         self.page_size := ((self.hi - self.lo) * self.bar_size) / (0 ~= self.bar_area_size) | 0
      }

      #
      # Set bar height/width according to orientation
      #
      if /self.is_horizontal_flag then
         self.bar_area.bar_h := self.bar_size
      else
         self.bar_area.bar_w := self.bar_size

      self.move_value(self.value)
      self.set_pos_from_value()
      self.bar_area.invalidate()
   end

   public initially()
      if /self.is_range_flag then {
         \self.total_size | runerr("Total size not set")
         \self.page_size | runerr("Page size not set")
      }
      \self.increment_size | runerr("Increment size not set")
      \self.value | runerr("Value not set")

      if /self.is_horizontal_flag then {
         b1.set_paint(ImagePaint().set_cache("gui.ARROW_UP"))
         b2.set_paint(ImagePaint().set_cache("gui.ARROW_DOWN"))
      } else {
         b1.set_paint(ImagePaint().set_cache("gui.ARROW_LEFT"))
         b2.set_paint(ImagePaint().set_cache("gui.ARROW_RIGHT"))
      }
      cast(self,Component).initially()
   end

   public layout()
      if /self.is_horizontal_flag then {
         #
         # Set button positions
         #
         b1.x := self.x + border.get_l_inset()
         b1.y := self.y + border.get_t_inset()
         b1.w := self.w - border.get_total_width()
         b1.h := max(DEFAULT_INNER_SIZE, b1.get_preferred_height(b1.w))
         b2.x := b1.x 
         b2.h := max(DEFAULT_INNER_SIZE, b2.get_preferred_height(b1.w))
         b2.y := self.y + self.h - b2.h - border.get_b_inset()
         b2.w := b1.w

         #
         # Compute bar area dimensions
         #
         bar_area.x := b1.x + 2
         bar_area.y := b1.y + b1.h
         bar_area.w := b1.w - 4
         bar_area.h := b2.y - (b1.y + b1.h)

         self.bar_area.bar_x := self.bar_area.x
         self.bar_area_pos := self.bar_area.y
         self.bar_area.bar_w := self.bar_area.w
         self.bar_area_size := self.bar_area.h
      } else {
         b1.x := self.x + border.get_l_inset()
         b1.y := self.y + border.get_t_inset()
         b1.w := max(DEFAULT_INNER_SIZE, b1.get_preferred_width())
         b1.h := self.h - border.get_total_height()
         b2.w := max(DEFAULT_INNER_SIZE, b2.get_preferred_width())
         b2.x := self.x + self.w - b2.w - border.get_r_inset()
         b2.y := b1.y
         b2.h := b1.h

         bar_area.x := b1.x + b1.w
         bar_area.y := b1.y + 2
         bar_area.w := b2.x - (b1.x + b1.w)
         bar_area.h := b1.h - 4

         self.bar_area_pos := self.bar_area.x
         self.bar_area.bar_y := self.bar_area.y
         self.bar_area_size := self.bar_area.w
         self.bar_area.bar_h := self.bar_area.h
      }

      b1.layout()      
      b2.layout()      

      reconfigure()
   end

   public shift(dx, dy)
      cast(self,Component).shift(dx, dy)
      if /self.is_horizontal_flag then {
         self.bar_pos +:= dy
         self.bar_area_pos +:= dy
      } else {
         self.bar_pos +:= dx
         self.bar_area_pos +:= dx
      }
      self.bar_area.bar_x +:= dx
      self.bar_area.bar_y +:= dy
   end

   public finally()
      repeat_ticker.stop()
      cast(self,Component).finally()
   end

   public new()
      cast(self,Component).new()
      repeat_ticker := Dispatcher.new_task{repeat_tick()}
      self.b1 := IconButton().
         set_border(EmptyBorder().set_insets(0, 0, 0, 0)).
         connect(self.handle_button_up, Event.BUTTON_PRESS).
         connect(self.handle_button_up, Event.BUTTON_HELD).
         set_accepts_focus(&no)
      add(self.b1)
      self.b2 := IconButton().
         set_border(EmptyBorder().set_insets(0, 0, 0, 0)).
         connect(self.handle_button_down, Event.BUTTON_PRESS).
         connect(self.handle_button_down, Event.BUTTON_HELD).
         set_accepts_focus(&no)
      add(self.b2)
      self.bar_area := BarArea().
         connect(self.handle_lpress, Event.MOUSE_LEFT_PRESS).
         connect(self.handle_ldrag, Event.MOUSE_LEFT_DRAG).
         connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE)
      add(self.bar_area)
      self.wheel_factor := DEFAULT_WHEEL_FACTOR
      set_wheel_component(self)
      set_border(RaisedBorder())
      return
   end
end
