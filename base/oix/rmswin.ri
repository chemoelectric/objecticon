/*
 * rmswin.ri - Microsoft Windows-specific graphics interface code.
 *
 */

#define FONTHASH_SIZE 64
#define CURSORHASH_SIZE 128

static struct SharedCursor *null_cursor;
static wcp alccontext(wbp w);
static void init_window_system(void);
static void note_skip(wsp ws);
static void setup_cursors(void);
static int inited;
static void open_screen_win(wsp ws);
static void close_screen_win(wsp ws);
static wfp fonts[FONTHASH_SIZE], default_font;
static struct wcursor *cursors[CURSORHASH_SIZE];
static wfp load_font(char *s);
static gb_Font *mkfont(char *s);
static HDC dummy_hdc;
static wsp wsp_for_hwnd(HWND hwnd);
static wcp clonecontext(wcp src);
static void freecontext(wcp wc);
static void freewindow(wsp ws);
static void resizepixmap(wbp w);
static struct imgdataformat imgdataformat_MSBGRA32;
static struct SharedColor *new_sharedcolor(char *name, int r, int g, int b, int a);
static struct SharedColor *link_sharedcolor(struct SharedColor *i);
static void unlink_sharedcolor(struct SharedColor *i);
static struct SharedBitmap *new_sharedbitmap(struct imgdata *imd);
static struct SharedBitmap *link_sharedbitmap(struct SharedBitmap *x);
static void unlink_sharedbitmap(struct SharedBitmap *x);
static struct SharedCursor *new_sharedcursor(HCURSOR cursor, int private);
static struct SharedCursor *link_sharedcursor(struct SharedCursor *x);
static void unlink_sharedcursor(struct SharedCursor *x);
static struct wcursor *lookup_wcursor(char *name);
static struct wcursor *ensure_wcursor(char *name);
static void synch_cursor(wsp ws);
static void synch_cursors(struct wcursor *c);
static gb_Bitmap *imgdata_to_bitmap(struct imgdata *imd);
static void bitmap_to_imgdata(gb_Bitmap *bm, struct imgdata *imd);
static wbp findwbp(wsp ws);
static void handle_paint(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse_enter(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse_leave(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse_move(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse_wheel(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse_up(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_mouse_down(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_capture_changed(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_keypress(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_size(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_move(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_getminmaxinfo(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void handle_showwindow(wsp ws, UINT msg, WPARAM wp, LPARAM lp);
static void capture_mouse(wsp ws);
static void uncapture_mouse(wsp ws);
static void track_mouse(wsp ws);
static void apply_windowlabel(wsp ws);
static void mk_Draw(wbp w, gb_Draw *d);
static int get_outer_width(wsp ws);
static int get_outer_height(wsp ws);
static void synch_state(wsp ws, int new_state);
static void init_geom(wsp ws);
static void synch_pos(wsp ws, int newx, int newy);
static void synch_size(wsp ws, int neww, int newh);

static void show_keystate(char *name, int k);
static void show_keyevent(UINT msg, WPARAM wp, LPARAM lp);
static void dbg(char *fmt, ...);

static wsp grabwin;

static int mouse_debug = 0;
static int key_debug = 0;
static int cursor_debug = 0;

static struct SharedColor *black, *white;

#begdef CheckUnhidden(ws)
do {
   if (!ws->win) {
      LitWhy("Window is hidden");
      return Failed;
   }
} while(0)
#enddef

/* List of windows with win non-null */
static wsp vwstates;

/* List of bindings */
static wbp wbndngs;

#define PALCLR(c) (c | 0x2000000L)

static int BORDER_HEIGHT;
static int BORDER_WIDTH;
static HCURSOR using_cursor;

/*
 * draw ops
 */
stringint drawops[] = {
    { 0, 2},
    {"over",  0},
    {"source",  1},
};

/*
 * line types
 */
stringint linestyles[] = {
    {0, 2},
    {"disc",     EndDisc},
    {"square",   EndSquare},
};

#define NormalCanvas 1
#define HiddenCanvas 2
#define IconicCanvas 3
#define PopupCanvas  4
#define MaximizedCanvas  5
#define WithdrawnCanvas  6

static stringint canvastypes[] = {
    {0, 6},
    {"hidden",      HiddenCanvas},
    {"iconic",      IconicCanvas},
    {"maximized",   MaximizedCanvas},
    {"normal",      NormalCanvas},
    {"popup",       PopupCanvas},
    {"withdrawn",   WithdrawnCanvas},
};

#if 0
static void dump_all(void)
{
    int i,j,k;
    wsp x;
    wbp y;
    i = 0;
    for (y = wbndngs; y; y = y->next) {
        printf("Binding %p\n",y);
        printf("\tcanvas %p\n",y->window);
        printf("\tcontext %p\n",y->context);
        ++i;
    }
    printf("============\n");
    j = 0;
    for (x = wstates; x; x = x->next) {
        printf("Canvas %p\n",x);
        printf("\trefcount=%d\n", x->refcount);
        printf("\tlabel=%s\n", x->windowlabel);
        printf("\tgeometry=%d,%d %dx%d\n", x->x,x->y,x->width,x->height);
        printf("\twin=%d\n", (int)x->win);
        ++j; 
    }
    printf("============\n");
    k = 0;
    for (x = vwstates; x; x = x->vnext) {
        printf("Non-hidden Canvas %p\n",x);
        printf("\trefcount=%d\n", x->refcount);
        printf("\tlabel=%s\n", x->windowlabel);
        printf("\tgeometry=%d,%d %dx%d\n", x->x,x->y,x->width,x->height);
        printf("\twin=%d\n", (int)x->win);
        ++k; 
    }

    printf("Total %d bindings %d canvases (%d non-hidden)\n",i,j,k);
    fflush(stdout);
}
#endif

/*
 * allocate a window binding structure
 */
static wbp alcwbinding(void)
{
    wbp w;
    w = safe_zalloc(sizeof(struct _wbinding));
    GLink(w, wbndngs);
    return w;
}

/*
 * free a window binding.
 */
void freewbinding(wbp w)
{
    freewindow(w->window);
    freecontext(w->context);
    GUnlink(w, wbndngs);
    free(w);
}

wbp wopen(char *display)
{
    wbp w;
    wsp ws;

    if (!inited) {
        init_window_system();
        inited = 1;
    }

    /*
     * allocate a binding, a window state, and a context
     */
    w = alcwbinding();

    GAlloc(ws, _wstate);
    ws->listp = nulldesc;
    ws->windowlabel = defaultwindowlabel;
    add_gc_global(&ws->windowlabel);
    add_gc_global(&ws->listp);
    ws->cursor = lookup_wcursor("arrow");
    ws->state = HiddenCanvas;
    ws->minwidth = ws->minheight = 1;
    ws->maxwidth = ws->maxheight = INT_MAX;
    w->window = ws;
    ws = w->window;
    create_list(64, &ws->listp);
    ws->width = ws->height = 1;
    w->context = alccontext(w);
    ws->reqx = ws->reqy = ws->x = ws->y = -INT_MAX;
    ws->pix = gb_create_Bitmap(ws->width, ws->height, w->context->bg->color, 0);
    ws->pixwidth = ws->width;
    ws->pixheight = ws->height;
    ws->win = 0;
    return w;
}

static void mk_Draw(wbp w, gb_Draw *d)
{
    wsp ws = w->window;
    wcp wc = w->context;
    d->win = ws->win;
    d->pix = ws->pix;
    d->clipx = wc->clipx;
    d->clipy = wc->clipy;
    d->clipw = wc->clipw;
    d->cliph = wc->cliph;
    d->font = wc->font->font;
    d->fg = wc->fg->color;
    d->bg = wc->bg->color;
    d->linewidth = wc->linewidth;
    if (wc->pattern)
        d->pattern = wc->pattern->bitmap;
    else
        d->pattern = 0;
    d->drawop = wc->drawop->i;
    d->linestyle = wc->linestyle->i;
    d->holding = ws->holding;
    if (d->holding) {
        d->holdx = &ws->holdx;
        d->holdy = &ws->holdy;
        d->holdwidth = &ws->holdwidth;
        d->holdheight = &ws->holdheight;
    }
}

static void apply_windowlabel(wsp ws)
{
    WCHAR *mbs = ucs_to_wchar(&ws->windowlabel, 1, NULL);
    SetWindowTextW(ws->win, mbs);
    free(mbs);
}

static void handle_getminmaxinfo(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    MINMAXINFO *mmi = (MINMAXINFO *)lp;
    if (ws->resizable) {
        mmi->ptMinTrackSize.x = ws->minwidth + BORDER_WIDTH;
        mmi->ptMinTrackSize.y = ws->minheight + BORDER_HEIGHT;
        if (ws->maxwidth != INT_MAX)
            mmi->ptMaxTrackSize.x = ws->maxwidth + BORDER_WIDTH;
        if (ws->maxheight != INT_MAX)
            mmi->ptMaxTrackSize.y = ws->maxheight + BORDER_HEIGHT;
    } else {
        mmi->ptMinTrackSize.x = mmi->ptMaxTrackSize.x =
            ws->width + BORDER_WIDTH;
        mmi->ptMinTrackSize.y = mmi->ptMaxTrackSize.y =
            ws->height + BORDER_HEIGHT;
    }
}

static void synch_pos(wsp ws, int newx, int newy)
{
    if ((newx != ws->x) || (newy != ws->y)) {
        ws->x = newx;
        ws->y = newy;
        qeventcode(ws, WINDOWMOVED);
    }
}

static void synch_size(wsp ws, int neww, int newh)
{
    if ((ws->width != neww) || (ws->height != newh)) {
        ws->width = neww;
        ws->height = newh;
        resizepixmap(findwbp(ws));
        qeventcode(ws, WINDOWRESIZED);
    }
}

static void handle_move(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    /* lp gives the position of the drawable area. */
    synch_pos(ws, GET_X_LPARAM(lp), GET_Y_LPARAM(lp));
}

static void handle_size(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    switch (wp) {
        case SIZE_MINIMIZED: {
            synch_state(ws, IconicCanvas);
            return;
        }
        case SIZE_MAXIMIZED: {
            synch_state(ws, MaximizedCanvas);
            break;
        }
        case SIZE_RESTORED: {
            synch_state(ws, NormalCanvas);
            break;
        }
    }
    synch_size(ws, LOWORD(lp), HIWORD(lp));
}

static void handle_showwindow(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    if (wp == 0)
        synch_state(ws, WithdrawnCanvas);
    else if (ws->state != PopupCanvas)
        synch_state(ws, NormalCanvas);
}

static void synch_state(wsp ws, int new_state)
{
    if (ws->state != new_state) {
        ws->state = new_state;
        if (new_state == NormalCanvas || new_state == MaximizedCanvas)
            note_skip(ws);
        qeventcode(ws, WINDOWSTATE);
    }
}

static void show_keystate(char *name, int k)
{
    SHORT s = GetKeyState(k);
    dbg("\t%s %s %s\n", name, (s < 0) ? "Down":"Up", (s > 0) ? "Toggled":"");
}

static void show_keyevent(UINT msg, WPARAM wp, LPARAM lp)
{
    char *s;
    switch(msg) {
        case WM_KEYUP:
            s = "WM_KEYUP";
            break;
        case WM_SYSKEYUP:
            s = "WM_SYSKEYUP";
            break;
        case WM_CHAR:
            s = "WM_CHAR";
            break;
        case WM_SYSCHAR:
            s = "WM_SYSCHAR";
            break;
        case WM_KEYDOWN:
            s = "WM_KEYDOWN";
            break;
        case WM_SYSKEYDOWN:
            s = "WM_SYSKEYDOWN";
            break;
        default:
            syserr("Unexpected msg value");
    }
    dbg("%s(%d) wp=%d\n", s, msg, (int)wp);
    dbg("\trepeat count=%d\n", lp&0xffff);
    lp >>= 15;
    dbg("\tscan code=%d\n", lp&0xff);
    lp >>= 8;
    dbg("\textended=%d\n", lp&0x01);
    lp >>= 1;
    lp >>= 4;  /* reserved */
    dbg("\tcontext code=%d\n", lp&0x01);
    lp >>= 1;
    dbg("\tprevious key state=%d\n", lp&0x01);
    lp >>= 1;
    dbg("\ttransition state=%d\n", lp&0x01);

    show_keystate("VK_LSHIFT",VK_LSHIFT);
    show_keystate("VK_RSHIFT",VK_RSHIFT);  
    show_keystate("VK_LCONTROL",VK_LCONTROL);
    show_keystate("VK_RCONTROL",VK_RCONTROL);
    show_keystate("VK_LMENU",VK_LMENU);
    show_keystate("VK_RMENU",VK_RMENU);
}

static void handle_keypress(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    DWORD dw;
    LONG t;
    int fl;
    POINT p;
    tended struct descrip curr;

    if (key_debug) show_keyevent(msg, wp, lp);
    switch(msg) {
        case WM_CHAR:
        case WM_SYSCHAR:
            if (wp < 256)
                MakeStr(&allchars[wp], 1, &curr);
            else
                MakeDesc(D_Ucs, make_one_char_ucs_block(wp), &curr);
            break;
        case WM_KEYUP:
        case WM_SYSKEYUP:
        case WM_KEYDOWN:
        case WM_SYSKEYDOWN:
            if (wp == VK_DELETE)
                MakeStr(&allchars[127], 1, &curr);
            else 
                MakeInt(wp, &curr);
            break;
        default:
            syserr("Unexpected msg value");
    }

   /* Mouse location in SCREEN coordinates; convert to client */
    dw = GetMessagePos();
    p.x = GET_X_LPARAM(dw);
    p.y = GET_Y_LPARAM(dw);
    ScreenToClient(ws->win, &p);

    t = GetMessageTime();

    fl = 0;
    if (GetKeyState(VK_CONTROL) < 0)
        fl |= MOD_CTRL;
    if (GetKeyState(VK_SHIFT) < 0)
        fl |= MOD_SHIFT;
    if (GetKeyState(VK_LMENU) < 0)
        fl |= MOD_META;
    if (GetKeyState(VK_RMENU) < 0) {
        fl |= MOD_META5;
        fl &= ~MOD_CTRL;
    }
    if (msg == WM_KEYUP || msg == WM_SYSKEYUP)
        fl |= MOD_RELEASE;
    qevent(ws, &curr, p.x, p.y, t, fl);
}

static void handle_mouse_wheel(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    LONG t;
    POINT p;
    int state, dir, num, delta, fl;

    if (mouse_debug) dbg("handle_mouse_wheel(%x)\n", ws->win);

    /* Wheel events aren't redirected to the captured window, so if a grab is
     * in progress they have to be redirected manually. 
     */
    if (grabwin)
        ws = grabwin;

    state = fl = 0;

    if (MK_LBUTTON & wp) state |= 1;
    if (MK_MBUTTON & wp) state |= 2;
    if (MK_RBUTTON & wp) state |= 4;

    /* Unlike normal mouse events, the co-ordinates are absolute, so
     * convert to client co-ordinates.
     */
    p.x = GET_X_LPARAM(lp);
    p.y = GET_Y_LPARAM(lp);
    ScreenToClient(ws->win, &p);

    t = GetMessageTime();

    if (MK_CONTROL & wp)
        fl |= MOD_CTRL;
    if (MK_SHIFT & wp)
        fl |= MOD_SHIFT;

    delta = GET_WHEEL_DELTA_WPARAM(wp);
    dir = (delta > 0) ? 8 : 16;
    num = Abs(delta) / WHEEL_DELTA;

    /*
     * We only get one MS event for a wheel movement, so call
     * qmouseevents twice for each increment, once with the button 4 or
     * 5 going down and again with it coming up.  This generates one
     * icon event, on the second qmouseevents call.
     */
    while (num--) {
        qmouseevents(ws, state | dir, p.x, p.y, t, fl);
        qmouseevents(ws, state, p.x, p.y, t, fl);
    }
}

static void dbg(char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    fflush(stderr);
}

static void capture_mouse(wsp ws)
{
    if (mouse_debug) dbg("capture_mouse(%x) capturecount=%d\n", ws->win, ws->capturecount);
    if (ws->capturecount == 0) {
        ws->savedcapture = SetCapture(ws->win);
        if (mouse_debug) dbg("SetCapture, savedcapture=%x ourselves=%x\n", ws->savedcapture, ws->win);
    }
    ++ws->capturecount;
    if (mouse_debug) dbg("now capturecount=%d\n", ws->capturecount);
}

static void uncapture_mouse(wsp ws)
{
    if (mouse_debug) dbg("uncapture_mouse(%x) capturecount=%d\n", ws->win, ws->capturecount);
    if (ws->capturecount > 0) {
        --ws->capturecount;
        if (ws->capturecount == 0) {
            if (mouse_debug) dbg("SetCapture to %x\n", ws->savedcapture);
            /* This will in fact now call handle_capture_changed() */
            SetCapture(ws->savedcapture);
            ws->savedcapture = 0;
        }
    }
    if (mouse_debug) dbg("now capturecount=%d\n", ws->capturecount);
}

/*
 * This may be called either when we release in uncapture_mouse above,
 * or externally.  In either case, set the count and grab to zero.
 * Some calls to uncapture_mouse() may follow, and do nothing.
 */
static void handle_capture_changed(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    if (mouse_debug) dbg("handle_capture_changed(%x), resetting capturecount to 0\n", ws->win);
    ws->savedcapture = 0;
    ws->capturecount = 0;
}

static void track_mouse(wsp ws)
{
    TRACKMOUSEEVENT tme;
    tme.cbSize = sizeof(TRACKMOUSEEVENT);
    tme.dwFlags = TME_LEAVE;
    tme.hwndTrack = ws->win;
    TrackMouseEvent(&tme);
    ws->trackingmouse = 1;
}

static void handle_mouse_leave(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    LONG t;
    struct descrip d;
    if (mouse_debug) dbg("handle_mouse_leave(%x)\n", ws->win);
    t = GetMessageTime();
    MakeInt(MOUSEEXITED, &d);
    qevent(ws, &d, 0, 0, t, 0);
    ws->trackingmouse = 0;
}

static void handle_mouse_enter(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    LONG t;
    int x, y;
    struct descrip d;
    if (mouse_debug) dbg("handle_mouse_enter(%x)\n", ws->win);
    x = GET_X_LPARAM(lp);
    y = GET_Y_LPARAM(lp);
    t = GetMessageTime();
    MakeInt(MOUSEENTERED, &d);
    qevent(ws, &d, x, y, t, 0);
}

static void handle_mouse_move(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    int x, y;
    x = GET_X_LPARAM(lp);
    y = GET_Y_LPARAM(lp);
    if (mouse_debug) dbg("handle_mouse_move(%x) skipped=%d\n", ws->win,
                                    (x == ws->skipx && y == ws->skipy));
    if (!ws->trackingmouse) {
        handle_mouse_enter(ws, msg, wp, lp);
        track_mouse(ws);
        synch_cursor(ws);
    }
    if (x != ws->skipx || y != ws->skipy) {
        handle_mouse(ws, msg, wp, lp);
        ws->skipx = x;
        ws->skipy = y;
    }
}

static void handle_mouse_up(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    if (mouse_debug) dbg("handle_mouse_up(%x)\n", ws->win);
    uncapture_mouse(ws);
    handle_mouse(ws, msg, wp, lp);
}

static void handle_mouse_down(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    if (mouse_debug) dbg("handle_mouse_down(%x)\n", ws->win);
    capture_mouse(ws);
    handle_mouse(ws, msg, wp, lp);
}

static void handle_mouse(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    LONG t;
    int x, y, state, fl;

    state = fl = 0;

    if (MK_LBUTTON & wp) state |= 1;
    if (MK_MBUTTON & wp) state |= 2;
    if (MK_RBUTTON & wp) state |= 4;

    x = GET_X_LPARAM(lp);
    y = GET_Y_LPARAM(lp);
    t = GetMessageTime();

    if (MK_CONTROL & wp)
        fl |= MOD_CTRL;
    if (MK_SHIFT & wp)
        fl |= MOD_SHIFT;

    qmouseevents(ws, state, x, y, t, fl);
}

static void handle_paint(wsp ws, UINT msg, WPARAM wp, LPARAM lp)
{
    if (!ws->holding)
        gb_do_paint(ws->win, ws->pix);
}

LRESULT_CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    wsp ws;
    ws = wsp_for_hwnd(hwnd);
    if (ws) {
        switch(msg) {
            case WM_PAINT:
                handle_paint(ws, msg, wp, lp);
                return 0;
            case WM_MOUSEMOVE:
                handle_mouse_move(ws, msg, wp, lp);
                return 0;
            case WM_MOUSELEAVE:
                handle_mouse_leave(ws, msg, wp, lp);
                return 0;
            case WM_MOUSEWHEEL:
                handle_mouse_wheel(ws, msg, wp, lp);
                return 0;
            case WM_CAPTURECHANGED:
                handle_capture_changed(ws, msg, wp, lp);
                return 0;
            case WM_LBUTTONDBLCLK: 
            case WM_RBUTTONDBLCLK: 
            case WM_MBUTTONDBLCLK: 
            case WM_LBUTTONDOWN: 
            case WM_RBUTTONDOWN:
            case WM_MBUTTONDOWN:
                handle_mouse_down(ws, msg, wp, lp);
                return 0;
            case WM_LBUTTONUP:
            case WM_RBUTTONUP:
            case WM_MBUTTONUP:
                handle_mouse_up(ws, msg, wp, lp);
                return 0;
            case WM_KEYDOWN:
            case WM_SYSKEYDOWN:
            case WM_CHAR:
            case WM_SYSCHAR:
            case WM_KEYUP:
            case WM_SYSKEYUP:
                handle_keypress(ws, msg, wp, lp);
                return 0;
            case WM_SIZE:
                handle_size(ws, msg, wp, lp);
                return 0;
            case WM_MOVE:
                handle_move(ws, msg, wp, lp);
                return 0;
            case WM_GETMINMAXINFO:
                handle_getminmaxinfo(ws, msg, wp, lp);
                return 0;
            case WM_SHOWWINDOW:
                handle_showwindow(ws, msg, wp, lp);
                return 0;
            case WM_CLOSE:
                qeventcode(ws, WINDOWCLOSED);
                return 0;
        }
    }
    return DefWindowProcW(hwnd, msg, wp, lp);
}

void pollevent(wbp w)
{
    MSG m;
    while (PeekMessage(&m, NULL, 0, 0, PM_REMOVE)) {
        TranslateMessage(&m);
        DispatchMessage(&m);
    }
}

int ownselection(wbp w, char *selection)
{
    wsp ws = w->window;
    tended struct descrip tmp;

    CheckUnhidden(ws);

    /* Ignore anything other than CLIPBOARD selections. */
    if (strcmp(selection, "CLIPBOARD") == 0) {
        MakeInt(SELECTIONREQUEST, &tmp);
        list_put(&ws->listp, &tmp);
        list_put(&ws->listp, &zerodesc);/* req id */
        LitStr("none", &tmp);           /* property */
        list_put(&ws->listp, &tmp);
        cstr2string(selection, &tmp);   /* selection */
        list_put(&ws->listp, &tmp);
        LitStr("UTF8_STRING", &tmp);    /* type */
        list_put(&ws->listp, &tmp);
        list_put(&ws->listp, &zerodesc); /* time */
    }
    return Succeeded;
}

int requestselection(wbp w, char *selection, char *target)
{
    wsp ws = w->window;
    tended struct descrip tmp, res;

    CheckUnhidden(ws);
    res = nulldesc;
    if (strcmp(selection, "CLIPBOARD") == 0) {
        if (strcmp(target, "TARGETS") == 0)
            LitStr("UTF8_STRING\n", &res);
        else if (strcmp(target, "UTF8_STRING") == 0) {
            HANDLE hg;
            char *phg;
            if (!OpenClipboard(NULL)) {
                win32error2why();
                return Failed;
            }
            hg = GetClipboardData(CF_UNICODETEXT);
            if (hg) {
                phg = (char *)GlobalLock(hg);
                wchar_to_ucs((WCHAR *)phg, &res);
                GlobalUnlock(hg);
            }
            CloseClipboard();
        }
    }

    MakeInt(SELECTIONRESPONSE, &tmp);
    list_put(&ws->listp, &tmp);
    cstr2string(selection, &tmp);   /* selection */
    list_put(&ws->listp, &tmp);
    cstr2string(target, &tmp);      /* target */
    list_put(&ws->listp, &tmp);
    list_put(&ws->listp, &res);

    return Succeeded;
}

int sendselectionresponse(wbp w, word requestor, char *property, 
                          char *selection, char *target, word time, dptr data)
{
    wsp ws = w->window;
    HGLOBAL hg;
    char *phg;
    SIZE_T nbytes;
    WCHAR *tmp;
    word tmplen;

    CheckUnhidden(ws);

    /* data is &null if the selection doesn't support what we asked for (UTF8_STRING) */
    if (is:null(*data))
        return Succeeded;

    if (!cnv:ucs(*data, *data))
        ReturnErrVal(128, *data, Error);

    if (!OpenClipboard(NULL)) {
        win32error2why();
        return Failed;
    }

    tmp = ucs_to_wchar(data, 1, &tmplen);
    EmptyClipboard();
    nbytes = tmplen * sizeof(WCHAR);
    MemProtect(hg = GlobalAlloc(GMEM_DDESHARE, nbytes));
    phg = (char *)GlobalLock(hg);
    memcpy(phg, tmp, nbytes);
    GlobalUnlock(hg);
    SetClipboardData(CF_UNICODETEXT, hg);
    CloseClipboard();
    free(tmp);
    return Succeeded;
}

static void close_screen_win(wsp ws)
{
    if (ws->win) {
        DestroyWindow(ws->win);
        ws->win = 0;
        ws->x = ws->y = -INT_MAX;
        ws->trackingmouse = ws->capturecount = 0;
        ws->state = HiddenCanvas;
        GUnlink4(ws, vwstates, vnext, vprevious);
    }
}

static wsp wsp_for_hwnd(HWND hwnd)
{
    wsp ws;
    for (ws = vwstates; ws; ws = ws->vnext) {
        if (ws->win == hwnd) 
            return ws;
    }
    return 0;
}

static void init_geom(wsp ws)
{
    POINT p;
    RECT r;
    p.x = p.y = 0;
    ClientToScreen(ws->win, &p);
    synch_pos(ws, p.x, p.y);
    GetClientRect(ws->win, &r);
    synch_size(ws, r.right - r.left, r.bottom - r.top);
}

static void note_skip(wsp ws)
{
    POINT p;
    GetCursorPos(&p);
    ScreenToClient(ws->win, &p);
    ws->skipx = p.x;
    ws->skipy = p.y;
}

static void open_screen_win(wsp ws)
{
    switch (ws->state) {
        case PopupCanvas: {
            ws->win = CreateWindowExW(WS_EX_TOPMOST | WS_EX_TOOLWINDOW,
                                      L"oix", 
                                      NULL,
                                      WS_CHILD,
                                      ws->reqx == -INT_MAX ? 0 : ws->reqx, 
                                      ws->reqy == -INT_MAX ? 0 : ws->reqy,
                                      ws->width,
                                      ws->height,
                                      GetDesktopWindow(),
                                      NULL, NULL, NULL); 
            SetWindowPos(ws->win, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
            break;
        } 
        default: {
            HWND parent;
            if (ws->transientfor)
                parent = ws->transientfor->win;
            else
                parent = NULL;
            ws->win = CreateWindowExW(0,
                                      L"oix", 
                                      NULL,
                                      WS_OVERLAPPEDWINDOW,
                                      ws->reqx == -INT_MAX ? CW_USEDEFAULT : ws->reqx, 
                                      ws->reqy == -INT_MAX ? CW_USEDEFAULT : ws->reqy,
                                      ws->width + BORDER_WIDTH,
                                      ws->height + BORDER_HEIGHT,
                                      parent,
                                      NULL, NULL, NULL);
            apply_windowlabel(ws);
        }
    }

    switch (ws->state) {
        case WithdrawnCanvas: {
            ShowWindow(ws->win, SW_HIDE);
            break;
        }
        case IconicCanvas: {
            ShowWindow(ws->win, SW_MINIMIZE);
            break;
        }
        case MaximizedCanvas: {
            ShowWindow(ws->win, SW_MAXIMIZE);
            break;
        }
        case NormalCanvas:
        case PopupCanvas: {
            ShowWindow(ws->win, SW_SHOWNORMAL);
            break;
        }
    }

    note_skip(ws);
    init_geom(ws);

    GLink4(ws, vwstates, vnext, vprevious);
}

int setcanvas(wbp w, char *s)
{
    wsp ws = w->window;
    HWND stdwin = ws->win;
    stringint *e;

    e = stringint_lookup(canvastypes, s);
    if (!e)
        return Failed;

    if (e->i == ws->state)
        return Succeeded;

    /*
     * If we're presently hidden, just open the visible window.
     */
    if (!ws->win) {
        if (e->i != HiddenCanvas) {
            ws->state = e->i;
            /* We should now get a WM_PAINT message which will copy
             * the pix to the new window. */
            open_screen_win(ws);
        }
        return Succeeded;
    }

    /*
     * More complex cases, with the window already unhidden.
     */
    switch (e->i) {
        case HiddenCanvas: {
            close_screen_win(ws);
            break;
        }
        case IconicCanvas: {
            if (ws->state == PopupCanvas)
                return Failed;
            ShowWindow(ws->win, SW_MINIMIZE);
            break;
        }
        case WithdrawnCanvas: {
            if (ws->state == PopupCanvas)
                return Failed;
            ShowWindow(ws->win, SW_HIDE);
            break;
        }
        case MaximizedCanvas: {
            if (ws->state == PopupCanvas)
                return Failed;
            ShowWindow(ws->win, SW_MAXIMIZE);
            break;
        }
        case NormalCanvas: {
            if (ws->state == PopupCanvas)
                return Failed;
            ShowWindow(ws->win, SW_SHOWNORMAL);
            break;
        }
        case PopupCanvas:
            return Failed;
    }
    return Succeeded;
}

int setwindowlabel(wbp w, dptr val)
{
    wsp ws = w->window;
    ws->windowlabel = *val;
    if (ws->win)
        apply_windowlabel(ws);
    return Succeeded;
}

static gb_Font *mkfont(char *s)
{
    int flags;
    double size;
    char family[MAXFONTWORD];
    if (!parsefont(s, family, &flags, &size))
        return 0;
    return gb_find_Font(family, flags, size);
}

static wfp load_font(char *s)
{
    wfp rv;
    int i;
    gb_Font *f;

    /*
     * See if the font is already loaded.
     */
    i = hasher(hashcstr(s), fonts);
    for(rv = fonts[i]; rv; rv = rv->next) {
        if (!strcmp(s, rv->name))
            return rv;
    }

    f = mkfont(s);
    if (!f)
        return 0;

    rv = safe_zalloc(sizeof(struct _wfont));
    rv->name = salloc(s);
    gb_get_metrics(dummy_hdc, f, &rv->ascent, &rv->descent, &rv->maxwidth);
    /*dbg("ascent=%d descent=%d maxwidth=%d\n", rv->ascent,rv->descent,rv->maxwidth);*/
    rv->font = f;
    rv->next = fonts[i];
    fonts[i] = rv;
    return rv;
}

/*
 * Set the window's font by name.
 */
int setfont(wbp w, char *s)
{
    wfp f = load_font(s);
    if (!f)
        return Failed;
    w->context->font = f;
    return Succeeded;
}

int lowerwindow(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    SetWindowPos(ws->win, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
    return Succeeded;
}

int raisewindow(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    SetWindowPos(ws->win, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
    return Succeeded;
}

int setlinestyle(wbp w, char *val)
{
    stringint *e;
    wcp wc = w->context;
    e = stringint_lookup(linestyles, val);
    if (!e)
        return Failed;
    wc->linestyle = e;
    return Succeeded;
}

int setlinewidth(wbp w, double linewid)
{
    wcp wc = w->context;
    wc->linewidth = linewid;
    return Succeeded;
}

double getlinewidth(wbp w)
{
    return w->context->linewidth;
}

int getdepth(wbp w, int *res)
{
    int i, j;
    i = GetDeviceCaps(dummy_hdc, BITSPIXEL);
    j = GetDeviceCaps(dummy_hdc, PLANES);
    *res = i * j;
    return Succeeded;
}

/*
 * Set the context's foreground color
 */
int setfg(wbp w, char *val)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(val, &r, &g, &b, &a))
        return Failed;
    unlink_sharedcolor(wc->fg);
    wc->fg = new_sharedcolor(val, r, g, b, a);
    return Succeeded;
}

char *getfg(wbp w)
{
    return w->context->fg->name;
}

/*
 * Set the window context's background color
 */
int setbg(wbp w, char *val)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(val, &r, &g, &b, &a))
        return Failed;
    unlink_sharedcolor(wc->bg);
    wc->bg = new_sharedcolor(val, r, g, b, a);
    return Succeeded;
}

char *getbg(wbp w)
{
    return w->context->bg->name;
}

int setpointer(wbp w, char *val)
{
    struct wcursor *c;
    wsp ws = w->window;
    c = lookup_wcursor(val);
    if (!c)
        return Failed;
    ws->cursor = c;
    if (ws->win)
        synch_cursor(ws);
    return Succeeded;
}

int setdrawop(wbp w, char *val)
{
    wcp wc = w->context;
    stringint *e = stringint_lookup(drawops, val);
    if (!e)
        return Failed;
    wc->drawop = e;
    return Succeeded;
}

char *getlinestyle(wbp w)
{
    return w->context->linestyle->s;
}

char *getpointer(wbp w)
{
    return w->window->cursor->name;
}

char *getdisplay(wbp w)
{
    return "MS Windows";
}

char *getdrawop(wbp w)
{
    return w->context->drawop->s;
}

char *getcanvas(wbp w)
{
    char *v = stringint_int2str(canvastypes, w->window->state);
    if (!v)
        syserr("Invalid value of state");
    return v;
}

/*
 * erase an area
 */
void erasearea(wbp w, int x, int y, int width, int height)
{
    gb_Draw d;
    mk_Draw(w, &d);
    gb_erasearea(&d, x, y, width, height);
}

/*
 * copy an area
 */
int copyarea(wbp w, int x, int y, int width, int height, wbp w2, int x2, int y2, wbp w3, int x3, int y3)
{
    gb_Draw d;
    mk_Draw(w2, &d);
    gb_copyarea(w->window->pix, x, y, width, height, &d, x2, y2);
    return Succeeded;
}

void captureimgdata(wbp w, int x, int y, struct imgdata *imd)
{
    wsp ws = w->window;
    int i, j;
    gb_Color *p;
    imd->data = safe_malloc(imd->width * imd->height * sizeof(gb_Color));
    p = (gb_Color *)imd->data;
    for(i = y; i < y + imd->height; i++)
        for(j = x; j < x + imd->width; j++)
            *p++ = gb_getpixel(ws->pix, j, i);
    imd->format = &imgdataformat_MSBGRA32;
}

void drawimgdata(wbp w, int x, int y, struct imgdata *imd)
{
    gb_Bitmap *bm;
    gb_Draw d;
    mk_Draw(w, &d);
    bm = imgdata_to_bitmap(imd);
    gb_draw_Bitmap(&d, x, y, bm);
    gb_free_Bitmap(bm);

}

struct imgdataformat *getimgdataformat(wbp w)
{
    return &imgdataformat_MSBGRA32;
}

int getdisplaysize(wbp w, int *width, int *height)
{
    *width = GetDeviceCaps(dummy_hdc, HORZRES);
    *height = GetDeviceCaps(dummy_hdc, VERTRES);
    return Succeeded;
}

int getdisplaysizemm(wbp w, int *width, int *height)
{
    *width = GetDeviceCaps(dummy_hdc, HORZSIZE);
    *height = GetDeviceCaps(dummy_hdc, VERTSIZE);
    return Succeeded;
}

int querypointer(wbp w, int *x, int *y)
{
    wsp ws = w->window;
    POINT p;
    CheckUnhidden(ws);
    GetCursorPos(&p);
    ScreenToClient(ws->win, &p);
    *x = p.x;
    *y = p.y;
    return Succeeded;
}

int queryrootpointer(wbp w, int *x, int *y)
{
    POINT p;
    GetCursorPos(&p);
    *x = p.x;
    *y = p.y;
    return Succeeded;
}

void drawlines(wbp w, struct point *points, int npoints)
{
    gb_Draw d;
    int x, y, width, height, adj;
    mk_Draw(w, &d);
    points_extent(points, npoints, &x, &y, &width, &height);
    adj = d.linewidth;
    gb_drawlines(&d, points, npoints, x - adj, y - adj, width + 2 * adj, height + 2 * adj);
}

void drawarc(wbp wb, double cx, double cy, double rx, double ry, double angle1, double angle2)
{
    gb_Draw d;
    mk_Draw(wb, &d);
    gb_drawarc(&d, cx, cy, rx, ry, angle1, angle2);
}

void fillarc(wbp wb, double cx, double cy, double rx, double ry, double angle1, double angle2)
{
    gb_Draw d;
    mk_Draw(wb, &d);
    gb_fillarc(&d, cx, cy, rx, ry, angle1, angle2);
}

void filltrapezoids(wbp w, struct trapezoid *traps, int ntraps)
{
    int i;
    for (i = 0; i < ntraps; ++i) {
        struct point p[4];
        p[0].x = traps[i].x1; p[0].y = traps[i].top;
        p[1].x = traps[i].x2; p[1].y = traps[i].top;
        p[2].x = traps[i].x4; p[2].y = traps[i].bottom;
        p[3].x = traps[i].x3; p[3].y = traps[i].bottom;
        fillpolygon(w, p, 4);
    }
}

void filltriangles(wbp w, struct triangle *tris, int ntris)
{
    int i;
    for (i = 0; i < ntris; ++i) {
        struct point p[3];
        p[0].x = tris[i].p1.x; p[0].y = tris[i].p1.y;
        p[1].x = tris[i].p2.x; p[1].y = tris[i].p2.y;
        p[2].x = tris[i].p3.x; p[2].y = tris[i].p3.y;
        fillpolygon(w, p, 3);
    }
}

void fillpolygon(wbp w, struct point *points, int npoints)
{
    gb_Draw d;
    int x, y, width, height, adj;
    mk_Draw(w, &d);
    points_extent(points, npoints, &x, &y, &width, &height);
    adj = 4;
    gb_fillpolygon(&d, points, npoints, x - adj, y - adj, width + 2 * adj, height + 2 * adj);
}

void fillrectangle(wbp wb, int x, int y, int width, int height)
{
    gb_Draw d;
    mk_Draw(wb, &d);
    gb_fillrectangle(&d, x, y, width, height);
}

void drawrectangle(wbp wb, int x, int y, int width, int height, int thick)
{
    gb_Draw d;
    mk_Draw(wb, &d);
    gb_drawrectangle(&d, x, y, width, height, thick);
}

static wcp alccontext(wbp w)
{
    wcp wc;
    GAlloc(wc, _wcontext);
    wc->fg = link_sharedcolor(black);
    wc->bg = link_sharedcolor(white);
    wc->drawop = stringint_lookup(drawops, "over");
    wc->linestyle = stringint_lookup(linestyles, "square");
    wc->linewidth = 1.0;
    wc->font = default_font;
    wc->leading = defaultleading;
    wc->clipx = wc->clipy = 0;
    wc->clipw = wc->cliph = -1;
    return wc;
}

/*
 * allocate a context, cloning attributes from an existing context
 */
static wcp clonecontext(wcp src)
{
    wcp wc;

    GAlloc(wc, _wcontext);

    wc->clipx = src->clipx;
    wc->clipy = src->clipy;
    wc->clipw = src->clipw;
    wc->cliph = src->cliph;
    wc->dx = src->dx;
    wc->dy = src->dy;
    wc->fg = link_sharedcolor(src->fg);
    wc->bg = link_sharedcolor(src->bg);
    if (src->pattern)
        wc->pattern = link_sharedbitmap(src->pattern);
    wc->drawop = src->drawop;
    wc->linewidth = src->linewidth;
    wc->linestyle = src->linestyle;
    wc->font = src->font;
    return wc;
}

/*
 * free a window state
 */
static void freewindow(wsp ws)
{
    ws->refcount--;
    if(ws->refcount == 0) {
        close_screen_win(ws);
        gb_free_Bitmap(ws->pix);
        del_gc_global(&ws->listp);
        del_gc_global(&ws->windowlabel);
        if (ws->transientfor)
            freewindow(ws->transientfor);
        if (ws == grabwin)
            grabwin = 0;
        free(ws);
    }
}

/*
 * free a window context
 */
static void freecontext(wcp wc)
{
    wc->refcount--;
    if(wc->refcount == 0) {
        if (wc->pattern)
            unlink_sharedbitmap(wc->pattern);
        unlink_sharedcolor(wc->fg);
        unlink_sharedcolor(wc->bg);
        free(wc);
    }
}

int walert(wbp w, int volume)
{
    MessageBeep(0);
    return Succeeded;
}

int setpattern(wbp w, struct imgdata *imd)
{
    wcp wc = w->context;
    if (wc->pattern)
        unlink_sharedbitmap(wc->pattern);
    if (imd)
        wc->pattern = new_sharedbitmap(imd);
    else
        wc->pattern = 0;
    return Succeeded;
}

static int get_outer_width(wsp ws)
{
    if (ws->state == PopupCanvas)
        return ws->width;
    else
        return ws->width + BORDER_WIDTH;
}

static int get_outer_height(wsp ws)
{
    if (ws->state == PopupCanvas)
        return ws->height;
    else
        return ws->height + BORDER_HEIGHT;
}

void doconfig(wbp w, int status)
{
    wsp ws = w->window;
    wcp wc = w->context;
    if (status & (C_POS | C_SIZE | C_MINSIZE | C_MAXSIZE | C_RESIZE)) {
        if (ws->win) {
            switch (status & (C_POS|C_SIZE)) {
                case C_POS|C_SIZE: {
                    SetWindowPos(ws->win, ws->win, ws->reqx, ws->reqy,
                                 get_outer_width(ws), get_outer_height(ws),
                                 SWP_NOZORDER|SWP_NOACTIVATE);
                    break;
                }
                case C_SIZE: {
                    SetWindowPos(ws->win, ws->win, 0, 0,
                                 get_outer_width(ws), get_outer_height(ws),
                                 SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
                    break;
                }
                case C_POS: {
                    SetWindowPos(ws->win, ws->win,
                                 ws->reqx,
                                 ws->reqy,
                                 0, 0, SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
                    break;
                }
            }
            if (status & C_SIZE) {
                RECT r;
                /*
                 * Within a call to SetWindowPos doing a resize, DOS
                 * will synchronously send a WM_GETMINMAXINFO, and
                 * then set the size and (if the size has changed)
                 * send a WM_SIZE.  A minor problem occurs if the
                 * window size is equal to the maximum size, and we
                 * request a change to a size greater than the
                 * maximum.  Since the actual window size does not
                 * change, there is no WM_SIZE message, and
                 * ws->width/height remain inconsistent.  Therefore we
                 * synch the size here to ensure it is correct.
                 */
                GetClientRect(ws->win, &r);
                synch_size(ws, r.right - r.left, r.bottom - r.top);
            }
        }
    }
    if (status & C_SIZE)
        resizepixmap(w);
}

int grabpointer(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    capture_mouse(ws);
    grabwin = ws;
    note_skip(ws);
    return Succeeded;
}

int ungrabpointer(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    uncapture_mouse(ws);
    grabwin = 0;
    return Succeeded;
}

static void resizepixmap(wbp w)
{
    gb_Bitmap *np;
    wsp ws = w->window;
    wcp wc = w->context;
    if (ws->pixwidth == ws->width && ws->pixheight == ws->height)
        return;
    ws->pixwidth = ws->width;
    ws->pixheight = ws->height;
    np = gb_create_Bitmap(ws->pixwidth, ws->pixheight, wc->bg->color, ws->pix);
    gb_free_Bitmap(ws->pix);
    ws->pix = np;
}

int textwidth(wbp w, dptr str)
{
    float f;
    WCHAR *mbs;
    word len;
    gb_Draw d;
    mk_Draw(w, &d);
    if (is:string(*str))
        mbs = string_to_wchar(str, 0, &len);
    else
        mbs = ucs_to_wchar(str, 0, &len);
    f = gb_textwidth(&d, mbs, len);
    free(mbs);
    return (int)ceilf(f);
}

void drawstring(wbp w, int x, int y, dptr str)
{
    wcp wc = w->context;
    WCHAR *mbs;
    word len;
    gb_Draw d;
    mk_Draw(w, &d);
    if (is:string(*str))
        mbs = string_to_wchar(str, 0, &len);
    else
        mbs = ucs_to_wchar(str, 0, &len);
    gb_drawstring(&d, x, y, mbs, len);
    free(mbs);
}

int warppointer(wbp w, int x, int y)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    SetCursorPos(ws->x + x, ws->y + y);
    return Succeeded;
}

int readimagefileimpl(char *filename, struct imgdata *imd) 
{
    gb_Bitmap *bm;
    bm = gb_load_Bitmap(filename);
    if (!bm)
        return NoCvt;
    bitmap_to_imgdata(bm, imd);
    gb_free_Bitmap(bm);
    return Succeeded;
}

int writeimagefileimpl(char *filename, struct imgdata *imd)
{
    return NoCvt;
}

int readimagedataimpl(dptr data, struct imgdata *imd)
{
    int rv;
    char *fn;
    if (!(is_png(data) || is_jpeg(data)))
        return NoCvt;
    fn = datatofile(data);
    if (!fn)
        return Failed;
    rv = readimagefileimpl(fn, imd);
    remove(fn);
    return rv;
}

int settransientfor(wbp w, wbp other)
{
    wsp ws = w->window;
    if (ws->win) {
        LitWhy("Can't set transient_for on an open window");
        return Failed;
    }
    if (other) {
        if (ws->transientfor)
            freewindow(ws->transientfor);
        ws->transientfor = linkwindow(other->window);
    } else {
        if (ws->transientfor)
            freewindow(ws->transientfor);
        ws->transientfor = 0;
    }
    return Succeeded;
}

int setwindowicon(wbp w, struct imgdata *imd)
{
    return Failed;
}

int grabkeyboard(wbp w)
{
    return Succeeded;
}

int ungrabkeyboard(wbp w)
{
    return Succeeded;
}

wbp clonewindow(wbp w)
{
    wbp w2;
    w2 = alcwbinding();
    w2->window = linkwindow(w->window);
    w2->context = clonecontext(w->context);
    return w2;
}

wbp couplewindows(wbp w1, wbp w2)
{
    wbp w3;
    w3 = alcwbinding();
    w3->window = linkwindow(w1->window);
    w3->context = linkcontext(w2->context);
    return w3;
}

static struct SharedColor *new_sharedcolor(char *name, int r, int g, int b, int a)
{
    struct SharedColor *res;
    GAlloc(res, SharedColor);
    res->name = salloc(name);
    res->color = gb_make_Color(a / 256, r / 256, g / 256, b / 256);
    return res;
}

static struct SharedColor *link_sharedcolor(struct SharedColor *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedcolor(struct SharedColor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        free(x->name);
        free(x);
    }
}

static struct SharedCursor *new_sharedcursor(HCURSOR cursor, int private)
{
    struct SharedCursor *res;
    GAlloc(res, SharedCursor);
    res->cursor = cursor;
    res->private = private;
    return res;
}

static struct SharedCursor *link_sharedcursor(struct SharedCursor *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedcursor(struct SharedCursor *x)
{
    --x->refcount;
    if (cursor_debug) dbg("unlink_sharedcursor %p refcount=%d\n", x, x->refcount);
    if (x->refcount == 0) {
        if (cursor_debug) dbg("freeing %p, cursor=%p private=%d\n", x, x->cursor, x->private);
        /* Only free cursors we created ourselves (with CreateIconIndirect) */
        if (x->private) {
            /* Is the cursor the last one used with SetCursor.  If so,
             * ensure it is unused by windows, by using SetCursor
             * again.
             */
            if (x->cursor == using_cursor) {
                if (cursor_debug) dbg("cursor is in use, clearing\n");
                SetCursor(null_cursor->cursor);
                using_cursor = 0;
            }
            if (cursor_debug) dbg("DestroyCursor(%p)\n", x->cursor);
            DestroyCursor(x->cursor);
        }
        free(x);
    }
}

static struct wcursor *lookup_wcursor(char *name)
{
    struct wcursor *rv;
    int i;
    i = hasher(hashcstr(name), cursors);
    for(rv = cursors[i]; rv; rv = rv->next) {
        if (!strcmp(name, rv->name))
            return rv;
    }
    return 0;
}

static struct wcursor *ensure_wcursor(char *name)
{
    struct wcursor *rv;
    int i;
    i = hasher(hashcstr(name), cursors);
    for(rv = cursors[i]; rv; rv = rv->next) {
        if (!strcmp(name, rv->name))
            return rv;
    }
    rv = safe_zalloc(sizeof(struct wcursor));
    rv->name = salloc(name);
    rv->next = cursors[i];
    cursors[i] = rv;
    return rv;
}

static void bitmap_to_imgdata(gb_Bitmap *bm, struct imgdata *imd)
{
    int i, j;
    UINT width, height;
    gb_Color *p;
    gb_get_Bitmap_size(bm, &width, &height);
    imd->format = &imgdataformat_MSBGRA32;
    imd->width = width;
    imd->height = height;
    imd->data = safe_malloc(imd->width * imd->height * sizeof(gb_Color));
    p = (gb_Color *)imd->data;
    for(j = 0; j < imd->height; j++) {
        for(i = 0; i < imd->width; i++)
            *p++ = gb_getpixel(bm, i, j);
    }
}

static gb_Bitmap *imgdata_to_bitmap(struct imgdata *imd)
{
    gb_Bitmap *bm;
    int i, j;
    bm = gb_create_empty_Bitmap(imd->width, imd->height);
    for(j = 0; j < imd->height; j++) {
        for(i = 0; i < imd->width; i++) {
            int r, g, b, a;
            imd->format->getpixel(imd, i, j, &r, &g, &b, &a);
            gb_setpixel(bm, i, j, a / 256, r / 256, g / 256, b / 256);
        }
    }
    return bm;
}

static struct SharedBitmap *new_sharedbitmap(struct imgdata *imd)
{
    struct SharedBitmap *res;
    GAlloc(res, SharedBitmap);
    res->bitmap = imgdata_to_bitmap(imd);
    return res;
}

static struct SharedBitmap *link_sharedbitmap(struct SharedBitmap *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedbitmap(struct SharedBitmap *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        gb_free_Bitmap(x->bitmap);
        free(x);
    }
}

int focuswindow(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    SetFocus(ws->win);
    return Succeeded;
}

static void synch_cursor(wsp ws)
{
    /* Only call SetCursor if the mouse is over this window. */
    if (ws->trackingmouse) {
        /* Keep track of what we set, in case we need to destroy this cursor. */
        using_cursor = ws->cursor->shared_cursor->cursor;
        SetCursor(using_cursor);
        if (cursor_debug) dbg("synch_cursor(%x) to %s, SetCursor(%p)\n", 
                              ws->win, ws->cursor->name, using_cursor);
    }
}

static void synch_cursors(struct wcursor *c)
{
    wsp x;
    if (cursor_debug) dbg("synch_cursors\n");
    for (x = vwstates; x; x = x->vnext) {
        if (x->cursor == c)
            synch_cursor(x);
    }
}

void hold(wbp w)
{
    wsp ws = w->window;
    ws->holding = 1;
    ws->holdx = ws->holdy = ws->holdwidth = ws->holdheight = 0;
}

void restore(wbp w)
{
    wsp ws = w->window;
    gb_Draw d;
    ws->holding = 0;
    mk_Draw(w, &d);
    d.clipx = d.clipy = 0;
    d.clipw = d.cliph = -1;
    gb_pix_to_win(&d,
                  ws->holdx, ws->holdy, ws->holdwidth, ws->holdheight);
}

int definepointer(wbp w, char *name, struct imgdata *imd, int x, int y)
{
    struct wcursor *rv;
    gb_Bitmap *bm;
    HICON icon, cursor;
    ICONINFO info;
    BOOL res;
    if (cursor_debug) dbg("definepointer %s %dx%d, hotspot %d,%d\n", name, imd->width,
                          imd->height, x, y);
    bm = imgdata_to_bitmap(imd);
    icon = gb_get_HICON(bm);
    gb_free_Bitmap(bm);
    if (!icon) {
        LitWhy("Failed to create HICON");
        return Failed;
    }
    res = GetIconInfo(icon, &info);
    DestroyIcon(icon);
    if (!res) {
        win32error2why();
        return Failed;
    }
    info.xHotspot = x;
    info.yHotspot = y;
    cursor = CreateIconIndirect(&info);
    DeleteObject(info.hbmMask);
    DeleteObject(info.hbmColor);
    if (!cursor) {
        win32error2why();
        return Failed;
    }
    rv = ensure_wcursor(name);
    if (rv->shared_cursor) {
        struct SharedCursor *tmp = rv->shared_cursor;
        rv->shared_cursor = new_sharedcursor(cursor, 1);
        synch_cursors(rv);
        unlink_sharedcursor(tmp);
    } else
        rv->shared_cursor = new_sharedcursor(cursor, 1);
    return Succeeded;
}

int copypointer(wbp w, char *dest, char *src)
{
    struct wcursor *sc, *dc;
    if (cursor_debug) dbg("copypointer %s %s\n", dest, src);
    sc = lookup_wcursor(src);
    if (!sc)
        return Failed;
    dc = ensure_wcursor(dest);
    if (sc != dc) {
        if (dc->shared_cursor) {
            struct SharedCursor *tmp = dc->shared_cursor;
            dc->shared_cursor = link_sharedcursor(sc->shared_cursor);
            synch_cursors(dc);
            unlink_sharedcursor(tmp);
        } else
            dc->shared_cursor = link_sharedcursor(sc->shared_cursor);
    }
    return Succeeded;
}

static wbp findwbp(wsp ws)
{
    wbp wb;
    for (wb = wbndngs; wb; wb = wb->next)
        if (wb->window == ws)
            return wb;
    syserr("Couldn't find wbp for wsp");
    return 0;  /* not reached */
}

static void setup_cursor(char *name, LPCTSTR cid)
{
    int i;
    struct wcursor *rv;
    i = hasher(hashcstr(name), cursors);
    rv = safe_zalloc(sizeof(struct wcursor));
    rv->name = name;
    if (cid)
        rv->shared_cursor = new_sharedcursor(LoadCursor(NULL, cid), 0);
    else
        rv->shared_cursor = link_sharedcursor(null_cursor);
    rv->next = cursors[i];
    cursors[i] = rv;
}

static void init_window_system(void)
{
    WNDCLASSEXW wc;
    RECT r;
    wc.cbSize =         sizeof(WNDCLASSEXW);
    wc.style =          CS_DBLCLKS;
    wc.lpfnWndProc =    WndProc;
    wc.cbClsExtra =     0;
    wc.cbWndExtra =     0;
    wc.hInstance =      GetModuleHandle(0);
    wc.hIcon =          LoadIcon(0, IDI_APPLICATION);
    wc.hCursor =        0;
    wc.hbrBackground =  GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =   0;
    wc.lpszClassName =  L"oix";
    wc.hIconSm =        LoadIcon(0, IDI_APPLICATION);
    RegisterClassExW(&wc);
    r.left = r.top = r.right = r.bottom = 0;
    AdjustWindowRect(&r, WS_OVERLAPPEDWINDOW, FALSE);
    BORDER_WIDTH = r.right - r.left;
    BORDER_HEIGHT = r.bottom - r.top;
    gb_initialize(ffatalerr);
    dummy_hdc = GetDC(0);
    black = new_sharedcolor("black", 0, 0, 0, 0xffff);
    white = new_sharedcolor("white", 0xffff,0xffff,0xffff, 0xffff);
    default_font = load_font(defaultfont);
    if (!default_font)
        ffatalerr("Couldn't load default font");
    setup_cursors();
}

static void setup_cursors()
{
    null_cursor = new_sharedcursor(LoadCursor(NULL, IDC_ARROW), 0);

    /* Windows ones */
    setup_cursor("help", IDC_HELP);
    setup_cursor("hand", IDC_HAND);
    setup_cursor("ibeam", IDC_IBEAM);
    setup_cursor("uparrow", IDC_UPARROW);
    setup_cursor("wait", IDC_WAIT);
    setup_cursor("starting", IDC_APPSTARTING);
    setup_cursor("sizeall", IDC_SIZEALL);
    setup_cursor("sizenesw", IDC_SIZENESW);
    setup_cursor("sizens", IDC_SIZENS);
    setup_cursor("sizenwse", IDC_SIZENWSE);
    setup_cursor("sizewe", IDC_SIZEWE);
    setup_cursor("no", IDC_NO);

    setup_cursor("X cursor", 0);
    setup_cursor("arrow", IDC_ARROW);
    setup_cursor("based arrow down", 0);
    setup_cursor("based arrow up", 0);
    setup_cursor("boat", 0);
    setup_cursor("bogosity", 0);
    copypointer(0, "bottom left corner", "sizenesw");
    copypointer(0, "bottom right corner", "sizenwse");
    setup_cursor("bottom side", 0);
    setup_cursor("bottom tee", 0);
    setup_cursor("box spiral", 0);
    setup_cursor("center ptr", 0);
    copypointer(0, "circle", "no");
    setup_cursor("clock", 0);
    setup_cursor("coffee mug", 0);
    setup_cursor("cross", IDC_CROSS);
    setup_cursor("cross reverse", 0);
    setup_cursor("crosshair", 0);
    setup_cursor("diamond cross", 0);
    setup_cursor("dot", 0);
    setup_cursor("dotbox", 0);
    copypointer(0, "double arrow", "sizens");
    setup_cursor("draft large", 0);
    setup_cursor("draft small", 0);
    setup_cursor("draped box", 0);
    setup_cursor("exchange", 0);
    copypointer(0, "fleur", "sizeall");
    setup_cursor("gobbler", 0);
    setup_cursor("gumby", IDC_SIZENESW);
    copypointer(0, "hand1", "hand");
    copypointer(0, "hand2", "hand");
    setup_cursor("heart", 0);
    setup_cursor("icon", 0);
    setup_cursor("iron cross", 0);
    setup_cursor("left ptr", 0);
    setup_cursor("left side", 0);
    setup_cursor("left tee", 0);
    setup_cursor("leftbutton", 0);
    setup_cursor("ll angle", 0);
    setup_cursor("lr angle", 0);
    setup_cursor("man", 0);
    setup_cursor("middlebutton", 0);
    setup_cursor("mouse", 0);
    setup_cursor("pencil", 0);
    setup_cursor("pirate", 0);
    setup_cursor("plus", 0);
    copypointer(0, "question arrow", "help");
    setup_cursor("right ptr", 0);
    setup_cursor("right side", 0);
    setup_cursor("right tee", 0);
    setup_cursor("rightbutton", 0);
    setup_cursor("rtl logo", 0);
    setup_cursor("sailboat", 0);
    setup_cursor("sb down arrow", 0);
    copypointer(0, "sb h double arrow", "sizewe");
    setup_cursor("sb left arrow", 0);
    setup_cursor("sb right arrow", 0);
    copypointer(0, "sb up arrow", "uparrow");
    copypointer(0, "sb v double arrow", "sizens");
    setup_cursor("shuttle", 0);
    setup_cursor("sizing", 0);
    setup_cursor("spider", 0);
    setup_cursor("spraycan", 0);
    setup_cursor("star", 0);
    setup_cursor("target", 0);
    setup_cursor("tcross", 0);
    setup_cursor("top left arrow", 0);
    copypointer(0, "top left corner", "sizenwse");
    copypointer(0, "top right corner", "sizenesw");
    setup_cursor("top side", 0);
    setup_cursor("top tee", 0);
    setup_cursor("trek", 0);
    setup_cursor("ul angle", 0);
    setup_cursor("umbrella", 0);
    setup_cursor("ur angle", 0);
    copypointer(0, "watch", "wait");
    copypointer(0, "xterm", "ibeam");
}

static void set_MSBGRA32(struct imgdata *imd, int x, int y, int r, int g, int b, int a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    *s++ = b / 256;
    *s++ = g / 256;
    *s++ = r / 256;
    *s++ = a / 256;
}

static void get_MSBGRA32(struct imgdata *imd, int x, int y, int *r, int *g, int *b, int *a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    *b = 257 * (*s++);
    *g = 257 * (*s++);
    *r = 257 * (*s++);
    *a = 257 * (*s++);
}

static struct imgdataformat imgdataformat_MSBGRA32 = {set_MSBGRA32,get_MSBGRA32,0,0,getlength_32,8,24,0,"MSBGRA32"};

void registerplatformimgdataformats()
{
    registerimgdataformat(&imgdataformat_MSBGRA32);
}
