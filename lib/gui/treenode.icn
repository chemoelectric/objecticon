#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

import util, ipl.pdco, ipl.lists

#
# This class represents a node in a {Tree} object.
#
class TreeNode()
   public 
      label,
      icon_paint,
      always_expandable_flag,
      depth,
      is_expanded_flag,
      children,
      draw_line,
      parent

   #
   # Traverse all the {TreeNode}s in this subtree, including this
   # {TreeNode}, in preorder ordering.
   #
   public traverse_all_preorder()
      coact(self)
      every (!children).traverse_all_preorder()
   end

   #
   # Traverse all the {TreeNode}s in this subtree, including this
   # {TreeNode}, in postorder ordering.
   #
   public traverse_all_postorder()
      every (!children).traverse_all_postorder()
      coact(self)
   end

   #
   # Traverse all the open {TreeNode}s in this subtree, including this
   # {TreeNode}, in preorder ordering.
   #
   public traverse_open_preorder()
      coact(self)
      if \self.is_expanded_flag then
         every (!children).traverse_open_preorder()
   end

   #
   # Traverse all open {TreeNode}s in this subtree, including this
   # {TreeNode}, in postorder ordering.
   #
   public traverse_open_postorder()
      if \self.is_expanded_flag then
         every (!children).traverse_open_postorder()
      coact(self)
   end

   #
   # Expand all the {TreeNode}s below this node.  Nodes with no children
   # are not expanded unless the force flag is set to 1.
   #
   public expand(force)
      local n
      every n := Seq{traverse_all_postorder()} do
         if \force | *n.children > 0 then
            n.is_expanded_flag := 1
   end

   #
   # This method expands the path from this node to the root,
   # thereby ensuring it is visible.  This node itself is not
   # expanded, only its parents.
   #
   public expand_to_root()
      local n
      n := self
      while n := n.get_parent() do
         n.set_expanded(&yes)
   end

   #
   # Set the label for this node.
   #
   public set_label(x)
      self.label := x
      return self
   end

   #
   # Return the label
   #
   public get_label()
      return self.label
   end

   # Set the icons for this node, as three {Paint} instances.  The
   # first is displayed if the {TreeNode} is open and has children,
   # the second is displayed if the {TreeNode} is closed and has
   # children, and the third is displayed if the node has no children.
   #
   # Note that these instances are neither initialized or finalized by
   # this class (nor by {Tree}) - that must be done externally by the
   # owner.  (This does mean many nodes can share the same instance
   # however).
   #
   public set_icon_paint(i1, i2, i3)
      self.icon_paint := [i1, i2, i3]
      return self
   end

   #
   # Add the given {TreeNode} to this {TreeNode}'s list of children.
   # @param  The {TreeNode} to add.
   # @param i   The index to add at; if omitted then the new node
   # @          is appended to the end.
   # @fail      If i is out of range
   #
   public add(n, i)
      /i := 0
      insert(self.children, i, n) | fail
      n.parent := self
      return self
   end

   #
   # Get the index of the given child node
   #
   public get_index(n)
      return keyof(self.children, n)
   end

   #
   # Delete the given {TreeNode} from the children.
   # @fail      If n is not a child of this instance.
   #
   public remove(n)
      return remove_index(get_index(n))
   end

   #
   # Remove the {TreeNode} at the given index from the list of children.
   # @param i    The index
   # @fail      If i is out of range
   #
   public remove_index(i)
      local c
      c := self.children[i] | fail
      c.parent := &null
      delete(self.children, i)
      return self
   end

   #
   # Remove all the children.
   #
   public remove_all()
      return remove_list() & self
   end

   #
   # Move the {TreeNode} to the given index position.
   # @param c   The {TreeNode} to move.
   # @param j   The new position.
   # @fail      If c is not a child of this instance, 
   # @           or j is out of range.
   #
   public reposition(c, j)
      return reposition_index(get_index(c), j)
   end

   #
   # Move the {TreeNode} at position {i} to {j}.
   # @param i   The old position.
   # @param j   The new position.
   # @fail      If either index is out of range.
   #
   public reposition_index(i, j)
      lmove(children, i, j) | fail
      return self
   end

   # Remove the children in the range `i:j`, returning the
   # removed children in a list.
   # @param i   The start slice index, default 1
   # @param j   The end slice index, default 0
   # @fail      If the range is invalid.
   #
   #
   public remove_list(i, j)
      local l, s
      s := cvslice(i, j, *children) | fail
      l := children[s.lo:s.hi]
      every 1 to s.hi - s.lo do
         delete(children, s.lo)
      every (!l).parent := &null
      return l
   end

   # Add all the `TreeNode`s contained in list `l` at index `i`.
   #
   # @param l    The list to add
   # @param i    The index
   # @fail      If i is out of range
   #
   public add_list(l, i)
      local c
      /i := 0
      i := cvpos(i, *children) | fail
      every c := !l do {
         insert(children, i, c)
         c.parent := self
         i +:= 1
      }
      return self
   end

   # Move all the children of `TreeNode` `other`, to this
   # `TreeNode`, adding them at index `i`.  `other` will be left empty.
   #
   # @param other The source {TreeNode}.
   # @param i     The index to add at; if omitted then the new components
   # @            are appended to the end.
   # @fail        If i is out of range
   #
   public move_all(other, i)
      return add_list(other.remove_list(), i)
   end

   #
   # Get the parent node, or fail if there is none.
   #
   public get_parent()
      return \self.parent
   end

   #
   # Get the child nodes
   #
   public get_children()
      return children
   end

   #
   # This configures the {TreeNode} so that it is always treated as though it has children
   # for display purposes, event though it may in fact have no children.
   #
   public set_always_expandable(s)
      self.always_expandable_flag := check_flag(s)
      return self
   end

   #
   # Set the expanded flag.  Note that this will not update the GUI, to do that
   # call tree.tree_structure_changed() on the tree in which the node resides.
   #
   public set_expanded(s)
      self.is_expanded_flag := check_flag(s)
      return self
   end
      
   #
   # Toggle the opened status of the {TreeNode}. Note that this will not update the GUI, to do that
   # call tree.tree_structure_changed() on the tree in which the node resides.
   #
   public toggle_expanded()
      self.is_expanded_flag := toggle_flag(self.is_expanded_flag)
      return self
   end

   #
   # Succeed iff the node is opened
   #
   public is_expanded()
      return \is_expanded_flag
   end

   #
   # Clear all the children
   #
   public clear_children()
      every (!children).parent := &null
      clear(children)
      return self
   end

   public new()
      children := []
      return
   end
end

