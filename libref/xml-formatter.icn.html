<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>formatter.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: formatter.icn 9120 2021-05-29 19:02:46Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package xml
<a name="10"/>
<a name="11"/>import io, exception, util
<a name="12"/>
<a name="13"/>#
<a name="14"/># This is an abstract base class for Formatters, which take a Document
<a name="15"/># object (or a Node within a Document), and output that document to a
<a name="16"/># stream.
<a name="17"/>#
<a name="18"/>abstract class Formatter(Stream, HasCloseUnderlying)
<a name="19"/>   private const
<a name="20"/>      file
<a name="21"/>   protected 
<a name="22"/>      level
<a name="23"/>
<a name="24"/>   #
<a name="25"/>   # Create a formatter which will output to the `Stream` `file`; by
<a name="26"/>   # default standard output.
<a name="27"/>   #
<a name="28"/>   public new(f)
<a name="29"/>      file := need_Stream(\f) | FileStream.stdout
<a name="30"/>      file.can(Stream.WRITE) | runerr("Stream not writable", file)
<a name="31"/>      return
<a name="32"/>   end
<a name="33"/>
<a name="34"/>   public override out(s)
<a name="35"/>      return file.out(s) | throw(&amp;why)
<a name="36"/>   end
<a name="37"/>
<a name="38"/>   public override get_mode()
<a name="39"/>      return WRITE
<a name="40"/>   end
<a name="41"/>
<a name="42"/>   public override close()
<a name="43"/>      if \close_underlying_flag then
<a name="44"/>         file.close() | fail
<a name="45"/>      link
<a name="46"/>   end
<a name="47"/>
<a name="48"/>   public format(n)
<a name="49"/>      self.level := -1
<a name="50"/>      link try1{ format_node(n) }
<a name="51"/>   end
<a name="52"/>
<a name="53"/>   protected format_node(n)
<a name="54"/>      local s
<a name="55"/>      level +:= 1
<a name="56"/>      if s := text(n) then
<a name="57"/>         format_content(s)
<a name="58"/>      else if is(n, Element) then
<a name="59"/>         format_element(n)
<a name="60"/>      else if is(n, DocType) then
<a name="61"/>         format_doctype(n)
<a name="62"/>      else if is(n, Comment) then
<a name="63"/>         format_comment(n)
<a name="64"/>      else if is(n, ProcessingInstruction) then
<a name="65"/>         format_pi(n)
<a name="66"/>      else if is(n, CData) then
<a name="67"/>         format_cdata(n)
<a name="68"/>      else if is(n, Document) then
<a name="69"/>         format_document(n)
<a name="70"/>      else if is(n, XmlDecl) then
<a name="71"/>         format_xmldecl(n)
<a name="72"/>      else
<a name="73"/>         runerr("Unexpected type in document structure", n)
<a name="74"/>      level -:= 1
<a name="75"/>   end
<a name="76"/>
<a name="77"/>   protected abstract format_document(n)
<a name="78"/>
<a name="79"/>   protected abstract format_content(s)
<a name="80"/>
<a name="81"/>   protected abstract format_doctype(n)
<a name="82"/>
<a name="83"/>   protected abstract format_comment(n)
<a name="84"/>
<a name="85"/>   protected abstract format_pi(n)
<a name="86"/>
<a name="87"/>   protected abstract format_element(n)
<a name="88"/>
<a name="89"/>   protected abstract format_cdata(n)
<a name="90"/>
<a name="91"/>   protected abstract format_xmldecl(n)
<a name="92"/>end
<a name="93"/>
<a name="94"/>#
<a name="95"/># Convert `s` by escaping any characters in cset `c`, which defaults
<a name="96"/># to `'&amp;&lt;&gt;"\''`
<a name="97"/>#
<a name="98"/>procedure xml_escape(s, c)
<a name="99"/>   local ch, r
<a name="100"/>   /c := '&amp;&lt;&gt;"\''
<a name="101"/>   r := ""
<a name="102"/>   s ? {
<a name="103"/>      while r ||:= string(tab(upto(c))) do {
<a name="104"/>         ch := move(1)
<a name="105"/>         r ||:= case string(ch) of {
<a name="106"/>            "&amp;" : "&amp;amp;"
<a name="107"/>            "&lt;" : "&amp;lt;"
<a name="108"/>            "&gt;" : "&amp;gt;"
<a name="109"/>            "'" : "&amp;apos;"
<a name="110"/>            "\"" : "&amp;quot;"
<a name="111"/>            default : "&amp;#" || ord(ch) || ";"
<a name="112"/>         }
<a name="113"/>      }
<a name="114"/>      return r || tab(0)
<a name="115"/>   }
<a name="116"/>end
<a name="117"/>
</pre></body></html>
