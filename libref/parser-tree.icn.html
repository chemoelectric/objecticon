<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>tree.icn</title></head><body><pre>
<a name="1"/>package parser
<a name="2"/>
<a name="3"/>import util, io, ipl.pdco(Seq)
<a name="4"/>
<a name="5"/>final class Token()
<a name="6"/>   public const
<a name="7"/>      tok, 
<a name="8"/>      s, 
<a name="9"/>      val,
<a name="10"/>      line,
<a name="11"/>      column,
<a name="12"/>      filename
<a name="13"/>
<a name="14"/>   private readable 
<a name="15"/>      chunk
<a name="16"/>
<a name="17"/>   public set_chunk(chunk)
<a name="18"/>      self.chunk := chunk
<a name="19"/>      link
<a name="20"/>   end
<a name="21"/>
<a name="22"/>   public get_pad()
<a name="23"/>      return .if chunk[-*s:0] == s then
<a name="24"/>         chunk[1:-*s]
<a name="25"/>      else
<a name="26"/>         chunk
<a name="27"/>   end
<a name="28"/>
<a name="29"/>   public str()
<a name="30"/>      return .chunk
<a name="31"/>   end
<a name="32"/>
<a name="33"/>   #
<a name="34"/>   # Output this token to the given stream.
<a name="35"/>   #
<a name="36"/>   public output(f)
<a name="37"/>      return f.writes1(chunk)
<a name="38"/>   end
<a name="39"/>
<a name="40"/>   public traverse_all_preorder()
<a name="41"/>      coact(self)
<a name="42"/>   end
<a name="43"/>
<a name="44"/>   public traverse_all_postorder()
<a name="45"/>      coact(self)
<a name="46"/>   end
<a name="47"/>
<a name="48"/>   public traverse_tokens()
<a name="49"/>      coact(self)
<a name="50"/>   end
<a name="51"/>
<a name="52"/>   public new(tok, s, chunk, val, line, column, filename)
<a name="53"/>      self.tok := tok
<a name="54"/>      self.s := s
<a name="55"/>      self.val := val
<a name="56"/>      self.chunk := chunk
<a name="57"/>      self.line := line
<a name="58"/>      self.column := column
<a name="59"/>      self.filename := filename
<a name="60"/>      return
<a name="61"/>   end
<a name="62"/>end
<a name="63"/>
<a name="64"/>#
<a name="65"/># This represents a node in the parse tree.  The children are
<a name="66"/># either other Nodes, or Token instances, which come from the lexer.
<a name="67"/>#
<a name="68"/>final class Node()
<a name="69"/>   public const 
<a name="70"/>      label
<a name="71"/>   private const
<a name="72"/>      children
<a name="73"/>   public static const
<a name="74"/>      EMPTY
<a name="75"/>   
<a name="76"/>   private static init()
<a name="77"/>      EMPTY := Node("Empty")
<a name="78"/>   end
<a name="79"/>
<a name="80"/>   public child(i)
<a name="81"/>      return .children[i]
<a name="82"/>   end
<a name="83"/>
<a name="84"/>   public gen()
<a name="85"/>      suspend .!children
<a name="86"/>   end
<a name="87"/>
<a name="88"/>   #
<a name="89"/>   # Get the index of the given child element
<a name="90"/>   #
<a name="91"/>   public get_index(c)
<a name="92"/>      return keyof(children, c)
<a name="93"/>   end
<a name="94"/>
<a name="95"/>   public set(i, x)
<a name="96"/>      children[i] := x
<a name="97"/>      link
<a name="98"/>   end
<a name="99"/>
<a name="100"/>   public size()
<a name="101"/>      return *children
<a name="102"/>   end
<a name="103"/>
<a name="104"/>   #
<a name="105"/>   # Traverse all the `Node`s and `Token`s in this subtree, including this
<a name="106"/>   # `Node`, in preorder ordering.
<a name="107"/>   #
<a name="108"/>   public traverse_all_preorder()
<a name="109"/>      coact(self)
<a name="110"/>      every (!children).traverse_all_preorder()
<a name="111"/>   end
<a name="112"/>
<a name="113"/>   #
<a name="114"/>   # Traverse all the `Node`s and `Token`s in this subtree, including this
<a name="115"/>   # `Node`, in postorder ordering.
<a name="116"/>   #
<a name="117"/>   public traverse_all_postorder()
<a name="118"/>      every (!children).traverse_all_postorder()
<a name="119"/>      coact(self)
<a name="120"/>   end
<a name="121"/>
<a name="122"/>   #
<a name="123"/>   # Traverse all the `Token`s in this subtree.
<a name="124"/>   #
<a name="125"/>   public traverse_tokens()
<a name="126"/>      every (!children).traverse_tokens()
<a name="127"/>   end
<a name="128"/>
<a name="129"/>   #
<a name="130"/>   # Return a string representation of this node.  Note - this may
<a name="131"/>   # need considerable stack space for some programs.
<a name="132"/>   #
<a name="133"/>   public str()
<a name="134"/>      local s
<a name="135"/>      s := ""
<a name="136"/>      every s ||:= (!children).str()
<a name="137"/>      return s
<a name="138"/>   end
<a name="139"/>
<a name="140"/>   #
<a name="141"/>   # Output this node to the given stream.
<a name="142"/>   #
<a name="143"/>   public output(f)
<a name="144"/>      local c
<a name="145"/>      every c := !children do
<a name="146"/>         c.output(f) | fail
<a name="147"/>      return
<a name="148"/>   end
<a name="149"/>
<a name="150"/>   public new(label, children[])
<a name="151"/>      self.label := label
<a name="152"/>      self.children := children
<a name="153"/>      return
<a name="154"/>   end
<a name="155"/>end
<a name="156"/>
<a name="157"/>protected abstract class Tree()
<a name="158"/>   public const pos
<a name="159"/>
<a name="160"/>   public optional get_first_token()
<a name="161"/>
<a name="162"/>   public dumpw()
<a name="163"/>      Util.dumpw(pos)
<a name="164"/>   end
<a name="165"/>
<a name="166"/>   package new(pos)
<a name="167"/>      self.pos := pos
<a name="168"/>      return
<a name="169"/>   end
<a name="170"/>end
<a name="171"/>
<a name="172"/>protected abstract class List()
<a name="173"/>   public const lpos, index
<a name="174"/>
<a name="175"/>   package abstract flatten()
<a name="176"/>   package abstract unflatten()
<a name="177"/>   public abstract put(o)
<a name="178"/>   public abstract push(o)
<a name="179"/>
<a name="180"/>   public clear()
<a name="181"/>      lpos.set(index, Node.EMPTY)
<a name="182"/>      link
<a name="183"/>   end
<a name="184"/>
<a name="185"/>   public gen()
<a name="186"/>      suspend !flatten()
<a name="187"/>   end
<a name="188"/>
<a name="189"/>   public size()
<a name="190"/>      return *flatten()
<a name="191"/>   end
<a name="192"/>
<a name="193"/>   public get(i)
<a name="194"/>      return flatten()[i]
<a name="195"/>   end
<a name="196"/>
<a name="197"/>   public set(i, o)
<a name="198"/>      local l
<a name="199"/>      l := flatten()
<a name="200"/>      l[i] := o
<a name="201"/>      unflatten(l)
<a name="202"/>      link
<a name="203"/>   end
<a name="204"/>
<a name="205"/>   public insert(i, o)
<a name="206"/>      local l
<a name="207"/>      l := flatten()
<a name="208"/>      default.insert(l, i, o)
<a name="209"/>      unflatten(l)
<a name="210"/>      link
<a name="211"/>   end
<a name="212"/>
<a name="213"/>   public delete(i)
<a name="214"/>      local l
<a name="215"/>      l := flatten()
<a name="216"/>      default.delete(l, i)
<a name="217"/>      unflatten(l)
<a name="218"/>      link
<a name="219"/>   end
<a name="220"/>
<a name="221"/>   package new(lpos, index)
<a name="222"/>      self.lpos := lpos
<a name="223"/>      self.index := index
<a name="224"/>      return
<a name="225"/>   end
<a name="226"/>end
<a name="227"/>
<a name="228"/>#
<a name="229"/># Left-assoc list; define put and flatten
<a name="230"/>#
<a name="231"/>abstract class LList(List)
<a name="232"/>   package override unflatten(l)
<a name="233"/>      clear()
<a name="234"/>      every put(!l)
<a name="235"/>      link
<a name="236"/>   end
<a name="237"/>
<a name="238"/>   public override push(o)
<a name="239"/>      local l
<a name="240"/>      l := flatten()
<a name="241"/>      default.push(l, o)
<a name="242"/>      unflatten(l)
<a name="243"/>      link
<a name="244"/>   end
<a name="245"/>end
<a name="246"/>
<a name="247"/>#
<a name="248"/># Right-assoc list; define push and flatten
<a name="249"/>#
<a name="250"/>abstract class RList(List)
<a name="251"/>   package override unflatten(l)
<a name="252"/>      clear()
<a name="253"/>      every push(back(l))
<a name="254"/>      link
<a name="255"/>   end
<a name="256"/>
<a name="257"/>   public override put(s)
<a name="258"/>      local l
<a name="259"/>      l := flatten()
<a name="260"/>      default.put(l, s)
<a name="261"/>      unflatten(l)
<a name="262"/>      link
<a name="263"/>   end
<a name="264"/>end
<a name="265"/>
<a name="266"/>class Leaf(Tree)
<a name="267"/>   #
<a name="268"/>   # Return a string representation of this leaf node (typically an
<a name="269"/>   # identifier).  Note that this doesn't include the inter-token data
<a name="270"/>   # (comments and white space).  To get that, use pos.chunk or
<a name="271"/>   # pos.str().
<a name="272"/>   #
<a name="273"/>   public str()
<a name="274"/>      return pos.s
<a name="275"/>   end
<a name="276"/>
<a name="277"/>   public override get_first_token()
<a name="278"/>      return pos
<a name="279"/>   end
<a name="280"/>end
<a name="281"/>
<a name="282"/>class Id(Tree)
<a name="283"/>   public const comma
<a name="284"/>
<a name="285"/>   #
<a name="286"/>   # Return a string representation of this Id node.  Note that this
<a name="287"/>   # doesn't include the inter-token data (comments and white space).
<a name="288"/>   # To get that, use pos.str().
<a name="289"/>   #
<a name="290"/>   public str()
<a name="291"/>      return if is(pos, Token) then
<a name="292"/>         pos.s
<a name="293"/>      else case pos.label of {
<a name="294"/>         "dotident": Util.dotid2string(pos)
<a name="295"/>         "dottedident": Util.dottedid2string(pos)
<a name="296"/>      }
<a name="297"/>   end
<a name="298"/>
<a name="299"/>   public override get_first_token()
<a name="300"/>      return pos
<a name="301"/>   end
<a name="302"/>
<a name="303"/>   package override new(pos, comma)
<a name="304"/>      Tree.new(pos)
<a name="305"/>      /comma := Token(YY.COMMA, ",", ",")
<a name="306"/>      self.comma := comma
<a name="307"/>      return
<a name="308"/>   end
<a name="309"/>end
<a name="310"/>
<a name="311"/>abstract class IdList(LList)
<a name="312"/>   private const lab
<a name="313"/>
<a name="314"/>   package override flatten()
<a name="315"/>      local l, n
<a name="316"/>      l := []
<a name="317"/>      n := lpos.child(index)
<a name="318"/>      until n === Node.EMPTY do {
<a name="319"/>         if is(n, Node) &amp; n.label == lab then {
<a name="320"/>            default.push(l, Id(n.child(3), n.child(2)))
<a name="321"/>            n := n.child(1)
<a name="322"/>         } else {
<a name="323"/>            # Leftmost token, or Node with non-matching label.
<a name="324"/>            default.push(l, Id(n))
<a name="325"/>            break
<a name="326"/>         }
<a name="327"/>      }
<a name="328"/>      return l
<a name="329"/>   end
<a name="330"/>
<a name="331"/>   public override put(s)
<a name="332"/>      local v
<a name="333"/>      v := if lpos.child(index) === Node.EMPTY then
<a name="334"/>         s.pos
<a name="335"/>      else
<a name="336"/>         Node(lab, 
<a name="337"/>              lpos.child(index),
<a name="338"/>              s.comma,
<a name="339"/>              s.pos)
<a name="340"/>      lpos.set(index, v)
<a name="341"/>      link
<a name="342"/>   end
<a name="343"/>
<a name="344"/>   package override new(lpos, index, lab)
<a name="345"/>      LList.new(lpos, index)
<a name="346"/>      /lab := "idlist"
<a name="347"/>      self.lab := lab
<a name="348"/>      return
<a name="349"/>   end
<a name="350"/>end
<a name="351"/>
<a name="352"/>abstract class SimpleLList(Tree, LList)
<a name="353"/>   package override new(pos, index)
<a name="354"/>      Tree.new(pos)
<a name="355"/>      LList.new(pos, index)
<a name="356"/>      return
<a name="357"/>   end
<a name="358"/>end
<a name="359"/>
<a name="360"/>abstract class SimpleRList(Tree, RList)
<a name="361"/>   package override new(pos, index)
<a name="362"/>      Tree.new(pos)
<a name="363"/>      RList.new(pos, index)
<a name="364"/>      return
<a name="365"/>   end
<a name="366"/>end
<a name="367"/>
<a name="368"/>class SimpleIdList(Tree, IdList)
<a name="369"/>   package override new(pos, index, lab)
<a name="370"/>      Tree.new(pos)
<a name="371"/>      IdList.new(pos, index, lab)
<a name="372"/>      return
<a name="373"/>   end
<a name="374"/>end
<a name="375"/>
<a name="376"/>class AccessList(SimpleLList)
<a name="377"/>   private const lab
<a name="378"/>
<a name="379"/>   package override flatten()
<a name="380"/>      local l, n
<a name="381"/>      l := []
<a name="382"/>      n := lpos.child(index)
<a name="383"/>      until n === Node.EMPTY do {
<a name="384"/>         if is(n, Node) then {
<a name="385"/>            default.push(l, Leaf(n.child(2)))
<a name="386"/>            n := n.child(1)
<a name="387"/>         } else {
<a name="388"/>            default.push(l, Leaf(n))
<a name="389"/>            break
<a name="390"/>         }
<a name="391"/>      }
<a name="392"/>      return l
<a name="393"/>   end
<a name="394"/>
<a name="395"/>   public override put(x)
<a name="396"/>      local v
<a name="397"/>      v := if lpos.child(index) === Node.EMPTY then
<a name="398"/>         x.pos
<a name="399"/>      else
<a name="400"/>         Node(lab,
<a name="401"/>              lpos.child(index),
<a name="402"/>              x.pos)
<a name="403"/>      lpos.set(index, v)
<a name="404"/>      link
<a name="405"/>   end
<a name="406"/>
<a name="407"/>   package override new(lpos, index, lab)
<a name="408"/>      SimpleLList.new(lpos, index)
<a name="409"/>      /lab := "fieldaccess"
<a name="410"/>      self.lab := lab
<a name="411"/>      return
<a name="412"/>   end
<a name="413"/>end
<a name="414"/>
<a name="415"/>class LocalsList(SimpleLList)
<a name="416"/>   package override flatten()
<a name="417"/>      local l, n
<a name="418"/>      l := []
<a name="419"/>      n := lpos.child(index)
<a name="420"/>      until n === Node.EMPTY do {
<a name="421"/>         default.push(l, Local(n))
<a name="422"/>         n := n.child(1)
<a name="423"/>      }
<a name="424"/>      return l
<a name="425"/>   end
<a name="426"/>
<a name="427"/>   public override put(x)
<a name="428"/>      lpos.set(index, Node("locals", 
<a name="429"/>                           lpos.child(index),
<a name="430"/>                           x.pos.child(2),
<a name="431"/>                           x.pos.child(3)))
<a name="432"/>      link
<a name="433"/>   end
<a name="434"/>end
<a name="435"/>
<a name="436"/>class Invocable(SimpleLList)
<a name="437"/>   public override get_first_token()
<a name="438"/>      return pos.child(1)
<a name="439"/>   end
<a name="440"/>
<a name="441"/>   package override flatten()
<a name="442"/>      local l, n
<a name="443"/>      l := []
<a name="444"/>      n := lpos.child(index)
<a name="445"/>      until n === Node.EMPTY do {
<a name="446"/>         if is(n, Node) &amp; n.label == "invoclist" then {
<a name="447"/>            default.push(l, Id(n.child(3), n.child(2)))
<a name="448"/>            n := n.child(1)
<a name="449"/>         } else {
<a name="450"/>            default.push(l, Id(n))
<a name="451"/>            break
<a name="452"/>         }
<a name="453"/>      }
<a name="454"/>      return l
<a name="455"/>   end
<a name="456"/>
<a name="457"/>   public override put(x)
<a name="458"/>      local v
<a name="459"/>      v := if lpos.child(index) === Node.EMPTY then
<a name="460"/>         x.pos
<a name="461"/>      else
<a name="462"/>         Node("invoclist",
<a name="463"/>              lpos.child(index),
<a name="464"/>              x.comma,
<a name="465"/>              x.pos)
<a name="466"/>      lpos.set(index, v)
<a name="467"/>      link
<a name="468"/>   end
<a name="469"/>
<a name="470"/>   package override new(pos)
<a name="471"/>      SimpleLList.new(pos, 2)
<a name="472"/>      return
<a name="473"/>   end
<a name="474"/>end
<a name="475"/>
<a name="476"/>class Import(SimpleLList)
<a name="477"/>   public override get_first_token()
<a name="478"/>      return pos.child(1)
<a name="479"/>   end
<a name="480"/>
<a name="481"/>   package override flatten()
<a name="482"/>      local l, n, t
<a name="483"/>      l := []
<a name="484"/>      n := lpos.child(index)
<a name="485"/>      until n === Node.EMPTY do {
<a name="486"/>         if is(n, Node) &amp; n.label == "importlist" then {
<a name="487"/>            t := n.child(3)
<a name="488"/>            if is(t, Node) &amp; t.label == "importspec" then
<a name="489"/>               default.push(l, ImportSpec(t, n.child(2)))
<a name="490"/>            else
<a name="491"/>               default.push(l, Id(t, n.child(2)))
<a name="492"/>            n := n.child(1)
<a name="493"/>         } else {
<a name="494"/>            if is(n, Node) &amp; n.label == "importspec" then
<a name="495"/>               default.push(l, ImportSpec(n))
<a name="496"/>            else
<a name="497"/>               default.push(l, Id(n))
<a name="498"/>            break
<a name="499"/>         }
<a name="500"/>      }
<a name="501"/>      return l
<a name="502"/>   end
<a name="503"/>
<a name="504"/>   public override put(x)
<a name="505"/>      local v
<a name="506"/>      v := if lpos.child(index) === Node.EMPTY then
<a name="507"/>         x.pos
<a name="508"/>      else
<a name="509"/>         Node("importlist",
<a name="510"/>              lpos.child(index),
<a name="511"/>              x.comma,
<a name="512"/>              x.pos)
<a name="513"/>      lpos.set(index, v)
<a name="514"/>      link
<a name="515"/>   end
<a name="516"/>
<a name="517"/>   package override new(pos)
<a name="518"/>      SimpleLList.new(pos, 2)
<a name="519"/>      return
<a name="520"/>   end
<a name="521"/>end
<a name="522"/>
<a name="523"/>class Imports(SimpleLList)
<a name="524"/>   package override flatten()
<a name="525"/>      local l, n
<a name="526"/>      l := []
<a name="527"/>      n := pos.child(index)
<a name="528"/>      until n === Node.EMPTY do {
<a name="529"/>         default.push(l, Import(n.child(2)))
<a name="530"/>         n := n.child(1)
<a name="531"/>      }
<a name="532"/>      return l
<a name="533"/>   end
<a name="534"/>
<a name="535"/>   public override put(x)
<a name="536"/>      pos.set(index, Node("importdecls", 
<a name="537"/>                          pos.child(index),
<a name="538"/>                          x.pos))
<a name="539"/>      link
<a name="540"/>   end
<a name="541"/>end
<a name="542"/>
<a name="543"/>class Body(SimpleLList)
<a name="544"/>   package override flatten()
<a name="545"/>      local l, n, t, t2
<a name="546"/>      l := []
<a name="547"/>      n := lpos.child(index)
<a name="548"/>      until n === Node.EMPTY do {
<a name="549"/>         t := n.child(2)
<a name="550"/>         default.push(l, case t.label of {
<a name="551"/>            "body" : {
<a name="552"/>               t2 := t.child(2)
<a name="553"/>               case t2.label of {
<a name="554"/>                  "record" : Record(t)
<a name="555"/>                  "class" :  Class(t)
<a name="556"/>                  "proc" :  Procedure(t)
<a name="557"/>                  "global": Global(t)
<a name="558"/>                  default: syserr("Unknown body node: " || t2.label)
<a name="559"/>               }
<a name="560"/>            }
<a name="561"/>            "invocable": Invocable(t)
<a name="562"/>            default: syserr("Unknown declaration node: " || t.label)
<a name="563"/>         })
<a name="564"/>         n := n.child(1)
<a name="565"/>      }
<a name="566"/>      return l
<a name="567"/>   end
<a name="568"/>
<a name="569"/>   public override put(x)
<a name="570"/>      lpos.set(index, Node("bodydecls", 
<a name="571"/>                           lpos.child(index),
<a name="572"/>                           x.pos))
<a name="573"/>      link
<a name="574"/>   end
<a name="575"/>end
<a name="576"/>
<a name="577"/>class Prog(Tree)
<a name="578"/>   private const decls
<a name="579"/>
<a name="580"/>   public get_package()
<a name="581"/>      return Package(Node.EMPTY ~=== decls.child(1))
<a name="582"/>   end
<a name="583"/>
<a name="584"/>   public set_package(x)
<a name="585"/>      decls.set(1, x.pos)
<a name="586"/>      link
<a name="587"/>   end
<a name="588"/>
<a name="589"/>   public clear_package(x)
<a name="590"/>      decls.set(1, Node.EMPTY)
<a name="591"/>      link
<a name="592"/>   end
<a name="593"/>
<a name="594"/>   public get_imports()
<a name="595"/>      return Imports(decls, 2)
<a name="596"/>   end
<a name="597"/>
<a name="598"/>   public get_body()
<a name="599"/>      return Body(decls, 3)
<a name="600"/>   end
<a name="601"/>
<a name="602"/>   package override new(pos)
<a name="603"/>      Tree.new(pos)
<a name="604"/>      decls := pos.child(1)
<a name="605"/>      return
<a name="606"/>   end
<a name="607"/>end
<a name="608"/>
<a name="609"/>class InvocableOp(Tree)
<a name="610"/>   public const comma
<a name="611"/>   
<a name="612"/>   public override get_first_token()
<a name="613"/>      return pos.child(1)
<a name="614"/>   end
<a name="615"/>
<a name="616"/>   public get_op()
<a name="617"/>      return Leaf(pos.child(1))
<a name="618"/>   end
<a name="619"/>
<a name="620"/>   public get_num()
<a name="621"/>      return Leaf(pos.child(3))
<a name="622"/>   end
<a name="623"/>
<a name="624"/>   package override new(pos, comma)
<a name="625"/>      Tree.new(pos)
<a name="626"/>      /comma := Token(YY.COMMA, ",", ",")
<a name="627"/>      self.comma := comma
<a name="628"/>      return
<a name="629"/>   end
<a name="630"/>end
<a name="631"/>
<a name="632"/>class ImportSpec(SimpleIdList)
<a name="633"/>   public const comma
<a name="634"/>
<a name="635"/>   public get_package()
<a name="636"/>      return Id(pos.child(1))
<a name="637"/>   end
<a name="638"/>
<a name="639"/>   package override new(pos, comma)
<a name="640"/>      # pos.size() will be 4 for a "some" import, 5 for an "excl"
<a name="641"/>      # import, and the list of symbols is one child in from the end.
<a name="642"/>      SimpleIdList.new(pos, pos.size() - 1)
<a name="643"/>      /comma := Token(YY.COMMA, ",", ",")
<a name="644"/>      self.comma := comma
<a name="645"/>      return
<a name="646"/>   end
<a name="647"/>end
<a name="648"/>
<a name="649"/>final abstract class Util()
<a name="650"/>   public static dottedid2string(n)
<a name="651"/>      local s
<a name="652"/>      s := ""
<a name="653"/>      repeat {
<a name="654"/>         if is(n, Token) then {
<a name="655"/>            s := n.s || s
<a name="656"/>            return s
<a name="657"/>         }
<a name="658"/>         s := n.child(2).s || n.child(3).s || s
<a name="659"/>         n := n.child(1)
<a name="660"/>      }
<a name="661"/>   end
<a name="662"/>
<a name="663"/>   public static dotid2string(n)
<a name="664"/>      return n.child(1).s || n.child(2).s
<a name="665"/>   end
<a name="666"/>
<a name="667"/>   public static first_token(n)
<a name="668"/>      return Seq{ n.traverse_tokens() }
<a name="669"/>   end
<a name="670"/>
<a name="671"/>   public static dump(n, l)
<a name="672"/>      /l := 0
<a name="673"/>      if is(n, Node) then {
<a name="674"/>         write(repl(" ", 3*l), n.label)
<a name="675"/>         every dump(n.gen(), l+1)
<a name="676"/>      }
<a name="677"/>      else # It's a Token
<a name="678"/>         write(repl(" ", 3*l), "Token ", image(n), " ", "s=", image(n.s), "c=", image(n.chunk))
<a name="679"/>   end
<a name="680"/>
<a name="681"/>   public static dumpw(n)
<a name="682"/>      if is(n, Node) then
<a name="683"/>         every dumpw(n.gen())
<a name="684"/>      else # Token
<a name="685"/>         writes(n.chunk)
<a name="686"/>   end
<a name="687"/>end
<a name="688"/>
<a name="689"/>final abstract class Factory()
<a name="690"/>   public static new_id(pad, s)
<a name="691"/>      /pad := ""
<a name="692"/>      return Id(Token(YY.IDENT, s, pad || s),
<a name="693"/>                Token(YY.COMMA, ",", ","))
<a name="694"/>   end
<a name="695"/>
<a name="696"/>   public static new_prog()
<a name="697"/>      return Prog(Node("prog", 
<a name="698"/>                       Node("decls", Node.EMPTY, Node.EMPTY, Node.EMPTY), 
<a name="699"/>                       Token(YY.EOFX, "", "")))
<a name="700"/>   end
<a name="701"/>
<a name="702"/>   public static new_access(pad, s)
<a name="703"/>      local t
<a name="704"/>      t := case s of {
<a name="705"/>         "private": YY.PRIVATE
<a name="706"/>         "public": YY.PUBLIC
<a name="707"/>         "protected": YY.PROTECTED
<a name="708"/>         "package": YY.PACKAGE
<a name="709"/>         "static": YY.STATIC
<a name="710"/>         "const": YY.CONST
<a name="711"/>         "readable": YY.READABLE
<a name="712"/>         "final": YY.FINAL
<a name="713"/>         "abstract": YY.ABSTRACT
<a name="714"/>         "native": YY.NATIVE
<a name="715"/>         "optional": YY.OPTIONAL
<a name="716"/>         "override": YY.OVERRIDE
<a name="717"/>         default: runerr("Bad access value", s)
<a name="718"/>      }
<a name="719"/>      return Leaf(Token(t, s, pad || s))
<a name="720"/>   end
<a name="721"/>
<a name="722"/>   public static new_retention(pad, s)
<a name="723"/>      local t
<a name="724"/>      t := case s of {
<a name="725"/>         "local": YY.LOCAL
<a name="726"/>         "static": YY.STATIC
<a name="727"/>         default: runerr("Bad retention value", s)
<a name="728"/>      }
<a name="729"/>      /pad := " "
<a name="730"/>      return Leaf(Token(t, s, pad || s))
<a name="731"/>   end
<a name="732"/>
<a name="733"/>   public static new_procedure(pad, name, args, epad)
<a name="734"/>      local t
<a name="735"/>      /epad := "\n"
<a name="736"/>      t := Procedure(Node("body",
<a name="737"/>                          Node.EMPTY,
<a name="738"/>                          Node("proc",
<a name="739"/>                               Token(YY.PROCEDURE, "procedure", pad || "procedure"),
<a name="740"/>                               Token(YY.IDENT, name, " " || name),
<a name="741"/>                               Token(YY.LPAREN, "(", "("),
<a name="742"/>                               Node.EMPTY,
<a name="743"/>                               Token(YY.RPAREN, ")", ")"),
<a name="744"/>                               Node.EMPTY,
<a name="745"/>                               Node.EMPTY,
<a name="746"/>                               Node.EMPTY,
<a name="747"/>                               Node.EMPTY,
<a name="748"/>                               Token(YY.END, "end", epad || "end"))))
<a name="749"/>      t.get_args().put(new_id("", pop(args)))
<a name="750"/>      every t.get_args().put(new_id(" ", !args))
<a name="751"/>      return t
<a name="752"/>   end
<a name="753"/>
<a name="754"/>   public static new_class(pad, access, name, supers, epad)
<a name="755"/>      local t
<a name="756"/>      /epad := "\n"
<a name="757"/>      t := Class(Node("body",
<a name="758"/>                      Node.EMPTY,
<a name="759"/>                      Node("class",
<a name="760"/>                           Node.EMPTY,
<a name="761"/>                           Token(YY.CLASS, "class", if *access &gt; 0 then " class" else pad || "class"),
<a name="762"/>                           Token(YY.IDENT, name, " " || name),
<a name="763"/>                           Token(YY.LPAREN, "(", "("),
<a name="764"/>                           Node.EMPTY,
<a name="765"/>                           Token(YY.RPAREN, ")", ")"),
<a name="766"/>                           Node.EMPTY,
<a name="767"/>                           Node.EMPTY,
<a name="768"/>                           Token(YY.END, "end", epad || "end"))))
<a name="769"/>      t.get_access().put(new_access(pad, pop(access)))
<a name="770"/>      every t.get_access().put(new_access(" ", !access))
<a name="771"/>      t.get_supers().put(new_id("", pop(supers)))
<a name="772"/>      every t.get_supers().put(new_id(" ", !supers))
<a name="773"/>      return t
<a name="774"/>   end
<a name="775"/>
<a name="776"/>   public static new_deferred_method(pad, access, defer_type, name, args)
<a name="777"/>      local t
<a name="778"/>      t := DeferredMethod(Node("classbody",
<a name="779"/>                               Node.EMPTY,
<a name="780"/>                               Node.EMPTY,
<a name="781"/>                               Node("deferredmethod",
<a name="782"/>                                    Node.EMPTY,
<a name="783"/>                                    Token(YY.IDENT, name, " " || name),
<a name="784"/>                                    Token(YY.LPAREN, "(", "("),
<a name="785"/>                                    Node.EMPTY,
<a name="786"/>                                    Token(YY.RPAREN, ")", ")"))))
<a name="787"/>      t.get_access().put(new_access(pad, pop(access)))
<a name="788"/>      every t.get_access().put(new_access(" ", !access))
<a name="789"/>
<a name="790"/>      t.get_args().put(new_id("", pop(args)))
<a name="791"/>      every t.get_args().put(new_id(" ", !args))
<a name="792"/>
<a name="793"/>      t.set_defer_type(new_access(" ", defer_type))
<a name="794"/>
<a name="795"/>      return t
<a name="796"/>   end
<a name="797"/>
<a name="798"/>   public static new_method(pad, access, name, args, epad)
<a name="799"/>      local t
<a name="800"/>      /epad := "\n"
<a name="801"/>      t := Method(Node("classbody",
<a name="802"/>                       Node.EMPTY,
<a name="803"/>                       Node.EMPTY,
<a name="804"/>                       Node("method",
<a name="805"/>                            Token(YY.IDENT, name, " " || name),
<a name="806"/>                            Token(YY.LPAREN, "(", "("),
<a name="807"/>                            Node.EMPTY,
<a name="808"/>                            Token(YY.RPAREN, ")", ")"),
<a name="809"/>                            Node.EMPTY,
<a name="810"/>                            Node.EMPTY,
<a name="811"/>                            Node.EMPTY,
<a name="812"/>                            Node.EMPTY,
<a name="813"/>                            Token(YY.END, "end", epad || "end"))))
<a name="814"/>      t.get_access().put(new_access(pad, pop(access)))
<a name="815"/>      every t.get_access().put(new_access(" ", !access))
<a name="816"/>
<a name="817"/>      t.get_args().put(new_id("", pop(args)))
<a name="818"/>      every t.get_args().put(new_id(" ", !args))
<a name="819"/>
<a name="820"/>      return t
<a name="821"/>   end
<a name="822"/>
<a name="823"/>   public static new_fields(pad, access, ids)
<a name="824"/>      local t
<a name="825"/>      t := FieldList(Node("classbody",
<a name="826"/>                          Node.EMPTY,
<a name="827"/>                          Node.EMPTY,
<a name="828"/>                          Node.EMPTY))
<a name="829"/>      t.get_access().put(new_access(pad, pop(access)))
<a name="830"/>      every t.get_access().put(new_access(" ", !access))
<a name="831"/>      every t.put(new_id(" ", !ids))
<a name="832"/>      return t
<a name="833"/>   end
<a name="834"/>
<a name="835"/>   public static new_local(pad, ret, ids)
<a name="836"/>      local t
<a name="837"/>      t :=  Local(Node("locals", 
<a name="838"/>                        Node.EMPTY,
<a name="839"/>                        Node.EMPTY,
<a name="840"/>                        Node.EMPTY))
<a name="841"/>      t.set_retention(new_retention(pad, ret))
<a name="842"/>      every t.put(new_id(" ", !ids))
<a name="843"/>      return t
<a name="844"/>   end
<a name="845"/>
<a name="846"/>   public static new_record(pad, name, fields)
<a name="847"/>      local t, l
<a name="848"/>      t := Record(Node("body",
<a name="849"/>                       Node.EMPTY,
<a name="850"/>                       Node("record",
<a name="851"/>                            Token(YY.RECORD, "record", pad || "record"),
<a name="852"/>                            Token(YY.IDENT, name, " " || name),
<a name="853"/>                            Token(YY.LPAREN, "(", "("),
<a name="854"/>                            Node.EMPTY,
<a name="855"/>                            Token(YY.RPAREN, ")", ")"))))
<a name="856"/>      l := t.get_ids()
<a name="857"/>      l.put(new_id("", pop(fields)))
<a name="858"/>      every l.put(new_id(" ", !fields))
<a name="859"/>      return t
<a name="860"/>   end
<a name="861"/>
<a name="862"/>   public static new_global(pad, ids)
<a name="863"/>      local t, l
<a name="864"/>      t := Global(Node("body",
<a name="865"/>                       Node.EMPTY,
<a name="866"/>                       Node("global",
<a name="867"/>                            Node.EMPTY,
<a name="868"/>                            Token(YY.GLOBAL, "global", pad || "global"),
<a name="869"/>                            Node.EMPTY)))
<a name="870"/>      l := t.get_ids()
<a name="871"/>      every l.put(new_id(" ", !ids))
<a name="872"/>      return t
<a name="873"/>   end
<a name="874"/>
<a name="875"/>   public static new_package(pad, id)
<a name="876"/>      return Package(Node("package",
<a name="877"/>                          Token(YY.PACKAGE, "package", pad || "package"),
<a name="878"/>                          Token(YY.IDENT, id, " " || id)))
<a name="879"/>   end
<a name="880"/>
<a name="881"/>   public static new_import_some_spec(pad, pack, syms)
<a name="882"/>      local t
<a name="883"/>      t := ImportSpec(Node("importspec",
<a name="884"/>                           Token(YY.IDENT, pack, pad || pack),
<a name="885"/>                           Token(YY.LPAREN, "(", "("),
<a name="886"/>                           Node.EMPTY,
<a name="887"/>                           Token(YY.RPAREN, ")", ")")))
<a name="888"/>      t.put(new_id("", pop(syms)))
<a name="889"/>      every t.put(new_id(" ", !syms))
<a name="890"/>      return t
<a name="891"/>   end
<a name="892"/>
<a name="893"/>   public static new_import_except_spec(pad, pack, syms)
<a name="894"/>      local t
<a name="895"/>      t := ImportSpec(Node("importspec",
<a name="896"/>                           Token(YY.IDENT, pack, pad || pack),
<a name="897"/>                           Token(YY.MINUS, "-", "-"),
<a name="898"/>                           Token(YY.LPAREN, "(", "("),
<a name="899"/>                           Node.EMPTY,
<a name="900"/>                           Token(YY.RPAREN, ")", ")")))
<a name="901"/>      t.put(new_id("", pop(syms)))
<a name="902"/>      every t.put(new_id(" ", !syms))
<a name="903"/>      return t
<a name="904"/>   end
<a name="905"/>
<a name="906"/>   public static new_import(pad, packs)
<a name="907"/>      local t
<a name="908"/>      t :=  Import(Node("import",
<a name="909"/>                        Token(YY.IMPORT, "import", pad || "import"),
<a name="910"/>                        Node.EMPTY))
<a name="911"/>      every t.put(new_id(" ", !packs))
<a name="912"/>      return t
<a name="913"/>   end
<a name="914"/>
<a name="915"/>   public static new_invocable(pad, ids)
<a name="916"/>      local t
<a name="917"/>      t := Invocable(Node("invocable",
<a name="918"/>                          Token(YY.INVOCABLE, "invocable", pad || "invocable"),
<a name="919"/>                          Node.EMPTY))
<a name="920"/>      every t.put(new_id(" ", !ids))
<a name="921"/>      return t
<a name="922"/>   end
<a name="923"/>
<a name="924"/>   public static new_keyword(pad, id)
<a name="925"/>      /pad := ""
<a name="926"/>      return Node("keyword",
<a name="927"/>                  Token(YY.AND, "&amp;", pad || "&amp;"),
<a name="928"/>                  Token(YY.IDENT, id, id))
<a name="929"/>   end
<a name="930"/>end
<a name="931"/>
<a name="932"/>class ClassMembers(SimpleLList)
<a name="933"/>   package override flatten()
<a name="934"/>      local l, n, t
<a name="935"/>      l := []
<a name="936"/>      n := lpos.child(index)
<a name="937"/>      until n === Node.EMPTY do {
<a name="938"/>         t := n.child(3)
<a name="939"/>         default.push(l, 
<a name="940"/>              if is(t, Token) | t.label == "idlist" then
<a name="941"/>                 FieldList(n)
<a name="942"/>              else if t.label == "method" then
<a name="943"/>                 Method(n)
<a name="944"/>              else
<a name="945"/>                 DeferredMethod(n))
<a name="946"/>         n := n.child(1)
<a name="947"/>      }
<a name="948"/>      return l
<a name="949"/>   end
<a name="950"/>
<a name="951"/>   public override put(x)
<a name="952"/>      lpos.set(index, Node("classbody", 
<a name="953"/>                           lpos.child(index),
<a name="954"/>                           x.pos.child(2),
<a name="955"/>                           x.pos.child(3)))
<a name="956"/>      link
<a name="957"/>   end
<a name="958"/>end
<a name="959"/>
<a name="960"/>abstract class TopLevel(Tree)
<a name="961"/>   public get_package_flag()
<a name="962"/>      if pos.child(1) === Node.EMPTY then
<a name="963"/>         fail
<a name="964"/>      return Leaf(pos.child(1))
<a name="965"/>   end
<a name="966"/>
<a name="967"/>   public set_package_flag(x)
<a name="968"/>      pos.set(1, if /x then Node.EMPTY else x.pos)
<a name="969"/>      link
<a name="970"/>   end
<a name="971"/>end
<a name="972"/>
<a name="973"/>class Class(TopLevel)
<a name="974"/>   public override get_first_token()
<a name="975"/>      return Util.first_token(pos)
<a name="976"/>   end
<a name="977"/>
<a name="978"/>   public get_name()
<a name="979"/>      return Leaf(pos.child(2).child(3))
<a name="980"/>   end
<a name="981"/>
<a name="982"/>   public set_name(x)
<a name="983"/>      pos.child(2).set(3, x.pos)
<a name="984"/>      link
<a name="985"/>   end
<a name="986"/>
<a name="987"/>   public get_supers()
<a name="988"/>      return SimpleIdList(pos.child(2), 5, "super")
<a name="989"/>   end
<a name="990"/>
<a name="991"/>   public get_access()
<a name="992"/>      return AccessList(pos.child(2), 1, "classaccess")
<a name="993"/>   end
<a name="994"/>
<a name="995"/>   public get_members()
<a name="996"/>      return ClassMembers(pos.child(2), 7)
<a name="997"/>   end
<a name="998"/>end
<a name="999"/>
<a name="1000"/>protected abstract class Function()
<a name="1001"/>   public const
<a name="1002"/>      fpos,
<a name="1003"/>      name_index,
<a name="1004"/>      arglist_index,
<a name="1005"/>      locals_index
<a name="1006"/>
<a name="1007"/>   public get_name()
<a name="1008"/>      return Leaf(fpos.child(name_index))
<a name="1009"/>   end
<a name="1010"/>
<a name="1011"/>   public set_name(x)
<a name="1012"/>      fpos.set(name_index, x.pos)
<a name="1013"/>      link
<a name="1014"/>   end
<a name="1015"/>
<a name="1016"/>   public has_varargs()
<a name="1017"/>      local l
<a name="1018"/>      l := fpos.child(arglist_index)
<a name="1019"/>      succeed is(l, Node) &amp; l.label == "arglist"
<a name="1020"/>   end
<a name="1021"/>
<a name="1022"/>   public set_varargs(f)
<a name="1023"/>      need_flag(f)
<a name="1024"/>      if \f then {
<a name="1025"/>         unless has_varargs() then
<a name="1026"/>            fpos.set(arglist_index, Node("arglist",
<a name="1027"/>                                         fpos.child(arglist_index),
<a name="1028"/>                                         Token(YY.LBRACK, "[", "["),
<a name="1029"/>                                         Token(YY.RBRACK, "]", "]")))
<a name="1030"/>      } else {
<a name="1031"/>         if has_varargs() then
<a name="1032"/>            fpos.set(arglist_index, fpos.child(arglist_index).child(1))
<a name="1033"/>      }
<a name="1034"/>      link
<a name="1035"/>   end
<a name="1036"/>
<a name="1037"/>   public get_args()
<a name="1038"/>      local l
<a name="1039"/>      l := fpos.child(arglist_index)
<a name="1040"/>      if is(l, Node) &amp; l.label == "arglist" then
<a name="1041"/>         return SimpleIdList(l, 1)
<a name="1042"/>      else
<a name="1043"/>         return SimpleIdList(fpos, arglist_index)
<a name="1044"/>   end
<a name="1045"/>
<a name="1046"/>   public get_locals_list()
<a name="1047"/>      return LocalsList(fpos, \locals_index)
<a name="1048"/>   end
<a name="1049"/>
<a name="1050"/>   public get_initial_index()
<a name="1051"/>      return \locals_index + 1
<a name="1052"/>   end
<a name="1053"/>
<a name="1054"/>   public get_body_index()
<a name="1055"/>      return \locals_index + 3
<a name="1056"/>   end
<a name="1057"/>
<a name="1058"/>   public set_initial(s)
<a name="1059"/>      fpos.set(\locals_index + 1, Token(YY.STRINGLIT, s, s))
<a name="1060"/>      link
<a name="1061"/>   end
<a name="1062"/>
<a name="1063"/>   public set_body(s)
<a name="1064"/>      fpos.set(\locals_index + 3, Token(YY.STRINGLIT, s, s))
<a name="1065"/>      link
<a name="1066"/>   end
<a name="1067"/>
<a name="1068"/>   public get_initial_node()
<a name="1069"/>      return fpos.child(\locals_index + 1)
<a name="1070"/>   end
<a name="1071"/>
<a name="1072"/>   public get_body_node()
<a name="1073"/>      return fpos.child(\locals_index + 3)
<a name="1074"/>   end
<a name="1075"/>
<a name="1076"/>   public get_end_token()
<a name="1077"/>      return fpos.child(\locals_index + 4)
<a name="1078"/>   end
<a name="1079"/>
<a name="1080"/>   package new(fpos, name_index, arglist_index, locals_index)
<a name="1081"/>      self.fpos := fpos
<a name="1082"/>      self.name_index := name_index
<a name="1083"/>      self.arglist_index := arglist_index
<a name="1084"/>      self.locals_index := locals_index
<a name="1085"/>      return
<a name="1086"/>   end
<a name="1087"/>end
<a name="1088"/>
<a name="1089"/>class Local(SimpleIdList)
<a name="1090"/>   public override get_first_token()
<a name="1091"/>      return pos.child(2)
<a name="1092"/>   end
<a name="1093"/>
<a name="1094"/>   public get_retention()
<a name="1095"/>      return Leaf(pos.child(2))
<a name="1096"/>   end
<a name="1097"/>
<a name="1098"/>   public set_retention(s)
<a name="1099"/>      pos.set(2, s.pos)
<a name="1100"/>      link
<a name="1101"/>   end
<a name="1102"/>
<a name="1103"/>   package override new(pos)
<a name="1104"/>      SimpleIdList.new(pos, 3)
<a name="1105"/>      return
<a name="1106"/>   end
<a name="1107"/>end
<a name="1108"/>
<a name="1109"/>class FieldList(SimpleIdList)
<a name="1110"/>   public override get_first_token()
<a name="1111"/>      return Util.first_token(pos.child(2))
<a name="1112"/>   end
<a name="1113"/>
<a name="1114"/>   public get_access()
<a name="1115"/>      return AccessList(pos, 2)
<a name="1116"/>   end
<a name="1117"/>
<a name="1118"/>   package override new(pos)
<a name="1119"/>      SimpleIdList.new(pos, 3)
<a name="1120"/>      return
<a name="1121"/>   end
<a name="1122"/>end
<a name="1123"/>
<a name="1124"/>class Method(Tree, Function)
<a name="1125"/>   public override get_first_token()
<a name="1126"/>      return Util.first_token(pos.child(2))
<a name="1127"/>   end
<a name="1128"/>
<a name="1129"/>   public get_access()
<a name="1130"/>      return AccessList(pos, 2)
<a name="1131"/>   end
<a name="1132"/>
<a name="1133"/>   package override new(pos)
<a name="1134"/>      Tree.new(pos)
<a name="1135"/>      Function.new(pos.child(3), 1, 3, 5)
<a name="1136"/>      return
<a name="1137"/>   end
<a name="1138"/>end
<a name="1139"/>
<a name="1140"/>class DeferredMethod(Tree, Function)
<a name="1141"/>   public override get_first_token()
<a name="1142"/>      return Util.first_token(pos.child(2))
<a name="1143"/>   end
<a name="1144"/>
<a name="1145"/>   public get_access()
<a name="1146"/>      return AccessList(pos, 2)
<a name="1147"/>   end
<a name="1148"/>
<a name="1149"/>   public get_defer_type()
<a name="1150"/>      return Leaf(fpos.child(1))
<a name="1151"/>   end
<a name="1152"/>
<a name="1153"/>   public set_defer_type(s)
<a name="1154"/>      fpos.set(1, s.pos)
<a name="1155"/>      link
<a name="1156"/>   end
<a name="1157"/>
<a name="1158"/>   package override new(pos)
<a name="1159"/>      Tree.new(pos)
<a name="1160"/>      Function.new(pos.child(3), 2, 4)
<a name="1161"/>      return
<a name="1162"/>   end
<a name="1163"/>end
<a name="1164"/>
<a name="1165"/>class Procedure(TopLevel, Function)
<a name="1166"/>   public override get_first_token()
<a name="1167"/>      return Util.first_token(pos)
<a name="1168"/>   end
<a name="1169"/>
<a name="1170"/>   package override new(pos)
<a name="1171"/>      Tree.new(pos)
<a name="1172"/>      Function.new(pos.child(2), 2, 4, 6)
<a name="1173"/>      return
<a name="1174"/>   end
<a name="1175"/>end
<a name="1176"/>
<a name="1177"/>class Record(TopLevel)
<a name="1178"/>   public override get_first_token()
<a name="1179"/>      return Util.first_token(pos)
<a name="1180"/>   end
<a name="1181"/>
<a name="1182"/>   public get_ids()
<a name="1183"/>      return SimpleIdList(pos.child(2), 4)
<a name="1184"/>   end
<a name="1185"/>
<a name="1186"/>   public get_name()
<a name="1187"/>      return Leaf(pos.child(2).child(2))
<a name="1188"/>   end
<a name="1189"/>
<a name="1190"/>   public set_name(x)
<a name="1191"/>      pos.child(2).set(2, x.pos)
<a name="1192"/>      link
<a name="1193"/>   end
<a name="1194"/>end
<a name="1195"/>
<a name="1196"/>class Global(TopLevel, IdList)
<a name="1197"/>   public const
<a name="1198"/>      gpos
<a name="1199"/>
<a name="1200"/>   public override get_first_token()
<a name="1201"/>      return Util.first_token(pos)
<a name="1202"/>   end
<a name="1203"/>
<a name="1204"/>   public get_readable_flag()
<a name="1205"/>      if gpos.child(1) === Node.EMPTY then
<a name="1206"/>         fail
<a name="1207"/>      return Leaf(gpos.child(1))
<a name="1208"/>   end
<a name="1209"/>
<a name="1210"/>   public set_readable_flag(x)
<a name="1211"/>      gpos.set(1,  if /x then Node.EMPTY else x.pos)
<a name="1212"/>      link
<a name="1213"/>   end
<a name="1214"/>
<a name="1215"/>   package override new(pos)
<a name="1216"/>      Tree.new(pos)
<a name="1217"/>      gpos := pos.child(2)
<a name="1218"/>      IdList.new(gpos, 3)
<a name="1219"/>      return
<a name="1220"/>   end
<a name="1221"/>end
<a name="1222"/>
<a name="1223"/>class Package(Tree)
<a name="1224"/>   public override get_first_token()
<a name="1225"/>      return pos.child(1)
<a name="1226"/>   end
<a name="1227"/>
<a name="1228"/>   public get_name()
<a name="1229"/>      return Id(pos.child(2))
<a name="1230"/>   end
<a name="1231"/>
<a name="1232"/>   public set_name(x)
<a name="1233"/>      pos.set(2, x.pos)
<a name="1234"/>      link
<a name="1235"/>   end
<a name="1236"/>end
<a name="1237"/>
<a name="1238"/>#
<a name="1239"/># Classes for handling lists in expression Nodes
<a name="1240"/>#
<a name="1241"/>
<a name="1242"/>class ExprListElement(Tree)
<a name="1243"/>   public const comma
<a name="1244"/>
<a name="1245"/>   public override get_first_token()
<a name="1246"/>      return Util.first_token(pos)
<a name="1247"/>   end
<a name="1248"/>
<a name="1249"/>   public override new(pos, comma)
<a name="1250"/>      Tree.new(pos)
<a name="1251"/>      /comma := Token(YY.COMMA, ",", ",")
<a name="1252"/>      self.comma := comma
<a name="1253"/>      return
<a name="1254"/>   end
<a name="1255"/>end
<a name="1256"/>
<a name="1257"/>#
<a name="1258"/># List for handling a "exprlist" Node
<a name="1259"/>#
<a name="1260"/>class ExprList(SimpleLList)
<a name="1261"/>   package override flatten()
<a name="1262"/>      local l, n
<a name="1263"/>      l := []
<a name="1264"/>      n := lpos.child(index)
<a name="1265"/>      if n ~=== Node.EMPTY then {
<a name="1266"/>         repeat {
<a name="1267"/>            if is(n, Node) &amp; n.label == "exprlist" then {
<a name="1268"/>               default.push(l, ExprListElement(n.child(3), n.child(2)))
<a name="1269"/>               n := n.child(1)
<a name="1270"/>            } else {
<a name="1271"/>               # Leftmost token, or Node with non-matching label.
<a name="1272"/>               default.push(l, ExprListElement(n))
<a name="1273"/>               break
<a name="1274"/>            }
<a name="1275"/>         }
<a name="1276"/>      }
<a name="1277"/>      return l
<a name="1278"/>   end
<a name="1279"/>
<a name="1280"/>   public override put(s)
<a name="1281"/>      local v
<a name="1282"/>      v := if lpos.child(index) === Node.EMPTY then
<a name="1283"/>         s.pos
<a name="1284"/>      else
<a name="1285"/>         Node("exprlist",
<a name="1286"/>              lpos.child(index),
<a name="1287"/>              s.comma,
<a name="1288"/>              s.pos)
<a name="1289"/>      lpos.set(index, v)
<a name="1290"/>      link
<a name="1291"/>   end
<a name="1292"/>
<a name="1293"/>   public override new(pos, index)
<a name="1294"/>      SimpleLList.new(pos, index)
<a name="1295"/>      return
<a name="1296"/>   end
<a name="1297"/>end
<a name="1298"/>
<a name="1299"/>class CompoundElement(Tree)
<a name="1300"/>   public const semi
<a name="1301"/>
<a name="1302"/>   public override get_first_token()
<a name="1303"/>      return Util.first_token(pos)
<a name="1304"/>   end
<a name="1305"/>
<a name="1306"/>   public override new(pos, semi)
<a name="1307"/>      Tree.new(pos)
<a name="1308"/>      /semi := Token(YY.SEMICOL, ";", ";")
<a name="1309"/>      self.semi := semi
<a name="1310"/>      return
<a name="1311"/>   end
<a name="1312"/>end
<a name="1313"/>
<a name="1314"/>#
<a name="1315"/># List for handling a "compound" Node
<a name="1316"/>#
<a name="1317"/>class Compound(SimpleRList)
<a name="1318"/>   package override flatten()
<a name="1319"/>      local l, n
<a name="1320"/>      l := []
<a name="1321"/>      n := lpos.child(index)
<a name="1322"/>      if n ~=== Node.EMPTY then {
<a name="1323"/>         repeat {
<a name="1324"/>            if is(n, Node) &amp; n.label == "compound" then {
<a name="1325"/>               default.put(l, CompoundElement(n.child(1), n.child(2)))
<a name="1326"/>               n := n.child(3)
<a name="1327"/>            } else {
<a name="1328"/>               # Rightmost token, or Node with non-matching label.
<a name="1329"/>               default.put(l, CompoundElement(n))
<a name="1330"/>               break
<a name="1331"/>            }
<a name="1332"/>         }
<a name="1333"/>      }
<a name="1334"/>      return l
<a name="1335"/>   end
<a name="1336"/>
<a name="1337"/>   public override push(s)
<a name="1338"/>      local v
<a name="1339"/>      v := if lpos.child(index) === Node.EMPTY then
<a name="1340"/>         s.pos
<a name="1341"/>      else
<a name="1342"/>         Node("compound",
<a name="1343"/>              s.pos,
<a name="1344"/>              s.semi,
<a name="1345"/>              lpos.child(index))
<a name="1346"/>      lpos.set(index, v)
<a name="1347"/>      link
<a name="1348"/>   end
<a name="1349"/>
<a name="1350"/>   public override new(pos, index)
<a name="1351"/>      SimpleRList.new(pos, index)
<a name="1352"/>      return
<a name="1353"/>   end
<a name="1354"/>end
<a name="1355"/>
<a name="1356"/>class CaseListElement(Tree)
<a name="1357"/>   public const semi
<a name="1358"/>
<a name="1359"/>   public override get_first_token()
<a name="1360"/>      return Util.first_token(pos)
<a name="1361"/>   end
<a name="1362"/>
<a name="1363"/>   public override new(pos, semi)
<a name="1364"/>      Tree.new(pos)
<a name="1365"/>      /semi := Token(YY.SEMICOL, ";", ";")
<a name="1366"/>      self.semi := semi
<a name="1367"/>      return
<a name="1368"/>   end
<a name="1369"/>end
<a name="1370"/>
<a name="1371"/>#
<a name="1372"/># List for handling a "caselist" Node
<a name="1373"/>#
<a name="1374"/>class CaseList(SimpleLList)
<a name="1375"/>   package override flatten()
<a name="1376"/>      local l, n
<a name="1377"/>      l := []
<a name="1378"/>      n := lpos.child(index)
<a name="1379"/>      if n ~=== Node.EMPTY then {
<a name="1380"/>         repeat {
<a name="1381"/>            if is(n, Node) &amp; n.label == "caselist" then {
<a name="1382"/>               default.push(l, CaseListElement(n.child(3), n.child(2)))
<a name="1383"/>               n := n.child(1)
<a name="1384"/>            } else {
<a name="1385"/>               # Leftmost token, or Node with non-matching label.
<a name="1386"/>               default.push(l, CaseListElement(n))
<a name="1387"/>               break
<a name="1388"/>            }
<a name="1389"/>         }
<a name="1390"/>      }
<a name="1391"/>      return l
<a name="1392"/>   end
<a name="1393"/>
<a name="1394"/>   public override put(s)
<a name="1395"/>      local v
<a name="1396"/>      v := if lpos.child(index) === Node.EMPTY then
<a name="1397"/>         s.pos
<a name="1398"/>      else
<a name="1399"/>         Node("caselist",
<a name="1400"/>              lpos.child(index),
<a name="1401"/>              s.semi,
<a name="1402"/>              s.pos)
<a name="1403"/>      lpos.set(index, v)
<a name="1404"/>      link
<a name="1405"/>   end
<a name="1406"/>
<a name="1407"/>   public override new(pos, index)
<a name="1408"/>      SimpleLList.new(pos, index)
<a name="1409"/>      return
<a name="1410"/>   end
<a name="1411"/>end
<a name="1412"/>
<a name="1413"/>class DottedIdentListElement(Tree)
<a name="1414"/>   public const dot
<a name="1415"/>
<a name="1416"/>   public override get_first_token()
<a name="1417"/>      return Util.first_token(pos)
<a name="1418"/>   end
<a name="1419"/>
<a name="1420"/>   public override new(pos, dot)
<a name="1421"/>      Tree.new(pos)
<a name="1422"/>      /dot := Token(YY.DOT, ".", ".")
<a name="1423"/>      self.dot := dot
<a name="1424"/>      return
<a name="1425"/>   end
<a name="1426"/>end
<a name="1427"/>
<a name="1428"/>#
<a name="1429"/># List for handling a "dottedident" Node
<a name="1430"/>#
<a name="1431"/>class DottedIdentList(SimpleLList)
<a name="1432"/>   package override flatten()
<a name="1433"/>      local l, n
<a name="1434"/>      l := []
<a name="1435"/>      n := lpos.child(index)
<a name="1436"/>      if n ~=== Node.EMPTY then {
<a name="1437"/>         repeat {
<a name="1438"/>            if is(n, Node) &amp; n.label == "dottedident" then {
<a name="1439"/>               default.push(l, DottedIdentListElement(n.child(3), n.child(2)))
<a name="1440"/>               n := n.child(1)
<a name="1441"/>            } else {
<a name="1442"/>               # Leftmost token, or Node with non-matching label.
<a name="1443"/>               default.push(l, DottedIdentListElement(n))
<a name="1444"/>               break
<a name="1445"/>            }
<a name="1446"/>         }
<a name="1447"/>      }
<a name="1448"/>      return l
<a name="1449"/>   end
<a name="1450"/>
<a name="1451"/>   public override put(s)
<a name="1452"/>      local v
<a name="1453"/>      v := if lpos.child(index) === Node.EMPTY then
<a name="1454"/>         s.pos
<a name="1455"/>      else
<a name="1456"/>         Node("dottedident",
<a name="1457"/>              lpos.child(index),
<a name="1458"/>              s.dot,
<a name="1459"/>              s.pos)
<a name="1460"/>      lpos.set(index, v)
<a name="1461"/>      link
<a name="1462"/>   end
<a name="1463"/>
<a name="1464"/>   public override new(pos, index)
<a name="1465"/>      SimpleLList.new(pos, index)
<a name="1466"/>      return
<a name="1467"/>   end
<a name="1468"/>end
</pre></body></html>
