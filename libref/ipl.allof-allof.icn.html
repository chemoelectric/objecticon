<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>allof.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     allof.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedure for conjunction control operation
<a name="6"/>#
<a name="7"/>#	Author:   Robert J. Alexander
<a name="8"/>#
<a name="9"/>#	Date:     April 28, 1990
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#  allof{expr1,expr2} -- Control operation that performs iterative
<a name="18"/>#                        conjunction.
<a name="19"/>#
<a name="20"/>#     Iterative conjunction permits a conjunction expression to be built
<a name="21"/>#  at run time which supports full backtracking among the created terms
<a name="22"/>#  of the expression.  The computed expression can be of arbitrary
<a name="23"/>#  length, and is built via an iterative loop in which one term is
<a name="24"/>#  appended to the expression (as if connected with a "&amp;" operator) per
<a name="25"/>#  iteration.
<a name="26"/>#
<a name="27"/>#     Expr1 works like the control expression of "every-do"; it controls
<a name="28"/>#  iteration by being resumed to produce all of its possible results.
<a name="29"/>#  The allof{} expression produces the outcome of conjunction of all of
<a name="30"/>#  the resulting instances of expr2.
<a name="31"/>#
<a name="32"/>#     For example:
<a name="33"/>#
<a name="34"/>#       local c
<a name="35"/>#       ...
<a name="36"/>#       pattern := "ab*"
<a name="37"/>#       "abcdef" ? {
<a name="38"/>#          allof { c := !pattern ,
<a name="39"/>#             if c == "*" then move(0 to *&amp;subject - &amp;pos + 1) else =c
<a name="40"/>#             } &amp; pos(0)
<a name="41"/>#          }
<a name="42"/>#
<a name="43"/>#  This example will perform a wild card match on "abcdef" against
<a name="44"/>#  pattern "ab*", where "*" in a pattern matches 0 or more characters.
<a name="45"/>#  Since pos(0) will fail the first time it is evaluated, the allof{}
<a name="46"/>#  expression will be resumed just as a conjunction expression would,
<a name="47"/>#  and backtracking will propagate through all of the instances of
<a name="48"/>#  expr2; the expression will ultimately succeed (as its conjunctive
<a name="49"/>#  equivalent would).
<a name="50"/>#
<a name="51"/>#     The allof{} procedure models Icon's expression evaluation
<a name="52"/>#  mechanism in that it explicitly performs backtracking.  The author of
<a name="53"/>#  this procedure knows of no way to invoke Icon's built-in goal
<a name="54"/>#  directed evaluation to perform conjunction of a arbitrary number of
<a name="55"/>#  computed expressions (suggestions welcome).
<a name="56"/>#
<a name="57"/>############################################################################
<a name="58"/>#
<a name="59"/>#  Requires:  co-expressions
<a name="60"/>#
<a name="61"/>############################################################################
<a name="62"/>
<a name="63"/>package ipl.allof
<a name="64"/>
<a name="65"/>procedure allof(expr1, expr2)
<a name="66"/>   local elist,i,x,v
<a name="67"/>   #
<a name="68"/>   #  Initialize
<a name="69"/>   #
<a name="70"/>   elist := []          # expression list
<a name="71"/>   i := 1               # expression list index
<a name="72"/>   
<a name="73"/>   #
<a name="74"/>   #  Loop until backtracking over all expr2s has failed.
<a name="75"/>   #
<a name="76"/>   while i &gt; 0 do {
<a name="77"/>      unless x := elist[i] then
<a name="78"/>         #
<a name="79"/>         #  If we're at the end of the list of expressions, attempt an
<a name="80"/>         #  iteration to produce another expression.
<a name="81"/>         #
<a name="82"/>         if @expr1 then
<a name="83"/>            put(elist,x := ^expr2)
<a name="84"/>         else {
<a name="85"/>            #
<a name="86"/>            #  If no further iterations, suspend a result.
<a name="87"/>            #
<a name="88"/>            suspend v
<a name="89"/>            #
<a name="90"/>            #  We've been backed into -- reset to last expr2.
<a name="91"/>            #
<a name="92"/>            i -:= 1
<a name="93"/>            }
<a name="94"/>      #
<a name="95"/>      #  Evaluate the expression.
<a name="96"/>      #
<a name="97"/>      if v := @\x then {
<a name="98"/>         #
<a name="99"/>         #  If success, move on to the refreshed next expression.
<a name="100"/>         #
<a name="101"/>         i +:= 1
<a name="102"/>         elist[i] := ^elist[i]
<a name="103"/>         }
<a name="104"/>      else
<a name="105"/>         #
<a name="106"/>         #  If failure, back up.
<a name="107"/>         #
<a name="108"/>         i -:= 1
<a name="109"/>      }
<a name="110"/>end
</pre></body></html>
