<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>lsystem.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#       File:     lsystem.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures for Lindenmayer systems support
<a name="6"/>#
<a name="7"/>#	Author:   Stephen B. Wampler
<a name="8"/>#
<a name="9"/>#	Date:     May 2, 2001
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#	Version:  1.0
<a name="18"/>#
<a name="19"/>############################################################################
<a name="20"/>#
<a name="21"/>#   Comments: This package is the collection of routines
<a name="22"/>#      developed to facilitate experiments with L-systems,
<a name="23"/>#      including the interpretation of strings as turtle
<a name="24"/>#      graphics commands.
<a name="25"/>#
<a name="26"/>#      Only rudimentary L-systems are currently implemented.
<a name="27"/>#	users are encouraged to extend this system.
<a name="28"/>#
<a name="29"/>############################################################################
<a name="30"/>#
<a name="31"/>#	Requires:  Version 9 graphics, co-expressions (for glib.icn)
<a name="32"/>#
<a name="33"/>############################################################################
<a name="34"/>#
<a name="35"/>#	Links: glib
<a name="36"/>#
<a name="37"/>############################################################################
<a name="38"/>
<a name="39"/>package ipl.lsystem
<a name="40"/>
<a name="41"/>import
<a name="42"/>   io(read, write),
<a name="43"/>   ipl.glib(Left, Line_Forward, Move_Forward, Right)
<a name="44"/>
<a name="45"/>record Lsys(order, dist, delta, axiom, rewrite)
<a name="46"/>
<a name="47"/># lsmap(s1,T) - replace, in s1, occurrences of character key values in T
<a name="48"/>#     with assigned value for that key.  (Suitable for l-system rules!)
<a name="49"/>#
<a name="50"/>procedure lsmap(s1,T)
<a name="51"/>   local s
<a name="52"/>
<a name="53"/>   if type(T) ~== "table" then
<a name="54"/>      runerr("lsmap: Second argument not a table", T)
<a name="55"/>
<a name="56"/>   s := ""
<a name="57"/>   s1 ? while s ||:= (\T[move(1)] | move(1))
<a name="58"/>
<a name="59"/>   return s
<a name="60"/>end
<a name="61"/>
<a name="62"/># mk_map(L) - build a rewriting map table from list L
<a name="63"/>#
<a name="64"/>procedure mk_map(L)
<a name="65"/>   local a, t
<a name="66"/>
<a name="67"/>   t := table()
<a name="68"/>   every a := !L do {
<a name="69"/>      t[a[1]] := a[2]
<a name="70"/>      }
<a name="71"/>
<a name="72"/>   return t
<a name="73"/>end
<a name="74"/>      
<a name="75"/># read_Lsystem(f) - read in an L system from a file...
<a name="76"/>#
<a name="77"/>#      Form for an L_system:
<a name="78"/>#
<a name="79"/>#	order: n
<a name="80"/>#	delta: angle
<a name="81"/>#	axiom: string
<a name="82"/>#	map:   c = string
<a name="83"/>#
<a name="84"/>procedure read_Lsystem(f)
<a name="85"/>   local ls, line, next_token
<a name="86"/>
<a name="87"/>   ls := Lsys(0,10,90,"",table())
<a name="88"/>
<a name="89"/>   while line := read(f) do {
<a name="90"/>      next_token := create gen_tokens(line)
<a name="91"/>
<a name="92"/>      case map(@next_token) of {
<a name="93"/>         "order:": ls.order := integer(@next_token)
<a name="94"/>         "dist:" : ls.dist  := integer(@next_token)
<a name="95"/>         "delta:": ls.delta := numeric(@next_token)
<a name="96"/>	 "axiom:": ls.axiom := @next_token
<a name="97"/>	 "map:"  : ls.rewrite[@next_token] := (@next_token, @next_token)
<a name="98"/>         }
<a name="99"/>      }
<a name="100"/>
<a name="101"/>   return ls
<a name="102"/>end
<a name="103"/>
<a name="104"/>
<a name="105"/># write_Lsystem(ls) - display L-system ls (for debugging, mainly)
<a name="106"/>#
<a name="107"/>procedure  write_Lsystem(ls)
<a name="108"/>   write("L-system:")
<a name="109"/>   write("\torder: ",ls.order)
<a name="110"/>   write("\t dist: ",ls.dist)
<a name="111"/>   write("\tdelta: ",ls.delta)
<a name="112"/>   write("\taxiom: ",ls.axiom)
<a name="113"/>   every key := key(ls.rewrite) do
<a name="114"/>       write("\t  map: ",key," -&gt; ",ls.rewrite[key])
<a name="115"/>   return
<a name="116"/>end
<a name="117"/>
<a name="118"/>
<a name="119"/># build_cmd(ls) - return the command string for
<a name="120"/>#	l-system ls
<a name="121"/>#
<a name="122"/>procedure build_cmd(ls)
<a name="123"/>   local s
<a name="124"/>
<a name="125"/>   s := ls.axiom
<a name="126"/>   every 1 to ls.order do
<a name="127"/>      s := lsmap(s, ls.rewrite)
<a name="128"/>   return s
<a name="129"/>
<a name="130"/>end
<a name="131"/>
<a name="132"/># eval_cmd(s) - apply turtle t to command string
<a name="133"/>#
<a name="134"/>procedure eval_cmd(t,s,dist,delta)
<a name="135"/>
<a name="136"/>   s ? while obey(t,move(1), dist, delta)
<a name="137"/>
<a name="138"/>   return
<a name="139"/>end
<a name="140"/>         
<a name="141"/>
<a name="142"/># eval_lsys(t,ls,dist,delta) - apply turtle t directly to
<a name="143"/>#    an Lsystem avoids constructing full Lsystem string
<a name="144"/>#    at once (i.e. no need to call build_cmd).
<a name="145"/>#
<a name="146"/>procedure eval_lsys(t,ls)
<a name="147"/>   evaluate(t,ls.axiom, ls.rewrite, ls.order, ls.delta, ls.dist)
<a name="148"/>end
<a name="149"/>
<a name="150"/># evaluate(t,s, Ls_map, n, delta, dist) - recursive l-system evaluation
<a name="151"/>#   (avoids building entire command string)
<a name="152"/>procedure evaluate(t, s, Ls_map, n, delta, dist)
<a name="153"/>
<a name="154"/>    if n = 0 then return eval_cmd(t,s,dist,delta)
<a name="155"/>
<a name="156"/>    s ? while evaluate(t, lsmap(move(1), Ls_map), Ls_map, n-1, delta, dist)
<a name="157"/>    return
<a name="158"/>end
<a name="159"/>
<a name="160"/># obey(t, c, dist, delta) - execute the appropriate turtle command
<a name="161"/>#      using turtle t.   (INCOMPLETE) (this is where L-systems could
<a name="162"/>#      be greatly extended.)
<a name="163"/>procedure obey(t, c, dist, delta)
<a name="164"/>
<a name="165"/>    case c of {
<a name="166"/>       "f" : Move_Forward(t, dist)
<a name="167"/>       "+" : Left(t, delta)
<a name="168"/>       "-" : Right(t, delta)
<a name="169"/>       default: Line_Forward(t, dist)
<a name="170"/>       }
<a name="171"/>
<a name="172"/>   return
<a name="173"/>end
<a name="174"/>
<a name="175"/># get_tokens(s) - suspend the tokens in string s
<a name="176"/>#
<a name="177"/>procedure gen_tokens(s, ws)
<a name="178"/>   local nws
<a name="179"/>   
<a name="180"/>   /ws := ' \t'
<a name="181"/>   nws := ~ws
<a name="182"/>
<a name="183"/>   s ? while tab(upto(nws)) do
<a name="184"/>          suspend tab(many(nws)) \ 1
<a name="185"/>
<a name="186"/>end
</pre></body></html>
