package io

import
   util(error, to_flag, SetFields),
   lang(NoCopy)


$ifdef _UNIX
$define EOL "\n"
$endif
$ifdef _MS_WIN32
$define EOL "\r\n"
$endif

#
# This is the top-level stream class.  It is not instantiated
# directly.
#
class Stream()
   public static const
      READ,
      WRITE,
      SEEK,
      TRUNCATE,
      READ_WRITE,
      ALL

   private static init()
      READ := 'r'
      WRITE := 'w'
      SEEK := 's'
      TRUNCATE := 't'
      READ_WRITE := 'rw'
      ALL := 'rwst'
   end

   #
   # Return at least one, and up to n characters from the stream, or
   # fail if either at end-of-file or on error.  After failure, the
   # {eof()} method can be used to check for end-of-file, and {&why} is
   # set in any case.
   #
   # @param n the maximum number of chars to read.
   #
   public defer in(n)

   #
   # Output the given string to the stream.  The number of characters
   # output is returned, which will always be greater than zero, but may
   # be less than {*s}.  Fails on an error, setting {&why}.
   #
   # @param s the string to write
   #
   public defer out(s)

   #
   # Seek to the given offset.  Icon-style offsets are used, so 1 is
   # the beginning of the stream, and 0 the end.  Not all types of stream
   # support {seek} - see {get_mode}.
   #
   # @param offset the position to seek to
   # @return the new position.
   #
   public defer seek(offset)

   #
   # Return the current position of the stream.
   #
   public defer tell()

   #
   # Truncate this stream to the given length, and set the position to the
   # new end of the stream (ie, len + 1).
   #
   public defer truncate(len)

   #
   # Return a cset indicating which functions the stream supports.
   # The possible character members are listed as constants above.  If
   # the cset contains {READ}, the stream is readable; {WRITE}
   # indicates the stream is writable, {SEEK} indicates that it is
   # seekable (and supports {tell} too), and {TRUNCATE} that it is
   # truncatable.
   #
   public defer get_mode()

   #
   # Close the stream.  After being closed, any further calls on the
   # stream may stop with a runtime error.
   #
   public defer close()

   #
   # After an attempt to read from the stream has failed, this method
   # can be used to see if the failure was because the stream was at
   # the end-of-file.
   #
   public defer eof()

   #
   # Succeed iff the stream's mode has all the chars in {c}
   #
   public can(c)
      return get_mode() ** c === c
   end

   #
   # Read a complete line from the stream, reading up to the next "\n"
   # or end-of-file.  In the former case, the "\n" and also any "\r"
   # immediately before it is stripped from the result.
   #
   public read()
      local s, c
      s := ""
      repeat {
         if c := in(1) then {
            if c == "\n" then {
               if s[-1] == "\r" then
                  s[-1] := ""
               return s
            } else
               s ||:= c
         } else {
            if eof() & (*s > 0) then
               return s
            else
               fail
         }
      }
   end

   #
   # Read {n} chars from the stream.  The only difference between this
   # and {in} is that this method will try and return exactly {n}
   # characters, and will only return less because of reaching the
   # end-of-file.
   #
   public reads(n)
      local s, t
      s := ""
      while n > 0 do {
         if t := in(n) then {
            s ||:= t
            n -:= *t
         } else {
            if eof() & (*s > 0) then
               return s
            else
               fail
         }
      }
      return s
   end

   #
   # This writes each parameter to the stream.  Each parameter is
   # guaranteed to be completely output, except on error, in which
   # case the method fails and sets &why.
   #
   public writes(a[])
      local e, n
      every e := !a do {
         while *e > 0 do {
            n := out(e) | fail
            e := e[n + 1:0]
         }
      }
      return
   end

   #
   # This behaves just like {writes}, except that a newline is
   # appended after all the parameters are output.
   #
   public write(a[])
      local e, n
      every e := !a | EOL do {
         while *e > 0 do {
            n := out(e) | fail
            e := e[n + 1:0]
         }
      }
      return
   end
end

#
# This is a stream based on an Icon string.  An initial string can be
# provided to the constructor.  Reading from the stream will be quite
# efficient, but writing will be relatively slow, particularly if the
# string is long.  For a much faster alternative, see {RamStream}.
#
class StringStream(Stream)
   private 
      f_eof,
      subj,
      pos

   public in(n)
      local t, e
      f_eof := &null
      if pos > *subj then {
         f_eof := 1
         return error("End of file")
      }
      e := min(pos + n, *subj + 1)
      t := subj[pos:e]
      pos := e
      return t
   end

   public out(s)
      local e
      if pos > *subj then {
         subj ||:= repl("\0", pos - *subj - 1) || s
         pos := *subj + 1
      } else {
         e := min(pos + *s, *subj + 1)
         subj[pos:e] := s
         pos +:= *s
      }
      return *s
   end

   public seek(offset)
      return if offset > 0 then
         pos := offset
      else if -offset <= *subj then
         pos := *subj + 1 + offset
      else
         error("Seek out of range")
   end

   public tell()
      return pos
   end

   public close()
      return
   end

   public get_mode()
      return ALL
   end

   public truncate(len)
      if len > *subj then
         subj ||:= repl("\0", len - *subj)
      else
         subj := subj[1:len + 1]
      pos := *subj + 1
      return
   end

   public eof()
      return \.f_eof
   end

   public str()
      return .subj
   end

   #
   # Create a new {StringStream}, with initial value of {subj}.
   #
   # @param subj the initial value of the stream; defaults to empty 
   # @      string.
   #
   public new(subj)
      /subj := ""
      self.subj := subj
      self.pos := 1
      return
   end
end

#
# This class takes another stream and provides read/write buffers so
# that input/output to the inner stream tends to take place in larger
# chunks.
#
class BufferStream(Stream, SetFields)
   private
      other,
      rpos,
      wbuff,
      wbuff_len,
      rbuff,
      flush_on_nl_flag,
      buff_size

   #
   # Set the underlying stream to use.
   #
   public set_other(other)
      self.other := other
   end

   #
   # If set, the stream is flushed whenever a newline is written.
   #
   public set_flush_on_nl(s)
      self.flush_on_nl_flag := to_flag(s)
   end

   #
   # Set the buffer size to use.
   #
   public set_buff_size(n)
      self.buff_size := n
   end

   public read()
      local t
      flush() | fail
      repeat {
         rbuff ? {
            if t := tab(upto('\n')) then {
               t ||:= move(1)
               rbuff := tab(0)
               \rpos +:= *t
               break
            }
         }
         if *rbuff = 0 & other.can(SEEK) then
            rpos := other.tell() | fail
         rbuff ||:= other.in(buff_size) | {
            other.eof() | fail
            t := rbuff
            rbuff := ""
            rpos := &null
            break
         }
      }
      if *t = 0 then
         fail
      if t[-1] == "\n" then {
         t[-1] := ""
         if t[-1] == "\r" then
            t[-1] := ""
      }
      return t
   end

   public in(n)
      local t
      flush() | fail
      if *rbuff > 0 then {
         rbuff ? {
            t := move(n) | tab(0)
            rbuff := tab(0)
            \rpos +:= *t
         }
      } else if n < buff_size then {
         if other.can(SEEK) then
            rpos := other.tell() | fail
         rbuff := other.in(buff_size) | fail
         rbuff ? {
            t := move(n) | tab(0)
            rbuff := tab(0)
            \rpos +:= *t
         }
      } else
         t := other.in(n) | fail
      return t
   end

   public out(s)
      unbuff() | fail
      put(wbuff, s)
      wbuff_len +:= *s
      if wbuff_len > buff_size | (\flush_on_nl_flag & upto('\n', s)) then
         flush() | fail
      return *s
   end

   #
   # Flush the write buffer.
   #
   public flush()
      local n, s
      if *wbuff = 0 then
         return
      s := ""
      every s ||:= !wbuff
      wbuff := []
      wbuff_len := 0
      while *s > 0 do {
         n := other.out(s) | fail
         s := s[n + 1:0]
      }
      return
   end

   #
   # Un-buffer the read buffer.  For a seekable stream this involves
   # discarding the read buffer and seeking to the position
   # corresponding to the start of the buffer.  For a non-seekable
   # stream, this call has no effect.
   #
   public unbuff()
      if *rbuff > 0 & \rpos & other.can(SEEK) then {
         other.seek(rpos) | fail
         rbuff := ""
         rpos := &null
      }
      return
   end

   #
   # Calls {unbuff} and {flush}
   #
   public synch()
      unbuff() | fail
      flush() | fail
      return
   end

   public close()
      flush() | fail
      return other.close()
   end

   public seek(offset)
      synch() | fail
      return other.seek(offset)
   end

   public tell()
      synch() | fail
      return other.tell()
   end

   public truncate(len)
      synch() | fail
      return other.truncate(len)
   end

   public get_mode()
      return other.get_mode()
   end

   public eof()
      return other.eof()
   end

   public set_one(f)
      case f.attr of {
         "other" : set_other(f.object_val(Stream))
         "buff_size" : set_buff_size(f.int_val())
         "flush_on_nl" : set_flush_on_nl(f.flag_val())
         default: fail
      }
      return
   end

   public new(a[])
      self.rbuff := ""
      self.wbuff := []
      self.wbuff_len := 0
      self.buff_size := 1024
      set_fields(a)
      return
   end
end

#
# This is the parent class of streams based on a posix-style
# integer-based file descriptor.
#
class DescStream(Stream, NoCopy)
   protected 
      fd,
      mode,
      f_eof

   #
   # Return the integer file descriptor.
   #
   public get_fd()
      return .fd
   end

   public get_mode()
      return .mode
   end

   public eof()
      return \.f_eof
   end

   #
   # Performs a select on the given lists of streams, each of which
   # must be a {DescStream}.  The lists are changed by the method,
   # and the modified lists indicate which streams are ready to read,
   # write or have an error.
   # 
   # On a timeout or error this method fails and sets {&why}.
   #
   # @param rl the read list of streams
   # @param wl the write list of streams
   # @param el the error list of streams
   # @param timeout the timeout; if omitted waits indefinitely
   # @return the number of items in the three lists, always > 0.
   #
   public static defer select(rl, wl, el, timeout)

   #
   # Performs a poll on one or more streams, each of which must be a
   # {DescStream}.  The arguments take the form of {Stream} followed
   # by flags, which should be selected from those constants in the
   # {Poll} class.  The last argument is the optional timeout. The
   # result is a list of the flags corresponding to each {Stream}
   # provided.  This method fails on timeout or error, setting {&why}
   # accordingly.
   #
   public static defer poll(a[])

   #
   # Turn the specified flags on or off, and return the new set of
   # flags.  The flags should be selected from the constants in
   # {FileOpt}.
   # @param on the flags to turn on
   # @param off the flags to turn off
   # @return the new flags
   #
   public defer flag(on, off)

   protected new(fd, mode)
      self.fd := fd
      self.mode := mode
      return
   end
end

#
# This procedure emulates the old Icon builtin function of the
# same name.  It always returns a {BufferStream} wrapping a
# {FileStream}.
#
procedure open(name, mode)
   local i
   i := case mode of {
      &null | "r" : FileOpt.RDONLY
      "w" : ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT)
      "b"|"rw"|"r+" : FileOpt.RDWR
      "crw"|"w+" : ior(FileOpt.RDWR, FileOpt.TRUNC, FileOpt.CREAT)
      "a" : ior(FileOpt.WRONLY, FileOpt.APPEND, FileOpt.CREAT)
      "a+" : ior(FileOpt.RDWR, FileOpt.APPEND, FileOpt.CREAT)
      default: return error("Invalid mode flag: " || mode)
   }
   return BufferStream("other=",FileStream.open(name, i))
end

#
# Convenient method to call {write} with standard error as output.
#
procedure ewrite(a[])
   return write!push(a, FileStream.stderr)
end

#
# Convenient method to call {writes} with standard error as output.
#
procedure ewrites(a[])
   return writes!push(a, FileStream.stderr)
end

#
# This procedure emulates the old Icon builtin {write} function.
#
procedure write(a[])
   local e, f, r, n
   r := a[-1]
   if is(a[1], Stream) then
      f := pop(a)
   else
      f := FileStream.b_stdout
   every e := \!a | EOL do {
      if is(e, Stream) then {
         f.out(EOL)
         f := e
      } else {
         e := string(e) | runerr(103, e)
         while *e > 0 do {
            n := f.out(e) | fail
            e := e[n + 1:0]
         }
      }
   }
   return r
end

#
# This procedure emulates the old Icon builtin {writes} function.
#
procedure writes(a[])
   local e, f, r, n
   r := a[-1]
   if is(a[1], Stream) then
      f := pop(a)
   else
      f := FileStream.b_stdout
   every e := \!a do {
      if is(e, Stream) then {
         if f === FileStream.b_stdout then
            f.flush() | fail
         f := e
      } else {
         e := string(e) | runerr(103, e)
         while *e > 0 do {
            n := f.out(e) | fail
            e := e[n + 1:0]
         }
      }
   }
   if f === FileStream.b_stdout then
      f.flush() | fail
   return r
end

#
# This procedure emulates the old Icon builtin {stop} function.
#
procedure stop(a[])
   write!push(a, FileStream.stderr)
   exit(1)
end

#
# This procedure emulates the old Icon builtin {read} function.
#
procedure read(f)
   /f := FileStream.b_stdin
   return f.read()
end

#
# This procedure emulates the old Icon builtin {reads} function.
#
procedure reads(f, n)
   /f := FileStream.b_stdin
   /n := 1
   return f.reads(n)
end

#
# This procedure emulates the old Icon builtin {close} function.
#
procedure close(f)
   f.close() | fail
   return f
end

#
# This class represents a stream based on a local file.
#
class FileStream(DescStream)
   public static const
      # A {FileStream} representing standard input
      stdin, 
      # A {FileStream} representing standard output
      stdout,
      # A {FileStream} representing standard error
      stderr,
      # A {BufferStream} wrapping stdin
      b_stdin, 
      # A {BufferStream} wrapping stdout
      b_stdout,
      # A {BufferStream} wrapping stderr
      b_stderr

   #
   # Open a new {FileStream} using the underlying system open
   # function.
   # @param name the file name
   # @param flags the flags, selected from {FileOpt}
   # @param perm the create permissions to use if a file is
   # @      created, selected from {Mode}.
   #
   public static open(name, flags, perm)
      local mode
      if iand(flags, FileOpt.WRONLY) ~= 0 then
         mode := WRITE ++ SEEK ++ TRUNCATE
      else if iand(flags, FileOpt.RDWR) ~= 0 then
         mode := ALL
      else
         mode := READ ++ SEEK
      return FileStream(open_impl(name, flags, perm), mode)
   end

   private static defer open_impl(path, flags, perm)

   private static init()
      stdin := FileStream(0, READ)
      stdout := FileStream(1, WRITE)
      stderr := FileStream(2, WRITE)
      b_stdin := BufferStream("other=",stdin, "flush_on_nl=t")
      b_stdout := BufferStream("other=",stdout, "flush_on_nl=t")
      b_stderr := BufferStream("other=",stderr, "flush_on_nl=t")
   end

   public defer in(n)

   public defer out(s)

   public defer seek(offset)

   public defer tell()

   public defer truncate(len)

   #
   # Return a {Stat} object with info about this file.
   #
   public stat()
      return Stat!stat_impl()
   end

   private defer stat_impl()

   public defer close()
end

#
# This class represents a stream based on a socket.
#
class SocketStream(DescStream)
   #
   # Create a socket with the given domain and type.
   #
   # @param domain from {ProtocolFormat}.  The default is
   # @    {ProtocolFormat.INET} 
   # @param typ the type from {SocketType}.  The default is
   # @    {SocketType.STREAM}.
   #
   public static socket(domain, typ)
      return SocketStream(socket_impl(domain, typ), READ_WRITE)
   end

   #
   # Create a pair of sockets of the given type
   #
   # @param typ the type from {SocketType}.  The default is
   # {SocketType.STREAM}.
   #
   public static socketpair(typ)
      local t
      t := socketpair_impl(typ) | fail
      return [SocketStream(t[1], READ_WRITE), SocketStream(t[2], READ_WRITE)]
   end

   public defer in(n)

   #
   # Connect a socket previously created with {Socket} to the given
   # address.  The address is a string in the form "unix:<filename>"
   # for an {AF_UNIX} address, or "inet:<host>:<port>" for an
   # {AF_INET} address.  The host can be "INADDR_ANY" if desired.
   #
   public defer connect(addr)

   #
   # Bind a socket to the given address, which is in the same form as
   # for {connect}.
   #
   public defer bind(addr)

   #
   # Listen for connections with the given backlog.
   #
   public defer listen(backlog)

   #
   # Accept a new connection, returning a new {SocketStream}.
   #
   public accept()
      return SocketStream(accept_impl(), READ_WRITE)
   end

   private defer accept_impl()

   public defer out(s)

   public defer close()

   private static defer socketpair_impl(typ)

   private static defer socket_impl(domain, typ)
end

#
# This class is used to read directory contents.
#
class DirStream(Stream, NoCopy)
   private 
      dd,
      line,
      f_eof

   #
   # Open the given directory.  Entries may be read one at a time
   # using the stream's {read} method.
   #
   public static open(dir)
      return DirStream(open_impl(dir))
   end

   public read()
      local t
      f_eof := &null
      if (*\line > 0) then {
         t := line[1:-1]
         line := ""
         return t
      }
      if t := read_impl(dd) then
         return t
   end

   public in(n)
      local t
      f_eof := &null
      if (*\line > 0) | (line := read_impl(dd) || EOL) then {
         line ? {
            t := move(n) | tab(0)
            line := tab(0)
         }
         return t
      }
   end

   private defer read_impl(dd)

   public defer close()

   public eof()
      return \.f_eof
   end

   public get_mode()
      return READ
   end

   private static defer open_impl(path)

   private new(dd)
      self.dd := dd
      return
   end
end

#
# This stream represents a pipe to a command running in a forked child
# process.  The pipe is either readable or writable, but not both.
#
class ProgStream(FileStream, NoCopy)
   private
      pid

   #
   # Open a new {ProgStream} based on the given command and flags.
   # @param cmd the command line to run
   # @param flags either {FileOpt.WRONLY} or {FileOpt.RDONLY}
   #
   public static open(cmd, flags)
      local l, mode
      if iand(flags, FileOpt.WRONLY) ~= 0 then
         mode := WRITE
      else
         mode := READ
      l := open_impl(cmd, flags) | fail
      return ProgStream(l[1], l[2], mode)
   end

   public defer close()

   private static defer open_impl(cmd, flags)

   private new(fd, pid, mode)
      cast(self,FileStream).new(fd, mode)
      self.pid := pid
      return
   end
end

#
# This class provides a {Stream} which stores its data in memory.  It
# can be used to efficiently concatenate together many strings, or as
# a convenient temporary stream.
#
class RamStream(Stream, NoCopy)
   private
      f_eof,
      ptr

   public defer in(n)

   public defer out(s)

   public defer seek(offset)

   public defer tell()

   public defer truncate(len)

   #
   # Return the current content of the {RamStream} as a string.
   #
   public defer str()

   public defer close()

   #
   # Close the stream and return the finished content as a string.
   #
   public done()
      local s
      s := str()
      close()
      return s
   end

   private static defer new_impl(s)

   public get_mode()
      return ALL
   end

   public eof()
      return \.f_eof
   end

   #
   # Create a new {RamStream}, with initial value of {s}.
   #
   # @param s the initial value of the stream; defaults to empty 
   # @      string.
   #
   public new(s)
      /s := ""
      ptr := new_impl(s)
      return
   end
end
