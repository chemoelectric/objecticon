############################################################################
#
#	File:     emptygen.icn
#
#	Subject:  Procedures for meta-translation code generation
#
#	Author:   Ralph E. Griswold
#
#	Date:     December 5, 1995
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#  This program is designed to be linked with the output of the meta-
#  translator.  As given here, they produce an identity translation.
#  Modifications can be made to effect different translations.
#
#  The procedures here are just wrappers.  This file is a skeleton that
#  can be used as a basis for code-generation procedures.
#
############################################################################
#
#  Bug:  The invocable declaration is not handled properly.  "invocable all"
#        will get by, but some other forms produce syntax errors.  The
#        problem is in the meta-translator itself, not in this program.
#
############################################################################
#
#  Links:  strings
#
############################################################################

package ipl.emptygen

procedure main(Mp)

   Mp()					# call meta-procedure

end

# e1 | e2
procedure Alt(e1, e2)			
end

# e1 ! e2
procedure Apply(e1, e2)			
end

# procedure argument (parameter)
procedure Arg(e)			
end

# e1 op e2
procedure Asgnop(op, e1, e2)		
end

# e1 ?:= e2
procedure Augscan(e1, e2)		
end

# e1 & e2
procedure Bamper(e1, e2)		
end

# e1 op e2
procedure Binop(op, e1, e2)		
end

# procedure body
procedure Body(es[])			
end

# break e
procedure Break(e)			
end

# case e of { caselist }
procedure Case(e, clist)		
end

# e1 : e2
procedure Cclause(e1, e2)		
end

# cclause1 ; cclause2
procedure Clist(cclause1, cclause2)	
end

# 'c'
procedure Clit(c)			
end

# { e1; e2; ... }
procedure Compound(es[])		
end

# create e
procedure Create(e)			
end

# default: e
procedure Default(e)			
end

# end
procedure End()				
end

# every e
procedure Every(e)			
end

# every e1 do e2
procedure EveryDo(e1, e2)		
end

# fail
procedure Fail()			
end

# e . f
procedure Field(e, f)			
end

# global v1, v2, ...
procedure Global(vs[])			
end

# if e1 then e2
procedure If(e1, e2)			
end

# if e1 then e2 else e3
procedure IfElse(e1, e2, e3)		
end

# i
procedure Ilit(i)			
end

# initial e
procedure Initial(e)			
end

# invocable s1, s2, ... (problem)
procedure Invocable(ss[])		
end

# e(e1, e2, ...)
procedure Invoke(e, es[])		
end

# &s
procedure Key(s)			
end

# e1 \ e2
procedure Limit(e1, e2)			
end

# link "v1, v2, ..."
procedure Link(vs[])			
end

# [e1, e2, ... ]
procedure List(es[])			
end

# local v1, v2, ...
procedure Local(vs[])			
end

# next
procedure Next()			
end

# not e
procedure Not(e)			
end

# &null
procedure Null()			
end

# (e1, e2, ... )
procedure Paren(es[])			
end

# e{e1, e2, ... }
procedure Pdco(e, es[])			
end

# procedure n(v1, v2, ...)
procedure Proc(n, vs[])			
end

# record n(f1, f2, ...)
procedure Record(n, fs[])		
end

# repeat e
procedure Repeat(e)			
end

# return e
procedure Return(e)			
end

# r
procedure Rlit(r)			
end

# e1 ? e2
procedure Scan(e1, e2)			
end

# e1[e2 op  e3]
procedure Section(op, e1, e2, e3)	
end

# "s"
procedure Slit(s)			
end

# static v1, v2, ..
procedure Static(vs[])			
end

# e1[e2]
procedure Subscript(e1, e2)		
end

# suspend e
procedure Suspend(e)			
end

# suspend e1 do e2
procedure SuspendDo(e1, e2)		
end

# e1 to e2
procedure To(e1, e2)			
end

# e1 to e2 by e3
procedure ToBy(e1, e2, e3)		
end

# |e
procedure Repalt(e)			
end

# op e
procedure Unop(op, e)			
end

# until e
procedure Until(e)			
end

# until e1 do e2
procedure UntilDo(e1, e2)		
end

# v
procedure Var(v)			
end

# while e
procedure While(e)			
end

# while e1 do e2
procedure WhileDo(e1, e2)		
end

