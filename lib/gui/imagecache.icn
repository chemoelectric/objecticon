package gui

import 
   graphics, 
   util,
   cairo,
   io,
   ipl.graphics

$ifdef _PNG
$load CLOCK "images/gui.CLOCK_24.png"
$load CLOSE "images/gui.CLOSE_24.png"
$load FONT "images/gui.FONT_24.png"
$load FILESIZE "images/gui.FILESIZE_24.png"
$else
$load CLOCK "images/gui.CLOCK_24.gif"
$load CLOSE "images/gui.CLOSE_24.gif"
$load FONT "images/gui.FONT_24.gif"
$load FILESIZE "images/gui.FILESIZE_24.gif"
$endif
$load HOME "images/gui.HOME_24.gif"
$load NEW_FOLDER "images/gui.NEW_FOLDER_24.gif"
$load REFRESH "images/gui.REFRESH_24.gif"
$load UP "images/gui.UP_24.gif"
$load PREV "images/gui.PREV_24.gif"
$load NEXT "images/gui.NEXT_24.gif"
$load HIDDENFILE "images/gui.HIDDENFILE_24.gif"
$load FAVOURITES "images/gui.FAVOURITES_24.gif"
$load CONFIGURE "images/gui.CONFIGURE_24.gif"
$load OPEN_FOLDER "images/gui.OPEN_FOLDER_16.gif"
$load CLOSED_FOLDER "images/gui.CLOSED_FOLDER_16.gif"
$load FILE "images/gui.FILE_16.gif"
$load WINDOW_CLOSE "images/gui.WINDOW_CLOSE_16.gif"
$load WINDOW_ICONIFY "images/gui.WINDOW_ICONIFY_16.gif"

$load CLOCK_SVG "images/gui.CLOCK_SVG.svgz"
$load FILESIZE_SVG "images/gui.FILESIZE_SVG.svgz"
$load FONT_SVG "images/gui.FONT_SVG.svgz"

final abstract class ImageCache()
   public static 
      imap,
      names

   private static init()
      local i, j
      names := table()
      imap := table()
      name_image("gui.HOME_24", HOME)
      name_image("gui.PREV_24", PREV)
      name_image("gui.NEXT_24", NEXT)
      name_image("gui.CLOSE_24", CLOSE)
      name_image("gui.NEW_FOLDER_24", NEW_FOLDER)
      name_image("gui.REFRESH_24", REFRESH)
      name_image("gui.UP_24", UP)
      name_image("gui.CLOCK_24", CLOCK)
      name_image("gui.FONT_24",FONT)
      name_image("gui.FILESIZE_24", FILESIZE)
      name_image("gui.HIDDENFILE_24", HIDDENFILE)
      name_image("gui.FAVOURITES_24", FAVOURITES)
      name_image("gui.CONFIGURE_24", CONFIGURE)
      name_image("gui.CLOSED_FOLDER_16", CLOSED_FOLDER)
      name_image("gui.OPEN_FOLDER_16", OPEN_FOLDER)
      name_image("gui.FILE_16", FILE)
      name_image("gui.WINDOW_CLOSE_16", WINDOW_CLOSE)
      name_image("gui.WINDOW_ICONIFY_16", WINDOW_ICONIFY)

      name_image("gui.CLOCK_SVG", CLOCK_SVG)
      name_image("gui.FILESIZE_SVG", FILESIZE_SVG)
      name_image("gui.FONT_SVG", FONT_SVG)

      i := scale_odd(13)
      j := scale(2)
      name_image("gui.BOX_UP", mk_box_up(i, j))
      name_image("gui.BOX_DOWN",  mk_box_down(i, j))
      name_image("gui.DIAMOND_UP", mk_diamond_up(i, j))
      name_image("gui.DIAMOND_DOWN",  mk_diamond_down(i, j))

      i := scale_odd(11)
      name_image("gui.ARROW_UP", mk_arrow_up(i))
      name_image("gui.ARROW_DOWN", mk_arrow_down(i))

      i := scale_odd(9)
      name_image("gui.ARROW_LEFT", mk_arrow_left(i))
      name_image("gui.ARROW_RIGHT", mk_arrow_right(i))

      i := scale_odd(7)
      name_image("gui.TINY_ARROW_UP", mk_arrow_up(i))
      name_image("gui.TINY_ARROW_DOWN", mk_arrow_down(i))

      i := scale(9)
      j := scale(1)
      name_image("gui.PLUS", mk_handle(i, j))
      name_image("gui.MINUS", mk_handle(i, j, &yes))

      i := scale_odd(5)
      j := scale(6)
      name_image("gui.VERT_GRID", mk_v_grid(i, j))
      name_image("gui.HORIZ_GRID", mk_h_grid(i, j))
   end

   # Associate arbitrary image data (eg gif file data), with a name.
   # The name can then be passed to {get} or {load} to retrieve a
   # window with the corresponding image.   It is a runtime error
   # if the key already exists in the table.
   #
   public static name_image(name, data)
      if member(names, name) then
         runerr("ImageCache duplicate name key", name)
      insert(names, name, data)
      return ImageCache
   end

   #
   # Given an existing key, add an entry to the name-data table with
   # `new_key`, pointing to the same data.  Fails if `key` is not an
   # existing key into the data table.
   #
   public static copy_name(new_key, key)
      return name_image(new_key, member(names, key))
   end

   #
   # Return the data previously set with {name_image}.  Fails if the
   # name is unknown.
   #
   public static get_named_image(name)
      return member(names, name)
   end

   #
   # Place an entry into the window cache with the given key.  The
   # window should not be subsequently closed.  It is a runtime error
   # if the key already exists in the table.
   #
   public static cache_window(key, win)
      if member(imap, key) then
         runerr("ImageCache duplicate image key", key)
      insert(imap, key, win)
      return ImageCache
   end

   #
   # Given an existing key, add an entry to the window cache with
   # `new_key`, pointing to the same window.  Fails if `key` is not an
   # existing key into the image table.
   #
   public static copy_key(new_key, key)
      return cache_window(new_key, member(imap, key))
   end

   #
   # Return an entry in the window cache, or fail if the key is not
   # present.
   #
   public static get_cached_window(key)
      return member(imap, key)
   end

   #
   # Load an image, using the cache if possible.  The parameter `s`
   # should be either a file name, or the name of an image set by
   # {name_image()}.  On a successful load, the image is stored in the
   # cache for future use, and thus should not be closed after use.
   #
   public static get(s, win)
      return member(imap, get_key(s, win))
   end

   #
   # This is the same as `get`, but returns the key into the cached
   # window map, rather than the window.  If it succeeds, then the
   # returned key will be in the map, and the window can be retrieved
   # by `get_cached_window`.
   #
   public static get_key(s, win)
      local w, key, p, fl
      key := s
      if s := member(names, s) then
         fl := &yes
      if is_image_string(s) then {
         if \win then
            key ||:= "#With colour "|| Window.color_value(win.get_fg()) || "/" || Window.color_value(win.get_bg())
         if w := member(imap, key) then
            return key
         \fl | return error("Invalid key for ImageCache")
         w := use {
            p := image_string_to_Pixels(s, win),
            Window.open_image(p)
         } | fail
      } else {
         if w := member(imap, key) then
            return key
         \fl | Files.access(key) | return error("Invalid key for ImageCache")
         w := Window.open_image(s) | fail
      }
      insert(imap, key, w)
      return key
   end

   #
   # Load an image without using the cache.  The parameter {s} should
   # be either a file name, or the name of an image set by
   # {name_image()}.  It may also be raw image data (unlike `get`).
   # The returned image should be closed after use.
   #
   public static load(s, win)
      local p
      s := member(names, s)
      return if is_image_string(s) then {
         use {
            p := image_string_to_Pixels(s, win),
            Window.open_image(p)
         }
      } else
         Window.open_image(s)
   end

   #
   # Convenient method to combine `copy_key` and `get_key_with_resize`
   #
   public static copy_key_with_resize(new_key, s, width, height, win)
      return copy_key(new_key, get_key_with_resize(s, width, height, win))
   end

   #
   # This is like `get`, but if the resulting window is not of the
   # given dimensions, then another window is created (and cached),
   # which is the result of resizing to the desired size.
   #
   public static get_with_resize(s, width, height, win)
      return member(imap, get_key_with_resize(s, width, height, win))
   end

   private static try_convert(s, width, height)
      return if s := member(names, s) then {
         if is_image_string(s) then
            fail
         run_convert(StringStream(s),
                     ["-resize", 
                      width || "x" || height,
                      "-",
                      "png:-"])
      } else
         run_convert(,
                     [s,
                      "-resize", 
                      width || "x" || height,
                      "png:-"])
   end

   #
   # Like `get_with_resize`, but returns the key rather than the
   # window.  `width` and `height` default to the value of `scale()`
   # applied to the raw image's dimensions.
   #
   public static get_key_with_resize(s, width, height, win)
      local w, key, w2
      key := get_key(s, win) | fail
      w := member(imap, key)
      /width := scale(w.get_width())
      /height := scale(w.get_height())
      if w.get_width() = width & w.get_height() = height then
         return key
      key ||:= "#Resized to " || width || "x" || height
      if member(imap, key) then
         return key
      (w2 := Window.open_image(try_convert(s, width, height))) | {
         w2 := Window().set_size(width, height)
         Zoom(w, w2)
      }
      insert(imap, key, w2)
      return key
   end

   #
   # This function takes an SVG filename, or key to named SVG data set
   # by `name_image()` (ie, an xml document), `s`, scales the SVG to
   # the given size, and returns a cached window.
   #
   public static get_scaled_svg(s, width, height)
      return member(imap, get_scaled_svg_key(s, width, height))
   end

   #
   # Like `get_scaled_svg`, but returns the key rather than the window.
   #
   public static get_scaled_svg_key(s, width, height)
      local w, key, cc, svg
      key := s || "#Scaled to " || width || "x" || height
      if member(imap, key) then
         return key
      (s := member(names, s)) | Files.access(s) | return error("Invalid key for ImageCache")
      svg := SVG(s) | fail
      w := Window().
         set_size(width, height).
         set_bg("transparent").
         erase_area()
      use {
         cc := Context(w).
            scale(real(width) / svg.get_width(), real(height) / svg.get_height()),
         svg.render(cc)
      }
      svg.close()
      insert(imap, key, w)
      return key
   end

   #
   # A convenient function to try to get a scaled SVG from the given
   # data `s`, but if SVG capability is not available then to use the
   # alternative conventional image `alt_s`, resized in either case to
   # the given dimensions.
   #
   public static get_scaled_svg_key_alt(s, alt_s, width, height)
      return if \Context.LOADED then 
         get_scaled_svg_key(s, width, height) 
      else 
         get_key_with_resize(alt_s, width, height)
   end
end
