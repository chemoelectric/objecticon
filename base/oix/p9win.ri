static int inited;
static vlong startup_time;
static wfp fonts;

static wsp alc_winstate(void);
static wcp alc_context(wbp w);
static wfp alc_font(wbp w, char **s);
static int configure_canvas(wbp w);
static void mouse_loop(wsp ws);
static void cons_loop(wsp ws);
static void flush_event_pipe(wsp ws);
static vlong get_time(void);
static int open_screen_win(wsp ws);
static void close_screen_win(wsp ws);
static int open_pix_win(wsp ws);
static void close_pix_win(wsp ws);
static void handle_resize(wsp ws);
static int init_window_system(void);
static void clear_pix(wbp wb);
static void clear_win(wbp wb);

#define EMAXMSG 128+8192     /* size of 9p header+data */

static void draw_error(Display *d, char *s)
{
    fprintf(stderr, "Draw error on display %p: %s\n", d, s);
}

wbp wopen(wbp parent, dptr attr, int n, int *err_index)
{
    wbp w;
    wsp ws;
    int i;
    char answer[128];
    tended struct descrip attrrslt;
    if (!inited) {
        if (!init_window_system())
            return 0;
        inited = 1;
    }

    w = alc_wbinding();
    ws = w->window = alc_winstate();
    w->context = alc_context(w);
    create_list(0, &ws->listp);

    /*
     * some defaults
     */
    ws->height = 100;
    ws->width  = 100;

    for (i = 0; i < n; i++){
        switch (wattrib((wbp) w, StrLoc(attr[i]), StrLen(attr[i]), &attrrslt, answer)) {
            case Error:
                free_binding(w);
                *err_index = i;
                return 0;
            case Failed:
                whyf("Bad window attribute: %.*s", (int)StrLen(attr[i]), StrLoc(attr[i]));
                free_binding(w);
                *err_index = -1;
                return 0;
        }
    }
    if (ws->windowlabel == NULL)
        ws->windowlabel = salloc(DEFAULT_WINDOW_LABEL);

    if (open_pix_win(ws) == Failed) {
        free_binding(w);
        return 0;
    }
    /* Fill pixmap with bg color */
    clear_pix(w);

    if (configure_canvas(w) != Succeeded) {
        free_binding(w);
        return 0;
    }

    return w;
}

static void printrect(char *s, Rectangle r)
{
    printf("%s: %d %d %d %d\n", s, r.min.x,r.min.y,r.max.x,r.max.y);
}

static void clear_pix(wbp w)
{
    wsp ws = w->window;
    Image *src = w->context->bg;
    gendraw(ws->pix, ws->pix->r, src, src->r.min, 0, ZP);
}

static void clear_win(wbp w)
{
    wsp ws = w->window;
    Image *src = w->context->bg;
    gendraw(ws->win, ws->win->r, src, src->r.min, 0, ZP);
}

static void copy_to(Image *dest, Image *src)
{
    Rectangle t = Rect(dest->r.min.x, 
                       dest->r.min.y,
                       dest->r.min.x + (src->r.max.x - src->r.min.x),
                       dest->r.min.y + (src->r.max.y - src->r.min.y));
    gendraw(dest, t, src, src->r.min, 0, ZP);
}

static void pix_to_win(wsp ws)
{
    copy_to(ws->win, ws->pix);
    flushimage(display, 1);
}

static void win_to_pix(wsp ws)
{
    copy_to(ws->pix, ws->win);
    flushimage(display, 1);
}

static int configure_canvas(wbp w)
{
    wsp ws = w->window;

    if (ISTOBEHIDDEN(ws)) {
        if (ws->win) {
            win_to_pix(ws);
            close_screen_win(ws);
        }
    } else {
        if (!ws->win) {
            if (open_screen_win(ws) == Failed)
                return Failed;
        }
        pix_to_win(ws);
    }
    return Succeeded;
}

static void mouse_loop(wsp ws)
{
    char buf[EMAXMSG + 9];
    int r;
    int tfd;

    buf[0] = 'M';
    tfd = open("/dev/bintime", OREAD);
    while ((r = read(ws->mouse_fd, buf + 9, EMAXMSG)) > 0) {
        if (tfd)
            pread(tfd, &buf[1], 8, 0);
        /*printf("buff=<<%s>>\n",buf+9);*/
        if (write(ws->event_pipe[1], buf, r + 9) != r + 9)
            break;
    }

    buf[0] = 'Q';
    write(ws->event_pipe[1], buf, 1);
    _exits(0);
}

static void cons_loop(wsp ws) 
{
    Rune r;
    char t[11], in[10];
    int tfd;

    t[0] = 'C';
    tfd = open("/dev/bintime", OREAD);
    while (read(ws->cons_fd, in, sizeof in) > 0) {
        if (tfd)
            pread(tfd, &t[1], 8, 0);
        chartorune(&r, in);
        t[9] = r;
        t[10] = r>>8;
        if (write(ws->event_pipe[1], t, 11) != 11)
            break;
    }

    t[0] = 'Q';
    write(ws->event_pipe[1], t, 1);
    _exits(0);
}

static wbp find_first_wbp_for(wsp ws)
{
    wbp wb;
    for (wb = wbndngs; wb; wb = wb->next)
        if (wb->window == ws)
            return wb;
    syserr("Couldn't find wbp for wsp");
}

static void handle_resize(wsp ws)
{
    char buff[128];
    sprintf(buff, "%s/winname", ws->mount_dir);
    printf("reconnecting to %s repl=%d\n",buff, ws->pix->repl);
    if (gengetwindow(display, buff, &ws->win, &ws->screen, Refnone) < 0)
        syserr("Failed to reconnect to window on a resize");
    /* Fill the win with the bg of the first context */
    clear_win(find_first_wbp_for(ws));
    pix_to_win(ws);
    close_pix_win(ws);
    ws->width = ws->win->r.max.x - ws->win->r.min.x;
    ws->height = ws->win->r.max.y - ws->win->r.min.y;
    printf("new size:%d %d\n",ws->width, ws->height);
    if (open_pix_win(ws) == Failed)
        syserr("Failed to open_pix_win on a resize");
    win_to_pix(ws);
}

static void flush_event_pipe(wsp ws)
{
    Dir *st;
    vlong length;
    int n;
    uchar ebuf[EMAXMSG + 1];
    tended struct descrip d;

    /* Check if pipe open */
    if (!ws->win || ws->event_pipe[0] < 0)
        return;

    for (;;) {
        /* Check if anything to read */
        st = dirfstat(ws->event_pipe[0]);
        if (!st)
            syserr("Couldn't stat event pipe");
        length = st->length;
        free(st);
        if (length == 0)
            return;

        n = read(ws->event_pipe[0], ebuf, sizeof(ebuf));
        if (n <= 0)
            return;

        switch (ebuf[0]) {
            case 'C' : {
                int i;
                vlong now;
                uword time;
                if (n != 11)
                    syserr("bad console data in event pipe");
                be2vlong(&now, &ebuf[1]);
                time = (now - startup_time) / 1000000;
                i = ebuf[9] + (ebuf[10]<<8);
                if (i < 256) {
                    /* Found a char string, so generate string event(s) */
                    StrLen(d) = 1;
                    StrLoc(d) = &allchars[i & 0xFF];
                } else if (i < 60000) {
                    d.dword = D_Ucs;
                    BlkLoc(d) = (union block *)make_one_char_ucs_block(i);
                } else 
                    MakeInt(i, &d);
                qevent(ws, &d, 0, 0, time, 0, 1);
                break;
            }
            case 'M': {
                int x, y, b, e = 0;
                vlong now;
                uword time;
                if(n < 10+2*12)
                    syserr("bad mouse data in event pipe");
                be2vlong(&now, &ebuf[1]);
                time = (now - startup_time) / 1000000;
                x = atoi((char*)ebuf+10+0*12) - ws->win->r.min.x;
                y = atoi((char*)ebuf+10+1*12) - ws->win->r.min.y;
                b = atoi((char*)ebuf+10+2*12);
                if (ebuf[9] == 'r') {
                    handle_resize(ws);
                    e = RESIZED;
                } else {
                    switch (b) {
                        case 0: {
                            if (ws->mouse_down) {
                                e = ws->mouse_down;
                                ws->mouse_down = 0;
                            } else {
                                if (ws->inputmask & PointerMotionMask)
                                    e = MOUSEMOVED;
                                else
                                    e = 0;
                            }
                            break;
                        }
                        case 1: {
                            if (ws->mouse_down)
                                e = MOUSELEFTDRAG;
                            else {
                                e = MOUSELEFT;
                                ws->mouse_down = MOUSELEFTUP;
                            }
                            break;
                        }
                        case 2: {
                            if (ws->mouse_down)
                                e = MOUSEMIDDRAG;
                            else {
                                e = MOUSEMID;
                                ws->mouse_down = MOUSEMIDUP;
                            }
                            break;
                        }
                        case 4: {
                            if (ws->mouse_down)
                                e = MOUSERIGHTDRAG;
                            else {
                                e = MOUSERIGHT;
                                ws->mouse_down = MOUSERIGHTUP;
                            }
                            break;
                        }
                        case 8: {
                            ws->mouse_down = MOUSE4UP;
                            break;
                        }
                        case 16: {
                            ws->mouse_down = MOUSE5UP;
                            break;
                        }
                        default: {
                        }
                    }
                }
                if (e) {
                    MakeInt(e, &d);
                    qevent(ws, &d, x, y, time, 0, 0);
                }
                break;
            }
        }
    }
}

int walert(wbp w, int volume)
{
    return Succeeded;
}

void unsetclip(wbp w)
{
}

void setclip(wbp w)
{
}

wcp clone_context(wbp w)
{
    return 0;
}

char *get_mutable_name(wbp w, int mute_index)
{
    return 0;
}

int set_mutable(wbp w, int i, char *s)
{
    return Failed;
}

int copyarea(wbp w,wbp w2,int x,int y,int wd,int h,int x2,int y2)
{
    return Succeeded;
}

int rebind(wbp w, wbp w2)
{
    return Succeeded;
}

void drawarcs(wbp w, XArc *arcs, int narcs) 
{
}

void drawlines(wbp w, XPoint *points, int npoints)
{
}

void drawpoints(wbp w, XPoint *points, int npoints)
{
}

static void impl_drawrectangles(wcp wc, Image *dest, XRectangle *recs)
{
    Point p[5];
    p[0] = addpt(dest->r.min, Pt(recs->x, recs->y));
    p[1] = Pt(p[0].x + recs->width, p[0].y);
    p[2] = Pt(p[0].x + recs->width, p[0].y + recs->height);
    p[3] = Pt(p[0].x, p[0].y + recs->height);
    p[4] = p[0];
    poly(dest, p, 5, Endsquare, Endsquare, 0, wc->fg, ZP);
}

void drawrectangles(wbp w, XRectangle *recs, int nrecs)
{
    wsp ws = w->window;
    wcp wc = w->context;
    while (nrecs-- > 0) {
        if (ws->win)
            impl_drawrectangles(wc, ws->win, recs);        
        impl_drawrectangles(wc, ws->pix, recs);        
        ++recs;
    }
    flushimage(display, 1);
}

void fillpolygon (wbp w, XPoint *pts, int npts)
{
}

void drawsegments(wbp w, XSegment *segs, int nsegs)
{
}

static void clip(wcp wc, Image *i)
{
    if (wc->clipw < 0)
        return;
    i->clipr = Rect(i->r.min.x + wc->clipx, 
                    i->r.min.y + wc->clipy, 
                    i->r.min.x + wc->clipx + wc->clipw, 
                    i->r.min.y + wc->clipy + wc->cliph);
    print("clipr=%R\n",i->clipr);
}

static void unclip(wcp wc, Image *i)
{
    i->clipr = i->r;
}

static void impl_drawstrng(wcp wc, Image *dest, int x, int y, char *str, int slen)
{
    printf("font=%p\n",wc->font->font);
    clip(wc, dest);
    stringn(dest, addpt(dest->r.min, Pt(x, y)), wc->fg, ZP, wc->font->font, str, slen);
    unclip(wc, dest);
}

void drawstrng(wbp w, int x, int y, char *str, int slen)
{
    wsp ws = w->window;
    wcp wc = w->context;
    if (ws->win)
        impl_drawstrng(wc, ws->win, x, y, str, slen);
    impl_drawstrng(wc, ws->pix, x, y, str, slen);
    flushimage(display, 1);
}

void drawutf8(wbp w, int x, int y, char *str, int slen)
{
}

int drawblimage(wbp w, int x, int y, int wd, int h,
                int ch, unsigned char *s, word len)
{
    return Succeeded;
}

int strimage(wbp w, int x, int y, int width, int height,
             struct palentry *e, unsigned char *s,
             word len, int on_icon)
{
    return 0;
}

void erasearea(wbp w, int x, int y, int width, int height)
{
}

void wsync (wbp w)
{
}

void pollevent(void)
{
    wsp ws;
    for (ws = wstates; ws; ws = ws->next)
        flush_event_pipe(ws);
}

int isetfg(wbp w, int fg)
{
    return Failed;
}

int setfg(wbp w, char *val)
{
    long r, g, b, a, n;
    wcp wc = w->context;
    if (parsecolor(w, val, &r, &g, &b, &a) != Succeeded)
        return Failed;
    if (wc->fgname) 
        free(wc->fgname);
    wc->fgname = salloc(val);
    if (wc->fg)
        freeimage(wc->fg);
    r /= 256;
    g /= 256;
    b /= 256;
    a /= 256;
    n = (r << 24) | (g << 16) | (b << 8) | a;
    printf("setfg %d %d %d %d -> %x\n", r,g,b,a,n);
    MemProtect(wc->fg = allocimage(display, Rect(0, 0, 1, 1), screen->chan, 1, n));
    return Succeeded;
}

void getfg(wbp w, char *answer)
{
    strcpy(answer, w->context->fgname);
}

int isetbg(wbp w, int bg)
{
    return Failed;
}

int setbg(wbp w, char *val)
{
    long r, g, b, a, n;
    wcp wc = w->context;
    if (parsecolor(w, val, &r, &g, &b, &a) != Succeeded)
        return Failed;
    if (wc->bgname) 
        free(wc->bgname);
    wc->bgname = salloc(val);
    if (wc->bg)
        freeimage(wc->bg);
    r /= 256;
    g /= 256;
    b /= 256;
    a /= 256;
    n = (r << 24) | (g << 16) | (b << 8) | a;
    printf("setbg %d %d %d %d -> %x\n", r,g,b,a,n);
    MemProtect(wc->bg = allocimage(display, Rect(0, 0, 1, 1), screen->chan, 1, n));
    return Succeeded;
}

void getbg(wbp w, char *answer)
{
    strcpy(answer, w->context->bgname);
}

void fillarcs(wbp w, XArc *arcs, int narcs)
{
}

void fillrectangles(wbp w, XRectangle *recs, int nrecs)
{
}

static char *convert_spec(char *s)
{
    int flags, size;
    char family[MAXFONTWORD+1], *r;
    static char buff[256];
    
    if (!strncmp(s, "p9:", 3))
        return s + 3;

    if (!parsefont(s, family, &flags, &size))
        return s;

    /*
     * Check for special "standard" family names.
     */
    if (!strcmp(family, "fixed"))
        r = "fixed/unicode.8x13.font";
    else if (!strcmp(family, "mono"))
        r = "courier/latin1.5.font";
    else if (!strcmp(family, "typewriter"))
        r = "courier/latin1.5.font";
    else if (!strcmp(family, "sans"))
        r = "lucidasans/latin1.7.font";
    else if (!strcmp(family, "serif"))
        r = "times/latin1.7.font";
    else
        r = "times/latin1.7.font";
            
    sprintf(buff, "/lib/font/bit/%s", r);
    printf("%s->%s\n",s,buff);
    return buff;
}

static wfp new_font(char *s)
{
    wfp rv;
    Font *f;

    f = openfont(display, convert_spec(s));
    if (!f)
        f = display->defaultfont;

    GRFX_ALLOC(rv, _wfont);
    rv->name = salloc(s);
    rv->font = f;
    GRFX_LINK(rv, fonts);
    return rv;
}

int setfont(wbp w, char *s)
{
    wcp wc = w->context;
    wfp rv;
    /*
     * See if the font is already loaded
     */
    for(rv = fonts; rv; rv = rv->next) {
        if (!strcmp(s, rv->name)) {
            wc->font = rv;
            return Succeeded;
        }
    }
    if (!(rv = new_font(s)))
        return Failed;

    wc->font = rv;
    return Succeeded;
}

void getfontname(wbp w, char *answer)
{
    strcpy(answer, w->context->font->name);
}

void free_mutable(wbp w, int mute_index)
{
}

void free_color(wbp w, char *s)
{
}

int lowerWindow (wbp w)
{
    return Succeeded;
}

int mutable_color (wbp w, dptr argv, int ac, int *retval)
{
    LitWhy("Mutable colors not supported");
    return Failed;
}

int setpattern(wbp w, char *name, int len)
{
    return Succeeded;
}

int setpatternbits(wbp w, int width, word *bits, int nbits)
{
    return Succeeded;
}

int getpixel_init(wbp w, struct imgmem *imem)
{
    return Succeeded;
}

int getpixel_term(wbp w, struct imgmem *imem)
{
    return Succeeded;
}

int getpixel(wbp w,int x,int y,word *rv,char *s,struct imgmem *im)
{
    return Succeeded;
}

int query_rootpointer(XPoint *pp)
{
    return Succeeded;
}

int raisewindow(wbp w)
{
    return Succeeded;
}

int readimage(wbp w, char *filename, int x, int y, int *status)
{
    return Succeeded;
}

int textwidth(wbp w, char *s, int n)
{
    return 0;
}

int utf8width(wbp w, char *s, int n)
{
    return 0;
}

int do_config(wbp w, int status)
{
    wsp ws = w->window;
    int have_win = 0;

    /* Dispose of window if open */
    if (ws->win) {
        have_win = 1;
        close_screen_win(ws);
    }
    if (status & 2) {
        /* Copy the pixmap to a temporary buffer */
        Image *t;
        MemProtect(t = allocimage(display, ws->pix->r, screen->chan, 1, DNofill));
        copy_to(t, ws->pix);
        close_pix_win(ws);
        if (open_pix_win(ws) == Failed)
            syserr("Failed to open_pix_win on a resize");
        clear_pix(w);
        copy_to(ws->pix, t);
        freeimage(t);
    }
    if (have_win) {
        if (open_screen_win(ws) == Failed)
            return Failed;
        pix_to_win(ws);
    }
    return Succeeded;
}

int getdefault(wbp w, char *prog, char *opt, char *answer)
{
    return Failed;
}

void wflush(wbp w)
{
}

int dumpimage (wbp w, char *filename, unsigned int x, unsigned int y,
               unsigned int width, unsigned int height)
{
    return NoCvt;
}

int own_selection(wbp w, char *selection)
{
    return Succeeded;
}

int request_selection(wbp w, char *selname, char *targetname)
{
    return Succeeded;
}

int send_selection_response(wbp w, word requestor, char *property, 
                            char *target, char *selection, word time, dptr data)
{
    return Succeeded;
}

static void kill_proc(int id)
{
    char buff[128];
    int fd;
    sprintf(buff, "/proc/%d/note", id);
    fd = open(buff, OWRITE);
    if (fd >= 0) {
        write(fd, "kill", 4);
        close(fd);
    }
}

static int open_screen_win(wsp ws)
{
    char *srvwsys, buff[256];
    srvwsys = getenv("wsys");
    if(srvwsys == 0) {
        LitWhy("Can't find $wsys");
        return 0;
    }
    ws->wsys_fd = open(srvwsys, ORDWR);
    if(ws->wsys_fd < 0) {
        whyf("Can't open $wsys(%s): %r", srvwsys);
        close_screen_win(ws);
        return Failed;
    }
    strcpy(ws->mount_dir, "/tmp");
    snprintf(buff, sizeof(buff), "new -r %d %d %d %d %s",
             ws->posx, ws->posy, ws->posx + ws->width + 2*Borderwidth, 
             ws->posy + ws->height + 2*Borderwidth, ws->windowlabel);
    if (mount(ws->wsys_fd, -1, "/tmp", MREPL, buff) < 0) {
        whyf("Can't mount new window: %r");
        close_screen_win(ws);
        return Failed;
    }
    if (gengetwindow(display, "/tmp/winname", &ws->win, &ws->screen, Refnone) < 0) {
        whyf("gengetwindow failed: %r");
        close_screen_win(ws);
        return Failed;
    }
    if (pipe(ws->event_pipe) < 0) {
        whyf("Couldn't init event pipe: %r");
        close_screen_win(ws);
        return Failed;
    }

    snprint(buff, sizeof buff, "%s/mouse", ws->mount_dir);
    ws->mouse_fd = open(buff, ORDWR|OCEXEC);
    if (ws->mouse_fd < 0) {
        whyf("Can't open mouse file %s: %r", buff);
        close_screen_win(ws);
        return Failed;
    }

    snprint(buff, sizeof buff, "%s/cons", ws->mount_dir);
    ws->cons_fd = open(buff, OREAD);
    if (ws->cons_fd < 0) {
        whyf("Can't open cons file %s: %r", buff);
        close_screen_win(ws);
        return Failed;
    }

    snprint(buff, sizeof buff, "%s/consctl", ws->mount_dir);
    ws->consctl_fd = open(buff, OWRITE|OCEXEC);
    if(ws->consctl_fd < 0) {
        whyf("Can't open consctl file %s: %r", buff);
        close_screen_win(ws);
        return Failed;
    }
    write(ws->consctl_fd, "rawon", 5);

    switch (ws->mouse_pid = rfork(RFPROC)) {
        case 0: {
            mouse_loop(ws);
            break;
        }
        case -1: {
            whyf("rfork failed: %r");
            close_screen_win(ws);
            return Failed;
        }
    }

    switch (ws->cons_pid = rfork(RFPROC)) {
        case 0: {
            cons_loop(ws);
            break;
        }
        case -1: {
            whyf("rfork failed: %r");
            close_screen_win(ws);
            return Failed;
        }
    }

    return Succeeded;
}

static void close_screen_win(wsp ws)
{
    unmount(0, ws->mount_dir);
    if (ws->event_pipe[0] >= 0)
        close(ws->event_pipe[0]);
    if (ws->event_pipe[1] >= 0)
        close(ws->event_pipe[1]);
    if (ws->consctl_fd >= 0)
        close(ws->consctl_fd);
    if (ws->mouse_fd >= 0)
        close(ws->mouse_fd);
    if (ws->cons_fd >= 0)
        close(ws->cons_fd);
    if (ws->mouse_pid >= 0)
        kill_proc(ws->mouse_pid);
    if (ws->cons_pid >= 0)
        kill_proc(ws->cons_pid);
    if (ws->wsys_fd >= 0)
        close(ws->wsys_fd);
    if (ws->win) {
        freeimage(ws->win);
        ws->win = 0;
    }
    if (ws->screen) {
        freescreen(ws->screen);
        ws->screen = 0;
    }
    ws->mount_dir[0] = 0;
    ws->event_pipe[0] = ws->event_pipe[1] = ws->mouse_fd = ws->cons_fd = ws->consctl_fd =
        ws->mouse_pid = ws->cons_pid = ws->wsys_fd = -1;
}

static int open_pix_win(wsp ws)
{
    MemProtect(ws->pix = allocimage(display, Rect(0, 0, ws->width, ws->height), screen->chan, 1, DNofill));
    return Succeeded;
}

static void close_pix_win(wsp ws)
{
    if (ws->pix) {
        freeimage(ws->pix);
        ws->pix = 0;
    }
}

void wclose(wbp w)
{
    wsp ws = w->window;
    pollevent();
    if (ws->win && ws->refcount > 1) {
        /* Turn into pixmap */
        SETTOBEHIDDEN(ws);
        configure_canvas(w); 
    }
}

void free_window(wsp ws)
{
   ws->refcount--;
   if(ws->refcount == 0) {
       if (ws->win)
           close_screen_win(ws);
       if (ws->pix)
           close_pix_win(ws);
       if (ws->windowlabel) { 
           free(ws->windowlabel); 
           ws->windowlabel=0;
       }
       if (ws->iconlabel) {
           free(ws->iconlabel); 
           ws->iconlabel=0;
       }
       GRFX_UNLINK(ws, wstates);
   }
}

void free_context(wcp wc)
{
    wc->refcount--;
    if(wc->refcount == 0) {
        if (wc->fgname) 
            free(wc->fgname);
        if (wc->fg)
            freeimage(wc->fg);
        if (wc->bgname) 
            free(wc->bgname);
        if (wc->bg)
            freeimage(wc->bg);
        GRFX_UNLINK(wc, wcntxts);
    }
}

int setminheight(wbp w, int new_height)
{
    return Succeeded;
}

int setminwidth(wbp w, int new_width)
{
    return Succeeded;
}

int nativecolor(wbp w, char *s, long *r, long *g, long *b)
{
    return 0; /* boolean rv */
}

int getimstr(wbp w, int x, int y, int width, int hgt,
             struct palentry *ptbl, unsigned char *data)
{
    return 0; /* boolean rv */
}

int setheight(wbp w, int new_height)
{
    wsp ws = w->window;
    ws->height = new_height;
    return Succeeded;
}

int setwidth(wbp w, int new_width)
{
    wsp ws = w->window;
    ws->width = new_width;
    return Succeeded;
}

int setposx(wbp w, int new_posx)
{
    wsp ws = w->window;
    ws->posx = new_posx;
    return Succeeded;
}

int setposy(wbp w, int new_posy)
{
    wsp ws = w->window;
    ws->posy = new_posy;
    return Succeeded;
}

int setinputmask(wbp w, char *val)
{
    wsp ws = w->window;
    if (strchr(val,'m'))
        ws->inputmask |= PointerMotionMask;
    else
        ws->inputmask &= ~PointerMotionMask;

    return Succeeded;
}

int allowresize(wbp w, int on)
{
    return Succeeded;
}

int setcanvas(wbp w, char *s)
{
    wsp ws = w->window;
    if (!strcmp(s, "iconic") || !strcmp(s, "maximal"))
        return Succeeded;
    printf("setcanvas %p %p\n",ws->win,ws->pix);
    if (!strcmp(s, "normal")) {
        CLRTOBEHIDDEN(ws);
    } else if (!strcmp(s, "hidden")) {
        SETTOBEHIDDEN(ws);
    } else
        return Error;

    /* If the window is already open, call configure_canvas now; otherwise it
     * is called from wopen after the rest of the arg
     */
    if (ws->win || ws->pix) {
        if (configure_canvas(w) == Failed)
            return Failed;
    }

    return Succeeded;
}

int seticonicstate(wbp w, char *s)
{
    return Succeeded;
}

int seticonlabel(wbp w, char *val)
{
    return Succeeded;
}

int seticonpos(wbp w, char *s)
{
    return Succeeded;
}

int setwindowlabel(wbp w, char *val)
{
    return Succeeded;
}

int setgamma(wbp w, double gamma)
{
    return Succeeded;
}

int setfillstyle(wbp w, char *s)
{
    return Succeeded;
}

int setlinestyle(wbp w, char *s)
{
    return Succeeded;
}

int setlinewidth(wbp w, int linewid)
{
    return Succeeded;
}

int setpointer(wbp w, char *val)
{
    return Succeeded;
}

int setdrawop(wbp w, char *val)
{
    return Succeeded;
}

int setdisplay(wbp w, char *s)
{
    return Succeeded;
}

int setimage(wbp w, char *val)
{
    return Succeeded;
}

void toggle_fgbg (wbp w)
{
}

void warppointer(wbp w, int x, int y)
{
}

int getvisual(wbp w, char *answer)
{
    strcpy(answer, "none");
    return Succeeded;
}

void getdisplay(wbp w, char *answer)
{
    strcpy(answer, "Plan9");
}

int seticonimage(wbp w, dptr dp)
{
    return Succeeded;
}

int getpos(wbp w)
{
    return Succeeded;
}

void getlinestyle(wbp w, char *answer)
{
    strcpy(answer, "none");
}

int query_pointer (wbp w, XPoint *pp)
{
    return Succeeded;
}

void getpointername(wbp w, char *answer)
{
    strcpy(answer, "none");
}

void getdrawop (wbp w, char *answer)
{
    strcpy(answer, "none");
}

void getcanvas (wbp w, char *answer)
{
    if (w->window->win)
        strcpy(answer, "normal");
    else
        strcpy(answer, "hidden");
}

void geticonic (wbp w, char *answer)
{
    strcpy(answer, "none");
}

int geticonpos(wbp w, char *answer)
{
    strcpy(answer, "none");
    return Succeeded;
}

static wsp alc_winstate()
{
    wsp ws;
    GRFX_ALLOC(ws, _wstate);
    ws->serial = ++canvas_serial;
    ws->bits = 1024;				/* echo ON; others OFF */
    ws->listp = nulldesc;
    ws->event_pipe[0] = ws->event_pipe[1] = ws->mouse_fd = ws->cons_fd = ws->consctl_fd =
        ws->mouse_pid = ws->cons_pid = ws->wsys_fd = -1;
    GRFX_LINK(ws, wstates);
    return ws;
}

static wcp alc_context(wbp w)
{
    wcp wc;
    GRFX_ALLOC(wc, _wcontext);
    wc->serial = ++context_serial;
    wc->clipx = wc->clipy = 0;
    wc->clipw = wc->cliph = -1;
    MemProtect(wc->fg = allocimage(display, Rect(0, 0, 1, 1), screen->chan, 1, DBlack));
    MemProtect(wc->bg = allocimage(display, Rect(0, 0, 1, 1), screen->chan, 1, DWhite));
    wc->fgname = salloc("black");
    wc->bgname = salloc("white");
    GRFX_LINK(wc, wcntxts);
    return wc;
}

static int init_window_system(void)
{
    if (initdraw(0, 0, "objecticon") < 0) {
        errno2why();
        return 0;
    }
    startup_time = get_time();
}

static vlong get_time()
{

    int f;
    uchar b[8];
    vlong t;

    memset(b, 0, sizeof b);
    f = open("/dev/bintime", OREAD);
    if(f >= 0) {
        pread(f, b, sizeof(b), 0);
        close(f);
    }
    be2vlong(&t, b);
    return t;
}
