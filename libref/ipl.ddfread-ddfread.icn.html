<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>ddfread.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     ddfread.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures for reading ISO 8211 DDF files
<a name="6"/>#
<a name="7"/>#	Author:   Gregg M. Townsend
<a name="8"/>#
<a name="9"/>#	Date:     June 26, 2000
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#	These procedures read DDF files ("Data Descriptive Files",
<a name="18"/>#	ISO standard 8211) such as those specified by the US Geological
<a name="19"/>#	Survey's "Spatial Data Transfer Standard" for digital maps.
<a name="20"/># 	ISO8211 files from other sources may contain additional data
<a name="21"/>#	encodings not recognized by these procedures.
<a name="22"/>#
<a name="23"/>#	ddfopen(filename) opens a file and returns a handle.
<a name="24"/>#	ddfdda(handle) returns a list of header records.
<a name="25"/>#	ddfread(handle) reads the next data record.
<a name="26"/>#	ddfclose(handle) closes the  file.
<a name="27"/>#
<a name="28"/>############################################################################
<a name="29"/>#
<a name="30"/>#	ddfopen(filename) opens a DDF file, decodes the header, and
<a name="31"/>#	returns an opaque handle for use with subsequent calls.  It
<a name="32"/>#	fails if any problems are encountered.  Instead of a filename,
<a name="33"/>#	an already-open file can be supplied.
<a name="34"/>#
<a name="35"/>############################################################################
<a name="36"/>#
<a name="37"/>#	ddfdda(handle) returns a list of records containing data
<a name="38"/>#	from the Data Descriptive Area (DDA) of the file header.
<a name="39"/>#	Each record contains the following fields:
<a name="40"/>#
<a name="41"/>#		tag	DDR entry tag
<a name="42"/>#		control	field control data
<a name="43"/>#		name	field name
<a name="44"/>#		labels	list of field labels
<a name="45"/>#		format	data format
<a name="46"/>#
<a name="47"/>#	The records may also contain other fields used internally.
<a name="48"/>#
<a name="49"/>############################################################################
<a name="50"/>#
<a name="51"/>#	ddfread(handle) reads the next data record from the file.
<a name="52"/>#	It returns a list of lists, with each sublist containing
<a name="53"/>#	a tag name followed by the associated data values, already
<a name="54"/>#	decoded according to the specification given in the header.
<a name="55"/>#
<a name="56"/>############################################################################
<a name="57"/>#
<a name="58"/>#	ddfclose(handle) closes a DDF file.
<a name="59"/>#
<a name="60"/>############################################################################
<a name="61"/>
<a name="62"/>
<a name="63"/>
<a name="64"/>$define RecSep "\x1E"		# ASCII Record Separator
<a name="65"/>$define UnitSep "\x1F"		# ASCII Unit Separator
<a name="66"/>$define EitherSep '\x1E\x1F'	# either separator, as cset
<a name="67"/>
<a name="68"/>$define LabelSep "!"		# label separator
<a name="69"/>$define AnySep	'!\x1E\x1F'	# any separator, as cset
<a name="70"/>
<a name="71"/>
<a name="72"/>
<a name="73"/>package ipl.ddfread
<a name="74"/>
<a name="75"/>import
<a name="76"/>   io(close, open, reads, Stream)
<a name="77"/>
<a name="78"/>record ddf_info(	# basic DDF file handle
<a name="79"/>   file,		# underlying file
<a name="80"/>   header,		# last header
<a name="81"/>   dlist,		# DDA list (of ddf_dde records)
<a name="82"/>   dtable		# DDA table (indexed by tag)
<a name="83"/>   )
<a name="84"/>
<a name="85"/>
<a name="86"/>record ddf_header(	# DDF header information
<a name="87"/>   hcode,		# header code (R if to reuse)
<a name="88"/>   dlen,		# data length
<a name="89"/>   ddata,		# dictionary data (as a string)
<a name="90"/>   tsize,		# size of tag field in dictionary
<a name="91"/>   lsize,		# size of length field
<a name="92"/>   psize,		# size of position field
<a name="93"/>   s			# header string
<a name="94"/>   )
<a name="95"/>
<a name="96"/>
<a name="97"/>record ddf_dde(		# data description entry
<a name="98"/>   tag,			# record tag
<a name="99"/>   control,		# field control
<a name="100"/>   name,		# field name
<a name="101"/>   rep,			# non-null if labels repeat to end of record
<a name="102"/>   labels,		# list of labels
<a name="103"/>   format,		# format
<a name="104"/>   dlist		# decoder list
<a name="105"/>   )
<a name="106"/>
<a name="107"/>
<a name="108"/>record ddf_decoder(	# field decoder record
<a name="109"/>   proc,		# decoding procedure
<a name="110"/>   arg			# decoder argument
<a name="111"/>   )
<a name="112"/>
<a name="113"/>
<a name="114"/>
<a name="115"/>#########################  PUBLIC PROCEDURES  #########################
<a name="116"/>
<a name="117"/>
<a name="118"/>
<a name="119"/>#  ddfopen(filename) -- open DDF file for input
<a name="120"/>#
<a name="121"/>#  Opens a DDF file, decodes the header, and returns an opaque handle h
<a name="122"/>#  for use with ddfread(h).  Fails if any problems are found.
<a name="123"/>
<a name="124"/># open DDF file
<a name="125"/>procedure ddfopen(fname)		
<a name="126"/>   local f, h, p, l, t, e
<a name="127"/>
<a name="128"/>   if is(fname, Stream) then
<a name="129"/>      f := fname
<a name="130"/>   else
<a name="131"/>      f := open(fname, "r")	| fail
<a name="132"/>
<a name="133"/>   h := ddf_rhdr(f)		| fail
<a name="134"/>   p := ddf_rdata(f, h)		| fail
<a name="135"/>   l := dda_list(p)		| fail
<a name="136"/>   t := table()
<a name="137"/>   every e := !l do
<a name="138"/>      t[e.tag] := e
<a name="139"/>   return ddf_info(f, h, l, t)
<a name="140"/>end
<a name="141"/>
<a name="142"/>
<a name="143"/>
<a name="144"/>#  ddfdda(handle) -- return list of DDAs
<a name="145"/>#
<a name="146"/>#  Returns a list of Data Descriptive Area records containing the
<a name="147"/>#  following fields:
<a name="148"/>#
<a name="149"/>#     tag	DDR entry tag
<a name="150"/>#     control	field control data
<a name="151"/>#     name	field name
<a name="152"/>#     labels	list of field labels
<a name="153"/>#     format	data format
<a name="154"/>#
<a name="155"/>#  (There may be other fields present for internal use.)
<a name="156"/>
<a name="157"/>procedure ddfdda(handle)
<a name="158"/>   return handle.dlist
<a name="159"/>end
<a name="160"/>
<a name="161"/>
<a name="162"/>
<a name="163"/>
<a name="164"/>#  ddfread(handle) -- read DDF record
<a name="165"/>#
<a name="166"/>#  Reads the next record using a handle returned by ddfopen().
<a name="167"/>#  Returns a list of lists, each sublist consisting of a
<a name="168"/>#  tag name followed by the associated data values
<a name="169"/>
<a name="170"/># read DDF record
<a name="171"/>procedure ddfread(handle)		
<a name="172"/>   local h, p, dlist, code, data, drec, sublist, e
<a name="173"/>
<a name="174"/>   h := handle.header
<a name="175"/>   if h.hcode ~== "R" then
<a name="176"/>      h := handle.header := ddf_rhdr(handle.file) | fail
<a name="177"/>   p := ddf_rdata(handle.file, h) | fail
<a name="178"/>   dlist := list()
<a name="179"/>   while code := get(p) do {
<a name="180"/>      data := get(p)
<a name="181"/>      drec := \handle.dtable[code] | next	# ignore unregistered code
<a name="182"/>      put(dlist, sublist := [code])
<a name="183"/>      data ? {
<a name="184"/>         until pos(0) do {
<a name="185"/>            every e := !drec.dlist do
<a name="186"/>               every put(sublist, e.proc(e.arg))
<a name="187"/>            if /drec.rep | (pos(-1) &amp; =RecSep) then
<a name="188"/>               break
<a name="189"/>            }
<a name="190"/>         }
<a name="191"/>      }
<a name="192"/>   return dlist
<a name="193"/>end
<a name="194"/>
<a name="195"/>
<a name="196"/>
<a name="197"/>#  ddfclose(handle) -- close DDF file
<a name="198"/>
<a name="199"/># close DDF file
<a name="200"/>procedure ddfclose(handle)		
<a name="201"/>   close(\handle.file)
<a name="202"/>   every !handle := &amp;null
<a name="203"/>   return
<a name="204"/>end
<a name="205"/>
<a name="206"/>
<a name="207"/>
<a name="208"/>#########################  INTERNAL PROCEDURES  #########################
<a name="209"/>
<a name="210"/>
<a name="211"/>
<a name="212"/>#  ddf_rhdr(f) -- read DDF header record
<a name="213"/>
<a name="214"/>procedure ddf_rhdr(f)
<a name="215"/>   local s,  tlen, hcode, off, nl, np, nx, nt, ddata
<a name="216"/>
<a name="217"/>   s := reads(f, 24)				| fail
<a name="218"/>   *s = 24					| fail
<a name="219"/>   s ? {
<a name="220"/>      tlen := integer(move(5))			| fail
<a name="221"/>      move(1)
<a name="222"/>      hcode := move(1)
<a name="223"/>      move(5)
<a name="224"/>      off := integer(move(5))			| fail
<a name="225"/>      move(3)					| fail
<a name="226"/>      nl := integer(move(1))			| fail
<a name="227"/>      np := integer(move(1))			| fail
<a name="228"/>      nx := move(1)				| fail
<a name="229"/>      nt := integer(move(1))			| fail
<a name="230"/>   }
<a name="231"/>   ddata := reads(f, off - 24)			| fail
<a name="232"/>   *ddata = off - 24				| fail
<a name="233"/>
<a name="234"/>   return ddf_header(hcode, tlen - off, ddata, nt, nl, np, s)
<a name="235"/>end
<a name="236"/>
<a name="237"/>
<a name="238"/>
<a name="239"/>#  ddf_rdata(f, h) -- read data, returning code/value pairs in list
<a name="240"/>
<a name="241"/>procedure ddf_rdata(f, h)
<a name="242"/>   local tag, len, posn, data, a, d
<a name="243"/>
<a name="244"/>   d := reads(f, h.dlen)			| fail
<a name="245"/>   if *d &lt; h.dlen then fail
<a name="246"/>   a := list()
<a name="247"/>   h.ddata ? until pos(0) do {
<a name="248"/>      if =RecSep then break
<a name="249"/>      tag := move(h.tsize)			| fail
<a name="250"/>      len := move(h.lsize)			| fail
<a name="251"/>      posn := move(h.psize)			| fail
<a name="252"/>      data := d[posn + 1 +: len]		| fail
<a name="253"/>      every put(a, tag | data)
<a name="254"/>      }
<a name="255"/>   return a
<a name="256"/>end
<a name="257"/>
<a name="258"/>
<a name="259"/>
<a name="260"/>#  dda_list(pairs) -- build DDA list from tag/data pairs
<a name="261"/>
<a name="262"/>procedure dda_list(p)
<a name="263"/>   local l, labels, tag, spec, control, name, format, d, rep
<a name="264"/>
<a name="265"/>   l := list()
<a name="266"/>   while tag := get(p) do {
<a name="267"/>      labels := list()
<a name="268"/>      spec := get(p)				| fail
<a name="269"/>      spec ? {
<a name="270"/>         control := move(6)			| fail
<a name="271"/>         name := tab(upto(EitherSep) | 0)
<a name="272"/>         move(1)
<a name="273"/>         rep := ="*"
<a name="274"/>         while put(labels, tab(upto(AnySep))) do {
<a name="275"/>            if =LabelSep then next
<a name="276"/>            move(1)
<a name="277"/>            break
<a name="278"/>            }
<a name="279"/>         format := tab(upto(EitherSep) | 0)
<a name="280"/>         move(1)
<a name="281"/>         pos(0)					| fail
<a name="282"/>         }
<a name="283"/>      d := ddf_dtree(format)			| fail
<a name="284"/>      put(l, ddf_dde(tag, control, name, rep, labels, format, d))
<a name="285"/>      }
<a name="286"/>
<a name="287"/>   return l
<a name="288"/>end
<a name="289"/>
<a name="290"/>
<a name="291"/>
<a name="292"/>#  ddf_dtree(format) -- return tree of decoders for format
<a name="293"/>#
<a name="294"/>#  keeps a cache to remember &amp; share decoder lists for common formats
<a name="295"/>
<a name="296"/>procedure ddf_dtree(format)
<a name="297"/>   static dcache
<a name="298"/>   initial {
<a name="299"/>      dcache := table()
<a name="300"/>      dcache[""] := [ddf_decoder(ddf_str, EitherSep)]
<a name="301"/>      }
<a name="302"/>
<a name="303"/>   /dcache[format] := ddf_fcrack(format[2:-1])
<a name="304"/>   return dcache[format]
<a name="305"/>end
<a name="306"/>
<a name="307"/>
<a name="308"/>
<a name="309"/>#  ddf_fcrack(s) -- crack format string
<a name="310"/>
<a name="311"/>procedure ddf_fcrack(s)
<a name="312"/>   local dlist, n, d
<a name="313"/>
<a name="314"/>   dlist := list()
<a name="315"/>   s ? until pos(0) do {
<a name="316"/>
<a name="317"/>      if (any(&amp;digits)) then
<a name="318"/>         n := tab(many(&amp;digits))
<a name="319"/>      else
<a name="320"/>         n := 1
<a name="321"/>
<a name="322"/>      d := &amp;null
<a name="323"/>      d := case move(1) of {
<a name="324"/>         ",":	next
<a name="325"/>         "A":	ddf_oneof(ddf_str, ddf_strn)
<a name="326"/>         "B":	ddf_oneof(&amp;null,   ddf_binn, 8)
<a name="327"/>         "I":	ddf_oneof(ddf_int, ddf_intn)
<a name="328"/>         "R":	ddf_oneof(ddf_real, ddf_realn)
<a name="329"/>         "(":	ddf_decoder(ddf_repeat, ddf_fcrack(tab(bal(')')), move(1)))
<a name="330"/>         }
<a name="331"/>      if /d then fail
<a name="332"/>      every 1 to n do
<a name="333"/>         put(dlist, d)
<a name="334"/>      }
<a name="335"/>   return dlist
<a name="336"/>end
<a name="337"/>
<a name="338"/>
<a name="339"/>
<a name="340"/>#  ddf_oneof(tabproc, moveproc, quantum) -- select one of two procs
<a name="341"/>
<a name="342"/>procedure ddf_oneof(tabproc, moveproc, quantum)
<a name="343"/>   local d, n
<a name="344"/>
<a name="345"/>   ="(" |
<a name="346"/>      return ddf_decoder(tabproc, EitherSep)
<a name="347"/>
<a name="348"/>   if any(&amp;digits) then {
<a name="349"/>      /quantum := 1
<a name="350"/>      n := integer(tab(many(&amp;digits)))
<a name="351"/>      n % quantum = 0					| fail
<a name="352"/>      d := ddf_decoder(moveproc, n / quantum)
<a name="353"/>      }
<a name="354"/>   else {
<a name="355"/>      d := ddf_decoder(\tabproc, move(1) ++ EitherSep)	| fail
<a name="356"/>      }
<a name="357"/>
<a name="358"/>   =")"							| fail
<a name="359"/>   return d
<a name="360"/>end
<a name="361"/>
<a name="362"/>
<a name="363"/>
<a name="364"/>#########################  DECODING PROCEDURES  #########################
<a name="365"/>
<a name="366"/>
<a name="367"/>
<a name="368"/># delimited string
<a name="369"/>procedure ddf_str(cs)			
<a name="370"/>   return 1(tab(upto(cs)), move(1))
<a name="371"/>end
<a name="372"/>
<a name="373"/># string of n characters
<a name="374"/>procedure ddf_strn(n)			
<a name="375"/>   return move(n)
<a name="376"/>end
<a name="377"/>
<a name="378"/># delimited integer
<a name="379"/>procedure ddf_int(cs)			
<a name="380"/>   local s
<a name="381"/>   s := tab(upto(cs))
<a name="382"/>   move(1)
<a name="383"/>   return integer(s) | 0
<a name="384"/>end
<a name="385"/>
<a name="386"/># integer of n digits
<a name="387"/>procedure ddf_intn(n)			
<a name="388"/>   local s
<a name="389"/>   s := move(n)
<a name="390"/>   return integer(s) | 0
<a name="391"/>end
<a name="392"/>
<a name="393"/># delimited real
<a name="394"/>procedure ddf_real(cs)			
<a name="395"/>   local s
<a name="396"/>   s := tab(upto(cs))
<a name="397"/>   move(1)
<a name="398"/>   return real(s) | 0.0
<a name="399"/>end
<a name="400"/>
<a name="401"/># real of n digits
<a name="402"/>procedure ddf_realn(n)			
<a name="403"/>   local s
<a name="404"/>   s := move(n)
<a name="405"/>   return real(s) | 0.0
<a name="406"/>end
<a name="407"/>
<a name="408"/># binary value of n bytes
<a name="409"/>procedure ddf_binn(n)			
<a name="410"/>   local v, c
<a name="411"/>   v := c := ord(move(1))
<a name="412"/>   every 2 to n do
<a name="413"/>      v := 256 * v + ord(move(1))
<a name="414"/>   if c &lt; 128 then	# if sign bit unset in first byte
<a name="415"/>      return v
<a name="416"/>   else
<a name="417"/>      return v - ishift(1, 8 * n)
<a name="418"/>end
<a name="419"/>
<a name="420"/># repeat sublist to EOR
<a name="421"/>procedure ddf_repeat(lst)		
<a name="422"/>   local e
<a name="423"/>   repeat {
<a name="424"/>      every e := !lst do {
<a name="425"/>         if (=RecSep | &amp;null) &amp; pos(0) then
<a name="426"/>            fail
<a name="427"/>         else
<a name="428"/>            suspend e.proc(e.arg)
<a name="429"/>         }
<a name="430"/>      }
<a name="431"/>end
</pre></body></html>
