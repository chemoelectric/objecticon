package ipl.browser

import 
   gui,
   ipl.strings

abstract class HasAscent()
   public abstract get_ascent(dw, dh)
end

abstract class HasMaxWidth()
   public abstract get_max_width()
end

abstract class TextFlowCmd()
  public const attr

   public new(attr)
      self.attr := attr
      return
   end
end

class ComponentCmd(TextFlowCmd)
   public const c, align

   public new(c, attr, align)
      self.c := c
      self.attr := attr
      self.align := align
      return
   end
end

class TextCmd(TextFlowCmd)
  public const s

   public new(s, attr)
      self.s := s
      self.attr := attr
      return
   end
end

class NamedAnchorCmd(TextFlowCmd)
   public const
      name

   public new(name, attr)
      self.name := name
      self.attr := attr
      return
   end
end

class NewRowCmd(TextFlowCmd) end
class ParaCmd(TextFlowCmd) end
class SupStartCmd(TextFlowCmd) end
class SupEndCmd(TextFlowCmd) end
class SubStartCmd(TextFlowCmd) end
class SubEndCmd(TextFlowCmd) end

class BreakCmd(TextFlowCmd)
   public const clear

   public new(clear, attr)
      self.clear := clear
      self.attr := attr
      return
   end
end

class TextOut(Rect)
   public const s, attr, ascent, descent

   public new(attr, s, ascent, descent, w, h)
      self.attr := attr
      self.s := s
      self.ascent := ascent
      self.descent := descent
      self.w := w
      self.h := h
      return
   end
end

class CompOut(Rect)
   public const c, align, attr, pw, maxw
   public ascent, descent

   public set_height_from_width()
      h := c.get_preferred_height(w)
      h <:= integer(c.get_constraint("fix_h"))
      return self
   end

   public new(attr, c, align, pw, maxw)
      self.attr := attr
      self.c := c
      self.align := align
      self.pw := pw
      self.maxw := maxw
      return
   end
end

class TextSelection()
   public const textout, textflow, i, j, w_off, w_sub, h

   public get_bounds()
      return Rect(textflow.x + textflow.border.get_l_inset() + textout.x + w_off,
                  textflow.y + textflow.border.get_t_inset() + textflow.y_off + textout.y,
                  w_sub,
                  textout.h)
   end

   public new(textout, textflow, i, j, w_off, w_sub)
      self.textout := textout
      self.textflow := textflow
      self.i := i
      self.j := j
      self.w_off := w_off
      self.w_sub := w_sub
      return
   end
end

class OutputRow(Rect)
   public const l

   public new()
      l := []
      return
   end
end

class TextFlow(Component)
   public const
      input

   private readable
      y_off

   private
      left_comps,
      right_comps,
      output_comps,
      output_rows,
      computed_output_rows,
      row,
      row_x,
      row_y,
      row_bottom,
      row_width,
      row_ascent,
      first_row_ascent,
      row_descent,
      baseline_off,
      row_abs_middle_height,
      row_abs_top_height,
      row_abs_bottom_height,
      max_pre_w,
      max_word_w,
      max_ll,
      calculating,
      need_spc,
      right_margin,
      compute_w,
      deferred,
      v_align,
      at_new_para,
      def_width,
      max_width,
      held,
      wrote,
      dominant_width,
      computed_named_anchors,
      named_anchors,
      browser

   public static const 
      WHITESPACE,
      PREFERRED_WIDTH,
      MAX_WIDTH

   private static init()
      WHITESPACE := ' \t\r\n\v\f'
      PREFERRED_WIDTH := 1
      MAX_WIDTH := 2
   end

   private compute(width)
      /width := 16r7fffffff
      if width === compute_w then 
         return
      compute_w := width
      calculating := if width = 16r7fffffff then 1 else &null
      output_comps := []
      output_rows := []
      left_comps := []
      right_comps := []
      named_anchors := table()
      row := []
      deferred := []
      at_new_para := 1
      row_width := row_y := row_bottom := row_x := max_pre_w := max_word_w := max_ll := 
         baseline_off := row_abs_middle_height := row_abs_top_height :=
         row_abs_bottom_height := row_ascent := row_descent := 0
      right_margin := compute_w
      need_spc := first_row_ascent := &null
      compute1(, input)
      while *(row | deferred) > 0 do
         new_row()
      if \calculating then {
         # Ensure that we have cleared any left/right images, so that
         # we calculate max_ll correctly (which we only need if
         # calculating).
         until have_max() do 
            new_row()
      }
   end

   public set_v_align(v)
      self.v_align := v
      return self
   end

   public reset_layout()
      max_width := def_width := output_rows := output_comps := left_comps :=
         named_anchors := right_comps := compute_w := &null
   end

   public set_dominant_width(x)
      self.dominant_width := x
      return self
   end

   public get_default_width()
      local c
      if dominant_width === MAX_WIDTH then
         return get_max_width()
      if /def_width then {
         compute()
         def_width := max_pre_w
         every c := !output_comps do
            def_width <:= c.pw
         def_width <:= max_word_w
         def_width +:= border.get_total_width()
      }
      return def_width
   end

   public get_max_width()
      if dominant_width === PREFERRED_WIDTH then
         return get_preferred_width()
      if /max_width then {
         compute()
         max_width := max_ll + border.get_total_width()
      }
      return max_width
   end

   public get_default_height(dw)
      local mh, co
      dw -:= border.get_total_width()
      compute(dw)
      mh := row_bottom
      every co := !left_comps | !right_comps do
        mh <:= co.y + co.h
      return mh + border.get_total_height()
   end

   public get_first_row_ascent(dw)
      dw -:= border.get_total_width()
      compute(dw)
      return \first_row_ascent | 0
   end

   private compute1()
      local cmd, font, W
      W := cbwin.clone()
      every cmd := !input do {
         if font ~=== cmd.attr.font then {
            W.close()
            W := attr_clone(cmd.attr)
            font := cmd.attr.font
         } 
         case classof(cmd) of {
            ComponentCmd: 
               compute_component(cmd)
            NewRowCmd: {
               # Avoid 1-pixel gap, which would be added if *row=0
               if *row > 0 then
                  new_row()
            }
            ParaCmd: {
               if /at_new_para then {
                  new_row(W.get_font_height() / 2)
                  at_new_para := 1
               }
            }

            SupStartCmd: baseline_off +:= W.get_font_ascent() / 2
            SupEndCmd: baseline_off -:= W.get_font_ascent() / 2
            SubStartCmd: baseline_off -:= W.get_font_ascent() / 3
            SubEndCmd: baseline_off +:= W.get_font_ascent() / 3

            BreakCmd: {
               if *row > 0 then
                  new_row()
               else
                  new_row(W.get_font_height())
               case \cmd.clear of {
                  Align.L: 
                     until row_x = 0 do new_row()
                  Align.R:
                     until right_margin = compute_w do new_row()
                  "all":
                     until have_max() do new_row()
               }
            }
            NamedAnchorCmd: {
               insert(named_anchors, string(cmd.name), row_y)
            }
            TextCmd: {
               if \cmd.attr.pre then
                  compute_pre_txt(W, cmd)
               else
                  compute_txt(W, cmd)
            }
         }
      }
      W.close()
   end

   public lookup_named_anchor(name)
      local yp
      if yp := member(\computed_named_anchors, string(name)) then
         return yp + y + border.get_t_inset() + y_off
   end

   private attr_clone(attr)
      local W
      W := cbwin.clone()
      W.set_fg(attr.fg)
      W.set_font(attr.font)
      return W
   end

   private rows_in_range(ry, rh)
      local i, j, m, or
      # Shortcut for very common case
      if *computed_output_rows = 1 then {
         or := computed_output_rows[1]
         return if or.y + or.h > ry  &  or.y < ry + rh then or
      }
      i := 1
      j := *computed_output_rows
      while i <= j do {
         m := (i + j) / 2
         or := computed_output_rows[m]
         if or.y + or.h <= ry then
            i := m + 1
         else if or.y >= ry + rh then
            j := m - 1
         else
            break
      }
      if i > j then
         fail

      # Now row m is in the sought range; but rows before may be too,
      # so tab back as far as needed.
      while or := computed_output_rows[m - 1] &
         or.y + or.h > ry  &  or.y < ry + rh do
         m -:= 1

      # Now suspend all the rows in range from row m forwards.
      while or := computed_output_rows[m] &
         or.y + or.h > ry  &  or.y < ry + rh do
      {
         suspend or
         m +:= 1
      }
   end

   public display()
      local o, W, font, fg, x1, y1, x2, y2, r, t, ts, or
      border.draw(self.cbwin, x, y, w, h)
      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      W := cbwin.clone()
      r := get_cbwin_clip()
      every or := rows_in_range(r.y - y1, r.h) do {
         every o := !or.l do {
            t := Rect(x1 + o.x, y1 + o.y, o.w, o.h)
            if r.intersect(t) then {
               if font ~=== o.attr.font | fg ~=== o.attr.fg then {
                  W.close()
                  W := attr_clone(o.attr)
                  font := o.attr.font
                  fg := o.attr.fg
               } 

               draw_string_ex(W, x1 + o.x, y1 + o.y, o.s)
               if ts := browser.is_banded(o) then {
                  # NB - the rectangle used should be the same as that returned by t.get_bounds()
                  Gui.style.fill_selection_rectangle(cbwin, 
                                                     x1 + o.x + ts.w_off,
                                                     y1 + o.y, 
                                                     ts.w_sub,
                                                     o.h)
               }
               if \o.attr.underline then {
                  x2 := x1 + o.x
                  y2 := y1 + o.y + W.get_font_ascent() + 1
                  W.draw_line(x2, y2, x2 + o.w, y2)
               }
               if \o.attr.strike then {
                  x2 := x1 + o.x
                  y2 := y1 + o.y + (2 * W.get_font_ascent()) / 3
                  W.draw_line(x2, y2, x2 + o.w, y2)
               }
            }
         }
      }
      W.close()
      cast(self,Component).display()
   end

   public calculate_banded(br, bs)
      local d, i, u, j, or, o, W, font, x1, y1, t, first, last, first_r, last_r, l, ts
      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      l := []
      every or := rows_in_range(br.y - y1, br.h) do {
         every o := !or.l do {
            t := Rect(x1 + o.x, y1 + o.y, o.w, o.h)
            if t := br.intersect(t) then {
               if /first := o then
                  first_r := t
               last := o
               last_r := t
            }
            if \first then
               put(l, o)
         }
      }
      if /first then
         fail
      until l[-1] === last do
         pull(l)

      W := cbwin.clone()
      every o := !l do {
         if font ~=== o.attr.font then {
            W.close()
            W := attr_clone(o.attr)
            font := o.attr.font
         } 
         i := 1
         if o === first then {
            d := first_r.x - x1 - o.x
            u := 0
            while i <= *o.s & ((.u + (u := W.text_width(o.s[1+:i]))) / 2) < d do
               i +:= 1
         }
         if o === last then {
            d := last_r.x - x1 - o.x + last_r.w
            j := i
            u := W.text_width(o.s[1:i])
            while j <= *o.s & ((.u + (u := W.text_width(o.s[1+:j]))) / 2) < d do
               j +:= 1
         } else
            j := *o.s + 1

         if i < j then {
            ts := TextSelection(o, self, 
                                i, j, 
                                W.text_width(o.s[1:i]), W.text_width(o.s[i:j]))
            insert(bs, o, ts)
         }
      }
      W.close()
   end

   public get_selected_text(br)
      local o, x1, y1, t, or, s, sr
      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      s := u""
      every or := rows_in_range(br.y - y1, br.h) do {
         sr := u""
         every o := !or.l do {
            if t := browser.is_banded(o) then
               sr ||:= o.s[t.i:t.j]
         }
         if *sr > 0 then {
            if *s > 0 then
               s ||:= u"\n"
            s ||:= sr
         }
      }
      if *s > 0 then
         return s
   end

   public calculate_link_text(t)
      local o, or, u, u2, or2
      every or := !computed_output_rows do {
         every o := !or.l do {
            if u := \o.attr.url then {
               if u === u2 & or ~=== or2 then
                  t[u] ||:= u" "
               t[u] ||:= o.s
               u2 := u
               or2 := or
            }
         }
      }
   end

   public layout()
      local co, c, x1, y1
      compute(self.w - border.get_total_width())
      y_off := case v_align of {
         Align.T: 0
         Align.C: (h - get_default_height(w)) / 2
         Align.B: h - get_default_height(w)
         default: runerr("invalid v_align", v_align)
      }

      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      every co := !output_comps do {
         c := co.c
         c.x := co.x + x1
         c.y := co.y + y1
         c.w := co.w
         c.h := co.h
         c.layout()
      }
      computed_output_rows := output_rows
      computed_named_anchors := named_anchors 
   end

   private new_row(gap)
      local x1, r, g, need, or, row_height
      /gap := 0
      if *row > 0 then {
         x1 := row_x

         # Expand space for comps relative to absolute top
         row_descent <:= row_abs_top_height - row_ascent

         # and to absolute bottom
         row_ascent <:= row_abs_bottom_height - row_descent

         # finally absolute middle
         need := row_abs_middle_height - (row_ascent + row_descent)
         if need > 0 then {
            row_ascent +:= need / 2
            row_descent +:= need / 2 + need % 2
         }

         row_height := row_ascent + row_descent

         if /calculating then {
            put(output_rows, or := OutputRow())
            or.x := row_x
            or.y := row_y
            or.h := row_height
            or.w := row_width
         }
         row_bottom := row_y + row_height

         /first_row_ascent := row_ascent      
         while r := get(row) do {
            if /calculating & x1 = row_x then {
               case r.attr.align of {
                  Align.C:
                     x1 +:= (right_margin - row_width - row_x) / 2
                  Align.R:
                     x1 +:= right_margin - row_width - row_x
               }
            }
            if is(r, CompOut) then {
               r.x := x1
               r.y := case r.align of {
                  Align.C: row_y + row_ascent - r.h / 2
                  Align.B: row_y + row_ascent - r.ascent
                  Align.T: row_y
                  "absbottom": row_y + row_height - r.h
                  "absmiddle": row_y + (row_height - r.h) / 2
                  default: runerr("invalid alignment", r.align)
               }
               x1 +:= r.w
            } else {
               r.x := x1
               r.y := row_y + row_ascent - r.ascent
               x1 +:= r.w
               put((\or).l, r)
            }
            if \calculating & \r.attr.pre then
               # Since a pre section can still have several elements on a
               # line (eg with an <a> in a line), we need to record the
               # maximum width of the line.
               max_pre_w <:= r.x + r.w - row_x
         }

         row_y +:= row_height + gap
      } else
         row_y +:= 1

      if \calculating then
         max_ll <:= compute_w - (right_margin - row_width - row_x)

      row_width := row_abs_middle_height := row_abs_top_height := row_abs_bottom_height := row_ascent := row_descent := 0

      row_x := 0
      every g := !left_comps do
         if g.y <= row_y < g.y + g.h then
            row_x <:= g.x + g.w

      right_margin := compute_w
      every g := !right_comps do
         if g.y <= row_y < g.y + g.h then
            right_margin >:= g.x

      while do_deferred(deferred[1]) do
         pop(deferred)
   end

   private fits_in_row_with_maxw(co)
      return have_max() | (row_x + co.maxw + row_width <= right_margin)
   end

   private fits_in_row_with_pw(co)
      return have_max() | (row_x + co.pw + row_width <= right_margin)
   end

   private do_deferred(co)
      case co.align of {
         Align.L: {
            if fits_in_row_with_maxw(co) then {
               left_comp_out(co)
               return
            }
         }
         Align.R: {
            if fits_in_row_with_maxw(co) then {
               right_comp_out(co)
               return
            }
         }
      }
   end

   private left_comp_out(co)
      co.x := row_x
      co.y := row_y
      co.w := min(co.maxw, right_margin - row_x - row_width)
      co.set_height_from_width()
      row_x +:= co.w
      put(left_comps, co)
   end

   private right_comp_out(co)
      co.w := min(co.maxw, right_margin - row_x - row_width)
      co.x := right_margin - co.w
      co.y := row_y
      co.set_height_from_width()
      right_margin -:= co.w
      put(right_comps, co)
   end

   package is_top_level()
      return self === browser.view.inner
   end

   private compute_component(cmd)
      local co, prefw, maxw, i
      prefw := cmd.c.get_preferred_width()
      maxw := if is(cmd.c, HasMaxWidth) then cmd.c.get_max_width() else prefw

      # Apply constraints
      if i := cmd.c.get_constraint("fix_w") then
         prefw := maxw := max(i, prefw)
      else if i := integer(cmd.c.get_constraint("pct_w")) then {
         case classof(cmd.c) of {
            Line: {
               if /calculating then
                  prefw := maxw := max(((right_margin - row_x - row_width) * i) / 100, prefw)
            }
            Img: {
               if /calculating then
                  prefw := maxw := max((compute_w * i) / 100, prefw)
               else {
                  # Since prefw/maxw is set to 1 (see Img), we set it
                  # to the actual image size, so the max width is calculated
                  # on that basis.
                  if not is_top_level() then
                     maxw := (\cmd.c.win).get_width()
               }
            }
            Tbl: {
               if /calculating then
                  prefw := maxw := max((compute_w * i) / 100, prefw)
            }
            default: syserr("Invalid type with pct_w")
         }
      }
      co := CompOut(cmd.attr, cmd.c, cmd.align, prefw, maxw)
      put(output_comps, co)
      case cmd.align of {
         Align.L: {
            # If already have deferred, then defer this too, otherwise they will be out of order. 
            if *deferred = 0 & fits_in_row_with_maxw(co) then
               left_comp_out(co)
            else
               put(deferred, co)
         }
         Align.R: {
            if *deferred = 0 & fits_in_row_with_maxw(co) then 
               right_comp_out(co)
            else
               put(deferred, co)
         }
         Align.B: {
            comp_out(co)
            row_ascent <:= co.ascent
            row_descent <:= co.descent
         }
         Align.T: {
            comp_out(co)
            row_abs_top_height <:= co.h
         }
         Align.C: {
            comp_out(co)
            row_ascent <:= co.h / 2
            row_descent <:= co.h / 2 + co.h % 2
         }
         "absbottom": {
            comp_out(co)
            row_abs_bottom_height <:= co.h
         }
         "absmiddle": {
            comp_out(co)
            row_abs_middle_height <:= co.h
         }
         default: runerr("invalid alignment", cmd.align)
      }
   end

   private comp_out(co)
      local c
      c := co.c
      until fits_in_row_with_pw(co) do
         new_row()
      co.w := min(co.maxw, right_margin - row_x - row_width)
      co.set_height_from_width()
      co.ascent := (if is(co.c, HasAscent) then co.c.get_ascent(co.w, co.h) else co.h) + baseline_off
      co.descent := co.h - co.ascent
      # A component cancels outstanding ws before the line eg the \n after the <br> is ignored
      # begin<br>
      # <img src="/tmp/j3.jpeg">is some stuff
      if *row = 0 then
         need_spc := &null
      at_new_para := &null
      put(row,  co)
      row_width +:= co.w
   end

   private txt_out(W, attr, s)
      local xo
      xo := TextOut(attr, s, 
                    W.get_font_ascent() + baseline_off, 
                    W.get_font_descent() - baseline_off, 
                    W.text_width(s), W.get_font_height())
      put(row,  xo)
      row_width +:= xo.w
      row_ascent <:= xo.ascent
      row_descent <:= xo.descent
      at_new_para := &null
   end

   private have_max()
      return *row = 0 & row_x = 0 & right_margin = compute_w
   end

   private compute_txt(W, cmd)
      local ds, ds2, tw, attr, wd, l, i
      attr := cmd.attr
      ds := u""
      l := []
      if any(WHITESPACE, cmd.s) then
         need_spc := 1
      every put(l, words(cmd.s, WHITESPACE))
      while wd := get(l) do {
         max_word_w <:= W.text_width(wd)
         if *ds = 0 then {
            # Never put a space at the start of a row.
            if *row > 0 & \need_spc then
               ds2 := u" " || wd
            else
               ds2 := wd
            need_spc := &no
         } else
            ds2 := ds || u" " || wd
         tw := W.text_width(ds2)
         if row_x + row_width + tw > right_margin then {
            if *ds = 0 then {
               if have_max() then {
                  i := *wd + 1
                  while i > 2 &
                     row_x + row_width +  W.text_width(wd[1:i]) > right_margin do
                     i -:= 1
                  txt_out(W, attr, wd[1:i])
                  new_row()
                  push(l, u"" ~== wd[i:0])
               } else {
                  new_row()
                  push(l, wd)
               }
            } else {
               txt_out(W, attr, ds)
               new_row()
               ds := u""
               push(l, wd)
            }
         } else
            ds := ds2
      }
      if *ds > 0 then
         txt_out(W, attr, ds)
      if any(WHITESPACE, cmd.s[-1]) then
         need_spc := 1
   end

   private compute_pre_txt(W, cmd)
      local s, tw, attr, l, i, s2, nl
      attr := cmd.attr
      l := []

      cmd.s ? until pos(0) do
         put(l, detab( (tab(upto('\n')) || move(1)) | tab(0)))

      while s := get(l) do {
         s2 := s
         if s2[-1] == u"\n" then {
            s2[-1] := u""
            if s2[-1] == u"\r" then
               s2[-1] := u""
            nl := &yes
         } else
            nl := &no
         tw := W.text_width(s2)
         if row_x + row_width + tw > right_margin then {
            if have_max() then {
               i := *s2 + 1
               while i > 2 &
                  row_x + row_width +  W.text_width(s2[1:i]) > right_margin do
                  i -:= 1
               txt_out(W, attr, s2[1:i])
               new_row()
               push(l, u"" ~== s[i:0])
            } else {
               new_row()
               push(l, s)
            }
         } else {
            txt_out(W, attr, s2)
            if \nl then
               new_row()
         }
      }
   end

   private which_text_out(e)
      local or, o, x1, y1
      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      every or := rows_in_range(e.y - y1, 1) do {
         every o := !or.l do {
            if o.inside(e.x - x1, e.y - y1) then
               return o
         }
      }
   end

   private handle_lrelease(e)
      if \wrote then
         self.browser.goto(wrote, browser.page_url, Worker.NORMAL)
   end

   private handle_mrelease(e)
      if \wrote then
         self.browser.link_mrelease(wrote)
   end

   private handle_lpress(e)
      local c, t
      if t := which_text_out(e) then {
         if c := \ ( \ (t.attr.form_label)).comp & not c.is_shaded() then {
            parent_dialog.set_focus(c.gen_focusable(e))
            if is(c, Toggle) then
               c.on_action(e)
         }
      }
      held := wrote
   end

   package wants_press(e)
      return \wrote
   end

   private handle_rpress(e)
      local pm, pm_menu
      if pm_menu := browser.create_link_menu(\wrote) then {
         pm := PopupMenu()
         pm.popup(parent_dialog, pm_menu, e.x, e.y)
      }
   end

   private handle_move(e)
      local u
      if u := \which_text_out(e).attr.url then {
         if wrote ~=== u then {
            set_pointer("hand1")
            browser.msg(u.str())
            wrote := u
         }
      } else if \wrote then {
         browser.clear_msg()
         wrote := &null
         set_pointer()
      }
   end

   public get_pointer(e)
      handle_move(e)
      return \self.pointer
   end

   private handle_ldrag(e)
      local u
      if u := \which_text_out(e).attr.url & u === held then {
         if wrote ~=== u then {
            set_pointer("hand1")
            browser.msg(u.str())
            wrote := u
         }
      } else if \wrote then {
         browser.clear_msg()
         wrote := &null 
         set_pointer()
      }
   end

   private handle_exit(e)
      if \wrote then {
         browser.clear_msg()
         wrote := &null
         set_pointer()
      }
   end

   public new(browser)
      cast(self,Component).new()
      self.browser := browser
      set_border(NullBorder())
      input := []
      v_align := Align.T
      set_constraint("x_fill", &yes)
      set_constraint("y_fill", &yes)
      connect(self.handle_move, Event.MOUSE_MOVEMENT)
      connect(self.handle_ldrag, Event.MOUSE_LEFT_DRAG)
      connect(self.handle_lpress, Event.MOUSE_LEFT_PRESS)
      connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE)
      connect(self.handle_exit, Event.MOUSE_EXIT)
      connect(self.handle_rpress, Event.MOUSE_RIGHT_PRESS)
      connect(self.handle_mrelease, Event.MOUSE_MIDDLE_RELEASE)
      return
    end
end
