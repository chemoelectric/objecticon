#SRC: JCON

$include "posix.icn"

#  I/O test -- writes ./tmp1 and ./tmp2 as well as stdout

procedure main()
   local L, f, m, n, t1, t2

   L := [&input, &output, &errout,
   	m := open("/etc/motd"), n := open("/dev/null", "w")]
   L := sort(L)
   every f := !L do
      write(type(f), ": ", image(f))

   write()
   write(read())
   write(read(&input))
   while write(read()) do break
   write(!&input)
   every write(!&input \ 2)
   every write(!&input) \ 2

   &error := -1
   write()
   write("flush /etc/motd: ", image(flush(m)) | "FAILED")
   write("close /etc/motd: ", image(close(m)) | "FAILED")
   write("close /etc/motd: ", image(close(m)) | "FAILED")
   write("flush /etc/motd: ", image(flush(m)) | "FAILED")

   write()
   write("flush /dev/null: ", image(flush(n)) | "FAILED")
   write("close /dev/null: ", image(close(n)) | "FAILED")
   write("close /dev/null: ", image(close(n)) | "FAILED")
   write("flush /dev/null: ", image(flush(n)) | "FAILED")
   &error := 0

   every remove("tmp1" | "tmp2")
   every remove("tmp1" | "tmp2")
   write(image(open("tmp1")))		# should fail

   write()
   rfile("/dev/null")
   wfile("tmp1", "w", "follow the yellow brick road")
   rfile("tmp1")
   wfile("tmp1", "w", "shorter file")
   rfile("tmp1")
   wfile("tmp1", "a", "gets extended")
   rfile("tmp1")
   wfile("tmp1", "r+", "changed")
   rfile("tmp1")
   wfile("tmp1", "r+", "mode b ")
   rfile("tmp1")
   wfile("tmp1", "w+", "cleared anew")
   rfile("tmp1")
   rename("tmp1", "tmp2")
   rfile("tmp2")

   write()
   write(image(t1 := open("tmp1", "w")) | "can't open tmp1")
   write(image(t2 := open("tmp2", "w")) | "can't open tmp2")
   writes(">stdout")
   writes(t1, ">1a")
   writes(t2, ">2a")
   writes(&output)
   writes(">stdout")
   writes(t2, ">2b")
   writes(t1, ">1b")
   writes(&output)
   write(">stdout")
   write(t1, ">1c")
   write(t2)
   write(t2, ">2c")
   write(&output)
   write(">stdout")
   write(t2, ">2d")
   write(t1)
   write(t1, ">1d")
   write(&output)
   every write(t1 | t2)
   writes(t1, ">1e")
   writes(t2, ">2e")
   write(t1, ">1f")
   write(t2, ">2f")
   every close(t1 | t2)
   rfile("tmp1")
   rfile("tmp2")

   every remove("tmp1" | "tmp2")
   every remove("tmp1" | "tmp2")

   write()
   writes("abc")
   writes("def\nghi")
   writes("\njklmno\n")
   write("pqr\nstu")
   writes("vwxyz")
   writes()
   writes("")
   writes("\n")

   write()
   tsys("echo hello world")			# simple echo
   tsys("ls io.[ids][tca][dnt]")		# check wildcarding

   tpipe()

end



#  wfile(name, mode, s) -- break apart string and write file

procedure wfile(name, mode, s)
   local f, x

   write()
   writes("write ", name, ",", mode, ":\t ")
   if f := open(name, mode) then s ? {
      writes(s)
      tab(many(' '))
      while not pos(0) do {
         x := tab(upto(' ') | 0)
	 write(f, x) | stop("Failed to write:", strerror())
	 tab(many(' '))
         }
      write(" : ", tell(f))
      flush(f)
      close(f)
      }
   else {
      write("can't open")
      }
   return
end

procedure seekx(f,i)
   if i <= 0 then
      return seek(f,i,SEEK_END)
   else
      return seek(f,i-1,SEEK_SET)
end


#  rfile(name) -- read and echo file contents (several different ways)

procedure rfile(name)
   local f, i

   writes("read  ", name, ":\t")
   if not (f := open(name, "r")) then {
      write(" can't open")
      fail
      }

   # read()
   while writes(" ", read(f))
   write()

   # bang
   seek(f, 0)
   every writes(" ", "  !f:\t\t" | !f | "\n")

   # both, mixed
   seek(f, 0)
   writes("   read/!f:\t")
   while writes(" ", read(f)) do writes(" ", !f)
   write()

   # reads()
   seek(f, 0)
   writes("   reads():\t")
   while writes(" ", map(reads(f, 5), "\n", "."))
   write()

   # nonsequential
   writes("   nonseq:\t ")
   every i := 30 to -30 by -1 do
      if seekx(f, i) then
	 writes(map(reads(f), "\n", ".") | "?")
      else
	 writes("-")
   write()

   close(f)
   return
end


#  tsys(s) -- test system call

procedure tsys(s)
   write("$ ", s)
   system(s)
   return
end


#  tpipe() -- test pipes

procedure tpipe()
   local p

   # very simple case
   write()
   p := popen("echo hello world", "r") | stop("can't open echo pipe")
   write(image(p))
   while write("> ", read(p))
   close(p)

   # check unclosed pipe
   write()
   p := popen("sed 's/^/=()= /' io.icn") | stop("can't open od pipe")
   write(image(p))
   every 1 to 10 do write("> ", read(p))
   # p is deliberately left unclosed

   # check wildcarding, and also !pipe
   write()
   p := popen("ls io.i?n io.d?t io.s?d") | stop("can't open ls pipe")
   write(image(p))
   every write("> ", !p)
   close(p)

   # check output pipe
   write()
   p := popen("tr aeiou oaeui", "w") | stop("can't open tr pipe")
   write(image(p))
   write(p, "once upon a midnight dreary")
   write(p, "two roads diverged in a yellow wood")
   write(p, "and the mome raths outgrabe")
   write("--- closing output pipe")
   close(p)
   write("--- done closing output pipe")
   remove("tmp1")

   return
end
