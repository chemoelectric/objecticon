package util

#
# Delete all instances of x from the list l.
#
procedure list_del(l, x)
   local t
   t := []
   while put(t, pop(l))
   every put(l, x ~=== !t)
   return l
end

#
# Keep only unique list elements
#
procedure list_unique(L)
   local result, culls, x

   result := []
   culls := list2set(L)

   every x := !L do
      if member(culls, x) then {
         delete(culls, x)
         put(result, x)
      }

   return result

end

#
# Convert a string to a list.
#
# @param s the string to convert
# @param sep cset of the separator chars, default ','
#
procedure str2list(s, sep)
   local l, t
   /sep := ','
   l := []
   s ? repeat {
      t := tab(upto(sep) | 0)
      put(l, t)
      if pos(0) then
         break
      move(1)
   }
   return l
end

#
# Convert a list to a string
#
# @param l the list
# @param sep the separator char, default ","
#
procedure list2str(l, sep)
   local s
   /sep := ","
   s := ""
   every s ||:= !l || sep
   s[-1] := ""
   return s
end

#
# Succeed iff the sequence generated by {&features} contains the given
# string.
#
procedure has_feature(x)
   static s
   initial {
      s := set()
      every insert(s, &features)
   }
   return member(s, x)
end

#
# What is just ahead in the current scan?
#
procedure coming_up(i, j)
   /j := 0
   return &subject[&pos+j +: i]
end

#
# Like many, but succeeds with empty result if zero matching char. Many needs
# one or more.
#
procedure many_star(c)
   if any(c) then
      return many(c)
   else
      return &pos
end

#
# Search for a string using find and suspend the position after the string,
# if found.
#
procedure past(s)
   suspend find(s) + *s
end

#
# Convenient procedure to set {&why} to the given string and fail.
#
procedure error(s)
   &why := s
end

#
# Generate the results of a co-expression as a sequence.
#
procedure coexp_seq(e)
   suspend |@e
end

#
# Create a set containing all the elements of x
#
procedure list2set(x)
   local s
   s := set()
   every insert(s, !x)
   return s
end
