#
# $Id$
#

package xml

import util, ipl.scan, io, ipl.pdco

class WebScraper()
   private
      paths

   #
   # Generate the lookup ids this webscraper can search for
   #
   public get_ids()
      suspend key(paths)
   end

   public load_file(fn)
      return set_page(Files.file_to_string(fn)) 
   end

   public set_page(data)
      local p, d, n, s, i, anchors

      p := HtmlParser()
      d := p.parse(data) | return error("Couldn't parse")

      anchors := create_anchors(d) | fail

      paths := table()

      every n := Seq{d.traverse_nodes_preorder()} do {
         if is(n, Element) & s := n.get_attribute("scrapeId") then {
            do_insert(s, n, anchors) | fail
         }
         i := 0
         every s := text(!n.children) do {
            i +:= 1
            s ? if tab(cl_match("$scrapeid=")) then {
               s := tab(upto('$')) | return error("Unclosed scrapeid")
               do_insert(s, n, anchors, i)
            }
         }
      }

      return self
   end

   public do_insert(s, n, anchors, si)
      local a, t, anchor_str, anchor_path, id
      s ? {
         if a := tab(upto(':')) then {
            move(1)
            t := \anchors[a] | return error("Unknown anchor:" || a)
            anchor_str := t[1]
            anchor_path := t[2]
         }
         id := tab(0)
      }
      return insert(paths, id, create_path(n, anchor_str, anchor_path, si))
   end

   public create_anchors(d)
      local n, s, id, str, res

      res := table()
      every n := Seq{d.traverse_nodes_preorder()} do {
         every s := text(!n.children) do {
            s ? if tab(cl_match("$anchorid=")) then {
               id := tab(upto('$')) | return error("Unclosed anchor id")
               move(1)
               str := tab(0)
               insert(res, id, [str, path_to_root(n)])
            }
         }
      }

      return res
   end

   public create_path(n, anchor_str, anchor_path, si)
      local p1, p2, res, el

      res := []
      p1 := path_to_root(n)

      if \anchor_path then {
         p2 := copy(anchor_path)
         while p1[1] === p2[1] do {
            pop(p1)
            pop(p2)
         }

         put(res, ["A", anchor_str])
         put(res, ["U", *p2])
      } else {
         put(res, ["R"])
         pop(p1)
      }

      every el := !p1 do
         put(res, ["T", get_tag_index(el), el.name])

      if \si then
         put(res, ["S", si])

      return res
   end

   public get_tag_index(n)
      local i, e
      i := 0
      every e := !n.parent.children do {
         if not(text(e)) & is(e, Element) & e.name == n.name then
            i +:= 1
         if e === n then
            return i
      }
      syserr("Couldn't find child in parent!")
   end

   public path_to_root(n)
      local l
      l := []
      repeat {
         push(l, n)
         n := n.parent 
         is(n, Element) | return l
      }
   end

   public lookup(d, id)
      local l, n, e

      l := \paths[id] | return error("Unknown id:" || id)

      every e := !l do {
         #write("Doing:",to_string(e))
         case e[1] of {
            "R" : {
               n := d.get_root_element()
            }
            "A" : {
               n := d.find_string(e[2]) | return error("Couldn't find anchor string:" || e[2])
            }
            "U" : {
               every 1 to e[2] do {
                  n := n.parent
                  is(n, Element) | return error("Couldn't go up")
               }
            }
            "T" : {
               #n.print_structure()
               n := n.get_nth_element(e[2], e[3]) | return error("While looking up " || 
                                                                 id || ": Element " || e[3] || " not found.")
            }
            "S" : {
               n := n.get_nth_string(e[2]) | return error("While looking up " || 
                                                       id || ": String at " || e[2] || " not found.")
            }
            default : syserr("Unknown command")
         }
      }
      return n
   end

   public new(fn)
      if \fn then
         return load_file(fn)
      return
   end
end

