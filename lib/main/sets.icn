#
# $Id$
#

package datastruct

import lang

#
# This is a common superclass for a set-like data structure.
#
abstract class Set(ObjectOutput, ObjectHash, ObjectEquals)
   #
   # Insert a new member.  Always succeeds and returns {self}.
   #
   public abstract insert(x)

   #
   # Succeed with `x` if it is a member of the set.
   #
   public abstract member(x)

   #
   # Delete `x` from the set.  Fails if the key was not present,
   # otherwise succeeds and returns {self}.
   #
   public abstract delete(x)

   #
   # Return a sorted list of members.
   #
   public sort()
      return default.sort(member_list())
   end

   #
   # Generate the members.
   #
   public abstract gen()

   #
   # Generate the members in reverse order.  Only implemented for sets which store their
   # members in sorted order.
   #
   public defer back()

   #
   # Return the rank of the given entry, ie its order number in the
   # set; fails if there is no matching entry in the set.  Only
   # implemented for sets which store their keys in sorted order.
   #
   public defer rank(x)

   #
   # Return the `i`th entry, in order, in the set.  Fails if `i` is
   # out of range, using standard icon indexing semantics.  Only
   # implemented for sets which store their keys in sorted order.
   #
   public defer select(i)

   #
   # Return the size of the set.
   #
   public abstract size()

   #
   # Clear the set of all elements.
   #
   public abstract clear()

   #
   # Return a list of the members, in the order produced by {gen()}.
   #
   public member_list()
      local l
      l := []
      every put(l, gen())
      return l
   end

   #
   # Custom equals mirrors the {equals()} behaviour for builtin sets.
   #
   private object_equals(other, seen)
      other.size() = self.size() | fail
      return hash_and_check(other.member_list(), self.member_list(), seen)
   end

   #
   # Custom hash mirrors the {hash()} behaviour for builtin sets.
   #
   private object_hash(depth)
      local n
      n := size()
      if depth > 1 then
         every n +:= hash(gen(), depth - 1)
      return n
   end

   #
   # Output object
   #
   private object_output(oo)
      local elements, e, sep
      elements := sort()
      if oo.simple{!elements} then {
         oo.object_start(self)
         every e := !elements do {
            if \sep then
               oo.writes1(",")
            oo.traverse(e)
            sep := 1
         }
         oo.object_end(self)
      } else {
         oo.nl().
            object_start(self).
            iplus()
         every e := !elements do {
            if \sep then
               oo.writes1(",")
            oo.nl().
               traverse(e)
            sep := 1
         }
         oo.iminus().
            nl().
            object_end(self)
      }
   end
end

#
# A class to provide an unmodifiable view of another set.
#
class UnmodifiableSet(Set)
   private const s

   public defer insert(x)

   public member(x)
      return s.member(x)
   end

   public defer delete(x)

   public sort()
      return s.sort()
   end

   public gen()
      suspend s.gen()
   end

   public back()
      suspend s.back()
   end

   public rank(x)
      return s.rank(x)
   end

   public select(i)
      return s.select(i)
   end

   public size()
      return s.size()
   end

   public defer clear()

   public new(s)
      self.s := s
      return
   end
end

#
# A Set which is a view of the keys of a {Table}.
#
class TableSet(Set)
   private t

   public insert(x)
      t.insert(x, t.def)
      return self
   end

   public member(x)
      if t.member(x) then
         return x
   end

   public delete(x)
      return t.delete(x) & self
   end

   public sort()
      local l
      l := []
      every put(l, (!t.sort())[1])
      return l
   end

   public gen()
      suspend t.key()
   end

   public back()
      suspend t.back_key()
   end

   public rank(x)
      return t.rank(x)
   end

   public select(i)
      return t.select(i)
   end

   public size()
      return t.size()
   end

   public clear()
      t.clear()
      return self
   end

   #
   # Create a new instance.
   #
   # @param t either the {Table} to wrap, or a class indicating the class of
   # @   a new {Table}, which will be instantiated by calling its
   # @   constructor with no parameters.
   # @param entries initial entries to insert.
   #
   public new(t, entries[])
      if type(t) == "class" then
         t := t()
      self.t := t
      every insert(!entries)
      return
   end
end

#
# A {Set} that is just a wrapper around a builtin set
#
class BuiltinSet(Set)
   private s

   public insert(x)
      default.insert(s, x)
      return self
   end

   public member(x)
      return default.member(s, x)
   end

   public delete(x)
      return default.delete(s, x) & self
   end

   public sort()
      return default.sort(s)
   end

   public gen()
      suspend !s
   end

   public size()
      return *s
   end

   public clear()
      default.clear(s)
      return self
   end

   #
   # Create a new instance.
   #
   # @param s the set to wrap; if omitted a new set is created.
   #
   public new(s)
      /s := set()
      self.s := s
      return
   end
end
