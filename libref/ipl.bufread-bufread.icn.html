<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>bufread.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#   File:     bufread.icn
<a name="4"/>#
<a name="5"/>#   Subject:  Procedures for buffered read and lookahead
<a name="6"/>#
<a name="7"/>#   Author:   Charles A. Shartsis
<a name="8"/>#
<a name="9"/>#   Date:     March 11,1995
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#   Version:  1.0
<a name="18"/>#
<a name="19"/>############################################################################
<a name="20"/>#
<a name="21"/>#   Synopsis:
<a name="22"/>#
<a name="23"/>#       bufopen(s)      Open a file name s for buffered read and lookahead
<a name="24"/>#       bufread(f)      Read the next line from file f
<a name="25"/>#       bufnext(f, n)   Return the next nth record from file f
<a name="26"/>#                       without changing the next record to be read by
<a name="27"/>#                       bufread
<a name="28"/>#       bufclose(f)     Close file f
<a name="29"/>#
<a name="30"/>############################################################################
<a name="31"/>#    
<a name="32"/>#   These procedures provide a mechanism for looking ahead an 
<a name="33"/>#   arbitrary number of records in an open file while still
<a name="34"/>#   keeping track of the logical current record and end-of-file.
<a name="35"/>#   Although similar in intent to the procedures in buffer.icn, these
<a name="36"/>#   procedures are used differently.  The procedures bufopen, 
<a name="37"/>#   bufread, and bufclose were designed to closely mirror the
<a name="38"/>#   built-in open, read, and close.
<a name="39"/>#   
<a name="40"/>#   A code segment like
<a name="41"/>#   
<a name="42"/>#           file := open("name", "r") | stop("open failed")
<a name="43"/>#           while line := read(file) do {
<a name="44"/>#               ...process current line...
<a name="45"/>#           }
<a name="46"/>#           close(file)
<a name="47"/>#   
<a name="48"/>#   can be changed to the following with no difference in behavior:
<a name="49"/>#   
<a name="50"/>#           file := bufopen("name", "r") | stop("open failed")
<a name="51"/>#           while line := bufread(file) do {
<a name="52"/>#               ...process current line...
<a name="53"/>#           }
<a name="54"/>#           bufclose(file)
<a name="55"/>#   
<a name="56"/>#   However in addition to processing the current line, one may
<a name="57"/>#   also process subsequent lines BEFORE they are logically
<a name="58"/>#   read:
<a name="59"/>#   
<a name="60"/>#           file := bufopen("name", "r") | stop("open failed")
<a name="61"/>#           while line := bufread(file) do {
<a name="62"/>#               ...process current line...
<a name="63"/>#               line := bufnext(file,1) # return next line
<a name="64"/>#               ...process next line...
<a name="65"/>#               line := bufnext(file,2) # return 2nd next line
<a name="66"/>#               ...process 2nd next line...
<a name="67"/>#               ...etc...
<a name="68"/>#           }
<a name="69"/>#           bufclose(file)
<a name="70"/>#   
<a name="71"/>#   In the code above, calls to bufnext do not affect the results of 
<a name="72"/>#   subsequent bufread's.  The bufread procedure always steps through
<a name="73"/>#   the input file a line at a time without skipping lines whether or 
<a name="74"/>#   not bufnext is called.
<a name="75"/>#
<a name="76"/>############################################################################
<a name="77"/>#
<a name="78"/>#   Here is a more detailed description of the procedures:
<a name="79"/>#   
<a name="80"/>#   bufopen(s)
<a name="81"/>#   ==========
<a name="82"/>#   Produces a file resulting from opening s for reading ("r" option),
<a name="83"/>#   but fails if the file cannot be opened.  if s is missing or
<a name="84"/>#   the value of s is &amp;null, then standard input is opened and
<a name="85"/>#   input is returned.  Unlike the Icon open function, bufopen()
<a name="86"/>#   can and must be called prior to any call to bufread or bufnext
<a name="87"/>#   involving standard input.  Unlike named files, only one buffered
<a name="88"/>#   standard input may be open at any given time.
<a name="89"/>#   
<a name="90"/>#   Default:
<a name="91"/>#   s   &amp;null   (indicates input should be opened for buffered
<a name="92"/>#               reading)
<a name="93"/>#               
<a name="94"/>#   Errors (from open):
<a name="95"/>#   103     s not string
<a name="96"/>#   
<a name="97"/>#   Errors (new):
<a name="98"/>#   Attempt to open standard input when currently open
<a name="99"/>#   
<a name="100"/>#
<a name="101"/>#   bufread(f)
<a name="102"/>#   ==========
<a name="103"/>#   Produces a string consisting of the next line from f, but fails on
<a name="104"/>#   end of file.   Calls to bufnext do not affect the results of
<a name="105"/>#   subsequent bufread's.  The procedure bufread always steps
<a name="106"/>#   through a file a line at a time without skipping lines.  The 
<a name="107"/>#   procedure bufread fails when a logical end of file is
<a name="108"/>#   reached, i.e., when the physical end of file has 
<a name="109"/>#   been reached AND the internal buffer is empty.
<a name="110"/>#   
<a name="111"/>#   Default:
<a name="112"/>#   f   input
<a name="113"/>#   
<a name="114"/>#   Errors:
<a name="115"/>#   f is not a file
<a name="116"/>#   f not opened for buffered reads (includes input)
<a name="117"/>#   
<a name="118"/>#   
<a name="119"/>#   bufnext(f, n)
<a name="120"/>#   =============
<a name="121"/>#   Produces a string consisting of the nth next line from f after
<a name="122"/>#   the current line.  It fails when the physical end of file
<a name="123"/>#   has been reached.
<a name="124"/>#   
<a name="125"/>#   Default:
<a name="126"/>#   f   amperInput
<a name="127"/>#   n   1 (the next line after the current one)
<a name="128"/>#   
<a name="129"/>#   Errors:
<a name="130"/>#   f is not a file
<a name="131"/>#   f not opened for buffered reads (includes amperInput)
<a name="132"/>#   n not convertible to integer
<a name="133"/>#   n not positive
<a name="134"/>#
<a name="135"/>#   
<a name="136"/>#   bufclose(f)
<a name="137"/>#   ===========
<a name="138"/>#   Produces f after closing it.  Standard input must
<a name="139"/>#   be closed before it can be reopened using bufopen.
<a name="140"/>#   If standard input is closed, all lines read using bufnext
<a name="141"/>#   are lost when it is reopened.  In general, there is no
<a name="142"/>#   practical reason to bufclose and then bufopen standard input.
<a name="143"/>#   One may want to bufclose standard input to release its
<a name="144"/>#   internal buffer for garbage collection.
<a name="145"/>#   
<a name="146"/>#   Default:
<a name="147"/>#   f   amperInput
<a name="148"/>#   
<a name="149"/>#   Errors (from close):
<a name="150"/>#   105     f not file
<a name="151"/>#   
<a name="152"/>############################################################################
<a name="153"/>
<a name="154"/>package ipl.bufread
<a name="155"/>
<a name="156"/>import
<a name="157"/>   io(close, open, read, need_Stream),
<a name="158"/>   util(need_integer)
<a name="159"/>
<a name="160"/>package global fbuf
<a name="161"/>
<a name="162"/>procedure bufopen(fname)
<a name="163"/>
<a name="164"/>    local file
<a name="165"/>    
<a name="166"/>    initial
<a name="167"/>        fbuf := table()
<a name="168"/>    
<a name="169"/>    if file := open(fname, "r") then {
<a name="170"/>       fbuf[file] := []
<a name="171"/>       return file
<a name="172"/>    }
<a name="173"/>        
<a name="174"/>end
<a name="175"/>
<a name="176"/>procedure bufclose(file)
<a name="177"/>
<a name="178"/>   delete(\fbuf, file)
<a name="179"/>   return close(file)
<a name="180"/>
<a name="181"/>end
<a name="182"/>
<a name="183"/>procedure bufread(file)
<a name="184"/>
<a name="185"/>    local buf
<a name="186"/>
<a name="187"/>    need_Stream(file)
<a name="188"/>    buf := member(\fbuf, file) | runerr("bufread: File not open for buffered reads", file)
<a name="189"/>    return get(buf) | read(file)
<a name="190"/>
<a name="191"/>end
<a name="192"/>
<a name="193"/>procedure bufnext(file, n)
<a name="194"/>
<a name="195"/>    local buf
<a name="196"/>
<a name="197"/>    need_Stream(file)
<a name="198"/>    n := need_integer(\n, 1) | 1
<a name="199"/>
<a name="200"/>    buf := member(\fbuf, file) | runerr("bufnext: File not open for buffered reads", file)
<a name="201"/>
<a name="202"/>    while *buf &lt; n do
<a name="203"/>       put(buf, read(file)) | fail
<a name="204"/>
<a name="205"/>    return buf[n]
<a name="206"/>
<a name="207"/>end
</pre></body></html>
