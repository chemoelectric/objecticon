package ipl.functional

import
   lang(Class),
   ipl.callable(callable)

#
# Implementation class for {partial}
#
package class Partial()
   private
      f, spec, v

   public call(a[])
      local e, c, r
      e := create !v
      r := []
      every c := !spec do {
         case c of {
            "v": put(r, @e)
            "V": while put(r, @e)
            "a": put(r, get(a))
            "A": while put(r, get(a))
            "-": get(a)
            default: runerr("invalid spec char to partial", c)
         }
      }
      suspend f!r
   end

   public new(f, spec, v)
      self.f := f
      self.spec := spec
      self.v := v
      return
   end
end

# Returns a function which modifies its arguments according to `spec`,  before applying them
# to f.  The modification is specified by the following characters in spec:-
#    "v": add the next value (which follow the spec parameter).
#    "V": add the remaining values.
#    "a": add the next argument.
#    "A": add the remaining arguments.
#    "-": skip the next argument.
#
# @example
# @   f := partial(write, "vvvAV", "a", "b", "c", "p", "q", "r")
# @   f("x","y","z")   # writes abcxyzpqr
#
procedure partial(f, spec, l[])
   return Partial(f, spec, l).call
end

#
# Implementation class for {lpartial}
#
package class LPartial()
   private
      f, l

   public call(a[])
      suspend f!(l ||| a)
   end

   public new(f, l)
      self.f := f
      self.l := l
      return
   end
end

#
# Partial application to function f, prepending l to the arguments.
#
procedure lpartial(f, l[])
   return LPartial(f, l).call
end

#
# Implementation class for {rpartial}
#
package class RPartial()
   private
      f, l

   public call(a[])
      suspend f!(a ||| l)
   end

   public new(f, l)
      self.f := f
      self.l := l
      return
   end
end

#
# Partial application to function f, appending l to the arguments.
#
procedure rpartial(f, l[])
   return RPartial(f, l).call
end

#
# Implementation class for {compose}
#
package class Compose()
   private
      f, g

   public call(a[])
      suspend f(g!a)
   end

   public new(f, g)
      self.f := f
      self.g := g
      return
   end
end

#
# Compose functions f and g
#
procedure compose(f, g)
   return Compose(f, g).call
end

#
# Implementation class for {lpartial2}
#
package class LPartial2()
   private
      f, x

   public call(a)
      suspend f(x, a)
   end

   public new(f, x)
      self.f := f
      self.x := x
      return
   end
end

# Partial application of the first parameter to the two-parameter
# function f.  The result is the same as using the more general
# function {lpartial}, but avoids the creation of temporary lists on
# each invocation of the resulting function.
#
procedure lpartial2(f, x)
   return LPartial2(f, x).call
end

# Convenient function to get the named binary operator, partially
# applied with x as the left argument.  For example lpb(2, "*")
# returns a function which doubles its argument, whilst lpb(0, "<")
# returns a function which succeeds and returns its argument if it is
# greater than 0.
#
procedure lpb(x, s)
   return lpartial2(callable(s, 2), x)
end

#
# Implementation class for {rpartial2}
#
package class RPartial2()
   private
      f, x

   public call(a)
      suspend f(a, x)
   end

   public new(f, x)
      self.f := f
      self.x := x
      return
   end
end

# Partial application of the second parameter to the two-parameter
# function f.  The result is the same as using the more general
# function {rpartial}, but avoids the creation of temporary lists on
# each invocation of the resulting function.
#
procedure rpartial2(f, x)
   return RPartial2(f, x).call
end

# Convenient function to get the named binary operator, partially
# applied with x, using rpartial.  For example rpb("/", 2) returns a
# function which halves its argument.
#
procedure rpb(s, x)
   return rpartial2(callable(s, 2), x)
end

#
# Implementation class for {methodf}
#
package class Methodf()
   private field

   public call(obj, a[])
      suspend Class.get(obj, field)!a
   end

   public new(field)
      self.field := field
      return
   end
end

# Returns a function that takes its first argument, obtains the given
# field from it, and then applies the remaining arguments to the
# resulting method.
#
# @example
# @ f := methodf("abc")
# @ f(obj, 1, 2, 3)   # invokes obj.abc(1, 2, 3)
#
procedure methodf(field)
   return Methodf(field).call
end

#
# Implementation class for {coexf}
#
package class Coexf()
   private e

   public call()
      return @e
   end

   public new(e)
      self.e := e
      return
   end
end

#
# Given a co-expression {e}, this returns a function which produces @e
# on each evaluation.  Arguments to the function are discarded.
#
procedure coexf(e)
   return Coexf(e).call
end
