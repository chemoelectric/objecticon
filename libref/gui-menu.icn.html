<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>menu.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: menu.icn 9081 2021-04-27 14:46:19Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package gui
<a name="10"/>
<a name="11"/>import graphics
<a name="12"/>
<a name="13"/>#
<a name="14"/># This class encapsulates a drop down menu, or a sub-menu.
<a name="15"/>#
<a name="16"/># The left, centre and right labels/images of the elements
<a name="17"/># within it are formatted within the menu automatically.
<a name="18"/>#
<a name="19"/>class Menu(TextMenuItem)
<a name="20"/>   public 
<a name="21"/>      max_label_left_w,                                
<a name="22"/>      max_label_mid_w,                                
<a name="23"/>      max_label_right_w,                                
<a name="24"/>      which_open,                                
<a name="25"/>      which_highlight,
<a name="26"/>      pressed
<a name="27"/>
<a name="28"/>   public override resize()
<a name="29"/>      local py, m, tw
<a name="30"/>
<a name="31"/>      self.max_label_left_w := self.max_label_right_w := self.max_label_mid_w := 0
<a name="32"/>      self.h := border.get_total_height()
<a name="33"/>      py := self.y + border.get_t_inset()
<a name="34"/>
<a name="35"/>      every m := !self.children do {
<a name="36"/>         #
<a name="37"/>         # Save the x, y and height of the label; the width is set
<a name="38"/>         # at the end.
<a name="39"/>         #
<a name="40"/>         m.label_x := self.x + border.get_l_inset()
<a name="41"/>         m.label_y := py
<a name="42"/>         m.label_h := max(m.get_label_left_height() | 0,
<a name="43"/>                          m.get_label_mid_height() | 0,
<a name="44"/>                          m.get_label_right_height() | 0)
<a name="45"/>         self.max_label_left_w &lt;:= m.get_label_left_width()
<a name="46"/>         self.max_label_mid_w &lt;:= m.get_label_mid_width()
<a name="47"/>         self.max_label_right_w &lt;:= m.get_label_right_width()
<a name="48"/>
<a name="49"/>         #
<a name="50"/>         # Increment height; compute maximum label element widths.
<a name="51"/>         #
<a name="52"/>         self.h +:= m.label_h
<a name="53"/>         py +:= m.label_h
<a name="54"/>      }
<a name="55"/>
<a name="56"/>      #
<a name="57"/>      # Calculate total width
<a name="58"/>      #
<a name="59"/>      tw := self.max_label_mid_w + self.max_label_left_w + self.max_label_right_w
<a name="60"/>      self.w := border.get_total_width() + tw
<a name="61"/>      every (!self.children).label_w := tw
<a name="62"/>   end
<a name="63"/>
<a name="64"/>   public override display(cw)
<a name="65"/>      local c
<a name="66"/>
<a name="67"/>      #
<a name="68"/>      # Draw rectangle around whole
<a name="69"/>      #
<a name="70"/>      border.draw(cw, self.x, self.y, self.w, self.h)
<a name="71"/>
<a name="72"/>      #
<a name="73"/>      # Draw individual items, with rectangle around open sub-item.  We just
<a name="74"/>      # draw those in the clip rectangle to save time.
<a name="75"/>      #
<a name="76"/>      every c := !self.children do {
<a name="77"/>         if cw.drawable(c.label_x, c.label_y, c.label_w, c.label_h) then {
<a name="78"/>            c.draw_label(cw, self.max_label_left_w, self.max_label_mid_w, self.max_label_right_w)
<a name="79"/>            if c === \self.which_highlight then
<a name="80"/>               Gui.style.fill_down_rectangle(cw, c.label_x, c.label_y, c.label_w, c.label_h)
<a name="81"/>            else if c.is_shaded() then
<a name="82"/>               Gui.style.shade_rectangle(cw,
<a name="83"/>                                          c.label_x, c.label_y, c.label_w, c.label_h)
<a name="84"/>         }
<a name="85"/>      }
<a name="86"/>   end
<a name="87"/>
<a name="88"/>   #
<a name="89"/>   # Go to the first non-shaded item; returns self if one found, fails
<a name="90"/>   # otherwise.
<a name="91"/>   #
<a name="92"/>   public override cursor_on()
<a name="93"/>      local m
<a name="94"/>      every m := !children do {
<a name="95"/>         unless m.is_shaded() | m.is_decorative() then
<a name="96"/>            return set_which_highlight(m)
<a name="97"/>      }
<a name="98"/>   end
<a name="99"/>
<a name="100"/>   #
<a name="101"/>   # Set which_open and which_highlight to (non-null) x.
<a name="102"/>   #
<a name="103"/>   public set_which_open(x)
<a name="104"/>      #
<a name="105"/>      # Do nothing if x presently open
<a name="106"/>      #
<a name="107"/>      if self.which_open === x then
<a name="108"/>         link
<a name="109"/>
<a name="110"/>      set_which_highlight(x)
<a name="111"/>      self.which_open := x
<a name="112"/>      self.which_open.show(self.x + self.w, 
<a name="113"/>                           self.which_open.label_y - self.which_open.border.get_t_inset(),
<a name="114"/>                           self.x)
<a name="115"/>      link
<a name="116"/>   end
<a name="117"/>
<a name="118"/>   #
<a name="119"/>   # Set the which_highlight to x, which_open to null
<a name="120"/>   #
<a name="121"/>   public set_which_highlight(x)
<a name="122"/>      #
<a name="123"/>      # Do nothing if already in desired state.
<a name="124"/>      #
<a name="125"/>      if (self.which_highlight === x) &amp; /self.which_open then
<a name="126"/>         link
<a name="127"/>
<a name="128"/>      (\self.which_open).hide()
<a name="129"/>      # Just invalidate the bits that have changed.
<a name="130"/>      self.temp_win.invalidate((\self.which_highlight).get_label_rect())
<a name="131"/>      self.which_highlight := x
<a name="132"/>      self.temp_win.invalidate((\self.which_highlight).get_label_rect())
<a name="133"/>      self.which_open := &amp;null
<a name="134"/>      link
<a name="135"/>   end
<a name="136"/>
<a name="137"/>   public handle_key_up(e)
<a name="138"/>      local m, last
<a name="139"/>      every m := !children do {
<a name="140"/>         if \last &amp; m === which_highlight then {
<a name="141"/>            set_which_highlight(last)
<a name="142"/>            return
<a name="143"/>         }
<a name="144"/>         m.is_shaded() | m.is_decorative() | (last := m)
<a name="145"/>      }
<a name="146"/>      set_which_highlight(\last)
<a name="147"/>   end
<a name="148"/>
<a name="149"/>   public handle_key_down(e)
<a name="150"/>      local m, t, first
<a name="151"/>      every m := !children do {
<a name="152"/>         unless m.is_shaded() | m.is_decorative() then {
<a name="153"/>            if /self.which_highlight | \t then {
<a name="154"/>               set_which_highlight(m)
<a name="155"/>               return
<a name="156"/>            }
<a name="157"/>            /first := m
<a name="158"/>         }
<a name="159"/>         if m === which_highlight then
<a name="160"/>            t := m
<a name="161"/>      }
<a name="162"/>      set_which_highlight(\first)
<a name="163"/>   end
<a name="164"/>
<a name="165"/>   public handle_key_home(e)
<a name="166"/>      local m
<a name="167"/>      every m := !children do {
<a name="168"/>         unless m.is_shaded() | m.is_decorative() then {
<a name="169"/>            set_which_highlight(m)
<a name="170"/>            return
<a name="171"/>         }
<a name="172"/>      }
<a name="173"/>   end
<a name="174"/>
<a name="175"/>   public handle_key_end(e)
<a name="176"/>      local m
<a name="177"/>      every m := back(children) do {
<a name="178"/>         unless m.is_shaded() | m.is_decorative() then {
<a name="179"/>            set_which_highlight(m)
<a name="180"/>            return
<a name="181"/>         }
<a name="182"/>      } 
<a name="183"/>  end
<a name="184"/>
<a name="185"/>   public handle_key_right(e)
<a name="186"/>      if /self.which_highlight then
<a name="187"/>         self.cursor_on() | parent_component.go_right()
<a name="188"/>      else if self.which_highlight.is_sub_menu() then {
<a name="189"/>         set_which_open(self.which_highlight)
<a name="190"/>         self.which_open.cursor_on()
<a name="191"/>      } else
<a name="192"/>         parent_component.go_right()
<a name="193"/>   end
<a name="194"/>
<a name="195"/>   public handle_key_left(e)
<a name="196"/>      if /parent then
<a name="197"/>         parent_component.go_left()
<a name="198"/>      else
<a name="199"/>         parent.set_which_highlight(self)
<a name="200"/>   end
<a name="201"/>
<a name="202"/>   public handle_key_escape(e)
<a name="203"/>      if \e.shift then
<a name="204"/>         close_all()
<a name="205"/>      else if /parent then
<a name="206"/>         parent_component.make_partial()
<a name="207"/>      else
<a name="208"/>         parent.set_which_highlight(self)
<a name="209"/>   end
<a name="210"/>
<a name="211"/>   public handle_key_return(e)
<a name="212"/>      if \self.which_highlight then {
<a name="213"/>         if self.which_highlight.is_sub_menu() then {
<a name="214"/>            set_which_open(self.which_highlight)
<a name="215"/>            self.which_open.cursor_on()
<a name="216"/>         } else
<a name="217"/>            self.which_highlight.selected(e)
<a name="218"/>      }
<a name="219"/>   end
<a name="220"/>
<a name="221"/>   public handle_press(e)
<a name="222"/>      local m
<a name="223"/>      # Open the item where the pointer is or clear highlight (eg
<a name="224"/>      # if over a shaded item).
<a name="225"/>      #
<a name="226"/>      if m := self.which_item(e) then {
<a name="227"/>         if m.is_sub_menu() then {
<a name="228"/>            if m === self.which_open then
<a name="229"/>               self.set_which_highlight(m)
<a name="230"/>            else
<a name="231"/>               self.set_which_open(m)
<a name="232"/>         } else
<a name="233"/>            self.set_which_highlight(m)
<a name="234"/>      } else
<a name="235"/>         self.set_which_highlight()
<a name="236"/>   end
<a name="237"/>
<a name="238"/>   public handle_release(e)
<a name="239"/>      if \self.which_highlight then {
<a name="240"/>         #
<a name="241"/>         # If item selected and not a sub-menu, return its selected
<a name="242"/>         # event.
<a name="243"/>         self.which_highlight.is_sub_menu() | self.which_highlight.selected(e)
<a name="244"/>      }
<a name="245"/>   end
<a name="246"/>
<a name="247"/>   public handle_move(e)
<a name="248"/>      local m
<a name="249"/>      if m := self.which_item(e) then {
<a name="250"/>         # 
<a name="251"/>         # If this is the current highlight, do nothing, as a sub-menu may
<a name="252"/>         # be highlighted but not open (due to a click) and we don't
<a name="253"/>         # want to flick it back open on a move.
<a name="254"/>         #
<a name="255"/>         if m ~=== self.which_highlight then {
<a name="256"/>            #
<a name="257"/>            # Over a (different) item; either open it or highlight it.
<a name="258"/>            #
<a name="259"/>            if m.is_sub_menu() then
<a name="260"/>               self.set_which_open(m)
<a name="261"/>            else
<a name="262"/>               self.set_which_highlight(m)
<a name="263"/>         }
<a name="264"/>      } else if /self.which_open then
<a name="265"/>         #
<a name="266"/>         # Over menu but not over item (eg over grey/separator); clear highlight, 
<a name="267"/>         # but not an open submenu.
<a name="268"/>         #
<a name="269"/>         self.set_which_highlight()
<a name="270"/>   end
<a name="271"/>
<a name="272"/>   public handle_exit(e)
<a name="273"/>      if /self.which_open then
<a name="274"/>         #
<a name="275"/>         # An exit clears the highlight, unless there is an open submenu.
<a name="276"/>         #
<a name="277"/>         self.set_which_highlight()
<a name="278"/>   end
<a name="279"/>
<a name="280"/>   public handle_default(e)
<a name="281"/>      local m
<a name="282"/>      if m := find_key(e.code) then {
<a name="283"/>         if m.is_sub_menu() then {
<a name="284"/>            set_which_open(m)
<a name="285"/>            m.cursor_on()
<a name="286"/>         } else
<a name="287"/>            m.selected(e)
<a name="288"/>      }
<a name="289"/>   end
<a name="290"/>
<a name="291"/>   public find_key(k)
<a name="292"/>      local m
<a name="293"/>      every m := !children do {
<a name="294"/>         if m.accel === k &amp; not(m.is_shaded() | m.is_decorative()) then
<a name="295"/>            return m
<a name="296"/>      }
<a name="297"/>   end
<a name="298"/>
<a name="299"/>   public override handle_key(e)
<a name="300"/>      if e === accel_skip then
<a name="301"/>         accel_skip := &amp;null
<a name="302"/>      else case /e.release &amp; e.code of {
<a name="303"/>         Key.UP: handle_key_up(e)
<a name="304"/>         Key.DOWN: handle_key_down(e)
<a name="305"/>         Key.HOME : handle_key_home(e)
<a name="306"/>         Key.END : handle_key_end(e)
<a name="307"/>         Key.RIGHT: handle_key_right(e)
<a name="308"/>         Key.LEFT: handle_key_left(e)
<a name="309"/>         "\e" : handle_key_escape(e)
<a name="310"/>         "\r" | "\l" | " " : handle_key_return(e)
<a name="311"/>         default: handle_default(e)
<a name="312"/>      }
<a name="313"/>   end
<a name="314"/>
<a name="315"/>   protected override create_proxy()
<a name="316"/>      local c
<a name="317"/>      c := SubMenuProxyComponent(self)
<a name="318"/>      every c.connect(handle_press, 
<a name="319"/>                             Event.MOUSE_LEFT_PRESS | Event.MOUSE_MIDDLE_PRESS | Event.MOUSE_RIGHT_PRESS)
<a name="320"/>      every c.connect(handle_release, 
<a name="321"/>                             Event.MOUSE_LEFT_RELEASE_OVER | Event.MOUSE_MIDDLE_RELEASE_OVER | Event.MOUSE_RIGHT_RELEASE_OVER)
<a name="322"/>      every c.connect(handle_move, 
<a name="323"/>                             Event.MOUSE_MOVEMENT | Event.MOUSE_LEFT_DRAG_OVER | Event.MOUSE_MIDDLE_DRAG_OVER | Event.MOUSE_RIGHT_DRAG_OVER)
<a name="324"/>      c.connect(handle_exit, Event.MOUSE_EXIT)
<a name="325"/>      c.connect(handle_key, Event.KEY_PRESS)
<a name="326"/>      return c
<a name="327"/>   end
<a name="328"/>
<a name="329"/>   #
<a name="330"/>   # Close this menu.
<a name="331"/>   #
<a name="332"/>   public override hide()
<a name="333"/>      #
<a name="334"/>      # Recursively close any open sub-menu.
<a name="335"/>      #
<a name="336"/>      set_which_highlight()
<a name="337"/>      TextMenuItem.hide()
<a name="338"/>   end
<a name="339"/>
<a name="340"/>   # A helpful method to tidy up a menu by removing any redundant
<a name="341"/>   # separators.  This can simplify the logic when creating a menu
<a name="342"/>   # with optional elements.
<a name="343"/>   #
<a name="344"/>   public tidy()
<a name="345"/>      local i
<a name="346"/>      # Remove empty child menus
<a name="347"/>      every i := *children to 1 by -1 do {
<a name="348"/>         if is(children[i], Menu) &amp; *children[i].children = 0 then
<a name="349"/>            remove_index(i)
<a name="350"/>      }
<a name="351"/>      # Remove redundant separators
<a name="352"/>      every i := *children to 1 by -1 do {
<a name="353"/>         if is(children[i], MenuSeparator) then {
<a name="354"/>            if is(children[i + 1], MenuSeparator) then
<a name="355"/>               remove_index(i + 1)
<a name="356"/>            if i = (1 | *children) then
<a name="357"/>               remove_index(i)
<a name="358"/>         }
<a name="359"/>      }
<a name="360"/>      link
<a name="361"/>   end
<a name="362"/>
<a name="363"/>   public override new()
<a name="364"/>      TextMenuItem.new()
<a name="365"/>      self.set_border(RaisedBorder())
<a name="366"/>      self.is_sub_menu_flag := &amp;yes
<a name="367"/>      self.set_paint_right(ImagePaint().set_cache("gui.ARROW_RIGHT"))
<a name="368"/>      # The little arrow is to the right of its area.
<a name="369"/>      self.border_right.x_align := Align.R
<a name="370"/>      return
<a name="371"/>   end
<a name="372"/>end
</pre></body></html>
