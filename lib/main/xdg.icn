package xdg

import 
   io,
   posix,
   util,
   lang,
   gui,
   cairo,
   ipl.strings,
   ipl.wildcard,
   ipl.sort,
   ipl.pdco

# An object for parsing and holding the parts of a locale string, like
# "en_GB.utf8".
#
class Locale()
   public const
      lang, country, encoding, modifier

   public new(s)
      s ? {
         lang := tab(upto('_.@') | 0)
         if ="_" then
            country := tab(upto('.@') | 0)
         if ="." then
            encoding := tab(upto('@') | 0)
         if ="@" then
            modifier := tab(0)
      }
      return
   end
end

# An object for holding info about a theme and the icons in its
# various directories.
#
class ThemeIndex()
   public const
      directories,   # A list of ThemeDirectory objects
      parents        # A list of parent theme names (strings)

   public new(directories, parents)
      self.directories := directories
      self.parents := parents
      return
   end   
end

# Encapsulates a directory in a theme.  This is not an actual directory,
# but gives the meta information about the several actual directories
# that it does relate to.  These actual directories are located under
# the various elements of the base directories path, and each one has
# an element in the cached_dirs member.
#
# For example an index.theme file may contain the directory group:-
#   [16x16/intl]
#   Size=16
#   Context=International
#   Type=Threshold
#
# This is represented by a ThemeDirectory.  Then, each element from
# gen_base_dirs() is appended to the theme name to give an actual
# directory :-
#
#   "/home/rparlett/.local/share/16x16/intl"
#   "/usr/local/share/16x16/intl"
#   "/usr/share/16x16/intl"
#  
# and the cached contents of those directories are stored in CachedDir
# instances in the cached_dirs list.
#
class ThemeDirectory()
   public const
      type,         # Type, a string
      size,         # Sizes etc, all integers
      minsize,      #         
      maxsize,
      threshold,
      cached_dirs   # A list of CachedDir objects

   public matches_size(desired_size, scalable_flag)
      case type of {
         "Fixed": return desired_size = size
         "Threshold": {
            return size - threshold <= desired_size <= size + threshold
         }
         "Scalable": {
            if \scalable_flag then
               return minsize <= desired_size <= maxsize
         }
      }
   end

   public directory_size_distance(desired_size, scalable_flag)
      case type of {
         "Fixed": return abs(desired_size - size)
         "Threshold": {
            if desired_size < size - threshold then 
               return minsize - desired_size
            if desired_size > size + threshold then 
               return desired_size - maxsize
            return 0
         }
         "Scalable": {
            if \scalable_flag then {
               if desired_size < minsize then
                  return minsize - desired_size
               if desired_size > maxsize then
                  return desired_size - maxsize
               return 0
            }
         }
      }
   end

   public new(type, size, minsize, maxsize, threshold, cached_dirs)
      self.type := type
      self.size := size
      self.minsize := minsize
      self.maxsize := maxsize
      self.threshold := threshold
      self.cached_dirs := cached_dirs
      return
   end
end

#
# Encapsulates cached info about a directory.
#
class CachedDir()
   public const
      file_path,    # A FilePath, giving the directory
      contents      # A set of strings, being the entries in the directory.

   # If f (no path) is in the directory, return its full path.
   #
   public access(f)
      if member(contents, f) then
         return file_path.child(f).str()
   end

   public new(file_path, contents)
      self.file_path := file_path
      self.contents := contents
      return
   end
end

#
# Represents info from a ".desktop" file
#
class DesktopEntry()
   public const
      name,                 # Descriptive name (ucs)
      icon,                 # Icon name (string)
      source,               # Source file (string)
      exec,                 # Exec entry (ucs)
      exec_line,            # optional ExecLine entry (ucs)
      path,                 # Path entry (ucs)
      terminal,             # Terminal entry (flag)
      initial_preference    # InitialPreference entry (integer or &null)

   package
      list_pos              # Used internally for initial_preference sort

   #
   # Substitute a single file, with optional line number, into the
   # Exec command, returning a command string.
   #
   public subst_file(f, line)
      local r, ch, s, fl
      s := \exec | fail
      if \line then
         s := \exec_line
      r := u""
      s ? repeat {
         r ||:= tab(upto('%') | 0)
         move(1) | break
         r ||:= case ch := string(move(1)) of {
            "%": u"%"
            "i": u"--icon " || \icon
            "c": name
            "k": ucs(source)
            !"uUfF": (fl := 1, \f)
            "L": \line
         }
      }
      # If file not substituted, then add to the end.
      if /fl then
         r ||:= u" " || \f
      return r
   end

   public new(name, icon, source, exec, exec_line, path, terminal, initial_preference)
      self.name := name
      self.icon := icon
      self.source := source
      self.exec := exec
      self.exec_line := exec_line
      self.path := path
      self.terminal := terminal
      self.initial_preference := initial_preference
      return
   end
end

#
# This class contains many static methods for looking up XDG data.
#
final abstract class Xdg()
   private static const
      LC_MESSAGES,        # A Locale object giving the LC_MESSAGES locale info
      INI_LC_KEYS,        # A list of strings used to choose locale-based keys in
                          # ini files
      ICON_THEMES,        # A map of theme names (string) to ThemeIndex objects.
      GLOBS,              # A Globs instance for file pattern matching.
      ICONS,              # A map of mime-type (string) to list of icon names (strings)
      GENERIC_ICONS,      #   - ditto -
      MIME_SUBCLASSES,    # A map of mime-type (string) to lists of mime-types (strings)
      MIME_ALIASES,       #   - ditto -
      MIME_ALTERNATIVES,  # A cache of alternative_mime_types() results,
                          #   mapping mime-type (string) to lists of mime-types (strings)
      FIND_ICON_CACHE,    # A cache of find_icon() results, mapping string key to icon
                          #   name (string)
      ICON_FALLBACK_CACHED_DIRS,  # A list of CachedDir objects
      DESKTOP_ENTRIES     # A map of mime-types (string) to list of DesktopEntry objects.

   private static readable
      icon_theme,
      scalable_flag

   private static init()
      LC_MESSAGES := Locale(getenv_ne("LC_ALL" | "LC_MESSAGES" | "LANG") | "C")
      INI_LC_KEYS := []
      every put(INI_LC_KEYS, 
                LC_MESSAGES.lang || "_" || \LC_MESSAGES.country || "@" || \LC_MESSAGES.modifier |
                LC_MESSAGES.lang || "_" || \LC_MESSAGES.country |
                LC_MESSAGES.lang || "@" || \LC_MESSAGES.modifier |
                LC_MESSAGES.lang |
                &null)
      ICON_THEMES := table()
      MIME_ALTERNATIVES := table()
      GLOBS := read_globs()
      ICONS := read_icons()
      GENERIC_ICONS := read_generic_icons()
      MIME_ALIASES := read_mime_aliases()
      MIME_SUBCLASSES := read_mime_subclasses()
      FIND_ICON_CACHE := table()
      icon_theme := get_current_icon_theme()
      ICON_FALLBACK_CACHED_DIRS := setup_icon_fallback_cached_dirs()
      scalable_flag := &yes
      DESKTOP_ENTRIES := read_desktop_entries()
   end

   #
   # Set the icon theme; fails if the theme is invalid.
   #
   public static set_icon_theme(s)
      s := string(s) | runerr(103, s)
      get_theme_index(s) | fail
      icon_theme := s
      clear(FIND_ICON_CACHE)
      return Xdg
   end

   private static getenv_ne(k)
      return "" ~== System.getenv(k)
   end

   #
   # Ensure XDG_DATA_HOME exists, or try and create it.
   #
   public static ensure_data_home()
      local f, c, s
      if s := getenv_ne("XDG_DATA_HOME") then
         Files.is_directory(s) | return error("File specified by XDG_DATA_HOME is not a directory")
      else {
         f := FilePath(Files.get_home())
         every c := ".local" | "share" do {
            f := f.child(c)
            s := f.str()
            Files.is_directory(s) | Files.mkdir(s) | return error("Couldn't create data directory " || s || ": " || &why)
         }
      }
      return s
   end

   #
   # Ensure XDG_CONFIG_HOME exists, or try and create it.
   #
   public static ensure_config_home()
      local s
      if s := getenv_ne("XDG_CONFIG_HOME") then
         Files.is_directory(s) | return error("File specified by XDG_CONFIG_HOME is not a directory")
      else {
         s := FilePath(Files.get_home()).child(".config").str()
         Files.is_directory(s) | Files.mkdir(s) | return error("Couldn't create config directory " || s || ": " || &why)
      }
      return s
   end

   #
   # Return the XDG_DATA_HOME directory
   #
   public static get_data_home()
      return getenv_ne("XDG_DATA_HOME") | FilePath(Files.get_home()).walk(".local", "share").str()
   end

   #
   # Return the XDG_CONFIG_HOME directory
   #
   public static get_config_home()
      return getenv_ne("XDG_CONFIG_HOME") | FilePath(Files.get_home()).child(".config").str()
   end

   #
   # Return the XDG_DATA_DIRS path
   #
   public static get_data_dirs()
      return getenv_ne("XDG_DATA_DIRS") | "/usr/local/share:/usr/share"
   end

   #
   # Return the XDG_CONFIG_DIRS path
   #
   public static get_config_dirs()
      return getenv_ne("XDG_CONFIG_DIRS") | "/etc/xdg"
   end

   #
   # Generate the base directories, being `get_data_home()` followed
   # by the elements of `get_data_dirs()`
   #
   public static gen_base_dirs()
      suspend get_data_home() | Files.split_paths(get_data_dirs())
   end

   private static parse_glob_file(g, s)
      local weight, type, pattern, l
      every l := separate_lines(s) do l ? {
         if weight := integer(tab(upto(':'))) & 
            move(1) &
            type := string(tab(upto(':'))) &
            move(1) &
            pattern := tab(0) then 
         {
            g.add(pattern, weight, type)
         }
      }
   end

   #
   # Given a filename, return the corresponding mime type.
   #
   public static get_mime_type_for_file(f)
      return GLOBS.lookup(f).mime_type
   end

   #
   # Generate the generic icons defined for the given mime type.
   #
   public static gen_generic_icons(mt)
      suspend .!member(GENERIC_ICONS, map(mt))
   end

   #
   # Generate the icons defined for the given mime type.
   #
   public static gen_icons(mt)
      suspend .!member(ICONS, map(mt))
   end

   #
   # Generate all the icons defined for the given mime type, namely
   # the default icon formed from substituting / for -; then the icons
   # and then the generic icons.
   #
   public static gen_all_icons(mt)
      suspend map(mt, "/" || &ucase, "-" || &lcase) | .!member(ICONS | GENERIC_ICONS, map(mt))
   end

   #
   # Generate the alternative mime types for the given mime type.
   # This recursively traverses the subclasses and aliases and
   # generates all possible alternatives.
   #
   public static alternative_mime_types(mt)
      local l
      if not(l := member(MIME_ALTERNATIVES, mt)) then {
         l := []
         alternative_mime_types1(mt, l, set())
         insert(MIME_ALTERNATIVES, mt, l)
      }
      suspend !.l
   end

   private static alternative_mime_types1(mt, l, seen)
      local sub, mmt
      mmt := map(mt)
      if member(seen, mmt) then
         fail
      put(l, mt)
      insert(seen, mmt)
      every alternative_mime_types1(!member(MIME_ALIASES, mmt), l, seen)
      if sub := member(MIME_SUBCLASSES, mmt) then
         every alternative_mime_types1(!sub, l, seen)
      else if match("text/", mmt) then
         alternative_mime_types1("text/plain", l, seen)
      else if not match("inode/", mmt) then
         alternative_mime_types1("application/octet-stream", l, seen)
   end

   private static cache_icon(f, size)
      return if endswith(f, ".svg" | ".svgz") then
         ImageCache.get_scaled_svg_key(f, size, size)
      else
         ImageCache.get_key(f)
   end

   #
   # This calls `find_icon`, caches the result in `ImageCache`, and
   # returns the cache key.
   #
   public static find_icon_and_cache(icon, size)
      return cache_icon(find_icon(icon, size), size)
   end

   #
   # This calls `find_icon_for_file`, caches the result in
   # `ImageCache`, and returns the cache key.
   #
   public static find_icon_for_file_and_cache(file, size)
      return cache_icon(find_icon_for_file(file, size), size)
   end

   private static read_generic_icons()
      local d, t, s, k, v, l
      t := table()
      every d := gen_base_dirs() do {
         if s := Files.file_to_string(FilePath(d).walk("mime", "generic-icons").str()) then {
            every l := separate_lines(s) do l ? {
               if k := map(tab(upto(':'))) &
                  move(1) &
                  v := tab(0) then
               {
                  put(member(t, k), v) | insert(t, k, [v])
               }
            }
         }
      }
      return t
   end

   private static read_icons()
      local d, t, s, k, v, l
      t := table()
      every d := gen_base_dirs() do {
         if s := Files.file_to_string(FilePath(d).walk("mime", "icons").str()) then {
            every l := separate_lines(s) do l ? {
               if k := map(tab(upto(':'))) &
                  move(1) &
                  v := tab(0) then
               {
                  put(member(t, k), v) | insert(t, k, [v])
               }
            }
         }
      }
      return t
   end

   private static read_mime_aliases()
      local d, t, s, k, v, l
      t := table()
      every d := gen_base_dirs() do {
         if s := Files.file_to_string(FilePath(d).walk("mime", "aliases").str()) then {
            every l := separate_lines(s) do l ? {
               if k := map(tab(upto(' '))) &
                  move(1) &
                  v := tab(0) then
               {
                  put(member(t, k), v) | insert(t, k, [v])
               }
            }
         }
      }
      return t
   end

   private static read_mime_subclasses()
      local d, t, s, k, v, l
      t := table()
      every d := gen_base_dirs() do {
         if s := Files.file_to_string(FilePath(d).walk("mime", "subclasses").str()) then {
            every l := separate_lines(s) do l ? {
               if k := map(tab(upto(' '))) &
                  move(1) &
                  v := tab(0) then
               {
                  put(member(t, k), v) | insert(t, k, [v])
               }
            }
         }
      }
      return t
   end

   private static read_globs()
      local d, g, s
      g := Globs()
      every d := Reverse{ gen_base_dirs() } do {
         if s := ucs(Files.file_to_string(FilePath(d).walk("mime", "globs2").str())) then
            parse_glob_file(g, s)
      }
      return g
   end

   private static unescape(s)
      local t, ch
      t := u""
      s ? repeat {
         t ||:= tab(upto('\\') | 0)
         ch := (move(1), move(1)) | break
         t ||:= case ch of {
            u"s": u" "
            u"t": u"\t"
            u"n": u"\n"
            u"r": u"\r"
            default: ch
         }
      }
      return t
   end

   # Note that this is more liberal than the desktop entry spec
   # indicates, since we want to parse the mimeapps.list file, which
   # has keys with chars outside &letters ++ &digits ++ '-'
   #
   private static parse_key_val(group)
      local key, val, enc, t
      key := trim(tab(upto('[='))) | fail
      if =u"[" then {
         enc := string(tab(upto(']'))) | fail
         move(1)
         tab(many(' '))
      }
      =u"=" | fail
      tab(many(' '))
      val := unescape(tab(0))
      (t := member(group, key)) | insert(group, key, t := table())
      insert(t, enc, val)
   end

   private static resolve_lc(group)
      local key, sel, t
      every key := default.key(group) do {
         t := member(group, key)
         if sel := member(t, !INI_LC_KEYS) then
            insert(group, key, sel)
         else
            # No matching locale (or fallback without locale), so
            # delete the key entirely.
            delete(group, key)
      }
   end

   private static parse_ini_file(s)
      local group, groups, gn, l
      groups := table()
      every l := separate_lines(s) do l ? {
         if pos(0) | match(u"#") then
            next
         if =u"[" & gn := tab(upto(']')) then {
            group := table()
            insert(groups, gn, group)
         } else
            parse_key_val(\group)
      }
      every resolve_lc(!groups)
      return groups
   end

   private static load_ini_file(f)
      return parse_ini_file(ucs(Files.file_to_string(f)))
   end

   private static dir_set1(f)
      local s, res
      res := set()
      repeat {
         s := f.read_line() | fail
         if /s then
            return res
         insert(res, s)
      }
   end

   private static dir_set(dir)
      local f
      return use {
         f := DirStream(dir),
         dir_set1(f)
      }
   end

   private static gen_theme_directories(tm)
      suspend separate(member(member(tm, u"Icon Theme"), u"Directories"))
   end

   private static gen_theme_parents(tm)
      suspend string(separate(member(member(tm, u"Icon Theme"), u"Inherits")))
   end

   # Build a ThemeIndex object given the name and the ini table.
   private static build_theme_index(theme, tm)
      local d, subdir, f, dirs, ds, m, cd,
         type, size, minsize, maxsize, threshold
      dirs := []
      every subdir := gen_theme_directories(tm) do {
         if m := member(tm, subdir) &
            size := integer(member(m, u"Size")) then 
         {
            type := string(member(m, u"Type")) | "Threshold"
            threshold := integer(member(m, u"Threshold")) | 2
            minsize := integer(member(m, u"MinSize")) | size
            maxsize := integer(member(m, u"MaxSize")) | size
            cd := []
            every d := gen_base_dirs() do {
               f := FilePath(d).walk("icons", theme).append(FilePath(subdir))
               if ds := dir_set(f.str()) & *ds > 2 then
                  put(cd, CachedDir(f, ds))
            }
            if *cd > 0 then
               put(dirs, ThemeDirectory(type, size, minsize, maxsize, threshold, cd))
         }
      }
      return ThemeIndex(dirs, ipl.pdco.List{gen_theme_parents(tm)})
   end

   private static setup_icon_fallback_cached_dirs()
      local d, p, r, ds
      r := []
      every d := gen_base_dirs() do {
         p := FilePath(d).child("icons")
         if ds := dir_set(p.str()) & *ds > 2 then
            put(r, CachedDir(p, ds))
      }
      return r
   end

   private static get_theme_index1(name)
      local d, m
      every d := gen_base_dirs() do {
         if m := build_theme_index(name, load_ini_file(FilePath(d).walk("icons", name, "index.theme").str())) then
            return m
      }
   end

   private static get_theme_index(name)
      local m
      if not(m := member(ICON_THEMES, name)) then {
         m := get_theme_index1(name)
         insert(ICON_THEMES, name, m)
      }
      return \m
   end

   #
   # Find an icon given the icon name (string) and integer size.
   #
   public static find_icon(icon, size)
      local k, v
      icon := string(icon) | runerr(103, icon)
      k := icon || "/" || size
      if not(v := member(FIND_ICON_CACHE, k)) then {
         v := find_icon_helper(icon, size, icon_theme, set()) | lookup_fallback_icon(icon)
         insert(FIND_ICON_CACHE, k, v)
      }
      return \v
   end

   #
   # Find an icon given a filename (string) and integer size.
   #
   public static find_icon_for_file(file, size)
      return find_icon(gen_all_icons(alternative_mime_types(get_mime_type_for_file(file))),
                       size)
   end

   private static get_current_icon_theme()
      local f, theme, d
      every theme := getenv_ne("OITHEME") | "oxygen" | "gnome" do {
         every d := gen_base_dirs() do {
            f := FilePath(d).walk("icons", theme, "index.theme").str()
            if Files.access(f) then
               return theme
         }
      }
      return "hicolor"
   end

   private static find_icon_helper(icon, size, theme, tried)
      local theme_index
      if member(tried, theme) then
         fail
      insert(tried, theme)
      theme_index := get_theme_index(theme) | fail

      # Try this theme, failing that try recursively with the theme's parents.
      return lookup_icon(theme_index, icon, size) | 
         find_icon_helper(icon, size, !theme_index.parents, tried)
   end

   private static lookup_fallback_icon(icon)
      return has_icon(!ICON_FALLBACK_CACHED_DIRS, icon)
   end

   private static has_icon(cached_dir, icon)
      local ex, f
      if f := cached_dir.access(icon || ".png") then
         return f
      if \scalable_flag then {
         every ex := ".svg" | ".svgz" do {
            if f := cached_dir.access(icon || ex) then {
               # Try to load cairo; if fail then don't look for svg files again.
               if /Context.LOADED then {
                  scalable_flag := &null
                  fail
               }
               return f
            }
         }
      }
   end

   private static lookup_icon(theme_index, icon, size)
      local subdir, f, minimal_size, closest_filename, ms
      every subdir := !theme_index.directories do {
         if subdir.matches_size(size, scalable_flag) then {
            # Search in all the CachedDirs in the subdir
            if f := has_icon(!subdir.cached_dirs, icon) then
               return f
         }
      }
      minimal_size := lang.Limit.MaxWord
      every subdir := !theme_index.directories do {
         if (ms := subdir.directory_size_distance(size, scalable_flag)) < minimal_size then {
            if f := has_icon(!subdir.cached_dirs, icon) then {
               closest_filename := f
               minimal_size := ms
            }
         }
      }
      return \closest_filename
   end

   private static build_desktop_entry(dm, src)
      local name, icon, exec, path, terminal, try_exec, 
         initial_preference, exec_line
      dm := member(dm, u"Desktop Entry") | fail
      member(dm, u"Type") == u"Application" | fail
      name := member(dm, u"Name") | fail

      # A TryExec entry means testing if such an exe is on the path;
      # if not ignore the entry
      if try_exec := member(dm, u"TryExec") then
         Files.find_exe(try_exec) | fail

      icon := string(member(dm, u"Icon"))
      exec := member(dm, u"Exec")
      exec_line := member(dm, u"ExecLine")
      path := member(dm, u"Path")
      terminal := if map(member(dm, u"Terminal")) == u"true" then &yes
      initial_preference := integer(member(dm, u"InitialPreference"))
      return DesktopEntry(name, icon, src, exec, exec_line, path, terminal, initial_preference)
   end

   private static gen_desktop_mime_types(dm)
      suspend "" ~== map(string(separate(member(member(dm, u"Desktop Entry"), u"MimeType"), ';')))
   end

   private static scan_application_dir(p, prefix, t, u)
      local l, e, de, mt, dm, src, key
      l := Files.ucs_list(p.str()) | fail
      every e := !l do {
         if not(Files.is_hidden(e.name)) then {
            if e.stat.mode_str[1] == "d" then {
               scan_application_dir(p.child(e.name), prefix || e.name || u"-", t, u)
            } else if endswith(e.name, u".desktop") then {
               key := prefix || e.name
               if (not member(t, key)) & 
                  src := p.child(e.name).str() &
                  dm := load_ini_file(src) &
                  de := build_desktop_entry(dm, src) then 
               {
                  insert(t, key, de)
                  every mt := gen_desktop_mime_types(dm) do
                     put(member(u, mt), de) | insert(u, mt, [de])
               }
            }
         }
      }
   end

   private static process_mimeapps_list(mm, t, u)
      local a, mime_type, l, d
      every a := member(mm, u"Added Associations" | u"Default Applications") do {
         # Each entry gives a mime type and list of desktop files, so
         # we look each one up in t.  The resulting list prepends to any
         # desktop entries there already.
         every mime_type := key(a) do {
            if l := member(u, string(mime_type)) then {
               every d := Reverse{ member(t, separate(member(a, mime_type), ';')) } do {
                  # Keep the list unique, by deleting the element (if present)
                  # we're about to push on the front.
                  delete(l, keyof(l, d))
                  push(l, d)
               }
            } else {
               insert(u, 
                      string(mime_type),
                      ipl.pdco.List{ member(t, separate(member(a, mime_type), ';')) })
            }
         }
      }
      if a := member(mm, u"Removed Associations") then {
         # Each entry gives a mime type and list of desktop files to
         # remove from the corresponding list in u.
         every mime_type := key(a) do {
            if l := member(u, string(mime_type)) then {
               # Lookup the DesktopEntry (in t) and then delete it from l.
               every d := member(t, separate(member(a, mime_type), ';')) do
                  delete(l, keyof(l, d))
            }
         }
      }
   end

   private static prefcmp(d1, d2)
      local ip1, ip2
      ip1 := \d1.initial_preference | -1
      ip2 := \d2.initial_preference | -1
      return (ip1 > ip2) | (ip1 = ip2 & d1.list_pos > d2.list_pos)
   end

   private static sort_by_preference(l)
      local e, i
      # Do nothing if they're all unset
      \ (!l).initial_preference | fail
      # The list_pos is used to maintain the original ordering if the
      # preferences for two entries are the same.
      i := *l
      every e := !l do {
         e.list_pos := i
         i -:= 1
      }
      qsort(l, prefcmp)
   end

   private static read_desktop_entries()
      local d, t, u, f, mm
      t := table()    # maps desktop entry names (ucs, eg u"kate.desktop") to DesktopEntry object
      u := table()    # mime-type (string) to list of DesktopEntry
      every d := gen_base_dirs() do
         scan_application_dir(FilePath(d).child("applications"), u"", t, u)

      # Sort each list of DesktopEntry by the initial preference field.
      every sort_by_preference(!u)

      # Process customisations from the mimeapps.lists files.
      every d := Reverse{ gen_base_dirs() } do {
         f := FilePath(d).walk("applications", "mimeapps.list").str()
         if mm := load_ini_file(f) then
            process_mimeapps_list(mm, t, u)
      }

      return u
   end

   #
   # Generate the `DesktopEntry` objects suitable for a particular
   # filename (without path), with the most suitable first.
   #
   public static gen_desktop_entries_for_file(file)
      suspend Unique{gen_desktop_entries(alternative_mime_types(get_mime_type_for_file(file)))}
   end

   #
   # Given a mime type (string), generate the corresponding `DesktopEntry` objects, in preference order.
   #
   public static gen_desktop_entries(mt)
      suspend .!member(DESKTOP_ENTRIES, map(mt))
   end
end

#
# An entry in the `Globs` object.
#
class GlobMatch()
   public const
      weight,      # The integer weight
      mime_type,   # The mime mime_type (string)
      pattern      # An optional wildcard pattern.

   public new(weight, mime_type, pattern)
      self.weight := weight
      self.mime_type := mime_type
      self.pattern := pattern
      return
   end
end

# A helper class used to store wildcard ("globbing") information
# associated with mime-types.
#
class Globs()
   private const
      literal,
      simple,
      other

   public lookup(f)
      local i, v, fm
      f := ucs(f) | fail
      fm := map(f)
      if v := member(literal, f | fm) then
         return v
      every i := upto('.', f) do {
         if v := member(simple, (f | fm)[i + 1:0]) then
            return v
      }
      every v := !other do {
         if v.pattern.match(f | fm) then
            return v
      }
   end

   #
   # Add an entry.  p is the pattern (ucs), weight an integer and mime_type
   # the mime type (string).
   #
   public add(p, weight, mime_type)
      local x, t, k
      if p == u"__NOGLOBS__" then {
         every t := literal | simple | other do {
            every k := key(t) do {
               if t[k].mime_type == mime_type then
                  delete(t, k)
            }
         }
      } else if upto('*?[', p) then {
         if match(u"*.", p) & not upto('*?[', p[3:0]) then {
            p := p[3:0]
            x := member(simple, p)
            if /x | (weight > x.weight) then
               insert(simple, p, GlobMatch(weight, mime_type))
         } else {
            x := member(other, p)
            if /x | (weight > x.weight) then
               insert(other, p, GlobMatch(weight, mime_type, Wildcard(p)))
         }
      } else {
         x := member(literal, p)
         if /x | (weight > x.weight) then
            insert(literal, p, GlobMatch(weight, mime_type))
      }
      return self
   end

   public new()
      literal := table()
      simple := table()
      other := table()
      return
   end
end
