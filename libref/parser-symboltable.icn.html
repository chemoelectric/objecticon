<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>symboltable.icn</title></head><body><pre>
<a name="1"/>package parser
<a name="2"/>
<a name="3"/>import 
<a name="4"/>   util(Connectable, error, need_flag, env_string), 
<a name="5"/>   lang(Text),
<a name="6"/>   datastruct(SortTable),
<a name="7"/>   io
<a name="8"/>
<a name="9"/>abstract protected class Symbol()
<a name="10"/>   public const
<a name="11"/>      scanned_file,
<a name="12"/>      obj,
<a name="13"/>      name
<a name="14"/>
<a name="15"/>   public get_package()
<a name="16"/>      return \scanned_file.pack
<a name="17"/>   end
<a name="18"/>
<a name="19"/>   # Return the fully-qualified name of the Symbol.
<a name="20"/>   public abstract get_fq_name()
<a name="21"/>
<a name="22"/>   # Return the fully-qualified name of the Symbol, but
<a name="23"/>   # symbols not in a package are prefixed with "default.".
<a name="24"/>   public abstract get_fq_name_default()
<a name="25"/>
<a name="26"/>   package new(scanned_file, obj, name)
<a name="27"/>      self.scanned_file := scanned_file
<a name="28"/>      self.obj := obj
<a name="29"/>      self.name := name
<a name="30"/>      return
<a name="31"/>   end
<a name="32"/>end
<a name="33"/>
<a name="34"/>abstract class TopLevelSymbol(Symbol)
<a name="35"/>   public abstract has_package_flag()
<a name="36"/>
<a name="37"/>   public override get_fq_name()
<a name="38"/>      return (\scanned_file.pack || "." || name) | name
<a name="39"/>   end
<a name="40"/>
<a name="41"/>   public override get_fq_name_default()
<a name="42"/>      return (\scanned_file.pack || "." || name) | ("default." || name)
<a name="43"/>   end
<a name="44"/>end
<a name="45"/>
<a name="46"/>class ProcedureSymbol(TopLevelSymbol)
<a name="47"/>   public override has_package_flag()
<a name="48"/>      succeed if is(obj, Tree) then
<a name="49"/>         obj.get_package_flag()
<a name="50"/>      else
<a name="51"/>         \obj.package_flag
<a name="52"/>   end
<a name="53"/>end
<a name="54"/>
<a name="55"/>class BuiltinSymbol(TopLevelSymbol)
<a name="56"/>   public override has_package_flag()
<a name="57"/>   end
<a name="58"/>
<a name="59"/>   package override new(name)
<a name="60"/>      self.name := name
<a name="61"/>      return
<a name="62"/>   end
<a name="63"/>end
<a name="64"/>
<a name="65"/>class RecordSymbol(TopLevelSymbol)
<a name="66"/>   public override has_package_flag()
<a name="67"/>      succeed if is(obj, Tree) then
<a name="68"/>         obj.get_package_flag()
<a name="69"/>      else
<a name="70"/>         \obj.package_flag
<a name="71"/>   end
<a name="72"/>end
<a name="73"/>
<a name="74"/>class GlobalSymbol(TopLevelSymbol)
<a name="75"/>   public const
<a name="76"/>      decl_obj
<a name="77"/>
<a name="78"/>   public override has_package_flag()
<a name="79"/>      # Check the "global" node (rather than the ident node).
<a name="80"/>      succeed if is(decl_obj, Tree) then
<a name="81"/>         decl_obj.get_package_flag()
<a name="82"/>      else
<a name="83"/>         \decl_obj.package_flag
<a name="84"/>   end
<a name="85"/>
<a name="86"/>   public has_readable_flag()
<a name="87"/>      # Check the "global" node (rather than the ident node).
<a name="88"/>      succeed if is(decl_obj, Tree) then
<a name="89"/>         decl_obj.get_readable_flag()
<a name="90"/>      else
<a name="91"/>         \decl_obj.readable_flag
<a name="92"/>   end
<a name="93"/>
<a name="94"/>   package override new(scanned_file, obj, name, decl_obj)
<a name="95"/>      Symbol.new(scanned_file, obj, name)
<a name="96"/>      self.decl_obj := decl_obj
<a name="97"/>      return
<a name="98"/>   end
<a name="99"/>end
<a name="100"/>
<a name="101"/>class ClassSymbol(TopLevelSymbol)
<a name="102"/>   package
<a name="103"/>      fields,
<a name="104"/>      supers,
<a name="105"/>      resolved_supers, 
<a name="106"/>      implemented_fields,
<a name="107"/>      implemented_classes
<a name="108"/>
<a name="109"/>   public get_supers()
<a name="110"/>      suspend .!supers
<a name="111"/>   end
<a name="112"/>
<a name="113"/>   public add_super(s)
<a name="114"/>      put(supers, s)
<a name="115"/>      link
<a name="116"/>   end
<a name="117"/>
<a name="118"/>   public get_resolved_supers()
<a name="119"/>      suspend .!resolved_supers
<a name="120"/>   end
<a name="121"/>
<a name="122"/>   package add_resolved_super(c)
<a name="123"/>      put(self.resolved_supers, c)
<a name="124"/>      link
<a name="125"/>   end
<a name="126"/>
<a name="127"/>   public get_implemented_fields()
<a name="128"/>      suspend .!self.implemented_fields
<a name="129"/>   end
<a name="130"/>
<a name="131"/>   public get_implemented_field(n)
<a name="132"/>      return member(implemented_fields, n)
<a name="133"/>   end
<a name="134"/>
<a name="135"/>   public get_implemented_classes()
<a name="136"/>      suspend .!self.implemented_classes
<a name="137"/>   end
<a name="138"/>
<a name="139"/>   package set_implemented_classes(l)
<a name="140"/>      local f
<a name="141"/>      implemented_classes := l
<a name="142"/>      implemented_fields := table()
<a name="143"/>      every f := !(!implemented_classes).fields do 
<a name="144"/>         member(implemented_fields, f.name) | insert(implemented_fields, f.name, f)
<a name="145"/>      link
<a name="146"/>   end
<a name="147"/>
<a name="148"/>   public get_field(n)
<a name="149"/>      return member(fields, n)
<a name="150"/>   end
<a name="151"/>
<a name="152"/>   public get_fields()
<a name="153"/>      suspend .!self.fields
<a name="154"/>   end
<a name="155"/>
<a name="156"/>   package add_field(f)
<a name="157"/>      insert(fields, f.name, f)
<a name="158"/>      link
<a name="159"/>   end
<a name="160"/>
<a name="161"/>   public override has_package_flag()
<a name="162"/>      succeed if is(obj, Tree) then
<a name="163"/>         obj.get_package_flag()
<a name="164"/>      else
<a name="165"/>         \obj.package_flag
<a name="166"/>   end
<a name="167"/>
<a name="168"/>   public is_final()
<a name="169"/>      succeed if is(obj, Tree) then
<a name="170"/>         obj.get_access().gen().str() == "final"
<a name="171"/>      else
<a name="172"/>         iand(obj.flags, lang.Class.Final) ~= 0
<a name="173"/>   end
<a name="174"/>
<a name="175"/>   public is_protected()
<a name="176"/>      succeed if is(obj, Tree) then
<a name="177"/>         obj.get_access().gen().str() == "protected"
<a name="178"/>      else
<a name="179"/>         iand(obj.flags, lang.Class.Protected) ~= 0
<a name="180"/>   end
<a name="181"/>
<a name="182"/>   public is_abstract()
<a name="183"/>      succeed if is(obj, Tree) then
<a name="184"/>         obj.get_access().gen().str() == "abstract"
<a name="185"/>      else
<a name="186"/>         iand(obj.flags, lang.Class.Abstract) ~= 0
<a name="187"/>   end
<a name="188"/>
<a name="189"/>   package override new(scanned_file, obj, name)
<a name="190"/>      Symbol.new(scanned_file, obj, name)
<a name="191"/>      self.fields := table()
<a name="192"/>      self.supers := []
<a name="193"/>      self.resolved_supers := []
<a name="194"/>      return
<a name="195"/>   end
<a name="196"/>end
<a name="197"/>
<a name="198"/>class ClassField(Symbol)
<a name="199"/>   public const
<a name="200"/>      defining_class
<a name="201"/>
<a name="202"/>   public override get_fq_name()
<a name="203"/>      return defining_class.get_fq_name() || "." || name
<a name="204"/>   end
<a name="205"/>
<a name="206"/>   public override get_fq_name_default()
<a name="207"/>      return defining_class.get_fq_name_default() || "." || name
<a name="208"/>   end
<a name="209"/>
<a name="210"/>   package override new(defining_class, obj, name)
<a name="211"/>      Symbol.new(defining_class.scanned_file, obj, name)
<a name="212"/>      self.defining_class := defining_class
<a name="213"/>      return
<a name="214"/>   end
<a name="215"/>end
<a name="216"/>
<a name="217"/>class ClassVariable(ClassField)
<a name="218"/>   public const
<a name="219"/>      decl_obj
<a name="220"/>
<a name="221"/>   package override new(defining_class, obj, name, decl_obj)
<a name="222"/>      ClassField.new(defining_class, obj, name)
<a name="223"/>      self.decl_obj := decl_obj
<a name="224"/>      return
<a name="225"/>   end
<a name="226"/>end
<a name="227"/>
<a name="228"/>class ClassMethod(ClassField)
<a name="229"/>end
<a name="230"/>
<a name="231"/>final class ScannedFile()
<a name="232"/>   public const
<a name="233"/>      filename
<a name="234"/>
<a name="235"/>   private readable
<a name="236"/>      obj,
<a name="237"/>      strinv,
<a name="238"/>      methinv
<a name="239"/>
<a name="240"/>   private const
<a name="241"/>      imports,
<a name="242"/>      invocables,
<a name="243"/>      resolved_invocables,
<a name="244"/>      symbols
<a name="245"/>
<a name="246"/>   private readable
<a name="247"/>      pack
<a name="248"/>
<a name="249"/>   package set_obj(obj)
<a name="250"/>      self.obj := obj
<a name="251"/>      link
<a name="252"/>   end
<a name="253"/>
<a name="254"/>   package set_package(pack)
<a name="255"/>      self.pack := pack
<a name="256"/>      link
<a name="257"/>   end
<a name="258"/>      
<a name="259"/>   package add_symbol(sym)
<a name="260"/>      insert(symbols, sym.name, sym)
<a name="261"/>      link
<a name="262"/>   end
<a name="263"/>
<a name="264"/>   public get_symbol(name)
<a name="265"/>      return member(symbols, name)
<a name="266"/>   end
<a name="267"/>
<a name="268"/>   public get_symbols()
<a name="269"/>      suspend .!symbols
<a name="270"/>   end
<a name="271"/>
<a name="272"/>   package add_import(i)
<a name="273"/>      insert(imports, i.name, i)
<a name="274"/>      link
<a name="275"/>   end
<a name="276"/>
<a name="277"/>   public get_import(name)
<a name="278"/>      return member(imports, name)
<a name="279"/>   end
<a name="280"/>
<a name="281"/>   public get_imports()
<a name="282"/>      suspend .!imports
<a name="283"/>   end
<a name="284"/>
<a name="285"/>   public get_resolved_invocables()
<a name="286"/>      suspend .!resolved_invocables
<a name="287"/>   end
<a name="288"/>
<a name="289"/>   package add_resolved_invocable(sym)
<a name="290"/>      put(resolved_invocables, sym)
<a name="291"/>      link
<a name="292"/>   end
<a name="293"/>
<a name="294"/>   public get_invocables()
<a name="295"/>      suspend .!invocables
<a name="296"/>   end
<a name="297"/>
<a name="298"/>   package add_invocable(sym)
<a name="299"/>      put(invocables, sym)
<a name="300"/>      link
<a name="301"/>   end
<a name="302"/>
<a name="303"/>   package set_strinv(v)
<a name="304"/>      self.strinv := need_flag(v)
<a name="305"/>      link
<a name="306"/>   end
<a name="307"/>
<a name="308"/>   package set_methinv(v)
<a name="309"/>      self.methinv := need_flag(v)
<a name="310"/>      link
<a name="311"/>   end
<a name="312"/>
<a name="313"/>   public convert_dottedidentexpr(n)
<a name="314"/>      local ls
<a name="315"/>      if is(n, Token) then
<a name="316"/>         return n.s
<a name="317"/>      ls := Util.dottedid2string(n.child(1))
<a name="318"/>      if (ls == (\pack | "default")) | member(imports, ls) then
<a name="319"/>         return ls || "." || n.child(3).s
<a name="320"/>      return convert_dottedidentexpr(n.child(1))
<a name="321"/>   end
<a name="322"/>
<a name="323"/>   package new(filename)
<a name="324"/>      self.filename := filename
<a name="325"/>      self.imports := table()
<a name="326"/>      self.symbols := table()
<a name="327"/>      self.invocables := []
<a name="328"/>      self.resolved_invocables := []
<a name="329"/>      return
<a name="330"/>   end
<a name="331"/>end
<a name="332"/>
<a name="333"/>final class ImportDec()
<a name="334"/>   public const
<a name="335"/>      mode,
<a name="336"/>      name
<a name="337"/>
<a name="338"/>   private const 
<a name="339"/>      syms
<a name="340"/>
<a name="341"/>   public static const
<a name="342"/>      All, Some, Except
<a name="343"/>
<a name="344"/>   private static init()
<a name="345"/>      All := 0
<a name="346"/>      Some := 1
<a name="347"/>      Except := 2
<a name="348"/>   end
<a name="349"/>
<a name="350"/>   package add(sym)
<a name="351"/>      insert(syms, sym)
<a name="352"/>   end
<a name="353"/>
<a name="354"/>   public has(sym)
<a name="355"/>      succeed member(syms, sym)
<a name="356"/>   end
<a name="357"/>
<a name="358"/>   package new(name, mode)
<a name="359"/>      self.name := name
<a name="360"/>      self.mode := mode
<a name="361"/>      self.syms := set()
<a name="362"/>      return
<a name="363"/>   end
<a name="364"/>end
<a name="365"/>
<a name="366"/>class SymbolTable(Connectable)
<a name="367"/>   private
<a name="368"/>      pparser,
<a name="369"/>      package_db,
<a name="370"/>      symbol_table, 
<a name="371"/>      scanned_files,
<a name="372"/>      scanned_packages,
<a name="373"/>      file_mode,
<a name="374"/>      pp_defs
<a name="375"/>
<a name="376"/>   public static const
<a name="377"/>      SCANNING_EVENT,
<a name="378"/>      PREFER_SRC,
<a name="379"/>      PREFER_U,
<a name="380"/>      ALWAYS_SRC,
<a name="381"/>      ALWAYS_U
<a name="382"/>
<a name="383"/>   private static const
<a name="384"/>      BUILTINS
<a name="385"/>
<a name="386"/>   private static init()
<a name="387"/>      SCANNING_EVENT := "scanning"
<a name="388"/>      PREFER_SRC := "prefer_src"
<a name="389"/>      PREFER_U := "prefer_u"
<a name="390"/>      ALWAYS_SRC := "always_src"
<a name="391"/>      ALWAYS_U := "always_u"
<a name="392"/>      BUILTINS := set()
<a name="393"/>      every insert(BUILTINS, lang.Proc.get_name(lang.Prog.get_functions()))
<a name="394"/>   end
<a name="395"/>
<a name="396"/>   private parse(f)
<a name="397"/>      local prog
<a name="398"/>      prog := pparser.parse_file(f, pp_defs) | fail
<a name="399"/>      return prog
<a name="400"/>   end
<a name="401"/>
<a name="402"/>   public dump()
<a name="403"/>      local e, f
<a name="404"/>      every e := !sort(symbol_table) do {
<a name="405"/>         write(e[1],"-&gt;",lang.Class.get_name(e[2]), " in file ", (\e[2].scanned_file).filename | "-")
<a name="406"/>         if is(e[2], ClassSymbol) then {
<a name="407"/>            every f := !sort(\e[2].implemented_fields) do {
<a name="408"/>               write("\t", f[1], "-&gt;", lang.Class.get_name(f[2]), " from ", f[2].defining_class.name)
<a name="409"/>            }
<a name="410"/>         }
<a name="411"/>      }
<a name="412"/>   end
<a name="413"/>
<a name="414"/>   private add_symbol(sym)
<a name="415"/>      local k
<a name="416"/>      k := sym.get_fq_name()
<a name="417"/>      if \symbol_table[k] then
<a name="418"/>         return error("Symbol " || k || " already defined in " || symbol_table[k].scanned_file.filename)
<a name="419"/>      symbol_table[k] := sym
<a name="420"/>      sym.scanned_file.add_symbol(sym)
<a name="421"/>      link
<a name="422"/>   end
<a name="423"/>
<a name="424"/>   private get_stem(f)
<a name="425"/>      if Text.lower(f[-4:0]) == ".icn" then
<a name="426"/>         return f[1:-4]
<a name="427"/>      if Text.lower(f[-2:0]) == ".u" then
<a name="428"/>         return f[1:-2]
<a name="429"/>      return f
<a name="430"/>   end
<a name="431"/>
<a name="432"/>   private match_stem(f)
<a name="433"/>      local fu, fi
<a name="434"/>      fu := f || ".u"
<a name="435"/>      fi := f || ".icn"
<a name="436"/>      case file_mode of {
<a name="437"/>         PREFER_SRC : {
<a name="438"/>            if Files.access(fi, Access.R_OK) then 
<a name="439"/>               return fi
<a name="440"/>            if Files.access(fu, Access.R_OK) then
<a name="441"/>               return fu
<a name="442"/>         }
<a name="443"/>         PREFER_U : {
<a name="444"/>            if Files.access(fu, Access.R_OK) then
<a name="445"/>               return fu
<a name="446"/>            if Files.access(fi, Access.R_OK) then 
<a name="447"/>               return fi
<a name="448"/>         }
<a name="449"/>         ALWAYS_SRC : {
<a name="450"/>            if Files.access(fi, Access.R_OK) then 
<a name="451"/>               return fi
<a name="452"/>         }
<a name="453"/>         ALWAYS_U : {
<a name="454"/>            if Files.access(fu, Access.R_OK) then
<a name="455"/>               return fu
<a name="456"/>         }
<a name="457"/>      }
<a name="458"/>   end
<a name="459"/>
<a name="460"/>   private scan(f)
<a name="461"/>      local sf, i, g
<a name="462"/>      # Standardize by getting rid of the extension
<a name="463"/>      f := get_stem(f)
<a name="464"/>      if scanned_files.member(f) then
<a name="465"/>         link
<a name="466"/>      g := match_stem(f) | return error("No .icn or .u file at " || f)
<a name="467"/>      fire(SCANNING_EVENT, g)
<a name="468"/>      sf := ScannedFile(g)
<a name="469"/>      scanned_files.insert(f, sf)
<a name="470"/>      if Text.lower(g[-4:0]) == ".icn" then
<a name="471"/>         scan_src(sf) | fail
<a name="472"/>      else
<a name="473"/>         scan_u(sf) | fail
<a name="474"/>      if \sf.pack then
<a name="475"/>         scan_package(sf.pack) | fail
<a name="476"/>      every i := sf.get_imports() do
<a name="477"/>         scan_package(i.name) | fail
<a name="478"/>
<a name="479"/>      link
<a name="480"/>   end
<a name="481"/>
<a name="482"/>   private scan_src(sf)
<a name="483"/>      local c, d, e, f, s, i, prog, mode
<a name="484"/>
<a name="485"/>      prog := parse(sf.filename) | fail
<a name="486"/>      sf.set_obj(prog)
<a name="487"/>
<a name="488"/>      # Optional package
<a name="489"/>      sf.set_package(prog.get_package().get_name().str())
<a name="490"/>
<a name="491"/>      # Any imports
<a name="492"/>      every e := prog.get_imports().gen().gen() do {
<a name="493"/>         if is(e, Id) then
<a name="494"/>            sf.add_import(ImportDec(e.str(), ImportDec.All))
<a name="495"/>         else {
<a name="496"/>            s := e.get_package().str()
<a name="497"/>            unless i := sf.get_import(s) then {
<a name="498"/>               mode := if e.pos.size() = 4 then 
<a name="499"/>                  ImportDec.Some else ImportDec.Except
<a name="500"/>               i := ImportDec(s, mode)
<a name="501"/>               sf.add_import(i)
<a name="502"/>            }
<a name="503"/>            every i.add(e.gen().str())
<a name="504"/>         }
<a name="505"/>      }
<a name="506"/>
<a name="507"/>      # All other decs.
<a name="508"/>      every d := prog.get_body().gen() do {
<a name="509"/>         case classof(d) of {
<a name="510"/>            Global : {
<a name="511"/>               every s := d.gen() do
<a name="512"/>                  add_symbol(GlobalSymbol(sf, s, s.str(), d)) | fail
<a name="513"/>            }
<a name="514"/>            Procedure : add_symbol(ProcedureSymbol(sf, d, d.get_name().str())) | fail
<a name="515"/>            Class : {
<a name="516"/>               c := ClassSymbol(sf, d, d.get_name().str())
<a name="517"/>               every c.add_super(d.get_supers().gen().str())
<a name="518"/>               every e := d.get_members().gen() do {
<a name="519"/>                  case classof(e) of {
<a name="520"/>                     FieldList: {
<a name="521"/>                        every f := e.gen() do
<a name="522"/>                           c.add_field(ClassVariable(c, f, f.str(), e))
<a name="523"/>                     }
<a name="524"/>                     DeferredMethod | Method:
<a name="525"/>                        c.add_field(ClassMethod(c, e, e.get_name().str()))
<a name="526"/>                  }
<a name="527"/>               }
<a name="528"/>               add_symbol(c) | fail
<a name="529"/>            }
<a name="530"/>
<a name="531"/>            Record : add_symbol(RecordSymbol(sf, d, d.get_name().str())) | fail
<a name="532"/>            Invocable : {
<a name="533"/>               every e := d.gen() do {
<a name="534"/>                  if is(e, Id) then {
<a name="535"/>                     s := e.str()
<a name="536"/>                     case s of {
<a name="537"/>                        "all": sf.set_strinv(&amp;yes)
<a name="538"/>                        "methods": sf.set_methinv(&amp;yes)
<a name="539"/>                        default: {
<a name="540"/>                           if s[1] == "\"" then
<a name="541"/>                              s := s[2:-1]
<a name="542"/>                           sf.add_invocable(s)
<a name="543"/>                        }
<a name="544"/>                     }
<a name="545"/>                  }
<a name="546"/>               }
<a name="547"/>            }
<a name="548"/>            default : syserr("Unknown global dec type:" || d)
<a name="549"/>         }
<a name="550"/>      }
<a name="551"/>      return
<a name="552"/>   end
<a name="553"/>
<a name="554"/>   private scan_u(sf)
<a name="555"/>      local s, r, uf, d, c, e
<a name="556"/>      s := Files.file_to_string(sf.filename) | return error("Couldn't read " || sf.filename)
<a name="557"/>      r := UReader()
<a name="558"/>      uf := (s ? r.scan_decls()) | return error("Couldn't scan ufile: " || &amp;why)
<a name="559"/>      sf.set_obj(uf)
<a name="560"/>      sf.set_package(uf.pack)
<a name="561"/>      every sf.add_import(uf.get_imports())
<a name="562"/>      sf.set_strinv(uf.strinv)
<a name="563"/>      sf.set_methinv(uf.methinv)
<a name="564"/>      every sf.add_invocable(uf.get_invocables())
<a name="565"/>      every d := uf.get_symbols() do {
<a name="566"/>         case classof(d) of {
<a name="567"/>            UGlobal : add_symbol(GlobalSymbol(sf, d, d.name, d)) | fail
<a name="568"/>            UProcedure : add_symbol(ProcedureSymbol(sf, d, d.name)) | fail
<a name="569"/>            UClass : {
<a name="570"/>               c := ClassSymbol(sf, d, d.name)
<a name="571"/>               every c.add_super(d.get_supers())
<a name="572"/>               every e := d.get_fields() do {
<a name="573"/>                  case classof(e) of {
<a name="574"/>                     UMethod :
<a name="575"/>                        c.add_field(ClassMethod(c, e, e.name))
<a name="576"/>                     UVariable :
<a name="577"/>                        c.add_field(ClassVariable(c, e, e.name, e))
<a name="578"/>                     default :
<a name="579"/>                        syserr("Unknown type:" || e)
<a name="580"/>                  }
<a name="581"/>               }
<a name="582"/>               add_symbol(c) | fail
<a name="583"/>            }
<a name="584"/>            URecord : add_symbol(RecordSymbol(sf, d, d.name)) | fail
<a name="585"/>            default : syserr("Unknown ufile type:" || d)
<a name="586"/>         }
<a name="587"/>      }
<a name="588"/>      return
<a name="589"/>   end
<a name="590"/>
<a name="591"/>   public scan_file(f)
<a name="592"/>      return scan(FilePath(f).canonical().str())
<a name="593"/>   end
<a name="594"/>
<a name="595"/>   private ensure_package_db()
<a name="596"/>      local d, p, s, f, t
<a name="597"/>      if \package_db then
<a name="598"/>         return
<a name="599"/>      package_db := SortTable(, Files.standard_case_cmp)
<a name="600"/>      every d := Files.getcwd() | Files.split_paths(env_string("OI_PATH")) do {
<a name="601"/>         p := FilePath(d).canonical()
<a name="602"/>         s := p.str()
<a name="603"/>         unless package_db.member(s) then {
<a name="604"/>            if f := open(p.child("packages.txt").str(), "r") then {
<a name="605"/>               unless t := scan_packtxt(f) then {
<a name="606"/>                  f.close()
<a name="607"/>                  fail
<a name="608"/>               }
<a name="609"/>               f.close()
<a name="610"/>            } else
<a name="611"/>               t := table()
<a name="612"/>            package_db.insert(s, t)
<a name="613"/>         }
<a name="614"/>      }
<a name="615"/>      return
<a name="616"/>   end
<a name="617"/>
<a name="618"/>   private scan_packtxt(f)
<a name="619"/>      local s, t, u
<a name="620"/>      t := table()
<a name="621"/>      while s := read(f) do {
<a name="622"/>         if s == "&gt;package" then {
<a name="623"/>            s := read(f) | return error("Corrupt - package name expected following package")
<a name="624"/>            if member(t, s) then
<a name="625"/>               return error("Corrupt - duplicate package entry")
<a name="626"/>            insert(t, s, u := set())
<a name="627"/>         } else
<a name="628"/>            insert(\u, s) | return error("Corrupt - package expected")
<a name="629"/>      }
<a name="630"/>      return t
<a name="631"/>   end
<a name="632"/>
<a name="633"/>   public get_all_packages()
<a name="634"/>      ensure_package_db() | fail
<a name="635"/>      suspend key(package_db.gen())
<a name="636"/>   end
<a name="637"/>
<a name="638"/>   public scan_package(p)
<a name="639"/>      local fs, seen, f, n
<a name="640"/>      if member(scanned_packages, p) then
<a name="641"/>         link
<a name="642"/>      insert(scanned_packages, p)
<a name="643"/>      ensure_package_db() | fail
<a name="644"/>      every n := package_db.nodes() do {
<a name="645"/>         if fs := \n.val[p] then {
<a name="646"/>            if \seen then
<a name="647"/>               return error("Located package " || p || " in multiple directories")
<a name="648"/>            every f := FilePath(n.key).child(!fs).str()  do
<a name="649"/>               scan(f) | fail
<a name="650"/>            seen := &amp;yes
<a name="651"/>         }
<a name="652"/>      }
<a name="653"/>      if /seen then
<a name="654"/>         return error("Cannot resolve package " || p)
<a name="655"/>      link
<a name="656"/>   end
<a name="657"/>
<a name="658"/>   public gen_symbol_names()
<a name="659"/>      suspend key(symbol_table)
<a name="660"/>   end
<a name="661"/>
<a name="662"/>   public gen_symbols()
<a name="663"/>      suspend .!symbol_table
<a name="664"/>   end
<a name="665"/>
<a name="666"/>   public add_builtins()
<a name="667"/>      local x
<a name="668"/>      every x := !BUILTINS do
<a name="669"/>         insert(symbol_table, x, BuiltinSymbol(x))
<a name="670"/>      link
<a name="671"/>   end
<a name="672"/>
<a name="673"/>   public gb_locate(name)
<a name="674"/>      local x
<a name="675"/>      if x := glocate(name) then
<a name="676"/>         return x
<a name="677"/>      if member(BUILTINS, name) then {
<a name="678"/>         insert(symbol_table, name, x := BuiltinSymbol(name))
<a name="679"/>         return x
<a name="680"/>      }
<a name="681"/>   end
<a name="682"/>
<a name="683"/>   public glocate(name)
<a name="684"/>      return member(symbol_table, name)
<a name="685"/>   end
<a name="686"/>
<a name="687"/>   public get_scanned_file(f)
<a name="688"/>      return scanned_files.member(get_stem(FilePath(f).canonical().str()))
<a name="689"/>   end
<a name="690"/>
<a name="691"/>   private static check_package_access(sf, sym)
<a name="692"/>      if sym.has_package_flag() &amp;
<a name="693"/>         not(is(sym, GlobalSymbol) &amp; sym.has_readable_flag()) &amp;
<a name="694"/>         sf.pack ~=== "lang" &amp;
<a name="695"/>         sf.pack ~=== sym.scanned_file.pack then
<a name="696"/>         fail
<a name="697"/>      return sym
<a name="698"/>   end
<a name="699"/>
<a name="700"/>   public resolve_n(sf, name)
<a name="701"/>      local r, i, g
<a name="702"/>
<a name="703"/>      r := []
<a name="704"/>      name ? if upto('.') then {
<a name="705"/>         if ="default." then
<a name="706"/>            name := tab(0)
<a name="707"/>         put(r, check_package_access(sf, gb_locate(name)))
<a name="708"/>         return r
<a name="709"/>      }
<a name="710"/>      if \sf.pack then
<a name="711"/>         put(r, glocate(sf.pack || "." || name))
<a name="712"/>      else
<a name="713"/>         put(r, gb_locate(name))
<a name="714"/>      every i := sf.get_imports() do {
<a name="715"/>         if (i.mode = ImportDec.All) |
<a name="716"/>            (i.mode = ImportDec.Some &amp; i.has(name)) |
<a name="717"/>            (i.mode = ImportDec.Except &amp; not i.has(name))
<a name="718"/>         then
<a name="719"/>            put(r, check_package_access(sf, glocate(i.name || "." || name)))
<a name="720"/>      }
<a name="721"/>      if \sf.pack &amp; (*r = 0) then {
<a name="722"/>         if g := gb_locate(name) &amp; is(g, BuiltinSymbol) then
<a name="723"/>            put(r, g)
<a name="724"/>      }
<a name="725"/>      return r
<a name="726"/>   end
<a name="727"/>
<a name="728"/>   public resolve(sf, name)
<a name="729"/>      local l
<a name="730"/>      l := resolve_n(sf, name) | fail
<a name="731"/>      if *l = 0 then
<a name="732"/>         return error("Couldn't resolve symbol " || name)
<a name="733"/>      if *l &gt; 1 then
<a name="734"/>         return error("Ambiguous symbol " || name)
<a name="735"/>      return l[1]
<a name="736"/>   end
<a name="737"/>
<a name="738"/>   public resolve_classes()
<a name="739"/>      resolve_invocables() | fail
<a name="740"/>      resolve_supers() | fail
<a name="741"/>      compute_inheritance() | fail
<a name="742"/>      link
<a name="743"/>   end
<a name="744"/>
<a name="745"/>   public gen_type(c)
<a name="746"/>      local e
<a name="747"/>      every e := !symbol_table do
<a name="748"/>         if is(e, c) then
<a name="749"/>            suspend e
<a name="750"/>   end
<a name="751"/>
<a name="752"/>   private resolve_invocables()
<a name="753"/>      local sf, s, x
<a name="754"/>      every sf := scanned_files.gen() do {
<a name="755"/>         every s := sf.get_invocables() do {
<a name="756"/>            if s[1] ~== "." then {
<a name="757"/>               x := resolve(sf, s) | fail
<a name="758"/>               sf.add_resolved_invocable(x)
<a name="759"/>            }
<a name="760"/>         }
<a name="761"/>      }
<a name="762"/>      return
<a name="763"/>   end
<a name="764"/>
<a name="765"/>   private resolve_supers()
<a name="766"/>      local c, sup_name, sup
<a name="767"/>      every c := gen_type(ClassSymbol) do {
<a name="768"/>         every sup_name := c.get_supers() do {
<a name="769"/>            sup := resolve(c.scanned_file, sup_name) | fail
<a name="770"/>            is(sup, ClassSymbol) | return error("Superclass of " || c.name || " not a class")
<a name="771"/>            c.add_resolved_super(sup)
<a name="772"/>         }
<a name="773"/>      }
<a name="774"/>      return
<a name="775"/>   end
<a name="776"/>
<a name="777"/>   private compute_inheritance()
<a name="778"/>      local c
<a name="779"/>      every c := gen_type(ClassSymbol) do
<a name="780"/>         linearize_c3(c) | return error("Couldn't linearize " || c.name || ": " || &amp;why)
<a name="781"/>      return
<a name="782"/>   end
<a name="783"/>
<a name="784"/>   private static linearize_c3(c, seen)
<a name="785"/>      local t, e, l
<a name="786"/>      if l := \c.implemented_classes then
<a name="787"/>         return l
<a name="788"/>      /seen := set()
<a name="789"/>      if member(seen, c) then
<a name="790"/>         return error("Circular inheritance: " || c.name)
<a name="791"/>      insert(seen, c)
<a name="792"/>      t := []
<a name="793"/>      every e := !c.resolved_supers do
<a name="794"/>         put(t, copy(linearize_c3(e, seen))) | fail
<a name="795"/>      delete(seen, c)
<a name="796"/>      put(t, copy(c.resolved_supers))
<a name="797"/>      l := push(merge_c3(t), c) | fail
<a name="798"/>      c.set_implemented_classes(l)
<a name="799"/>      return l
<a name="800"/>   end
<a name="801"/>
<a name="802"/>   private static in_tail(l, h)
<a name="803"/>      succeed keyof(!l, h) &gt; 1
<a name="804"/>   end
<a name="805"/>
<a name="806"/>   private static merge1_c3(l, r)
<a name="807"/>      local h, e
<a name="808"/>      every h := (!l)[1] do {
<a name="809"/>         unless in_tail(l, h) then {
<a name="810"/>            put(r, h)
<a name="811"/>            # Pop h off any of the lists
<a name="812"/>            every e := !l do {
<a name="813"/>               if e[1] === h then
<a name="814"/>                  pop(e)
<a name="815"/>            }
<a name="816"/>            return
<a name="817"/>         }
<a name="818"/>      }
<a name="819"/>      error("Inheritance hierarchy cannot be linearized")
<a name="820"/>   end
<a name="821"/>
<a name="822"/>   private static merge_c3(l)
<a name="823"/>      local r
<a name="824"/>      r := []
<a name="825"/>      while !!l do
<a name="826"/>         merge1_c3(l, r) | fail
<a name="827"/>      return r
<a name="828"/>   end
<a name="829"/>
<a name="830"/>   public set_file_mode(s)
<a name="831"/>      self.file_mode := s
<a name="832"/>      link
<a name="833"/>   end
<a name="834"/>
<a name="835"/>   public set_pp_defs(t)
<a name="836"/>      self.pp_defs := t
<a name="837"/>      link
<a name="838"/>   end
<a name="839"/>
<a name="840"/>   public override new()
<a name="841"/>      Connectable.new()
<a name="842"/>      symbol_table := table()
<a name="843"/>      scanned_files := SortTable(, Files.standard_case_cmp)
<a name="844"/>      scanned_packages := set()
<a name="845"/>      file_mode := PREFER_SRC
<a name="846"/>      pparser := Parser()
<a name="847"/>      return
<a name="848"/>   end
<a name="849"/>end
</pre></body></html>
