#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

class SelectionOwner()
   public defer get_content(target)
   public defer lost_ownership()
   public defer get_win()
   public defer get_targets()
end

class TextSelectionOwner(SelectionOwner)
   protected defer get_text()

   public get_targets()
      suspend Selection.STRING_TARGET | Selection.UTF8_STRING_TARGET
   end

   public get_content(target)
      case target of {
         Selection.STRING_TARGET: return string(text_convert(get_text(), "string"))
         Selection.UTF8_STRING_TARGET: return string(text_convert(get_text(), "ucs"))
      }
   end
end

class Selection()
   public static const
      PRIMARY,         # Selection constants
      SECONDARY,
      CLIPBOARD,
      UTF8_STRING_TARGET,
      STRING_TARGET,
      TARGETS_TARGET

   private static const owners

   private static init()
      PRIMARY := "PRIMARY"      # These 3 must correspond to X Atom names.
      SECONDARY := "SECONDARY"
      CLIPBOARD := "CLIPBOARD"
      STRING_TARGET := "STRING"
      UTF8_STRING_TARGET := "UTF8_STRING"
      TARGETS_TARGET := "TARGETS"
      owners := table()
   end

   public static own(selection, obj)
      local curr
      if curr := \owners[selection] then {
         # Check if current owner is asserting selection.
         if curr === obj then
            return

         curr.lost_ownership()
         delete(owners, selection)

         # If two different objects in the same window, no need to call
         # the graphics layer.
         if curr.get_win() === obj.get_win() then {
            owners[selection] := obj
            return
         }
      }
      obj.get_win().own_selection(selection)
      owners[selection] := obj
   end

   #
   # Return the content for the given selection.  Fails if there is no such
   # selection, or the selection's target doesn't match the requested target
   # (which defaults to string target type).
   #
   public static get_content(selection, target)
      local curr, s
      /target := STRING_TARGET
      # Shortcut if we have the selection already.
      if curr := \owners[selection] then {
         if target == TARGETS_TARGET then {
            s := TARGETS_TARGET || "\n"
            every s ||:= curr.get_targets() || "\n"
            return s
         }
         curr.get_targets() == target | fail
         return curr.get_content(target)
      }
      return (?Dispatcher.dialogs).win.get_selection_content(selection, target)
   end

   #
   # Helpful function to check if the given selection supports the given
   # target.
   #
   public static has_target(selection, target)
      local s
      get_content(selection, TARGETS_TARGET) ? {
         while s := tab(upto('\n')) do {
            if s == target then
               return s
            move(1)
         }
      }
   end

   #
   # A dialog is closing... any components inside lose ownership.
   #
   public static dispose_owners(d)
      local e
      every e := !sort(owners) do {
         if e[2].get_win() === d.get_win() then {
            e[2].lost_ownership(e[1])
            delete(owners, e[1])
         }
      }
   end

   public static get_owner(selection)
      return \owners[selection]
   end

   public static clear(win, selection)
      local c
      if (c := \owners[selection]) & (c.get_win() === win) then {
         c.lost_ownership()
         delete(owners, selection)
      }
   end
end
