<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>imagecache.icn</title></head><body><pre>
<a name="1"/>package gui
<a name="2"/>
<a name="3"/>import 
<a name="4"/>   graphics, 
<a name="5"/>   util,
<a name="6"/>   cairo,
<a name="7"/>   io,
<a name="8"/>   lang,
<a name="9"/>   ipl.imagedetect
<a name="10"/>
<a name="11"/>$if _PNG
<a name="12"/>$load CLOCK "images/gui.CLOCK_24.png"
<a name="13"/>$load CLOSE "images/gui.CLOSE_24.png"
<a name="14"/>$load FONT "images/gui.FONT_24.png"
<a name="15"/>$load FILESIZE "images/gui.FILESIZE_24.png"
<a name="16"/>$load CIRCULATE "images/gui.CIRCULATE_12.png"
<a name="17"/>$load FILE "images/gui.FILE_16.png"
<a name="18"/>$load OPEN_FOLDER "images/gui.OPEN_FOLDER_16.png"
<a name="19"/>$load CLOSED_FOLDER "images/gui.CLOSED_FOLDER_16.png"
<a name="20"/>$load FAVOURITES "images/gui.FAVOURITES_24.png"
<a name="21"/>$load UP "images/gui.UP_24.png"
<a name="22"/>$load PREV "images/gui.PREV_24.png"
<a name="23"/>$load NEXT "images/gui.NEXT_24.png"
<a name="24"/>$load REFRESH "images/gui.REFRESH_24.png"
<a name="25"/>$else
<a name="26"/>$load CLOCK "images/gui.CLOCK_24.gif"
<a name="27"/>$load CLOSE "images/gui.CLOSE_24.gif"
<a name="28"/>$load FONT "images/gui.FONT_24.gif"
<a name="29"/>$load FILESIZE "images/gui.FILESIZE_24.gif"
<a name="30"/>$load CIRCULATE "images/gui.CIRCULATE_12.gif"
<a name="31"/>$load FILE "images/gui.FILE_16.gif"
<a name="32"/>$load OPEN_FOLDER "images/gui.OPEN_FOLDER_16.gif"
<a name="33"/>$load CLOSED_FOLDER "images/gui.CLOSED_FOLDER_16.gif"
<a name="34"/>$load FAVOURITES "images/gui.FAVOURITES_24.gif"
<a name="35"/>$load UP "images/gui.UP_24.gif"
<a name="36"/>$load PREV "images/gui.PREV_24.gif"
<a name="37"/>$load NEXT "images/gui.NEXT_24.gif"
<a name="38"/>$load REFRESH "images/gui.REFRESH_24.gif"
<a name="39"/>$endif
<a name="40"/>$load HOME "images/gui.HOME_24.gif"
<a name="41"/>$load NEW_FOLDER "images/gui.NEW_FOLDER_24.gif"
<a name="42"/>$load HIDDENFILE "images/gui.HIDDENFILE_24.gif"
<a name="43"/>$load CONFIGURE "images/gui.CONFIGURE_24.gif"
<a name="44"/>$load WINDOW_CLOSE "images/gui.WINDOW_CLOSE_16.gif"
<a name="45"/>$load WINDOW_ICONIFY "images/gui.WINDOW_ICONIFY_16.gif"
<a name="46"/>
<a name="47"/>$load CLOCK_SVG "images/gui.CLOCK_SVG.svgz"
<a name="48"/>$load FILESIZE_SVG "images/gui.FILESIZE_SVG.svgz"
<a name="49"/>$load FONT_SVG "images/gui.FONT_SVG.svgz"
<a name="50"/>$load REFRESH_SVG "images/gui.REFRESH.svgz"
<a name="51"/>$load UP_SVG "images/gui.UP.svgz"
<a name="52"/>$load PREV_SVG "images/gui.PREV.svgz"
<a name="53"/>$load NEXT_SVG "images/gui.NEXT.svgz"
<a name="54"/>
<a name="55"/>final abstract class ImageCache()
<a name="56"/>   public static 
<a name="57"/>      imap,
<a name="58"/>      names
<a name="59"/>
<a name="60"/>   private static init()
<a name="61"/>      local i, j
<a name="62"/>      names := table()
<a name="63"/>      imap := table()
<a name="64"/>      name_image("gui.HOME_24", HOME)
<a name="65"/>      name_image("gui.PREV_24", PREV)
<a name="66"/>      name_image("gui.NEXT_24", NEXT)
<a name="67"/>      name_image("gui.CLOSE_24", CLOSE)
<a name="68"/>      name_image("gui.NEW_FOLDER_24", NEW_FOLDER)
<a name="69"/>      name_image("gui.REFRESH_24", REFRESH)
<a name="70"/>      name_image("gui.UP_24", UP)
<a name="71"/>      name_image("gui.CLOCK_24", CLOCK)
<a name="72"/>      name_image("gui.FONT_24",FONT)
<a name="73"/>      name_image("gui.FILESIZE_24", FILESIZE)
<a name="74"/>      name_image("gui.HIDDENFILE_24", HIDDENFILE)
<a name="75"/>      name_image("gui.FAVOURITES_24", FAVOURITES)
<a name="76"/>      name_image("gui.CONFIGURE_24", CONFIGURE)
<a name="77"/>      name_image("gui.CLOSED_FOLDER_16", CLOSED_FOLDER)
<a name="78"/>      name_image("gui.OPEN_FOLDER_16", OPEN_FOLDER)
<a name="79"/>      name_image("gui.FILE_16", FILE)
<a name="80"/>      name_image("gui.WINDOW_CLOSE_16", WINDOW_CLOSE)
<a name="81"/>      name_image("gui.WINDOW_ICONIFY_16", WINDOW_ICONIFY)
<a name="82"/>      name_image("gui.CIRCULATE_12", CIRCULATE)
<a name="83"/>
<a name="84"/>      name_image("gui.CLOCK_SVG", CLOCK_SVG)
<a name="85"/>      name_image("gui.FILESIZE_SVG", FILESIZE_SVG)
<a name="86"/>      name_image("gui.FONT_SVG", FONT_SVG)
<a name="87"/>      name_image("gui.REFRESH_SVG", REFRESH_SVG)
<a name="88"/>      name_image("gui.UP_SVG", UP_SVG)
<a name="89"/>      name_image("gui.NEXT_SVG", NEXT_SVG)
<a name="90"/>      name_image("gui.PREV_SVG", PREV_SVG)
<a name="91"/>
<a name="92"/>      i := scale_odd(13)
<a name="93"/>      j := scale(2)
<a name="94"/>      name_image("gui.BOX_UP", mk_box_up(i, j))
<a name="95"/>      name_image("gui.BOX_DOWN",  mk_box_down(i, j))
<a name="96"/>      name_image("gui.DIAMOND_UP", mk_diamond_up(i, j))
<a name="97"/>      name_image("gui.DIAMOND_DOWN",  mk_diamond_down(i, j))
<a name="98"/>
<a name="99"/>      i := scale_odd(11)
<a name="100"/>      name_image("gui.ARROW_UP", mk_arrow_up(i))
<a name="101"/>      name_image("gui.ARROW_DOWN", mk_arrow_down(i))
<a name="102"/>
<a name="103"/>      i := scale_odd(9)
<a name="104"/>      name_image("gui.ARROW_LEFT", mk_arrow_left(i))
<a name="105"/>      name_image("gui.ARROW_RIGHT", mk_arrow_right(i))
<a name="106"/>
<a name="107"/>      i := scale_odd(7)
<a name="108"/>      name_image("gui.TINY_ARROW_UP", mk_arrow_up(i))
<a name="109"/>      name_image("gui.TINY_ARROW_DOWN", mk_arrow_down(i))
<a name="110"/>
<a name="111"/>      j := scale(1)
<a name="112"/>      i := (if j % 2 = 0 then scale_even else scale_odd)(9)
<a name="113"/>      name_image("gui.PLUS", mk_handle(i, j))
<a name="114"/>      name_image("gui.MINUS", mk_handle(i, j, &amp;yes))
<a name="115"/>
<a name="116"/>      i := scale_odd(5)
<a name="117"/>      j := scale(6)
<a name="118"/>      name_image("gui.VERT_GRID", mk_v_grid(i, j))
<a name="119"/>      name_image("gui.HORIZ_GRID", mk_h_grid(i, j))
<a name="120"/>   end
<a name="121"/>
<a name="122"/>   #
<a name="123"/>   # Associate image data (eg gif file data), with a name.  The data
<a name="124"/>   # must be either a string, or a `Pixels` instance.  In the latter
<a name="125"/>   # case, the instance must never be closed.
<a name="126"/>   #
<a name="127"/>   # The name can then be passed to `get` or `load` to retrieve a
<a name="128"/>   # window with the corresponding image.  It is a runtime error if
<a name="129"/>   # the key already exists in the table.
<a name="130"/>   #
<a name="131"/>   public static name_image(name, data)
<a name="132"/>      name := need_string(name)
<a name="133"/>      if member(names, name) then
<a name="134"/>         runerr("ImageCache duplicate name key", name)
<a name="135"/>      is(data, Pixels) | (data := need_string(data))
<a name="136"/>      insert(names, name, data)
<a name="137"/>      link
<a name="138"/>   end
<a name="139"/>
<a name="140"/>   #
<a name="141"/>   # Given an existing key, add an entry to the name-data table with
<a name="142"/>   # `new_key`, pointing to the same data.  Fails if `key` is not an
<a name="143"/>   # existing key into the data table.
<a name="144"/>   #
<a name="145"/>   public static copy_name(new_key, key)
<a name="146"/>      return name_image(new_key, get_named_image(key))
<a name="147"/>   end
<a name="148"/>
<a name="149"/>   #
<a name="150"/>   # Return the data previously set with `name_image`.  Fails if the
<a name="151"/>   # name is unknown.
<a name="152"/>   #
<a name="153"/>   public static get_named_image(name)
<a name="154"/>      return member(names, need_string(name))
<a name="155"/>   end
<a name="156"/>
<a name="157"/>   #
<a name="158"/>   # Place an entry into the window cache with the given key.  The
<a name="159"/>   # window should not be subsequently closed.  It is a runtime error
<a name="160"/>   # if the key already exists in the table.
<a name="161"/>   #
<a name="162"/>   public static cache_window(key, win)
<a name="163"/>      key := need_string(key)
<a name="164"/>      if member(imap, key) then
<a name="165"/>         runerr("ImageCache duplicate image key", key)
<a name="166"/>      insert(imap, key, need_Window(win))
<a name="167"/>      link
<a name="168"/>   end
<a name="169"/>
<a name="170"/>   #
<a name="171"/>   # Given an existing key, add an entry to the window cache with
<a name="172"/>   # `new_key`, pointing to the same window.  Fails if `key` is not an
<a name="173"/>   # existing key into the image table.
<a name="174"/>   #
<a name="175"/>   public static copy_key(new_key, key)
<a name="176"/>      return cache_window(new_key, get_cached_window(key))
<a name="177"/>   end
<a name="178"/>
<a name="179"/>   #
<a name="180"/>   # Return an entry in the window cache, or fail if the key is not
<a name="181"/>   # present.
<a name="182"/>   #
<a name="183"/>   public static get_cached_window(key)
<a name="184"/>      return member(imap, need_string(key))
<a name="185"/>   end
<a name="186"/>
<a name="187"/>   #
<a name="188"/>   # Load an image, using the cache if possible.  The parameter `s`
<a name="189"/>   # should be either a file name, or the name of an image set by
<a name="190"/>   # `name_image()`.  On a successful load, the image is stored in the
<a name="191"/>   # cache for future use, and thus should not be closed after use.
<a name="192"/>   #
<a name="193"/>   # In this and subsequent methods, `win` is a `Window`.  This
<a name="194"/>   # parameter is only required if the image data in question is an
<a name="195"/>   # image string.  The window is then used to provide the foreground
<a name="196"/>   # and background palette colours.
<a name="197"/>   #
<a name="198"/>   public static get(s, win)
<a name="199"/>      return member(imap, get_key(s, win))
<a name="200"/>   end
<a name="201"/>
<a name="202"/>   #
<a name="203"/>   # This is the same as `get`, but returns the key into the cached
<a name="204"/>   # window map, rather than the window.  If it succeeds, then the
<a name="205"/>   # returned key will be in the map, and the window can be retrieved
<a name="206"/>   # by `get_cached_window`.
<a name="207"/>   #
<a name="208"/>   public static get_key(s, win)
<a name="209"/>      local w, key, p, fl
<a name="210"/>      key := s := need_string(s)
<a name="211"/>      if s := member(names, key) then
<a name="212"/>         fl := &amp;yes
<a name="213"/>      if is_image_string(s) then {
<a name="214"/>         need_Window(win)
<a name="215"/>         key ||:= "#With colour "|| Window.color_value(win.get_fg()) || "/" || Window.color_value(win.get_bg())
<a name="216"/>         if member(imap, key) then
<a name="217"/>            return key
<a name="218"/>         \fl | return error("Invalid key for ImageCache")
<a name="219"/>         w := use {
<a name="220"/>            p := image_string_to_pixels(s, win),
<a name="221"/>            open_image(p)
<a name="222"/>         } | fail
<a name="223"/>      } else {
<a name="224"/>         if member(imap, key) then
<a name="225"/>            return key
<a name="226"/>         \fl | Files.access(key) | return error("Invalid key for ImageCache")
<a name="227"/>         w := open_image(s) | fail
<a name="228"/>      }
<a name="229"/>      insert(imap, key, w)
<a name="230"/>      return key
<a name="231"/>   end
<a name="232"/>
<a name="233"/>   #
<a name="234"/>   # Load an image without using the cache.  The parameter `s` should
<a name="235"/>   # be either a file name, or the name of an image set by
<a name="236"/>   # `name_image()`.  It may also be raw image data (unlike `get`).
<a name="237"/>   # The returned image should be closed after use.
<a name="238"/>   #
<a name="239"/>   public static load(s, win)
<a name="240"/>      local p
<a name="241"/>      return use {
<a name="242"/>         p := load_pixels(s, win),
<a name="243"/>         open_image(p)
<a name="244"/>      }
<a name="245"/>   end
<a name="246"/>
<a name="247"/>   #
<a name="248"/>   # This is like `load`, but a `Pixels` is returned instead of a
<a name="249"/>   # `Window`.
<a name="250"/>   #
<a name="251"/>   public static load_pixels(s, win)
<a name="252"/>      s := need_string(s)
<a name="253"/>      s := member(names, s)
<a name="254"/>      return if is(s, Pixels) then
<a name="255"/>         s.shared_copy()
<a name="256"/>      else if is_image_string(s) then
<a name="257"/>         image_string_to_pixels(s, win)
<a name="258"/>      else
<a name="259"/>         Pixels(s)
<a name="260"/>   end
<a name="261"/>
<a name="262"/>   #
<a name="263"/>   # Convenient method to combine `copy_key` and `get_key_with_resize`
<a name="264"/>   #
<a name="265"/>   public static copy_key_with_resize(new_key, s, width, height, win)
<a name="266"/>      return copy_key(new_key, get_key_with_resize(s, width, height, win))
<a name="267"/>   end
<a name="268"/>
<a name="269"/>   #
<a name="270"/>   # This is like `get`, but the resulting cached window will be of
<a name="271"/>   # the given dimensions.
<a name="272"/>   #
<a name="273"/>   public static get_with_resize(s, width, height, win)
<a name="274"/>      return member(imap, get_key_with_resize(s, width, height, win))
<a name="275"/>   end
<a name="276"/>
<a name="277"/>   #
<a name="278"/>   # Like `get_with_resize`, but returns the key rather than the
<a name="279"/>   # window.
<a name="280"/>   #
<a name="281"/>   public static get_key_with_resize(s, width, height, win)
<a name="282"/>      local w, key, key1, s1, p, fl
<a name="283"/>      key := s := need_string(s)
<a name="284"/>      width := need_integer(width, 1)
<a name="285"/>      height := need_integer(height, 1)
<a name="286"/>      s1 := s
<a name="287"/>      if s1 := member(names, key) then
<a name="288"/>         fl := &amp;yes
<a name="289"/>      if is_image_string(s1) then {
<a name="290"/>         need_Window(win)
<a name="291"/>         \fl | return error("Invalid key for ImageCache")
<a name="292"/>         key ||:= "#With colour "|| Window.color_value(win.get_fg()) || "/" || Window.color_value(win.get_bg())
<a name="293"/>      } else {
<a name="294"/>         \fl | Files.access(key) | return error("Invalid key for ImageCache")
<a name="295"/>      }
<a name="296"/>
<a name="297"/>      if w := member(imap, key) &amp;
<a name="298"/>         w.get_width() = width &amp; w.get_height() = height
<a name="299"/>      then
<a name="300"/>         return key
<a name="301"/>
<a name="302"/>      key1 := key
<a name="303"/>      key ||:= "#Resized to " || width || "x" || height
<a name="304"/>      if member(imap, key) then
<a name="305"/>         return key
<a name="306"/>      use {
<a name="307"/>         p := load_pixels(s, win),
<a name="308"/>         {
<a name="309"/>            if p.get_width() = width &amp; p.get_height() = height then
<a name="310"/>               key := key1
<a name="311"/>            w := zoom_pix(p, width, height)
<a name="312"/>         }
<a name="313"/>      } | fail
<a name="314"/>
<a name="315"/>      insert(imap, key, w)
<a name="316"/>      return key
<a name="317"/>   end
<a name="318"/>
<a name="319"/>   #
<a name="320"/>   # This function takes an SVG filename, or key to named SVG data set
<a name="321"/>   # by `name_image()` (ie, an xml document), `s`, scales the SVG to
<a name="322"/>   # the given size, and returns a cached window.
<a name="323"/>   #
<a name="324"/>   public static get_scaled_svg(s, width, height)
<a name="325"/>      return member(imap, get_scaled_svg_key(s, width, height))
<a name="326"/>   end
<a name="327"/>
<a name="328"/>   #
<a name="329"/>   # Like `get_scaled_svg`, but returns the key rather than the window.
<a name="330"/>   #
<a name="331"/>   public static get_scaled_svg_key(s, width, height)
<a name="332"/>      local w, key, cc, svg
<a name="333"/>      s := need_string(s)
<a name="334"/>      width := need_integer(width, 1)
<a name="335"/>      height := need_integer(height, 1)
<a name="336"/>      key := s || "#Scaled to " || width || "x" || height
<a name="337"/>      if member(imap, key) then
<a name="338"/>         return key
<a name="339"/>      (s := member(names, s)) | Files.access(s) | return error("Invalid key for ImageCache")
<a name="340"/>      use {
<a name="341"/>         svg := SVG(s),
<a name="342"/>         {
<a name="343"/>            w := new_win()
<a name="344"/>            w.set_size(width, height).
<a name="345"/>              set_bg("transparent").
<a name="346"/>              erase_area()
<a name="347"/>            use {
<a name="348"/>               cc := Context(w).
<a name="349"/>                  scale(real(width) / svg.get_width(), real(height) / svg.get_height()),
<a name="350"/>               svg.render(cc)
<a name="351"/>            }
<a name="352"/>            insert(imap, key, w)
<a name="353"/>         }
<a name="354"/>      } | fail
<a name="355"/>      return key
<a name="356"/>   end
<a name="357"/>
<a name="358"/>   #
<a name="359"/>   # A convenient function to try to get a scaled SVG from the given
<a name="360"/>   # data `s`, but if SVG capability is not available then to use the
<a name="361"/>   # alternative conventional image `alt_s`, resized in either case to
<a name="362"/>   # the given dimensions.
<a name="363"/>   #
<a name="364"/>   public static get_scaled_svg_key_alt(s, alt_s, width, height)
<a name="365"/>      return if \Context.LOADED then 
<a name="366"/>         get_scaled_svg_key(s, width, height) 
<a name="367"/>      else 
<a name="368"/>         get_key_with_resize(alt_s, width, height)
<a name="369"/>   end
<a name="370"/>
<a name="371"/>   #
<a name="372"/>   # Useful debug function to print the contents of the cache.
<a name="373"/>   #
<a name="374"/>   public static show()
<a name="375"/>      local k, v, i
<a name="376"/>      write("Cache name table\n----------------")
<a name="377"/>      every k := key(names) do {
<a name="378"/>         v := names[k]
<a name="379"/>         if is(v, Pixels) then
<a name="380"/>            write("\t", k, " -&gt; ", to_string(v))
<a name="381"/>         else {
<a name="382"/>            writes("\t", k, " -&gt; ", *v, " bytes ")
<a name="383"/>            if i := ImageStringInfo(v) then
<a name="384"/>               write("image string ", i.width, "x", i.height)
<a name="385"/>            else if i := detect(v) then
<a name="386"/>               write(i.format, " ", i.width, "x", i.height)
<a name="387"/>            else
<a name="388"/>               write("data")
<a name="389"/>         }
<a name="390"/>      }
<a name="391"/>      write("\nCache image table\n-----------------")
<a name="392"/>      every k := key(imap) do {
<a name="393"/>         v := imap[k]
<a name="394"/>         write("\t", k, " -&gt; ", to_string(v))
<a name="395"/>      }
<a name="396"/>   end
<a name="397"/>end
</pre></body></html>
