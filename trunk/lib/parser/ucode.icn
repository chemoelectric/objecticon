package parser

import
   util(error),
   lang(OpCode)

class UFile()
   private readable
      pack,
      declend_offset,
      trace,
      strinv,
      version

   private const
      imports,
      invocables,
      symbols, 
      links

   package set_package(pack)
      self.pack := pack
   end

   package add_link(s)
      put(links, s)
   end

   public get_links()
      suspend .!links
   end

   package add_symbol(obj)
      put(symbols, obj)
   end

   public get_symbols()
      suspend .!symbols
   end

   package add_import(i)
      put(imports, i)
   end

   public get_imports()
      suspend .!imports
   end

   package add_invocable(s)
      put(invocables, s)
   end

   public get_invocables()
      suspend .!invocables
   end

   package set_declend_offset(p)
      self.declend_offset := p
   end

   package set_trace(t)
      self.trace := t
   end

   package set_strinv(v)
      self.strinv := v
   end

   package set_version(s)
      self.version := s
   end

   package new()
      self.symbols := []
      self.invocables := []
      self.imports := []
      self.links := []
      return
   end
end

class UObject()
   public const
      name,
      file,
      line

   package new(name, file, line)
      self.name := name
      self.file := file
      self.line := line
      return
   end
end

class UClass(UObject)
   public const
      supers,
      fields,
      flags

   package add_field(o)
      put(fields, o)
   end

   public get_fields()
      suspend .!fields
   end

   package add_super(s)
      put(supers, s)
   end

   public get_supers()
      suspend .!supers
   end

   package new(name, file, line, flags)
      cast(self,UObject).new(name, file, line)
      self.flags := flags
      self.supers := []
      self.fields := []
      return
   end
end

class UVariable(UObject)
   public const
      flags

   package new(name, file, line, flags)
      cast(self,UObject).new(name, file, line)
      self.flags := flags
      return
   end
end

class ULocal()
   public static const
      # variable declared local dynamic 
      F_Dynamic,
      # variable declared local static 
      F_Static,
      # variable is a formal parameter 
      F_Argument

   public const
      flags,
      id

   private static init()
      F_Dynamic := 8r020
      F_Static := 8r040
      F_Argument := 8r01000
   end

   package new(id, flags)
      self.id := id
      self.flags := flags
      return
   end
end

class UConst()
   public const
      flags,
      val

   public static const
      # literal is an integer 
      F_IntLit,
      # literal is a real 
      F_RealLit,
      # literal is a string 
      F_StrLit,
      # literal is a cset 
      F_CsetLit,
      # literal is a ucs 
      F_UcsLit,
      # literal is a large int
      F_LrgintLit

   private static init()
      F_IntLit := 8r02000
      F_RealLit := 8r04000
      F_StrLit := 8r010000
      F_CsetLit := 8r020000
      F_UcsLit := 8r040000
      F_LrgintLit := 8r0100000
   end

   package new(val, flags)
      self.val := val
      self.flags := flags
      return
   end
end

class UFunction()
   private readable
      nargs,
      locals,
      consts

   package set_nargs(n)
      self.nargs := n
   end

   package add_local(l)
      put(locals, l)
   end

   public get_locals()
      suspend .!locals
   end

   package add_const(l)
      put(consts, l)
   end

   public get_consts()
      suspend .!consts
   end

   package new()
      self.locals := []
      self.consts := []
      return
   end
end

class UMethod(UObject, UFunction)
   public const
      flags

   package new(name, file, line, flags)
      cast(self,UObject).new(name, file, line)
      cast(self,UFunction).new()
      self.flags := flags
      return
   end
end

class UProcedure(UObject, UFunction)
   package new(name, file, line)
      cast(self,UObject).new(name, file, line)
      cast(self,UFunction).new()
      return
   end
end

class URecord(UObject)
   private
      fields

   public get_fields()
      suspend .!fields
   end

   package add_field(s)
      put(fields, s)
   end

   package new(name, file, line)
      cast(self,UObject).new(name, file, line)
      self.fields := []
      return
   end
end

class UGlobal(UObject)
end

class UReader()
   public scan_decls()
      local uf, file, line, uop, s, n, curr_import, curr_class, 
         curr_record, curr_func
      uf := UFile()
      uop := uin_expectop() | fail
      uop == OpCode.Version | return error("Missing version identification")
      s := uin_str() | fail
      uf.set_version(s)
      repeat {
         uop := uin_expectop() | fail
         case uop of {
            OpCode.Filen:
               file := uin_str() | fail

            OpCode.Line:
               line := uin_16() | fail

            OpCode.Declend: {
               uf.set_declend_offset(&pos)
               break
            }

            OpCode.Package: {
               s := uin_str() | fail
               uf.set_package(s)
            }

            OpCode.Import: {
               s := uin_str() | fail
               n := uin_16() | fail
               curr_import := if n = 0 then ImportDec(s) else ImportDec(s, 1)
               uf.add_import(curr_import)
            }

            OpCode.Importsym: {
               s := uin_str() | fail
               curr_import.add(s)
            }

            OpCode.Class: {
               n := uin_32() | fail
               s := uin_str() | fail
               curr_class := UClass(s, file, line, n)
               uf.add_symbol(curr_class)
            }

            OpCode.Super: {
               s := uin_str() | fail
               curr_class.add_super(s)
            }

            OpCode.Classfield: {
               n := uin_32() | fail
               s := uin_str() | fail
               if iand(n, lang.Class.M_Method) ~= 0 then {
                  curr_func := UMethod(s, file, line, n)
                  curr_class.add_field(curr_func)
               } else
                  curr_class.add_field(UVariable(s, file, line, n))
            }

             OpCode.Nargs: {
                n := uin_16() | fail
                curr_func.set_nargs(n)
             }

             OpCode.Recordfield: {
                s := uin_str() | fail
                curr_record.add_field(s)
             }

             OpCode.Record: {
                s := uin_str() | fail
                curr_record := URecord(s, file, line)
                uf.add_symbol(curr_record)
             }

             OpCode.Trace: {
                uf.set_trace(-1)
             }

             OpCode.Procdecl: {
                s := uin_str() | fail
                curr_func := UProcedure(s, file, line)
                uf.add_symbol(curr_func)
             }

             OpCode.Local: {
                n := uin_32() | fail
                s := uin_str() | fail
                curr_func.add_local(ULocal(s, n))
             }

             OpCode.Con: {
                n := uin_32() | fail
                s := uin_bin() | fail
                curr_func.add_const(UConst(s, n))
             }

             OpCode.Global: {
                s := uin_str() | fail
                uf.add_symbol(UGlobal(s, file, line))
             }

             OpCode.Invocable: {
                s := uin_str() | fail
                if s == "0" then
                   uf.set_strinv(1)
                else
                   uf.add_invocable(s)
             }

             OpCode.Link: {
                s := uin_str() | fail
                uf.add_link(s)
             }
            
            default:
               return error("ill-formed ufile")
         }
      }

      return uf
   end

   private uin_expectop()
      return uin_op() | error("Unexpected EOF")
   end

   private uin_op()
      return ord(move(1))
   end

   private uin_str()
      local s
      s := tab(upto('\0')) | error("Unexpected EOF")
      move(1)
      return s
   end

   private uin_16()
      local s, i
      s := move(2) | return error("Unexpected EOF")
      i := raw_convert(s)
      if i > 16r7fff then
         i -:= 16r10000
      return i
   end

   private uin_32()
      local s, i
      s := move(4) | return error("Unexpected EOF")
      i := raw_convert(s)
      if i > 16r7fffffff then
         i -:= 16r100000000
      return i
   end

   private uin_bin()
      local s, i
      s := move(2) | return error("Unexpected EOF")
      i := raw_convert(s)
      return move(i)
   end

   private static defer raw_convert(s)
end
