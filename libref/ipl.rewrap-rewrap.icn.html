<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>rewrap.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     rewrap.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures for advanced line rewrap
<a name="6"/>#
<a name="7"/>#	Author:   Richard L. Goerwitz
<a name="8"/>#
<a name="9"/>#	Date:	  March 3, 1996
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#	Version:  1.4
<a name="18"/>#
<a name="19"/>############################################################################
<a name="20"/>#
<a name="21"/>#  The procedure rewrap(s,i), included in this file, reformats text
<a name="22"/>#  fed to it into strings &lt; i in length.  Rewrap utilizes a static
<a name="23"/>#  buffer, so it can be called repeatedly with different s arguments,
<a name="24"/>#  and still produce homogenous output.  This buffer is flushed by
<a name="25"/>#  calling rewrap with a null first argument.  The default for
<a name="26"/>#  argument 2 (i) is 70.
<a name="27"/>#
<a name="28"/>############################################################################
<a name="29"/>#
<a name="30"/>#  Here's a simple example of how rewrap could be used.  The following
<a name="31"/>#  program reads the standard input, producing fully rewrapped output.
<a name="32"/>#
<a name="33"/>#  procedure main()
<a name="34"/>#      every write(rewrap())
<a name="35"/>#      write(rewrap())
<a name="36"/>#  end
<a name="37"/>#
<a name="38"/>#  Naturally, in practice you would want to do things like check for in-
<a name="39"/>#  dentation or blank lines in order to wrap only on a paragraph-by para-
<a name="40"/>#  graph basis, as in
<a name="41"/>#
<a name="42"/>#  procedure main()
<a name="43"/>#      while line := read() do {
<a name="44"/>#          if line == "" then {
<a name="45"/>#              write("" ~== rewrap())
<a name="46"/>#              write(line)
<a name="47"/>#          } else {
<a name="48"/>#              if match("\t", line) then {
<a name="49"/>#                  write(rewrap())
<a name="50"/>#                  write(rewrap(line))
<a name="51"/>#              } else {
<a name="52"/>#                  write(rewrap(line))
<a name="53"/>#              }
<a name="54"/>#          }
<a name="55"/>#      }
<a name="56"/>#  end
<a name="57"/>#
<a name="58"/>#  Fill-prefixes can be implemented simply by prepending them to the
<a name="59"/>#  output of rewrap:
<a name="60"/>#
<a name="61"/>#      i := 70; fill_prefix := " &gt; "
<a name="62"/>#      while line := read(input_file) do {
<a name="63"/>#          line ?:= (f_bit := tab(many('&gt; ')) | "", tab(0))
<a name="64"/>#          write(fill_prefix || f_bit || rewrap(line, i - *fill_prefix))
<a name="65"/>#          etc.
<a name="66"/>#
<a name="67"/>#  Obviously, these examples are fairly simplistic.  Putting them to
<a name="68"/>#  actual use would certainly require a few environment-specific
<a name="69"/>#  modifications and/or extensions.  Still, I hope they offer some
<a name="70"/>#  indication of the kinds of applications rewrap might be used in.
<a name="71"/># 
<a name="72"/>#  Note:  If you want leading and trailing tabs removed, map them to
<a name="73"/>#  spaces first.  Rewrap only fools with spaces, leaving tabs intact.
<a name="74"/>#  This can be changed easily enough, by running its input through the
<a name="75"/>#  Icon detab() function.
<a name="76"/>#
<a name="77"/>############################################################################
<a name="78"/>#
<a name="79"/>#  See also:  wrap.icn
<a name="80"/>#
<a name="81"/>############################################################################
<a name="82"/>
<a name="83"/>
<a name="84"/>package ipl.rewrap
<a name="85"/>
<a name="86"/>procedure rewrap(s,i)
<a name="87"/>
<a name="88"/>    local extra_bit, line
<a name="89"/>    static old_line
<a name="90"/>    initial old_line := ""
<a name="91"/>
<a name="92"/>    # Default column to wrap on is 70.
<a name="93"/>    /i := 70
<a name="94"/>    # Flush buffer on null first argument.
<a name="95"/>    if /s then {
<a name="96"/>	extra_bit := old_line
<a name="97"/>	old_line := ""
<a name="98"/>	return "" ~== extra_bit
<a name="99"/>    }
<a name="100"/>
<a name="101"/>    # Prepend to s anything that is in the buffer (leftovers from the last s).
<a name="102"/>    s ?:= { tab(many(' ')); old_line || trim(tab(0)) }
<a name="103"/>
<a name="104"/>    # If the line isn't long enough, just add everything to old_line.
<a name="105"/>    if *s &lt; i then old_line := s || " " &amp; fail
<a name="106"/>
<a name="107"/>    s ? {
<a name="108"/>
<a name="109"/>	# While it is possible to find places to break s, do so.
<a name="110"/>	while any(' \-',line := EndToFront(i),-1) do {
<a name="111"/>	    # Clean up and suspend the last piece of s tabbed over.
<a name="112"/>	    line ?:= (tab(many(' ')), trim(tab(0)))
<a name="113"/>            if *&amp;subject - &amp;pos + *line &gt; i
<a name="114"/>	    then suspend line
<a name="115"/>	    else {
<a name="116"/>		old_line := ""
<a name="117"/>		return line || tab(0)
<a name="118"/>	    }
<a name="119"/>	}
<a name="120"/>
<a name="121"/>	# Keep the extra section of s in a buffer.
<a name="122"/>	old_line := tab(0)
<a name="123"/>
<a name="124"/>	# If the reason the remaining section of s was unrewrapable was
<a name="125"/>	# that it was too long, and couldn't be broken up, then just return
<a name="126"/>	# the thing as-is.
<a name="127"/>	if *old_line &gt; i then {
<a name="128"/>	    old_line ? {
<a name="129"/>		if extra_bit := tab(upto(' \-')+1) || (tab(many(' ')) | "")
<a name="130"/>		then old_line := tab(0)
<a name="131"/>		else extra_bit := old_line &amp; old_line := ""
<a name="132"/>		return trim(extra_bit)
<a name="133"/>	    }
<a name="134"/>	}
<a name="135"/>	# Otherwise, clean up the buffer for prepending to the next s.
<a name="136"/>	else {
<a name="137"/>	    # If old_line is blank, then don't mess with it.  Otherwise,
<a name="138"/>	    # add whatever is needed in order to link it with the next s.
<a name="139"/>	    if old_line ~== "" then {
<a name="140"/>		# If old_line ends in a dash, then there's no need to add a
<a name="141"/>		# space to it.
<a name="142"/>		if old_line[-1] ~== "-"
<a name="143"/>		then old_line ||:= " "
<a name="144"/>	    }
<a name="145"/>	}
<a name="146"/>    }
<a name="147"/>    
<a name="148"/>end
<a name="149"/>
<a name="150"/>
<a name="151"/>
<a name="152"/>procedure EndToFront(i)
<a name="153"/>    # Goes with rewrap(s,i)
<a name="154"/>    *&amp;subject+1 - &amp;pos &gt;= i | fail
<a name="155"/>    suspend &amp;subject[.&amp;pos:&amp;pos &lt;- &amp;pos+i to &amp;pos by -1]
<a name="156"/>end
</pre></body></html>
