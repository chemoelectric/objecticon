<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>tablecolumn.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: tablecolumn.icn 8347 2020-07-04 15:55:58Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package gui
<a name="10"/>
<a name="11"/>import util, ipl.pdco
<a name="12"/>
<a name="13"/>#
<a name="14"/># This class provides one column within a `Table`, which
<a name="15"/># displays a table of data.  A column has a label with a
<a name="16"/># button which produces an event when clicked.  The column may
<a name="17"/># be expanded or contracted by dragging the right edge of the
<a name="18"/># button.
<a name="19"/>#
<a name="20"/># The label is set by calling the `set_label(x)` method of the
<a name="21"/># parent class, `TextButton`.
<a name="22"/># 
<a name="23"/>abstract class BaseTableColumn(TextButton)
<a name="24"/>   public 
<a name="25"/>      column_width,  
<a name="26"/>      drag_offset,
<a name="27"/>      tx,
<a name="28"/>      tw,
<a name="29"/>      is_resizing
<a name="30"/>
<a name="31"/>   public static const
<a name="32"/>      CHANGE_SIZE_BORDER, MIN_COLUMN_WIDTH
<a name="33"/>
<a name="34"/>   private static init()
<a name="35"/>      CHANGE_SIZE_BORDER := env_scale("OI_TABLECOLUMN_CHANGE_SIZE_BORDER") | scale(4)
<a name="36"/>      MIN_COLUMN_WIDTH := env_scale("OI_TABLECOLUMN_MIN_COLUMN_WIDTH") | scale(20)
<a name="37"/>   end
<a name="38"/>
<a name="39"/>   public in_resize_region(e)
<a name="40"/>      return in_region(e) &amp;
<a name="41"/>         (self.x + self.w - CHANGE_SIZE_BORDER &lt;= e.x &lt; self.x + self.w)
<a name="42"/>   end
<a name="43"/>
<a name="44"/>   public override handle_lpress(e)
<a name="45"/>      if in_resize_region(e) then {
<a name="46"/>         self.is_resizing := &amp;yes
<a name="47"/>         self.parent.parent.no_more_sizing := &amp;yes
<a name="48"/>         self.drag_offset := e.x - (self.x + self.w)
<a name="49"/>      } else
<a name="50"/>         TextButton.handle_lpress(e)
<a name="51"/>   end
<a name="52"/>
<a name="53"/>   public override handle_ldrag(e)
<a name="54"/>      if \self.is_resizing then {
<a name="55"/>         self.w_spec := e.x - self.x - drag_offset
<a name="56"/>         self.w_spec &lt;:= MIN_COLUMN_WIDTH
<a name="57"/>         get_table_content().invalidate_subject_width()
<a name="58"/>         get_table_content().set_internal_fields()
<a name="59"/>         self.parent.layout()
<a name="60"/>         self.parent.parent.invalidate()
<a name="61"/>      } else
<a name="62"/>         TextButton.handle_ldrag(e)
<a name="63"/>   end
<a name="64"/>
<a name="65"/>   public override handle_lrelease(e)
<a name="66"/>      if \self.is_resizing then {
<a name="67"/>         self.is_resizing := &amp;no
<a name="68"/>      } else
<a name="69"/>         TextButton.handle_lrelease(e)
<a name="70"/>   end
<a name="71"/>
<a name="72"/>   public override get_pointer(e)
<a name="73"/>      if in_resize_region(e) then
<a name="74"/>         return "sb h double arrow"
<a name="75"/>   end
<a name="76"/>
<a name="77"/>   #
<a name="78"/>   # Set the initial width of the column, in pixels.  If this is
<a name="79"/>   # not provided, then the width will be set automatically to
<a name="80"/>   # use up any available free space.
<a name="81"/>   # :Parameters :
<a name="82"/>   # :  `x` - The width
<a name="83"/>   #
<a name="84"/>   public set_column_width(x)
<a name="85"/>      self.column_width := /x | need_integer(x, 0)
<a name="86"/>      link
<a name="87"/>   end
<a name="88"/>
<a name="89"/>   #
<a name="90"/>   # Set the column alignment
<a name="91"/>   # :Parameters :
<a name="92"/>   # :  `x` - A constant from `Align`
<a name="93"/>   public set_column_align(x)
<a name="94"/>      self.border.x_align := x
<a name="95"/>      link
<a name="96"/>   end
<a name="97"/>
<a name="98"/>   public override display()
<a name="99"/>      TextButton.display()
<a name="100"/>      Gui.style.fill_shadow_rectangle(self.cbwin, x + w - Gui.FINE_WIDTH, y, Gui.FINE_WIDTH, h)
<a name="101"/>      if self === \parent.which_highlight then
<a name="102"/>         border.draw_highlight(cbwin, x, y, w - Gui.FINE_WIDTH, h)
<a name="103"/>   end
<a name="104"/>
<a name="105"/>   #
<a name="106"/>   # Return the table content
<a name="107"/>   #
<a name="108"/>   public get_table_content()
<a name="109"/>      return parent.parent.table_content
<a name="110"/>   end
<a name="111"/>
<a name="112"/>   #
<a name="113"/>   # Return the table view
<a name="114"/>   #
<a name="115"/>   public get_table_view()
<a name="116"/>      return parent.parent.table_content.view
<a name="117"/>   end
<a name="118"/>
<a name="119"/>   #
<a name="120"/>   # The column's index in the header
<a name="121"/>   #
<a name="122"/>   public get_column_index()
<a name="123"/>      return parent.get_index(self)
<a name="124"/>   end
<a name="125"/>
<a name="126"/>   #
<a name="127"/>   # The table's contents list
<a name="128"/>   #
<a name="129"/>   public get_contents()
<a name="130"/>      return parent.parent.table_content.contents
<a name="131"/>   end
<a name="132"/>
<a name="133"/>   #
<a name="134"/>   # Generate the column's data, as a slice of the contents list.
<a name="135"/>   #
<a name="136"/>   public slice()
<a name="137"/>      suspend get_table_content().slice(get_column_index())
<a name="138"/>   end
<a name="139"/>
<a name="140"/>   public override layout()
<a name="141"/>      self.tx := self.x + border.get_l_inset()
<a name="142"/>      self.tw := self.w - border.get_total_width()
<a name="143"/>   end
<a name="144"/>
<a name="145"/>   public override shift(dx, dy)
<a name="146"/>      TextButton.shift(dx, dy)
<a name="147"/>      self.tx +:= dx
<a name="148"/>   end
<a name="149"/>
<a name="150"/>   #
<a name="151"/>   # Draw an individual cell for this column.
<a name="152"/>   #
<a name="153"/>   # :Parameters :
<a name="154"/>   # :  `W` - the cloned window to draw into
<a name="155"/>   # :  `data` - the data to draw
<a name="156"/>   # :  `line` - the line number of the data
<a name="157"/>   # :  `col` - the column number of the data
<a name="158"/>   # :  `cy` - the y position of the cell
<a name="159"/>   # :  `ch` - the height of the cell
<a name="160"/>   #
<a name="161"/>   public abstract draw_cell(W, data, line, col, cy, ch)
<a name="162"/>
<a name="163"/>   #
<a name="164"/>   # Return the desired height of the lines for the cells in this column.  This should
<a name="165"/>   # return an integer if the heights are all the same, or a list containing the different
<a name="166"/>   # heights for each line.
<a name="167"/>   # :Parameters :
<a name="168"/>   # :  `W` - the cloned window to draw into
<a name="169"/>   #
<a name="170"/>   public abstract calculate_line_height(W)
<a name="171"/>
<a name="172"/>   public override new()
<a name="173"/>      TextButton.new()
<a name="174"/>      self.set_accepts_focus(&amp;no)
<a name="175"/>      self.set_border(EmptyBorder().
<a name="176"/>                      set_l_inset(Gui.TEXT_INSET).
<a name="177"/>                      set_r_inset(Gui.TEXT_INSET).
<a name="178"/>                      set_x_align(Align.L))
<a name="179"/>      return
<a name="180"/>   end
<a name="181"/>end
<a name="182"/>
<a name="183"/>#
<a name="184"/># The basic table column, which displays simple textual data.
<a name="185"/>#
<a name="186"/>class TableColumn(BaseTableColumn)
<a name="187"/>   public override draw_cell(W, data, line, col, cy, ch)
<a name="188"/>      local x1, y1
<a name="189"/>      x1 := case border.x_align of {
<a name="190"/>         Align.R : self.tx + self.tw - W.text_width(data)
<a name="191"/>         Align.C : self.tx + (self.tw - W.text_width(data)) / 2
<a name="192"/>         Align.L : self.tx
<a name="193"/>         default : runerr("Bad column alignment", border.x_align)
<a name="194"/>      }
<a name="195"/>      y1 := cy + (ch - W.get_line_height()) / 2
<a name="196"/>      W.draw_string(x1, y1 + W.get_line_ascent(), data)
<a name="197"/>   end
<a name="198"/>
<a name="199"/>   public override calculate_line_height(W)
<a name="200"/>      return W.get_line_height()
<a name="201"/>   end
<a name="202"/>end
<a name="203"/>
<a name="204"/>#
<a name="205"/># A table column which delegates interpretation of the data to
<a name="206"/># an `ItemPaint` instance.
<a name="207"/>#
<a name="208"/>class ItemPaintTableColumn(BaseTableColumn)
<a name="209"/>   public
<a name="210"/>      item_paint,
<a name="211"/>      item_border
<a name="212"/>
<a name="213"/>   public override initially()
<a name="214"/>      \self.item_paint | runerr("ItemPaint not set")
<a name="215"/>      BaseTableColumn.initially()
<a name="216"/>      self.item_paint.initially(self)
<a name="217"/>      self.item_border.initially(self)
<a name="218"/>   end
<a name="219"/>
<a name="220"/>   public override finally()
<a name="221"/>      BaseTableColumn.finally()
<a name="222"/>      self.item_paint.finally()
<a name="223"/>      self.item_border.finally()
<a name="224"/>   end
<a name="225"/>
<a name="226"/>   public set_item_paint(r)
<a name="227"/>      if is_initialized() then {
<a name="228"/>         (\self.item_paint).finally()
<a name="229"/>         self.item_paint := r
<a name="230"/>         self.item_paint.initially(self)
<a name="231"/>      } else
<a name="232"/>         self.item_paint := r
<a name="233"/>      link
<a name="234"/>   end
<a name="235"/>
<a name="236"/>   #
<a name="237"/>   # Set a border to draw along with each Paint instance.
<a name="238"/>   #
<a name="239"/>   public set_item_border(b)
<a name="240"/>      if is_initialized() then {
<a name="241"/>         (\self.item_border).finally()
<a name="242"/>         self.item_border := b
<a name="243"/>         self.item_border.initially(self)
<a name="244"/>      } else
<a name="245"/>         self.item_border := b
<a name="246"/>      link
<a name="247"/>   end
<a name="248"/>
<a name="249"/>   public override set_column_align(x)
<a name="250"/>      BaseTableColumn.set_column_align(x)
<a name="251"/>      self.item_border.x_align := x
<a name="252"/>      link
<a name="253"/>   end
<a name="254"/>
<a name="255"/>   public override calculate_line_height(W)
<a name="256"/>      local bh
<a name="257"/>      bh := item_border.get_total_height()
<a name="258"/>      return item_paint.get_constant_height(W) + bh |
<a name="259"/>         ipl.pdco.List{ item_paint.get_height(W, slice()) + bh }
<a name="260"/>   end
<a name="261"/>
<a name="262"/>   public override draw_cell(W, data, line, col, cy, ch)
<a name="263"/>      local r
<a name="264"/>      r := Rect(self.x, cy, self.w, ch)
<a name="265"/>      item_paint.draw_rect(W, data, item_border.float(r, item_paint.get_size(W, data)))
<a name="266"/>      item_border.draw_rect(W, r)
<a name="267"/>   end
<a name="268"/>
<a name="269"/>   public override new()
<a name="270"/>      BaseTableColumn.new()
<a name="271"/>      self.set_item_border(NullBorder().
<a name="272"/>                           set_x_align(Align.L))
<a name="273"/>      return
<a name="274"/>   end
<a name="275"/>end
</pre></body></html>
