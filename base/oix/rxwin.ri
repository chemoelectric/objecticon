/*
 * File: rxwin.ri - X11 system-specific graphics interface code.
 */

#define GetDepth(wd) DefaultDepth((wd)->display,DefaultScreen((wd)->display))
#define GetVisual(wd) DefaultVisual((wd)->display,DefaultScreen((wd)->display))
#define GetWidth(wd) DisplayWidth((wd)->display,DefaultScreen((wd)->display))
#define GetHeight(wd) DisplayHeight((wd)->display,DefaultScreen((wd)->display))
#define GetRoot(wd) DefaultRootWindow((wd)->display)

/*
 * Polyedge to use with pixwin; set to PolyEdgeSharp or PolyEdgeSmooth
 */

#define PolyEdge PolyEdgeSmooth

/*
 * Global variables specific to X
 */
static wdp wdsplys;

struct lineinfo {
    double dx, dy;
    double len;
    XPointDouble p1, p2, q1, q2;
};

/*
 * function prototypes
 */
static void handle_config(wsp w, XConfigureEvent *event);
static void handle_property(wsp ws, XPropertyEvent *event);
static void handle_exposures(wsp ws, XExposeEvent *event);
static void handle_mouse(wsp ws, XButtonEvent *event);
static void handle_keypress(wsp ws, XKeyEvent *event);
static void handle_crossing(wsp ws, XCrossingEvent *event);
static char *get_progname(void);
static void wmap(wbp w);
static wsp wsp_for_Window(wdp wd, Window w);
static void synch_cursor(wsp ws);
static void synch_cursors(wdp wd, struct wcursor *c);
static void setup_cursors(wdp wd);
static void setup_cursor(wdp wd, char *name, int id);
static struct SharedCursor *new_sharedcursor(wdp wd, Cursor cursor);
static struct SharedCursor *link_sharedcursor(struct SharedCursor *x);
static void unlink_sharedcursor(struct SharedCursor *x);
static struct wcursor *lookup_wcursor(wdp wd, char *name);
static struct wcursor *ensure_wcursor(wdp wd, char *name);
static int convert_KeySym_to_code_point(KeySym k);
static wfp newfont(wdp wd, char *s);
static wdp alcdisplay (char *s);
static void resizepixmap(wbp w);
static void clip(wbp w);
static void no_clip(wsp ws, int and_win);
static int make_mod(unsigned int state);
static char* property_to_string(wdp wd, Atom target, int number_items, void* data);
static Atom convert_target(wdp wd, Atom desired_target);
static void get_atom_descriptor(wsp ws, Atom a, dptr dest);
static void synch_state(wsp ws);
static void synch_net_wm_state(wsp ws, int desired_state);
static void close_screen_win(wsp ws);
static void fill2(wbp w, int op, XRenderColor  *color, int x, int y, int width, int height);
static void pic2(wbp w, Picture src, int x, int y, int width, int height);
static void pat1(wbp w, int x, int y, int width, int height);
static void pat2(wbp w, int x, int y, int width, int height);
static void maskpic2(wbp w, Picture mask, int x, int y, int width, int height);
static Picture get_draw_picture(wcp wc);
static void pix_to_win(wsp ws, int x, int y, int w, int h);
static Picture getmask(wdp wd, int width, int height);
static XPointDouble doublept(double x, double y);
static XTriangle triangle(double x1, double y1, double x2, double y2, double x3, double y3);
static XTrapezoid trapezoid(double top, double x1, double x2, double bottom, double x3, double x4);
static int needmask(wcp wc, int overlap);
static int make_circle(double cx, double cy, double radius, int max_ntraps, XTrapezoid traps[]);
static int make_ellipse(double cx, double cy, double rx, double ry, int max_ntraps, XTrapezoid traps[]);
static void drawlineinfos(wbp w, struct lineinfo *lis, int nlis, int closed);
static void getlineinfo(wcp wc, XPointDouble *p0, XPointDouble *q0, struct lineinfo *res);
static wcp clonecontext(wcp wc);
static void freecontext(wcp wc);
static void freewindow(wsp ws);
static void apply_windowlabel(wsp ws);
static void apply_windowicon(wsp ws);

static stringint drawops[] = {
   { 0, 12},
   {"atop",  PictOpAtop},
   {"clear",  PictOpClear},
   {"dest",  PictOpDst},
   {"dest atop",  PictOpAtopReverse},
   {"dest in",  PictOpInReverse},
   {"dest out",  PictOpOutReverse},
   {"dest over",  PictOpOverReverse},
   {"in",  PictOpIn},
   {"out",  PictOpOut},
   {"over",  PictOpOver},
   {"source",  PictOpSrc},
   {"xor",  PictOpXor},
};

static stringint linestyles[] = {
    {0, 3},
    {"enddisc",      EndDisc},
    {"endsquare",    EndSquare},
    {"solid",        EndSquare},
};

static stringint canvastypes[] = {
    {0, 8},
    {"fullscreen",  FullScreenState},
    {"hidden",      HiddenState},
    {"iconic",      IconicState},
    {"maximized",   MaximizedState},
    {"normal",      NormalState},
    {"popup",       PopupState},
    {"root",        RootState},
    {"withdrawn",   WithdrawnState},
};

static int selection_debug = 0;

#if 0
static void dump_all(void)
{
    int i,j,k;
    wsp x;
    wbp y;
    i = 0;
    for (y = wbndngs; y; y = y->next) {
        printf("Binding %p\n",y);
        printf("\tcanvas %p\n",y->window);
        printf("\tcontext %p\n",y->context);
        ++i;
    }
    printf("============\n");
    j = 0;
    for (x = wstates; x; x = x->next) {
        printf("Canvas %p\n",x);
        printf("\trefcount=%d\n", x->refcount);
        printf("\tlabel=%s\n", x->windowlabel);
        printf("\tgeometry=%d,%d %dx%d\n", x->x,x->y,x->width,x->height);
        printf("\twin=%d\n", (int)x->win);
        ++j; 
    }
    printf("============\n");
    k = 0;
    for (x = vwstates; x; x = x->vnext) {
        printf("Non-hidden Canvas %p\n",x);
        printf("\trefcount=%d\n", x->refcount);
        printf("\tlabel=%s\n", x->windowlabel);
        printf("\tgeometry=%d,%d %dx%d\n", x->x,x->y,x->width,x->height);
        printf("\twin=%d\n", (int)x->win);
        ++k; 
    }

    printf("Total %d bindings %d canvases (%d non-hidden)\n",i,j,k);
}
#endif
#if 0
static void dump_ximage(XImage *xi)
{
    int i,j;
    printf("XImage=%p\n",xi);
    printf("\twidth, height=%d %d\n", xi->width, xi->height);            /* size of image */
    printf("\txoffset=%d\n", xi->xoffset);                  /* number of pixels offset in X direction */
    printf("\tformat=%d\n", xi->format);                  /* XYBitmap, XYPixmap, ZPixmap */
    printf("\tbyte_order=%d\n", xi->byte_order);               /* data byte order, LSBFirst, MSBFirst */
    printf("\tbitmap_unit =%d\n", xi->bitmap_unit);             /* quant. of scanline 8, 16, 32 */
    printf("\tbitmap_bit_order =%d\n", xi->bitmap_bit_order);        /* LSBFirst, MSBFirst */
    printf("\tbitmap_pad   =%d\n", xi->bitmap_pad);            /* 8, 16, 32 either XY or ZPixmap */
    printf("\tdepth  =%d\n", xi->depth);              /* depth of image */
    printf("\tbytes_per_line=%d\n", xi->bytes_per_line);          /* accelerator to next scanline */
    printf("\tbits_per_pixel=%d\n", xi->bits_per_pixel);        /* bits per pixel (ZPixmap) */
    printf("\tred_mask=%lx\n", xi->red_mask);       /* bits in z arrangement */
    printf("\tgreen_mask=%lx\n", xi->green_mask);
    printf("\tblue_mask=%lx\n", xi->blue_mask);

    for (i=0;i<32;++i)
        printf("%d ", (int)imd->data[i]);
    printf("\n");
    printf("\nPixel dump of region %d,%d size %d,%d\n",x,y,xi->width,xi->height);
    
    for (j=0; j < xi->height; ++j) {
        unsigned long c0=-1;
        printf("\nrow %d:",j);
        for (i = 0; i < xi->width; ++i) {
            unsigned long c;            
            c=XGetPixel(xi,i,j);
            if (c!=c0) {
                printf("%lx ",c);
                c0=c;
            } else
                printf("-");
        }
    }
    printf("\n");
}



#endif

#define ATOM(d, x) ((d)->atoms[ATOM_##x])

struct SharedPicture *new_sharedpicture(wdp wd, struct imgdata *imd)
{
    struct SharedPicture *res;
    XRenderPictureAttributes pa;
    GAlloc(res, SharedPicture);
    res->wd = wd;
    res->pix = imgdata_to_Pixmap(wd, imd);
    pa.repeat = 1;
    res->i = XRenderCreatePicture(wd->display, res->pix, wd->pixfmt, CPRepeat, &pa);
    res->width = imd->width;
    res->height = imd->height;
    return res;
}

struct SharedPicture *link_sharedpicture(struct SharedPicture *x)
{
    ++x->refcount;
    return x;
}

void unlink_sharedpicture(struct SharedPicture *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        if (x->i)
            XRenderFreePicture(x->wd->display, x->i);
        if (x->pix)
            XFreePixmap(x->wd->display, x->pix);
        free(x);
    }
}

struct SharedColor *new_sharedcolor(wdp wd, char *name, int r, int g, int b, int a)
{
    struct SharedColor *res;
    GAlloc(res, SharedColor);
    res->wd = wd;
    res->color.red = Mul16(r, a);
    res->color.green = Mul16(g, a);
    res->color.blue = Mul16(b, a);
    res->color.alpha = a;
    res->brush = XRenderCreateSolidFill(wd->display, &res->color);
    res->name = salloc(name);
    return res;
}

struct SharedColor *link_sharedcolor(struct SharedColor *x)
{
    ++x->refcount;
    return x;
}

void unlink_sharedcolor(struct SharedColor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        XRenderFreePicture(x->wd->display, x->brush);
        free(x->name);
        free(x);
    }
}

static struct SharedCursor *new_sharedcursor(wdp wd, Cursor cursor)
{
    struct SharedCursor *res;
    GAlloc(res, SharedCursor);
    res->wd = wd;
    res->cursor = cursor;
    return res;
}

static struct SharedCursor *link_sharedcursor(struct SharedCursor *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedcursor(struct SharedCursor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        XFreeCursor(x->wd->display, x->cursor);
        free(x);
    }
}

static struct wcursor *lookup_wcursor(wdp wd, char *name)
{
    struct wcursor *rv;
    int i;
    i = hasher(hashcstr(name), wd->cursors);
    for(rv = wd->cursors[i]; rv; rv = rv->next) {
        if (!strcmp(name, rv->name))
            return rv;
    }
    return 0;
}

static struct wcursor *ensure_wcursor(wdp wd, char *name)
{
    struct wcursor *rv;
    int i;
    i = hasher(hashcstr(name), wd->cursors);
    for(rv = wd->cursors[i]; rv; rv = rv->next) {
        if (!strcmp(name, rv->name))
            return rv;
    }
    MemProtect(rv = calloc(1, sizeof(struct wcursor)));
    rv->name = salloc(name);
    rv->next = wd->cursors[i];
    wd->cursors[i] = rv;
    return rv;
}

int definepointer(wbp w, char *name, int x, int y)
{
    struct wcursor *rv;
    Cursor nc;
    wdp wd = w->window->display;
    nc = XRenderCreateCursor(wd->display, w->window->ppic, x, y);
    rv = ensure_wcursor(wd, name);
    if (rv->shared_cursor) {
        unlink_sharedcursor(rv->shared_cursor);
        rv->shared_cursor = new_sharedcursor(wd, nc);
        synch_cursors(wd, rv);
    } else
        rv->shared_cursor = new_sharedcursor(wd, nc);
    return Succeeded;
}

static void synch_cursors(wdp wd, struct wcursor *c)
{
    wsp x;
    for (x = wd->vwstates; x; x = x->vnext) {
        if (x->cursor == c)
            synch_cursor(x);
    }
}

int copypointer(wbp w, char *dest, char *src)
{
    struct wcursor *sc, *dc;
    wdp wd = w->window->display;
    sc = lookup_wcursor(wd, src);
    if (!sc)
        return Failed;
    dc = ensure_wcursor(wd, dest);
    if (sc != dc) {
        if (dc->shared_cursor) {
            unlink_sharedcursor(dc->shared_cursor);
            dc->shared_cursor = link_sharedcursor(sc->shared_cursor);
            synch_cursors(wd, dc);
        } else
            dc->shared_cursor = link_sharedcursor(sc->shared_cursor);
    }
    return Succeeded;
}

static void setup_cursor(wdp wd, char *name, int id)
{
    int i;
    struct wcursor *rv;
    i = hasher(hashcstr(name), wd->cursors);
    MemProtect(rv = calloc(1, sizeof(struct wcursor)));
    rv->name = name;
    rv->shared_cursor = new_sharedcursor(wd, XCreateFontCursor(wd->display, id));
    rv->next = wd->cursors[i];
    wd->cursors[i] = rv;
}

static void setup_cursors(wdp wd)
{
    setup_cursor(wd, "X cursor",	XC_X_cursor);
    setup_cursor(wd, "arrow",		XC_arrow);
    setup_cursor(wd, "based arrow down",XC_based_arrow_down);
    setup_cursor(wd, "based arrow up",	XC_based_arrow_up);
    setup_cursor(wd, "boat",		XC_boat);
    setup_cursor(wd, "bogosity",	XC_bogosity);
    setup_cursor(wd, "bottom left corner",XC_bottom_left_corner);
    setup_cursor(wd, "bottom right corner",XC_bottom_right_corner);
    setup_cursor(wd, "bottom side",	XC_bottom_side);
    setup_cursor(wd, "bottom tee",	XC_bottom_tee);
    setup_cursor(wd, "box spiral",	XC_box_spiral);
    setup_cursor(wd, "center ptr",	XC_center_ptr);
    setup_cursor(wd, "circle",		XC_circle);
    setup_cursor(wd, "clock",		XC_clock);
    setup_cursor(wd, "coffee mug",	XC_coffee_mug);
    setup_cursor(wd, "cross",		XC_cross);
    setup_cursor(wd, "cross reverse",	XC_cross_reverse);
    setup_cursor(wd, "crosshair",	XC_crosshair);
    setup_cursor(wd, "diamond cross",	XC_diamond_cross);
    setup_cursor(wd, "dot",		XC_dot);
    setup_cursor(wd, "dotbox",		XC_dotbox);
    setup_cursor(wd, "double arrow",	XC_double_arrow);
    setup_cursor(wd, "draft large",	XC_draft_large);
    setup_cursor(wd, "draft small",	XC_draft_small);
    setup_cursor(wd, "draped box",	XC_draped_box);
    setup_cursor(wd, "exchange",	XC_exchange);
    setup_cursor(wd, "fleur",		XC_fleur);
    setup_cursor(wd, "gobbler",		XC_gobbler);
    setup_cursor(wd, "gumby",		XC_gumby);
    setup_cursor(wd, "hand1",		XC_hand1);
    setup_cursor(wd, "hand2",		XC_hand2);
    setup_cursor(wd, "heart",		XC_heart);
    setup_cursor(wd, "icon",		XC_icon);
    setup_cursor(wd, "iron cross",	XC_iron_cross);
    setup_cursor(wd, "left ptr",	XC_left_ptr);
    setup_cursor(wd, "left side",	XC_left_side);
    setup_cursor(wd, "left tee",	XC_left_tee);
    setup_cursor(wd, "leftbutton",	XC_leftbutton);
    setup_cursor(wd, "ll angle",	XC_ll_angle);
    setup_cursor(wd, "lr angle",	XC_lr_angle);
    setup_cursor(wd, "man",		XC_man);
    setup_cursor(wd, "middlebutton",	XC_middlebutton);
    setup_cursor(wd, "mouse",		XC_mouse);
    setup_cursor(wd, "pencil",		XC_pencil);
    setup_cursor(wd, "pirate",		XC_pirate);
    setup_cursor(wd, "plus",		XC_plus);
    setup_cursor(wd, "question arrow",	XC_question_arrow);
    setup_cursor(wd, "right ptr",	XC_right_ptr);
    setup_cursor(wd, "right side",	XC_right_side);
    setup_cursor(wd, "right tee",	XC_right_tee);
    setup_cursor(wd, "rightbutton",	XC_rightbutton);
    setup_cursor(wd, "rtl logo",	XC_rtl_logo);
    setup_cursor(wd, "sailboat",	XC_sailboat);
    setup_cursor(wd, "sb down arrow",	XC_sb_down_arrow);
    setup_cursor(wd, "sb h double arrow",	XC_sb_h_double_arrow);
    setup_cursor(wd, "sb left arrow",	XC_sb_left_arrow);
    setup_cursor(wd, "sb right arrow",	XC_sb_right_arrow);
    setup_cursor(wd, "sb up arrow",	XC_sb_up_arrow);
    setup_cursor(wd, "sb v double arrow",	XC_sb_v_double_arrow);
    setup_cursor(wd, "shuttle",		XC_shuttle);
    setup_cursor(wd, "sizing",		XC_sizing);
    setup_cursor(wd, "spider",		XC_spider);
    setup_cursor(wd, "spraycan",	XC_spraycan);
    setup_cursor(wd, "star",		XC_star);
    setup_cursor(wd, "target",		XC_target);
    setup_cursor(wd, "tcross",		XC_tcross);
    setup_cursor(wd, "top left arrow",	XC_top_left_arrow);
    setup_cursor(wd, "top left corner",	XC_top_left_corner);
    setup_cursor(wd, "top right corner",XC_top_right_corner);
    setup_cursor(wd, "top side",	XC_top_side);
    setup_cursor(wd, "top tee",		XC_top_tee);
    setup_cursor(wd, "trek",		XC_trek);
    setup_cursor(wd, "ul angle",	XC_ul_angle);
    setup_cursor(wd, "umbrella",	XC_umbrella);
    setup_cursor(wd, "ur angle",	XC_ur_angle);
    setup_cursor(wd, "watch",		XC_watch);
    setup_cursor(wd, "xterm",		XC_xterm);
}

#begdef CheckUnhidden(ws)
do {
   if (!ws->win) {
      LitWhy("Window is hidden");
      return Failed;
   }
} while(0)
#enddef

static char *atom_fmt(wsp ws,Atom a) 
{
    static int n = 0;
    static char buff[8][96];
    char *s, *r;
    r = buff[n];
    if (a == None)
        return "None(0)";

    s = XGetAtomName(ws->display->display, a);
    if (s) {
        sprintf(r, "%.64s(%ld)", s, (long)a);
        XFree(s);
    } else {
        sprintf(r, "?unknown atom(%ld)", (long)a);
    }

    n = (n + 1) % 8;
    return r;
}

/*
 * Get the string name of the given Atom into dest.  The string is
 * allocated in the string region.
 */
static void get_atom_descriptor(wsp ws, Atom a, dptr dest)
{
    char *s = XGetAtomName(ws->display->display, a);
    cstr2string(s, dest);
    XFree(s);
}

static Atom convert_target(wdp wd, Atom desired_target)
{
    /* Check for common cases. */
    if ( (desired_target == ATOM(wd, TIMESTAMP))    ||
         (desired_target == ATOM(wd, LIST_LENGTH) ) ||
         (desired_target == ATOM(wd, SPAN) ) ||
         (desired_target == ATOM(wd, CHARACTER_POSITION) ) ||
         (desired_target == ATOM(wd, LENGTH) ) ) {
        return XA_INTEGER;
    }

    if ( desired_target == ATOM(wd, TARGETS) ) {
        return XA_ATOM;
    }

    if ( desired_target == ATOM(wd, CLIENT_WINDOW) ) {
        return XA_WINDOW;
    }

    /* Otherwise, no need to convert target. */
    return desired_target;
}

static char* property_to_string(wdp wd, Atom target, int number_items, void* data)
{
    char *result = 0;
    int i, length;

    /* Convert target, if necessary. */
    target = convert_target(wd, target);

    switch (target) {
        case XA_ATOM: {
            int curr_len, total_len;
            unsigned long *long_array = (unsigned long *)data;

            length = 32;
            MemProtect(result = malloc(length));
            *result = 0;
            total_len = 0;

            /* Convert to atom names. */
            for (i = 0; i < number_items; i++) {
                char *atom_name = XGetAtomName(wd->display, long_array[i] );
                if (atom_name) {
                    curr_len = strlen(atom_name) + 1;    /* +1 for the \n */
                    if (total_len + curr_len + 1 > length) {  /* +1 for the \0 */
                        length = total_len + curr_len + 1;
                        MemProtect(result = realloc(result, length));
                    }
                    sprintf(result + total_len, "%s\n", atom_name);
                    total_len += curr_len;
                    XFree(atom_name);
                }
            }
            break;
        }
        case XA_INTEGER: {
            long *long_array = (long *)data;
            length = number_items * 20 + 1;
            MemProtect(result = malloc(length));
            *result = 0;
            for (i = 0; i < number_items; i++) {
                if (i > 0)
                    strcat(result, " ");
                sprintf(result + strlen(result), "%ld", long_array[i]);
            }
            break;
        }
        case XA_WINDOW: {
            unsigned long *long_array = (unsigned long *)data;
            length = number_items * 12 + 1;
            MemProtect(result = malloc(length));
            *result = 0;
            for (i = 0; i < number_items; i++) {
                if (i > 0)
                    strcat(result, " ");
                sprintf(result + strlen(result), "0x%8.8lu", long_array[i]);
            }
            break;
        }
    }

    return result;
}

static wsp wsp_for_Window(wdp wd, Window w)
{
    wsp ws;
    for (ws = wd->vwstates; ws; ws = ws->vnext) {
        if (ws->win == w)
            return ws;
    }
    return 0;
}

void pollevent(wbp w)
{
    wdp wd = w->window->display;
    XEvent event;
    Window evwin;
    wsp ws;
    while (XPending(wd->display)) {
        XNextEvent(wd->display, &event);
        evwin = event.xexpose.window;  /* go ahead, criticize all you like */
        ws = wsp_for_Window(wd, evwin);
        if (!ws)
            continue;

        switch (event.type) {
            case SelectionRequest: {
                tended struct descrip tmp;
                if (selection_debug)
                    printf("SelectionRequest event:\n\towner=%lx requestor=%lx "
                           "property=%s target=%s selection=%s\n",
                           (long)event.xselectionrequest.owner,
                           (long)event.xselectionrequest.requestor,
                           atom_fmt(ws, event.xselectionrequest.property),
                           atom_fmt(ws, event.xselectionrequest.target),
                           atom_fmt(ws, event.xselectionrequest.selection)
                        );

                MakeInt(SELECTIONREQUEST, &tmp);
                list_put(&ws->listp, &tmp);
                MakeInt((word)event.xselectionrequest.requestor, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselectionrequest.property, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselectionrequest.selection, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselectionrequest.target, &tmp);
                list_put(&ws->listp, &tmp);
                MakeInt(event.xselectionrequest.time, &tmp);
                list_put(&ws->listp, &tmp);
                break;
            }

            case SelectionClear: {
                tended struct descrip tmp;
                if (selection_debug)
                    printf("SelectionClear event win=%lx selection=%s\n",
                           (long)event.xselectionclear.window,
                           atom_fmt(ws, event.xselectionclear.selection));
                MakeInt(SELECTIONCLEAR, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselectionclear.selection, &tmp);
                list_put(&ws->listp, &tmp);
                break;
            }

            case SelectionNotify: {
                Atom actual_type;
                int actual_format;
                unsigned long bytes_after, nitems;
                unsigned char *prop;
                word bytes_read;
                tended struct descrip tmp;
                int status;
                char *conv_str;

                if (selection_debug)
                    printf("SelectionNotify: requestor=%lx selection=%s target=%s property=%s\n",
                           (long)event.xselection.requestor,
                           atom_fmt(ws, event.xselection.selection),
                           atom_fmt(ws, event.xselection.target),
                           atom_fmt(ws, event.xselection.property));

                MakeInt(SELECTIONRESPONSE, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselection.selection, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselection.target, &tmp);
                list_put(&ws->listp, &tmp);

                if (event.xselection.property == None) {
                    if (selection_debug)
                        printf("XGetWindowProperty xselection.property == None\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                status = XGetWindowProperty(ws->display->display,
                                            ws->win,
                                            event.xselection.property,
                                            0,
                                            8192,   /* Means we won't get back > 32kb of stuff */
                                            True,
                                            AnyPropertyType,
                                            &actual_type,
                                            &actual_format,
                                            &nitems,
                                            &bytes_after,
                                            &prop);

                if (status != Success) {
                    if (selection_debug)
                        printf("XGetWindowProperty failed\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                if (actual_type == None) {
                    if (selection_debug)
                        printf("XGetWindowProperty returned actual_type == None\n");
                    list_put(&ws->listp, &nulldesc);
                    if (prop) XFree(prop);
                    break;
                }

                /* Shouldn't ever happen */
                if (!prop) {
                    if (selection_debug)
                        printf("XGetWindowProperty set prop to null\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                bytes_read = nitems * (actual_format/8);
                if (selection_debug)
                    printf("Got %lu items x %d bits -> %ld bytes actual_type=%s\n",
                           nitems, actual_format, (long)bytes_read, atom_fmt(ws, actual_type));

                conv_str = property_to_string(ws->display,
                                              actual_type,
                                              nitems,
                                              prop);
                if (conv_str) {
                    /* Make an Icon string out of the data */
                    cstr2string(conv_str, &tmp);
                    free(conv_str);
                } else {
                    /* Make an Icon string out of the data */
                    bytes2string((char *)prop, bytes_read, &tmp);
                }
                list_put(&ws->listp, &tmp);

                XFree(prop);
                    
                break;
            }

            case KeyRelease: {
                if (ws->inputmask & IM_KEY_RELEASE)
                    handle_keypress(ws, (XKeyEvent *)&event);
                break;
            }
            case KeyPress:
                handle_keypress(ws, (XKeyEvent *)&event);
                break;
            case ButtonPress:
            case ButtonRelease:
            case MotionNotify:
                handle_mouse(ws, (XButtonEvent *)&event);
                break;
            case LeaveNotify:
            case EnterNotify:
                handle_crossing(ws, (XCrossingEvent *)&event);
                break;
            case NoExpose:
                break;
            case Expose:
                handle_exposures(ws, (XExposeEvent *)&event);
                break;
            case PropertyNotify:
                handle_property(ws, (XPropertyEvent *)&event);
                break;
            case UnmapNotify:
            case MapNotify:
                break;
            case ConfigureNotify:
                handle_config(ws, (XConfigureEvent *)&event);
                break;
            case ClientMessage: {
                /*
                 * only client message we handle at present are destroy requests
                 */
                if (event.xclient.data.l[0] == ATOM(ws->display, WM_DELETE_WINDOW))
                    qeventcode(ws, WINDOWCLOSED);
                break;
            }
            default:
                break;
        }
    }
}

static void close_screen_win(wsp ws)
{
    wdp wd = ws->display;
    XRenderFreePicture(wd->display, ws->wpic);
    XDestroyWindow(wd->display, ws->win);
    XFlush(wd->display);
    ws->win = 0;
    ws->wpic = 0;
    GUnlink4(ws, wd->vwstates, vnext, vprevious);
    synch_state(ws);
}

/*
 * open a window
 */
wbp wopen(char *display)
{
    wbp w;
    wsp ws;
    wcp wc;
    wdp wd;
    XRenderPictureAttributes attr;

    if ((wd = alcdisplay(display)) == NULL) {
        /* alcdisplay will have set &why */
        return 0;
    }

    w = alcwbinding(wd);

    GAlloc(ws, _wstate);
    ws->listp = nulldesc;
    ws->windowlabel = defaultwindowlabel;
    add_gc_global(&ws->windowlabel);
    add_gc_global(&ws->listp);
    ws->cursor = lookup_wcursor(wd, "left ptr");
    ws->state = HiddenState;
    ws->x = ws->y = -INT_MAX;
    ws->minwidth = ws->minheight = 1;
    ws->maxwidth = ws->maxheight = INT_MAX;
    ws->width = ws->height = ws->pixwidth = ws->pixheight = 1;
    ws->pxft = NULL;
    ws->display = wd;
    w->window = ws;
    create_list(64, &ws->listp);

    GAlloc(wc, _wcontext);
    wc->display = wd;
    wc->bg = link_sharedcolor(wd->white);
    wc->fg = link_sharedcolor(wd->black);
    wc->font = wd->defaultfont;
    wc->leading = defaultleading;
    wc->drawop = stringint_lookup(drawops, "over");
    wc->clipx = wc->clipy = 0;
    wc->clipw = wc->cliph = -1;
    wc->linewidth = 1;
    wc->linestyle = stringint_lookup(linestyles, "endsquare");

    w->context = wc;

    /*
     * Create the 1x1 pixmap
     */
    ws->pix = XCreatePixmap(wd->display, GetRoot(wd),
                            ws->pixwidth, ws->pixheight,
                            32);
    attr.poly_edge = PolyEdge;
    ws->ppic = XRenderCreatePicture(wd->display, ws->pix, wd->pixfmt, CPPolyEdge, &attr);

    /* Fill pixmap with background colour */
    XRenderFillRectangle(wd->display,
                         PictOpSrc,
                         ws->ppic,
                         &wc->bg->color,
                         0, 0, ws->width, ws->height);
    return w;
}

int setwindowicon(wbp w, struct imgdata *imd)
{
    wsp ws = w->window;
    int i, j, k;
    free(ws->icondata);
    if (imd) {
        ws->iconlen = 2 + imd->width * imd->height;
        MemProtect(ws->icondata = malloc(ws->iconlen * sizeof(unsigned long)));
        k = 0;
        ws->icondata[k++] = imd->width;
        ws->icondata[k++] = imd->height;
        for (j = 0; j < imd->height; ++j) {
            for (i = 0; i < imd->width; ++i) {
                int r, g, b, a;
                imd->format->getpixel(imd, i, j, &r, &g, &b, &a);
                ws->icondata[k++] = ((a/256)<<24) | ((r/256)<<16) | ((g/256)<<8) | (b/256);
            }
        }
        if (ws->win)
            apply_windowicon(ws);
    } else {
        ws->icondata = 0;
        ws->iconlen = 0;
    }
    return Succeeded;
}

int getwindowicon(wbp w, struct imgdata *imd)
{
    wsp ws = w->window;
    int i, j;
    unsigned long *p;
    if (!ws->icondata)
        return Failed;
    p = ws->icondata;
    imd->format = &imgdataformat_RGBA32;
    imd->width = *p++;
    imd->height = *p++;
    MemProtect(imd->data = malloc(imd->format->getlength(imd)));
    for (j = 0; j < imd->height; ++j) {
        for (i = 0; i < imd->width; ++i) {
            int r, g, b, a;
            b = 257 * (*p & 0xff);
            g = 257 * (*p>>8 & 0xff);
            r = 257 * (*p>>16 & 0xff);
            a = 257 * (*p>>24 & 0xff);
            imd->format->setpixel(imd, i, j, r, g, b, a);
            ++p;
        }
    }
    return Succeeded;
}

int setpattern(wbp w, struct imgdata *imd)
{
    wcp wc = w->context;
    wdp wd = w->window->display;
    if (wc->pattern)
        unlink_sharedpicture(wc->pattern);
    if (imd)
        wc->pattern = new_sharedpicture(wd, imd);
    else
        wc->pattern = 0;
    return Succeeded;
}

int getpattern(wbp w, struct imgdata *imd)
{
    wcp wc = w->context;
    wdp wd = w->window->display;
    XImage *xi;
    if (!wc->pattern)
        return Failed;
    MemProtect(xi = XGetImage(wd->display, wc->pattern->pix,
                              0, 0,
                              wc->pattern->width,
                              wc->pattern->height,
                              AllPlanes,
                              ZPixmap));

    imd->format = wd->format;
    imd->data = (unsigned char *)xi->data;
    imd->width = wc->pattern->width;
    imd->height = wc->pattern->height;
    xi->data = 0;
    XDestroyImage(xi);
    return Succeeded;
}

/*
 * Return an allocated string giving the part of the prog name after the last '/'.
 */
static char *get_progname()
{
    int n;
    char *p, *s, *m;
    p = StrLoc(kywd_prog);
    s = p + StrLen(kywd_prog);
    while (s > p && s[-1] != '/')
        s--;				/* find tail of prog_name */
    n = p + StrLen(kywd_prog) - s;          /* no. of chars to copy */
    MemProtect(m = malloc(n + 1));
    memcpy(m, s, n);
    m[n] = 0;
    return m;
}

/*
 *  Open the X window for a non-hidden icon window.
 */
static void wmap(wbp w)
{
    XWindowAttributes attrs;
    XSetWindowAttributes attr;
    char *s, *m1, *m2;
    XWMHints wmhints;
    XClassHint clhints;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;

    /*
     * create the X window (or use the DefaultRootWindow if requested)
     */
    attr.background_pixel = 0xffffff;  /* TODO wc->bg->c; */

    switch (ws->state) {
        case RootState:
            ws->win = GetRoot(wd);
            break;
        case PopupState: {
            attr.override_redirect = True;
            ws->win = XCreateWindow(wd->display, GetRoot(wd),
                                    ws->x < 0 ? 0 : ws->x,
                                    ws->y < 0 ? 0 : ws->y, 
                                    ws->width, ws->height, 
                                    0,
                                    GetDepth(wd),
                                    InputOutput,
                                    CopyFromParent,
                                    CWBackPixel|CWOverrideRedirect,
                                    &attr);
            break;
        }
        default: {
            ws->win = XCreateWindow(wd->display, GetRoot(wd),
                                    ws->x < 0 ? 0 : ws->x,
                                    ws->y < 0 ? 0 : ws->y, 
                                    ws->width, ws->height, 
                                    0,
                                    GetDepth(wd),
                                    InputOutput,
                                    CopyFromParent,
                                    CWBackPixel,
                                    &attr);
            break;
        }
    }

    ws->wpic = XRenderCreatePicture(wd->display, ws->win, wd->winfmt, 0, NULL);

    /* Set the optional WM_TRANSIENT_FOR hint. */
    if (ws->transientfor && ws->transientfor->win)
        XSetTransientForHint(wd->display, ws->win, ws->transientfor->win);

    /* Turn off background; this prevents X filling the background on an expose
       and hence prevents unsightly flicker on a resize. */
    XSetWindowBackgroundPixmap(wd->display, ws->win, None);

    XSetWMProtocols(wd->display, ws->win, &ATOM(wd, WM_DELETE_WINDOW), 1);

    XClearWindow(wd->display, ws->win);

    GLink4(ws, wd->vwstates, vnext, vprevious);

    /* For RootState, need to fill since XClearWindow above fills with a pixmap */
    if (ws->state == RootState) {
        XRenderFillRectangle(wd->display,
                             PictOpSrc,
                             ws->wpic,
                             &wc->bg->color,
                             0, 0, ws->width, ws->height);
    } else {
        XSizeHints size_hints;
        size_hints.flags = PSize | PMinSize | PMaxSize;
        size_hints.width = ws->width;
        size_hints.height= ws->height;
        if (ws->x != -INT_MAX && ws->y != -INT_MAX) {
            size_hints.flags |= USPosition;
            size_hints.x = ws->x;
            size_hints.y = ws->y;
        }
        if (ws->resizable) {
            size_hints.min_width = ws->minwidth;
            size_hints.min_height = ws->minheight;
            size_hints.max_width = ws->maxwidth;
            size_hints.max_height = ws->maxheight;
        }
        else {
            size_hints.min_width = size_hints.max_width = ws->width;
            size_hints.min_height = size_hints.max_height = ws->height;
        }
        apply_windowlabel(ws);

        XSetWMNormalHints(wd->display, ws->win, &size_hints);
        XSelectInput(wd->display, ws->win, 
                     ExposureMask | KeyPressMask | EnterWindowMask | LeaveWindowMask |
                     ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | PropertyChangeMask |
                     StructureNotifyMask | PointerMotionMask | KeyReleaseMask);

        if (ws->icondata)
            apply_windowicon(ws);
    }

    wmhints.input = True;
    wmhints.flags = InputHint;
    if (ws->state == IconicState) {
        wmhints.flags |= StateHint;
        wmhints.initial_state = IconicState;
    } else if (ws->state == WithdrawnState) {
        wmhints.flags |= StateHint;
        wmhints.initial_state = WithdrawnState;
    } else if (ws->state != RootState) {
        wmhints.flags |= StateHint;
        wmhints.initial_state = NormalState;
    }
    XSetWMHints(wd->display, ws->win, &wmhints);

    /*
     * Set the class hints that name the program (for reference by the
     * window manager) following conventions given in O'Reilly.
     */
    if ((s = getenv("OIRESOURCE_NAME"))) {
        clhints.res_name = s;
        m1 = 0;
    } else {
        m1 = get_progname();
        clhints.res_name = m1;
    }
    if ((s = getenv("OIRESOURCE_CLASS"))) {
        clhints.res_class = s;
        m2 = 0;
    } else {
        /* Defaults to prog name, with first letter capitalized (see X(7) manpage). */
        m2 = get_progname();
        m2[0] = toupper((unsigned char)m2[0]);
        clhints.res_class = m2;
    }
    XSetClassHint(wd->display, ws->win, &clhints);
    free(m1);
    free(m2);
    XSync(wd->display, False);

    if (ws->state == MaximizedState) {
        Atom atoms[2];
        atoms[0] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
        atoms[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
        XChangeProperty(wd->display, ws->win,
                        ATOM(wd, _NET_WM_STATE),
                        XA_ATOM, 32,
                        PropModeReplace, (unsigned char *)atoms, 2);
    } else if (ws->state == FullScreenState) {
        Atom atoms[1];
        atoms[0] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
        XChangeProperty(wd->display, ws->win,
                        ATOM(wd, _NET_WM_STATE),
                        XA_ATOM, 32,
                        PropModeReplace, (unsigned char *)atoms, 1);
    }

    if (ws->state != RootState && ws->state != WithdrawnState)
        XMapWindow(wd->display, ws->win);

    XGetWindowAttributes(wd->display, ws->win, &attrs);
    ws->width = attrs.width;
    ws->height = attrs.height;
    resizepixmap(w);

    synch_cursor(ws);

    XSync(wd->display, False);
}

static void synch_net_wm_state(wsp ws, int desired_state)
{
    XEvent e;
    wdp wd = ws->display;
    e.xclient.type = ClientMessage;
    e.xclient.serial = 0;
    e.xclient.send_event = True;
    e.xclient.display = wd->display;
    e.xclient.message_type = ATOM(wd, _NET_WM_STATE);
    e.xclient.format = 32;
    e.xclient.window = ws->win;
    e.xclient.data.l[3] = 0;
    switch (desired_state) {
        case NormalState: {
            e.xclient.data.l[0] = _NET_WM_STATE_REMOVE;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
            e.xclient.data.l[2] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            break;
        }
        case MaximizedState: {
            e.xclient.data.l[0] = _NET_WM_STATE_REMOVE;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[0] = _NET_WM_STATE_ADD;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
            e.xclient.data.l[2] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            break;
        }
        case FullScreenState: { 
            e.xclient.data.l[0] = _NET_WM_STATE_REMOVE;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
            e.xclient.data.l[2] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[0] = _NET_WM_STATE_ADD;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            break;
        }
        default: {
            syserr("Invalid desired_state");
            break;
        }
    }
    XSync(wd->display, False);
}

void doconfig(wbp w, int status)
{
    wsp ws = w->window;
    wdp wd = ws->display;

    if (ws->win) {
        if (status & (C_POS | C_SIZE | C_MINSIZE | C_MAXSIZE | C_RESIZE)) {
            if (status != C_POS) {
                XSizeHints size_hints;
                size_hints.flags = PMinSize | PMaxSize;
                if (ws->resizable) {
                    size_hints.min_width = ws->minwidth;
                    size_hints.min_height = ws->minheight;
                    size_hints.max_width = ws->maxwidth;
                    size_hints.max_height = ws->maxheight;
                }
                else {
                    size_hints.min_width = size_hints.max_width = ws->width;
                    size_hints.min_height = size_hints.max_height = ws->height;
                }
                XSetWMNormalHints(wd->display, ws->win, &size_hints);
            }

            switch (status & (C_POS|C_SIZE)) {
                case C_POS: {
                    XMoveWindow(wd->display, ws->win, ws->x, ws->y);
                    break;
                }
                case C_SIZE: {
                    XResizeWindow(wd->display, ws->win, ws->width, ws->height);
                    break;
                }
                case C_POS|C_SIZE: {
                    XMoveResizeWindow(wd->display, ws->win, ws->x, ws->y, ws->width, ws->height);
                    break;
                }
            }
        }
    }
    if (status & C_SIZE)
        resizepixmap(w);
}

convert_to_macro(INT32)

/*
 * data is a safe pointer into a frame.
 */
int sendselectionresponse(wbp w, word requestor, char *property, char *selection, char *target, word time, dptr data)
{
    Atom property_atom, target_atom, selection_atom, target_list[32];
    XEvent theevent;
    struct lgstate state;
    tended struct b_lelem *le;
    tended char *cstr_target;
    int target_cnt = 1;
    wsp ws = w->window;
    wdp wd = ws->display;

    if (selection_debug)
        printf("sendselectionresponse:\n\trequestor=%lx "
               "property=%s target=%s selection=%s time=%ld\n",
               (long)requestor, property, target, selection, (long)time);

    property_atom = XInternAtom(wd->display, property, False);
    target_atom = XInternAtom(wd->display, target, False);
    selection_atom = XInternAtom(wd->display, selection, False);

    if (target_atom == ATOM(wd, TARGETS)) {
        if (!is:list(*data))
            ReturnErrVal(108, *data, Error);
        target_list[0] = ATOM(wd, TARGETS);
        for (le = lgfirst(&ListBlk(*data), &state); le;
             le = lgnext(&ListBlk(*data), &state, le)) {
            if (!cnv:C_string(le->lslots[state.result], cstr_target))
                ReturnErrVal(148, le->lslots[state.result], Error);
            target_list[target_cnt++] = XInternAtom(wd->display, cstr_target, False);
            if (selection_debug)
                printf("\tAdding target:%s\n", cstr_target);
        }
        XChangeProperty(wd->display,
                        requestor,
                        property_atom,
                        XA_ATOM,
                        32,
                        PropModeReplace,
                        (unsigned char *)target_list,
                        target_cnt);
        theevent.xselection.property = property_atom;
    } else if (is:null(*data)) {
        /* Can't handle this target type */
        if (selection_debug)
            printf("\tSetting property to None\n");
        theevent.xselection.property = None;
    } else if (convert_target(wd, target_atom) == XA_INTEGER) {
        INT32 i32;
        long l;
        if (!cnv:integer(*data, *data))
            ReturnErrVal(101, *data, Error);
        if (!convert_to_INT32(data, &i32))
            /* the convert function has set the error values itself */
            return Error;
        /* The data is sent as a long regardless of whether that is 32 or 64 bits. */
        l = i32;
        if (selection_debug)
            printf("\tSetting property to INTEGER data %ld\n", l);
        XChangeProperty(wd->display,
                        requestor,
                        property_atom,
                        XA_INTEGER,
                        32,
                        PropModeReplace,
                        (unsigned char *)&l,
                        1);
        theevent.xselection.property = property_atom;
    } else {
        if (!cnv:string(*data, *data))
            ReturnErrVal(103, *data, Error);
        if (selection_debug)
            printf("\tSetting property to %d bytes of data\n", (int)StrLen(*data));
        XChangeProperty(wd->display,
                        requestor,
                        property_atom,
                        target_atom,
                        8,
                        PropModeReplace,
                        (unsigned char *)StrLoc(*data),
                        StrLen(*data));
        theevent.xselection.property = property_atom;
    }

    theevent.type = SelectionNotify;
    theevent.xselection.serial = 0; /*event.xselectionrequest.serial;*/
    theevent.xselection.send_event = True;
    theevent.xselection.requestor = requestor;
    theevent.xselection.selection = selection_atom;
    theevent.xselection.target = target_atom;
    theevent.xselection.time = time;

    XSendEvent(wd->display,
               requestor,
               False, NoEventMask, &theevent);

    return Succeeded;
}

int ownselection(wbp w, char *selname)
{
    Atom selection;
    Window curr;
    wsp ws = w->window;
    wdp wd = ws->display;

    CheckUnhidden(ws);

    selection = XInternAtom(wd->display, selname, False);
    curr = XGetSelectionOwner(wd->display, selection);

    /* Check for no change in selection */
    if (curr == ws->win) {
        if (selection_debug)
            printf("Ownership of selection %s retained by %lx\n", 
                   atom_fmt(ws, selection),
                   (long)ws->win);
    } else {
        if (selection_debug)
            printf("Owner of selection %s set from %lx -> %lx\n", 
                   atom_fmt(ws, selection),
                   (long)curr,
                   (long)ws->win);

        /*
         * X doesn't send a SelectionClear event to us when the selection
         * changes between our own windows, so if the current owner is one
         * our windows, send it a "clear" message.
         */
        if (curr) {
            wsp x;
            for (x = wd->vwstates; x; x = x->vnext) {
                if (x->win == curr) {
                    tended struct descrip tmp;
                    if (selection_debug)
                        printf("Enqueueing artificial SELECTIONCLEAR to current owner %lx\n", (long)curr);
                    MakeInt(SELECTIONCLEAR, &tmp);
                    list_put(&x->listp, &tmp);
                    get_atom_descriptor(x, selection, &tmp);
                    list_put(&x->listp, &tmp);
                    break;
                }
            }
        }
    }
    XSetSelectionOwner(wd->display, 
                       selection,
                       ws->win,
                       CurrentTime);

    return Succeeded;
}

int requestselection(wbp w, char *selname, char *targetname)
{
    Atom selection, target, property;
    wsp ws = w->window;
    wdp wd = ws->display;
    CheckUnhidden(ws);
    selection = XInternAtom(wd->display, selname, False);
    target = XInternAtom(wd->display, targetname, False);
    /* 
     * Use 8 property atoms to allow multiple concurrent requests
     * without the results getting mixed up.  Obviously this isn't
     * perfect, but is better than nothing.
     */
    property = wd->atoms[ATOM__OBJECTICON_PROP0 + (ws->propcount++) % 8];
    if (selection_debug)
        printf("getselectioncontent: calling XConvertSelection selection=%s target=%s property=%s requestor=%lx\n",
               atom_fmt(ws, selection),
               atom_fmt(ws, target),
               atom_fmt(ws, property),
               (long)ws->win);

    XConvertSelection(wd->display,
                      selection, 
                      target, 
                      property,
                      ws->win,
                      CurrentTime);

    return Succeeded;
}

int warppointer(wbp w, int x, int y)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    XWarpPointer(ws->display->display, None, ws->win, 0,0,0,0, x, y);
    return Succeeded;
}

static void apply_windowlabel(wsp ws)
{
    wdp wd = ws->display;
    XChangeProperty(wd->display, ws->win,
                    ATOM(wd, _NET_WM_NAME), 
                    ATOM(wd, UTF8_STRING),
                    8,
                    PropModeReplace, 
                    (unsigned char *)StrLoc(UcsBlk(ws->windowlabel).utf8),
                    StrLen(UcsBlk(ws->windowlabel).utf8));
}

static void apply_windowicon(wsp ws)
{
    wdp wd = ws->display;
    XChangeProperty(wd->display, ws->win,
                    ATOM(wd, _NET_WM_ICON), 
                    XA_CARDINAL, 
                    32,
                    PropModeReplace, 
                    (unsigned char *)ws->icondata,
                    ws->iconlen);
}

int setwindowlabel(wbp w, dptr val)
{
    wsp ws = w->window;
    ws->windowlabel = *val;
    if (ws->win)
        apply_windowlabel(ws);
    return Succeeded;
}

static void synch_cursor(wsp ws)
{
    XDefineCursor(ws->display->display, ws->win, ws->cursor->shared_cursor->cursor);
}

/*
 * setpointer() - define a mouse pointer shape
 */
int setpointer(wbp w, char *val)
{
    struct wcursor *c;
    wsp ws = w->window;
    c = lookup_wcursor(ws->display, val);
    if (!c)
        return Failed;
    ws->cursor = c;
    if (ws->win)
        synch_cursor(ws);
    return Succeeded;
}

/*
 * setdrawop() - set the drawing operation
 */
int setdrawop(wbp w, char *val)
{
    stringint *e;
    wcp wc = w->context;
    e = stringint_lookup(drawops, val);
    if (!e)
        return Failed;
    wc->drawop = e;
    return Succeeded;
}

wbp clonewindow(wbp w)
{
    wbp w2;
    w2 = alcwbinding(w->window->display);
    w2->window = linkwindow(w->window);
    w2->context = clonecontext(w->context);
    return w2;
}

wbp couplewindows(wbp w1, wbp w2)
{
    wbp w3;
    if (w1->window->display != w2->context->display) {
        LitWhy("Can't couple between different displays");
        return 0;
    }
    w3 = alcwbinding(w1->window->display);
    w3->window = linkwindow(w1->window);
    w3->context = linkcontext(w2->context);
    return w3;
}

static void clip(wbp w)
{
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;
    XRectangle rec;
    if (wc->clipw >= 0) {
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XRenderSetPictureClipRectangles(wd->display,
                                        ws->ppic,
                                        0, 0, &rec, 1);
        if (ws->wpic)
            XRenderSetPictureClipRectangles(wd->display,
                                             ws->wpic,
                                             0, 0, &rec, 1);
    } else
        no_clip(ws, 1);
}

static void no_clip(wsp ws, int and_win)
{
    XRenderPictureAttributes attr;
    wdp wd = ws->display;
    attr.clip_mask = None;
    XRenderChangePicture(wd->display,
                         ws->ppic,
                         CPClipMask,
                         &attr);
    if (and_win && ws->wpic)
        XRenderChangePicture(wd->display,
                             ws->wpic,
                             CPClipMask,
                             &attr);
}

char *getcanvas(wbp w)
{
    char *v = stringint_int2str(canvastypes, w->window->state);
    if (!v)
        syserr("Invalid value of state");
    return v;
}

/*
 *  Set the canvas type
 */
int setcanvas(wbp w, char *s)
{
    stringint *e;
    wsp ws = w->window;
    wdp wd = ws->display;
    e = stringint_lookup(canvastypes, s);
    if (!e)
        return Failed;
    if (e->i == ws->state)
        return Succeeded;

    if (!ws->win) {
        if (e->i != HiddenState) {
            ws->state = e->i;
            wmap(w);
        }
        return Succeeded;
    }

    switch (e->i) {
        case IconicState: {
            if (ws->state == RootState || ws->state == PopupState)
                return Failed;
            if (ws->state == WithdrawnState) {
                XWMHints wmhints;
                wmhints.flags = StateHint;
                wmhints.initial_state = IconicState;
                XSetWMHints(wd->display, ws->win, &wmhints);
                XMapWindow(wd->display, ws->win);
            } else
                XIconifyWindow(wd->display, ws->win, DefaultScreen(wd->display));
            break;
        }

        case WithdrawnState: {
            if (ws->state == RootState || ws->state == PopupState)
                return Failed;
            XWithdrawWindow(wd->display, ws->win, DefaultScreen(wd->display));
            break;
        }

        case NormalState:
        case MaximizedState:
        case FullScreenState: {
            if (ws->state == RootState || ws->state == PopupState)
                return Failed;
            if (ws->state == WithdrawnState) {
                XWMHints wmhints;
                wmhints.flags = StateHint;
                wmhints.initial_state = NormalState;
                XSetWMHints(wd->display, ws->win, &wmhints);
            }
            /*
             * Use XMapRaised to try to give more consistent results
             * (kwin will restore an iconified window to its previous
             * position in the stack, whilst fvwm puts it to the top)
             */
            XMapRaised(wd->display, ws->win);
            synch_net_wm_state(ws, e->i);
            break;
        }

        case PopupState:
        case RootState:
            return Failed;

        case HiddenState: {
            close_screen_win(ws);
            break;
        }
        default:
            syserr("Unexpected canvas state");
    }
    return Succeeded;
}

/*
 * Set the context's line style by name.
 */
int setlinestyle(wbp w, char *val)
{
    stringint *e;
    wcp wc = w->context;
    e = stringint_lookup(linestyles, val);
    if (!e)
        return Failed;
    wc->linestyle = e;
    return Succeeded;
}

/*
 * Set the context's line width
 */
int setlinewidth(wbp w, double linewid)
{
    wcp wc = w->context;
    wc->linewidth = linewid;
    return Succeeded;
}

double getlinewidth(wbp w)
{
    return w->context->linewidth;
}

/*
 * Set the context's foreground color by name.
 */
int setfg(wbp w, char *s)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(s, &r, &g, &b, &a))
        return Failed;
    unlink_sharedcolor(wc->fg);
    wc->fg = new_sharedcolor(wc->display, s, r, g, b, a);
    return Succeeded;
}

/*
 * Set the window context's background color by name.
 */
int setbg(wbp w, char *s)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(s, &r, &g, &b, &a))
        return Failed;
    unlink_sharedcolor(wc->bg);
    wc->bg = new_sharedcolor(wc->display, s, r, g, b, a);
    return Succeeded;
}

char *getdisplay(wbp w)
{
    char *tmp;
    wdp wd = w->window->display;
    if (!strcmp(wd->name, "")) {
        if ((tmp = getenv("DISPLAY")) != NULL)
            return tmp;
        else
            return "";
    }
    else return wd->name;
}

int getdisplaysize(wbp w, int *width, int *height)
{
    *width = GetWidth(w->window->display);
    *height = GetHeight(w->window->display);
    return Succeeded;
}

int getdepth(wbp w, int *res)
{
    *res = GetDepth(w->window->display);
    return Succeeded;
}

/*
 * getpos() - update the window state's notion of its current position
 */
int getpos(wbp w)
{
    Window garbage1, garbage2;
    int root_x, root_y, win_x, win_y;
    unsigned int key_buttons;
    wsp ws = w->window;
    wdp wd = ws->display;
    CheckUnhidden(ws);
    /*
     * This call is made because it is guaranteed to generate
     * a synchronous request of the server, not just ask Xlib
     * what the window position was last it knew.
     */
    if (XQueryPointer(wd->display, ws->win, &garbage1, &garbage2,
                      &root_x, &root_y, &win_x, &win_y, &key_buttons) == True) {
        ws->x = root_x - win_x;
        ws->y = root_y - win_y;
    }
    return Succeeded;
}

char *getfg(wbp w)
{
    return w->context->fg->name;
}

char *getbg(wbp w)
{
    return w->context->bg->name;
}

char *getlinestyle(wbp w)
{
    return w->context->linestyle->s;
}

char *getpointer(wbp w)
{
    return w->window->cursor->name;
}

char *getdrawop(wbp w)
{
    return w->context->drawop->s;
}

int grabpointer(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    if (XGrabPointer(ws->display->display, ws->win,False, 
                     ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | PointerMotionMask,
                     GrabModeAsync, GrabModeAsync, None, None, CurrentTime) != GrabSuccess) {
        LitWhy("XGrabPointer failed");
        return Failed;
    }
    return Succeeded;
}

int ungrabpointer(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    XUngrabPointer(ws->display->display, CurrentTime);
    return Succeeded;
}

int grabkeyboard(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    if (XGrabKeyboard(ws->display->display, ws->win,False, 
                      GrabModeAsync, GrabModeAsync, CurrentTime) != GrabSuccess) {
        LitWhy("XGrabKeyboard failed");
        return Failed;
    }
    return Succeeded;
}

int ungrabkeyboard(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    XUngrabKeyboard(ws->display->display, CurrentTime);
    return Succeeded;
}

/*
 * Set the window's font by name.
 */
int setfont(wbp w, char *s)
{
    wfp tmp;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;

    tmp = loadfont(wd, s);
    if (!tmp)
        return Failed;
    wc->font = tmp;
    return Succeeded;
}

void synch_pix_and_win(wsp ws, int x, int y, int w, int h)
{
    if (ws->win) {
        no_clip(ws, 1);
        pix_to_win(ws, x, y, w, h);
    }
}

static void pix_to_win(wsp ws, int x, int y, int w, int h)
{
    wdp wd = ws->display;
    if (ws->win)
        XRenderComposite(wd->display, PictOpSrc, ws->ppic, 0, ws->wpic,
                         x, y, 0, 0, x, y, w, h);
}

/*
 * callback procedures
 */

static void handle_exposures(wsp ws, XExposeEvent *event)
{
    synch_pix_and_win(ws, event->x, event->y, event->width, event->height);
}

/*
 * resizepixmap(w,width,height) -- ensure w's backing pixmap is at least
 * width x height pixels.
 *
 * Resizes the backing pixmap, if needed.  Called when X resize events
 * arrive, as well as when programs make explicit resize requests.
 *
 */
static void resizepixmap(wbp w)
{
    Pixmap p;
    Picture pp;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;
    int old_w, old_h;
    XRenderPictureAttributes attr;

    if ((ws->width == ws->pixwidth) && (ws->height == ws->pixheight))
        return;

    old_w = ws->pixwidth;
    old_h = ws->pixheight;
    ws->pixheight = Max(1, ws->height);
    ws->pixwidth  = Max(1, ws->width);
    p = XCreatePixmap(wd->display, GetRoot(wd), ws->pixwidth, ws->pixheight, 32);
    attr.poly_edge = PolyEdge;
    pp = XRenderCreatePicture(wd->display, p, wd->pixfmt, CPPolyEdge, &attr);
    /* Fill with bg colour */
    XRenderFillRectangle(wd->display,
                         PictOpSrc,
                         pp,
                         &wc->bg->color,
                         0, 0, ws->pixwidth, ws->pixheight);

    no_clip(ws, 0);
    XRenderComposite(wd->display, PictOpSrc, ws->ppic, 0, pp,
                     0,0,0,0,0,0, old_w, old_h);

    XFreePixmap(wd->display, ws->pix);	/* free old pixmap */
    XRenderFreePicture(wd->display, ws->ppic);
    ws->pix = p;
    ws->ppic = pp;
    if (ws->pxft) {
        XftDrawDestroy(ws->pxft);
        ws->pxft = NULL;
    }
}

static void synch_state(wsp ws)
{
    Atom actual_type;
    int actual_format;
    unsigned long bytes_after, nitems;
    unsigned char *prop;
    unsigned long state;
    wdp wd = ws->display;

    if (ws->win == 0) {
        ws->state = HiddenState;
        return;
    }

    if (ws->state == PopupState || ws->state == RootState)
        return;

    if (XGetWindowProperty(wd->display,
                           ws->win,
                           ATOM(wd, WM_STATE),
                           0,
                           1,
                           False,
                           ATOM(wd, WM_STATE),
                           &actual_type,
                           &actual_format,
                           &nitems,
                           &bytes_after,
                           &prop) != Success)
        return;
    
    if (actual_type == ATOM(wd, WM_STATE))
        state = *((unsigned long *)prop);
    else 
        /* WM_STATE absent => withdrawn */
        state = WithdrawnState;

    if (prop) XFree(prop);

    if (state == WithdrawnState || state == IconicState) {
        ws->state = state;
        return;
    }

    /* Normal state, so check if maximized, etc */

    if (XGetWindowProperty(wd->display,
                           ws->win,
                           ATOM(wd, _NET_WM_STATE),
                           0,
                           8192,
                           False,
                           XA_ATOM,
                           &actual_type,
                           &actual_format,
                           &nitems,
                           &bytes_after,
                           &prop) != Success)
        return;

    if (actual_type == XA_ATOM) {
        int i, max = 0;
        Atom *atoms = (Atom *)prop;
        for (i = 0; i < nitems; ++i) {
            if (atoms[i] == ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT))
                max |= 1;
            else if (atoms[i] == ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ))
                max |= 2;
            else if (atoms[i] == ATOM(wd, _NET_WM_STATE_FULLSCREEN))
                max |= 4;
        }
        if (max == 3)
            ws->state = MaximizedState;
        else if (max == 4)
            ws->state = FullScreenState;
        else
            ws->state = NormalState;
    } else
        /* Unexpected, assume normal state */
        ws->state = NormalState;

    if (prop) XFree(prop);
}

static void handle_property(wsp ws, XPropertyEvent *event)
{
    if (event->atom == ATOM(ws->display, WM_STATE) ||
        event->atom == ATOM(ws->display, _NET_WM_STATE))
        synch_state(ws);
}

/*
 * Resize operations are made as painless as possible, but the
 * user program is informed anyhow.  The integer coordinates are
 * the new size of the window, in pixels.
 */
static void handle_config(wsp ws, XConfigureEvent *event)
{
    /*
     * Update X-Icon's information about the window's configuration
     */

    ws->x = event->x;
    ws->y = event->y;

    /*
     * If this was not a resize, drop it
     */
    if ((event->width == ws->width) && (event->height == ws->height))
        return;

    ws->width = event->width;
    ws->height = event->height;

    resizepixmap(findwbp(ws));

    qeventcode(ws, WINDOWRESIZED);
}

static int make_mod(unsigned int state)
{
    int x = 0;

    if (state & ShiftMask)
        x |= MOD_SHIFT;
    if (state & LockMask)
        x |= MOD_LOCK;
    if (state & ControlMask)
        x |= MOD_CTRL;
    if (state & Mod1Mask)
        x |= MOD_META;
    if (state & Mod2Mask)
        x |= MOD_META2;
    if (state & Mod3Mask)
        x |= MOD_META3;
    if (state & Mod4Mask)
        x |= MOD_META4;
    if (state & Mod5Mask)
        x |= MOD_META5;
    return x;
}

static void handle_crossing(wsp ws, XCrossingEvent *event)
{
    struct descrip d;
    if (event->mode != NotifyNormal)
        return;
    MakeInt(event->type == EnterNotify ? MOUSEENTERED:MOUSEEXITED, &d);
    qevent(ws, &d, event->x, event->y,
           (uword)event->time, 
           make_mod(event->state));
}

/*
 * Queue up characters for keypress events.
 */
static void handle_keypress(wsp ws, XKeyEvent *event)
{
    int i, j, fl;
    char s[10];
    tended struct descrip d;
    KeySym k;

    fl = make_mod(event->state);
    if (event->type == KeyRelease)
        fl |= MOD_RELEASE;
    /* First try to convert the event to a simple char string, and a KeySym */
    i = XLookupString(event, s, sizeof(s), &k, NULL);
    if (i > 0) {
        /* Found a char string, so generate string event(s) */
        StrLen(d) = 1;
        for (j = 0; j < i; j++) {
            StrLoc(d) = &allchars[s[j] & 0xFF];
            qevent(ws, &d, event->x, event->y,
                   (uword)event->time, fl);
        }
        return;
    }

    /* Second try is to convert to a unicode char; if found generate a 1-char
     * ucs/string */
    i = convert_KeySym_to_code_point(k);
    if (i > 0) {
        if (i < 256) {
            StrLen(d) = 1;
            StrLoc(d) = &allchars[i];
        } else {
            d.dword = D_Ucs;
            BlkLoc(d) = (union block *)make_one_char_ucs_block(i);
        }
        qevent(ws, &d, event->x, event->y,
               (uword)event->time, fl);
        return;
    }

    /* Neither of those worked, so it must be a non-character key (cursor key, etc).
     * So just generate the numerical value of the KeySym as an integer.
     */
    MakeInt(k, &d);
    qevent(ws, &d, event->x, event->y,
           (uword)event->time, fl);
}

#include "rxkeysyms.ri"

/*
 * Handle button presses and drag events.  In the case of drags, we should
 * really be looking at an XMotionEvent instead of an XButtonEvent, but
 * the structures are identical up to the button field (which we do not
 * examine for drag events).  Mouse coordinates are queued up after the event.
 */
static void handle_mouse(wsp ws, XButtonEvent *event)
{
    int state = 0;
    if (event->state & Button1Mask) state |= 1;
    if (event->state & Button2Mask) state |= 2;
    if (event->state & Button3Mask) state |= 4;
    if (event->state & Button4Mask) state |= 8;
    if (event->state & Button5Mask) state |= 16;
    switch (event->type) {
        case ButtonPress: {
            switch (event->button) {
                case Button1: state |= 1; break;
                case Button2: state |= 2; break;
                case Button3: state |= 4; break;
                case Button4: state |= 8; break;
                case Button5: state |= 16; break;
            }
            break;
        }
        case ButtonRelease: {
            switch (event->button) {
                case Button1: state &= ~1; break;
                case Button2: state &= ~2; break;
                case Button3: state &= ~4; break;
                case Button4: state &= ~8; break;
                case Button5: state &= ~16; break;
            }
            break;
        }
    }
    qmouseevents(ws, state, 
                 event->x, event->y, 
                 (uword)event->time, 
                 make_mod(event->state));
}

static void semi(struct point *pts, int *npts, int maxpts,
                 double cx, double cy, double rx, double ry, double a1, double a2,
                 int xfrom, int xto, int xby, double x0ang, double xnegang, double xposang)
{
    int x1;
    double y1, th;
    if (a1 > x0ang + Pi/2) return;
    if (a1 + a2 < x0ang - Pi/2) return;
    x1 = xfrom;
    for(;;) {
        if ((xby > 0 && x1 > xto) || (xby < 0 && x1 < xto)) break;
        y1 = -sqrt(1 - pow(x1/rx, 2)) * ry * xby;
        if (x1 == 0)
            th = x0ang;
        else if (x1 < 0)
            th = atan(y1/x1) + xnegang;
        else
            th = atan(y1/x1) + xposang;
        if (th > a1+a2) return;
        if (a1 <= th && *npts < maxpts) {
            pts[*npts].x = cx + x1;
            pts[*npts].y = cy + y1;
            ++*npts;
        }
        x1 += xby;
   }
}

void drawarc(wbp w, double cx, double cy, double rx, double ry, double angle1, double angle2)
{
    struct point *pts;
    int maxpts, npts;
    maxpts = 4 * (rx + 1) + 4;
    MemProtect(pts = malloc(maxpts * sizeof(struct point)));
    npts = 0;
    semi(pts, &npts, maxpts, cx, cy, rx, ry, angle1, angle2,  rx,  -rx, -1, 0.5*Pi, Pi,   0);
    semi(pts, &npts, maxpts, cx, cy, rx, ry, angle1, angle2, -rx,   rx,  1, 1.5*Pi, Pi,   2*Pi);
    semi(pts, &npts, maxpts, cx, cy, rx, ry, angle1, angle2,  rx,  -rx, -1, 2.5*Pi, 3*Pi, 2*Pi);
    semi(pts, &npts, maxpts, cx, cy, rx, ry, angle1, angle2, -rx,   rx,  1, 3.5*Pi, 3*Pi, 4*Pi);
    if (angle2 == 2 * Pi && npts < maxpts)
        pts[npts++] = pts[0];  /* Ensure drawlines recognizes a closed arc */
    drawlines(w, pts, npts);
    free(pts);
}

void fillarc(wbp w, double cx, double cy, double rx, double ry, double angle1, double angle2)
{ 
    wsp ws = w->window;
    wdp wd = ws->display;
    wcp wc = w->context;
    XTrapezoid traps[32];
    int ntraps, has_wedge;

    has_wedge = (angle1 != 0 || angle2 != 2 * Pi);

    if (has_wedge || needmask(wc, 0)) {
        Picture mask;
        int x, y, width, height;
        double h2, w2;

        /*
         * calculate width and height for the masks, and their x, y
         * position to draw onto the screen.  Note that width and
         * height are even; this avoids any antialiasing relics when
         * joining trapezoids and rectangles in the wedge mask.
         */
        x = floor(cx - rx);
        y = floor(cy - ry);
        width = 2 * ceil(cx - x);
        height = 2 * ceil(cy - y);
        h2 = height / 2.0;
        w2 = width / 2.0;
        /* printf("cx,cy=%f,%f rx,ry=%f,%f  ->   x,y=%d,%d   width.height=%d,%d   w2,h2=%f,%f\n",cx,cy,rx,ry,x,y,width,height,w2,h2); */

        ntraps = make_ellipse(cx - x, cy - y,    /* centre */
                              rx, ry,            /* x/y radius */
                              ElemCount(traps), traps);
        mask = getmask(wd, width, height);
        XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  mask, 0, 0, 0, traps, ntraps);
        if (has_wedge) {
            XTrapezoid trap;
            Picture wedge1, wedge2;
            double x1, x2, a1, a2, op;
            if (angle1 + angle2 < 2 * Pi) {
                /* Calculate a wedge to include */
                a1 = angle1;
                a2 = angle1 + angle2;
                op = PictOpInReverse;
            } else {
                /* Calculate a wedge to exclude */
                a1 = angle1 + angle2 - 2 * Pi;
                a2 = angle1;
                op = PictOpOutReverse;
            }

            /* wedge1 is everything swept forward clockwise from a2 to
             * 3pm.  wedge2 is the area from a1 swept back
             * anticlockwise to 3pm; The intersection of the two gives
             * the wedge to either include or exclude.
             */
            wedge1 = getmask(wd, width, height);
            wedge2 = getmask(wd, width, height);
            if (NearZero(a1 - 2*Pi, 1)) ;
            else if (NearZero(a1, 1))
                XRenderFillRectangle(wd->display, PictOpOver, wedge1, &wd->white->color, 0, 0, width ,height); 
            else if (NearZero(a1 - Pi, 1))
                XRenderFillRectangle(wd->display, PictOpOver, wedge1, &wd->white->color, 0, 0, width ,h2);
            else if (a1 > Pi) {
                x1 = w2 - h2 / tan(a1 - Pi);
                trap = trapezoid(0,x1,width,  h2, w2, width);
                XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  wedge1, 0, 0, 0, &trap, 1);
            } else {
                x1 = w2 - h2 * tan(a1 - Pi/2);
                trap = trapezoid(0,0,width-x1, height,0,x1);
                XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  wedge1, 0, 0, 0, &trap, 1);
                XRenderFillRectangle(wd->display, PictOpOver, wedge1, &wd->white->color, 0, 0, width ,h2);
            }

            if (NearZero(a2, 1)) ;
            else if (NearZero(a2 - 2*Pi, 1))
                XRenderFillRectangle(wd->display, PictOpOver, wedge2, &wd->white->color, 0, 0, width ,height); 
            else if (NearZero(a2 - Pi, 1))
                XRenderFillRectangle(wd->display, PictOpOver, wedge2, &wd->white->color, 0, h2, width ,h2); 
            else if (a2 > Pi) {
                x2 = w2 - h2 / tan(a2 - Pi);
                trap = trapezoid(0,0,x2,  height, 0, width-x2);
                XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  wedge2, 0, 0, 0, &trap, 1);
                XRenderFillRectangle(wd->display, PictOpOver, wedge2, &wd->white->color, 0, h2, width, h2);
            } else {
                x2 = w2 - h2 * tan(a2 - Pi/2);
                trap = trapezoid(h2, w2, width,  height, x2, width);
                XRenderCompositeTrapezoids(wd->display, PictOpOver, wd->white->brush,  wedge2, 0, 0, 0, &trap, 1);
            }
            XRenderComposite(wd->display,
                             op,
                             wedge1,          /* src */
                             wedge2,         /* mask */
                             mask,           /* dest */
                             0,0,            /* src x,y */
                             0,0,            /* mask x,y */
                             0, 0,           /* dst x,y */
                             width, height);

            XRenderFreePicture(wd->display, wedge1);
            XRenderFreePicture(wd->display, wedge2);
        }
        clip(w);
        maskpic2(w, mask, x, y, width, height);
        XRenderFreePicture(wd->display, mask);
    } else {
        clip(w);
        ntraps = make_ellipse(cx, cy,
                              rx, ry,
                              ElemCount(traps), traps);
        XRenderCompositeTrapezoids(wd->display, 
                                   wc->drawop->i,
                                   get_draw_picture(wc),
                                   ws->ppic, 
                                   0, 0, 0,
                                   traps, ntraps);
        pix_to_win(ws, cx - rx - 2, cy - ry - 2, 2 * rx + 4, 2 * ry + 4);
    }
}

/*
 * The orientation of the computed corner points is always the same
 * (p0 and q0 are the given input points), as follows :-
 *  
 *   p2 -------------------- q2      ^
 *   |                       |       |
 *   p0       -->--          q0   linewidth
 *   |                       |       |
 *   p1 ---------------------q1      v
 *
 *   <-------- len ---------->
 */

static void getlineinfo(wcp wc, XPointDouble *p0, XPointDouble *q0, struct lineinfo *res)
{
    double ex, ey;
    res->dx = q0->x - p0->x;
    res->dy = q0->y - p0->y;
    res->len = hypot(res->dx, res->dy);
    ex = (wc->linewidth * res->dy) / (2 * res->len);
    ey = -(wc->linewidth * res->dx) / (2 * res->len);
    res->p1 = doublept(p0->x - ex ,p0->y - ey);
    res->p2 = doublept(p0->x + ex, p0->y + ey);
    res->q1 = doublept(q0->x - ex ,q0->y - ey);
    res->q2 = doublept(q0->x + ex, q0->y + ey);
}

static void calc_extent(wcp wc, struct lineinfo *lis, int n, int closed, int *x, int *y, int *width, int *height)
{
    int i;
    double x1, x2, y1, y2;
    for (i = 0; i < n; ++i) {
        struct lineinfo *li = &lis[i]; 
        if (i == 0) {
            x1 = x2 = li->p1.x;
            y1 = y2 = li->p1.y;
        } else {
            if (li->p1.x < x1) x1 = li->p1.x;
            if (li->p1.x > x2) x2 = li->p1.x;
            if (li->p1.y < y1) y1 = li->p1.y;
            if (li->p1.y > y2) y2 = li->p1.y;
        }
        if (li->p2.x < x1) x1 = li->p2.x;
        if (li->p2.x > x2) x2 = li->p2.x;
        if (li->p2.y < y1) y1 = li->p2.y;
        if (li->p2.y > y2) y2 = li->p2.y;
        if (li->q1.x < x1) x1 = li->q1.x;
        if (li->q1.x > x2) x2 = li->q1.x;
        if (li->q1.y < y1) y1 = li->q1.y;
        if (li->q1.y > y2) y2 = li->q1.y;
        if (li->q2.x < x1) x1 = li->q2.x;
        if (li->q2.x > x2) x2 = li->q2.x;
        if (li->q2.y < y1) y1 = li->q2.y;
        if (li->q2.y > y2) y2 = li->q2.y;
    }
    x1 -= wc->linewidth / 2.0;
    y1 -= wc->linewidth / 2.0;
    x2 += wc->linewidth / 2.0;
    y2 += wc->linewidth / 2.0;
    range_extent(x1, y1, x2, y2, x, y, width, height);
}

static XPointDouble doublept(double x, double y)
{
    XPointDouble t;
    t.x = x;
    t.y = y;
    return t;
}

static XPointDouble midpt(XPointDouble p1, XPointDouble p2)
{
    XPointDouble t;
    t.x = (p1.x + p2.x) / 2.0;
    t.y = (p1.y + p2.y) / 2.0;
    return t;
}

static XTriangle triangle(double x1, double y1, double x2, double y2, double x3, double y3)
{
    XTriangle t;
    t.p1.x = XDoubleToFixed(x1);
    t.p1.y = XDoubleToFixed(y1);
    t.p2.x = XDoubleToFixed(x2);
    t.p2.y = XDoubleToFixed(y2);
    t.p3.x = XDoubleToFixed(x3);
    t.p3.y = XDoubleToFixed(y3);
    return t;
}

static XTrapezoid trapezoid(double top, double x1, double x2, double bottom, double x3, double x4)
{
    XTrapezoid t;
    t.top = XDoubleToFixed(top);
    t.left.p1.x = XDoubleToFixed(x1);
    t.left.p1.y = t.top;
    t.right.p1.x = XDoubleToFixed(x2);
    t.right.p1.y = t.top;
    t.bottom = XDoubleToFixed(bottom);
    t.left.p2.x = XDoubleToFixed(x3);
    t.left.p2.y = t.bottom;
    t.right.p2.x = XDoubleToFixed(x4);
    t.right.p2.y = t.bottom;
    return t;
}

static void traps(wbp w,
                  int op,
                  Picture src,
                  Picture dest,
                  XPointDouble p1, double top, double x1, double x2,  double bottom, double x3, double x4, XPointDouble p2)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    XTriangle tri[2];
    XTrapezoid trap;
    top = round(top);
    bottom = round(bottom);
    tri[0] = triangle(p1.x,p1.y, x1,top, x2,top);
    tri[1] = triangle(p2.x,p2.y, x3,bottom, x4,bottom);
    XRenderCompositeTriangles(wd->display, op, src, dest, 0,0,0, tri, 2);
    trap = trapezoid(top, x1, x2, bottom, x3, x4);
    XRenderCompositeTrapezoids(wd->display, op, src,  dest, 0, 0, 0, &trap, 1);
}

static int make_ellipse(double cx, double cy, double rx, double ry, int max_ntraps, XTrapezoid traps[])
{
    int n=0, k=0, y1, y2, w1, w2;
    double L, th;
    max_ntraps /= 2;
    while(k < max_ntraps) {
        th = (Pi/2)*k/max_ntraps;
        L = 1.0 / hypot(cos(th)/ry, sin(th)/rx);

        y1 = (int)(L*cos(th));
        w1 = sqrt(L*L - y1*y1);
        do {
            k++;
            th = (Pi/2)*k/max_ntraps;
            L = 1.0/hypot(cos(th)/ry, sin(th)/rx);
            y2=(int)(L*cos(th));
        } while(k < max_ntraps && y1==y2);
        if(y1 == y2)
            break;

        w2 = sqrt(L*L - y2*y2);
        traps[n] = trapezoid(round(cy-y1), cx-w1, cx+w1,
                             round(cy-y2), cx-w2, cx+w2);
        n++;
        traps[n] = trapezoid(round(cy+y2), cx-w2, cx+w2,
                             round(cy+y1), cx-w1, cx+w1);
        n++;
    }
    return n;
}

static int make_circle(double cx, double cy, double radius, int max_ntraps, XTrapezoid traps[])
{
    return make_ellipse(cx, cy, radius, radius, max_ntraps, traps);
}

static void drawjoin(wbp w, 
                     int op,
                     Picture src,
                     Picture dest,
                     XPointDouble r)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    wcp wc = w->context;
    XTrapezoid traps[8];
    int ntraps;
    ntraps = make_circle(r.x,
                         r.y,
                         wc->linewidth / 2.0,
                         ElemCount(traps), traps);
    XRenderCompositeTrapezoids(wd->display, op, src,  dest, 0, 0, 0, traps, ntraps);
}


static void drawlineinfo(wbp w,
                         int op,
                         Picture src,
                         Picture dest,
                         struct lineinfo *prev,
                         struct lineinfo *curr,
                         struct lineinfo *next)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    wcp wc = w->context;
    if (NearZero(curr->dx, 2) || NearZero(curr->dy, 2)) {
        XTrapezoid trap;
        /*
         * Almost vertical or horizontal, so draw as a single
         * trapezoid, which should be almost a rectangle.
         */
        if (NearZero(curr->dx, 2)) {
            if (curr->dy > 0)
                trap = trapezoid(curr->p1.y, curr->p1.x, curr->p2.x, curr->q1.y, curr->q1.x, curr->q2.x);
            else
                trap = trapezoid(curr->q2.y, curr->q2.x, curr->q1.x, curr->p2.y, curr->p2.x, curr->p1.x);
        } else { /* curr->dy ~== 0 */
            if (curr->dx > 0)
                trap = trapezoid(curr->p2.y, curr->p2.x, curr->q2.x, curr->p1.y, curr->p1.x, curr->q1.x);
            else
                trap = trapezoid(curr->q1.y, curr->q1.x, curr->p1.x, curr->q2.y, curr->q2.x, curr->p2.x);
        }
        XRenderCompositeTrapezoids(wd->display, op, src,  dest, 0, 0, 0, &trap, 1);
    } else {
        if (curr->q1.y > curr->p1.y && curr->p1.y > curr->q2.y) {
            traps(w, op, src, dest, 
                  curr->p2, 
                  curr->q2.y,  curr->p2.x - (curr->dy*curr->dy)/curr->dx, curr->q2.x,
                  curr->p1.y,  curr->p1.x, curr->q1.x + (curr->dy*curr->dy)/curr->dx,
                  curr->q1);
        } else if (curr->q1.y > curr->q2.y && curr->q2.y  > curr->p1.y) {
            traps(w, op, src, dest, 
                  curr->p2, 
                  curr->p1.y,  curr->p1.x,curr->p1.x + (wc->linewidth*curr->len)/curr->dy,
                  curr->q2.y,  curr->q2.x - (wc->linewidth*curr->len)/curr->dy,curr->q2.x,
                  curr->q1);
        } else if (curr->q2.y > curr->q1.y && curr->q1.y > curr->p2.y) {
            traps(w, op, src, dest, 
                  curr->p1, 
                  curr->p2.y,  curr->p2.x - (wc->linewidth*curr->len)/curr->dy,curr->p2.x,
                  curr->q1.y,  curr->q1.x,curr->q1.x + (wc->linewidth*curr->len)/curr->dy,
                  curr->q2);
        } else if (curr->q2.y > curr->p2.y && curr->p2.y > curr->q1.y) {
            traps(w, op, src, dest, 
                  curr->p1, 
                  curr->q1.y,  curr->q1.x,curr->p1.x - (curr->dy*curr->dy)/curr->dx,
                  curr->p2.y,  curr->q2.x + (curr->dy*curr->dy)/curr->dx,curr->p2.x,
                  curr->q2);
        } else if (curr->p2.y > curr->q2.y && curr->q2.y > curr->p1.y) {
            traps(w, op, src, dest, 
                  curr->q1, 
                  curr->p1.y,  curr->q1.x + (curr->dy*curr->dy)/curr->dx,curr->p1.x,
                  curr->q2.y,  curr->q2.x,curr->p2.x - (curr->dy*curr->dy)/curr->dx,
                  curr->p2);
        } else if (curr->p2.y > curr->p1.y && curr->p1.y > curr->q2.y) {
            traps(w, op, src, dest, 
                  curr->q1, 
                  curr->q2.y,  curr->q2.x,curr->q2.x - (wc->linewidth*curr->len)/curr->dy,
                  curr->p1.y,  curr->p1.x + (wc->linewidth*curr->len)/curr->dy,curr->p1.x,
                  curr->p2);
        } else if (curr->p1.y > curr->p2.y && curr->p2.y > curr->q1.y) {
            traps(w, op, src, dest, 
                  curr->q2, 
                  curr->q1.y,  curr->q1.x + (wc->linewidth*curr->len)/curr->dy,curr->q1.x,
                  curr->p2.y, curr->p2.x, curr->p2.x - (wc->linewidth*curr->len)/curr->dy,
                  curr->p1);
        } else if (curr->p1.y > curr->q1.y && curr->q1.y > curr->p2.y) {
            traps(w, op, src, dest, 
                  curr->q2, 
                  curr->p2.y,  curr->p2.x,curr->q2.x + (curr->dy*curr->dy)/curr->dx,
                  curr->q1.y, curr->p1.x - (curr->dy*curr->dy)/curr->dx,curr->q1.x, 
                  curr->p1);
        }
    }

    if (prev) {
        XPointDouble r = midpt(curr->p1, curr->p2);
        if (wc->linewidth == 1) {
            /*
             * This provides a solid pixel in the corner between
             * perpendicular horizontal/vertical single pixel width
             * lines; without it the corner would be transluscent due
             * to the 0.5 pixel shift at each end.
             */
            if ((curr->dy == 0 && prev->dx == 0) || (curr->dx == 0 && prev->dy == 0))
                XRenderComposite(wd->display,
                                 op,
                                 src,          /* src */
                                 None,         /* mask */
                                 dest,         /* dest */
                                 0,0,          /* src x,y */
                                 0,0,          /* mask x,y */
                                 r.x, r.y,     /* dst x,y */
                                 1, 1);
        } else {
            drawjoin(w, op, src, dest, r);
        }
    } else {
        if (wc->linewidth > 1 && wc->linestyle->i == EndDisc)
            drawjoin(w, op, src, dest, midpt(curr->p1, curr->p2));
    }

    if (!next) {
        if (wc->linewidth > 1 && wc->linestyle->i == EndDisc)
            drawjoin(w, op, src, dest, midpt(curr->q1, curr->q2));
    }
}

static void drawlineinfos_impl(wbp w, int op, Picture src, Picture dest, struct lineinfo *lis, int nlis, int closed)
{
    int i;
    for (i = 0; i < nlis; ++i) {
        struct lineinfo *prev, *next;
        if (i > 0)
            prev = &lis[i - 1];
        else
            prev = closed ? &lis[nlis - 1] : 0;
        if (i < nlis - 1)
            next = &lis[i + 1];
        else
            next = closed ? &lis[0] : 0;
        drawlineinfo(w, op, src, dest, prev, &lis[i], next);
    }
}

static XPointDouble adjustpoint(wcp wc, struct point *points, int npoints, int i, int closed)
{
    XPointDouble pd;
    pd.x = points[i].x;
    pd.y = points[i].y;
    /*
     * If the linewidth is odd, shift exactly horizontal and vertical
     * segments lying exact pixel lines by 0.5 pixel so that they are
     * not output with antialiased edges.
     */
    if (fmod(wc->linewidth, 2) == 1) {
        struct point *next, *prev;
        if (i > 0)
            prev = &points[i - 1];
        else
            prev = closed ? &points[npoints - 1] : 0;
        if (i < npoints - 1)
            next = &points[i + 1];
        else
            next = closed ? &points[0] : 0;
        if ((prev && prev->x == points[i].x && fmod(prev->x, 1.0) == 0) || (next && next->x == points[i].x && fmod(next->x, 1.0) == 0))
            pd.x += 0.5;
        if ((prev && prev->y == points[i].y && fmod(prev->y, 1.0) == 0) || (next && next->y == points[i].y && fmod(next->y, 1.0) == 0))
            pd.y += 0.5;
    }
    return pd;
}
 
static void drawlineinfos(wbp w, struct lineinfo *lis, int nlis, int closed)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    wcp wc = w->context;
    int i, x, y, width, height;
    if (nlis == 0)
        return;
    calc_extent(wc, lis, nlis, closed, &x, &y, &width, &height);
    clip(w);
    if (needmask(wc, 1)) {
        Picture mask = getmask(wd, width, height);
        for (i = 0; i < nlis; ++i) {
            lis[i].p1.x -= x; lis[i].p1.y -= y;
            lis[i].p2.x -= x; lis[i].p2.y -= y;
            lis[i].q1.x -= x; lis[i].q1.y -= y;
            lis[i].q2.x -= x; lis[i].q2.y -= y;
        }
        drawlineinfos_impl(w, PictOpOver, wd->white->brush, mask, lis, nlis, closed);
        maskpic2(w, mask, x, y, width, height);
        XRenderFreePicture(wd->display, mask);
    } else {
        drawlineinfos_impl(w, wc->drawop->i, get_draw_picture(wc), ws->ppic, lis, nlis, closed);
        pix_to_win(ws, x, y, width, height);
    }
}

void drawlines(wbp w, struct point *points, int npoints)
{
    wcp wc = w->context;
    struct lineinfo *lis;
    int nlis, i, closed;
    XPointDouble pd1, pd2;

    if (npoints < 2)
        return;
    closed = points[npoints - 1].x == points[0].x && points[npoints - 1].y == points[0].y;

    MemProtect(lis = malloc((npoints - 1) * sizeof(struct lineinfo)));
    pd1 = adjustpoint(wc, points, npoints, 0, closed);
    nlis = 0;
    for (i = 1; i < npoints; ++i) {
        if (points[i - 1].x != points[i].x || points[i - 1].y != points[i].y) {
            pd2 = adjustpoint(wc, points, npoints, i, closed);
            getlineinfo(wc, &pd1, &pd2, &lis[nlis]);
            nlis++;
            pd1 = pd2;
        }
    }
    drawlineinfos(w, lis, nlis, closed);
    free(lis);
}

void drawpoint(wbp w, int x, int y)
{
    fillrectangle(w, x, y, 1, 1);
}

static int needmask(wcp wc, int overlap)
{
    /* ops where influence of source color is 0 (clear, dest, dest in, dest out) */
    if (wc->drawop->i == PictOpClear || wc->drawop->i == PictOpDst || wc->drawop->i == PictOpInReverse || wc->drawop->i == PictOpOutReverse)
        return 0;
    if (wc->pattern)
        return 1;
    if (!overlap)
        return 0;
    if (wc->fg->color.alpha != 0xffff)
        return 1;
    return 0;
}

static Picture getmask(wdp wd, int width, int height)
{
    Pixmap pix;
    Picture pic;
    XRenderPictureAttributes attr;
    pix = XCreatePixmap(wd->display, GetRoot(wd),
                        width, height,
                        8);
    attr.poly_edge = PolyEdge;
    pic = XRenderCreatePicture(wd->display, pix, wd->maskfmt, CPPolyEdge, &attr);
    XFreePixmap(wd->display, pix);
    XRenderFillRectangle(wd->display, PictOpSrc, pic, &wd->transparent->color, 0, 0, width ,height);
    return pic;
}

void drawrectangle(wbp w, int x, int y, int width, int height, int thick)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    wcp wc = w->context;
    /* If too small to give a gap in the middle, then simply fill a
     * rectangle, otherwise draw as four lines. */
    if (width <= 2 * thick || height <= 2 * thick)
        fillrectangle(w, x, y, width, height);
    else {
        clip(w);
        /* Note that we know the two vertical lines will be at least one pixel high, since
         * height > 2 * thick
         */
        if (wc->pattern) {
            pat1(w,
                 x, y,
                 width, thick);
            pat1(w,
                 x, y +  thick,
                 thick, height - 2 * thick);
            pat1(w,
                 x + width - thick, y + thick,
                 thick, height - 2 * thick);
            pat1(w,
                 x, y + height - thick,
                 width, thick);
        } else {
            XRectangle r[4];
            r[0].x = x;
            r[0].y = y;
            r[0].width = width;
            r[0].height = thick;
            r[1].x = x;
            r[1].y = y +  thick;
            r[1].width = thick;
            r[1].height = height - 2 * thick;
            r[2].x = x + width - thick;
            r[2].y = y + thick;
            r[2].width = thick;
            r[2].height = height - 2 * thick;
            r[3].x = x;
            r[3].y = y + height - thick;
            r[3].width = width;
            r[3].height = thick;
            XRenderFillRectangles(wd->display,
                                  wc->drawop->i,
                                  ws->ppic,
                                  &wc->fg->color,
                                  r, 4);
        }

        pix_to_win(ws, x, y, width, height);
    }
}

void fillpolygon(wbp w, struct point *points, int npoints)
{
    XPointDouble *xpoints;
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    int x, y, width, height, i;
    if (npoints < 3)
        return;
    points_extent(points, npoints, &x, &y, &width, &height);
    MemProtect(xpoints = malloc(npoints * sizeof(XPointDouble)));
    clip(w);
    if (needmask(wc, 0)) {
        Picture mask;
        for (i = 0; i < npoints; ++i) {
            xpoints[i].x = points[i].x - x;
            xpoints[i].y = points[i].y - y;
        }
        mask = getmask(wd, width, height);

        XRenderCompositeDoublePoly(wd->display, 
                                   PictOpOver,
                                   wd->white->brush,
                                   mask, 
                                   None, 0, 0, 0, 0,
                                   xpoints, npoints, 0);

        maskpic2(w, mask, x, y, width, height);
        XRenderFreePicture(wd->display, mask);
    } else {
        for (i = 0; i < npoints; ++i) {
            xpoints[i].x = points[i].x;
            xpoints[i].y = points[i].y;
        }
        XRenderCompositeDoublePoly(wd->display, 
                                   wc->drawop->i,
                                   get_draw_picture(wc),
                                   ws->ppic, 
                                   None, 0, 0, 0, 0,
                                   xpoints, npoints, 0);
        pix_to_win(ws, x, y, width, height);
    }
    free(xpoints);
}

void filltrapezoids(wbp w, struct trapezoid *traps, int ntraps)
{
    XTrapezoid *xtraps;
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    int x, y, width, height, i;

    trapezoids_extent(traps, ntraps, &x, &y, &width, &height);
    MemProtect(xtraps = malloc(ntraps * sizeof(XTrapezoid)));
    clip(w);
    if (needmask(wc, 1)) {
        Picture mask;
        for (i = 0; i < ntraps; ++i)
            xtraps[i] = trapezoid(traps[i].top - y, traps[i].x1 - x, traps[i].x2 - x,
                                  traps[i].bottom - y, traps[i].x3 - x, traps[i].x4 - x);
        mask = getmask(wd, width, height);
        XRenderCompositeTrapezoids(wd->display, 
                                   PictOpOver,
                                   wd->white->brush,
                                   mask,
                                   0, 0, 0,
                                   xtraps, ntraps);
        maskpic2(w, mask, x, y, width, height);
        XRenderFreePicture(wd->display, mask);
    } else {
        for (i = 0; i < ntraps; ++i)
            xtraps[i] = trapezoid(traps[i].top, traps[i].x1, traps[i].x2,
                                  traps[i].bottom, traps[i].x3, traps[i].x4);
        XRenderCompositeTrapezoids(wd->display, 
                                   wc->drawop->i,
                                   get_draw_picture(wc),
                                   ws->ppic, 
                                   0, 0, 0,
                                   xtraps, ntraps);
        pix_to_win(ws, x, y, width, height);
    }
    free(xtraps);
}

void filltriangles(wbp w, struct triangle *tris, int ntris)
{
    XTriangle *xtris;
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    int x, y, width, height, i;

    triangles_extent(tris, ntris, &x, &y, &width, &height);
    MemProtect(xtris = malloc(ntris * sizeof(XTrapezoid)));
    clip(w);
    if (needmask(wc, 1)) {
        Picture mask;
        for (i = 0; i < ntris; ++i)
            xtris[i] = triangle(tris[i].p1.x - x, tris[i].p1.y - y,
                                tris[i].p2.x - x, tris[i].p2.y - y, 
                                tris[i].p3.x - x, tris[i].p3.y - y);
        mask = getmask(wd, width, height);
        XRenderCompositeTriangles(wd->display, 
                                  PictOpOver,
                                  wd->white->brush,
                                  mask,
                                  0, 0, 0,
                                  xtris, ntris);
        maskpic2(w, mask, x, y, width, height);
        XRenderFreePicture(wd->display, mask);
    } else {
        for (i = 0; i < ntris; ++i)
            xtris[i] = triangle(tris[i].p1.x, tris[i].p1.y,
                                tris[i].p2.x, tris[i].p2.y, 
                                tris[i].p3.x, tris[i].p3.y);
        XRenderCompositeTriangles(wd->display, 
                                  wc->drawop->i,
                                  get_draw_picture(wc),
                                  ws->ppic, 
                                  0, 0, 0,
                                  xtris, ntris);
        pix_to_win(ws, x, y, width, height);
    }
    free(xtris);
}

static void maskpic2(wbp w, Picture mask, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    XRenderComposite(wd->display,
                     wc->drawop->i,
                     get_draw_picture(wc),          /* src */
                     mask,         /* mask */
                     ws->ppic,     /* dest */
                     x,y,          /* src x,y */
                     0,0,          /* mask x,y */
                     x, y,         /* dst x,y */
                     width, height);
    pix_to_win(ws, x, y, width, height);
}

static void pic2(wbp w, Picture src, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    XRenderComposite(wd->display,
                     wc->drawop->i,
                     src,          /* src */
                     None,         /* mask */
                     ws->ppic,     /* dest */
                     0,0,          /* src x,y */
                     0,0,          /* mask x,y */
                     x, y,         /* dst x,y */
                     width, height);
    pix_to_win(ws, x, y, width, height);
}

static void pat1(wbp w, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    XRenderComposite(wd->display,
                     wc->drawop->i,
                     wc->pattern->i,  /* src */
                     None,         /* mask */
                     ws->ppic,     /* dest */
                     x,y,          /* src x,y */
                     0,0,          /* mask x,y */
                     x, y,         /* dst x,y */
                     width, height);
}

static void pat2(wbp w, int x, int y, int width, int height)
{
    pat1(w, x, y, width, height);
    pix_to_win(w->window, x, y, width, height);
}

static void fill2(wbp w, int op, XRenderColor *color, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    XRenderFillRectangle(wd->display,
                         op,
                         ws->ppic,
                         color,
                         x, y, width, height);
    pix_to_win(ws, x, y, width, height);
}

static Pixmap imgdata_to_Pixmap1(wdp wd, struct imgdata *imd)
{
    XImage *xi;
    Pixmap pix;
    GC gc;
    MemProtect(xi = XCreateImage(wd->display, 
                                 GetVisual(wd), 
                                 32,            /* depth */
                                 ZPixmap, 
                                 0, 
                                 (char *)imd->data, 
                                 imd->width, imd->height, 
                                 BitmapPad(wd->display),
                                 0));

    pix = XCreatePixmap(wd->display, GetRoot(wd),
                      imd->width, imd->height,
                      32);
    gc = XCreateGC(wd->display, pix, 0, NULL);
    XPutImage(wd->display, pix, gc, xi,
              0,0, 0,0, imd->width, imd->height);
    xi->data = 0;
    XDestroyImage(xi);
    XFreeGC(wd->display, gc);
    return pix;
}

Pixmap imgdata_to_Pixmap(wdp wd, struct imgdata *imd)
{
    struct imgdata *tmp;
    Pixmap pix;
    if (imd->format == wd->format)
        return imgdata_to_Pixmap1(wd, imd);
    tmp = initimgdata(imd->width, imd->height, wd->format);
    copyimgdata(tmp, imd);
    pix = imgdata_to_Pixmap1(wd, tmp);
    unlinkimgdata(tmp);
    return pix;
}

static Picture get_draw_picture(wcp wc)
{
    if (wc->pattern)
        return wc->pattern->i;
    else
        return wc->fg->brush;
}

/*
 * fill a rectangle
 */
void fillrectangle(wbp w, int x, int y, int width, int height)
{
    wcp wc = w->context;
    clip(w);
    /*
     * fill the rectangle with the pattern or foreground color
     */
    if (wc->pattern)
        pat2(w, 
             x, y, width, height);
    else
        fill2(w,
              wc->drawop->i,
              &wc->fg->color,
              x, y, width, height);
}

/*
 * erase an area
 */
void erasearea(wbp w, int x, int y, int width, int height)
{
    wcp wc = w->context;
    clip(w);
    /*
     * fill the rectangle with the background color
     */
    fill2(w,
          PictOpSrc,
          &wc->bg->color,
          x, y, width, height);
}

/*
 * copy an area
 */
int copyarea(wbp w, int x, int y, int width, int height, wbp w2, int x2, int y2)
{
    wsp ws1 = w->window;
    wsp ws2 = w2->window;
    wcp wc2 = w2->context;
    wdp wd1 = ws1->display;
    wdp wd2 = ws2->display;

    if (wd1->display != wd2->display) {
        LitWhy("Can't copy between different displays");
        return Failed;
    }


    /*
     * Copying is between windows on one display, perhaps the same window.
     */
    no_clip(ws1, 0);
    clip(w2);

    /*
     * Copy the area.
     */
    XRenderComposite(wd1->display,
                     wc2->drawop->i,
                     ws1->ppic,    /* src */
                     None,         /* mask */
                     ws2->ppic,    /* dest */
                     x, y,         /* src_x,y */
                     0, 0,         /* mask x,y */
                     x2, y2,       /* dst x,y */
                     width, height);
    pix_to_win(ws2, x2, y2, width, height);
    return Succeeded;
}

void captureimgdata(wbp w, int x, int y, struct imgdata *imd)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    XImage *xi;
    MemProtect(xi = XGetImage(wd->display, ws->pix,
                              x, y, imd->width, imd->height,
                              AllPlanes, ZPixmap));
    imd->format = wd->format;
    imd->data = (unsigned char *)xi->data;
    xi->data = 0;
    XDestroyImage(xi);
}

void drawimgdata(wbp w, int x, int y, struct imgdata *imd)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    Pixmap pix;
    Picture pic;
    pix = imgdata_to_Pixmap(wd, imd);
    pic = XRenderCreatePicture(wd->display, pix, wd->pixfmt, 0, 0);
    clip(w);
    pic2(w,
         pic,
         x, y, imd->width, imd->height);
    XFreePixmap(wd->display, pix);
    XRenderFreePicture(wd->display, pic);
}

struct imgdataformat *getimgdataformat(wbp w)
{
    return w->window->display->format;
}

int querypointer(wbp w, int *x, int *y)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    Window garbage1, garbage2;
    int root_x, root_y;
    unsigned int key_buttons;
    CheckUnhidden(ws);
    /* XQueryPointer returns false if the pointer is not on the X11 Screen. */
    if (XQueryPointer(wd->display, ws->win, &garbage1, &garbage2,
                      &root_x, &root_y, x, y, &key_buttons) == False) {
        LitWhy("Pointer not on screen");
        return Failed;
    }
    return Succeeded;
}

int queryrootpointer(wbp w, int *x, int *y)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    Window garbage1, garbage2;
    int win_x, win_y;
    unsigned int key_buttons;
    /* XQueryPointer returns false if the pointer is not on the X11 Screen. */
    if (XQueryPointer(wd->display, GetRoot(wd), &garbage1, &garbage2,
                      x, y, &win_x, &win_y, &key_buttons) == False) {
        LitWhy("Pointer not on screen");
        return Failed;
    }
    return Succeeded;
}

int focuswindow(wbp w)
{
    XWindowAttributes attr;
    wsp ws = w->window;
    wdp wd = ws->display;
    CheckUnhidden(ws);
    /* From the manpage : The specified focus window must be viewable
     * at the time XSetInputFocus is called, or a BadMatch error
     * results. */
    XGetWindowAttributes(wd->display, ws->win, &attr);
    if (attr.map_state != IsViewable) {
        LitWhy("Can't focus window that is not viewable");
        return Failed;
    }
    XSetInputFocus(wd->display, ws->win, RevertToParent, CurrentTime);
    return Succeeded;
}

int raisewindow(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    XRaiseWindow(ws->display->display, ws->win);
    return Succeeded;
}

int lowerwindow(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    XLowerWindow(ws->display->display, ws->win);
    return Succeeded;
}

int walert(wbp w, int volume)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    XBell(wd->display, volume);    
    XFlush(wd->display);
    return Succeeded;
}

int textwidth(wbp w, dptr str)
{
    XGlyphInfo	extents; 
    if (is:string(*str))
        XftTextExtents8(w->window->display->display,
                        w->context->font->fsp,
                        (FcChar8 *)StrLoc(*str),
                        StrLen(*str),
                        &extents);
    else
        XftTextExtentsUtf8(w->window->display->display,
                           w->context->font->fsp,
                           (FcChar8 *)StrLoc(UcsBlk(*str).utf8),
                           StrLen(UcsBlk(*str).utf8),
                           &extents);
    
    /* xOff is a short; on long strings it wraps round at 32k, so
     * anding with 0xffff doubles the range of sensible result
     * values. */
    return extents.xOff & 0xffff;
}

static void prepare_xft(wbp w)
{
    XRectangle rec;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;

    if (!ws->pxft)
        MemProtect(ws->pxft = XftDrawCreateAlpha(wd->display, ws->pix, 32));

    if (wc->clipw >= 0) {
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XftDrawSetClipRectangles(ws->pxft, 0, 0, &rec, 1);
    } else
        XftDrawSetClip(ws->pxft, 0);
}

void drawstring(wbp w, int x, int y, dptr str)
{
    XftColor color;
    wcp wc = w->context;
    wsp ws = w->window;
    prepare_xft(w);
    color.pixel = 0;
    color.color = wc->fg->color;
    if (is:string(*str))
        XftDrawString8(ws->pxft,
                       &color,
                       wc->font->fsp,
                       x,
                       y,
                       (FcChar8 *)StrLoc(*str),
                       StrLen(*str));
    else
        XftDrawStringUtf8(ws->pxft,
                          &color,
                          wc->font->fsp,
                          x,
                          y,
                          (FcChar8 *)StrLoc(UcsBlk(*str).utf8),
                          StrLen(UcsBlk(*str).utf8));
    clip(w);
    pix_to_win(ws, 
               x, y - wc->font->ascent, 
               textwidth(w, str),
               wc->font->ascent + wc->font->descent);
}

/* This array must correspond with the NUMATOMS and ATOM_xxx constants defined in xwin.h. */
char *atom_names[NUMATOMS] = {
    "CHARACTER_POSITION",
    "CLIENT_WINDOW",
    "CLIPBOARD",
    "HOSTNAME",
    "HOST_NAME",
    "LENGTH",
    "LIST_LENGTH",
    "NAME",
    "OWNER_OS",
    "SPAN",
    "TARGETS",
    "TIMESTAMP",
    "USER",
    "WM_DELETE_WINDOW",
    "_NET_WM_STATE_MAXIMIZED_VERT",
    "_NET_WM_STATE_MAXIMIZED_HORZ",
    "_NET_WM_STATE_FULLSCREEN",
    "_NET_WM_STATE",
    "_NET_WM_ICON",
    "_NET_WM_NAME",
    "UTF8_STRING",
    "WM_STATE",
    "_OBJECTICON_PROP0",
    "_OBJECTICON_PROP1",
    "_OBJECTICON_PROP2",
    "_OBJECTICON_PROP3",
    "_OBJECTICON_PROP4",
    "_OBJECTICON_PROP5",
    "_OBJECTICON_PROP6",
    "_OBJECTICON_PROP7",
};

/*
 * allocate a window binding structure
 */
wbp alcwbinding(wdp wd)
{
    wbp w;
    MemProtect(w = calloc(1, sizeof(struct _wbinding)));
    GLink(w, wd->wbndngs);
    return w;
}

/*
 * free a window binding.
 */
void freewbinding(wbp w)
{
    wdp wd = w->window->display;
    freewindow(w->window);
    freecontext(w->context);
    GUnlink(w, wd->wbndngs);
    free(w);
}

wbp findwbp(wsp ws)
{
    wbp wb;
    for (wb = ws->display->wbndngs; wb; wb = wb->next)
        if (wb->window == ws)
            return wb;
    syserr("Couldn't find wbp for wsp");
    return 0;  /* not reached */
}

/*
 * allocate a display on machine s
 */
static wdp alcdisplay(char *s)
{
    wdp wd;
    Visual *vis;
    XVisualInfo xvi, *xvi_ret;
    int nitems_return;
    int major_version, minor_version;

    if (s == NULL) s = getenv("DISPLAY");
    if (s == NULL) s = "";
    for(wd = wdsplys; wd; wd = wd->next)
        if (wd->program == curpstate && !strcmp(wd->name,s)) {
            return wd;
        }

    MemProtect(wd = calloc(1, sizeof(struct _wdisplay)));

    wd->program = curpstate;
    wd->display = XOpenDisplay((*s=='\0') ? NULL : s);
    if (wd->display == NULL) {
        LitWhy("Couldn't connect to display");
        free(wd);
        return NULL;
    }

    if (!XRenderQueryVersion(wd->display, &major_version, &minor_version)) {
        LitWhy("XRender extension not available on server");
        XCloseDisplay(wd->display);
        free(wd);
        return NULL;
    }

    vis = GetVisual(wd);
    /*
     * Get info about the default visual, check it's suitable and
     * extract the rgb shift masks.
     */
    xvi.visualid = XVisualIDFromVisual(vis);
    xvi_ret = XGetVisualInfo(wd->display, VisualIDMask, &xvi, &nitems_return);
    if (nitems_return != 1) {
        LitWhy("Couldn't get default visual's info");
        XCloseDisplay(wd->display);
        free(wd);
        return NULL;
    }
    wd->format = ImageByteOrder(wd->display) == LSBFirst ? &imgdataformat_X11BGRA32 : &imgdataformat_X11ARGB32;
    wd->maskfmt = XRenderFindStandardFormat(wd->display, PictStandardA8);
    if (xvi_ret->class == TrueColor && xvi_ret->depth == 24 && xvi_ret->bits_per_rgb == 8) {
        wd->winfmt = XRenderFindStandardFormat(wd->display, PictStandardRGB24);
    } else {
        LitWhy("Unsupported display type");
        XCloseDisplay(wd->display);
        free(wd);
        return NULL;
    }
    XFree(xvi_ret);

    wd->defaultfont = loadfont(wd, defaultfont);
    if (wd->defaultfont == NULL) {
        LitWhy("Couldn't load default font");
        XCloseDisplay(wd->display);
        free(wd);
        return NULL;
    }
    wd->name = salloc(s);
    wd->pixfmt = XRenderFindStandardFormat(wd->display, PictStandardARGB32);
    wd->black = new_sharedcolor(wd, "black", 0, 0, 0, 65535);
    wd->white = new_sharedcolor(wd, "white", 65535, 65535, 65535, 65535);
    wd->transparent = new_sharedcolor(wd, "transparent", 0, 0, 0, 0);
    XInternAtoms(wd->display, atom_names, NUMATOMS, False, wd->atoms);
    setup_cursors(wd);
    GLink(wd, wdsplys);
    return wd;
}

/*
 * Convert a given font spec, which may or may not be in icon font spec format,
 * into fontconfig (used by Xft) style format.  The result is never null.
 * 
 * To avoid ambiguity, a spec can start with "fc:" to indicate it's in fontconfig
 * format; otherwise parsefont is called to decide the format.
 */
char *tofcpatternstr(char *s)
{
    static char res[256];
    int flags;
    double size;
    char *t, family[MAXFONTWORD];
    FcPattern *p;

    if (!strncmp(s, "fc:", 3))
        return s + 3;

    if (!parsefont(s, family, &flags, &size))
        return 0;

    p = FcPatternCreate();

    /*
     * Check first for special "standard" family names.
     */
    if (!strcmp(family, "fixed")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon fixed");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"mono");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "mono")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon mono");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"mono");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "typewriter")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon typewriter");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"courier");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "sans")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon sans");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"helvetica");
        flags |= FONTFLAG_PROPORTIONAL;
    }
    else if (!strcmp(family, "serif")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon serif");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"times");
        flags |= FONTFLAG_PROPORTIONAL;
    }
    else
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)family);

    FcPatternAddDouble(p, FC_SIZE, size);

    if (flags & FONTFLAG_MEDIUM)
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_MEDIUM);
    else if ((flags & FONTFLAG_DEMI) && (flags & FONTFLAG_BOLD))
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_DEMIBOLD);
    else if (flags & FONTFLAG_BOLD)
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_BOLD);
    else if (flags & FONTFLAG_LIGHT)
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_LIGHT);

    if (flags & FONTFLAG_ITALIC)
        FcPatternAddInteger(p, FC_SLANT, FC_SLANT_ITALIC);
    else if (flags & FONTFLAG_OBLIQUE)
        FcPatternAddInteger(p, FC_SLANT, FC_SLANT_OBLIQUE);
    else if (flags & FONTFLAG_ROMAN)
        FcPatternAddInteger(p, FC_SLANT, FC_SLANT_ROMAN);

    if (flags & FONTFLAG_PROPORTIONAL)
        FcPatternAddInteger(p, FC_SPACING, FC_PROPORTIONAL);
    if (flags & FONTFLAG_MONO)
        FcPatternAddInteger(p, FC_SPACING, FC_MONO);

    t = (char *)FcNameUnparse(p);
    strncpy(res, t, sizeof(res) - 1);
    free(t);
    FcPatternDestroy(p);

    return res;
}

/*
 * load a font and return a font structure.
 */

wfp loadfont(wdp wd, char *s)
{
    wfp rv;
    int i;

    /*
     * Convert to a system font name (without the fc: prefix)
     */
    s = tofcpatternstr(s);
    if (!s)
        return 0;

    /*
     * see if the font is already loaded on this display
     */
    i = hasher(hashcstr(s), wd->fonts);
    for(rv = wd->fonts[i]; rv; rv = rv->next) {
        if (!strcmp(s, rv->name + 3))
            return rv;
    }

    /*
     * load a new font
     */
    rv = newfont(wd, s);
    if (!rv)
        return 0;

    /*
     * link the font into this display's fontlist
     */
    rv->next = wd->fonts[i];
    wd->fonts[i] = rv;

    return rv;
}

static wfp newfont(wdp wd, char *s)
{
    wfp rv;
    XGlyphInfo	extents; 

    MemProtect(rv = calloc(1, sizeof(struct _wfont)));
    rv->fsp = XftFontOpenName(wd->display, DefaultScreen(wd->display), s);
    if (!rv->fsp){
        free(rv);
        return 0;
    }

    MemProtect(rv->name = malloc(strlen(s) + 3 + 1));
    sprintf(rv->name, "fc:%s", s);

    /*
     * Xft seems to sometimes give too-small values in its font
     * ascent/descent fields; therefore calculate the GlyphInfo
     * for the first 256 chars and take the maximum ascent/descent
     * of the sample and the font's reported values.
     */
    XftTextExtents8 (wd->display,
                     rv->fsp,
                     (FcChar8 *)allchars,
                     256,
                     &extents);
    rv->ascent = Max(rv->fsp->ascent, extents.y);
    rv->descent = Max(rv->fsp->descent, extents.height - extents.y);
    rv->maxwidth = rv->fsp->max_advance_width;
    return rv;
}

/*
 * allocate a context, cloning attributes from an existing context
 */
static wcp clonecontext(wcp wc)
{
    wcp rv;
    GAlloc(rv, _wcontext);
    rv->display = wc->display;
    rv->dx = wc->dx;
    rv->dy = wc->dy;
    rv->leading = wc->leading;
    rv->clipx = wc->clipx;
    rv->clipy = wc->clipy;
    rv->clipw = wc->clipw;
    rv->cliph = wc->cliph;
    rv->fg = link_sharedcolor(wc->fg);
    rv->bg = link_sharedcolor(wc->bg);
    if (wc->pattern)
        rv->pattern = link_sharedpicture(wc->pattern);
    rv->font = wc->font;
    rv->linestyle = wc->linestyle;
    rv->linewidth = wc->linewidth;
    rv->drawop = wc->drawop;
    return rv;
}

/*
 * free a window state
 */
static void freewindow(wsp ws)
{
    ws->refcount--;
    if(ws->refcount == 0) {
        if (ws->win)
            close_screen_win(ws);
        if (ws->pxft)
            XftDrawDestroy(ws->pxft);
        XFreePixmap(ws->display->display, ws->pix);
        XRenderFreePicture(ws->display->display, ws->ppic);
        free(ws->icondata);
        del_gc_global(&ws->listp);
        del_gc_global(&ws->windowlabel);
        if (ws->transientfor)
            freewindow(ws->transientfor);
        free(ws);
    }
}

/*
 * free a window context
 */
static void freecontext(wcp wc)
{
    wc->refcount--;
    if(wc->refcount == 0) {
        unlink_sharedcolor(wc->fg);
        unlink_sharedcolor(wc->bg);
        if (wc->pattern)
            unlink_sharedpicture(wc->pattern);
        free(wc);
    }
}

int readimagefileimpl(char *filename, struct imgdata *imd) 
{
    return NoCvt;
}

int writeimagefileimpl(char *filename, struct imgdata *imd)
{
    return NoCvt;
}

int readimagedataimpl(dptr data, struct imgdata *imd)
{
    return NoCvt;
}

int settransientfor(wbp w, wbp other)
{
    wsp ws = w->window;
    if (ws->win) {
        LitWhy("Can't set transient_for on an open window");
        return Failed;
    }
    if (other) {
        if (w->window->display != other->window->display) {
            LitWhy("Can't set transient_for with windows on different displays");
            return Failed;
        }
        if (ws->transientfor)
            freewindow(ws->transientfor);
        ws->transientfor = linkwindow(other->window);
    } else {
        if (ws->transientfor)
            freewindow(ws->transientfor);
        ws->transientfor = 0;
    }
    return Succeeded;
}

static void set_X11ARGB32(struct imgdata *imd, int x, int y, int r, int g, int b, int a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    b = (((unsigned)b) * a) / 65535;
    g = (((unsigned)g) * a) / 65535;
    r = (((unsigned)r) * a) / 65535;
    *s++ = a / 256;
    *s++ = r / 256;
    *s++ = g / 256;
    *s++ = b / 256;
}
static void get_X11ARGB32(struct imgdata *imd, int x, int y, int *r, int *g, int *b, int *a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    *a = 257 * (*s++);
    *r = 257 * (*s++);
    *g = 257 * (*s++);
    *b = 257 * (*s++);
    if (*a > 0) {
        *b = (((unsigned)*b) * 65535) / *a;
        *g = (((unsigned)*g) * 65535) / *a;
        *r = (((unsigned)*r) * 65535) / *a;
    }
}

static void set_X11BGRA32(struct imgdata *imd, int x, int y, int r, int g, int b, int a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    b = (((unsigned)b) * a) / 65535;
    g = (((unsigned)g) * a) / 65535;
    r = (((unsigned)r) * a) / 65535;
    *s++ = b / 256;
    *s++ = g / 256;
    *s++ = r / 256;
    *s++ = a / 256;
}

static void get_X11BGRA32(struct imgdata *imd, int x, int y, int *r, int *g, int *b, int *a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    *b = 257 * (*s++);
    *g = 257 * (*s++);
    *r = 257 * (*s++);
    *a = 257 * (*s++);
    if (*a > 0) {
        *b = (((unsigned)*b) * 65535) / *a;
        *g = (((unsigned)*g) * 65535) / *a;
        *r = (((unsigned)*r) * 65535) / *a;
    }
}

struct imgdataformat imgdataformat_X11ARGB32 =   {set_X11ARGB32,get_X11ARGB32,0,0,getlength_32,8,24,0,"X11ARGB32"};
struct imgdataformat imgdataformat_X11BGRA32 =   {set_X11BGRA32,get_X11BGRA32,0,0,getlength_32,8,24,0,"X11BGRA32"};

void registerplatformimgdataformats()
{
    registerimgdataformat(&imgdataformat_X11ARGB32);
    registerimgdataformat(&imgdataformat_X11BGRA32);
}
