<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>extmath.icn</title></head><body><pre>
<a name="1"/>package ipl.math
<a name="2"/>
<a name="3"/>#-------------------------------------------------------------------------------
<a name="4"/># Name:        ipl.math
<a name="5"/># Purpose:     Extended Library of mathematical functions
<a name="6"/>#
<a name="7"/># Author:      Oleg Baharew aka ArqricCat (IDP Team)
<a name="8"/>#
<a name="9"/># Created:     27.07.2013
<a name="10"/># Copyright:   (c) IDP Team, 2013
<a name="11"/># Licence:     MIT License
<a name="12"/>
<a name="13"/># Class summary:
<a name="14"/>
<a name="15"/>#  ExtMath - a class that provides an expanded set of mathematical functions that are 
<a name="16"/>#  implemented as static methods of this class.
<a name="17"/>
<a name="18"/>#  Constant defined in this class:
<a name="19"/>#     * syms - set of alphabetic and numeric
<a name="20"/>#     * eiler - Eiler-Maskeroni constant
<a name="21"/>  
<a name="22"/>#  Methods defined in this class:
<a name="23"/>#     * to_sys(x,n) - convert number to system with base n
<a name="24"/>#     * from_sys(x,n) - convert number from system with base n
<a name="25"/>#     * to_sys2(x,n1,n2) - convert number from system with base n1 to system with base n2
<a name="26"/>#     * root(x,y) - yth root from x
<a name="27"/>#     * discriminant(a,b,c) - discriminant of quadratic equation
<a name="28"/>#     * sgn(x) - signum function
<a name="29"/>#     * frac(x) - fraction part
<a name="30"/>#     * floor(x) -  largest integer not greater than x
<a name="31"/>#     * ceil(x) - smallest integer not less than x
<a name="32"/>#     * heavyside(x) - Heavyside function
<a name="33"/>#     * heavyside2(x) - Discrete Heavyside function
<a name="34"/>#     * rect(x) - rectangle function
<a name="35"/>#     * tri(x) - triangle function
<a name="36"/>#     * saw(x,a) - saw function (a is optional parameter)
<a name="37"/>#     * sinc(x) - normalized sinc function
<a name="38"/>#     * sinc2(x) - unnormalized sinc function
<a name="39"/>#     * weierstrass(a,b,x) - Weierstrass function
<a name="40"/>#     * si(x) - sine integral
<a name="41"/>#     * ci(x) - cosine integral
<a name="42"/>#     * erf(x) - error function
<a name="43"/>#     * erfc(x) - complicated error function
<a name="44"/>#     * gd(x) - guderman function
<a name="45"/>#     * arcgd(x) - inverse Guderman function
<a name="46"/>#     * sec(x) - secans
<a name="47"/>#     * cosec(x) - cosecans
<a name="48"/>#     * ctg(x) - cotangent
<a name="49"/>#     * ei(x) - exponent integral
<a name="50"/>#     * li(x) - logarithm integral
<a name="51"/>#     * cth(x) - cotangent
<a name="52"/>#     * sech(x) - hyperbolic secans
<a name="53"/>#     * csch(x) - hyperbolic cosecans
<a name="54"/>#     * fusc(x) - fusc function
<a name="55"/>#     * prostaferethic(x) - prostaferethic function
<a name="56"/>#     * gompertz(a,b,c,x) - Gompertz function
<a name="57"/>#     * gauss(mu,sigma,x) - Gauss function
<a name="58"/>#     * gamma(x) - gamma function
<a name="59"/>#     * lngamma(x) - natural logarithm absolute value of gamma function
<a name="60"/>#     * binocoef2(n,k) - binomial coefficients (accelerated method) 
<a name="61"/>#     * beta(x,y) - beta function 
<a name="62"/>#     * digamma(x) - digamma functions
<a name="63"/>#     * arsh(x) - area-sine 
<a name="64"/>#     * arch(x) - area-cosine
<a name="65"/>#     * arth(x) - area-tangent
<a name="66"/>#     * arcth(x) - area-cotangent
<a name="67"/>#     * arsch(x,n) - area-secans (n is paramether for sign of result, optional)
<a name="68"/>#     * arcsch(x) - area-cosecans
<a name="69"/>#     * dzeta(x) - Riman dzeta-function
<a name="70"/>#     * bessel1(x,v) - Bessel function of first kind
<a name="71"/>#     * bessel2(x,v) - Bessel function of second kind
<a name="72"/>#     * frenel1(x,v) - Fresnel integral S(x)
<a name="73"/>#     * frenel2(x,v) - Fresnel integral C(x)
<a name="74"/>
<a name="75"/>import 
<a name="76"/>   util(Math),
<a name="77"/>   ipl.factors(factorial)
<a name="78"/>
<a name="79"/>
<a name="80"/>
<a name="81"/>final abstract class ExtMath()
<a name="82"/>public static const 
<a name="83"/>   syms,
<a name="84"/>   eiler
<a name="85"/>
<a name="86"/>   private static init()
<a name="87"/>   syms := &amp;digits++&amp;ucase
<a name="88"/>   eiler := 0.5772156649015328606065120
<a name="89"/>   end
<a name="90"/>
<a name="91"/>   public static to_sys(x,n)
<a name="92"/>      local r,s,i,t,res
<a name="93"/>      s := list()
<a name="94"/>      t := list()
<a name="95"/>      while x &gt;= 1 do {
<a name="96"/>         r := x%n
<a name="97"/>         put(s,r)
<a name="98"/>         x := integer(x/n)
<a name="99"/>      }
<a name="100"/>      every i := *s to 1 by -1 do {
<a name="101"/>         put(t,syms[s[i]+1])
<a name="102"/>      }
<a name="103"/>      res:=""
<a name="104"/>      every i := 1 to *t do {
<a name="105"/>         res ||:= t[i]
<a name="106"/>      }
<a name="107"/>      return res
<a name="108"/>      end
<a name="109"/>
<a name="110"/>   public static from_sys(x,n)
<a name="111"/>      local r,t,i
<a name="112"/>      r := 0
<a name="113"/>      x := reverse(x)
<a name="114"/>      every i := 1 to *x do {
<a name="115"/>	 if x[i] == !syms then t := find(x[i],syms)-1
<a name="116"/>         r +:= t*(n^(i-1))	    
<a name="117"/>      }
<a name="118"/>      return r
<a name="119"/>   end
<a name="120"/>
<a name="121"/>   public static to_sys2(x,n1,n2)
<a name="122"/>   local tmp
<a name="123"/>   tmp := from_sys(x,n1)
<a name="124"/>   return to_sys(tmp,n2)
<a name="125"/>   end 
<a name="126"/>
<a name="127"/>   public static root(x,y)
<a name="128"/>   return x^(1.0/y)
<a name="129"/>   end
<a name="130"/>
<a name="131"/>   public static discriminant(a,b,c)
<a name="132"/>   return (b^2) - 4 * a * c
<a name="133"/>   end
<a name="134"/>
<a name="135"/>   public static sgn(x)
<a name="136"/>   if x &lt; 0 then return -1 else {
<a name="137"/>     if x = 0 then return 0 else return 1
<a name="138"/>   } 
<a name="139"/>   end
<a name="140"/> 
<a name="141"/>   public static frac(x)
<a name="142"/>   return abs(x - integer(x))
<a name="143"/>   end
<a name="144"/>
<a name="145"/>   public static floor(x)
<a name="146"/>   return integer(x - frac(x))
<a name="147"/>   end
<a name="148"/>
<a name="149"/>   public static ceil(x)
<a name="150"/>   if frac(x) = 0 then return x else return 1 + floor(x)
<a name="151"/>   end
<a name="152"/>
<a name="153"/>   public static heavyside(x)
<a name="154"/>   if x &lt; 0 then return 0 else {
<a name="155"/>      if x = 0 then return 0.5 else return 1
<a name="156"/>   }
<a name="157"/>   end
<a name="158"/>
<a name="159"/>   public static heavyside2(x)
<a name="160"/>   if x &lt; 0 then return 0 else return 1
<a name="161"/>   end
<a name="162"/>
<a name="163"/>   public static rect(x)
<a name="164"/>   if abs(x) &gt; 0.5 then return 0 else {
<a name="165"/>      if abs(x) = 0.5 then return 0.5 else return 1
<a name="166"/>   }
<a name="167"/>   end
<a name="168"/>
<a name="169"/>   public static tri(x)
<a name="170"/>   if abs(x) &lt; 1 then return 1 - abs(x) else return 0
<a name="171"/>   end
<a name="172"/>
<a name="173"/>   public static saw(x,a)
<a name="174"/>   local tmp
<a name="175"/>   /a := 1
<a name="176"/>   tmp := x/a
<a name="177"/>   return tmp - floor(tmp + 0.5)
<a name="178"/>   end
<a name="179"/>
<a name="180"/>   public static sinc(x)
<a name="181"/>   if x = 0 then return 1 else return Math.sin(Math.PI * x)/(Math.PI * x)
<a name="182"/>   end
<a name="183"/>
<a name="184"/>   public static sinc2(x)
<a name="185"/>   if x = 0 then return 1 else return Math.sin(x)/x
<a name="186"/>   end
<a name="187"/>   
<a name="188"/>   public static weierstrass(a,b,x)
<a name="189"/>   local i,k,m,s
<a name="190"/>   i:=0
<a name="191"/>   s:=0
<a name="192"/>   while i &lt; 10 do {
<a name="193"/>      k := Math.cos(Math.PI*x*(a^i))
<a name="194"/>      m := b^i
<a name="195"/>      s +:= k*m
<a name="196"/>      i +:= 1
<a name="197"/>   }
<a name="198"/>   return s
<a name="199"/>   end
<a name="200"/>
<a name="201"/>   public static si(x)
<a name="202"/>   local i,g,s,k,v
<a name="203"/>   i := 0
<a name="204"/>   s := 0
<a name="205"/>   while i &lt; 20 do {
<a name="206"/>      k := (2*i)+1
<a name="207"/>      g := (-1)^i
<a name="208"/>      v := (g*(x^k))/(factorial(k)*k)
<a name="209"/>      s +:= v
<a name="210"/>      i +:= 1
<a name="211"/>   }
<a name="212"/>   return s
<a name="213"/>  end
<a name="214"/>
<a name="215"/>   public static ci(x)
<a name="216"/>   local i,s,k
<a name="217"/>   s := eiler+Math.log(x)
<a name="218"/>   i :=1
<a name="219"/>   while i&lt;20 do {
<a name="220"/>      k := (((-1.0)^i)*(x^(2.0*i)))/(factorial(2.0*i)*2.0*i)
<a name="221"/>      s +:= k
<a name="222"/>      i +:= 1
<a name="223"/>   }
<a name="224"/>   return s
<a name="225"/>   end  
<a name="226"/>
<a name="227"/>   public static erf(x)
<a name="228"/>   local a,b,c,s,i
<a name="229"/>   a := 2.0 / Math.sqrt(Math.PI)
<a name="230"/>   s := 0
<a name="231"/>   every i:=0 to 20 do {
<a name="232"/>      b := 2*i + 1
<a name="233"/>      c := ((-1)^i * (x^b)) / (b * factorial(i))
<a name="234"/>      s +:= c
<a name="235"/>   }
<a name="236"/>   return a * s
<a name="237"/>   end
<a name="238"/>
<a name="239"/>   public static erfc(x)
<a name="240"/>   return 1 - erf(x)
<a name="241"/>   end
<a name="242"/>
<a name="243"/>   public static gd(x)
<a name="244"/>   return 2 * Math.atan(Math.exp(x)) - (Math.PI / 2.0)
<a name="245"/>   end
<a name="246"/>
<a name="247"/>   public static arcgd(x)
<a name="248"/>   return 0.5 * Math.log((1.0+Math.sin(x))/(1.0-Math.sin(x)))
<a name="249"/>   end
<a name="250"/>
<a name="251"/>   public static sec(x)
<a name="252"/>   return 1.0 / Math.cos(x)
<a name="253"/>   end
<a name="254"/>
<a name="255"/>   public static cosec(x)
<a name="256"/>   return 1.0 / Math.sin(x)
<a name="257"/>   end
<a name="258"/>
<a name="259"/>   public static ctg(x)
<a name="260"/>   return Math.cos(x) / Math.sin(x)
<a name="261"/>   end
<a name="262"/>
<a name="263"/>   public static ei(x)
<a name="264"/>   local s,i,a
<a name="265"/>   s := Math.log(x) + eiler
<a name="266"/>   every i := 1 to 20 do {
<a name="267"/>      a := (x^i) / (factorial(i)*i)
<a name="268"/>      s +:= a
<a name="269"/>   }
<a name="270"/>   return s 
<a name="271"/>   end
<a name="272"/>
<a name="273"/>   public static li(x)
<a name="274"/>   return ei(Math.log(x))
<a name="275"/>   end
<a name="276"/>
<a name="277"/>   public static cth(x)
<a name="278"/>   return 1.0 / tanh(x)
<a name="279"/>   end
<a name="280"/>
<a name="281"/>   public static sech(x)
<a name="282"/>   return 1.0 / cosh(x)
<a name="283"/>   end
<a name="284"/>
<a name="285"/>   public static csch(x)
<a name="286"/>   return 1.0 / sinh(x)
<a name="287"/>   end
<a name="288"/>   
<a name="289"/>   public static fusc(x)
<a name="290"/>   local a,b
<a name="291"/>   a := 1
<a name="292"/>   b := 0
<a name="293"/>   while x ~= 0 do {
<a name="294"/>      if x%2 = 0 then {
<a name="295"/>         a := a+b
<a name="296"/>         x := x/2
<a name="297"/>      } else {
<a name="298"/>         b := a+b 
<a name="299"/>         x := (x-1)/2
<a name="300"/>     }
<a name="301"/>   }
<a name="302"/>   return b
<a name="303"/>   end
<a name="304"/>
<a name="305"/>   public static prostaferethic(x)
<a name="306"/>   return integer((x^2)/4.0)
<a name="307"/>   end
<a name="308"/>
<a name="309"/>   public static gompertz(a,b,c,x)
<a name="310"/>   return a*Math.exp(b*Math.exp(c*x))
<a name="311"/>   end
<a name="312"/>
<a name="313"/>   public static gauss(mu,sigma,x)
<a name="314"/>   local a,b,c
<a name="315"/>   a := 1.0/(sigma*Math.sqrt(2*Math.PI))
<a name="316"/>   b := ((x-mu)^2)/(2*(sigma^2))
<a name="317"/>   c := Math.exp(-b)
<a name="318"/>   return a*c
<a name="319"/>   end
<a name="320"/>
<a name="321"/>   public static gamma(x)
<a name="322"/>   local p,q,a,b,i
<a name="323"/>   a := 0.0
<a name="324"/>   b := 1.0
<a name="325"/>   p := [-1.71618513886549492533811e+0,
<a name="326"/>          2.47656508055759199108314e+1,
<a name="327"/>         -3.79804256470945635097577e+2,
<a name="328"/>          6.29331155312818442661052e+2,
<a name="329"/>          8.66966202790413211295064e+2,
<a name="330"/>         -3.14512729688483675254357e+4,
<a name="331"/>         -3.61444134186911729807069e+4,
<a name="332"/>          6.64561438202405440627855e+4]
<a name="333"/>   q := [-3.08402300119738975254353e+1,
<a name="334"/>          3.15350626979604161529144e+2,
<a name="335"/>         -1.01515636749021914166146e+3,
<a name="336"/>         -3.10777167157231109440444e+3,
<a name="337"/>          2.25381184209801510330112e+4,
<a name="338"/>          4.75584627752788110767815e+3,
<a name="339"/>         -1.34659959864969306392456e+5,
<a name="340"/>         -1.15132259675553483497211e+5]
<a name="341"/>   every i:=1 to 8 do {
<a name="342"/>      a := (a+p[i])*(x-1);
<a name="343"/>      b := b*(x-1)+q[i];
<a name="344"/>   }
<a name="345"/>  return a/b+1.0
<a name="346"/>  end
<a name="347"/>
<a name="348"/>  public static lngamma(x)
<a name="349"/>  return Math.log(Math.abs(gamma(x)))
<a name="350"/>  end
<a name="351"/>
<a name="352"/>  public static binocoef2(n,k)
<a name="353"/>  local res,i
<a name="354"/>  res := 1.0
<a name="355"/>  i := 1.0
<a name="356"/>  while i &lt;= k do {
<a name="357"/>     res := res*(n-k+i)/i
<a name="358"/>     i +:= 1.0
<a name="359"/>  }
<a name="360"/>  return integer(res+0.01)
<a name="361"/>  end
<a name="362"/>
<a name="363"/>  public static beta(x,y)
<a name="364"/>  return (gamma(x)*gamma(y))/gamma(x+y)
<a name="365"/>  end
<a name="366"/>
<a name="367"/>  public static digamma(x)
<a name="368"/>  local s,i,z
<a name="369"/>  z := x - 1
<a name="370"/>  s := 0
<a name="371"/>  i := 1
<a name="372"/>  while i &lt; 250 do {
<a name="373"/>     s +:= z/(i*(i+z))
<a name="374"/>     i +:= 1
<a name="375"/>  }
<a name="376"/>  return s - eiler
<a name="377"/>  end
<a name="378"/>
<a name="379"/>  public static arsh(x)
<a name="380"/>  return Math.log(x+Math.sqrt((x^2)+1))
<a name="381"/>  end
<a name="382"/>
<a name="383"/>  public static arch(x)
<a name="384"/>  return Math.log(x+Math.sqrt((x^2)-1))
<a name="385"/>  end
<a name="386"/>
<a name="387"/>  public static arth(x)
<a name="388"/>  return 0.5*Math.log((1+x)/(1-x))
<a name="389"/>  end
<a name="390"/>
<a name="391"/>  public static arcth(x)
<a name="392"/>  return 0.5*Math.log((x+1)/(x-1))
<a name="393"/>  end
<a name="394"/>
<a name="395"/>  public static arsch(x,n)
<a name="396"/>  local res
<a name="397"/>  /n := 1
<a name="398"/>  res := Math.log((1+Math.sqrt(1-x^2))/x)
<a name="399"/>  if n = 1 then return res else return -res
<a name="400"/>  end
<a name="401"/>
<a name="402"/>  public static arcsch(x)
<a name="403"/>  if x &lt; 0 then return Math.log((1-Math.sqrt(1+x^2))/x) else Math.log((1+Math.sqrt(1+x^2))/x)
<a name="404"/>  end
<a name="405"/>
<a name="406"/>  public static dzeta(x) 
<a name="407"/>  local s,i
<a name="408"/>  s := 0
<a name="409"/>  i := 1
<a name="410"/>  while i &lt; 20 do {
<a name="411"/>     s +:= 1.0/(i^x)
<a name="412"/>     i +:= 1
<a name="413"/>  }
<a name="414"/>  return s
<a name="415"/>  end
<a name="416"/>
<a name="417"/>  public static bessel1(x,v)
<a name="418"/>  local s,z,i,a,b
<a name="419"/>  s := 0
<a name="420"/>  z := 0.5 * x
<a name="421"/>  i := 0
<a name="422"/>  while i &lt; 20 do {
<a name="423"/>     a := ((-1)^i) * z^(2*i+abs(v))
<a name="424"/>     b := factorial(i) * gamma(i+abs(v)+1)
<a name="425"/>     s +:= a/b
<a name="426"/>     i +:= 1
<a name="427"/>  }
<a name="428"/>  if v &gt;= 0 then return s else return ((-1.0)^v)*s
<a name="429"/>  end
<a name="430"/>
<a name="431"/>  public static bessel2(x,v)
<a name="432"/>  local a,b
<a name="433"/>  a := (bessel1(x,v)*Math.cos(v*Math.PI)) - bessel1(x,-v)
<a name="434"/>  b := Math.sin(v*Math.PI)
<a name="435"/>  return a/b
<a name="436"/>  end
<a name="437"/>
<a name="438"/>  public static fresnel1(x)
<a name="439"/>  local s,i,a,b,c
<a name="440"/>  s := 0
<a name="441"/>  i := 0
<a name="442"/>  while i &lt; 40 do {
<a name="443"/>     a := 4.0*i+3
<a name="444"/>     b := ((-1)^i) * (x^a)
<a name="445"/>     c := factorial(2*i+1) * a
<a name="446"/>     s +:= b/c
<a name="447"/>     i +:= 1
<a name="448"/>  }
<a name="449"/>  return s
<a name="450"/>  end
<a name="451"/>
<a name="452"/>  public static fresnel2(x)
<a name="453"/>  local s,i,a,b,c
<a name="454"/>  s := 0
<a name="455"/>  i := 0
<a name="456"/>  while i &lt; 40 do {
<a name="457"/>     a := 4.0*i+1.0
<a name="458"/>     b := ((-1)^i) * (x^a)
<a name="459"/>     c := factorial(2*i) * a
<a name="460"/>     s +:= b/c
<a name="461"/>     i +:= 1
<a name="462"/>  }
<a name="463"/>  return s
<a name="464"/>  end
<a name="465"/>end
</pre></body></html>
