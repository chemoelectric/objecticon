<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>misc.icn</title></head><body><pre>
<a name="1"/>package util
<a name="2"/>
<a name="3"/>import
<a name="4"/>   lang(Text,callable),
<a name="5"/>   ipl.lists(ldel1),
<a name="6"/>   ipl.pdco(Set),
<a name="7"/>   posix(System)
<a name="8"/>
<a name="9"/>
<a name="10"/>#
<a name="11"/># Succeed iff the sequence generated by `&amp;features` contains the given
<a name="12"/># string.
<a name="13"/>#
<a name="14"/>procedure has_feature(x)
<a name="15"/>   static s
<a name="16"/>   initial
<a name="17"/>      s := Set{ &amp;features }
<a name="18"/>   succeed member(s, x)
<a name="19"/>end
<a name="20"/>
<a name="21"/>#
<a name="22"/># Convenient procedure to set `&amp;why` to the given string and fail.
<a name="23"/>#
<a name="24"/>procedure error(s)
<a name="25"/>   &amp;why := s
<a name="26"/>end
<a name="27"/>
<a name="28"/>#
<a name="29"/># Like `error`, but if `s` is `&amp;null`, succeed with `v`; otherwise set
<a name="30"/># `&amp;why` and fail.
<a name="31"/>#
<a name="32"/># This is useful in procedures which accumulate a possible error
<a name="33"/># condition.
<a name="34"/>#
<a name="35"/>procedure error_if(s, v)
<a name="36"/>   if /s then
<a name="37"/>      return v
<a name="38"/>   &amp;why := s
<a name="39"/>end
<a name="40"/>
<a name="41"/>#
<a name="42"/># Extract an error code number from `&amp;why`.
<a name="43"/>#
<a name="44"/># If `&amp;why` was set by a native method which failed due to an error
<a name="45"/># which has a corresponding error code number (usually the value of
<a name="46"/># errno), then it may set `&amp;why` to a string in a format which
<a name="47"/># includes that number.  This procedure parses the string and extracts
<a name="48"/># the value.  `k` is optional and matches the name of the error
<a name="49"/># variable; if omitted then any variable matches.
<a name="50"/>#
<a name="51"/>procedure errno(k)
<a name="52"/>   local i
<a name="53"/>   &amp;why ? every tab(upto('(') + 1) &amp;
<a name="54"/>      (if /k then tab(many(&amp;letters ++ &amp;digits ++ '_\-')) else =k) &amp;
<a name="55"/>      ="=" &amp;
<a name="56"/>      i := integer(tab(many(&amp;digits ++ '+\-'))) &amp;
<a name="57"/>      any(')')
<a name="58"/>   do
<a name="59"/>      suspend i
<a name="60"/>end
<a name="61"/>
<a name="62"/># Invoke co-expression `e`, generating its results, in such a way that
<a name="63"/># changes to `var` made by `e` will not be seen by the caller, and
<a name="64"/># vice versa.
<a name="65"/>#
<a name="66"/># :Parameters :
<a name="67"/># :  `e` - a co-expression to evaluate
<a name="68"/># :  `var` - a co-expression generating a global variable.
<a name="69"/># :  `i` - an optional initial value for the global variable
<a name="70"/>#        within e
<a name="71"/>#
<a name="72"/># Example :-
<a name="73"/># ~
<a name="74"/>#   # Cleanup some io stuff, without affecting global vars g.
<a name="75"/>#   save_var{ io_cleanup(), g }
<a name="76"/># ~
<a name="77"/>procedure save_var(e, var, i)
<a name="78"/>   suspend save_state(e, VarState(var, i))
<a name="79"/>end
<a name="80"/>
<a name="81"/>#
<a name="82"/># A common case, having the same effect as `save_state(e, WhyState())`.
<a name="83"/>#
<a name="84"/>procedure save_why(e)
<a name="85"/>   suspend save_state(e, WhyState())
<a name="86"/>end
<a name="87"/>
<a name="88"/>#
<a name="89"/># This function saves `&amp;why` before evaluating `e`.  If `e` succeeds,
<a name="90"/># `&amp;why` is restored, and the result returned; otherwise `&amp;why` is not
<a name="91"/># restored and the procedure fails.
<a name="92"/>#
<a name="93"/>procedure protect_why(e)
<a name="94"/>   local t
<a name="95"/>   t := &amp;why
<a name="96"/>   return 1(@e, &amp;why := t)
<a name="97"/>end
<a name="98"/>
<a name="99"/>#
<a name="100"/># Produce a string showing a min, max range (one of the two params may
<a name="101"/># be &amp;null).
<a name="102"/>#
<a name="103"/>procedure range_string(min, max)
<a name="104"/>   local s
<a name="105"/>   s := "("
<a name="106"/>   if \min then
<a name="107"/>      s ||:= "&gt;= " || min
<a name="108"/>   if \max then {
<a name="109"/>      if \min then
<a name="110"/>         s ||:= " and "
<a name="111"/>      s ||:= "&lt;= " || max
<a name="112"/>   }
<a name="113"/>   s ||:= ")"
<a name="114"/>   return s
<a name="115"/>end
<a name="116"/>
<a name="117"/>#
<a name="118"/># Convert to an integer or signal a runtime error
<a name="119"/>#
<a name="120"/>procedure need_integer(x, min, max)
<a name="121"/>   x := integer(x) | runerr(101, x)
<a name="122"/>   if x &lt; \min | x &gt; \max then
<a name="123"/>      runerr("Integer value out of valid range " || range_string(min, max), x)
<a name="124"/>   return x
<a name="125"/>end
<a name="126"/>
<a name="127"/>#
<a name="128"/># Convert to a real or signal a runtime error
<a name="129"/>#
<a name="130"/>procedure need_real(x, min, max)
<a name="131"/>   x := real(x) | runerr(102, x)
<a name="132"/>   if x &lt; \min | x &gt; \max then
<a name="133"/>      runerr("Real value out of valid range " || range_string(min, max), x)
<a name="134"/>   return x
<a name="135"/>end
<a name="136"/>
<a name="137"/>#
<a name="138"/># Convert to a numeric (real or integer) or signal a runtime error
<a name="139"/>#
<a name="140"/>procedure need_numeric(x, min, max)
<a name="141"/>   x := numeric(x) | runerr(102, x)
<a name="142"/>   if x &lt; \min | x &gt; \max then
<a name="143"/>      runerr("Numeric value out of valid range " || range_string(min, max), x)
<a name="144"/>   return x
<a name="145"/>end
<a name="146"/>
<a name="147"/>#
<a name="148"/># Convert to a string or signal a runtime error
<a name="149"/>#
<a name="150"/>procedure need_string(x)
<a name="151"/>   return string(x) | runerr(103, x)
<a name="152"/>end
<a name="153"/>
<a name="154"/>#
<a name="155"/># Convert to a ucs or signal a runtime error
<a name="156"/>#
<a name="157"/>procedure need_ucs(x)
<a name="158"/>   return ucs(x) | runerr(128, x)
<a name="159"/>end
<a name="160"/>
<a name="161"/>#
<a name="162"/># Convert to text (string or ucs) or signal a runtime error
<a name="163"/>#
<a name="164"/>procedure need_text(x)
<a name="165"/>   return text(x) | runerr(129, x)
<a name="166"/>end
<a name="167"/>
<a name="168"/>#
<a name="169"/># Convert to a cset or signal a runtime error
<a name="170"/>#
<a name="171"/>procedure need_cset(x)
<a name="172"/>   return cset(x) | runerr(104, x)
<a name="173"/>end
<a name="174"/>
<a name="175"/>#
<a name="176"/># Check that x is a list, signalling a runtime error otherwise.
<a name="177"/>#
<a name="178"/>procedure need_list(x)
<a name="179"/>   type(x) == "list" | runerr(108, x)
<a name="180"/>   return x
<a name="181"/>end
<a name="182"/>
<a name="183"/>#
<a name="184"/># Check that x is a set, signalling a runtime error otherwise.
<a name="185"/>#
<a name="186"/>procedure need_set(x)
<a name="187"/>   type(x) == "set" | runerr(119, x)
<a name="188"/>   return x
<a name="189"/>end
<a name="190"/>
<a name="191"/>#
<a name="192"/># Check that x is a table, signalling a runtime error otherwise.
<a name="193"/>#
<a name="194"/>procedure need_table(x)
<a name="195"/>   type(x) == "table" | runerr(124, x)
<a name="196"/>   return x
<a name="197"/>end
<a name="198"/>
<a name="199"/>#
<a name="200"/># Check that x is a co-expression, signalling a runtime error otherwise.
<a name="201"/>#
<a name="202"/>procedure need_coexpression(x)
<a name="203"/>   type(x) == "co-expression" | runerr(118, x)
<a name="204"/>   return x
<a name="205"/>end
<a name="206"/>
<a name="207"/>#
<a name="208"/># Check that x is a weak reference, signalling a runtime error otherwise.
<a name="209"/>#
<a name="210"/>procedure need_weakref(x)
<a name="211"/>   type(x) == "weakref" | runerr(630, x)
<a name="212"/>   return x
<a name="213"/>end
<a name="214"/>
<a name="215"/>#
<a name="216"/># Check that x is a class, signalling a runtime error otherwise.
<a name="217"/>#
<a name="218"/>procedure need_class(x)
<a name="219"/>   type(x) == "class" | runerr(603, x)
<a name="220"/>   return x
<a name="221"/>end
<a name="222"/>
<a name="223"/>#
<a name="224"/># Check that x is a record constructor, signalling a runtime error otherwise.
<a name="225"/>#
<a name="226"/>procedure need_constructor(x)
<a name="227"/>   type(x) == "constructor" | runerr(604, x)
<a name="228"/>   return x
<a name="229"/>end
<a name="230"/>
<a name="231"/>#
<a name="232"/># Check that x is an instance of cl (a class or constructor),
<a name="233"/># signalling a runtime error otherwise.
<a name="234"/>#
<a name="235"/>procedure need_instance(x, cl)
<a name="236"/>   is(x, cl) | runerr(image(cl) ? (tab(upto(' ') + 1), tab(0) || " expected"), x)
<a name="237"/>   return x
<a name="238"/>end
<a name="239"/>
<a name="240"/>#
<a name="241"/># Convert to a callable or signal a runtime error
<a name="242"/>#
<a name="243"/># :Parameters :
<a name="244"/># :  `x` - the thing to convert
<a name="245"/># :  `n` - the optional number of args for an operator
<a name="246"/>#
<a name="247"/>procedure need_callable(x, n)
<a name="248"/>   return callable(x, n) | runerr("Callable expected", x)
<a name="249"/>end
<a name="250"/>
<a name="251"/>#
<a name="252"/># Convert and return `s1` so that it has the same type as `s2`, which
<a name="253"/># is assumed to be string or ucs, giving a runerr if conversion is not
<a name="254"/># possible.
<a name="255"/>#
<a name="256"/>procedure same_string_type(s1, s2)
<a name="257"/>   return if type(s2) == "string" then
<a name="258"/>      need_string(s1)
<a name="259"/>   else
<a name="260"/>      need_ucs(s1)
<a name="261"/>end
<a name="262"/>
<a name="263"/>#
<a name="264"/># This is like `same_string_type`, but if `s2` is a `ucs` and `s1` is
<a name="265"/># an ascii string, then `s1` is returned as-is, rather than converted
<a name="266"/># to a `ucs`.
<a name="267"/>#
<a name="268"/>procedure similar_string_type(s1, s2)
<a name="269"/>   return if type(s2) == "string" then
<a name="270"/>      need_string(s1)
<a name="271"/>   else if Text.is_ascii_string(s1) then
<a name="272"/>      s1
<a name="273"/>   else
<a name="274"/>      need_ucs(s1)
<a name="275"/>end
<a name="276"/>
<a name="277"/>#
<a name="278"/># Stores a list of cleanup expressions to be run.  See `use` and `clean`.
<a name="279"/>#
<a name="280"/>package global cleanup
<a name="281"/>
<a name="282"/>#
<a name="283"/># This procedure is used to automatically close a `Stream` or other
<a name="284"/># resource.  The first expression `e1` produces the resource, the
<a name="285"/># second `e2` uses it, and the third expression `e3` then closes it.
<a name="286"/># The result of `e2` is returned, if all three expressions succeed,
<a name="287"/># otherwise the procedure fails.
<a name="288"/>#
<a name="289"/># Each co-expression is optional, but if `e1` is omitted `e3` must be
<a name="290"/># provided; otherwise `e3` defaults to calling `close` on the
<a name="291"/># resource.
<a name="292"/>#
<a name="293"/># Example :-
<a name="294"/># ~
<a name="295"/>#     s := use { f := open("some.txt"),
<a name="296"/>#                do_something_with(f) }
<a name="297"/># ~
<a name="298"/>#
<a name="299"/># See also `clean()` below.
<a name="300"/>#
<a name="301"/>procedure use(e1, e2, e3)
<a name="302"/>   local x, v, f
<a name="303"/>   /e1 | (x := @e1) | fail
<a name="304"/>   if \cleanup &amp; \e2 then {
<a name="305"/>      /e3 := create x.close()
<a name="306"/>      push(cleanup, e3)
<a name="307"/>      (v := @e2) | (f := &amp;why)
<a name="308"/>      ldel1(cleanup, e3)
<a name="309"/>      @e3 | (/f := &amp;why)
<a name="310"/>   } else {
<a name="311"/>      /e2 | (v := @e2) | (f := &amp;why)
<a name="312"/>      (if /e3 then x.close() else @e3) | (/f := &amp;why)
<a name="313"/>   }      
<a name="314"/>   return error_if(f, v)
<a name="315"/>end
<a name="316"/>
<a name="317"/>#
<a name="318"/># This is like `use()`, but generates all results from `e2`.  So
<a name="319"/># unless the sequence is generated to its end, then the cleanup code
<a name="320"/># `e3` will not be run; in that case, the call should be wrapped in
<a name="321"/># `clean()`.
<a name="322"/>#
<a name="323"/>procedure use_seq(e1, e2, e3)
<a name="324"/>   local x
<a name="325"/>   /e1 | (x := @e1) | fail
<a name="326"/>   if \cleanup &amp; \e2 then {
<a name="327"/>      /e3 := create x.close()
<a name="328"/>      push(cleanup, e3)
<a name="329"/>      suspend |@e2
<a name="330"/>      ldel1(cleanup, e3)
<a name="331"/>      @e3
<a name="332"/>   } else {
<a name="333"/>      suspend |@\e2
<a name="334"/>      if /e3 then x.close() else @e3
<a name="335"/>   }
<a name="336"/>end
<a name="337"/>
<a name="338"/>#
<a name="339"/># This procedure can be used in conjunction with `use` to ensure that
<a name="340"/># all cleanup expressions are performed.  `e` is evaluated for its
<a name="341"/># first result only.  Then any outstanding cleanup expressions are
<a name="342"/># performed.  If `e` failed, or any of the cleanup expressions failed,
<a name="343"/># then the procedure fails; otherwise the first result of `e` is
<a name="344"/># returned.
<a name="345"/>#
<a name="346"/>procedure clean(e)
<a name="347"/>   local t, v, f, x
<a name="348"/>   t := cleanup
<a name="349"/>   cleanup := []
<a name="350"/>   (v := @e) | (f := &amp;why)
<a name="351"/>   while x := pop(cleanup) do
<a name="352"/>      @x | (/f := &amp;why)
<a name="353"/>   cleanup := t
<a name="354"/>   return error_if(f, v)
<a name="355"/>end
<a name="356"/>
<a name="357"/>#
<a name="358"/># Convert an index position based on a length, to an absolute index,
<a name="359"/># using Icon semantics of indices &lt;= 0.  Fails if pos is out of range.
<a name="360"/>#
<a name="361"/>procedure cvpos(pos, len)
<a name="362"/>   pos := need_integer(pos)
<a name="363"/>   len := need_integer(len)
<a name="364"/>   if pos &lt; -len | pos &gt; len + 1 then
<a name="365"/>      fail
<a name="366"/>   return if pos &gt; 0 then
<a name="367"/>      pos
<a name="368"/>   else
<a name="369"/>      pos + len + 1
<a name="370"/>end
<a name="371"/>
<a name="372"/>#
<a name="373"/># Convert an index position based on a length, to an absolute index,
<a name="374"/># using Icon semantics of indices &lt;= 0.  Fails if pos is out of range,
<a name="375"/># or points at the end of the range (pos = 0 or equivalent).
<a name="376"/>#
<a name="377"/>procedure cvpos_item(pos, len)
<a name="378"/>   pos := need_integer(pos)
<a name="379"/>   len := need_integer(len)
<a name="380"/>   if pos &lt; -len | pos &gt; len | pos = 0 then
<a name="381"/>      fail
<a name="382"/>   return if pos &gt; 0 then
<a name="383"/>      pos
<a name="384"/>   else
<a name="385"/>      pos + len + 1
<a name="386"/>end
<a name="387"/>
<a name="388"/>package record Slice(lo, hi)
<a name="389"/>
<a name="390"/>#
<a name="391"/># Normalize an icon slice specification (along the lines of
<a name="392"/># s[pos1:pos2]).  Returned is a record with lo, hi elements, giving
<a name="393"/># the extent of the slice.  Failure occurs if pos1 or pos2 are out of
<a name="394"/># range.
<a name="395"/>#
<a name="396"/>procedure cvslice(pos1, pos2, len)
<a name="397"/>   pos1 := cvpos(pos1, len) | fail
<a name="398"/>   pos2 := cvpos(pos2, len) | fail
<a name="399"/>   if pos1 &gt; pos2 then
<a name="400"/>      pos1 :=: pos2
<a name="401"/>   return Slice(pos1, pos2)
<a name="402"/>end
<a name="403"/>
<a name="404"/>#
<a name="405"/># Like cvslice above, but pos1 defaults to 1, pos2 to 0.
<a name="406"/>#
<a name="407"/>procedure cvslice_def(pos1, pos2, len)
<a name="408"/>   /pos1 := 1
<a name="409"/>   /pos2 := 0
<a name="410"/>   return cvslice(pos1, pos2, len)
<a name="411"/>end
<a name="412"/>
<a name="413"/>#
<a name="414"/># Helper procedure to return the index of the first element returned
<a name="415"/># by an iteration using the builtin `forward()` function, with
<a name="416"/># subsequent elements given by increasing this value by 1 each time.
<a name="417"/>#
<a name="418"/># :Parameters :
<a name="419"/># :  `i` - the starting position, default 1
<a name="420"/># :  `len` - the list length
<a name="421"/>#
<a name="422"/>procedure first_forward(i, len)
<a name="423"/>   /i := 1
<a name="424"/>   return cvpos_item(i, len)
<a name="425"/>end
<a name="426"/>
<a name="427"/>#
<a name="428"/># Helper procedure to return the index of the first element returned
<a name="429"/># in an iteration using the builtin `back()` function.  A negative
<a name="430"/># index is returned, with subsequent elements given by decreasing this
<a name="431"/># value by 1 each time.
<a name="432"/>#
<a name="433"/># :Parameters :
<a name="434"/># :  `i` - the starting position, default 0
<a name="435"/># :  `len` - the list length
<a name="436"/>#
<a name="437"/>procedure first_back(i, len)
<a name="438"/>   i := need_integer(\i) | 0
<a name="439"/>   return cvpos_item(i - 1, len) - len - 1
<a name="440"/>end
<a name="441"/>
<a name="442"/>#
<a name="443"/># This class can be used by a class which has various capabilities or
<a name="444"/># permitted operations, and needs to give clients a simple way of
<a name="445"/># seeing what it is capable of, by way of an integer bit flag
<a name="446"/># combination.
<a name="447"/>#
<a name="448"/>abstract class HasMode()
<a name="449"/>   #
<a name="450"/>   # Succeed iff the object's mode has all the flags in `c`
<a name="451"/>   #
<a name="452"/>   public can(c)
<a name="453"/>      succeed iand(get_mode(), c) = c
<a name="454"/>   end
<a name="455"/>
<a name="456"/>   # This method is implemented to return the integer bit flag
<a name="457"/>   # describing the object's capabilities.
<a name="458"/>   #
<a name="459"/>   public abstract get_mode()
<a name="460"/>end
<a name="461"/>
<a name="462"/>#
<a name="463"/># This class adds a close method to a class.  The default
<a name="464"/># implementation just returns `self`.
<a name="465"/>#
<a name="466"/>abstract class HasClose()
<a name="467"/>   #
<a name="468"/>   # Close the instance and free any resources it may have used.
<a name="469"/>   # After being closed, any further calls on the instance may stop
<a name="470"/>   # with a runtime error.  Fails on error, setting `&amp;why`; returns
<a name="471"/>   # `self` on success.
<a name="472"/>   #
<a name="473"/>   public close()
<a name="474"/>      link
<a name="475"/>   end
<a name="476"/>end
<a name="477"/>
<a name="478"/>#
<a name="479"/># This class simply adds a close_underlying_flag to a class.
<a name="480"/>#
<a name="481"/>abstract class HasCloseUnderlying()
<a name="482"/>   protected
<a name="483"/>      close_underlying_flag
<a name="484"/>
<a name="485"/>   #
<a name="486"/>   # If set, the stream will close any underlying `Stream`s when it is closed.
<a name="487"/>   #
<a name="488"/>   public set_close_underlying(s)
<a name="489"/>      self.close_underlying_flag := need_flag(s)
<a name="490"/>      link
<a name="491"/>   end
<a name="492"/>end
<a name="493"/>
<a name="494"/>#
<a name="495"/># Useful procedure to close a list of objects with `close` methods.
<a name="496"/>#
<a name="497"/>procedure lclose(l)
<a name="498"/>   local e, f
<a name="499"/>   every e := !l do
<a name="500"/>      e.close() | (f := &amp;why)
<a name="501"/>   return error_if(f)
<a name="502"/>end
<a name="503"/>
<a name="504"/>#
<a name="505"/># This class is used to save and restore some arbitrary global state.
<a name="506"/>#
<a name="507"/>abstract class State()
<a name="508"/>   # Called several times to swap the saved state with the global state
<a name="509"/>   public abstract swap()
<a name="510"/>end
<a name="511"/>
<a name="512"/>#
<a name="513"/># A `State` instance which saves an arbitrary global variable,
<a name="514"/># specified as a co-expression generating that variable.  An initial
<a name="515"/># value may also be specified.
<a name="516"/>#
<a name="517"/>class VarState(State)
<a name="518"/>   private var, t
<a name="519"/>
<a name="520"/>   public override swap()
<a name="521"/>      !var :=: t
<a name="522"/>   end
<a name="523"/>
<a name="524"/>   public new(var, i)
<a name="525"/>      self.var := var
<a name="526"/>      self.t := i
<a name="527"/>      return
<a name="528"/>   end
<a name="529"/>end
<a name="530"/>
<a name="531"/># A `State` which saves &amp;subject and &amp;pos.  Initial values of &amp;subject
<a name="532"/># and &amp;pos may optionally be specified.
<a name="533"/>#
<a name="534"/>class ScanState(State)
<a name="535"/>   private s, p
<a name="536"/>
<a name="537"/>   public override swap()
<a name="538"/>      local t
<a name="539"/>      t := &amp;pos
<a name="540"/>      &amp;subject :=: s
<a name="541"/>      &amp;pos := p
<a name="542"/>      p := t
<a name="543"/>   end
<a name="544"/>
<a name="545"/>   public new(is, ip)
<a name="546"/>      self.s := need_text(\is) | ""
<a name="547"/>      self.p := need_integer(\ip) | 1
<a name="548"/>      return
<a name="549"/>   end
<a name="550"/>end
<a name="551"/>
<a name="552"/>#
<a name="553"/># A `State` which saves &amp;pos.  An initial value may be specified.
<a name="554"/>#
<a name="555"/>class PosState(State)
<a name="556"/>   private p
<a name="557"/>
<a name="558"/>   public override swap()
<a name="559"/>      &amp;pos :=: p
<a name="560"/>   end
<a name="561"/>
<a name="562"/>   public new(i)
<a name="563"/>      self.p := need_integer(\i) | 1
<a name="564"/>      return
<a name="565"/>   end
<a name="566"/>end
<a name="567"/>
<a name="568"/>#
<a name="569"/># A `State` to save the global cleanup list used by `clean` and `use`.
<a name="570"/>#
<a name="571"/>class CleanupState(State)
<a name="572"/>   private t
<a name="573"/>
<a name="574"/>   public override swap()
<a name="575"/>      cleanup :=: t
<a name="576"/>   end
<a name="577"/>end
<a name="578"/>
<a name="579"/>#
<a name="580"/># A `State` to save `&amp;why`.
<a name="581"/>#
<a name="582"/>class WhyState(State)
<a name="583"/>   private w
<a name="584"/>
<a name="585"/>   public override swap()
<a name="586"/>      &amp;why :=: w
<a name="587"/>   end
<a name="588"/>
<a name="589"/>   public new(i)
<a name="590"/>      self.w := need_text(\i) | ""
<a name="591"/>      return
<a name="592"/>   end
<a name="593"/>end
<a name="594"/>
<a name="595"/>#
<a name="596"/># A `State` to save `&amp;trace`.
<a name="597"/>#
<a name="598"/>class TraceState(State)
<a name="599"/>   private t
<a name="600"/>
<a name="601"/>   public override swap()
<a name="602"/>      &amp;trace :=: t
<a name="603"/>   end
<a name="604"/>
<a name="605"/>   public new(i)
<a name="606"/>      self.t := need_integer(\i) | 0
<a name="607"/>      return
<a name="608"/>   end
<a name="609"/>end
<a name="610"/>
<a name="611"/>#
<a name="612"/># A `State` to save `&amp;random`.  The default initial value is 0.
<a name="613"/>#
<a name="614"/>class RandomState(State)
<a name="615"/>   private t
<a name="616"/>
<a name="617"/>   public override swap()
<a name="618"/>      &amp;random :=: t
<a name="619"/>   end
<a name="620"/>
<a name="621"/>   public new(i)
<a name="622"/>      self.t := need_integer(\i) | 0
<a name="623"/>      return
<a name="624"/>   end
<a name="625"/>end
<a name="626"/>
<a name="627"/>#
<a name="628"/># A `State` to save `&amp;handler`.  An initial value may be specified.
<a name="629"/>#
<a name="630"/>class HandlerState(State)
<a name="631"/>   private h
<a name="632"/>
<a name="633"/>   public override swap()
<a name="634"/>      &amp;handler :=: h
<a name="635"/>   end
<a name="636"/>
<a name="637"/>   public new(i)
<a name="638"/>      self.h := need_coexpression(\i)
<a name="639"/>      return
<a name="640"/>   end
<a name="641"/>end
<a name="642"/>
<a name="643"/>#
<a name="644"/># A `State` with `swap` implemented by a function.
<a name="645"/>#
<a name="646"/>class FuncState(State)
<a name="647"/>   private const f
<a name="648"/>
<a name="649"/>   public override swap()
<a name="650"/>      f()
<a name="651"/>   end
<a name="652"/>
<a name="653"/>   public new(f)
<a name="654"/>      self.f := need_callable(f)
<a name="655"/>      return
<a name="656"/>   end
<a name="657"/>end
<a name="658"/>
<a name="659"/>
<a name="660"/>#
<a name="661"/># A `State` which just brings a list of several other `State`s together.
<a name="662"/>#
<a name="663"/>class States(State)
<a name="664"/>   private const l
<a name="665"/>
<a name="666"/>   public override swap()
<a name="667"/>      every (!l).swap()
<a name="668"/>   end
<a name="669"/>
<a name="670"/>   public new(l[])
<a name="671"/>      self.l := l
<a name="672"/>      return
<a name="673"/>   end
<a name="674"/>end
<a name="675"/>
<a name="676"/>#
<a name="677"/># Evaluate the given co-expression `e`, suspending its results, whilst
<a name="678"/># invoking function `f` before and after each result of `e` is
<a name="679"/># generated, in order to save and restore some particular state.
<a name="680"/>#
<a name="681"/># `f` may be an instance of `State`, in which case its `swap` method
<a name="682"/># is called instead.
<a name="683"/>#
<a name="684"/>procedure save_state(e, f)
<a name="685"/>   f := if is(f, State) then f.swap else need_callable(f)
<a name="686"/>   f()
<a name="687"/>   suspend 1(|@e, { f() ; } ) do f()
<a name="688"/>   f()
<a name="689"/>end
<a name="690"/>
<a name="691"/>#
<a name="692"/># Return a non-empty string from the environment.
<a name="693"/>#
<a name="694"/>procedure env_string(s)
<a name="695"/>   return "" ~== System.getenv(s)
<a name="696"/>end
<a name="697"/>
<a name="698"/>#
<a name="699"/># Return a valid flag value from the environment.
<a name="700"/>#
<a name="701"/>procedure env_flag(s)
<a name="702"/>   local v
<a name="703"/>   v := env_string(s) | fail
<a name="704"/>   v := flag(v) | runerr("Flag value expected for " || s, v)
<a name="705"/>   return v
<a name="706"/>end
<a name="707"/>
<a name="708"/>#
<a name="709"/># Get a real-valued environment variable.  Fails if the variable isn't
<a name="710"/># defined, returns the real value otherwise.  `min` and `max` provide
<a name="711"/># optional bounds checking.
<a name="712"/>#
<a name="713"/>procedure env_real(s, min, max)
<a name="714"/>   local v
<a name="715"/>   v := env_string(s) | fail
<a name="716"/>   v := real(v) | runerr("Real value expected for " || s, v)
<a name="717"/>   if v &lt; \min | v &gt; \max then
<a name="718"/>      runerr("Value of " || s || " out of valid range " || range_string(min, max), v)
<a name="719"/>   return v
<a name="720"/>end
<a name="721"/>
<a name="722"/>#
<a name="723"/># Get an integer-valued environment variable.  Fails if the variable isn't
<a name="724"/># defined, returns the integer value otherwise.  `min` and `max` provide
<a name="725"/># optional bounds checking.
<a name="726"/>#
<a name="727"/>procedure env_int(s, min, max)
<a name="728"/>   local v
<a name="729"/>   v := env_string(s) | fail
<a name="730"/>   v := integer(v) | runerr("Integer value expected for " || s, v)
<a name="731"/>   if v &lt; \min | v &gt; \max then
<a name="732"/>      runerr("Value of " || s || " out of valid range " || range_string(min, max), v)
<a name="733"/>   return v
<a name="734"/>end
<a name="735"/>
<a name="736"/>#
<a name="737"/># Helper function to convert an optional parameter specified in a pdco
<a name="738"/># invocation.  `v` is the parameter (the value itself or a
<a name="739"/># coexpression giving the value, or &amp;null).
<a name="740"/>#
<a name="741"/># If v is a coexpression and it fails to produce a result, the
<a name="742"/># procedure fails.
<a name="743"/>#
<a name="744"/>procedure ce_param(v)
<a name="745"/>   return if type(v) == "co-expression" then @v else v
<a name="746"/>end
</pre></body></html>
