package io

import lang, util

# This stream wraps another stream (normally a {SocketStream}).  The
# {in} and {out} methods are invoked from the co-expression of the
# owning {Task}.  Those methods activate the {Task}'s {Scheduler}'s
# co-expression.  The stream's co-expression is re-activated only when
# the {Scheduler} determines the socket is ready for i/o (or has timed
# out).
#
class TaskStream(Stream)
   private readable
      timeout,
      other,
      task

   # Use the owning {Task} to poll for some i/o.  The given parameter
   # should be {Poll.IN} or {Poll.OUT} depending on whether we want to
   # be resumed on ready input or output respectively.  Fails on
   # timeout or error.
   #
   public poll(x)
      local r
      r := task.poll([other, x], timeout) | fail
      if /r then return error("Timeout")
      r[1] = x | return error("Socket error")
      return
   end

   public in(n)
      poll(Poll.IN) | fail
      return other.in(n)
   end

   public out(s)
      poll(Poll.OUT) | fail
      return other.out(s)
   end

   public close()
      return other.close()
   end

   public eof()
      return other.eof()
   end

   public get_mode()
      return other.get_mode()
   end

   public seek(offset)
      return other.seek(offset)
   end

   public tell()
      return other.tell()
   end

   public truncate(len)
      return other.truncate(len)
   end

   public new(other, task, timeout)
      self.other := other
      self.task := task
      self.timeout := timeout
      return
   end
end

class Task()
   public const
      scheduler
   private readable
      coex,
      sleep_until,
      last_sleep,
      poll_until,
      poll_req
   package readable
      state,
      active,
      poll_err,
      poll_res

   # If a task is currently sleeping, then this alters the time it
   # will sleep for, behaving as though the original call to {sleep}
   # had given {n} as its parameter.  Providing {0} as a parameter
   # will make the task ready to be activated again immediately.
   #
   public change_sleep(n)
      sleep_until := \last_sleep + n
   end

   # Succeed iff the task is currently active.
   #
   public is_active()
      return .\active
   end

   # Succeed iff the task is the current task.  Note that a task may
   # be active, but not the current task, since a task may itself
   # invoke {Scheduler.work} in order to activate another task, in a
   # nested fashion.  This may happen for example when a task shows a
   # modal dialog, and hence calls {Scheduler.work} via the dispatcher
   # event loop.
   #
   public is_current()
      return self === scheduler.curr_task
   end

   # Suspend this task, which must be the currently scheduled task, in
   # order to carry out a {DescStream.poll}.  The parameters and
   # result are in the same form as for {DescStream.poll}.  The
   # difference between this and {DescStream.poll} is that the
   # scheduler will suspend this task whilst the poll is taking place,
   # whereas {DescStream.poll} will block.  If {timeout} is zero, then
   # there is no advantage in using this method, and {DescStream.poll}
   # is preferable.
   #
   # @param l A list of alternating {DescStream}, flag (from {Poll})
   # @        pairs.
   # @param timeout The optional timeout
   #
   public poll(l, timeout)
      self === scheduler.curr_task | runerr("poll called on task which is not current")
      self.coex := &current
      self.poll_until := (Prog.get_runtime_millis() + \timeout) | &null
      self.poll_req := l
      scheduler.now_poll(self)
      return if \poll_err then
         error(poll_err)
      else
         .self.poll_res
   end

   # Suspend this task, which must be the currently scheduled task,
   # for {n} milliseconds.
   #
   # @param n The time to wait for.
   #
   public sleep(n)
      self === scheduler.curr_task | runerr("sleep called on task which is not current")
      self.coex := &current
      last_sleep := Prog.get_runtime_millis()
      sleep_until := last_sleep + n
      scheduler.now_sleep(self)
   end

   # Suspend this task, which must be the currently scheduled task,
   # placing it immediately into the ready state in the scheduler.
   #
   public yield()
      self === scheduler.curr_task | runerr("yield called on task which is not current")
      self.coex := &current
      scheduler.now_yield(self)
   end

   # Suspend this task, which must be the currently scheduled task,
   # but do not resume it.  Control reverts to the scheduler.  The
   # task may be subsequently restarted with {start}.  It is not
   # normally necessary to call this method, since it has the same
   # effect as suspending the task's co-expression using {suspend},
   # {fail}, or {return}.
   #
   public revert()
      self === scheduler.curr_task | runerr("sleep called on task which is not current")
      scheduler.now_revert()
   end

   # Start the task, which may not be currently active.  If the task
   # was previously stopped in a particular state (eg sleeping), then
   # it continues from that same state.
   #
   public start()
      /active | runerr("start called on a currently active task")
      scheduler.start(self)
   end

   # Stop the task, which may not be currently active.  This prevents
   # the scheduler from activating it.  Its present state is
   # remembered, and it may be started again in that state using
   # {start}.
   #
   public stop()
      /active | runerr("stop called on a currently active task")
      scheduler.stop(self)
   end

   #
   # Create a new {Task}.
   #
   # @param scheduler The {Scheduler} to use to activate the task.
   # @param coex The co-expression body of the task.
   #
   public new(scheduler, coex)
      self.coex := coex
      self.scheduler := scheduler
      return
   end
end

class Scheduler()
   private readable 
      coex,
      curr_task

   private
      ready,
      sleeping,
      polling
   
   public new()
      ready := set()
      sleeping := set()
      polling := set()
      return
   end

   package start(t)
      /t.state := ready
      insert(t.state, t)
   end

   package stop(t)
      delete(\t.state, t)
   end

   private set_state(t, x)
      delete(\t.state, t)
      t.state := x
      insert(t.state, t)
   end

   package now_sleep(t)
      \coex | syserr("now_sleep with null coex")
      set_state(t, sleeping)
      coact(, coex)
   end

   package now_poll(t)
      \coex | syserr("now_poll with null coex")
      set_state(t, polling)
      coact(, coex)
   end

   package now_yield(t)
      \coex | syserr("now_yield with null coex")
      set_state(t, ready)
      coact(, coex)
   end

   package now_revert()
      \coex | syserr("now_revert with null coex")
      coact(, coex)
   end

   #
   # Do some i/o work.  A maximum of {n} bits of work are done; the
   # default is 1.  If {n} is negative, work is done until no more is
   # ready.  Succeeds if any work was done; fails if no work was done.
   #
   public work(n)
      local r
      /n := 1
      until n = 0 do {
         do_work() | break
         r := 1
         n -:= 1
      }
      return \r
   end

   #
   # Test whether there are any tasks in the internal lists.
   #
   public empty()
      return not(*(ready | sleeping | polling) > 0)
   end

   private run(t)
      local sc, st
      delete(t.state, t)
      t.state := &null
      sc := coex
      st := curr_task
      coex := &current
      curr_task := t
      t.active := 1
      coact(, t.coex, &current)
      t.active := &null
      coex := sc
      curr_task := st
    end

   private do_work()
      local t, r, curr_time
      repeat {
         if t := ?ready then {
            run(t)
            return
         }

         if *sleeping > 0 then {
            curr_time := Prog.get_runtime_millis()
            every t := !sleeping do {
               if curr_time >= t.sleep_until then
                  set_state(t, ready)
            }
            if *ready > 0 then
               next
         }

         if *polling > 0 then {
            curr_time := Prog.get_runtime_millis()
            every t := !polling do {
               if r := DescStream.poll(t.poll_req, 0) then {
                  if /r then {
                     if curr_time >= \t.poll_until then {
                        set_state(t, ready)
                        t.poll_err := t.poll_res := &null
                     }
                  } else {
                     set_state(t, ready)
                     t.poll_err := &null
                     t.poll_res := r
                  }
               } else {
                  set_state(t, ready)
                  t.poll_err := &why
                  t.poll_res := &null
               }
            }
            if *ready > 0 then
               next
         }

         fail
      }
   end
end
