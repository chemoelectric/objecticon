#summary Specifying access to fields
<wiki:toc max_depth="3" />
= Field modifiers =
There are various modifiers which can be applied to a field.  Each modifier is described in detail in its own section.

== private ==
A private field can only be accessed from within a method in the same class as the field.

== public ==
A public field can be accessed from anywhere.

== package ==
A package field can only be accessed from within the same package as the field.

== protected ==
This varies slightly depending on whether we are accessing an instance field or a static field.

In the case of an non-static field, the caller must be a method in the implemented classes of the instance being accessed.  So, for example, consider the following tree of superclasses :-
{{{
   A
   |
   B    C
   \   / \
    \ /   \
     X     Y
}}}
Here, `X` has two superclasses, `B` and `C`.  `B` in turn has a superclass `A`, so `X`'s [Inheritance#Implemented_classes implemented classes] are `X, B, C, A`.  This means that any protected instance field in `X` could only be accessed from a method within those four classes.  A method in `Y`, would not be able to access the field in the instance of `X`, even if the field were defined in `C`, the common superclass of `X` and `Y` (in that case a method in `Y` _could_ access that field on an instance of `Y`).  This little example program illustrates this.
{{{
import io

class C()
   protected f

   public new(f)
      self.f := f
      return
   end
end

class X(C)
end

class Y(C)
   public try(o)
      write(o.f)
   end
end

procedure main()
   local x, y
   x := X(100)
   y := Y(99)
   y.try(y)   # Okay, writes 99
   y.try(x)   # Will lead to a runtime error...
end
}}}
In the case of a static field, the field being accessed must be in the implemented classes of the calling method's class.  So in the above example a method in `X` could access static protected fields in any of the classes `X, B, C, A`.

== static ==
This declares the field as static - for more information on what this means, see [Fields].

== const ==
Declaring a static field const means that it cannot be changed (ie, assigned to) after the class has been initialized, which is just after the class's static `init()` method has been called.  Therefore, static const fields can be initialized in `init()` and thereafter treated as constants, with any attempt to assign to them causing a runtime error.  For example

{{{
import io

class Maths()
   public static const PI

   private static init()
      PI := 3.14
   end
end

procedure main()
   write(Maths.PI) # Write 3.14
   Maths.PI := 3   # Runtime error
end
}}}

A `const` instance field is similar, and can be assigned to during instance initialization, but thereafter becomes fixed.  The class's `new()` method can be used to set initial values of the field.  For example

{{{
import io

class Employee()
   public const name, age

   public new(name, age)
      self.name := name
      self.age := age
      return
   end
end

procedure main()
   local e
   e := Employee("Mary", 30)
   write(e.name, ",", e.age)   # Writes Mary,30
   e.age := 25                 # Runtime error
end
}}}

A method cannot be declared `const`.

=== Substitution and constant folding ===
Fields which are declared `public static const`, and are assigned to a literal value (string, cset or numeric) in the `init()` method, normally have this literal value substituted for any use of the field in the program.  Thus the line `write(Maths.PI)` in the example above will generate the same code as the line `write(3.14)`.  This saves a field access at runtime, and also lets the translator apply constant folding on the substituted value.  Thus the expression `2 * Maths.PI * radius` would generate the same code as `6.28 * radius`.

== readable ==
The readable modifier must always be specified together with either the `private, package`, or `protected` modifier.  It indicates that the field is accessible in a read-only fashion, where it would otherwise be inaccessible, based on that other modifier.

So for example, consider the following class :-

{{{
import io

class X()
   private readable v

   public f()
      v := 100
   end
end

procedure main()
   local x
   x := X()
   x.f()
   write(x.v)   # Okay, prints 100
   x.v := 101   # Runtime error
end
}}}

The field `v` can be read and assigned to within `X`, but can only be read from outside of `X`.  Without the `readable` modifier, it would not be accessible at all outside of `X`, so the `write()` statement in `main()` would give a runtime error.

Note that a `public` field cannot be declared `readable`, because it is already readable everywhere.  Nor can a method be declared `readable`.

== final ==
Only an instance method can be declared `final`.  It indicates that the method cannot be overridden.  So, for example, the following will give an error during linking because the method `f()` in `Y` overrides `f()` in `X`, which is marked `final`.

{{{
class X()
   public final f()
   end
end

class Y(X)
   public f()
   end
end
}}}

A class can also be marked as `final`, and in this case it means that the class cannot be subclassed by another class.  So for example, this is not allowed :-

{{{
final class X()
   public f()
   end
end

class Y(X)
end
}}}

A static method cannot be `final` because `static` methods cannot be overridden, and a method cannot be marked `final` in a `final` class, because such a declaration would obviously be superfluous.

= Accessor methods =
Consider the following class :-
{{{
class Thing()
   private x

   public get_x()
      return x
   end

   public new()
      x := 99
      return
   end
end
}}}
At first glance this seems safe enough, but in fact it is possible to change the value of `x` from outside the class, as follows :-
{{{
import io

procedure main()
   local i
   i := Thing()
   i.get_x() := 100
   write(i.get_x())   # writes 100
end
}}}
This is because the `get_x()` method returns a reference to `x`, which can form the left side of an assignment.  Fortunately the problem is easily solved by explicitly dereferencing `x` using the unary `.` operator as follows :-
{{{
   public get_x()
      return .x
   end
}}}
The attempted assignment then generates a runtime error.  A nicer solution to this problem would be to make `x` a `private readable` variable and get rid of the `get_x()` method entirely.

Another potential access problem occurs when using structures such as lists, sets and tables.  Consider the following class :-
{{{
class Thing()
   private readable x

   public new()
      x := [1,2,3,4]
      return
   end
end
}}}
Unfortunately, although `x` cannot be assigned to from outside of the class, its contents can be changed :-
{{{
import io, lang

procedure main()
   local i
   i := Thing()
   put(i.x, 5)
   write(to_string(i.x))  # writes "list#1[1,2,3,4,5]"
end
}}}
One solution to this problem is to make `x` private and provide a method to generate its elements :-
{{{
import io, lang

class Thing()
   private x

   public gen_x()
      suspend .!x
   end

   public new()
      x := [1,2,3,4]
      return
   end
end

procedure main()
   local i
   i := Thing()
   every write(i.gen_x())  # writes 1,2,3,4 in turn
end
}}}
Note that we still have to dereference the generated elements before suspending them, otherwise they could be changed.

Another alternative would be to provided a method which simply returned a copy of `x`.