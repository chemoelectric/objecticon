#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package util

import lang, posix, io

# This class is a convenient way of creating a sub-process in a
# program.  It sets up a socket connection between the parent and
# child processes to allow them to communicate in a bi-directional
# fashion.
#
class Process(HasTask, HasBgProc)
   private readable
      e,
      sock

   #
   # Called by the parent process to start the child
   #
   public start()
      local l
      /pid | runerr("start() called out of sequence", self)
$ifdef _PLAN9
      l := FileStream.pipe(FileOpt9.OCEXEC, FileOpt9.OCEXEC) | fail
      pid := System.fork() | {
         save_why{ lclose(l) }
         fail
      }
      if pid > 0 then {
         # Parent
         sock := NonBlockStream(l[2],, 65536, 65536).
            set_write_on_close(NonBlockStream.BACKGROUND_FLUSH)
         l[1].close()
         return self
      } else {
         # Child
         pid := task := &null
         sock := NonBlockStream(l[1],, 65536, 65536).
            set_write_on_close(NonBlockStream.BACKGROUND_FLUSH)
         l[2].close()
         @e
         close_sock()
         exit(0)
      }
$else
      l := SocketStream.socketpair() | fail
      (l[1].dflag(DescOpt.CLOEXEC) &
       l[2].dflag(DescOpt.CLOEXEC) &
       pid := System.fork()) | {
         save_why{ lclose(l) }
         fail
       }
      if pid > 0 then {
         # Parent
         sock := l[2]
         l[1].close()
         return self
      } else {
         # Child
         pid := task := &null
         sock := l[1]
         l[2].close()
         @e
         close_sock()
         exit(0)
      }
$endif
   end

   #
   # Send an object to the other process.
   # 
   public send(obj)
      local s
      # The message format is <len><nl><encoded-data>; knowing the
      # length in advance lets us potentially get all the encoded data
      # in one low-level socket read, which is much faster.
      s := encode(obj, &yes) | fail
      return sock.writes(*s, "\n", s)
   end

   #
   # Receive an object from the other process.
   #
   public receive()
      local s, n
      s := sock.read() | fail
      n := integer(s) | return error("Expected integer size, got: " || s)
      return decode(sock.reads(n))
   end

   #
   # Attempt to get an object from the socket, failing if one is not
   # ready immediately.
   #
   public attempt()
      return poll(0)
   end

   #
   # Poll the socket for some available data, waiting for `t`
   # milliseconds.  If data becomes available then return it, else
   # fail.
   #
   public poll(t)
      local r
      r := do_poll(Poll.IN, t) | fail
      if /r then
         return error("Timeout")
      if DescStream.poll_in_test(r[1]) then
         return receive()
      return error("i/o error on reading from socket")
   end

   #
   # Do a `poll` on the socket.
   #
   public do_poll(for, timeout)
      return choose_poll([sock, for], timeout)
   end

   #
   # Return the socket
   #
   public get_sock()
      return .\sock
   end

   private close_sock()
$ifndef _PLAN9
      sock.shutdown(Shut.RDWR)
$endif
      sock.close()
      sock := &null
   end

   #
   # Called by the parent.  The method waits for the child to terminate.  The
   # child process will no longer exist after this call, so it resets pid to
   # &null and closes the socket.
   #
   public close()
      do_wait()
      close_sock()
      return self
   end

   #
   # Called by the parent to kill the child.  Then the `close` method is invoked.
   #
   public stop()
      \pid | runerr("stop() called out of sequence", self)
$ifdef _PLAN9
      # This may fail if the child has exited, so this isn't regarded as an
      # error (unix kill will succeed even if the child has already exited).
      Files.string_to_file("/proc/" || pid || "/note", "kill")
$else
      # kill should never fail (even if the child crashed).
      System.kill(pid, Signal.SIGTERM) | syserr("System.kill failed unexpectedly: " || &why)
$endif
      close()
      return self
   end

   # Create a new instance, with the given co-expression as the body
   # of the child process.
   #
   public new(e)
      self.e := e
      return
   end
end

