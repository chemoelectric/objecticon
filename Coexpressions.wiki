#summary Co-expressions
<wiki:toc max_depth="3" />
= Introduction =
The implementation and semantics of co-expressions is rather different in V2 of Object Icon, compared to V1, and indeed to traditional Icon.

The first and most significant difference to mention is that co-expressions in V2 are cheap.  Each co-expression has an interpreter stack, but it grows and shrinks dynamically in chunks called "frames", with one frame corresponding to each procedure call.  Each frame is quite small, typically about 100 bytes.  This is in sharp contrast to the traditional Icon interpreter's allocation for a co-expression - a fixed size region sufficient for both C and interpreter stack.

The implementation of co-expressions in V2 of Object Icon is also highly portable.  The conventional Icon implementation requires a low-level context switch to swap between C stacks.  This is inherently non-portable, and raises a number of other issues.  The new non-recursive design of the interpreter loop in V2 of Object Icon means that no context-switch is required to implement co-expressions, and the new implementation is written entirely in standard C.

== Co-expressions and local variables ==
In contrast to conventional Icon, V2 of Object Icon implements co-expressions in such a way that they share the local variables of the procedure in which they were created (in Icon each co-expression gets a copy of the local variables).

For example, the following program
{{{
import io

procedure main()
   local i, e
   i := 1
   e := create i := 2
   write(i)
   @e
   write(i)
end
}}}
outputs
{{{
1
2
}}}
whereas in Icon the result would be
{{{
1
1
}}}
Refreshing a co-expression creates a new co-expression, which also shares the same local variables.  Thus the program
{{{
import io

procedure main()
   local i, e
   i := 1
   e := create i +:= 1
   write(i)
   @e
   write(i)
   e := ^e
   @e
   write(i)
end
}}}
outputs
{{{
1
2
3
}}}
== The cocopy() function ==
Sometimes the way co-expressions share local variables is prohibitive.

Consider for example the problem of creating a list of co-expressions, each of which will generate a single number; 1 for the first, 2 for the second and so on.  The following obvious attempt (which would work in Icon), unfortunately doesn't work in Object Icon :-
{{{
import io

procedure main()
   local x, i, e

   x := []
   every i := 1 to 10 do
      put(x, create i)

   every e := !x do
      write(@e)
end
}}}
The problem with this is that each `create i` references the same `i`, which eventually reaches the value `10`.  So the output is ten `10`s.

To solve this problem, a builtin function `cocopy` is provided.  This does exactly the same as the refresh operator `^`, but instead of returning a new co-expression which also shares the local variables, a new set of local variables is allocated with values copied from the original.  Here is a working version of the above program :-
{{{
import io

procedure main()
   local x, i, e

   x := []
   every i := 1 to 10 do
      put(x, cocopy{i})

   every e := !x do
      write(@e)
end
}}}
Note we have used `cocopy{i}`, which is just syntactic shorthand for `cocopy(create i)`.

== Refreshing ==
In Icon, refreshing a co-expression reset the local variables to their values when the co-expression was created.   This doesn't happen in the V2 Object Icon implementation of co-expressions.  Refreshing a co-expression simply creates a new co-expression which shares the local variables of the co-expression being refreshed.  `cocopy` does the same, but creates copies of the local variables instead.

== The ! operator ==
V2 of Object Icon lets the unary ! operator be applied to co-expressions.  The effect is to generate the sequence of results from a refreshed copy of the given co-expression.  In other words, the result sequence of `!e` is the same as for `p(e)`, if `p` were defined as the following procedure :-
{{{
procedure p(e)
   local t
   e := ^e
   while t := @e do
      suspend t
end
}}}

== Uses of co-expressions ==

=== As an expression type ===

=== Co-routines ===
Co-expressions provide a complete co-routine capability.  One particularly useful feature of co-routines is to generate the elements of a deeply nested structure.  For example, consider the following binary tree class :-
{{{
class Node()
   public const data
   private l, r

   public insert(val)
      if val < data then
         (/l := Node(val)) | l.insert(val)
      else
         (/r := Node(val)) | r.insert(val)
   end

   public traverse()
      (\l).traverse()
      self@&source
      (\r).traverse()
   end

   public new(i)
      self.data := i
      return
   end
end
}}}
Given a populated tree `root`, the `traverse` method can be used to generate all the elements as follows :-
{{{
   e := create root.traverse()
   while write((@e).data)
}}}

=== PDCOs ===