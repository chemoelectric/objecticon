package plan9

import io, lang, util, exception, ipl.strings, ipl.pdco

record RAttach(tag, qid)
record RAuth(tag, aqid)
record RClunk(tag)
record RCreate(tag, qid, iounit)
record RError(tag, ename)
record RFlush(tag)
record ROpen(tag, qid, iounit)
record RRead(tag, data)
record RRemove(tag)
record RStat(tag, stat)
record RVersion(tag, msize, version)
record RWalk(tag, wqid)
record RWrite(tag, count)
record RWstat(tag)
record TAttach(tag, fid, afid, uname, aname)
record TAuth(tag, afid, uname, aname)
record TClunk(tag, fid)
record TCreate(tag, fid, name, perm, mode)
record TFlush(tag, oldtag)
record TOpen(tag, fid, mode)
record TRead(tag, fid, offset, count)
record TRemove(tag, fid)
record TStat(tag, fid)
record TVersion(tag, msize, version)
record TWalk(tag, fid, newfid, wname)
record TWrite(tag, fid, offset, data)
record TWstat(tag, fid, stat)

record Tinvalid()

record Info(mode, atime, mtime, length, name, uid, gid, muid)
record Qid(type, version, path)

abstract class File9P()
   private readable
      parent,
      name,
      perm,
      qversion,
      qpath,
      atime,
      mtime,
      uid,
      gid,
      muid,
      fixed

   private static 
      qpath_seq, user
      
   private static init()
      qpath_seq := 0
      user := Files.file_to_string("/env/user") | "none"
   end

   public get_length()
      return 0
   end

   public set_length(len)
      return self
   end

   public modified(uid)
      self.qversion +:= 1
      self.muid := uid
      self.mtime := Time.get_system_seconds()
      return self
   end

   public open(mode)
      return self
   end

   public close()
      return self
   end

   public path_unreferenced()
      return self
   end

   # Return the parent, or fail if this is the root directory.
   #
   public get_parent()
      return .\self.parent
   end

   public get_info()
      return Info(perm, atime, mtime, get_length(), name, uid, gid, muid)
   end

   public set_info(x)
      if \fixed & (\x.mode | \x.mtime | \x.gid) then throw("permission denied")
      set_perm(\x.mode)
      set_mtime(\x.mtime)
      set_name(\x.name)
      set_length(\x.length)
      set_gid(\x.gid)
      return self
   end

   # Note that normally {set_parent} should not be called; rather
   # {add_child} in the parent directory should be used.  This method
   # is public in order to allow files to point upwards to a
   # directory, but for the directory to not link downwards to them,
   # so that they don't appear in the directory's contents.
   #
   public set_parent(x)
      self.parent := x
      return self
   end

   public set_name(x)
      # Must be string since it's used as a table key
      x := string(x) | runerr(103, x)
      (\parent).rename_child(self, x)
      self.name := x
      return self
   end

   public set_fixed_perm(x)
      return set_perm(x, &yes)
   end

   public set_perm(x, y)
      iand(perm, Mode9.DMDIR) = iand(x, Mode9.DMDIR) | throw("Cannot change directory bit")
      self.perm := x
      self.fixed := y
      return self
   end

   public set_qversion(x)
      self.qversion := x
      return self
   end

   public set_mtime(x)
      self.mtime := x
      return self
   end

   public set_atime(x)
      self.atime := x
      return self
   end

   public set_uid(x)
      self.uid := x
      return self
   end

   public set_gid(x)
      self.gid := x
      return self
   end

   public set_muid(x)
      self.muid := x
      return self
   end

   public get_qid()
      return Qid(ishift(perm, -24), qversion, qpath)
   end

   public new()
      self.qversion := 0
      self.qpath := (qpath_seq +:= 1)
      self.mtime := self.atime := Time.get_system_seconds()
      self.uid := self.gid := self.muid := user
      self.perm := if is(self,Dir9P) then ior(8r777, Mode9.DMDIR) else 8r666
      return
   end
end

abstract class Dir9P(File9P)
   public abstract add_child(x)
   public abstract remove_child(x)
   public abstract get_child(x)
   package abstract rename_child(x, s)
   public abstract gen_children()
   public abstract create_child(name, uid, perm)
   public abstract is_empty()
end

class Dir9PImpl(Dir9P)
   private
      ent

   public add_child(x)
      \x.name | runerr("Child name not set")
      if member(ent, x.name) then
         throw("Can't add child named " || x.name || " - already exists")
      insert(ent, x.name, x)
      x.set_parent(self)
      return self
   end

   public remove_child(x)
      delete(ent, x.name)
      return self
   end

   public get_child(x)
      return .member(ent, x)
   end

   public gen_children()
      suspend .!ent
   end

   public is_empty()
      return *ent = 0
   end

   package rename_child(x, s)
      if ent[x.name] === x & x.name ~== s then {
         if member(ent, s) then
            throw("Can't change name to " || s || " - already exists")
         delete(ent, x.name)
         insert(ent, s, x)
      }
      return self
   end

   protected new_dir_child(name, uid, perm)
      return Dir9PImpl().
         set_name(name).
         set_uid(uid).
         set_muid(uid).
         set_gid(self.gid).
         set_perm(iand(perm, ior(icom(8r777), iand(self.perm, 8r777))))
   end

   protected new_regular_child(name, uid, perm)
      return Regular9PImpl().
         set_name(name).
         set_uid(uid).
         set_muid(uid).
         set_gid(self.gid).
         set_perm(iand(perm, ior(icom(8r666), iand(self.perm, 8r666))))
   end

   public create_child(name, uid, perm)
      local n
      n := if iand(perm, Mode9.DMDIR) = 0 then
         new_regular_child(name, uid, perm)
      else
         new_dir_child(name, uid, perm)
      add_child(n)
      return n
   end

   public new()
      Dir9P.new()
      ent := table()
      return
   end
end

abstract class Regular9P(File9P)
   public defer write(s, pos)
   public defer read(pos, count)
end

class Regular9PImpl(Regular9P)
   private readable
      data

   public open(mode)
      if iand(self.perm, Mode9.DMAPPEND) = 0 &
         iand(mode, FileOpt9.OTRUNC) ~= 0 then
         data := ""
      return self
   end

   public set_length(len)
      if len > *data then
         data ||:= repl("\0", len - *data)
      else
         data := data[1+:len]
      return self
   end

   public write(s, pos)
      if iand(self.perm, Mode9.DMAPPEND) = 0 then {
         if pos > *data then
            data ||:= repl("\0", pos - *data - 1) || s
         else
            data[pos:min(pos + *s, *data + 1)] := s
      } else
         data ||:= s
      return *s
   end

   public read(pos, count)
      if pos > *data then
         return
      else
         return data[pos:min(pos + count, *data + 1)]
   end

   public get_length()
      return *data
   end

   public set_data(s)
      s := string(s) | runerr(103, s)
      data := s
      return self
   end

   public new()
      Regular9P.new()
      data := ""
      return
   end
end

class Comms9P()
   public static const
      Tversion,
      Tauth,
      Tattach,
      Tflush,
      Twalk,
      Topen,
      Tcreate,
      Tread,
      Twrite,
      Tclunk,
      Tremove,
      Tstat,
      Twstat,
      Rversion,
      Rauth,
      Rattach,
      Rerror,
      Rflush,
      Rwalk,
      Ropen,
      Rcreate,
      Rread,
      Rwrite,
      Rclunk,
      Rremove,
      Rstat,
      Rwstat,
      AEXEC,
      AWRITE,
      AREAD,
      MAX_32,
      MAX_64

   private static init()
      Tversion :=     100
      Rversion :=     101
      Tauth :=        102
      Rauth :=        103
      Tattach :=      104
      Rattach :=      105
      Rerror :=       107
      Tflush :=       108
      Rflush :=       109
      Twalk :=        110
      Rwalk :=        111
      Topen :=        112
      Ropen :=        113
      Tcreate :=      114
      Rcreate :=      115
      Tread :=        116
      Rread :=        117
      Twrite :=       118
      Rwrite :=       119
      Tclunk :=       120
      Rclunk :=       121
      Tremove :=      122
      Rremove :=      123
      Tstat :=        124
      Rstat :=        125
      Twstat :=       126
      Rwstat :=       127

      AEXEC :=        1
      AWRITE :=       2
      AREAD :=        4

      MAX_32 :=       16rffffffff
      MAX_64 :=       16rffffffffffffffff
   end

   public static int_to_bytes(n, w)
      local s
      s := ""
      every 1 to w do {
         s ||:= char(iand(n, 255))
         n := ishift(n, -8)
      }
      return s
   end

   public static bytes_to_int(s)
      local n, ch
      n := 0
      every ch := back(s) do
         n := ishift(n, 8) + ord(ch)
      return n
   end

   public static encode_qid(q)
      return int_to_bytes(q.type, 1) || 
         int_to_bytes(q.version, 4) || 
         int_to_bytes(q.path,8)
   end

   public static encode_stat(qid, info)
      return encode_data_len2("\0\0\0\0\0\0" || 
                              encode_qid(qid) || 
                              int_to_bytes(info.mode, 4) ||
                              int_to_bytes(info.atime, 4) || 
                              int_to_bytes(info.mtime, 4) || 
                              int_to_bytes(info.length, 8) ||
                              encode_data_len2(info.name) ||
                              encode_data_len2(info.uid) ||
                              encode_data_len2(info.gid) ||
                              encode_data_len2(info.muid))
   end

   public static decode_wstat(s)
      local i, t
      i := Info()
      s ? {
         move(21) | fail          # tab past qid
         t := get_int4() | fail
         if t ~= MAX_32 then i.mode := t
         t := get_int4() | fail
         if t ~= MAX_32 then i.atime := t
         t := get_int4() | fail
         if t ~= MAX_32 then i.mtime := t
         t := get_int8() | fail
         if t ~= MAX_64 then i.length := t
         t := get_data_len2() | fail
         if *t > 0 then i.name := t
         t := get_data_len2() | fail
         if *t > 0 then i.uid := t
         t := get_data_len2() | fail
         if *t > 0 then i.gid := t
         t := get_data_len2() | fail
         if *t > 0 then i.muid := t
      }
      return i
   end

   public static encode_int4(n)
      return int_to_bytes(n, 4)
   end

   public static encode_int2(n)
      return int_to_bytes(n, 2)
   end

   public static encode_data_len2(s)
      return encode_int2(*s) || s
   end

   public static encode_data_len4(s)
      return encode_int4(*s) || s
   end

   public static get_int8()
      return bytes_to_int(move(8))
   end

   public static get_int4()
      return bytes_to_int(move(4))
   end

   public static get_int2()
      return bytes_to_int(move(2))
   end

   public static get_int1()
      return ord(move(1))
   end

   public static get_data_len2()
      return move(get_int2())
   end

   public static get_data_len4()
      return move(get_int4())
   end

   public static get(f)
      local s, size, body
      s := f.reads(4) | fail
      size := (s ? get_int4()) - 4 | return Tinvalid()
      body := f.reads(size) | fail
      return decode_body(body) | Tinvalid()
   end

   public static decode_body(body)
      local type, f1, f2, f3, f4, tag, n
      body ? {
         type := ord(move(1)) | fail
         tag := get_int2() | fail
         case type of {
            Tversion: {
               f1 := get_int4() | fail
               f2 := get_data_len2() | fail
               pos(0) | fail
               return TVersion(tag, f1, f2)
            }
            Tauth: {
               f1 := get_int4() | fail    # afid
               f2 := get_data_len2() | fail    # uname
               f3 := get_data_len2() | fail    # aname
               pos(0) | fail
               return TAuth(tag, f1, f2, f3)
            }
               
            Tattach: {
               f1 := get_int4() | fail    # fid
               f2 := get_int4() | fail    # afid
               f3 := get_data_len2() | fail    # uname
               f4 := get_data_len2() | fail    # aname
               pos(0) | fail
               return TAttach(tag, f1, f2, f3, f4)
            }

            Tflush: {
               f1 := get_int2() | fail     # oldtag
               pos(0) | fail
               return TFlush(tag, f1)
            }

            Twalk: {
               f1 := get_int4() | fail    # fid
               f2 := get_int4() | fail    # newfid
               n := get_int2() | fail     # nwname
               f3 := []
               every 1 to n do
                  put(f3, get_data_len2()) | fail
               pos(0) | fail
               return TWalk(tag, f1, f2, f3)
            }

            Topen: {
               f1 := get_int4() | fail    # fid
               f2 := get_int1() | fail    # mode
               pos(0) | fail
               return TOpen(tag, f1, f2)
            }

            Tcreate: {
               f1 := get_int4() | fail    # fid
               f2 := get_data_len2() | fail    # name
               f3 := get_int4() | fail    # perm
               f4 := get_int1() | fail    # mode
               pos(0) | fail
               return TCreate(tag, f1, f2, f3, f4)
            }

            Tread: {
               f1 := get_int4() | fail    # fid
               f2 := get_int8() | fail    # offset
               f3 := get_int4() | fail    # count
               pos(0) | fail
               return TRead(tag, f1, f2, f3)
            }

            Twrite: {
               f1 := get_int4() | fail    # fid
               f2 := get_int8() | fail    # offset
               f3 := get_data_len4() | fail    # data
               pos(0) | fail
               return TWrite(tag, f1, f2, f3)
            }

            Tclunk: {
               f1 := get_int4() | fail    # fid
               pos(0) | fail
               return TClunk(tag, f1)
            }
            Tremove: {
               f1 := get_int4() | fail    # fid
               pos(0) | fail
               return TRemove(tag, f1)
            }

            Tstat: {
               f1 := get_int4() | fail    # fid
               pos(0) | fail
               return TStat(tag, f1)
            }

            Twstat: {
               f1 := get_int4() | fail         # fid
               f2 := get_data_len2() | fail    # stat
               pos(0) | fail
               return TWstat(tag, f1, f2)
            }

            default: fail
         }
      }
   end

   public static encode(x)
      local s
      case classof(x) of {
         RVersion: {
            return encode_int4(13 + *x.version) ||
               char(Rversion) ||
               encode_int2(x.tag) ||
               encode_int4(x.msize) ||
               encode_data_len2(x.version)
         }

         RAttach: {
            return encode_int4(20) ||
               char(Rattach) ||
               encode_int2(x.tag) ||
               x.qid
         }

         RAuth: {
            return encode_int4(20) ||
               char(Rauth) ||
               encode_int2(x.tag) ||
               x.aqid
         }

         RClunk: {
            return encode_int4(7) ||
               char(Rclunk) ||
               encode_int2(x.tag)
         }

         RFlush: {
            return encode_int4(7) ||
               char(Rflush) ||
               encode_int2(x.tag)
         }

         RRemove: {
            return encode_int4(7) ||
               char(Rremove) ||
               encode_int2(x.tag)
         }

         RWstat: {
            return encode_int4(7) ||
               char(Rwstat) ||
               encode_int2(x.tag)
         }

         RError: {
            return encode_int4(9 + *x.ename) ||
               char(Rerror) ||
               encode_int2(x.tag) ||
               encode_data_len2(x.ename)
         }

         RWalk: {
            s := encode_int4(9 + 13 * *x.wqid) ||
               char(Rwalk) ||
               encode_int2(x.tag) ||
               encode_int2(*x.wqid)
            every s ||:= !x.wqid
            return s
         }

         RCreate: {
            return encode_int4(24) ||
               char(Rcreate) ||
               encode_int2(x.tag) ||
               x.qid ||
               encode_int4(x.iounit)
         }

         ROpen: {
            return encode_int4(24) ||
               char(Ropen) ||
               encode_int2(x.tag) ||
               x.qid ||
               encode_int4(x.iounit)
         }

         RWrite: {
            return encode_int4(11) ||
               char(Rwrite) ||
               encode_int2(x.tag) ||
               encode_int4(x.count)
         }

         RRead: {
            return encode_int4(11 + *x.data) ||
               char(Rread) ||
               encode_int2(x.tag) ||
               encode_data_len4(x.data)
         }

         RStat: {
            return encode_int4(9 + *x.stat) ||
               char(Rstat) ||
               encode_int2(x.tag) || 
               encode_data_len2(x.stat)
         }

         default:
            runerr("Bad type to encode")
      }
   end
end

abstract class Users()
   public abstract is_member(group, user)
   public abstract is_leader(group, user)
end

# Simple default Users database
#
class DefaultUsers(Users)
   public is_member(group, user)
      return group == user
   end

   public is_leader(group, user)
      return group == user
   end
end

record Group(name, leader, members)

# Users database read from /adm/users file.
#
class AdmUsers(Users)
   private
      source,
      groups

   private parse(s)
      local l, leader, members
      l := List{separate(s, ':')}
      if *l ~= 4 then
         fail
      leader := ("" ~== l[3])
      members := Set{separate("" ~== l[4])}
      return Group("" ~== l[2], leader, members)
   end

   public refresh()
      local s, g
      s := Files.file_to_string(source) | fail
      groups := table()
      every g := parse(separate_lines(s)) do
         insert(groups, g.name, g)
      return self
   end

   public is_member(group, user)
      local g
      if g := member(groups, group) then
         return member(g.members, user)
   end

   public is_leader(group, user)
      local g
      if g := member(groups, group) then {
         # If there is no specific leader then any member is a leader.
         return if /g.leader then 
            member(g.members, user)
         else
            g.leader == user
      }
   end

   public new(source)
      /source := "/adm/users"
      self.source := source
      refresh() | fail
      return
   end
end

abstract class Data9P()
   public abstract get_root(aname)
   public abstract get_parent(p)
   public abstract get_child(p, name)
   public abstract gen_children(p)
   public abstract remove_child(p1, p2)
   public abstract create_child(p, name, uid, perm)
   public abstract is_empty(p)
   public abstract modified(p, uid)
   public abstract open(p, mode)
   public abstract write(p, s, pos)
   public abstract read(p, pos, count)
   public abstract close(p)
   public abstract get_info(p)
   public abstract set_info(p, x)
   public abstract get_qid(p)
   public abstract path_unreferenced(p)
end

class TreeData9P(Data9P)
   private readable
      root

   public get_root(aname)
      return root
   end

   public get_parent(p)
      return p.get_parent()
   end

   public get_child(p, name)
      return p.get_child(name)
   end

   public gen_children(p)
      suspend p.gen_children()
   end

   public remove_child(p1, p2)
      return p1.remove_child(p2) & self
   end

   public create_child(p, name, uid, perm)
      return p.create_child(name, uid, perm)
   end

   public is_empty(p)
      return p.is_empty()
   end
   
   public modified(p, uid)
      return p.modified(uid) & self
   end

   public open(p, mode)
      return p.open(mode)
   end

   public write(p, s, pos)
      return p.write(s, pos)
   end

   public read(p, pos, count)
      return p.read(pos, count)
   end

   public close(p)
      return p.close() & self
   end

   public get_info(p)
      return p.get_info()
   end

   public set_info(p, x)
      return p.set_info(x) & self
   end

   public get_qid(p)
      return p.get_qid()
   end

   public path_unreferenced(p)
      return p.path_unreferenced() & self
   end

   public new(root)
      self.root := root
      return
   end
end

record Fid(path, uid, omode, dir)
record WorkItem(req, resp, worker)

class Session9P()
   private
      fids,        # table mapping fid numbers to Fid() records
      data, 
      users,
      paths,       # table mapping paths to sets of fid numbers representing those paths.  So
                   # for each fid number n, n is an element of paths[fids[n].path].
      ref_cnt,
      track_refs,
      verbose

   # Vars used just by async_io
   private
      writer,      # The writer task
      valid,       # Set of valid (non-flushed) WorkItems
      done_flag,   # Flag to indicate writer to exit
      queue        # Queue of WorkItems for output

   private new_fid(n, path, uid, mode)
      local s
      if member(fids, n) then
         throw("fid already in use:" || n)
      insert(fids, n, Fid(path, uid, mode))
      (s := member(paths, path)) | insert(paths, path, s := set())
      insert(s, n)
      inc_ref(path)
   end

   private del_fid(n)
      local x
      x := member(fids, n) | throw("no such fid:" || n)
      delete(fids, n)
      delete(paths[x.path], n)
      if *paths[x.path] = 0 then
         delete(paths, x.path)
      dec_ref(x.path)
   end

   private is_path_open(path)
      return \fids[!paths[path]].omode
   end

   private lookup(n, t)
      local o
      o := member(fids, n) | throw("no such fid:" || n)
      tmp(o.path, t)
      return o
   end

   private path_string(path)
      local s, t, n
      s := ""
      t := path
      repeat {
         n := data.get_info(t).name
         if n == "/" then
            s := "/" || s
         else if *s = 0 then
            s := n
         else
            s := n || "/" || s
         t := data.get_parent(t) | break
      }
      return s
   end

   public dump()
      local e
      write("Fids(",*fids,")")
      every e := !sort(fids) do
         write(e[1], " -> Fid(", path_string(e[2].path), ", ", e[2].uid, ", ", if \e[2].omode then "open" else "closed", ")")
      write("Paths(",*paths,")")
      every e := !sort(paths) do {
         writes(path_string(e[1]), " -> ")
         every writes(!e[2], " ")
         write()
      }
      write("Ref counts(",*ref_cnt,")")
      every e := !sort(ref_cnt) do {
         write(path_string(e[1]), "(",image(e[1]), ") -> ", e[2])
      }
   end

   private has_perm(info, uid, p)
      local m
      # see uid.c
      m := iand(info.mode, 7)
      if iand(p, m) = p then
         return
      if uid == info.uid then {
         m := ior(m, iand(ishift(info.mode, -6), 7))
         if iand(p, m) = p then
            return
      }
      if users.is_member(info.gid, uid) then {
         m := ior(m, iand(ishift(info.mode, -3), 7))
         if iand(p, m) = p then
            return
      }
   end

   private inc_ref(p)
      if \track_refs then {
         ref_cnt[p] +:= 1
         if \verbose then write("INC:",image(p), " to ", ref_cnt[p])
      }
   end

   public is_path_referenced(p)
      return .member(ref_cnt, p)
   end

   public is_path_unreferenced(p)
      return not member(ref_cnt, p)
   end

   private dec_ref(p)
      local i
      if \track_refs then {
         i := (ref_cnt[p] -:= 1)
         if \verbose then write("DEC:",image(p)," to ", i)
         if i < 0 then
            syserr("negative reference count in Session9P")
         if i = 0 then {
            delete(ref_cnt, p)
            data.path_unreferenced(p)
         }
      }
   end

   # Add path p to the temporary path list and increment its refcount.
   private tmp(p, t)
      if \track_refs then {
         put(t, p)
         inc_ref(p)
      }
      return p
   end

   public respond(x)
      local t, y
      t := []  # A list of paths temporarily used by respond_impl
      clean{ y := try1{respond_impl(x, t)} | RError(x.tag, &why) }
      every dec_ref(!t)
      return y
   end

   private respond_impl(x, t)
      local o, qids, e, s, i, p, info, n
      case classof(x) of {
         TVersion:
            return RVersion(65535, 8216, "9P2000")
         TAttach: {
            p := tmp(data.get_root(x.aname), t)
            new_fid(x.fid, p, x.uname)
            return RAttach(x.tag, Comms9P.encode_qid(data.get_qid(p)))
         }
         TClunk: {
            o := lookup(x.fid, t)
            del_fid(x.fid)
            if \o.omode then {
               data.close(o.path)
               if iand(o.omode, FileOpt9.ORCLOSE) ~= 0 then {
                  p := tmp(data.get_parent(o.path), t)
                  data.remove_child(p, o.path)
                  data.modified(p, o.uid)
               }
            }
            return RClunk(x.tag)
         }
         TRemove: {
            o := lookup(x.fid, t)
            del_fid(x.fid)
            info := data.get_info(o.path)
            if iand(info.mode, Mode9.DMDIR) ~= 0 & not data.is_empty(o.path) then
               throw("directory not empty")
            p := tmp(data.get_parent(o.path), t)
            has_perm(data.get_info(p), o.uid, Comms9P.AWRITE) | throw("permission denied")
            if \o.omode then
               data.close(o.path)
            data.remove_child(p, o.path)
            data.modified(p, o.uid)
            return RRemove(x.tag)
         }
         TCreate: {
            o := lookup(x.fid, t)
            /o.omode | throw("fid already open")
            info := data.get_info(o.path)
            iand(info.mode, Mode9.DMDIR) ~= 0 | throw("attempt to create in a regular file")
            has_perm(info, o.uid, Comms9P.AWRITE) | throw("permission denied")
            if tmp(data.get_child(o.path, x.name), t) then
               throw("create with name which already exists")
            p := tmp(data.create_child(o.path, x.name, o.uid, x.perm), t)
            p := tmp(data.open(p, x.mode), t)
            data.modified(o.path, o.uid)
            del_fid(x.fid)
            new_fid(x.fid, p, o.uid, x.mode)
            return RCreate(x.tag, Comms9P.encode_qid(data.get_qid(p)), 0)
         }
         TOpen: {
            o := lookup(x.fid, t)
            /o.omode | throw("fid already open")
            info := data.get_info(o.path)
            if iand(info.mode, Mode9.DMEXCL) ~= 0 & is_path_open(o.path) > 0 then
               throw("exclusive use file already open")
            if iand(info.mode, Mode9.DMDIR) ~= 0 &
               iand(x.mode, icom(FileOpt9.ORCLOSE)) ~= FileOpt9.OREAD then
                  throw("invalid mode for opening a directory")
            i := case iand(x.mode, 3) of {
               FileOpt9.OREAD : Comms9P.AREAD
               FileOpt9.OWRITE : Comms9P.AWRITE
               FileOpt9.ORDWR : ior(Comms9P.AREAD, Comms9P.AWRITE)
               FileOpt9.OEXEC : Comms9P.AEXEC
               default: throw("strange permissions value")
            }
            if iand(x.mode, FileOpt9.OTRUNC) ~= 0 then
               i := ior(i, Comms9P.AWRITE)
            has_perm(info, o.uid, i) | throw("permission denied")
            if iand(x.mode, FileOpt9.ORCLOSE) ~= 0 then {
               p := tmp(data.get_parent(o.path), t)
               has_perm(data.get_info(p), o.uid, Comms9P.AWRITE) | throw("permission denied")
            }
            p := tmp(data.open(o.path, x.mode), t)
            del_fid(x.fid)
            new_fid(x.fid, p, o.uid, x.mode)
            return ROpen(x.tag, Comms9P.encode_qid(data.get_qid(p)), 0)
         }
         TWalk: {
            o := lookup(x.fid, t)
            /o.omode | throw("cannot clone open fid")
            p := o.path
            qids := []
            every e := !x.wname do {
               if e == ".." then
                  p := tmp(data.get_parent(p), t)   # Note parent of root is root
               else 
                  p := tmp(data.get_child(p, e), t) | break
               put(qids, Comms9P.encode_qid(data.get_qid(p)))
            }
            if *qids = *x.wname then {
               new_fid(x.newfid, p, o.uid)
               return RWalk(x.tag, qids)
            } 
            if *qids = 0 then
               throw("file does not exist")
            return RWalk(x.tag, qids)
         }
         TWrite: {
            o := lookup(x.fid, t)
            (iand(\o.omode, 3) = (FileOpt9.OWRITE | FileOpt9.ORDWR)) |
               throw("write on file not open for writing")
            info := data.get_info(o.path)
            if iand(info.mode, Mode9.DMDIR) ~= 0 then
               throw("attempt to write to directory")
            n := data.write(o.path, x.data, x.offset + 1)
            data.modified(o.path, o.uid)
            return RWrite(x.tag, n)
         }
         TRead: {
            o := lookup(x.fid, t)
            (iand(\o.omode, 3) = (FileOpt9.OREAD | FileOpt9.OEXEC | FileOpt9.ORDWR)) |
               throw("read on file not open for reading")
            info := data.get_info(o.path)
            if iand(info.mode, Mode9.DMDIR) ~= 0 then {
               if x.offset = 0 then {
                  o.dir := []
                  every e := tmp(data.gen_children(o.path), t) do
                     put(o.dir, Comms9P.encode_stat(data.get_qid(e), data.get_info(e)))
               }
               s := ""
               while *s + *o.dir[1] <= x.count do
                  s ||:= get(o.dir)
            } else {
               s := data.read(o.path, x.offset + 1, x.count)
               /s := ""
            }
            return RRead(x.tag, s)
         }
         TStat: {
            o := lookup(x.fid, t)
            return RStat(x.tag, Comms9P.encode_stat(data.get_qid(o.path), data.get_info(o.path)))
         }
         TWstat: {
            o := lookup(x.fid, t)
            i := Comms9P.decode_wstat(x.stat)  | throw("invalid wstat data")
            info := data.get_info(o.path)
            if \i.name then {
               # The name can be changed by anyone with write
               # permission in the parent directory
               p := tmp(data.get_parent(o.path), t)
               has_perm(data.get_info(p), o.uid, Comms9P.AWRITE) | throw("permission denied")
               if tmp(data.get_child(p, i.name), t) then
                  throw("name already exists")
            }
            if \i.length then {
               # The length can be changed by anyone with write
               # permission on the file.
               has_perm(info, o.uid, Comms9P.AWRITE) | throw("permission denied")
               if i.length ~= 0 & iand(info.mode, Mode9.DMDIR) ~= 0 then
                  throw("cannot set length of directory to non-zero value")
            }
            if \i.mtime | \i.mode then {
               # The mode and mtime can be changed by the owner of the
               # file or the group leader of the file's current group.
               (info.uid == o.uid) | users.is_leader(info.gid, o.uid) | throw("permission denied")
               if \i.mode & iand(i.mode, Mode9.DMDIR) ~= iand(info.mode, Mode9.DMDIR) then
                  throw("directory bit cannot be changed")
            }
            if \i.gid then {
               # The gid can be changed: by the owner if also a member
               # of the new group; or by the group leader of the
               # file's current group if also leader of the new group
               (info.uid == o.uid & users.is_member(i.gid, o.uid)) |
                  (users.is_leader(info.gid, o.uid) & users.is_leader(i.gid, o.uid)) | throw("permission denied")
            }
            if \i.atime | \i.uid | \i.muid then
               throw("invalid value set in wstat")

            data.set_info(o.path, i)
            if \i.name then
               data.modified(p, o.uid)
            if \i.length then
               data.modified(o.path, o.uid)

            return RWstat(x.tag)
         }
         TFlush:
            return RFlush(x.tag)
         TAuth:
            throw("authorization not required")
         default:
            throw("unknown message type")
      }
   end

   public io(f)
      local x, y
      while x := Comms9P.get(f) do {
         if \verbose then write("GOT:", to_string(x))
         if is(x, Tinvalid) then
            next
         y := respond(x)
         if \verbose then write("SEND:", to_string(y))
         f.writes1(Comms9P.encode(y)) | fail
      }
   end

   private async_worker(item, sched)
      local t
      t := Task(sched, create {
         if member(valid, item) then {
            item.resp := respond(item.req)
            put(queue, item)
            writer.notify()
         }
         t.revert()
      }, States(ThrowHandlerState(), CleanupState()))
      return t.start()
   end

   private async_writer(sched, f)
      local ts, item, t
      t := Task(sched, create {
         use {
            ts := TaskStream(f, t).set_close_underlying(&no),
            repeat {
               while /done_flag & *queue = 0 do
                  t.sleep()
               # If the queue is empty then done_flag must be set, so
               # break.  Otherwise, send - so we flush the queue
               # before exiting even after done_flag set.
               item := get(queue) | break
               if member(valid, item) then {
                  if \verbose then write("SEND:", to_string(item.resp))
                  ts.writes1(Comms9P.encode(item.resp))
                  delete(valid, item)
               }
            }
         }
         if \verbose then write("WRITER EXITING")
         t.revert()
      }, CleanupState())
      return t.start()
   end

   public async_io(sched, f)
      local x, e, t, ts, item
      t := Task(sched, create {
         done_flag := &null
         valid := set()
         queue := []
         writer := async_writer(sched, f)
         use {
            ts := TaskStream(f, t).set_close_underlying(&no),
            while x := Comms9P.get(ts) do {
               if \verbose then write("GOT:", to_string(x))
               item := WorkItem(x)
               if is(x, TFlush) then {
                  item.resp := respond(x)
                  every e := !valid do {
                     if e.req.tag = x.oldtag then {
                        if \verbose then write("FLUSHING:", to_string(e.req))
                        delete(valid, e)
                        (\e.worker).interrupt()
                     }
                  }
                  insert(valid, item)
                  put(queue, item)
                  writer.notify()
               } else {
                  insert(valid, item)
                  item.worker := async_worker(item, sched)
               }
            }
         }
         done_flag := 1
         writer.notify()
         if \verbose then write("READER EXITING")
         t.revert()
      }, States(ThrowHandlerState(), CleanupState()))
      return t.start()
   end

   public io_task(sched, f)
      local t, ts
      t := Task(sched, create {
         use {
            ts := TaskStream(f, t).set_close_underlying(&no),
            io(ts)
         }
         t.revert()
      }, States(ThrowHandlerState(), CleanupState()))
      return t.start()
   end

   public set_data(d)
      data := d
      return self
   end

   public set_users(u)
      users := u
      return self
   end

   public set_verbose(x)
      self.verbose := check_flag(x)
      return self
   end

   public set_track_refs(x)
      self.track_refs := check_flag(x)
      return self
   end

   public new(d, u)
      /u := DefaultUsers()
      self.fids := table()
      self.paths := table()
      self.ref_cnt := table(0)
      set_data(d)
      set_users(u)
      return
   end
end
