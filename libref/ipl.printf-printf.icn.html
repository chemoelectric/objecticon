<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>printf.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#       File:     printf.icn
<a name="4"/>#
<a name="5"/>#       Subject:  Procedures for printf-style formatting
<a name="6"/>#
<a name="7"/>#       Author:   William H. Mitchell
<a name="8"/>#
<a name="9"/>#       Date:     July 20, 2005
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#       Contributors:   Cheyenne Wills, Phillip Lee Thomas, Michael Glass
<a name="18"/>#
<a name="19"/>############################################################################
<a name="20"/>
<a name="21"/>package ipl.printf
<a name="22"/>
<a name="23"/>import
<a name="24"/>   io(stop, FileStream, need_Stream),
<a name="25"/>   util(Format, need_integer, need_text, need_real, need_list),
<a name="26"/>   lang(Text,to_string),
<a name="27"/>   ipl.pdco(String)
<a name="28"/>
<a name="29"/>#
<a name="30"/># Returns a `printf` format as a string or ucs result.
<a name="31"/>#
<a name="32"/>procedure sprintf(format, args[])
<a name="33"/>   return lsprintf(format, args)
<a name="34"/>end
<a name="35"/>
<a name="36"/>#
<a name="37"/># Outputs a `printf` format to the given `io.Stream`.
<a name="38"/>#
<a name="39"/>procedure fprintf(file, format, args[])
<a name="40"/>   return lfprintf(file, format, args)
<a name="41"/>end
<a name="42"/>
<a name="43"/>#
<a name="44"/># Outputs a `printf` format to stderr.
<a name="45"/>#
<a name="46"/>procedure eprintf(format, args[])
<a name="47"/>   return lfprintf(FileStream.stderr, format, args)
<a name="48"/>end
<a name="49"/>
<a name="50"/>#
<a name="51"/># Set `&amp;why` from a `printf` format, and fail.
<a name="52"/>#
<a name="53"/>procedure whyf(format, args[])
<a name="54"/>   &amp;why := lsprintf(format, args)
<a name="55"/>end
<a name="56"/>
<a name="57"/>#
<a name="58"/># Call `stop()` with the result of a `printf` format.
<a name="59"/>#
<a name="60"/>procedure stopf(format, args[])
<a name="61"/>   stop(lsprintf(format, args))
<a name="62"/>end
<a name="63"/>
<a name="64"/>#
<a name="65"/># Performs a `printf` format, with the output produced as a result
<a name="66"/># sequence of string (or ucs) chunks, some of which may be empty.
<a name="67"/>#
<a name="68"/>procedure gprintf(format, args[])
<a name="69"/>   suspend lgprintf(format, args)
<a name="70"/>end
<a name="71"/> 
<a name="72"/>#
<a name="73"/># Outputs a C-style `printf` format to stdout.
<a name="74"/>#
<a name="75"/># The specifier format is
<a name="76"/># ~
<a name="77"/>#     %[index$]&lt;flags&gt;&lt;width&gt;.&lt;precision&gt;&lt;char&gt;
<a name="78"/># ~
<a name="79"/>#  &lt;flags&gt; can be :-
<a name="80"/>#  *   0 - pad fields with zeroes instead of spaces; this may
<a name="81"/>#          not give sensible results with some numerical formats,
<a name="82"/>#          eg signed numbers or left adjusted numbers.
<a name="83"/>#  *   ' - for formats d, r, e, use commas to separate thousands
<a name="84"/>#  *   - - left adjust fields instead of right adjust
<a name="85"/>#  *   S - for formats r, e, replace trailing fractional zeroes
<a name="86"/>#          with spaces
<a name="87"/>#  *   Z - for formats r, e, means drop trailing fractional
<a name="88"/>#          zeroes altogether
<a name="89"/>#  *   + - for numeric formats, add a leading + to positive
<a name="90"/>#          numbers
<a name="91"/>#
<a name="92"/># The optional "index$" specifier indicates the argument index to which
<a name="93"/># this specifier applies, rather than the next argument in sequence.
<a name="94"/>#
<a name="95"/># The optional width specifies the field width.  It may be "*", in
<a name="96"/># which case an argument is consumed to give the width, or
<a name="97"/># "*&lt;index&gt;$", indicating which argument to use.
<a name="98"/>#
<a name="99"/># The optional precision (which may also be a "*") means :-
<a name="100"/># *  for string formats (s, i, t) the maximum string length;
<a name="101"/># *  for integer formats (d, x, X, o, b), the minimum number of
<a name="102"/>#    digits; leading zeroes are added if needed.
<a name="103"/># *  for real formats (r, e), the number of digits in the
<a name="104"/>#    fractional part.
<a name="105"/>#
<a name="106"/># The formats are :-
<a name="107"/># *   %d  decimal number
<a name="108"/># *   %s  string or ucs
<a name="109"/># *   %x  hex lower case
<a name="110"/># *   %X  hex upper case
<a name="111"/># *   %o  octal
<a name="112"/># *   %b  binary
<a name="113"/># *   %i  image() result
<a name="114"/># *   %t  to_string() result
<a name="115"/># *   %r  real decimal
<a name="116"/># *   %e  real in exponential format
<a name="117"/># *   %E  real in exponential format, with a capital E in
<a name="118"/>#         the result
<a name="119"/># *   %w  the value of &amp;why
<a name="120"/># *   %n  the empty string (useful for inserting spaces for
<a name="121"/>#         table alignment)
<a name="122"/>#
<a name="123"/>procedure printf(format, args[])
<a name="124"/>   return lfprintf(FileStream.stdout, format, args)
<a name="125"/>end
<a name="126"/>
<a name="127"/># Get a positional param of the form &lt;int&gt;$, or fail.
<a name="128"/>package procedure optpos()
<a name="129"/>   return 1(integer(tab(many(&amp;digits ++ '\-'))), ="$")
<a name="130"/>end
<a name="131"/>
<a name="132"/># A helper class to process the arguments
<a name="133"/>package class Args()
<a name="134"/>   private a
<a name="135"/>   private const e
<a name="136"/>   public const why
<a name="137"/>
<a name="138"/>   public get(i)
<a name="139"/>      return if /i then @e else a[i]
<a name="140"/>   end
<a name="141"/>
<a name="142"/>   public intparam()
<a name="143"/>      local a, i
<a name="144"/>      return if ="*" then {
<a name="145"/>         # Optional *N$ form
<a name="146"/>         i := optpos()
<a name="147"/>         a := get(i)
<a name="148"/>         need_integer(a)
<a name="149"/>      } else
<a name="150"/>         integer(tab(many(&amp;digits)))
<a name="151"/>   end
<a name="152"/>
<a name="153"/>   public new(x)
<a name="154"/>      a := need_list(x)
<a name="155"/>      e := create !a
<a name="156"/>      # Save a copy of &amp;why, since its value could be disturbed by
<a name="157"/>      # calls to writes1 in lfprintf.
<a name="158"/>      why := &amp;why
<a name="159"/>      return
<a name="160"/>   end
<a name="161"/>end
<a name="162"/>
<a name="163"/>package procedure one(args)  
<a name="164"/>   local v, a, just, width, conv, prec, pad, flag, apos
<a name="165"/>   move(1)     # Move over %
<a name="166"/>   # Get the optional positional specifier, eg "3$"
<a name="167"/>   apos := optpos()
<a name="168"/>   flag := cset(tab(many('0\'\-+SZ'))) | ''
<a name="169"/>   # Convert flags to those used by Format.numeric_to_string
<a name="170"/>   if any(flag, "'") then flag ++:= ','
<a name="171"/>   if any(flag, "S") then flag ++:= 's'
<a name="172"/>   if any(flag, "Z") then flag ++:= 'z'
<a name="173"/>   just := if any(flag, "-") then left else right
<a name="174"/>   if any(flag, "0") then pad := "0"
<a name="175"/>   width := args.intparam()
<a name="176"/>   if ="." then prec := args.intparam()
<a name="177"/>   conv := move(1) | ""
<a name="178"/>   # Formats that take an argument.
<a name="179"/>   if any('dsxXobitreE', conv) then
<a name="180"/>      a := args.get(apos)
<a name="181"/>   v := case string(conv) of {
<a name="182"/>      "d": decimal(a, prec, flag)
<a name="183"/>      "s": str(a, prec)
<a name="184"/>      "x": Text.lower(intstr(a, prec, flag))
<a name="185"/>      "X": intstr(a, prec, flag)
<a name="186"/>      "o": intstr(a, prec, flag, 8)
<a name="187"/>      "b": intstr(a, prec, flag, 2)
<a name="188"/>      "i": str(image(a), prec)
<a name="189"/>      "t": str(to_string(a), prec)
<a name="190"/>      "r": fixnum(a, prec, flag)
<a name="191"/>      "e": eformatstr(a, prec, flag ++ 'e')
<a name="192"/>      "E": eformatstr(a, prec, flag ++ 'E')
<a name="193"/>      "w": str(args.why, prec)
<a name="194"/>      "n": str("", prec)
<a name="195"/>      default: str(conv, prec)
<a name="196"/>   }
<a name="197"/>   if \width &amp; *v &lt; width then
<a name="198"/>      v := just(v, width, pad)
<a name="199"/>   return v
<a name="200"/>end
<a name="201"/>
<a name="202"/>#
<a name="203"/># This is like `gprintf`, but the second argument is a list of the
<a name="204"/># arguments used by the format string.
<a name="205"/>#
<a name="206"/>procedure lgprintf(format, args)
<a name="207"/>   local v
<a name="208"/>   args := Args(args)
<a name="209"/>   format ? {
<a name="210"/>      while v := tab(upto('%')) do
<a name="211"/>         suspend v | one(args)
<a name="212"/>      return tab(0)
<a name="213"/>   }
<a name="214"/>end
<a name="215"/>
<a name="216"/>#
<a name="217"/># This is like `sprintf`, but the second argument is a list of the
<a name="218"/># arguments used by the format string.
<a name="219"/>#
<a name="220"/>procedure lsprintf(format, args)
<a name="221"/>   return String{ lgprintf(format, args) }
<a name="222"/>end
<a name="223"/>
<a name="224"/>#
<a name="225"/># This is like `fprintf`, but the second argument is a list of the
<a name="226"/># arguments used by the format string.
<a name="227"/>#
<a name="228"/>procedure lfprintf(file, format, args)
<a name="229"/>   local s
<a name="230"/>   need_Stream(file)
<a name="231"/>   every s := lgprintf(format, args) do
<a name="232"/>      file.writes1(s) | fail
<a name="233"/>   return file
<a name="234"/>end
<a name="235"/>
<a name="236"/>package procedure str(x, prec)
<a name="237"/>   x := need_text(x)
<a name="238"/>   return x[1:(\prec + 1) | 0]
<a name="239"/>end
<a name="240"/>
<a name="241"/>package procedure intstr(x, prec, flag, base)
<a name="242"/>   local v
<a name="243"/>   x := need_integer(x)
<a name="244"/>   v := Format.int_to_string(x, base, prec)
<a name="245"/>   if any(flag, "+") &amp; x &gt;= 0 then
<a name="246"/>      v := "+" || v
<a name="247"/>   return v
<a name="248"/>end
<a name="249"/>
<a name="250"/>package procedure fixnum(x, prec, flag)
<a name="251"/>   /prec := 6
<a name="252"/>   x := need_real(x)
<a name="253"/>   return Format.numeric_to_string(x, prec, flag)
<a name="254"/>end
<a name="255"/>
<a name="256"/>package procedure decimal(x, prec, flag)
<a name="257"/>   x := need_integer(x)
<a name="258"/>   # Limitation: if we have a precision (padded to min prec digits),
<a name="259"/>   # then we can't have commas.
<a name="260"/>   return if \prec then
<a name="261"/>      intstr(x, prec, flag, 10)
<a name="262"/>   else
<a name="263"/>      Format.numeric_to_string(x, 0, flag)
<a name="264"/>end
<a name="265"/>
<a name="266"/># e-format:  [-]m.ddddddE(+|-)xxx
<a name="267"/>#
<a name="268"/>package procedure eformatstr(x, prec, flag)
<a name="269"/>   /prec := 6
<a name="270"/>   x := need_real(x)
<a name="271"/>   return Format.numeric_to_string(x, prec, flag)
<a name="272"/>end
</pre></body></html>
