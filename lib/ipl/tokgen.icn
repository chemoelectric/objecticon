############################################################################
#
#	File:     tokgen.icn
#
#	Subject:  Procedures for token counting
#
#	Author:   Ralph E. Griswold
#
#	Date:     May 23, 1996
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#  These procedures are for use with code produced by a meta-translator.
#  The result of linking these procedures with a program
#  translated by standard the meta-translator and executing the
#  result is a tabulation of the tokens in the program.
#
############################################################################
#
#  Bug:  The invocable declaration is not handled properly.  "invocable all"
#        will get by, but some other forms produce syntax errors.  The
#        problem is in the meta-translator itself, not in this
#	 program.
#
############################################################################
#
#  Links:  showtbl
#
############################################################################

package ipl.tokgen

import
   io,
   ipl.showtbl(showtbl)

global binops, unops, vars, controls, procs, others, keys
global clits, ilits, rlits, slits
global summary, globals, locals, statics, declarations, fields, files, parms
global fldref
global all			# kludge -- invocable is not handled properly

procedure main(Mp)
   local names, tables, i, total, count

   total := 0			# total number of tokens

   #  Build a list of tables for the different types of tokens.  The order
   #  of the tables determines the order of output.

   tables := []
   every put(tables, (unops | binops | others | controls | keys | clits |
      ilits | rlits | slits | vars | fldref | declarations | globals |
      locals | statics | parms | fields | files) := table(0))

   #  Create a list of names for the different types of tokens.  The order
   #  of the names must correspond to the order of the tables above.

   names := ["Unary operators", "Binary operators", "Other operations", 
      "Control structures", "Keywords", "Cset literals", "Integer literals",
      "Real literals", "String literals", "Variable references",
      "Field references", "Declarations", "Globals", "Locals", "Statics",
      "Procedure parameters", "Record fields", "Included files"]

   #  Call the procedure corresponding to the target program.
   #  It adds the token counts to the tables.

   Mp()

   every i := 1 to *names do {
      count := showtbl(names[i],tables[i])[1]
      total +:= count
      write("\n", right(count, 8), "   total")
      }
   write("\nTotal tokens: ", total)

end

# e1 | e2
procedure Alt(e1, e2)			
   controls["e1 | e2"] +:= 1
   return
end

# e1 ! e2
procedure Apply(e1, e2)		
   binops["e1 ! e2"] +:= 1
   return
end

procedure Arg(s)
   return s
end

# e1 op e2
procedure Asgnop(op, e1, e2)		
   binops["e1 " || op || " e2"] +:= 1
   return
end

# e1 ?:= e2
procedure Augscan(e1, e2)		
   controls["e1 ?:= e2"] +:= 1
   return
end

# e1 & e2
procedure Bamper(e1, e2)		
   binops["e1 & e2"] +:= 1
   return
end

procedure Binop(s)
   binops["e1 " || s || " e2"] +:= 1
   return
end

# procedure body
procedure Body(s[])			
   return
end

# break e
procedure Break(e)			
   controls["break e"] +:= 1
   return
end

# case e of { caselist }
procedure Case(e, clist)		
   controls["case"] +:= 1
   return
end

# e1 : e2
procedure Cclause(e1, e2)		
   controls["case selector"] +:= 1
   return
end

# e1 ; e2 in case list
procedure Clist(e1, e2)		
   return
end

procedure Clit(s)
   clits[image(s)] +:= 1
   return
end

# { e1; e2; ... }
procedure Compound(es[])		
   every controls["{...}"] +:= 1
   return
end

# create e
procedure Create(e)			
   controls["create e"] +:= 1
   return
end

# default: e
procedure Default(e)			
   controls["default"] +:= 1
   return
end

# end
procedure End()			
   return
end

# every e
procedure Every(e)			
   controls["every e"] +:= 1
   return
end

# every e1 do e2
procedure EveryDo(e1, e2)		
   controls["every e1 do e2"] +:= 1
   return
end

# fail
procedure Fail()			
   controls["fail"] +:= 1
   return
end

# e . f
procedure Field(e1, e2)		
   binops["e1 . e2"] +:= 1
   fldref[e2] +:= 1
   return
end

# global v1, v2, ...
procedure Global(vs[])			
   every globals[!vs] +:= 1
   declarations["global"] +:= *vs	# each name counts as a declaration
   return
end

# if e1 then e2
procedure If(e1, e2)			
   controls["if e1 then e2"] +:= 1
   return
end

# if e1 then e2 else e3
procedure IfElse(e1, e2, e3)		
   controls["if e1 then e2 else e3"] +:= 1
   return
end

procedure Ilit(s)
   ilits[s] +:= 1
   return
end

# initial e
procedure Initial(s)			
   controls["initial"] +:= 1
   return
end

# invocable ... (problem)
procedure Invocable(es[])		
   declarations["invocable"] +:= 1
   return
end

# e0(e1, e2, ...)
procedure Invoke(e0, es[])		
   others["e(...)"] +:= 1
   return
end

procedure Key(s)
   keys["&" || s] +:= 1
   return
end

# e1 \ e2
procedure Limit(e1, e2)		
   controls["e1 \\ e2"] +:= 1
   return
end

# link "v1, v2, ..."
procedure Link(vs[])			
   every files[!vs] +:= 1
   declarations["link"] +:= *vs		# each file counts as a declaration
   return
end

# [e1, e2, ... ]
procedure List(es[])			
   others["[...]"] +:= 1
   return
end

# local v1, v2, ...
procedure Local(vs[])			
   every locals[!vs] +:= 1
   declarations["local"] +:= *vs	# each name counts as a declaration
   return
end

# next
procedure Next()			
   controls["next"] +:= 1
   return
end

# not e
procedure Not(e)			
   controls["not e"] +:= 1
   return
end

# &null
procedure Null()			
   return
end

# (e1, e2, ... )
procedure Paren(es[])			
   if *es > 1 then others["(...)"] +:= 1
   return
end

# e0{e1, e2, ... }
procedure Pdco(e0, es[])		
   others["e{...}"] +:= 1
   return
end

# procedure s(v1, v2, ...)
procedure Proc(s, es[])		


   every parms[\!es] +:= 1 do
   declarations["procedure"] +:= 1
   return
end

# record s(v1, v2, ...)
procedure Record(s, es[])		
    every fields[\!es] +:= 1
    declarations["record"] +:= 1
    return
end

# repeat e
procedure Repeat(e)			
   controls["repeat e"] +:= 1
   return
end

# return e
procedure Return(e)			
   controls["return e"] +:= 1
   return
end

procedure Rlit(s)
   rlits[s] +:= 1
   return
end

# e1 ? e2
procedure Scan(e1, e2)			
   controls["e1 ? e2"] +:= 1
   return
end

# e1[e2 op  e3]
procedure Section(op, e1, e2, e3)	
   others["e1[e2" || op || "e3]"] +:= 1
   return
end

procedure Slit(s)
   slits[image(s)] +:= 1
   return
end

# static v1, v2, ..
procedure Static(ev[])			
   every statics[!ev] +:= 1
   declarations["static"] +:= *ev	# each name counts as a declaration
   return
end

# e1[e2]
procedure Subscript(e1, e2)		
   binops["e1[e2]"] +:= 1
   return
end

# suspend e
procedure Suspend(e)			
   controls["suspend e"] +:= 1
   return
end

# suspend e1 do e2
procedure SuspendDo(e1, e2)		
   controls["suspend e1 do e2"] +:= 1
   return
end

# e1 to e2
procedure To(e1, e2)			
   others["e1 to e2"] +:= 1
   return
end

# e1 to e2 by e3
procedure ToBy(e1, e2, e3)		
   others["e1 to e2 by e3"] +:= 1
   return
end

# |e
procedure Repalt(e)			
   controls["|e"] +:= 1
   return
end

# op e (op may be compound)
procedure Unop(s)			
   every unops[!s || "e"] +:= 1
   return
end

# until e
procedure Until(e)			
   controls["until e"] +:= 1
   return
end

# until e1 do e2
procedure UntilDo(e1, e2)		
   controls["until e1 do e2"] +:= 1
   return
end

procedure Var(s)
   vars[s] +:= 1
   return
end

# while e
procedure While(e)			
   controls["while e"] +:= 1
   return
end

# while e1 do e2
procedure WhileDo(e1, e2)		
   controls["while e1 do e2"] +:= 1
   return
end
