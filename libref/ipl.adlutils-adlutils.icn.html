<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>adlutils.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     adlutils.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures to process address lists
<a name="6"/>#
<a name="7"/>#	Author:   Ralph E. Griswold
<a name="8"/>#
<a name="9"/>#	Date:     January 3, 1994
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#     Procedures used by programs that process address lists:
<a name="18"/>#
<a name="19"/>#	 nextadd()		get next address
<a name="20"/>#	 writeadd(add)		write address
<a name="21"/>#	 get_country(add)	get country
<a name="22"/>#	 get_state(add)		get state (U.S. addresses only)
<a name="23"/>#	 get_city(add)		get city (U.S. addresses only)
<a name="24"/>#	 get_zipcode(add)	get ZIP code (U.S. addresses only)
<a name="25"/>#	 get_lastname(add)	get last name
<a name="26"/>#	 get_namepfx(add)	get name prefix
<a name="27"/>#	 get_title(add)		get name title
<a name="28"/>#	 format_country(s)	format country name
<a name="29"/>#
<a name="30"/>############################################################################
<a name="31"/>#
<a name="32"/>#  Links:  lastname, io, namepfx, title
<a name="33"/>#
<a name="34"/>############################################################################
<a name="35"/>
<a name="36"/>package ipl.adlutils
<a name="37"/>
<a name="38"/>import
<a name="39"/>   io(write),
<a name="40"/>   ipl.io(PutBack, Read),
<a name="41"/>   ipl.lastname(lastname),
<a name="42"/>   ipl.namepfx(namepfx),
<a name="43"/>   ipl.title(title)
<a name="44"/>
<a name="45"/>record label(header, text, comments)
<a name="46"/>
<a name="47"/>procedure nextadd()
<a name="48"/>   local comments, header, line, text
<a name="49"/>
<a name="50"/>   initial {			# Get to first label.
<a name="51"/>      while line := Read() do
<a name="52"/>         line ? {
<a name="53"/>            if ="#" then {
<a name="54"/>               PutBack(line)
<a name="55"/>               break
<a name="56"/>               }
<a name="57"/>            }
<a name="58"/>      }
<a name="59"/>
<a name="60"/>   header := Read() | fail
<a name="61"/>
<a name="62"/>   comments := text := ""
<a name="63"/>
<a name="64"/>   while line := Read() do
<a name="65"/>      line ? {
<a name="66"/>         if pos(0) then next	# Skip empty lines.
<a name="67"/>         else if ="*" then comments ||:= "\n" || line
<a name="68"/>         else if ="#" then {	# Header for next label.
<a name="69"/>            PutBack(line)
<a name="70"/>            break		# Done with current label.
<a name="71"/>            }
<a name="72"/>         else text ||:= "\n" || line
<a name="73"/>         }
<a name="74"/>   every text | comments ?:= {	# Strip off leading newline, if any.
<a name="75"/>      move(1)
<a name="76"/>      tab(0)
<a name="77"/>      }
<a name="78"/>
<a name="79"/>   return label(header, text, comments)
<a name="80"/>
<a name="81"/>end
<a name="82"/>
<a name="83"/>procedure writeadd(add)
<a name="84"/>
<a name="85"/>   if *add.text + *add.comments = 0 then return
<a name="86"/>   write(add.header)
<a name="87"/>   if *add.text &gt; 0 then write(add.text)
<a name="88"/>   if *add.comments &gt; 0 then write(add.comments)
<a name="89"/>
<a name="90"/>   return
<a name="91"/>
<a name="92"/>end
<a name="93"/>
<a name="94"/>procedure get_country(add)
<a name="95"/>
<a name="96"/>   trim(add.text) ? {
<a name="97"/>      while tab(upto('\n')) do move(1)
<a name="98"/>      if tab(0) ? {
<a name="99"/>         tab(-1)
<a name="100"/>         any(&amp;digits)
<a name="101"/>         } then return "U.S.A."
<a name="102"/>      else return tab(0)
<a name="103"/>      }
<a name="104"/>end
<a name="105"/>
<a name="106"/>procedure get_state(add)
<a name="107"/>
<a name="108"/>   trim(add.text) ? {
<a name="109"/>      while tab(upto('\n')) do move(1)
<a name="110"/>      ="APO"
<a name="111"/>      while tab(upto(',')) do move(1)
<a name="112"/>      tab(many(' '))
<a name="113"/>      return (tab(any(&amp;ucase)) || tab(any(&amp;ucase))) | "XX"
<a name="114"/>      }
<a name="115"/>
<a name="116"/>end
<a name="117"/>
<a name="118"/># only works for U.S. addresses
<a name="119"/>procedure get_city(add)		
<a name="120"/>   local result
<a name="121"/>
<a name="122"/>   result := ""
<a name="123"/>   trim(add.text) ? {
<a name="124"/>      while tab(upto('\n')) do move(1)
<a name="125"/>      result := ="APO"
<a name="126"/>      result ||:= tab(upto(','))
<a name="127"/>      return result
<a name="128"/>      }
<a name="129"/>
<a name="130"/>end
<a name="131"/>
<a name="132"/>
<a name="133"/>
<a name="134"/>procedure get_zipcode(add)
<a name="135"/>   local zip
<a name="136"/>
<a name="137"/>   trim(add.text) ? {
<a name="138"/>      while tab(upto('\n')) do move(1)		# get to last line
<a name="139"/>      while tab(upto(' ')) do tab(many(' '))	# get to last field
<a name="140"/>      zip := tab(0)
<a name="141"/>      if *zip = 5 &amp; integer(zip) then return zip
<a name="142"/>      else if *zip = 10 &amp; zip ? {
<a name="143"/>         integer(move(5)) &amp; ="-" &amp; integer(tab(0))
<a name="144"/>         }
<a name="145"/>      then return zip
<a name="146"/>      else return "9999999999"			# "to the end of the universe"
<a name="147"/>      }
<a name="148"/>
<a name="149"/>end
<a name="150"/>
<a name="151"/>procedure get_lastname(add)
<a name="152"/>
<a name="153"/>   return lastname(add.text ? tab(upto('\n') | 0))
<a name="154"/>
<a name="155"/>end
<a name="156"/>
<a name="157"/>procedure get_namepfx(add)
<a name="158"/>
<a name="159"/>   return namepfx(add.text ? tab(upto('\n') | 0))
<a name="160"/>
<a name="161"/>end
<a name="162"/>
<a name="163"/>procedure get_title(add)
<a name="164"/>
<a name="165"/>   return title(add.text ? tab(upto('\n') | 0))
<a name="166"/>
<a name="167"/>end
<a name="168"/>
<a name="169"/>procedure format_country(s)
<a name="170"/>   local t, word
<a name="171"/>
<a name="172"/>   s := map(s)
<a name="173"/>   t := ""
<a name="174"/>   s ? while tab(upto(&amp;lcase)) do {
<a name="175"/>      word := tab(many(&amp;lcase))
<a name="176"/>      if word == "of" then t ||:= word
<a name="177"/>      else t ||:= {
<a name="178"/>         word ? {
<a name="179"/>            map(move(1),&amp;lcase,&amp;ucase) || tab(0)
<a name="180"/>            }
<a name="181"/>         }
<a name="182"/>      t ||:= move(1)
<a name="183"/>      }
<a name="184"/>   return t
<a name="185"/>end
</pre></body></html>
