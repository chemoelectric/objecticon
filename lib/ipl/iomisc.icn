package ipl.io

import
   io(Files, FileOpt, FileStream, DirStream, FilePath, stop), 
   util(use),
   exception(throw)

#
# Return an open file to /dev/null.  The returned file is shared
# and so should not be closed.
#
procedure get_null()
   static nul
   initial
      nul := FileStream(Files.NULL_FILE, FileOpt.RDWR) | stop("Can't open " || Files.NULL_FILE || ": ", &why)
   return nul
end

#
# Return an open file to /dev/zero.  The returned file is shared
# and so should not be closed.
#
procedure get_zero()
   static zero
   initial
      zero := FileStream("/dev/zero", FileOpt.RDWR) | stop("Can't open /dev/zero: ", &why)
   return zero
end

package record Msg(file, revert)

package procedure dir_recurse2(s, f, revert, on_err)
   local p, f2, l
   coact(Msg(f, &current), revert)
   p := FilePath(f)
   repeat {
      l := s.read_line() | fail
      if /l then
         return
      if Files.is_relative_dir(l) then
         next
      f2 := p.child(l).str() 
      if Files.is_directory(f2) then
         dir_recurse1(f2, revert, on_err)
      else
         coact(Msg(f2, &current), revert)
   }
end

#
# Procedure to use with `dir_recurse`; it just throws an exception
# with the value set to an informative error message.
#
procedure dir_recurse_throw(f)
   throw("Failed to read dir " || f || ": " || &why)
end

package procedure dir_recurse1(f, revert, on_err)
   local s
   use {
      s := DirStream(f),
      dir_recurse2(s, f, revert, on_err)
   } | on_err(f)
end

#
# Recursively traverse directory `f`, generating all the filenames
# (including directories).  If this generator isn't used to
# exhaustion, the call must be wrapped in the `util.clean()` function,
# in order to close all outstanding files.  `on_err` is an optional
# procedure to invoke on an error reading a directory.  If it throws
# an exception, then the call to `dir_recurse` should also be enclosed
# with one of the try procedures.
#
# @see `dir_recurse_throw()`
# @example
# @   clean{try1{{
# @      every f := dir_recurse(d, dir_recurse_throw) \ 50 do
# @         write("got ", f)
# @   }}} | write("Problem: ", &why)
#
procedure dir_recurse(f, on_err)
   local v, here, e
   here := &current
   /on_err := 1
   e := create dir_recurse1(f, here, on_err)
   v := @e | fail
   repeat {
      suspend v.file
      v := coact(, v.revert) | fail
   }
end
