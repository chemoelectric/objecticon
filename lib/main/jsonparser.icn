package json

import 
   lang,
   util,
   io,
   exception

class JSONParser()
   public static const 
      WS_CHAR,
      UNESCAPED_CHAR

   private
      utf8_flag,
      true,
      false,
      null

   private static init()
      WS_CHAR := ' \t\n\r'
      UNESCAPED_CHAR := '\x20-\x21\x23-\x5B\x5D-\U10FFFF'
   end

   #
   # Set a value to represent json "true"; by default `&yes`.
   #
   public set_true(x)
      self.true := x
      return self
   end

   #
   # Set a value to represent json "false"; by default `&no`.
   #
   public set_false(x)
      self.false := x
      return self
   end

   #
   # Set a value to represent json "null"; by default `&null`.
   #
   public set_null(x)
      self.null := x
      return self
   end

   private parse_number()
      local s
      s := (=u"-" | "") || 
         (=u"0" | (tab(any('123456789')) || (tab(many(&digits)) | ""))) ||
         ((=u"." || tab(many(&digits))) | "") ||
         ((=(u"e" | u"E") || (tab(any('+\-')) | "") || tab(many(&digits))) | "") | err("Invalid number")
      return numeric(s) | err("Number out of range")
   end

   private parse_string()
      local res
      # Shortcut for common case
      if =u"\"" & res := tab(many(UNESCAPED_CHAR)) & =u"\"" then
         return res
      return use {
         res := RamStream(),
         parse_string1(res)
      }
   end

   private parse_string1(res)
      local t, ch, i
      =u"\""
      repeat {
         res.out(tab(many(UNESCAPED_CHAR)))
         if pos(0) then
            err("Unclosed quote")
         if =u"\"" then
            break
         if =u"\\" then {
            ch := move(1) | err("Unclosed quote")
            res.out(case string(ch) of {
               "\"": "\""
               "\\": "\\"
               "/": "/"
               "b": "\b"
               "f": "\f"
               "n": "\n"
               "r": "\r"
               "t": "\t"
               "u": {
                  many(&digits ++ 'ABCDEFabcdef', t := move(4)) = 5 | err("Invalid \\u escape")
                  i := integer("16r" || t)
                  if \utf8_flag then
                     Text.utf8_seq(i | 63)
                  else
                     char(i | 63)
               }
               default: err("Invalid escape char in string: " || ch)
            })
         } else
            err("Invalid char in string:" || image(&subject[&pos]))
      }
      res := res.str()
      return if \utf8_flag then ucs(res) else res
   end

   private parse_value()
      return if =u"false" then
         false
      else if =u"true" then
         true
      else if =u"null" then
         null
      else if any('[') then
         parse_array()
      else if any('{') then
         parse_object()
      else if any('-' ++ &digits) then
         parse_number()
      else if any('\"') then
         parse_string()
      else
         err("Unexpected char: " || &subject[&pos])
   end

   private next_token()
      tab(many(WS_CHAR))
   end

   private parse_array()
      local res
      res := []
      =u"["
      next_token()
      if =u"]" then
         return res
      repeat {
         put(res, parse_value())
         next_token()
         if =u"]" then
            return res
         =u"," | err(", expected")
         next_token()
      }
      return res
   end

   private parse_object()
      local res, m, v
      res := table()
      =u"{"
      next_token()
      if =u"}" then
         return res
      repeat {
         m := parse_string()
         next_token()
         =u":" | err(": expected")
         next_token()
         v := parse_value()
         next_token()
         insert(res, m, v)
         if =u"}" then
            return res
         =u"," | err(", expected")
         next_token()
      }
      return res
   end

   private end_check(o)
      next_token()
      pos(0) | err("Extraneous input:" || tab(0))
      return o
   end

   private parse_impl()
      next_token()
      return if any('[') then
         parse_array()
      else if any('{') then
         parse_object()
      else
         err("[ or { expected")
   end

   private err(s)
      s ||:= " (char " || &pos || ")"
      throw(s)
   end

   public parse(s)
      s := text(s) | runerr(129, s)
      utf8_flag := Yes{ type(s) == "ucs" }
      return s ? clean{try1{ end_check(parse_impl()) }}
   end

   public new()
      true := &yes
      false := &no
      return
   end
end
