<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>bitstrm.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     bitstrm.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures to read and write strings of bits in files
<a name="6"/>#
<a name="7"/>#	Author:   Robert J. Alexander
<a name="8"/>#
<a name="9"/>#	Date:     August 14, 1996
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#  Procedures for reading and writing integer values made up of an
<a name="18"/>#  arbitrary number of bits, stored without regard to character
<a name="19"/>#  boundaries.
<a name="20"/>#
<a name="21"/>############################################################################
<a name="22"/>#
<a name="23"/>#  Usage of BitStreamWrite, by example:
<a name="24"/>#
<a name="25"/>#       record bit_value(value, nbits)
<a name="26"/>#       ...
<a name="27"/>#       BitStreamWrite()                        #initialize
<a name="28"/>#       while value := get_new_value() do       # loop to output values
<a name="29"/>#               BitStreamWrite(outfile, value.nbits, value.value)
<a name="30"/>#       BitStreamWrite(outfile)                 # output any buffered bits
<a name="31"/>#
<a name="32"/>#  Note the interesting effect that BitStreamWrite(outproc), as well as
<a name="33"/>#  outputting the complete string, pads the output to an even character
<a name="34"/>#  boundary.  This can be dune during construction of a bit string if
<a name="35"/>#  the effect is desired.
<a name="36"/>#
<a name="37"/>#  The "value" argument defaults to zero.
<a name="38"/>#
<a name="39"/>############################################################################
<a name="40"/>#
<a name="41"/>#  Usage of BitStreamRead, by example:
<a name="42"/>#
<a name="43"/>#       BitStreamRead()
<a name="44"/>#       while value := BitStreamRead(infile, nbits) do
<a name="45"/>#               # do something with value
<a name="46"/>#
<a name="47"/>#  BitStringRead fails when too few bits remain to satisfy a request.
<a name="48"/>#
<a name="49"/>############################################################################
<a name="50"/>#
<a name="51"/>#  See also: bitstr.icn
<a name="52"/>#
<a name="53"/>############################################################################
<a name="54"/>
<a name="55"/>package ipl.bitstrm
<a name="56"/>
<a name="57"/>import
<a name="58"/>   io(reads, writes)
<a name="59"/>
<a name="60"/>procedure BitStreamWrite(outfile,bits,value,outproc)
<a name="61"/>    local outvalue
<a name="62"/>    static buffer,bufferbits
<a name="63"/>    #
<a name="64"/>    #  Initialize.
<a name="65"/>    #
<a name="66"/>    initial {
<a name="67"/>	 buffer := bufferbits := 0
<a name="68"/>	    }
<a name="69"/>    /outproc := writes
<a name="70"/>    #
<a name="71"/>    #  If this is "close" call, flush buffer and reinitialize.
<a name="72"/>    #
<a name="73"/>    if /value then {
<a name="74"/>	 outvalue := &amp;null
<a name="75"/>	 if bufferbits &gt; 0 then
<a name="76"/>		  outproc(outfile,char(outvalue := ishift(buffer,8 - bufferbits)))
<a name="77"/>	 buffer := bufferbits := 0
<a name="78"/>	 return outvalue
<a name="79"/>	    }
<a name="80"/>    #
<a name="81"/>    #  Merge new value into buffer.
<a name="82"/>    #
<a name="83"/>    buffer := ior(ishift(buffer,bits),value)
<a name="84"/>    bufferbits +:= bits
<a name="85"/>    #
<a name="86"/>    #  Output bits.
<a name="87"/>    #
<a name="88"/>    while bufferbits &gt;= 8 do {
<a name="89"/>	 outproc(outfile,char(outvalue := ishift(buffer,8 - bufferbits)))
<a name="90"/>	 buffer := ixor(buffer,ishift(outvalue,bufferbits - 8))
<a name="91"/>	 bufferbits -:= 8
<a name="92"/>	    }
<a name="93"/>    return outvalue
<a name="94"/>end
<a name="95"/>
<a name="96"/>
<a name="97"/>procedure BitStreamRead(infile,bits,inproc)
<a name="98"/>    local value
<a name="99"/>    static buffer,bufferbits
<a name="100"/>    #
<a name="101"/>    #  Initialize.
<a name="102"/>    #
<a name="103"/>    initial {
<a name="104"/>	 buffer := bufferbits := 0
<a name="105"/>	    }
<a name="106"/>    #
<a name="107"/>    #  Reinitialize if called with no arguments.
<a name="108"/>    #
<a name="109"/>    if /infile then {
<a name="110"/>	 buffer := bufferbits := 0
<a name="111"/>	 return
<a name="112"/>	    }
<a name="113"/>    #
<a name="114"/>    #  Read in more data if necessary.
<a name="115"/>    #
<a name="116"/>    /inproc := reads
<a name="117"/>    while bufferbits &lt; bits do {
<a name="118"/>	 buffer := ior(ishift(buffer,8),ord(inproc(infile))) | fail
<a name="119"/>	 bufferbits +:= 8
<a name="120"/>	    }
<a name="121"/>    #
<a name="122"/>    #  Extract value from buffer and return.
<a name="123"/>    #
<a name="124"/>    value := ishift(buffer,bits - bufferbits)
<a name="125"/>    buffer := ixor(buffer,ishift(value,bufferbits - bits))
<a name="126"/>    bufferbits -:= bits
<a name="127"/>    return value
<a name="128"/>end
</pre></body></html>
