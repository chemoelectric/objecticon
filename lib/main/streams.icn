package io

import
   util(error, need_flag, need_integer, need_string,
        save_why, HasMode, HasCloseUnderlying, HasClose,
        lclose),
   lang(Class, NoCopy),
   posix(System),
   ipl.strings(replace),
   ipl.printf

$if _UNIX
import util(env_string)
$endif

#
# This is the top-level stream class.  It is not instantiated
# directly.
#
abstract class Stream(HasClose, HasMode)
   public static const
      # Constant indicating read capability
      READ,
      # Constant indicating write capability
      WRITE,
      # Constant indicating seek (and tell) capability
      SEEK,
      # Constant indicating truncate capability
      TRUNCATE,
      # Constant indicating read and write capability
      READ_WRITE,
      # Constant representing all capabilities (read, write, seek and
      # truncate).
      ALL

   private static init()
      READ := 1
      WRITE := 2
      SEEK := 4
      TRUNCATE := 8
      READ_WRITE := READ + WRITE
      ALL := READ + WRITE + SEEK + TRUNCATE
   end

   #
   # Return at least one, and up to n characters from the stream.  On
   # end-of-file, return `&null`.  On error, fail and set `&why`.
   #
   # :Parameters :
   # :  `n` - the maximum number of chars to read; n must be > 0.
   #
   public optional in(n)

   #
   # Output the given string to the stream.  The number of characters
   # output is returned, which will always be greater than zero
   # (unless s is empty), but may be less than `*s`.  Fails on an
   # error, setting `&why`.
   #
   # :Parameters :
   # :  `s` - the string to write
   #
   public optional out(s)

   #
   # Seek to the given offset.  Icon-style offsets are used, so 1 is
   # the beginning of the stream, and 0 the end.  Not all types of stream
   # support `seek` - see `get_mode`.
   #
   # :Parameters :
   # :  `offset` - the position to seek to
   # :Returns :
   # :  the new position.
   #
   public optional seek(offset)

   #
   # Return the current position of the stream.
   #
   public optional tell()

   #
   # Truncate this stream to the given length.  The file position
   # remains unchanged.
   #
   public optional truncate(len)

   #
   # Read a complete line from the stream, reading up to the next "\n"
   # or end-of-file.  In the former case, the "\n" and also any "\r"
   # immediately before it is stripped from the result.
   #
   # Returns `&null` on end-of-file
   #
   public read_line()
      local s, c
      s := ""
      repeat {
         c := in(1) | fail
         if /c then {
            if *s > 0 then
               return s
            else
               return
         }
         if c == "\n" then {
            if s[-1] == "\r" then
               s[-1] := ""
            return s
         } else
            s ||:= c
      }
   end

   #
   # Read `n` chars from the stream.  This method will try and return
   # exactly `n` characters, and will only return less because of
   # reaching the end-of-file.
   # 
   # If end-of-file is encountered before any characters were read, 
   # then `&null` is returned.
   #
   public read_exactly(n)
      local s, t
      n := need_integer(n, 1)
      s := ""
      while n > 0 do {
         t := in(n) | fail
         if /t then {
            if *s > 0 then
               return s
            else
               return
         }
         s ||:= t
         n -:= *t
      }
      return s
   end

   #
   # Generate all the remaining lines in the file
   #
   public gen()
      suspend |\read_line()
   end

   #
   # This method is the same as `read_line`, except that on end of
   # file it fails, setting `&why` to "End of file", rather than
   # returning `&null`.
   #
   public read()
      local s
      s := read_line() | fail
      return \s | error("End of file")
   end

   #
   # This method is the same as `read_exactly`, except that on end of
   # file it fails, setting `&why` to "End of file", rather than
   # returning `&null`.
   #
   public reads(n)
      local s
      s := read_exactly(n) | fail
      return \s | error("End of file")
   end

   #
   # Output the string `s`, by calling `out` several times until it is
   # fully output.
   #
   public writes1(s)
      local n
      s := need_string(s)
      while *s > 0 do {
         n := out(s) | fail
         s := s[n + 1:0]
      }
      link
   end

   #
   # Output the string `s`, followed by a newline.
   # 
   public write1(s)
      local e
      every e := s | "\N" do
         writes1(e) | fail
      link
   end

   #
   # This writes each parameter to the stream.  Each parameter is
   # guaranteed to be completely output, except on error, in which
   # case the method fails and sets &why.
   #
   public writes(a[])
      local e
      every e := !a do
         writes1(e) | fail
      link
   end

   #
   # This behaves just like `writes`, except that a newline is
   # appended after all the parameters are output.
   #
   public write(a[])
      local e
      every e := !a | "\N" do
         writes1(e) | fail
      link
   end

   #
   # Read from this stream until end-of-file, collecting the result as
   # a string.
   #
   public read_all()
      local s, t
      s := ""
      repeat {
         t := in(1048576) | fail
         if /t then
            return s
         s ||:= t
      }
   end

   #
   # Read from this stream until end-of-file, copying the result to the
   # given stream `f`.
   #
   public copy_to(f)
      local s
      repeat {
         s := in(1048576) | fail
         if /s then
            link
         f.writes1(s) | fail
      }
   end
end

# Check that x is a `Stream`, signalling a runtime error otherwise.
#
procedure need_Stream(x)
   is(x, Stream) | runerr("Stream expected", x)
   return x
end

#
# This is a stream based on an Icon string.  An initial string can be
# provided to the constructor.  Reading from the stream will be quite
# efficient, but writing will be relatively slow, particularly if the
# string is long.  For a much faster alternative, see `RamStream`.
#
class StringStream(Stream)
   private 
      subj,
      pos

   public override in(n)
      local t, e
      n := need_integer(n, 1)
      if pos > *subj then
         return
      e := min(pos + n, *subj + 1)
      t := subj[pos:e]
      pos := e
      return t
   end

   public override out(s)
      local e
      s := need_string(s)
      if pos > *subj then {
         subj ||:= repl("\0", pos - *subj - 1) || s
         pos := *subj + 1
      } else {
         e := min(pos + *s, *subj + 1)
         subj[pos:e] := s
         pos +:= *s
      }
      return *s
   end

   public override read_line()
      local i, s
      if pos > *subj then
         return
      if i := upto('\n', subj, pos) then {
         s := subj[pos:i]
         pos := i + 1
         if s[-1] == "\r" then
            s[-1] := ""
      } else {
         s := subj[pos:0]
         pos := *subj + 1
      }
      return s
   end

   public override seek(offset)
      offset := need_integer(offset)
      return .if offset > 0 then
         pos := offset
      else if -offset <= *subj then
         pos := *subj + 1 + offset
      else
         error("Seek out of range")
   end

   public override tell()
      return .pos
   end

   public override get_mode()
      return ALL
   end

   public override truncate(len)
      len := need_integer(len)
      if len > *subj then
         subj ||:= repl("\0", len - *subj)
      else if len >= 0 then
         subj := subj[1:len + 1]
      else
         return error("Negative truncate length")
      link
   end

   public str()
      return .subj
   end

   #
   # Create a new `StringStream`, with initial value of `subj`.
   #
   # :Parameters :
   # :  `subj` - the initial value of the stream; defaults to empty 
   #        string.
   #
   public new(subj)
      self.subj := need_string(\subj) | ""
      self.pos := 1
      return
   end
end

#
# This is a stream that mimics /dev/null.  Writes always succeed with
# no effect, and reads always fail with end of file.
#
class NullStream(Stream)
   public override in(n)
      return
   end

   public override out(s)
      s := need_string(s)
      return *s
   end

   public override seek(offset)
      return 1
   end

   public override tell()
      return 1
   end

   public override get_mode()
      return ALL
   end

   public override truncate(len)
      link
   end
end

#
# This is a stream that mimics /dev/zero.  Writes always succeed with
# no effect, and reads return however many zero bytes were requested.
#
class ZeroStream(Stream)
   public override in(n)
      return repl("\0", need_integer(n, 1))
   end

   public override out(s)
      s := need_string(s)
      return *s
   end

   public override seek(offset)
      return 1
   end

   public override tell()
      return 1
   end

   public override get_mode()
      return ALL
   end

   public override truncate(len)
      link
   end
end

#
# This class takes another stream and provides read/write buffers so
# that input/output to the inner stream tends to take place in larger
# chunks.
#
class BufferStream(Stream, HasCloseUnderlying)
   private const
      other
   private
      rpos,
      wbuff,
      wbuff_len,
      rbuff,
      flush_on_nl_flag,
      buff_size

   #
   # If set, the stream is flushed whenever a newline is written.
   #
   public set_flush_on_nl(s)
      self.flush_on_nl_flag := need_flag(s)
      link
   end

   #
   # Set the buffer size to use.
   #
   public set_buff_size(n)
      self.buff_size := n
      link
   end

   #
   # Push the string s onto the read buffer, so that it is read next.
   #
   public push(s)
      s := need_string(s)
      unbuff() | fail
      rbuff := s || rbuff
      link
   end

   #
   # Push the string s followed by an end-of-line.
   #
   public push_line(s)
      return push(s || "\N")
   end

   public override read_line()
      local t
      flush() | fail
      repeat {
         rbuff ? {
            if t := tab(upto('\n')) then {
               move(1)
               rbuff := tab(0)
               \rpos +:= *t + 1
               if t[-1] == "\r" then
                  t[-1] := ""
               return t
            }
         }
         if *rbuff = 0 & other.can(SEEK) then
            rpos := other.tell() | fail
         t := other.in(buff_size) | fail
         if /t then {
            rpos := &null
            if *rbuff = 0 then
               return
            t := rbuff
            rbuff := ""
            return t
         }
         rbuff ||:= t
      }
   end

   public override in(n)
      local t
      n := need_integer(n, 1)
      flush() | fail
      if *rbuff > 0 then {
         rbuff ? {
            t := move(n) | tab(0)
            rbuff := tab(0)
            \rpos +:= *t
         }
      } else if n < buff_size then {
         if other.can(SEEK) then
            rpos := other.tell() | fail
         t := other.in(buff_size) | fail
         if /t then
            return
         t ? {
            t := move(n) | tab(0)
            rbuff := tab(0)
            \rpos +:= *t
         }
      } else {
         t := other.in(n) | fail
         if /t then
            return
      }
      return t
   end

   public override out(s)
      s := need_string(s)
      unbuff() | fail
      # Avoid concatenating a large s in flush().
      if *s > buff_size then
         flush() | fail
      if *s > 0 then {
         put(wbuff, s)
         wbuff_len +:= *s
      }
      if wbuff_len > buff_size | (\flush_on_nl_flag & upto('\n', s)) then
         flush() | fail
      return *s
   end

   #
   # Flush the write buffer.
   #
   public flush()
      local s
      \wbuff | runerr(219, self)
      if *wbuff = 0 then
         link
      s := ""
      every s ||:= !wbuff
      clear(wbuff)
      wbuff_len := 0
      link other.writes1(s)
   end

   #
   # Un-buffer the read buffer.  For a seekable stream this involves
   # discarding the read buffer and seeking to the position
   # corresponding to the start of the buffer.  For a non-seekable
   # stream, this call has no effect.
   #
   public unbuff()
      \rbuff | runerr(219, self)
      if *rbuff > 0 & \rpos & other.can(SEEK) then {
         other.seek(rpos) | fail
         rbuff := ""
         rpos := &null
      }
      link
   end

   #
   # Calls `unbuff` and `flush`
   #
   public synch()
      unbuff() | fail
      flush() | fail
      link
   end

   public override close()
      local f
      flush() | (f := &why)
      if \close_underlying_flag then
         other.close() | (/f := &why)
      rbuff := wbuff := &null
      return if /f then self else error(f)
   end

   public override seek(offset)
      synch() | fail
      return other.seek(offset)
   end

   public override tell()
      synch() | fail
      return other.tell()
   end

   public override truncate(len)
      synch() | fail
      link other.truncate(len)
   end

   public override get_mode()
      return other.get_mode()
   end

   public new(other)
      self.other := need_Stream(other)
      self.rbuff := ""
      self.wbuff := []
      self.wbuff_len := 0
      self.buff_size := 8192
      self.close_underlying_flag := &yes
      return
   end
end

#
# This is the parent class of streams based on a posix-style
# integer-based file descriptor.
#
abstract class DescStream(Stream, NoCopy)
   protected 
      fd,
      mode

   #
   # Return the integer file descriptor; fails if the stream is
   # closed.
   #
   public get_fd()
      return .\fd
   end

   public override get_mode()
      return .mode
   end

   #
   # Performs a poll on one or more streams, each of which must be a
   # `DescStream`.  The parameter `l` is a list of pairs.  Each pair
   # is a `Stream` followed by flags, which should be selected from
   # those constants in the `Poll` class.  The last argument is the
   # optional timeout. The result is a list of the flags corresponding
   # to each `Stream` provided.  This method fails on error, setting
   # `&why` accordingly.  On a timeout, it succeeds and returns
   # `&null`.
   #
   public static native poll(l, timeout)

   #
   # Utility to check whether the result of a `poll` for `Poll.IN` indicates
   # a call to `in`.
   #
   public static poll_in_test(v)
      local x
      # Ignore OUT
      v := iand(v, icom(Poll.OUT))
      # Succeed if either IN or HUP is set, but no other.
      x := iand(v, ior(Poll.IN,Poll.HUP))
      succeed x ~= 0 & x = v
   end

   #
   # Utility to check whether the result of a `poll` for `Poll.OUT` indicates
   # a call to `out`.
   #
   public static poll_out_test(v)
      # Ignore IN
      v := iand(v, icom(Poll.IN))
      # Succeed if OUT is set, but no other.
      succeed v = Poll.OUT
   end

   #
   # Try to set `&why` to a helpful value based on any error value
   # stored in the stream.  This is particularly useful after `poll`
   # has indicated an error.  `v` is an optional default value of
   # `&why`.
   #
   public abstract improve_why(v)

   #
   # Turn the specified flags on or off, and return the new set of
   # flags.  The flags should be selected from the constants in
   # `FileOpt`.
   # :Parameters :
   # :  `on` - the flags to turn on
   # :  `off` - the flags to turn off
   # :Returns :
   # :  the new flags
   #
   public native flag(on, off)

   #
   # Turn the specified descriptor flags on or off, and return the new
   # set of flags.  The flags should be selected from the constants in
   # `DescOpt`.
   # :Parameters :
   # :  `on` - the flags to turn on
   # :  `off` - the flags to turn off
   # :Returns :
   # :  the new flags
   #
   public native dflag(on, off)

   #
   # Invokes the system function dup2(oldfd, newfd), with oldfd set to
   # this instance's `fd`, and newfd set to the given parameter's `fd`.
   #
   # On error this method fails and sets `&why`.  On success, it sets
   # the mode of the target to this instances's mode (since they both
   # now point to the same file), and returns `&null`.
   #
   # For example :-
   # ~
   #   f := FileStream("/tmp/xyz", 
   #       ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT)) | stop(&why)
   #   f.dup2(FileStream.stdout) | stop(&why)
   #   f.close()
   #   write("hello world")  # writes to /tmp/xyz
   # ~
   # :Parameters :
   # :  `other` - a `DescStream`
   public dup2(other)
      dup2_impl(other) | fail
      other.mode := self.mode
      link
   end

   private native dup2_impl()

   protected native dup_impl()

   #
   # Return a `Stat` object with info about this file.
   #
   public stat()
      return Stat!stat_impl()
   end

   private native stat_impl()

   #
   # Write selected attributes about a file.  If any of the parameters
   # are `&null`, they are left unchanged.  The nanosecond parameters
   # are ignored unless their corresponding time fields are being set.
   #
   # :Parameters :
   # :  `mode` - the mode (an integer)
   # :  `uid` - the owner id
   # :  `gid` - the group id
   # :  `atime` - the access time (an integer)
   # :  `mtime` - the modification time (an integer)
   # :  `atime_ns` - the access time nanosecond part (an integer, default 0)
   # :  `mtime_ns` - the modification time nanosecond part (an integer, default 0)
   #
   public native wstat(mode, uid, gid, atime, mtime, atime_ns, mtime_ns)

   # Helper function for initialization methods.
   #
   protected setup(fd, mode)
      self.fd := fd
      self.mode := mode
      link
   end
end

#
# This procedure emulates the old Icon builtin function of the same
# name.  It always returns a `BufferStream` or fails and sets `&why`.
# 
# :Parameters :
# :  `name` - The file name
# :  `mode` - The mode; possible values are :-
#    :  "r" - `FileStream` with `FileOpt.RDONLY`
#    :  "w" - `FileStream` with `FileOpt.WRONLY`, `FileOpt.TRUNC`, `FileOpt.CREAT`
#    :  "b"|"rw"|"r+" - `FileStream` with `FileOpt.RDWR`
#    :  "crw"|"w+" - `FileStream` with `FileOpt.RDWR`, `FileOpt.TRUNC`, `FileOpt.CREAT`
#    :  "a" - `FileStream` with `FileOpt.WRONLY`, `FileOpt.APPEND`, `FileOpt.CREAT`
#    :  "a+" - `FileStream` with `FileOpt.RDWR`, `FileOpt.APPEND`, `FileOpt.CREAT`
#    :  "p"|"pr" - `ProgInputStream`, using shell interpreter
#    :  "pw" - `ProgOutputStream`, using shell interpreter
#    :  "prw" - `ProgInputOutputStream`, using shell interpreter
#
procedure open(name, mode)
   return BufferStream(case mode of {
      &null | "r" : FileStream(name, FileOpt.RDONLY)
      "w" : FileStream(name, ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT))
      "b"|"rw"|"r+" : FileStream(name, FileOpt.RDWR)
      "crw"|"w+" : FileStream(name, ior(FileOpt.RDWR, FileOpt.TRUNC, FileOpt.CREAT))
      "a" : FileStream(name, ior(FileOpt.WRONLY, FileOpt.APPEND, FileOpt.CREAT))
      "a+" : FileStream(name, ior(FileOpt.RDWR, FileOpt.APPEND, FileOpt.CREAT))
$if _UNIX
      "p"|"pr" : ProgInputStream("/bin/sh", ["-c", name])
      "pw" : ProgOutputStream("/bin/sh", ["-c", name])
      "prw" : ProgInputOutputStream("/bin/sh", ["-c", name])
$else
      "p"|"pr"|"pw"|"prw" : error("Mode not supported")
$endif
      default: runerr("Invalid mode flag: " || mode)
   })
end

#
# Convenient method to call `write` with standard error as output.
#
procedure ewrite(a[])
   return write!push(a, FileStream.stderr)
end

#
# Convenient method to call `writes` with standard error as output.
#
procedure ewrites(a[])
   return writes!push(a, FileStream.stderr)
end

#
# This procedure emulates the old Icon builtin `write` function.
#
procedure write(a[])
   local e, f, r
   r := a[-1]
   f := if is(a[1], Stream) then
      pop(a)
   else
      FileStream.stdout
   every e := \!a | "\N" do {
      if is(e, Stream) then {
         f.writes1("\N") | fail
         f := e
      } else
         f.writes1(e) | fail
   }
   return r
end

#
# This procedure emulates the old Icon builtin `writes` function.
#
procedure writes(a[])
   local e, f, r
   r := a[-1]
   f := if is(a[1], Stream) then
      pop(a)
   else
      FileStream.stdout
   every e := \!a do {
      if is(e, Stream) then
         f := e
      else
         f.writes1(e) | fail
   }
   return r
end

#
# This procedure emulates the old Icon builtin `stop` function.
#
procedure stop(a[])
   write!push(a, FileStream.stderr)
   exit(1)
end

#
# This procedure emulates the old Icon builtin `read` function.
#
procedure read(f)
   /f := FileStream.stdin
   return f.read()
end

#
# This procedure emulates the old Icon builtin `reads` function.
#
procedure reads(f, n)
   /f := FileStream.stdin
   /n := 1
   return f.reads(n)
end

#
# This procedure emulates the old Icon builtin `close` function.
#
procedure close(f)
   return f.close()
end

#
# This class represents a stream based on a local file.
#
class FileStream(DescStream)
   public static const
      # A `FileStream` representing standard input
      stdin, 
      # A `FileStream` representing standard output
      stdout,
      # A `FileStream` representing standard error
      stderr

   private static create_for_fd(fd, mode)
      return Class.create_instance().setup(fd, mode)
   end

   #
   # Return a new instance which has a duplicated file descriptor
   # (using the dup() system call), and the same mode as this
   # instance.
   #
   public dup()
      return create_for_fd(dup_impl(), mode)
   end

   public override improve_why(v)
      &why := \v | "I/O error"
   end

   #
   # Open a new `FileStream` using the underlying system open
   # function.
   # :Parameters :
   # :  `name` - the file name
   # :  `flags` - the flags, selected from `FileOpt`, if perm
   #        and mode are omitted, defaults to `FileOpt.RDONLY`
   # :  `perm` - the create permissions to use if a file is
   #        created, selected from `Mode`.
   # :  `mode` - the resulting `Stream`'s mode; if omitted
   #        this is deduced from `flags` parameter and the
   #        type of file being opened.
   #
   public new(name, flags, perm, mode)
      if \mode then
         return setup(new_impl(name, flags, perm), mode)
      if /perm then
        /flags := FileOpt.RDONLY
      #
      # Set the READ/WRITE mode flags based on the FileOpt flags.
      #
      mode := case iand(flags, FileOpt.ACCMODE) of {
         FileOpt.RDONLY: READ
         FileOpt.WRONLY: WRITE
         FileOpt.RDWR: READ_WRITE
         default: return error("Invalid flags combination")
      }
      return setup(new_impl(name, flags, perm), mode).adjust_mode()
   end

   # Adjust this FileStream's mode based on the file type returned by
   # stat().  If it is a regular file, add SEEK capability, and
   # TRUNCATE too for a writable file.
   #
   private adjust_mode()
      if stat().mode_str[1] == "-" then {
         if can(WRITE) then
            mode := ior(mode, TRUNCATE)
         mode := ior(mode, SEEK)
      } else {
         if save_why{tell()} then
            mode := ior(mode, SEEK)
      }
      link
   end

   private static native new_impl(path, flags, perm)

   private static init()
      stdin := create_for_fd(0, READ).adjust_mode()
      stdout := create_for_fd(1, WRITE).adjust_mode()
      stderr := create_for_fd(2, WRITE).adjust_mode()
   end

   #
   # Create a pair of `PipeStream`s using the pipe system call.
   #
   public static pipe()
      local t
      t := pipe_impl() | fail
      return [PipeStream(t[1], READ), PipeStream(t[2], WRITE)]
   end

   private static native pipe_impl()

   #
   # This method provides an interface to the system pread function.
   #
   # NB - for consistency with `seek` and `tell`, `offset` is one
   # based.
   #
   # :Parameters :
   # :  `n` - the maximum number of chars to read; n must be > 0.
   # :  `offset` - the one-based offset to seek to before reading.
   #
   public native pread(n, offset)

   #
   # This method provides an interface to the system pwrite function.
   #
   # NB - for consistency with `seek` and `tell`, `offset` is one
   # based.
   #
   # :Parameters :
   # :  `s` - the string to write
   # :  `offset` - the one-based offset to seek to before writing.
   #
   public native pwrite(s, offset)

   #
   # Succeed if this `FileStream` represents a tty supporting links.
   #
   public is_flowterm_tty()
$if _UNIX
      static flowterm
      initial
         flowterm := integer(env_string("FLOWTERM"))
      return case flowterm of {
         1 : isatty()
         2 : &null
      }
$endif
   end

   public override native in(n)

   public override native out(s)

   public override native seek(offset)

   public override native tell()

   public override native truncate(len)

   public native chdir()

   public native isatty()

   public native ttyname()

   public override native close()
end

#
# This subclass of `FileStream` is the type returned by
# `FileStream.pipe`; it overrides the `out` method to catch signals on
# writing to a closed pipe.  These cause simple failure of `out`,
# rather than terminating the program.
#
class PipeStream(FileStream)
   public override dup()
      return PipeStream(dup_impl(), mode)
   end

   public override native out(s)

   package override new(fd, mode)
      setup(fd, mode)
      return
   end
end

#
# This class encapsulates data received from a particular source
# address.
#
class Received()
   public const
      data, src

   package new(data, src)
      self.data := data
      self.src := src
      return
   end
end

#
# This class represents a stream based on a socket.
#
class SocketStream(DescStream)
   private static create_for_fd(fd, mode)
      return Class.create_instance().setup(fd, mode)
   end

   #
   # Return a new instance which has a duplicated file descriptor
   # (using the dup() system call), and the same mode as this
   # instance.
   #
   public dup()
      return create_for_fd(dup_impl(), mode)
   end

   #
   # Create a socket with the given domain and type.
   #
   # :Parameters :
   # :  `domain` - from `ProtocolFormat`.  The default is
   #      `ProtocolFormat.INET` 
   # :  `typ` - the type from `SocketType`.  The default is
   #      `SocketType.STREAM`.
   #
   public new(domain, typ)
      return setup(new_impl(domain, typ), READ_WRITE)
   end

   #
   # Create a pair of sockets of the given type
   #
   # :Parameters :
   # :  `typ` - the type from `SocketType`.  The default is
   #   `SocketType.STREAM`.
   #
   public static socketpair(typ)
      local t
      t := socketpair_impl(typ) | fail
      return [create_for_fd(t[1], READ_WRITE), create_for_fd(t[2], READ_WRITE)]
   end

   #
   # Create a pair of sockets of the given type, but communication is limited to
   # one direction.  The first socket is the reader, and the second the writer.
   #
   # :Parameters :
   # :  `typ` - the type from `SocketType`.  The default is
   #   `SocketType.STREAM`.
   #
   public static one_way_socketpair(typ)
      local t, l
      t := socketpair_impl(typ) | fail
      l := [create_for_fd(t[1], READ), create_for_fd(t[2], WRITE)]
      l[2].shutdown(Shut.RD)
      l[1].shutdown(Shut.WR)
      return l
   end

   public override native in(n)

   #
   # Connect a socket to the given address.  The address is a string
   # in the form "unix:<filename>" for an `AF_UNIX` address,
   # "inet:<host>:<port>" for an `AF_INET` address, or
   # "inet6:<host>:<port>" for an `AF_INET6` address.  The "wildcard"
   # host can be specified by using the host string "*".
   #
   public native connect(addr)

   #
   # Bind a socket to the given address, which is in the same form as
   # for `connect`.
   #
   public native bind(addr)

   #
   # Listen for connections with the given backlog.
   #
   public native listen(backlog)

   #
   # Returns a string giving the address and port of the peer
   # connected to the socket, in the format used by the
   # `connect` method.
   #
   public native get_peer()

   #
   # Returns the local address of the socket, in the same format
   # as returned by `get_peer()`.
   #
   public native get_local()

   #
   # Accept a new connection, returning a new `SocketStream`.
   #
   public accept()
      return create_for_fd(accept_impl(), READ_WRITE)
   end

   #
   # Perform a shutdown on the socket.
   # :Parameters :
   # :  `how` - one of the constants in `Shut`
   #
   public native shutdown(how)

   #
   # Send the given string `s` (which may be empty) to the address
   # `dest`, which should be in the format used by the `connect`
   # method.
   #
   # :Parameters :
   # :  `s` - the message to send (a string)
   # :  `dest` - the destination
   # :  `flags` - optional selection of flags from `MessageOpt`
   #
   public native sendto(s, dest, flags)

   #
   # Receive a message of up to length `n`. The result on success is
   # a `Received` object encapsulating data and source address, which
   # will be in the format used by the `connect` method.  Unlike
   # `in()`, the data returned may be the empty string (and never
   # `&null`).
   #
   # :Parameters :
   # :  `n` - the limit of the message length
   # :  `flags` - optional selection of flags from `MessageOpt`
   #
   public recvfrom(n, flags)
      return Received!recvfrom_impl(n, flags)
   end

   private native recvfrom_impl(n, flags)

   #
   # Set values using the underlying setsockopt call.  The options
   # listed in the following table are recognized :-
   #
   # <https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_10_16>
   # 
   # Symbolic options can be found in the `SocketOpt` class.
   #
   # Flag values should have a `&yes` or `&no` argument.  `LINGER`
   # accepts `&null` meaning "off", or an integer value meaning on
   # with that seconds value.  The timeout values are in milliseconds.
   #
   public native setopt(opt, arg)

   #
   # Get values using the underlying getopt call; see `setopt` above.
   # `ERROR` will return `&null` if no error is set, or an error string
   # in the same format as `&why`.
   #
   public native getopt(opt)

   public override improve_why(v)
      &why := \getopt(SocketOpt.ERROR) | \v | "I/O error"
   end

   #
   # Return a list of IP numerical addresses for the given host.
   # 
   # The second parameter, `ver`, an integer, specifies the IP
   # versions which the result list can contain.  Possible values
   # are :-
   #
   # * 4 - return only v4 addresses
   # * 6 - return only v6 addresses
   # * 46 - return either v4 or v6 addresses, with v4 coming first
   # * 64 - return either v4 or v6 addresses, with v6 coming first
   # * 0 - return either v4 or v6 addresses, in the order returned by
   #       the underlying system call.
   #
   # If `ver` is omitted, the value given by the environment variable
   # `OI_IP_VERSION` is used; if that is unset then `4` is used.
   #
   # :Parameters :
   # :  `host` - the host name (a string)
   # :  `ver` - the IP version(s) to try
   public static native dns_query(host, ver)

   private native accept_impl()

   public override native out(s)

   public override native close()

   private static native socketpair_impl(typ)

   private static native new_impl(domain, typ)
end

#
# Parent class for classes which wish to define in() in terms of
# reading one line at time, rather than the other way round.
#
abstract class LineBasedInputStream(Stream)
   private
      line

   public override read_line()
      local t
      if *line > 0 then {
         t := line[1:-*"\N"]
         line := ""
         return t
      }
      return read_line_impl()
   end

   public override in(n)
      local t
      n := need_integer(n, 1)
      if *line = 0 then {
         t := read_line_impl() | fail
         if /t then
            return
         line := t || "\N"
      }
      line ? {
         t := move(n) | tab(0)
         line := tab(0)
      }
      return t
   end

   public override get_mode()
      return READ
   end

   #
   # Implemented to read a single line.  The EOL should not be
   # included.  Fails on error and returns `&null` on end-of-file
   #
   protected abstract read_line_impl()

   public new()
      self.line := ""
      return
   end
end

#
# Parent class for classes which wish to define out() in terms of
# writing one line at time, rather than the other way round.
#
abstract class LineBasedOutputStream(Stream)
   private
      buff

   public override out(s)
      local t, c
      s := need_string(s)
      if *s > 0 then {
         put(buff, s)
         if upto('\n', s) then {
            c := ""
            every c ||:= !buff
            clear(buff)
            c ? {
               while t := tab(upto('\n')) do {
                  if t[-1] == "\r" then
                     t[-1] := ""
                  write_line_impl(t) | fail
                  move(1)
               }
               pos(0) | put(buff, tab(0))
            }
         }
      }
      return *s
   end

   #
   # Implemented to output a single line.  The EOL is not included in
   # `s`.
   #
   protected abstract write_line_impl(s)
   
   public override get_mode()
      return WRITE
   end

   public new()
      self.buff := []
      return
   end
end

#
# This class is used to read directory contents.
#
final class DirStream(LineBasedInputStream, NoCopy)
   private 
      ptr

   protected override native read_line_impl()

   public override native close()

   private static native new_impl(path)

   public override new(path)
      LineBasedInputStream.new()
$if _MS_WIN32
      if *path = 0 then
         return error("Empty path")
      if any('\\/:', path[-1]) then
         path ||:= "*"
      else if not upto('*?', path) then
         path ||:= "\\*"
$endif
      self.ptr := new_impl(path) | fail
      return
   end
end

# Convenient superclass of classes which use a background process.
#
abstract class HasBgProc()
   protected
      pid,
      exit_info

   #
   # Wait for the child to exit, setting `exit_info`.
   #
   protected do_wait()
      \pid | runerr("do_wait() called out of sequence")
      # wait should never fail (even if the child crashed).
      exit_info := System.wait(pid) | syserr("System.wait failed unexpectedly: " || &why)
      pid := &null
      return
   end

   #
   # Return `ExitInfo` of the child process
   #
   public get_exit_info()
      return .\exit_info
   end

   #
   # Return process id of the child process
   #
   public get_pid()
      return .\pid
   end
end

# Convenient superclass of classes which have an optional `Task` to
# use for polling.
#
abstract class HasTask()
   protected
      task

   #
   # Set a `Task` to use when polling
   #
   public set_task(t)
      self.task := t
      link
   end

   #
   # Poll, either using the task's poll, or `DescStream.poll` if task
   # is unset.
   #
   protected choose_poll(l, timeout)
      return (if /task then DescStream else task).poll(l, timeout)
   end
end

#
# This stream represents a pipe to a command running in a forked child
# process.
#
class ProgInputStream(SocketStream, HasBgProc)
   #
   # Close the stream.  This waits for the child process to terminate.
   #
   public override close()
      shutdown(Shut.RD)
      SocketStream.close()
      do_wait()
      link
   end

   # Open a new readable `Stream` based on the given command.  The
   # first three parameters are the same as for the method
   # `posix.System.exec`;  the last two optionally give the standard
   # input and standard error of the command; by default the command
   # inherits these from the parent.  If the stderr param is the string
   # "pipe", then stderr is sent to the pipe along with stdout.
   #
   # For example :-
   # ~
   #     g := FileStream("/tmp/data",FileOpt.RDONLY) | stop(&why)
   #     f := ProgInputStream("wc", ["-l"],,g) | stop(&why)
   #     g.close()
   #     while write(f.read())   # writes the number of lines in /tmp/data
   #     f.close()
   # ~
   public override new(cmd, args, env, stdin, stderr)
      local l
      l := one_way_socketpair() | fail
      (pid := System.fork()) | {
         save_why{ lclose(l) }
         fail
      }
      if pid > 0 then {
         # Parent
         l[2].close()
         return setup(l[1].get_fd(), READ)
      } else {
         # Child
         if \stdin then
            stdin.dup2(FileStream.stdin) | stop(&why)
         if \stderr then {
            if stderr === "pipe" then
               l[2].dup2(FileStream.stderr) | stop(&why)
            else
               stderr.dup2(FileStream.stderr) | stop(&why)
         }
         l[2].dup2(FileStream.stdout) | stop(&why)
         lclose(l)
         System.exec(cmd, args, env) | stop(&why)
         syserr("Not reached")
      }
   end
end

#
# This stream represents a pipe from a command running in a forked child
# process.
#
class ProgOutputStream(SocketStream, HasBgProc)
   #
   # Close the stream.  This waits for the child process to terminate.
   #
   public override close()
      shutdown(Shut.WR)
      SocketStream.close()
      do_wait()
      link
   end

   # Open a new writeable `Stream` based on the given command. The
   # first three parameters are the same as for the method
   # `posix.System.exec`; the last two optionally give the standard
   # output and standard error of the command; by default the command
   # inherits these from the parent.
   #
   # For example :-
   # ~
   #      g := FileStream("/tmp/result",ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT)) | stop(&why)
   #      f := ProgOutputStream("wc", ["-l"],,g) | stop(&why)
   #      g.close()
   #      f.write("data")
   #      f.close()
   #      # Now /tmp/result contains "1" (ie, the output of wc -l applied to the data written to f)
   # ~
   public override new(cmd, args, env, stdout, stderr)
      local l
      l := one_way_socketpair() | fail
      (l[2].dflag(DescOpt.CLOEXEC) &
       pid := System.fork()) | {
          save_why{ lclose(l) }
          fail
       }
      if pid > 0 then {
         # Parent
         l[1].close()
         return setup(l[2].get_fd(), WRITE)
      } else {
         # Child
         if \stdout then
            stdout.dup2(FileStream.stdout) | stop(&why)
         if \stderr then
            stderr.dup2(FileStream.stderr) | stop(&why)
         l[1].dup2(FileStream.stdin) | stop(&why)
         lclose(l)
         System.exec(cmd, args, env) | stop(&why)
         syserr("Not reached")
      }
   end
end

#
# This stream represents a bi-directional pipe to a command running in
# a forked child process.
#
class ProgInputOutputStream(SocketStream, HasBgProc)
   #
   # Close the stream.  This waits for the child process to terminate.
   #
   public override close()
      shutdown(Shut.RDWR)
      SocketStream.close()
      do_wait()
      link
   end

   # Open a new readable and writeable `Stream` based on the given
   # command.  The first three parameters are the same as for the
   # method `posix.System.exec`; `stderr` optionally gives the
   # standard error of the command; by default the command inherits
   # this from the parent.  If the stderr param is the string "pipe",
   # then stderr is sent to the pipe along with stdout.
   #
   # For example :-
   # ~
   #     f := ProgInputOutputStream("myprog", []) | stop(&why)
   #     f.write("Some input")
   #     s := f.read()  # The response
   #     f.close()
   # ~
   public override new(cmd, args, env, stderr)
      local l
      l := SocketStream.socketpair() | fail
      (l[1].dflag(DescOpt.CLOEXEC) &
       pid := System.fork()) | {
         save_why{ lclose(l) }
         fail
      }
      if pid > 0 then {
         # Parent
         l[2].close()
         return setup(l[1].get_fd(), READ_WRITE)
      } else {
         # Child
         if \stderr then {
            if stderr === "pipe" then
               l[2].dup2(FileStream.stderr) | stop(&why)
            else
               stderr.dup2(FileStream.stderr) | stop(&why)
         }
         l[2].dup2(FileStream.stdout) | stop(&why)
         l[2].dup2(FileStream.stdin) | stop(&why)
         lclose(l)
         System.exec(cmd, args, env) | stop(&why)
         syserr("Not reached")
      }
   end
end

#
# Base class for FilterOutputStream and FilterInputStream
#
package abstract class FilterStreamBase(Stream, HasBgProc, HasCloseUnderlying, HasTask, NoCopy)
   protected
      cmd,
      err_sink,
      cin,
      cout,
      cerr

   # Convenient function to check that the command exited
   # successfully.  If it did, this function returns, otherwise it
   # fails and sets `&why` appropriately, based on the exit code and
   # stderr output.  The error sink must be set to a `StringStream` to
   # use this function.
   #
   public succeeded()
      local x
      is(err_sink, StringStream) | runerr("Must use a StringStream as error sink with succeeded()", err_sink)
      x := get_exit_info() | runerr("succeeded() can only be called after close()")
      if x.succeeded() then
         return
      return whyf("%s failed: %w: %s", cmd, trim(replace(err_sink.str(), "\n", " ")))
   end

   protected do_poll()
      local x, l, v
      l := []
      if \cin then
         every put(l, cin | Poll.IN)
      if \cerr then
         every put(l, cerr | Poll.IN)
      if \cout then
         every put(l, cout | Poll.OUT)
      if *l = 0 then
         runerr(219, self)
      x := choose_poll(l) | fail
      if \cin & (v := pop(x)) > 0 then {
         return if DescStream.poll_in_test(v) then
            cin
         else {
            cin.improve_why()
            whyf("Error on cin poll: %w")
         }
      }
      if \cerr & (v := pop(x)) > 0 then {
         return if DescStream.poll_in_test(v) then
            cerr
         else {
            cerr.improve_why()
            whyf("Error on cerr poll: %w")
         }
      }
      if \cout & (v := pop(x)) > 0 then {
         return if DescStream.poll_out_test(v) then
            cout
         else {
            cout.improve_why()
            whyf("Error on cout poll: %w")
         }
      }
      syserr("Invalid poll result")
   end

   protected close_cin()
      if \cin then {
         cin.shutdown(Shut.RD)
         cin.close()
         cin := &null
      }
   end

   protected close_cerr()
      if \cerr then {
         cerr.shutdown(Shut.RD)
         cerr.close()
         cerr := &null
      }
   end

   protected close_cout()
      if \cout then {
         cout.shutdown(Shut.WR)
         cout.close()
         cout := &null
      }
   end

   protected setup(cmd, args, env, err_sink)
      local l
      self.cmd := cmd
      /err_sink := StringStream()
      self.err_sink := err_sink
      l := SocketStream.one_way_socketpair() | fail
      (l |||:= SocketStream.one_way_socketpair() &
       l |||:= SocketStream.one_way_socketpair() &
       l[1].flag(FileOpt.NONBLOCK) & 
       l[4].dflag(DescOpt.CLOEXEC) &
       l[4].flag(FileOpt.NONBLOCK) & 
       l[5].flag(FileOpt.NONBLOCK) &
       pid := System.fork()) | {
          save_why{ lclose(l) }
          fail
       }
      if pid > 0 then {
         # Parent
         cin := l[1]
         cout := l[4]
         cerr := l[5]
         l[2].close()
         l[3].close()
         l[6].close()
         return
      } else {
         # Child
         l[2].dup2(FileStream.stdout) | stop(&why)
         l[3].dup2(FileStream.stdin) | stop(&why)
         l[6].dup2(FileStream.stderr) | stop(&why)
         lclose(l)
         System.exec(cmd, args, env) | stop(&why)
         syserr("Not reached")
      }
   end
end

#
# This stream filters output written to it through a background
# process and outputs the results to an arbitrary sink `Stream`.
#
# For example :-
# ~
#   # Encode s, putting the result in a RamStream
#   r := RamStream()
#   g := FilterOutputStream(r, "gzip", ["-c"])
#   g.write(s)
# ~
class FilterOutputStream(FilterStreamBase)
   private 
      sink

   private cp_cin()
      local t
      t := cin.in(1048576) | fail
      if /t then
         close_cin()
      else
         sink.writes1(t) | fail
      return
   end

   private cp_cerr()
      local t
      t := cerr.in(1048576) | fail
      if /t then
         close_cerr()
      else
         err_sink.writes1(t) | fail
      return
   end

   public override out(s)
      s := need_string(s)
      repeat {
         case do_poll() of {
            cin: cp_cin()
            cerr: cp_cerr()
            cout: return cout.out(s)
         } | fail
      }
   end

   private flush_remaining()
      while \cin | \cerr do {
         case do_poll() of {
            cin: cp_cin()
            cerr: cp_cerr()
            default: syserr("Unexpected result from do_poll")
         } | fail
      }
      return
   end

   # Close the stream.  This waits for the child process to terminate,
   # flushing any remaining output to `sink`.  NB: `sink` and
   # `err_sink` are not closed unless the `set_close_underlying` has
   # been set to `&yes`.
   #
   public override close()
      local f
      \pid | runerr(219, self)
      close_cout()
      flush_remaining() | (f := &why)
      close_cin()
      close_cerr()
      if \close_underlying_flag then {
         sink.close() | (/f := &why)
         (err_sink === sink) | err_sink.close() | (/f := &why)
      }
      do_wait()
      return if /f then self else error(f)
   end

   public override get_mode()
      return WRITE
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `sink` - the `Stream` to which data is output from the command.
   #        Defaults to a `NullStream`.
   # :  `cmd` - the name of the command                                    
   # :  `args` - the arg list                                              
   # :  `env` - the env list                                               
   # :  `err_sink` - optional stream to send standard error to.  If omitted,
   #        defaults to a `StringStream`, which can then be used together
   #        with `succeeded()` to check the command's exit status.
   public new(sink, cmd, args, env, err_sink)
      /sink := NullStream()
      self.sink := sink
      setup(cmd, args, env, err_sink) | fail
      return
   end
end

#
# This stream filters data taken from an arbitrary source `Stream`
# through a background process.  The output from that process can then
# be read as this `Stream`'s output.
#
# For example :-
# ~
#   g := FilterInputStream(StringStream(s), "gzip", ["-c"])
#   # Reading from g will give the compressed value of the string s.
#   res := g.read_all()
# ~
class FilterInputStream(FilterStreamBase)
   private 
      source,
      buff

   public override in(n)
      local x, i, t
      repeat {
         x := do_poll() | {
            if \cout then {
               # The child has exited, but the data has yet to reach
               # the input pipes; close cout and go round again to
               # wait for input or hup on cin/cerr.
               close_cout()
               next
            }
            fail
         }
         case x of {
            cin: {
               t := cin.in(n) | fail
               if /t then
                  close_cout()
               return t
            }
            cerr: {
               t := cerr.in(1048576) | fail
               if /t then {
                  close_cout()
                  close_cerr()
               } else
                  err_sink.writes1(t) | fail
            }
            cout: {
               if *buff = 0 then {
                  buff := source.in(1048576) | fail
                  if /buff then {
                     close_cout()
                     next
                  }
               }
               i := cout.out(buff) | {
                  # Broken pipe; this is caused by the command exiting
                  # between the do_poll() and the out() call.
                  close_cout()
                  next
               }
               buff := buff[i + 1:0]
            }
         }
      }
   end

   #
   # Exchange the handling of the command's stdout and stderr, so that
   # stdout goes to the stderr sink and stderr is read by calling
   # `in()`
   #
   public swap_outputs()
      cin :=: cerr
      link
   end

   private flush_cerr()
      local x, t
      while \cerr do {
         x := do_poll() | fail
         case x of {
            cerr: {
               t := cerr.in(1048576) | fail
               if /t then
                  close_cerr()
               else
                  err_sink.writes1(t) | fail
            }
            default:
               syserr("Unexpected result from do_poll")
         }
      }
      return
   end

   #
   # Close the stream.  This waits for the child process to terminate.
   # NB: `source` and `err_sink` are not closed unless the
   # `set_close_underlying` has been set to `&yes`.
   #
   public override close()
      local f
      \pid | runerr(219, self)
      close_cout()
      close_cin()
      flush_cerr() | (f := &why)
      close_cerr()
      if \close_underlying_flag then {
         source.close() | (/f := &why)
         err_sink.close() | (/f := &why)
      }
      do_wait()
      self.buff := &null
      return if /f then self else error(f)
   end

   public override get_mode()
      return READ
   end
   
   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `source` - the `Stream` from which data is given to the command.
   #        Defaults to a `NullStream`.
   # :  `cmd` - the name of the command                                    
   # :  `args` - the arg list                                              
   # :  `env` - the env list                                               
   # :  `err_sink` - optional stream to send standard error to.  If omitted,
   #        defaults to a `StringStream`, which can then be used together
   #        with `succeeded()` to check the command's exit status.
   public new(source, cmd, args, env, err_sink)
      /source := NullStream()
      self.source := source
      self.buff := ""
      setup(cmd, args, env, err_sink) | fail
      return
   end
end

#
# This class provides a `Stream` which stores its data in memory.  It
# can be used to efficiently concatenate together many strings, or as
# a convenient temporary stream.
#
final class RamStream(Stream, NoCopy)
   private
      ptr

   public override native in(n)

   public override native out(s)

   public override native read_line()

   public override native seek(offset)

   public override native tell()

   public override native truncate(len)

   #
   # Return the current content of the `RamStream` as a string.
   #
   public native str()

   public override native close()

   #
   # Close the stream and return the finished content as a string.
   #
   public done()
      local s
      s := str()
      close()
      return s
   end

   private static native new_impl(s, wiggle)

   public override get_mode()
      return ALL
   end

   #
   # Create a new `RamStream`, with initial value of `s`.
   #
   # :Parameters :
   # :  `s` - the initial value of the stream; defaults to empty 
   #        string.
   # :  `wiggle` - the extra space to reserve for growth of the buffer,
   #        default is 512 bytes.
   #
   public new(s, wiggle)
      ptr := new_impl(s, wiggle)
      return
   end
end

#
# This stream takes a list of other streams.  Its output is the concatenation of
# the output of those streams.
#
class SequenceStream(Stream, HasCloseUnderlying)
   private const
      a, ac

   public override in(n)
      local s
      repeat {
         if *a = 0 then
            return
         s := a[1].in(n) | fail
         if \s then
            return s
         pop(a)
      }
   end

   public override get_mode()
      return READ
   end

   public override close()
      if \close_underlying_flag then
         lclose(ac) | fail
      link
   end

   public new(a[])
      self.a := a
      self.ac := copy(a)
      return
   end
end

# A `Stream` which takes its data from a co-expression.  Each result
# provides one line of output.  End-of-file is signalled by the
# co-expression generating `&null` and errors are signalled by it
# failing and setting `&why`.
#
# For example :-
# ~
#     # A stream with 10 lines
#     e := LineBasedGeneratorStream{ (1 to 10) | &null }
# ~
class LineBasedGeneratorStream(LineBasedInputStream, NoCopy)
   private
      coex

   protected override read_line_impl()
      local t
      if /coex then
         return
      (t := @coex) | {
         coex := &null
         fail
      }
      if /t then {
         coex := &null
         return
      }
      return need_string(t)
   end

   public override new(coex)
      self.coex := coex
      LineBasedInputStream.new()
      return
   end
end

# A `Stream` which takes its data from a co-expression.  Each result
# provides a chunk of output of arbitrary size.  End-of-file is
# signalled by the co-expression generating `&null` and errors are
# signalled by it failing and setting `&why`.
#
# For example :-
# ~
#     # A stream containing a string repeated indefinitely.
#     e := GeneratorStream{ |"The quick brown fox" }
#
#     # A stream containing lines of random digits.
#     e := GeneratorStream{ |?(&digits ++ '\n') }
# ~
class GeneratorStream(Stream, NoCopy)
   private
      coex, buff

   public override get_mode()
      return READ
   end

   public override in(n)
      local t
      if /coex then
         return
      while *buff = 0 do {
         (t := @coex) | {
            coex := &null
            fail
         }
         if /t then {
            coex := &null
            return
         }
         buff := need_string(t)
      }
      buff ? {
         t := move(n) | tab(0)
         buff := tab(0)
      }
      return t
   end

   public new(e)
      self.coex := e
      self.buff := ""
      return
   end
end

# A `FileStream` which wraps a unix pseudo-terminal file.  This can be
# used to communicate with a child process, such as a shell.
#
class PttyStream(FileStream)
   public const
      slave_name

   public native set_size(cols, rows)

   private static native new_impl()
   private static native prepare_slave(f)

   #
   # Open the slave corresponding to this instance (the master file).
   # This is called by the child process to establish its end of the
   # communication channel.
   #
   public open_slave()
      local f
      f := FileStream(slave_name, FileOpt.RDWR) | fail
      prepare_slave(f) | {
         save_why{ f.close() }
         fail
      }
      return f
   end

   public override new()
      local l
      l := new_impl() | fail
      slave_name := l[2]
      return setup(l[1], READ_WRITE)
   end
end

$if _MS_WIN32

#
# Win32 Winsock socket stream.
#
class WinsockStream(Stream, NoCopy)
   private
      socket

   private static create_for_socket(socket)
      local o
      o := Class.create_instance()
      o.socket := socket
      return o
   end

   #
   # Create a socket with the given domain and type.
   #
   # :Parameters :
   # :  `domain` - from `ProtocolFormat`.  The default is
   #      `ProtocolFormat.INET` 
   # :  `typ` - the type from `SocketType`.  The default is
   #      `SocketType.STREAM`.
   #
   public new(domain, typ)
      self.socket := new_impl(domain, typ) | fail
      return
   end

   public override native in(n)

   public override native out(s)

   #
   # Connect a socket to the given address.  The address is a string
   # in the form "inet:<host>:<port>" for an `AF_INET` address, or
   # "inet6:<host>:<port>" for an `AF_INET6` address.  The "wildcard"
   # host can be specified by using the host string "*".
   #
   public native connect(addr)

   public override get_mode()
      return READ_WRITE
   end

   #
   # Bind a socket to the given address, which is in the same form as
   # for `connect`.
   #
   public native bind(addr)

   #
   # Listen for connections with the given backlog.
   #
   public native listen(backlog)

   #
   # Returns a string giving the address and port of the peer
   # connected to the socket, in the format used by the
   # `connect` method.
   #
   public native get_peer()

   #
   # Returns the local address of the socket, in the same format
   # as returned by `get_peer()`.
   #
   public native get_local()

   #
   # Accept a new connection, returning a new `WinsockStream`.
   #
   public accept()
      return create_for_socket(accept_impl())
   end

   #
   # Perform a shutdown on the socket.
   # :Parameters :
   # :  `how` - one of the constants in `Shut`
   #
   public native shutdown(how)

   #
   # Set whether or not the socket is in blocking mode.
   #
   public native set_blocking_mode(flag)

   #
   # Send the given string `s` (which may be empty) to the address
   # `dest`, which should be in the format used by the `connect`
   # method.
   #
   # :Parameters :
   # :  `s` - the message to send (a string)
   # :  `dest` - the destination
   # :  `flags` - optional selection of flags from `MessageOpt`
   #
   public native sendto(s, dest, flags)

   #
   # Receive a message of up to length `n`. The result on success is
   # a `Received` object encapsulating data and source address, which
   # will be in the format used by the `connect` method.  Unlike
   # `in()`, the data returned may be the empty string (and never
   # `&null`).
   #
   # :Parameters :
   # :  `n` - the limit of the message length
   # :  `flags` - optional selection of flags from `MessageOpt`
   #
   public recvfrom(n, flags)
      return Received!recvfrom_impl(n, flags)
   end

   private native recvfrom_impl(n, flags)

   #
   # Set values using the underlying setsockopt call.  The options
   # listed in the following table are recognized :-
   #
   # <https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_10_16>
   # 
   # Symbolic options can be found in the `SocketOpt` class.
   #
   # Flag values should have a `&yes` or `&no` argument.  `LINGER`
   # accepts `&null` meaning "off", or an integer value meaning on
   # with that seconds value.  The timeout values are in milliseconds.
   #
   public native setopt(opt, arg)

   #
   # Get values using the underlying getopt call; see `setopt` above.
   # `ERROR` will return `&null` if no error is set, or an error string
   # in the same format as `&why`.
   #
   public native getopt(opt)

   #
   # Try to set `&why` to a helpful value based on any error value
   # stored in the stream.  This is particularly useful after `poll`
   # has indicated an error.  `v` is an optional default value of
   # `&why`.
   #
   public improve_why(v)
      &why := \getopt(SocketOpt.ERROR) | \v | "I/O error"
   end

   #
   # Return a list of IP numerical addresses for the given host.
   # 
   # The second parameter, `ver`, an integer, specifies the IP
   # versions which the result list can contain.  Possible values
   # are :-
   #
   # * 4 - return only v4 addresses
   # * 6 - return only v6 addresses
   # * 46 - return either v4 or v6 addresses, with v4 coming first
   # * 64 - return either v4 or v6 addresses, with v6 coming first
   # * 0 - return either v4 or v6 addresses, in the order returned by
   #       the underlying system call.
   #
   # If `ver` is omitted, the value given by the environment variable
   # `OI_IP_VERSION` is used; if that is unset then `4` is used.
   #
   # :Parameters :
   # :  `host` - the host name (a string)
   # :  `ver` - the IP version(s) to try
   public static native dns_query(host, ver)

   private native accept_impl()

   public override native close()

   private static native new_impl(domain, typ)
end

$endif
