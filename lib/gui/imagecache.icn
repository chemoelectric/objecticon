package gui

import 
   graphics, 
   util,
   cairo,
   ipl.graphics

$load HOME "images/gui.HOME_24.gif"
$load NEW_FOLDER "images/gui.NEW_FOLDER_24.gif"
$load REFRESH "images/gui.REFRESH_24.gif"
$load UP "images/gui.UP_24.gif"
$load PREV "images/gui.PREV_24.gif"
$load NEXT "images/gui.NEXT_24.gif"
$load CLOSE "images/gui.CLOSE_24.png"
$load CLOCK "images/gui.CLOCK_24.gif"
$load FONT "images/gui.FONT_24.gif"
$load FILESIZE "images/gui.FILESIZE_24.gif"
$load HIDDENFILE "images/gui.HIDDENFILE_24.gif"
$load FAVOURITES "images/gui.FAVOURITES_24.gif"
$load CONFIGURE "images/gui.CONFIGURE_24.gif"

final abstract class ImageCache()
   public static 
      imap,
      names

   private static init()
      names := table()
      imap := table()
      name_image("gui.HOME_24", HOME)
      name_image("gui.PREV_24", PREV)
      name_image("gui.NEXT_24", NEXT)
      name_image("gui.CLOSE_24", CLOSE)
      name_image("gui.NEW_FOLDER_24", NEW_FOLDER)
      name_image("gui.REFRESH_24", REFRESH)
      name_image("gui.UP_24", UP)
      name_image("gui.CLOCK_24", CLOCK)
      name_image("gui.FONT_24",FONT)
      name_image("gui.FILESIZE_24", FILESIZE)
      name_image("gui.HIDDENFILE_24", HIDDENFILE)
      name_image("gui.FAVOURITES_24", FAVOURITES)
      name_image("gui.CONFIGURE_24", CONFIGURE)

      name_image("gui.BOX_UP", "13,(0=shadow;1=hilite;~=transparent),_
~~~~~~~~~~~~~_
~11111111111~_
~11111111110~_
~11~~~~~~~00~_
~11~~~~~~~00~_
~11~~~~~~~00~_
~11~~~~~~~00~_
~11~~~~~~~00~_
~11~~~~~~~00~_
~11~~~~~~~00~_
~11000000000~_
~10000000000~_
~~~~~~~~~~~~~_
")
      name_image("gui.BOX_DOWN", "13,(b=black;0=shadow;1=hilite;~=transparent),_
~~~~~~~~~~~~~_
~00000000001~_
~00000000001~_
~00~~~~~~~11~_
~00~bbbbb~11~_
~00~bbbbb~11~_
~00~bbbbb~11~_
~00~bbbbb~11~_
~00~bbbbb~11~_
~00~~~~~~~11~_
~01111111111~_
~11111111111~_
~~~~~~~~~~~~~_
")
      name_image("gui.DIAMOND_UP", "13,(0=shadow;1=hilite;~=transparent),_
~~~~~~1~~~~~~_
~~~~~111~~~~~_
~~~~11~11~~~~_
~~~11~~~11~~~_
~~11~~~~~11~~_
~11~~~~~~~11~_
11~~~~~~~~~11_
~00~~~~~~~00~_
~~00~~~~~00~~_
~~~00~~~00~~~_
~~~~00~00~~~~_
~~~~~000~~~~~_
~~~~~~0~~~~~~_
")
      name_image("gui.DIAMOND_DOWN", "13,(b=black;0=shadow;1=hilite;~=transparent),_
~~~~~~0~~~~~~_
~~~~~000~~~~~_
~~~~00~00~~~~_
~~~00~b~00~~~_
~~00~bbb~00~~_
~00~bbbbb~00~_
00~bbbbbbb~00_
~11~bbbbb~11~_
~~11~bbb~11~~_
~~~11~b~11~~~_
~~~~11~11~~~~_
~~~~~111~~~~~_
~~~~~~1~~~~~~_
")
      name_image("gui.ARROW_UP", "11,(b=black;c=black 50%;~=transparent),_
~~~~~c~~~~~_
~~~~cbc~~~~_
~~~cbbbc~~~_
~~cbbbbbc~~_
~cbbbbbbbc~_
cbbbbbbbbbc_
")
      name_image("gui.ARROW_DOWN", "11,(b=black;c=black 50%;~=transparent),_
cbbbbbbbbbc_
~cbbbbbbbc~_
~~cbbbbbc~~_
~~~cbbbc~~~_
~~~~cbc~~~~_
~~~~~c~~~~~_
")
      name_image("gui.ARROW_LEFT", "9,(b=black;c=black 50%;~=transparent),_
~~~~~~~~c_
~~~~~~cbb_
~~~~cbbbb_
~~cbbbbbb_
cbbbbbbbb_
~~cbbbbbb_
~~~~cbbbb_
~~~~~~cbb_
~~~~~~~~c_
")
      name_image("gui.ARROW_RIGHT", "9,(b=black;c=black 50%;~=transparent),_
c~~~~~~~~_
bbc~~~~~~_
bbbbc~~~~_
bbbbbbc~~_
bbbbbbbbc_
bbbbbbc~~_
bbbbc~~~~_
bbc~~~~~~_
c~~~~~~~~_
")
      name_image("gui.TINY_ARROW_UP", "7,(b=black;c=black 50%;~=transparent),_
~~~c~~~_
~~cbc~~_
~cbbbc~_
cbbbbbc_
")
      name_image("gui.TINY_ARROW_DOWN", "7,(b=black;c=black 50%;~=transparent),_
cbbbbbc_
~cbbbc~_
~~cbc~~_
~~~c~~~_
")
      name_image("gui.PLUS", "9,(b=black;~=transparent),_
bbbbbbbbb_
b~~~~~~~b_
b~~~b~~~b_
b~~~b~~~b_
b~bbbbb~b_
b~~~b~~~b_
b~~~b~~~b_
b~~~~~~~b_
bbbbbbbbb_
")
      name_image("gui.MINUS", "9,(b=black;~=transparent),_
bbbbbbbbb_
b~~~~~~~b_
b~~~~~~~b_
b~~~~~~~b_
b~bbbbb~b_
b~~~~~~~b_
b~~~~~~~b_
b~~~~~~~b_
bbbbbbbbb_
")
      name_image("gui.TINY_X", "8,(b=black;~=transparent),_
bb~~~~bb_
~bb~~bb~_
~~~bb~~~_
~bb~~bb~_
bb~~~~bb_
")
      name_image("gui.HORIZ_GRID", "24,(0=shadow;1=hilite;~=transparent),_
~00~~~~~~~~00~~~~~~~~00~_
0011~~~~~~0011~~~~~~0011_
0111~~~~~~0111~~~~~~0111_
~11~~~~~~~~11~~~~~~~~11~_
")
      name_image("gui.VERT_GRID", "4,(0=shadow;1=hilite;~=transparent),_
~00~_
0011_
0111_
~11~_
~~~~_
~~~~_
~~~~_
~~~~_
~~~~_
~~~~_
~00~_
0011_
0111_
~11~_
~~~~_
~~~~_
~~~~_
~~~~_
~~~~_
~~~~_
~00~_
0011_
0111_
~11~_
")
      name_image("gui.CLOSED_FOLDER", "16,c1,_
~~~~~~~~~~~~~~~~_
~~~~0000~~~~~~~~_
~~~0;;;;0~~~~~~~_
~~0;;;;;;0~~~~~~_
~0000000000000~~_
~0;;;;;;;;;;;0~~_
~0;;;;;;;;;;;0~~_
~0;;;;;;;;;;;0~~_
~0;;;;;;;;;;;0~~_
~0;;;;;;;;;;;0~~_
~0;;;;;;;;;;;0~~_
~0;;;;;;;;;;;0~~_
~0000000000000~~_
~~~~~~~~~~~~~~~~_
")
      name_image("gui.OPEN_FOLDER", "16,c1,_
~~~~~~~~~~~~~~~~_
~~~0000~~~~~~~~~_
~~0DDDD0~~~~~~~~_
~0DDDDDD0~~~~~~~_
0000000000000~~~_
02D2D2D2D2D20~~~_
0D2D000000000000_
02D0DDDDDDDDDDD0_
0D20DDDDDDDDDD0~_
020DDDDDDDDDDD0~_
0D0DDDDDDDDDDD0~_
00DDDDDDDDDD00~~_
0000000000000~~~_
~~~~~~~~~~~~~~~~_
")
      name_image("gui.FILE", "16,c1,_
~~~~~~~~~~~~~~~~_
~~~0000000~~~~~~_
~~~06666600~~~~~_
~~~0606060~0~~~~_
~~~0666660000~~~_
~~~0600606660~~~_
~~~0666666660~~~_
~~~0600600060~~~_
~~~0666666660~~~_
~~~0600060660~~~_
~~~0666666660~~~_
~~~0666666660~~~_
~~~0000000000~~~_
~~~~~~~~~~~~~~~~_
")
      name_image("gui.WINDOW_CLOSE_BUTTON", "16,c1,_
~>>>>>>>>>>>>>>~_
>>iiiiiiiiiiii>>_
>iiiiiiiiiiiiii>_
>iiiiiiiiiiiiii>_
>iii<<iiii<<iii>_
>iii<6<ii<6<iii>_
>iiii<6<<6<iiii>_
>iiiii<66<iiiii>_
>iiiii<66<iiiii>_
>iiii<6<<6<iiii>_
>iii<6<ii<6<iii>_
>iii(<iiii<(iii>_
>iiiiiiiiiiiiii>_
>iiiiiiiiiiiiii>_
>>iiiiiiiiiiii>>_
~>>>>>>>>>>>>>>~_
")
      name_image("gui.WINDOW_ICONIFY_BUTTON", "16,c1,_
~>>>>>>>>>>>>>>~_
>>iiiiiiiiiiii>>_
>iiiiiiiiiiiiii>_
>iiiiiiiiiiiiii>_
>iiiiiiiiiiiiii>_
>iiiiiiiiiiiiii>_
>iiiiiiiiiiiiii>_
>iiiiiiiiiiiiii>_
>iiiiiiiiiiiiii>_
>iiiiiiiiiiiiii>_
>iiiiiiiiiiiiii>_
>iiiiiiiiiiiiii>_
>ii<<<<<<<<<<ii>_
>ii6666666666ii>_
>>iiiiiiiiiiii>>_
~>>>>>>>>>>>>>>~_
")
   end

   # Associate arbitrary image data (eg gif file data), with a name.
   # The name can then be passed to {get} or {load} to retrieve a
   # window with the corresponding image.
   #
   public static name_image(name, data)
      insert(names, name, data)
   end

   #
   # Return the data previously set with {name_image}.  Fails if the
   # name is unknown.
   #
   public static get_named_image(name)
      return member(names, name)
   end

   #
   # Place an entry into the window cache with the given key.  The
   # window should not be subsequently closed.
   #
   public static cache_window(key, win)
      insert(imap, key, win)
   end

   #
   # Return an entry in the window cache, or fail if the key is not
   # present.
   #
   public static get_cached_window(key)
      return member(imap, key)
   end

   #
   # Load an image, using the cache if possible.  The parameter `s`
   # should be either in Icon image format, a file name, or the name
   # of an image set by {name_image()}.  On a successful load, the
   # image is stored in the cache for future use, and thus should not
   # be closed after use.
   #
   public static get(s, win)
      return member(imap, get_key(s, win))
   end

   #
   # This is the same as `get`, but returns the key into the cached
   # window map, rather than the window.  If it succeeds, then the
   # returned key will be in the map, and the window can be retrieved
   # by `get_cached_window`.
   #
   public static get_key(s, win)
      local w, key, p
      key := s
      s := member(names, s)
      if is_image_string(s) then {
         if \win then
            key := Window.color_value(win.get_fg()) || "/" || Window.color_value(win.get_bg()) || "#" || key
         if w := member(imap, key) then
            return key
         w := use {
            p := parse_image_string(s, win),
            Window.open_image(p)
         } | fail
      } else {
         if w := member(imap, key) then
            return key
         w := Window.open_image(s) | fail
      }
      insert(imap, key, w)
      return key
   end

   #
   # Load an image without using the cache.  The parameter {s} should
   # be either in Icon image format, a file name, or the name of an
   # image set by {name_image()}.  The returned image should be closed
   # after use.
   #
   public static load(s, win)
      local p
      s := member(names, s)
      return if is_image_string(s) then {
         use {
            p := parse_image_string(s, win),
            Window.open_image(p)
         }
      } else
         Window.open_image(s)
   end

   #
   # This is like `get`, but if the resulting window is not of the
   # given dimensions, then another window is created (and cached),
   # which is the result of resizing to the desired size.
   #
   public static get_with_resize(s, width, height, win)
      return member(imap, get_key_with_resize(s, width, height, win))
   end

   #
   # Like `get_with_resize`, but returns the key rather than the window.
   #
   public static get_key_with_resize(s, width, height, win)
      local w, key, w2
      key := get_key(s, win) | fail
      w := member(imap, key)
      if w.get_width() = width & w.get_height() = height then
         return key
      key ||:= "#Resized to " || width || "x" || height
      if member(imap, key) then
         return key
      w2 := Window().set_size(width, height)
      Zoom(w, w2)
      insert(imap, key, w2)
      return key
   end

   public static get_scaled_svg(s, width, height)
      return member(imap, get_scaled_svg_key(s, width, height))
   end

   public static get_scaled_svg_key(s, width, height)
      local w, key, cc, svg
      key := s || "#Scaled to " || width || "x" || height
      if member(imap, key) then
         return key
      s := member(names, s)
      svg := SVG(s) | fail
      w := Window().
         set_size(width, height).
         set_bg("transparent").
         erase_area()
      use {
         cc := Context(w).
            scale(real(width) / svg.get_width(), real(height) / svg.get_height()),
         svg.render(cc)
      }
      svg.close()
      insert(imap, key, w)
      return key
   end
end
