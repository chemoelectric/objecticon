############################################################################
#
#	File:     pdco.icn
#
#	Subject:  Procedures for programmer-defined control operations
#
#	Authors:  Ralph E. Griswold and Robert J. Alexander
#
#	Date:     June 10, 2001
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#  
#  These procedures use co-expressions to used to model the built-in
#  control structures of Icon and also provide new ones.
#
#   AddTabby{e, i}	adds tabby to treadling sequence
#  
#   Allpar{e1,e2, ...}
#			parallel evaluation with last result
#			used for short sequences
#
#   Alt{e1,e2}	models e1 | e2
#
#   Binop{op,e1,e2} produces the result of applying op to e1 and e2
#
#   CFapprox{e}	produce sequence of approximations for the
#			continued-fraction sequence e
#  
#   Compare{e1,e2}	compares result sequences of e1 and e2
#  
#   Complint{e}	produces the integers not in e
#
#   Cond{e1,e2, ...}
#			models the generalized Lisp conditional
#
#   Cumsum{e}	generates the cumulative sum of the terms of e
#  
#   Cyclepar{e1,e2, ...}
#			parallel evaluation with shorter sequences
#			re-evaluated
#
#   Decimate{e1, e2}
#			"decimate" e1 by deleting e2-numbered terms
#			(e2 is assumed to be an increasing sequence).
#
#   Decimation{e}	produce a decimation sequence from e1 by
#			deleting even-valued terms and replacing
#			odd-valued terms by their position.
#
#   Decollate{e, i}	decollate e according to parity of i
#
#   Delta{e1}	produces the difference of the values in e1
#
#   Elevate{e1, m, n}
#			elevate e1 mod n to n values
#  
#   Every{e1,e2}	models every e1 do e2
#
#   ExtendSeq{e1,i}	extends e1 to i results
#  
#   Extract{e1,e2, ...}
#			extract results of even-numbered arguments
#			according to odd-numbered values
#
#   Fifo{e1,e2, ...}	reversal of lifo evaluation
#
#   Friendly{m, k, e3}
#			friendly sequence starting at k shaft mod m
#
#   Galt{e1,e2, ...}
#			produces the results of concatenating the
#   		   	sequences for e1, e2, ...
#
#   Gconj{e1,e2,...}
#			models generalized conjunction: e1 & e2 & ...
#
#   The programmer-defined control operation above shows an interesting
#   technique for modeling conjunction via recursive generative
#   procedures.
#
#   Histo{e}	        generates histogram for e
#			default 100.
#
#   Increasing{e}	filters out non-increasing values in integer
#			sequence
#
#   Index{e1,e2}	produce e1-th terms from e2
#
#   Inter{e1,e2, ...}
#			produces results of e1, e2, ... alternately
#  
#   Lcond{e1,e2, ...}
#			models the Lisp conditional
#
#   Length{e}	returns the length of e
#  
#   Lifo{e1,e2, ...}	models standard Icon "lifo" evaluation
#
#   Limit{e1,e2}	models e1 \ e2
#
#   List{e}	        produces a list of the results from e
#
#   LowerTrim{e}	lower trim
#
#   Map{e1,e2}	maps values of e1 in the order they first appear
#			to values of e2 (as needed)
#
#   OddEven{e}		forces odd/even sequence
#
#   Palin{e}	x produces results of concatenating the
#			sequences for e and then its reverse.
#
#  
#   Parallel{e1,e2, ...}
#			parallel evaluation terminating on
#			shortest sequence
#
#   PatternPalin{e}
#			produces pattern palindrome.
#
#   Period{e, i}	generates the periodic part of e; i values are
#			used to find the period
#
#   Permute{e1,e2}	permutes each n-subsequence of e1 by the
#   		  	n positional values in lists from e2.  If a list does
#			not consist of all the integers in the range 1 to
#   		  	n, "interesting" things happen (see the use
#   		   	of map() for transpositions).
#
#   Pivot{e, m}	produces pivot points from e % m; m default 100
#
#   PosDiff{e1,e2}	produces positions at which e1 and e2 differ
#
#   Positions{e, i}	generates the positions at which i occurs in e.
#  
#   Random{e1,e2, ...}
#			produces results of e1, e2, ... at random
#
#   Reduce{op, x, e}
#			"reduces" the sequence e by starting with the value x
#			and repetitively applying op to the current
#		  	value and values from e.
#
#   RemoveDupl{e}	removes duplicate adjacent values.
#  
#   Repalt{e}	models |e
#
#   Repeat{e1, e2}	repeats the sequence for e1 e2 times
#
#   Repl{e1,e2}	replicates each value in e1 by the corresponding
#   		   	integer value in e2.
#  
#   Resume{e1,e2,e3}
#			models every e1 \ e2 do e3
#
#   Reverse{e}  	produces the results of e in reverse order.
#  
#   Rotate(e, i)	rotates the sequence for e left by i; negative
#   		   	i rotates to the right
#
#   Selfrepl{e1,i}	produces e1 * j copies of e1
#
#   Simple{e1,e2, ...}
#			simple evaluation with only success or
#			failure
#
#   Skip{e1,e2}	generate e1 skipping each e2 terms
#
#   Smod{e1,e2}	reduce terms in e1 (shaft) modulus e2
#
#   Span{e,m}	fill in between consecutive (integer) values in
#			e % m; m default 100
#
#   Sumlimit{e, i, j}
#			produces values of e until their sum exceeds
#			i.  Values less than j are discarded.
#
#   Trinop{op,e2,e2,e3}
#			produces the result of applying op to e1, e2, and e3
#
#   Unique{e}	produces the unique results of e in the order
#			they first appear
#
#   Unop{e1,e2}	produces the result of applying e1 to e2
#
#   UpperTrim{e}	upper trim
#
#
#   Wobble{e}	produces e(1), e(2), e(1), e(2), e(3), e(2), ...
#  
#   Comments:
#
#   Because of the handling of the scope of local identifiers in
#   co-expressions, expressions in programmer-defined control
#   operations cannot communicate through local identifiers.  Some
#   constructions, such as break and return, cannot be used in argu-
#   ments to programmer-defined control operations.
#  
############################################################################
#
#  Requires:  co-expressions
#
############################################################################
#
#  Links:  lists, periodic, rational
#
############################################################################

package ipl.pdco

import
   ipl.callable(callable),
   ipl.lists(lmap, lrotate),
   ipl.numbers(residue),
   ipl.periodic(repeater),
   ipl.rational(rational)

# PDCO to add tabby to treadling
procedure AddTabby(e, i)	
   /i :=  4	# number of regular treadles

   suspend Inter![e, create |((i + 1) | (i + 2))]

end

# PDAE for parallel evuation with repeats
procedure Allpar(L[])	
   local i, L1, done

   L1 := list(*L)

   done := list(*L,1)

   every i := 1 to *L do L1[i] := @L[i] | fail

   repeat {
      suspend L1[1] ! L1[2:0]
      every i := 1 to *L do
         if done[i] = 1 then ((L1[i] := @L[i]) | (done[i] := 0))
      if not(!done = 1) then fail
      }

end

# PDCO to model alternation
procedure Alt(e1, e2)	

   suspend |@e1
   suspend |@e2

end

# PDCO to apply binary operation to sequences
procedure Binop(e1, e2, e3)	
   local op, x, y

   repeat {
      op := @e1
      op := callable(op, 2) | runerr("*** invalid operation for Binop{}")
      (x := @e2 & y := @e3) | fail
      suspend op(x, y)
      }

end

# PDCO for continued-fraction approximations
procedure CFapprox(e)	
  local prev_n, prev_m, n, m, t

  prev_n := [1]
  prev_m := [0, 1]

  put(prev_n, (@e).denom) | fail

  while t := @e do {
     n := t.denom * get(prev_n) + t.numer * prev_n[1]
     m := t.denom * get(prev_m) + t.numer * prev_m[1]
     suspend rational(n, m, 1)
     put(prev_n, n)
     put(prev_m, m)
     if t.denom ~= 0 then {		# renormalize
        every !prev_n /:= t.denom
        every !prev_m /:= t.denom
        }
     }

end

# PDCO to compare sequences
procedure Compare(e1, e2)	
   local x1

   while x1 := @e1 do
      (x1 === @e2) | fail
   if @e2 then fail else return

end

# PDCO to generate integers not in sequence
procedure Complint(e)	
   local i, j			# EXPECTS MONOTONE NON-DECREASING SEQUENCE

   j := 0

   while i := @e do {
      i := integer(i) | runerr("*** invalid value in sequence to Compl{}")
      suspend j to i - 1
      j := i + 1
      }

   suspend seq(j)

end

# PDCO for generalized Lisp conditional
procedure Cond(L[])	
   local i, x

   every i := 1 to *L do
      if x := @L[i] then {
         suspend x
         suspend |@L[i]
         fail
         }

end

# PDCO to produce cumulative sum
procedure Cumsum(e)		
   local i

   i := 0

   while i +:= @e do
      suspend i

end

# PDAE for parallel evaluation with cycling
procedure Cyclepar(L[])	
   local i, L1, done

   L1 := list(*L)

   done := list(*L,1)

   every i := 1 to *L do L1[i] := @L[i] | fail

   repeat {
      suspend L1[1]!L1[2:0]
      every i := 1 to *L do {
         if not(L1[i] := @L[i]) then {
            done[i] := 0
            if !done = 1 then {
               L[i] := ^L[i]
               L1[i] := @L[i] | fail
               }
            else fail
            }
         }
      }
end

# PDCO to decimate sequence
procedure Decimate(e1, e2)	
   local i, j, count

   count := 0

   while j := @e2 do {
      while i := @e1 | fail do {
         count +:= 1
         if count = j then break next
         else suspend i
         }
      }

end

# PDCO to create decimation sequence
procedure Decimation(e)	
   local i, count

   count := 0

   while i := @e do {
      count +:= 1
      if i % 2 = 1 then suspend count
      }

end
# PDCO to decollate sequence
procedure Decollate(e1, e2)	
   local i, j, x

   i := @\e2 | 1

   i %:= 2
 
   j := 0

   while x := @e1 do {
      j +:= 1
      if j % 2 = i then suspend x
      }

end

# PDCO to generate difference sequence 
procedure Delta(e)	
   local i, j

   i := @e | fail

   while j := @e do {
      suspend j - i
      i := j
      }

end

# PDCO to elevate sequence
procedure Elevate(e1, e2, e3)	
   local n, m, shafts, i, j, k

   m := @e2 | fail
   n := @e3 | fail

   shafts := list(m)

   every !shafts := []

   every i := 1 to m do
      every put(shafts[i], i to n by m)

   while j := @e1 do {
      i := j % m + 1
      k := get(shafts[i])
      suspend k
      put(shafts[i], k)
      }

end

# PDCO to model iteration
procedure Every(e1, e2)	

   while @e1 do @^e2

end

# PDCO to extend sequence
procedure ExtendSeq(e1, e2)	
   local count

   count := integer(@e2) | fail
   if count < 1 then fail

   repeat {
      suspend |@e1 do {
         count -:= 1
         if count = 0 then fail
         }
      if *e1 == 0 then fail
      e1 := ^e1
      }

end

# PDAE to extract values
procedure Extract(L[])	
   local i, n, L1

   L1 := list(*L/2)

   repeat {
      i := 1
      while i < *L do {
         n := @L[i] | fail
         every 1 to n do
            L1[(i + 1)/2] := @L[i + 1] | fail
         L[i + 1] := ^L[i + 1]
         i +:= 2
         }
      suspend L1[1] ! L1[2:0]
      } 

end

# PDAE for reversal of lifo evaluation
procedure Fifo(L[])	
   local L1, j

   L1 := list(*L)

   j := *L

   repeat {
      repeat {
         if L1[j] := @L[j]
         then {
            j -:= 1
            (L[j] := ^L[j]) | break
            }
         else if (j +:= 1) > *L then fail
         }
      suspend L1[1] ! L1[2:0]
      j := 1
      }

end

# PDCO for friendly sequences
procedure Friendly(e1, e2, e3)	
   local mod, state, value

   mod := @e1 | fail
   state := @e2
   if /state then state := ?mod

   repeat {
      suspend state
      value := @e3 | fail
      if value % 2 = 0 then state +:= 1
      else state -:= 1
      state := residue(state, mod, 1)
      }

end

# PDCO to concatenate sequences
procedure Galt(L[])		
   local C

   every C := !L do
      suspend |@C

end

# PDCO for generalized conjunction
procedure Gconj(L[])	

   suspend Gconj_(L,1)

end

procedure Gconj_(L,i,v)

   local e
   if e := L[i] then {
      suspend v:= |@e & Gconj_(L,i + 1,v)
      L[i] := ^e
      }
   else suspend v

end

# histogram
procedure Histo(e1)		
   local results, seq

   seq := []

   while put(seq, @e1)

   results := list(max ! seq, 0)

   every results[!seq] +:= 1

   suspend !results

end


# PDCO to filter out non-increasing values
procedure Increasing(e)	
   local last, current

   last := @e | fail

   suspend last

   while current := @e do {
      if current <= last then next
      else {
         suspend current
         last := current
         }
      }

end

# PDCO to select terms by position
procedure Index(e1, e2)		
   local i, j, x

   j := @e2 | fail

   every i := seq() do {	# position
      x := @e1 | fail
      if j = i then {
         suspend x
         repeat {
            j := @e2 | fail
            if j > i then break
            }
         }
      }

end

# PDCO to interleave sequences
procedure Inter(L[])	

   suspend |@!L

end

# PDCO for Lisp conditional
procedure Lcond(L[])	
   local i

   every i := 1 to *L by 2 do
      if @L[i] then {
         suspend |@L[i + 1]
         fail
         }

end

# PDCO to produce length of sequence
procedure Length(e)	
   local i

   i := 0

   while @e do i +:= 1

   return i

end

# PDAE for standard lifo evaluation
procedure Lifo(L[])	
   local L1, j

   L1 := list(*L)

   j := 1

   repeat {
      repeat
         if L1[j] := @L[j]
         then {
            j +:= 1
            (L[j] := ^L[j]) | break
            }
         else if (j -:=  1) = 0
            then fail
      suspend L1[1] ! L1[2:0]
      j := *L
      }

end

# PDCO to model limtation
procedure Limit(e1, e2)	
   local i, x

   while i := @e2 do {
      every 1 to i do
         if x := @e1 then suspend x
         else break
      e1 := ^e1
      }

end

#
# Create a list from the result sequence of the given co-expression.
#
# @example
# @   # Results in the list [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
# @   List{(e := 0 to 9, e * e)}
#
procedure List(e)		
   local t
   t := []
   while put(t, @e)
   return t
end

#
# Create a set from the result sequence of the given co-expression.
#
# @example
# @   # Results in the set {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}
# @   Set{(e := 0 to 9, e * e)}
#
procedure Set(e)		
   local t
   t := set()
   while insert(t, @e)
   return t
end


# Construct a table from a result sequence.  The expression {e} should
# produce 2-element lists representing key-value pairs to add to the
# table.
#
# @example
# @   # Results in the table {1->1, 2->4, 3->9, 4->16}
# @   Table{(i := 1 to 4, [i, i * i])}
#
procedure Table(e)
   local t, x
   t := table()
   while x := @e do
      insert(t, x[1], x[2])
   return t
end

# lower trimming
procedure LowerTrim(e)	
   local i

   while i := @e do {
      i -:= 1
      if i ~= 0 then suspend i
      }

end

# PDCO to map values
procedure Map(e1, e2)		
   local maptbl, x

   maptbl := table()

   while x := @e1 do {
      /maptbl[x] := (@e2 | fail)
      suspend maptbl[x]
      }

end

# PDCO to force odd/even sequence
procedure OddEven(e)	
   local val, val_old

   while val := @e do {
      if val % 2 = \val_old % 2 then
         suspend val_old + 1
      suspend val
      val_old := val
      }

end

# PDCO to produce palindromic sequence
procedure Palin(e)	
   local tail, x

   tail := []

   while x := @e do {
      suspend x
      push(tail, x)
      } 

   every suspend !tail

end


# PDAE for parallel evaluation
procedure Parallel(L[])	
   local i, L1

   L1 := list(*L)

   repeat {
      every i := 1 to *L do
         L1[i] := @L[i] | fail
      suspend L1[1] ! L1[2:0]
      }

end

# PDCO to produce pattern palindrome
procedure PatternPalin(e)	
   local tail, x

   tail := []
   while x := @e do {
      suspend x
      push(tail, x)
   }

   get(tail)

   pull(tail)

   every suspend !tail

end

# PDCO for periodic part of sequence
procedure Period(e1, e2)		
   local limit, result

   limit := @\e2 | 300

   result := []

   every put(result, |@e1) \ limit

   result := repeater(result)

   suspend !result[2]

end

# PDCO for permutations
procedure Permute(e1, e2)	
   local temp1, temp2, chunk, i

   repeat {
      temp1 := @e2 | fail
      temp2 := []
      every put(temp2, i := 1 to *temp1)
      chunk := []
      every 1 to i do
         put(chunk, @e1) | fail
      suspend !lmap(temp1, temp2, chunk)
      }

end

# PDCO to generate pivot points
procedure Pivot(e1, e2)		
   local current, direction, m, new

   m := @\e2 | 100
   direction := "+"

   current := @e1 % m | fail

   suspend current

   repeat {
      new := @e1 % m | break
      if new = current then next
      case direction of {
         "+":  {
            if new > current then {
               current := new
               next
               }
            else {
               suspend current
               current := new
               direction := "-"
               }
            }
         "-":  {
            if new < current then {
               current := new
               next
               }
            else {
               suspend current
               current := new
               direction := "+"
               }
            }
         }

      }

   return current

end

# positions in e of i
procedure Positions(e1, e2)	
   local i, count, j

   i := integer(@\e2) | fail

   count := 0

   while j := @e1 do {
      count +:= 1
      if j = i then suspend count
      }

end

# PDCO to generate positions of difference
procedure PosDiff(e1, e2)	
   local i, x, y

   i := 0

   while x := @e1 & y := @e2 do {
      i +:= 1
      if x ~=== y then suspend i
      }

end

# PDCO to generate from sequences at random
procedure Random(L[])	
   local x

   while x := @?L do suspend x

end

# PDCO to model repeated alternation
procedure Repalt(e)	
   repeat {
      suspend |@e
      if *e == 0 then fail
      e := ^e
      }

end

# PDCO to reduce sequence using binary operation
procedure Reduce(e1, e2, e3)	
   local op, x

   op := callable(@e1, 2) | runerr("*** invalid operation for Reduce{}")
   x := @e2 | fail

   while x := op(x, @e3)

   return x

end

# PDCO to repeat sequence
procedure Repeat(e1, e2)	
   local i

   while i := @e2 do {
      if not(i := integer(i)) then runerr("*** invalid repetition in Repeat{}")
      every 1 to i do {
         suspend |@e1
         e1 := ^e1
         }
      }

end

# PDCO for remove duplicate values in a sequence
procedure RemoveDupl(e)	
   local old, new

   old := @e | fail
   suspend old

   repeat {
      new := @e | fail
      if new === old then next
      else {
         suspend new
         old := new
         }
      }

end

# PDCO to replicate values in a sequence
procedure Repl(e1, e2)	
   local x, i

   while x := @e1 do {
      i := @\e2 | 1
      suspend (1 to i) & x
      }

end

# PDCO to model limited iteration
procedure Resume(e1, e2, e3)	
   local i

   while i := @e2 do {
      e1 := ^e1
      every 1 to i do if @e1 then @^e3 else break
   }

end

# PDCO to reverse sequence
procedure Reverse(e)
   local result
   result := []
   while push(result, @e)
   suspend !result
end

# PDCO to rotate sequence
procedure Rotate(e1, e2)		
   local result, i, x

   i := integer(@e2) | runerr("*** invalid specification in Rotate{}")

   result := []

   if i <= 0 then {		# if not to right, works for infinite sequence
      every 1 to -i do
         put(result, @e1) | break
      while x := @e1 do
         suspend x
      suspend !result
      }

   else {
      while put(result, @e1)
      suspend !lrotate(result, i)
      }

end

# PDCO to produce multiple of values in sequence
procedure Selfrepl(e1, e2)	
   local i, j

   j := @\e2 | 1
   j := integer(j) | runerr("*** invalid second argument to Selfrepl{}")

   while i := @e1 do {
      i := integer(i) | runerr("*** invalid value in Selfrepl{}")
      suspend (1 to i * j) & i
      }

end

# PDAE for simple evaluation
procedure Simple(L[])	
   local i, L1

   L1 := list(*L)

   every i := 1 to *L do
      L1[i] := @L[i] | fail

   return L1[1] ! L1[2:0]

end

# PDCO to skip terms
procedure Skip(e1, e2)	
   local gap

   suspend @e1

   repeat {
      gap := @e2 | fail
      every 1 to gap do
         @e1 | fail
      suspend @e1
      }

end

# generalized modular reduction
procedure Smod(e1, e2)		
   local i, m

   while i := @e1 do {
      m := @e2 | fail
      suspend residue(i, m, 1)
      }

end

# fill in gaps in integer sequences
procedure Span(e1, e2)		
   local i, j, m

   j := @e1 | fail

   m := @\e2 | 100

   while i := residue(@e1, m, 1) do {
      if i > j then suspend j to i - 1
      else if i < j then suspend j to i + 1 by -1
      j := i
      } 

   suspend j

end

# PDCO to sum sequence to a limit
procedure Sumlimit(e1, e2, e3) 	
   local sum, min, limit, i

   limit := integer(@\e2) | 2 ^ 15
   min := integer(@\e3) | 0
   sum := 0

   while i := @e1 do {
      if i < min then next
      if (sum + i) > limit then fail
      sum +:= i
      suspend i
      }

end

# PDCO to apply trinary operator to sequneces
procedure Trinop(e1, e2, e3, e4)
   local op, x, y, z

   repeat {
      op := @e1
      op := callable(op, 3) | runerr("*** invalid operation for Trinop{}")
      x := @e2 & y := @e3 & z := @e4 | fail
      suspend op(x, y, z)
      }

end

# PDCO to filter out duplication values
procedure Unique(e)	
   local done, x

   done := set()

   while x := @e do
      if member(done, x) then next
      else {
         insert(done, x)
         suspend x
         }

end

# PDCO to apply unary operation to sequence
procedure Unop(e1, e2)	
   local op, x

   repeat {
      op := @e1
      op := callable(op, 1) | runerr("*** invalid operation for Unop{}")
      x := @e2  | fail
      suspend op(x)
      }

end

# upper sequence trimming
procedure UpperTrim(e)	
   local done, i

   done := set()

   while i := @e do {
      if not member(done, i) then
         insert(done, i)
      else suspend i
      }

end


# PDCO to produce sequence values alternately
procedure Wobble(e)	
   local x, y

   x := @e | fail
   suspend x

   while y := @e do {
      suspend y | x | y
      x := y
      }

end

#
# Evaluate the given expression, suspending its results, whilst
# ignoring any non-fatal runtime errors.  After failure,
# {&errortext} can be tested to see whether or not failure was
# caused by a runtime error.
#
procedure Safe(e)
   local t
   t := &handler
   &handler := &current
   suspend 1(|@e, &handler :=: t) do
      &handler :=: t                                         
   &handler := t
end

# A useful wrapper around {Safe}.  {Safe} is called with {e} to get
# its first result.  If no runerr occurs, then the result produced by
# {e} is returned.  If {e} fails, {&null} is returned.  If a runerr
# occurs, {errorclear} is called, {&why} is set and the procedure
# fails.
#
procedure SimpleSafe(e)
   local v
   v := Safe(e)
   if &errortext then {
      &why := if &errornumber then
         "Runtime error " || &errornumber || ": " || &errortext
      else                                                     
         "Runtime error: " || &errortext                       
      &why ||:= "; offending value: " || image(&errorvalue)
      errorclear()
   } else
      return v
end

# Dijkstra non-deterministic if construct
procedure If(a[])
   local x, i
   x := []
   every i := 1 to *a by 2 do 
      if @a[i] then 
         put(x, i)

   if *x = 0 then
      runerr("If : no guard succeeded")

   i := ?x + 1
   suspend |@a[i]
end

# Dijkstra non-deterministic do construct
procedure Do(a[])
   local x, i
   repeat {
      x := []
      every i := 1 to *a by 2 do
         if @^a[i] then 
            put(x, i)

      if *x = 0 then
         break

      @^a[?x + 1]
   }
end

#
# Generate the results of a co-expression as a sequence.
#
procedure Seq(e)
   suspend |@e
end


# Generate the results from the several expressions in the same
# left-to-right order as in normal icon evaluation.
# 
# For example Generate{1 to 3, !"ab"} generates [1,"a"], [1,"b"], [2,
# "a"] etc.
#
# Note that the same list instance is suspended each time, and should
# not be altered.
#
procedure Generate(e[])
   local vals, n
   n := *e
   vals := []
   repeat {
      # Invariant: vals contains valid values not suspended yet
      if *vals < n then {
         if put(vals, @e[*vals + 1]) then
            next
      } else # *vals=n
         suspend vals
      # Tab back to a good val:-
      repeat {
         if *vals = 0 then fail
         if vals[-1] := @e[*vals] then
            break
         e[*vals] := ^e[*vals]
         pull(vals)
      }                 
   }
end
