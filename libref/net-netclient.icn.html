<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>netclient.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: netclient.icn 8988 2021-03-22 01:04:37Z rparlett $
<a name="3"/>#
<a name="4"/>
<a name="5"/>package net
<a name="6"/>
<a name="7"/>$if _UNIX
<a name="8"/>import 
<a name="9"/>   posix
<a name="10"/>$endif
<a name="11"/>
<a name="12"/>import
<a name="13"/>   io,
<a name="14"/>   lang,
<a name="15"/>   util, 
<a name="16"/>   ssl,
<a name="17"/>   ipl.pdco,
<a name="18"/>   ipl.base64,
<a name="19"/>   ipl.printf,
<a name="20"/>   ipl.functional
<a name="21"/>
<a name="22"/>#
<a name="23"/># Common base class for a client class which holds a connection to a
<a name="24"/># server and communicates using CRLF-terminated lines.
<a name="25"/>#
<a name="26"/>abstract class NetClient(Connectable, HasTask, HasClose)
<a name="27"/>   public static const 
<a name="28"/>      CONNECTING_EVENT,
<a name="29"/>      CONNECTED_EVENT,
<a name="30"/>      CLOSED_EVENT,
<a name="31"/>      WRITING_STRING_EVENT,
<a name="32"/>      WRITING_LINE_EVENT,
<a name="33"/>      READ_LINE_EVENT,
<a name="34"/>      READ_STRING_EVENT,
<a name="35"/>      # The timeout (in ms) for IP addresses noted to avoid; by
<a name="36"/>      # default one minute.  Configure with environment variable
<a name="37"/>      # OI_NETCLIENT_AVOID_TIMEOUT.
<a name="38"/>      AVOID_TIMEOUT,
<a name="39"/>      # A flag, indicating that dns requests should always be in the
<a name="40"/>      # foreground; configure with environment variable
<a name="41"/>      # OI_NETCLIENT_FOREGROUND_DNS.
<a name="42"/>      FOREGROUND_DNS,
<a name="43"/>      # A table of addresses (string) to expiry time.
<a name="44"/>      avoid
<a name="45"/>
<a name="46"/>   private static init()
<a name="47"/>      CONNECTING_EVENT := "Connecting"
<a name="48"/>      CONNECTED_EVENT := "Connected"
<a name="49"/>      CLOSED_EVENT := "Closed"
<a name="50"/>      WRITING_STRING_EVENT := "Writing string"
<a name="51"/>      WRITING_LINE_EVENT := "Writing line"
<a name="52"/>      READ_LINE_EVENT := "Read line"
<a name="53"/>      READ_STRING_EVENT := "Read string"
<a name="54"/>      AVOID_TIMEOUT := env_int("OI_NETCLIENT_AVOID_TIMEOUT", 0) | 60*1000
<a name="55"/>      FOREGROUND_DNS := env_flag("OI_NETCLIENT_FOREGROUND_DNS")
<a name="56"/>      avoid := table()
<a name="57"/>   end
<a name="58"/>
<a name="59"/>   private readable
<a name="60"/>      path,
<a name="61"/>      server,
<a name="62"/>      port,
<a name="63"/>      timeout,
<a name="64"/>      ssl_flag,
<a name="65"/>      ssl_verify_flag,
<a name="66"/>      dont_retry_flag,
<a name="67"/>      ip_version,
<a name="68"/>      proxy,
<a name="69"/>      proxy_auth,
<a name="70"/>      proxy_type
<a name="71"/>   
<a name="72"/>   private
<a name="73"/>      connection,
<a name="74"/>      ssl_connection,
<a name="75"/>      ssl_want_shutdown,
<a name="76"/>      sbuff
<a name="77"/>
<a name="78"/>   # Note an address to avoid for the next `AVOID_TIMEOUT`
<a name="79"/>   # milliseconds.
<a name="80"/>   #
<a name="81"/>   public static avoid_addr(addr)
<a name="82"/>      insert(avoid, addr, Prog.get_runtime_millis() + AVOID_TIMEOUT)
<a name="83"/>      link
<a name="84"/>   end
<a name="85"/>
<a name="86"/>   # Given a list of addresses, choose the first which we are not
<a name="87"/>   # currently avoiding, or the best alternative otherwise.
<a name="88"/>   #
<a name="89"/>   public static choose_addr(l)
<a name="90"/>      local e, t, now, best
<a name="91"/>      # Purge expired entries from avoid
<a name="92"/>      now := Prog.get_runtime_millis()
<a name="93"/>      every e := key(avoid) do {
<a name="94"/>         if now &gt;= avoid[e] then
<a name="95"/>            delete(avoid, e)
<a name="96"/>      }
<a name="97"/>      every e := !l do {
<a name="98"/>         # If not avoiding this element, return it.
<a name="99"/>         t := member(avoid, e) | return e
<a name="100"/>         # Otherwise note the one with the earliest expiry.
<a name="101"/>         if /best | t &lt; avoid[best] then
<a name="102"/>            best := e
<a name="103"/>      }
<a name="104"/>      return best
<a name="105"/>   end
<a name="106"/>
<a name="107"/>   # Set the ip version option to pass during dns lookup; see
<a name="108"/>   # `SocketStream.dns_query()`.  By default, this is `&amp;null`.
<a name="109"/>   #
<a name="110"/>   public set_ip_version(ver)
<a name="111"/>      self.ip_version := /ver | need_integer(ver)
<a name="112"/>      link
<a name="113"/>   end
<a name="114"/>
<a name="115"/>   # Set the timeout in ms to use.  If `&amp;null`, then no timeout will
<a name="116"/>   # be used.
<a name="117"/>   #
<a name="118"/>   public set_timeout(timeout)
<a name="119"/>      self.timeout := /timeout | need_integer(timeout, 0)
<a name="120"/>      link
<a name="121"/>   end
<a name="122"/>
<a name="123"/>   private do_poll(for)
<a name="124"/>      return choose_poll([connection, for], timeout)
<a name="125"/>   end
<a name="126"/>
<a name="127"/>   private improve_why()
<a name="128"/>      connection.improve_why("Socket error")
<a name="129"/>   end
<a name="130"/>
<a name="131"/>$if _MS_WIN32
<a name="132"/>   private dns_query(server)
<a name="133"/>      return WinsockStream.dns_query(server, ip_version)
<a name="134"/>   end
<a name="135"/>
<a name="136"/>   private static ip_to_addr(ip, port)
<a name="137"/>      return if upto('.', ip) then 
<a name="138"/>         "inet:" || ip || ":" || port
<a name="139"/>      else
<a name="140"/>         "inet6:[" || ip || "]:" || port
<a name="141"/>   end
<a name="142"/>
<a name="143"/>   #
<a name="144"/>   # Open the connection.
<a name="145"/>   #
<a name="146"/>   protected open_connection()
<a name="147"/>      local r, domain, addr, msg_addr, l
<a name="148"/>
<a name="149"/>      close_connection()
<a name="150"/>      fire(CONNECTING_EVENT)
<a name="151"/>      if \path then
<a name="152"/>         return error_dont_retry("UNIX domain not supported")
<a name="153"/>      validate_settings() | fail
<a name="154"/>      if \proxy then {
<a name="155"/>         l := dns_query(proxy.host) | return whyf("Couldn't translate proxy address: %w")
<a name="156"/>         l := List{ ip_to_addr(!l, proxy.port) }
<a name="157"/>         addr := choose_addr(l)
<a name="158"/>         domain := if match("inet:", addr) then
<a name="159"/>            ProtocolFormat.INET
<a name="160"/>         else
<a name="161"/>            ProtocolFormat.INET6
<a name="162"/>         msg_addr := proxy.host || " (" || addr || ")"
<a name="163"/>      } else {
<a name="164"/>         l := dns_query(server) | return whyf("Couldn't translate address: %w")
<a name="165"/>         l := List{ ip_to_addr(!l, port) }
<a name="166"/>         addr := choose_addr(l)
<a name="167"/>         domain := if match("inet:", addr) then
<a name="168"/>            ProtocolFormat.INET
<a name="169"/>         else
<a name="170"/>            ProtocolFormat.INET6
<a name="171"/>         msg_addr := server || " (" || addr || ")"
<a name="172"/>      }
<a name="173"/>
<a name="174"/>      connection := WinsockStream(domain)
<a name="175"/>      unless connection.set_blocking_mode(&amp;no) then {
<a name="176"/>         quietly_close_connection()
<a name="177"/>         return whyf_dont_retry("Couldn't put socket in non-blocking mode: %w")
<a name="178"/>      }
<a name="179"/>
<a name="180"/>      unless connection.connect(addr) then {
<a name="181"/>         if errno() = WSAError.EWOULDBLOCK then {
<a name="182"/>            unless r := do_poll(Poll.OUT) then {
<a name="183"/>               quietly_close_connection()
<a name="184"/>               avoid_addr(addr)
<a name="185"/>               return whyf("Couldn't connect to %s: %w", msg_addr)
<a name="186"/>            }
<a name="187"/>            if /r then {
<a name="188"/>               close_connection()
<a name="189"/>               avoid_addr(addr)
<a name="190"/>               return whyf("Couldn't connect to %s: Timeout", msg_addr)
<a name="191"/>            }
<a name="192"/>            unless DescStream.poll_out_test(r[1]) then {
<a name="193"/>               improve_why()
<a name="194"/>               quietly_close_connection()
<a name="195"/>               avoid_addr(addr)
<a name="196"/>               return whyf("Couldn't connect to %s: %w", msg_addr)
<a name="197"/>            }
<a name="198"/>         } else {
<a name="199"/>            quietly_close_connection()
<a name="200"/>            avoid_addr(addr)
<a name="201"/>            return whyf("Couldn't connect to %s: %w", msg_addr)
<a name="202"/>         }
<a name="203"/>      }
<a name="204"/>
<a name="205"/>      if \proxy then {
<a name="206"/>         unless establish_proxy_connection() then {
<a name="207"/>            quietly_close_connection()
<a name="208"/>            fail
<a name="209"/>         }
<a name="210"/>      }
<a name="211"/>
<a name="212"/>      if \ssl_flag then {
<a name="213"/>         ssl_available() | return error_dont_retry(&amp;why)
<a name="214"/>         unless ssl_connection := SslStream(connection, server) then {
<a name="215"/>            quietly_close_connection()
<a name="216"/>            return whyf("Couldn't create SslStream: %w")
<a name="217"/>         }
<a name="218"/>         until ssl_connection.connect() do {
<a name="219"/>            unless ssl_maybe_poll() then {
<a name="220"/>               quietly_close_connection()
<a name="221"/>               return whyf("Couldn't perform SSL connection: %w")
<a name="222"/>            }
<a name="223"/>         }
<a name="224"/>         ssl_want_shutdown := &amp;yes
<a name="225"/>         if \ssl_verify_flag then {
<a name="226"/>            unless ssl_connection.verify() then {
<a name="227"/>               quietly_close_connection()
<a name="228"/>               return whyf_dont_retry("Couldn't verify SSL connection: %w")
<a name="229"/>            }
<a name="230"/>         }
<a name="231"/>      }
<a name="232"/>
<a name="233"/>      fire(CONNECTED_EVENT, addr)
<a name="234"/>      link
<a name="235"/>   end
<a name="236"/>$else
<a name="237"/>   private dns_query_impl(server)
<a name="238"/>      return SocketStream.dns_query(server, ip_version)
<a name="239"/>   end
<a name="240"/>
<a name="241"/>   private dns_background_query(p, server)
<a name="242"/>      local r
<a name="243"/>      if r := dns_query_impl(server) then
<a name="244"/>         p.send(r)
<a name="245"/>      else
<a name="246"/>         p.send(&amp;why)
<a name="247"/>   end
<a name="248"/>
<a name="249"/>   private dns_query(server)
<a name="250"/>      local p, v
<a name="251"/>      if /task | \FOREGROUND_DNS then
<a name="252"/>         return dns_query_impl(server)
<a name="253"/>      p := Process{dns_background_query(p, server)}.set_task(task)
<a name="254"/>      p.start() | fail
<a name="255"/>      if v := p.poll() then {
<a name="256"/>         p.close()
<a name="257"/>         return if type(v) == "list" then
<a name="258"/>            v
<a name="259"/>         else
<a name="260"/>            error(v)
<a name="261"/>      } else
<a name="262"/>         # poll() failed, meaning we were interrupted.  We don't want
<a name="263"/>         # to call close(), which would hang whilst p exited, so we
<a name="264"/>         # call stop() which kills it first.
<a name="265"/>         p.stop()
<a name="266"/>   end
<a name="267"/>
<a name="268"/>   private static ip_to_addr(ip, port)
<a name="269"/>      return if upto('.', ip) then 
<a name="270"/>         "inet:" || ip || ":" || port
<a name="271"/>      else
<a name="272"/>         "inet6:[" || ip || "]:" || port
<a name="273"/>   end
<a name="274"/>
<a name="275"/>   #
<a name="276"/>   # Open the connection.
<a name="277"/>   #
<a name="278"/>   protected open_connection()
<a name="279"/>      local r, domain, addr, msg_addr, l
<a name="280"/>
<a name="281"/>      close_connection()
<a name="282"/>      fire(CONNECTING_EVENT)
<a name="283"/>      validate_settings() | fail
<a name="284"/>      if \path then {
<a name="285"/>         domain := ProtocolFormat.UNIX
<a name="286"/>         msg_addr := addr := "unix:" || path
<a name="287"/>      } else if \proxy then {
<a name="288"/>         l := dns_query(proxy.host) | return whyf("Couldn't translate proxy address: %w")
<a name="289"/>         l := List{ ip_to_addr(!l, proxy.port) }
<a name="290"/>         addr := choose_addr(l)
<a name="291"/>         domain := if match("inet:", addr) then
<a name="292"/>            ProtocolFormat.INET
<a name="293"/>         else
<a name="294"/>            ProtocolFormat.INET6
<a name="295"/>         msg_addr := proxy.host || " (" || addr || ")"
<a name="296"/>      } else {
<a name="297"/>         l := dns_query(server) | return whyf("Couldn't translate address: %w")
<a name="298"/>         l := List{ ip_to_addr(!l, port) }
<a name="299"/>         addr := choose_addr(l)
<a name="300"/>         domain := if match("inet:", addr) then
<a name="301"/>            ProtocolFormat.INET
<a name="302"/>         else
<a name="303"/>            ProtocolFormat.INET6
<a name="304"/>         msg_addr := server || " (" || addr || ")"
<a name="305"/>      }
<a name="306"/>
<a name="307"/>      connection := SocketStream(domain)
<a name="308"/>      unless connection.flag(FileOpt.NONBLOCK) then {
<a name="309"/>         quietly_close_connection()
<a name="310"/>         return whyf_dont_retry("Couldn't put socket in non-blocking mode: %w")
<a name="311"/>      }
<a name="312"/>
<a name="313"/>      unless connection.connect(addr) then {
<a name="314"/>         if errno() = Errno.EINPROGRESS then {
<a name="315"/>            unless r := do_poll(Poll.OUT) then {
<a name="316"/>               quietly_close_connection()
<a name="317"/>               avoid_addr(addr)
<a name="318"/>               return whyf("Couldn't connect to %s: %w", msg_addr)
<a name="319"/>            }
<a name="320"/>            if /r then {
<a name="321"/>               close_connection()
<a name="322"/>               avoid_addr(addr)
<a name="323"/>               return whyf("Couldn't connect to %s: Timeout", msg_addr)
<a name="324"/>            }
<a name="325"/>            unless DescStream.poll_out_test(r[1]) then {
<a name="326"/>               improve_why()
<a name="327"/>               quietly_close_connection()
<a name="328"/>               avoid_addr(addr)
<a name="329"/>               return whyf("Couldn't connect to %s: %w", msg_addr)
<a name="330"/>            }
<a name="331"/>         } else {
<a name="332"/>            quietly_close_connection()
<a name="333"/>            avoid_addr(addr)
<a name="334"/>            return whyf("Couldn't connect to %s: %w", msg_addr)
<a name="335"/>         }
<a name="336"/>      }
<a name="337"/>
<a name="338"/>      if \proxy then {
<a name="339"/>         unless establish_proxy_connection() then {
<a name="340"/>            quietly_close_connection()
<a name="341"/>            fail
<a name="342"/>         }
<a name="343"/>      }
<a name="344"/>
<a name="345"/>      if \ssl_flag then {
<a name="346"/>         ssl_available() | return error_dont_retry(&amp;why)
<a name="347"/>         unless ssl_connection := SslStream(connection, server) then {
<a name="348"/>            quietly_close_connection()
<a name="349"/>            return whyf("Couldn't create SslStream: %w")
<a name="350"/>         }
<a name="351"/>         until ssl_connection.connect() do {
<a name="352"/>            unless ssl_maybe_poll() then {
<a name="353"/>               quietly_close_connection()
<a name="354"/>               return whyf("Couldn't perform SSL connection: %w")
<a name="355"/>            }
<a name="356"/>         }
<a name="357"/>         ssl_want_shutdown := &amp;yes
<a name="358"/>         if \ssl_verify_flag then {
<a name="359"/>            unless ssl_connection.verify() then {
<a name="360"/>               quietly_close_connection()
<a name="361"/>               return whyf_dont_retry("Couldn't verify SSL connection: %w")
<a name="362"/>            }
<a name="363"/>         }
<a name="364"/>      }
<a name="365"/>
<a name="366"/>      fire(CONNECTED_EVENT, addr)
<a name="367"/>      link
<a name="368"/>   end
<a name="369"/>
<a name="370"/>$endif
<a name="371"/>
<a name="372"/>   # After an error to an ssl function, check if it is because the
<a name="373"/>   # ssl layer needs to read/write from the underlying connection.
<a name="374"/>   # If so, poll the connection and return (so the ssl call can be
<a name="375"/>   # retried); otherwise fail.
<a name="376"/>   private ssl_maybe_poll()
<a name="377"/>      local r
<a name="378"/>      case ssl_error() of {
<a name="379"/>         SslStream.ERROR_WANT_READ : {
<a name="380"/>            r := do_poll(Poll.IN) | return whyf("Receive poll failed: %w")
<a name="381"/>            if /r then return error("Receive failed: Timeout")
<a name="382"/>            unless DescStream.poll_in_test(r[1]) then {
<a name="383"/>               improve_why()
<a name="384"/>               return whyf("Receive failed: %w")
<a name="385"/>            }
<a name="386"/>            return
<a name="387"/>         }
<a name="388"/>         SslStream.ERROR_WANT_WRITE: {
<a name="389"/>            r := do_poll(Poll.OUT) | return whyf("Send poll failed: %w")
<a name="390"/>            if /r then return error("Send failed: Timeout")
<a name="391"/>            unless DescStream.poll_out_test(r[1]) then {
<a name="392"/>               improve_why()
<a name="393"/>               return whyf("Send failed: %w")
<a name="394"/>            }
<a name="395"/>            return
<a name="396"/>         }
<a name="397"/>         SslStream.ERROR_SSL | SslStream.ERROR_SYSCALL: {
<a name="398"/>            # Don't send a ssl shutdown after these errors; see
<a name="399"/>            # https://www.openssl.org/docs/man1.1.1/man3/SSL_get_error.html
<a name="400"/>            ssl_want_shutdown := &amp;no
<a name="401"/>         }
<a name="402"/>      }
<a name="403"/>   end
<a name="404"/>
<a name="405"/>   public static valid_port(i)
<a name="406"/>      succeed 0 &lt; i &lt; 65536
<a name="407"/>   end
<a name="408"/>
<a name="409"/>   private validate_settings()
<a name="410"/>      if \path then {
<a name="411"/>         /server | runerr("Path and server set")
<a name="412"/>         /port | runerr("Path and port set")
<a name="413"/>         /proxy | runerr("Path and proxy set")
<a name="414"/>      } else {
<a name="415"/>         \server | runerr("No server set")
<a name="416"/>         \port | runerr("Server set, but no port")
<a name="417"/>         valid_port(port) | return error_dont_retry("Port out of range")
<a name="418"/>         if \proxy then
<a name="419"/>            valid_port(proxy.port) | return error_dont_retry("Proxy port out of range")
<a name="420"/>      } 
<a name="421"/>      return
<a name="422"/>   end
<a name="423"/>
<a name="424"/>   private establish_proxy_connection()
<a name="425"/>      return case proxy_type of {
<a name="426"/>         &amp;null | "http" : establish_http_proxy_connection()
<a name="427"/>         "socks5" : establish_socks5_proxy_connection()
<a name="428"/>         default: runerr("Invalid proxy type", proxy_type)
<a name="429"/>      }
<a name="430"/>   end
<a name="431"/>
<a name="432"/>   private socks5_string(s)
<a name="433"/>      s := need_string(s)
<a name="434"/>      return (char(*s) || s) | error_dont_retry("String too long for SOCKS encoding")
<a name="435"/>   end
<a name="436"/>
<a name="437"/>   private establish_socks5_proxy_connection()
<a name="438"/>      local s, len, v
<a name="439"/>      static errs
<a name="440"/>      initial
<a name="441"/>         errs := ["General SOCKS server failure",
<a name="442"/>                  "Connection not allowed by ruleset",
<a name="443"/>                  "Network unreachable",
<a name="444"/>                  "Host unreachable",
<a name="445"/>                  "Connection refused",
<a name="446"/>                  "TTL expired",
<a name="447"/>                  "Command not supported",
<a name="448"/>                  "Address type not supported"]
<a name="449"/>
<a name="450"/>      # Auth methods
<a name="451"/>      write_str(if \proxy_auth then "\x05\x02\x00\x02"
<a name="452"/>                               else "\x05\x01\x00") | fail
<a name="453"/>      s := exact_str(2) | fail
<a name="454"/>      v := ord(s[1])
<a name="455"/>      (v = 5) | return whyf_dont_retry("SOCKS version mismatch (%d)", v)
<a name="456"/>      case v := ord(s[2]) of {
<a name="457"/>         0 : {}     # No authentication needed
<a name="458"/>         2 : {
<a name="459"/>            # Username and password authentication
<a name="460"/>            \proxy_auth |  return error_dont_retry("Unexpected SOCKS authentication request")
<a name="461"/>            write_str("\x01" || socks5_string(proxy_auth.username) ||
<a name="462"/>                 socks5_string(proxy_auth.password)) | fail
<a name="463"/>            s := exact_str(2) | fail
<a name="464"/>            (s[2] == "\x00") | return error_dont_retry("SOCKS authentication failure")
<a name="465"/>         }
<a name="466"/>         255:
<a name="467"/>            return error_dont_retry("SOCKS authentication method(s) not accepted")
<a name="468"/>         default:
<a name="469"/>            return whyf_dont_retry("Unknown SOCKS authentication method requested (%d)", v)
<a name="470"/>      }
<a name="471"/>      # Connect request
<a name="472"/>      write_str("\x05\x01\x00\x03" || socks5_string(server) || char(port / 256) || char(port % 256)) | fail
<a name="473"/>      s := exact_str(4) | fail
<a name="474"/>      v := ord(s[2]) 
<a name="475"/>      (v = 0) | return case v of {
<a name="476"/>         1 to 6: error("SOCKS connection error: " || errs[v])
<a name="477"/>         7 to 8: error_dont_retry("SOCKS connection error: " || errs[v])
<a name="478"/>         default: whyf_dont_retry("Unknown SOCKS connection error code (%d)", v)
<a name="479"/>      }
<a name="480"/>      # The length of the address
<a name="481"/>      len := case v := ord(s[4]) of {
<a name="482"/>         1: 4
<a name="483"/>         4: 16
<a name="484"/>         3: ord(exact_str(1)) | fail
<a name="485"/>         default: return whyf_dont_retry("Incorrect SOCKS address indicator (%d)", v)
<a name="486"/>      }
<a name="487"/>      # Read and discard address and port
<a name="488"/>      exact_str(len + 2) | fail
<a name="489"/>      return
<a name="490"/>   end
<a name="491"/>
<a name="492"/>   private establish_http_proxy_connection()
<a name="493"/>      local l, pr, code, s
<a name="494"/>      l := ["CONNECT " || server || ":" || port  || " HTTP/1.1"]
<a name="495"/>      put(l, "User-Agent: netclient.icn [en]")
<a name="496"/>      if \proxy_auth then
<a name="497"/>         put(l, "Proxy-Authorization: Basic " || base64encode(proxy_auth.username || ":" || proxy_auth.password))
<a name="498"/>      put(l, "Host: " || server || ":" || port)
<a name="499"/>      put(l, "")
<a name="500"/>      write_lines(l) | fail
<a name="501"/>      pr := expect_line(&amp;yes) | fail
<a name="502"/>      if pr ? code := (tab(upto(' ')), tab(many(' ')), integer(tab(many(&amp;digits)))) then {
<a name="503"/>         if code = 200 then {
<a name="504"/>            # Skip any headers upto and including a blank line
<a name="505"/>            repeat {
<a name="506"/>               s := expect_line(&amp;yes) | fail
<a name="507"/>               if *s = 0 then
<a name="508"/>                  return
<a name="509"/>            }
<a name="510"/>         }
<a name="511"/>         if code = 404 then
<a name="512"/>            return error("Proxy server status error: " || pr)
<a name="513"/>      }
<a name="514"/>      return error_dont_retry("Proxy server status error: " || pr)
<a name="515"/>   end
<a name="516"/>
<a name="517"/>   #
<a name="518"/>   # Call `close_connection`, saving &amp;why.
<a name="519"/>   #
<a name="520"/>   protected quietly_close_connection()
<a name="521"/>      return save_why{ close_connection() }
<a name="522"/>   end
<a name="523"/>
<a name="524"/>   #
<a name="525"/>   # Close the connection
<a name="526"/>   #
<a name="527"/>   protected close_connection()
<a name="528"/>      local f
<a name="529"/>      if \ssl_connection then {
<a name="530"/>         if \ssl_want_shutdown then
<a name="531"/>            ssl_connection.shutdown()
<a name="532"/>         ssl_connection.close() | (f := &amp;why)
<a name="533"/>         connection.close() | (f := &amp;why)
<a name="534"/>         ssl_connection := connection := ssl_want_shutdown := &amp;null
<a name="535"/>         fire(CLOSED_EVENT)
<a name="536"/>      } else if \connection then {
<a name="537"/>         connection.close() | (f := &amp;why)
<a name="538"/>         connection := &amp;null
<a name="539"/>         fire(CLOSED_EVENT)
<a name="540"/>      }
<a name="541"/>      sbuff := ""
<a name="542"/>      link error_if(f)
<a name="543"/>   end
<a name="544"/>
<a name="545"/>   #
<a name="546"/>   # Close this client and any associated connection.
<a name="547"/>   #
<a name="548"/>   public override close()
<a name="549"/>      return close_connection()
<a name="550"/>   end
<a name="551"/>
<a name="552"/>   #
<a name="553"/>   # Set the path to use (implies using PF_UNIX socket domain)
<a name="554"/>   #
<a name="555"/>   public set_path(s)
<a name="556"/>      path := /s | need_text(s)
<a name="557"/>      link
<a name="558"/>   end
<a name="559"/>
<a name="560"/>   #
<a name="561"/>   # Set the server to use (implies using PF_INET socket domain)
<a name="562"/>   #
<a name="563"/>   public set_server(s)
<a name="564"/>      server := /s | need_text(s)
<a name="565"/>      link
<a name="566"/>   end
<a name="567"/>
<a name="568"/>   #
<a name="569"/>   # Set the port
<a name="570"/>   #
<a name="571"/>   public set_port(n)
<a name="572"/>      port := /n | need_integer(n, 0)
<a name="573"/>      link
<a name="574"/>   end
<a name="575"/>
<a name="576"/>   #
<a name="577"/>   # Set the proxy server to use, as a `HostPort` instance.
<a name="578"/>   #
<a name="579"/>   public set_proxy(s)
<a name="580"/>      proxy := s
<a name="581"/>      link
<a name="582"/>   end
<a name="583"/>
<a name="584"/>   #
<a name="585"/>   # Set the proxy authentication, as an `Authentication` instance.
<a name="586"/>   #
<a name="587"/>   public set_proxy_auth(s)
<a name="588"/>      proxy_auth := s
<a name="589"/>      link
<a name="590"/>   end
<a name="591"/>
<a name="592"/>   #
<a name="593"/>   # Set the type of proxy server to use.  Possible values are "http"
<a name="594"/>   # for HTTP with the CONNECT method (the default), or "socks5" for a
<a name="595"/>   # SOCKS5 server.
<a name="596"/>   #
<a name="597"/>   public set_proxy_type(s)
<a name="598"/>      proxy_type := s
<a name="599"/>      link
<a name="600"/>   end
<a name="601"/>
<a name="602"/>   #
<a name="603"/>   # Low-level write on the connection. 
<a name="604"/>   #
<a name="605"/>   private send(s)
<a name="606"/>      local i, r
<a name="607"/>      s := need_string(s)
<a name="608"/>      if \ssl_connection then {
<a name="609"/>         while *s &gt; 0 do {
<a name="610"/>            if i := ssl_connection.out(s) then
<a name="611"/>               s := s[i+1 : 0]
<a name="612"/>            else
<a name="613"/>               ssl_maybe_poll() | return whyf("Send SSL out() failed: %w")
<a name="614"/>         }
<a name="615"/>      } else {
<a name="616"/>         while *s &gt; 0 do {
<a name="617"/>            r := do_poll(Poll.OUT) | return whyf("Send poll failed: %w")
<a name="618"/>            if /r then return error("Send failed: Timeout")
<a name="619"/>            unless DescStream.poll_out_test(r[1]) then {
<a name="620"/>               improve_why()
<a name="621"/>               return whyf("Send failed: %w")
<a name="622"/>            }
<a name="623"/>            i := connection.out(s) | return whyf("Send out() failed: %w")
<a name="624"/>            s := s[i+1 : 0]
<a name="625"/>         }
<a name="626"/>      }
<a name="627"/>      link
<a name="628"/>   end
<a name="629"/>
<a name="630"/>   #
<a name="631"/>   # Low-level read on the connection. 
<a name="632"/>   #
<a name="633"/>   private recv(len)
<a name="634"/>      local r, s
<a name="635"/>      if \ssl_connection then {
<a name="636"/>         repeat {
<a name="637"/>            if s := ssl_connection.in(len) then
<a name="638"/>               return s
<a name="639"/>            ssl_maybe_poll() | return whyf("Receive SSL in() failed: %w")
<a name="640"/>         }
<a name="641"/>      } else {
<a name="642"/>         r := do_poll(Poll.IN) | return whyf("Receive poll failed: %w")
<a name="643"/>         if /r then return error("Receive failed: Timeout")
<a name="644"/>         unless DescStream.poll_in_test(r[1]) then {
<a name="645"/>            improve_why()
<a name="646"/>            return whyf("Receive failed: %w")
<a name="647"/>         }
<a name="648"/>         return connection.in(len) | whyf("Receive in() failed: %w")
<a name="649"/>      }
<a name="650"/>   end
<a name="651"/>
<a name="652"/>   #
<a name="653"/>   # Write the given string to the connection.
<a name="654"/>   #
<a name="655"/>   protected write_str(s)
<a name="656"/>      fire(WRITING_STRING_EVENT, s)
<a name="657"/>      return send(s)
<a name="658"/>   end
<a name="659"/>
<a name="660"/>   #
<a name="661"/>   # Write a single line to the connection, appending CRLF to the output stream.
<a name="662"/>   # 
<a name="663"/>   protected write_line(s)
<a name="664"/>      /s := ""
<a name="665"/>      fire(WRITING_LINE_EVENT, s)
<a name="666"/>      return send(s || "\r\n") 
<a name="667"/>   end
<a name="668"/>
<a name="669"/>   #
<a name="670"/>   # Write several lines in one go, but firing separate events for each line.
<a name="671"/>   #
<a name="672"/>   protected write_lines(l)
<a name="673"/>      local s
<a name="674"/>      s := ""
<a name="675"/>      every s ||:= (!l) || "\r\n"
<a name="676"/>      every fire(WRITING_LINE_EVENT, !l)
<a name="677"/>      return send(s)
<a name="678"/>   end
<a name="679"/>
<a name="680"/>   #
<a name="681"/>   # Read a single line from the connection, and return it.  Returns
<a name="682"/>   # `&amp;null` on end of file.  `fl` is a flag; if set then characters
<a name="683"/>   # are read one at a time from the connection.  This avoids the
<a name="684"/>   # usual buffering taking place (although any existing buffered
<a name="685"/>   # characters are still consumed).
<a name="686"/>   #
<a name="687"/>   protected read_line(fl)
<a name="688"/>      local line, s, len
<a name="689"/>      len := if /fl then 1048576 else 1
<a name="690"/>      repeat {
<a name="691"/>         #
<a name="692"/>         # Look for a line and if found return it.
<a name="693"/>         #
<a name="694"/>         sbuff ? {
<a name="695"/>            if line := tab(find("\r\n")) then {
<a name="696"/>               move(2)
<a name="697"/>               sbuff := tab(0)
<a name="698"/>               fire(READ_LINE_EVENT, line)
<a name="699"/>               return line
<a name="700"/>            }
<a name="701"/>         }
<a name="702"/>         s := recv(len) | fail
<a name="703"/>         if /s then {
<a name="704"/>            if *sbuff = 0 then
<a name="705"/>               return
<a name="706"/>            line := sbuff
<a name="707"/>            sbuff := ""
<a name="708"/>            fire(READ_LINE_EVENT, line)
<a name="709"/>            return line
<a name="710"/>         }
<a name="711"/>         sbuff ||:= s
<a name="712"/>      }
<a name="713"/>   end
<a name="714"/>
<a name="715"/>   #
<a name="716"/>   # This method is the same as `read_line`, except that on end of
<a name="717"/>   # file it fails, setting `&amp;why`, rather than returning `&amp;null`.
<a name="718"/>   #
<a name="719"/>   protected expect_line(fl)
<a name="720"/>      local s
<a name="721"/>      s := read_line(fl) | fail
<a name="722"/>      return \s | error("Unexpected end of file")
<a name="723"/>   end
<a name="724"/>
<a name="725"/>   #
<a name="726"/>   # Read up to len bytes on the connection, returning `&amp;null` on
<a name="727"/>   # end of file.
<a name="728"/>   #
<a name="729"/>   protected read_str(len)
<a name="730"/>      local t
<a name="731"/>      #
<a name="732"/>      # Use the line buffer if it has anything in it.
<a name="733"/>      #
<a name="734"/>      if *sbuff &gt; 0 then {
<a name="735"/>         sbuff ? {
<a name="736"/>            t := move(len) | tab(0)
<a name="737"/>            sbuff := tab(0)
<a name="738"/>         }
<a name="739"/>      } else {
<a name="740"/>         t := recv(len) | fail
<a name="741"/>         if /t then
<a name="742"/>            return
<a name="743"/>      }
<a name="744"/>      fire(READ_STRING_EVENT, t)
<a name="745"/>      return t
<a name="746"/>   end
<a name="747"/>
<a name="748"/>   #
<a name="749"/>   # This method is the same as `read_str`, except that on end of file
<a name="750"/>   # it fails, setting `&amp;why`, rather than returning `&amp;null`.
<a name="751"/>   #
<a name="752"/>   protected expect_str(len)
<a name="753"/>      local s
<a name="754"/>      s := read_str(len) | fail
<a name="755"/>      return \s | error("Unexpected end of file")
<a name="756"/>   end
<a name="757"/>
<a name="758"/>   #
<a name="759"/>   # This calls `expect_str` several times in order to read exactly `len`
<a name="760"/>   # characters from the connection.
<a name="761"/>   #
<a name="762"/>   protected exact_str(len)
<a name="763"/>      local s, t
<a name="764"/>      len := need_integer(len, 1)
<a name="765"/>      s := ""
<a name="766"/>      while len &gt; 0 do {
<a name="767"/>         t := expect_str(len) | fail
<a name="768"/>         s ||:= t
<a name="769"/>         len -:= *t
<a name="770"/>      }
<a name="771"/>      return s
<a name="772"/>   end
<a name="773"/>
<a name="774"/>   #
<a name="775"/>   # Succeed iff the connection is currently open.
<a name="776"/>   #
<a name="777"/>   protected is_connected()
<a name="778"/>      succeed \self.connection
<a name="779"/>   end
<a name="780"/>
<a name="781"/>   #
<a name="782"/>   # A flag value.  When set, indicate that the connection should be wrapped in
<a name="783"/>   # an SslStream.
<a name="784"/>   #
<a name="785"/>   public set_ssl(s)
<a name="786"/>      self.ssl_flag := need_flag(s)
<a name="787"/>      link
<a name="788"/>   end
<a name="789"/>
<a name="790"/>   #
<a name="791"/>   # A flag value.  When set, indicate that the remote host's identity should be
<a name="792"/>   # verified.  By default, this flag is on.
<a name="793"/>   #
<a name="794"/>   public set_ssl_verify(s)
<a name="795"/>      self.ssl_verify_flag := need_flag(s)
<a name="796"/>      link
<a name="797"/>   end
<a name="798"/>
<a name="799"/>   #
<a name="800"/>   # Set the `dont_retry_flag`, indicating an error has occurred that
<a name="801"/>   # couldn't be overcome by retrying.  Then `&amp;why` is set to `s`.
<a name="802"/>   #
<a name="803"/>   protected error_dont_retry(s)
<a name="804"/>      dont_retry_flag := &amp;yes
<a name="805"/>      &amp;why := s
<a name="806"/>   end
<a name="807"/>
<a name="808"/>   #
<a name="809"/>   # Like `error_dont_retry`, but take a format arguments for `whyf`.
<a name="810"/>   #
<a name="811"/>   protected whyf_dont_retry(a[])
<a name="812"/>      dont_retry_flag := &amp;yes
<a name="813"/>      whyf!a
<a name="814"/>   end
<a name="815"/>
<a name="816"/>   #
<a name="817"/>   # Clear the `dont_retry_flag`.
<a name="818"/>   #
<a name="819"/>   protected reset_dont_retry()
<a name="820"/>      dont_retry_flag := &amp;null
<a name="821"/>      link
<a name="822"/>   end
<a name="823"/>
<a name="824"/>   public override new()
<a name="825"/>      Connectable.new()
<a name="826"/>      sbuff := ""
<a name="827"/>      ssl_verify_flag := &amp;yes
<a name="828"/>      return
<a name="829"/>   end
<a name="830"/>end
<a name="831"/>
<a name="832"/>#
<a name="833"/># Class for storing a host and a port.
<a name="834"/>#
<a name="835"/>class HostPort()
<a name="836"/>   public const
<a name="837"/>      host, port
<a name="838"/>
<a name="839"/>   public new(host, port)
<a name="840"/>      self.host := need_text(host)
<a name="841"/>      self.port := need_integer(port, 0)
<a name="842"/>      return
<a name="843"/>   end
<a name="844"/>end
<a name="845"/>
<a name="846"/>#
<a name="847"/># Parse a string `s` in the form "host:port" into a `HostPort` instance.
<a name="848"/># `def` is an optional default port value.  `c` is a cset giving an
<a name="849"/># alternative separator from the default ":".
<a name="850"/>#
<a name="851"/>procedure parse_host_port(s, def, c)
<a name="852"/>   local host, port
<a name="853"/>   /c := ':'
<a name="854"/>   s ? {
<a name="855"/>      host := if ="[" then
<a name="856"/>         1(tab(upto(']')), move(1)) | return error("Missing ] bracket")
<a name="857"/>      else
<a name="858"/>         tab(upto(c) | 0)
<a name="859"/>      if *host = 0 then
<a name="860"/>         return error("Missing host")
<a name="861"/>      (port := (if tab(any(c)) then integer(tab(many(&amp;digits))) else \def) &amp; pos(0)) |
<a name="862"/>                 return error("Host" || c || "port expected")
<a name="863"/>      NetClient.valid_port(port) | return error("Port out of range")
<a name="864"/>   }
<a name="865"/>   return HostPort(host, port)
<a name="866"/>end
<a name="867"/>
<a name="868"/>#
<a name="869"/># Return an options() converter function for a host:port argument,
<a name="870"/># with `def` as an optional default port.
<a name="871"/>#
<a name="872"/>procedure host_port_opt(def)
<a name="873"/>   return rpartial(parse_host_port, def)
<a name="874"/>end
<a name="875"/>
<a name="876"/>#
<a name="877"/># A class for encapsulating a username and password
<a name="878"/>#
<a name="879"/>class Authentication()
<a name="880"/>   public const
<a name="881"/>      username, password
<a name="882"/>
<a name="883"/>   public new(username, password)
<a name="884"/>      self.username := need_text(username)
<a name="885"/>      self.password := need_text(password)
<a name="886"/>      return
<a name="887"/>   end
<a name="888"/>end
<a name="889"/>
<a name="890"/>#
<a name="891"/># options() converter function for an authentication argument.
<a name="892"/>#
<a name="893"/>procedure authentication_opt(s)
<a name="894"/>   return s ? Authentication( tab(upto(':')), move(1) &amp; tab(0) ) |
<a name="895"/>      error("Username:password expected")
<a name="896"/>end
<a name="897"/>
<a name="898"/>#
<a name="899"/># options() converter function for an IP version argument.
<a name="900"/>#
<a name="901"/>procedure ip_version_opt(s)
<a name="902"/>   return integer(s) = (4 | 6 | 46 | 64 | 0) | error("IP version expected")
<a name="903"/>end
<a name="904"/>
<a name="905"/>#
<a name="906"/># options() converter function for a port number.
<a name="907"/>#
<a name="908"/>procedure port_opt(s)
<a name="909"/>   s := integer(s) | return error("Port expected")
<a name="910"/>   return if NetClient.valid_port(s) then s else error("Port out of range")
<a name="911"/>end
</pre></body></html>
