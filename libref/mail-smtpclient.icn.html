<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>smtpclient.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: smtpclient.icn 8996 2021-03-24 07:27:53Z rparlett $
<a name="3"/>#
<a name="4"/>
<a name="5"/>package mail
<a name="6"/>
<a name="7"/>import net, util, lang
<a name="8"/>
<a name="9"/>class SmtpClient(NetClient)
<a name="10"/>   private static const 
<a name="11"/>      RFC822_HEADERS
<a name="12"/>
<a name="13"/>   private static init()
<a name="14"/>      RFC822_HEADERS := set("date", "resent-date", "return-path", "received", "sender", 
<a name="15"/>                            "from", "reply-to", "resent-sender", "resent-from", 
<a name="16"/>                            "resent-reply-to", "to", "resent-to", "cc", "resent-cc", 
<a name="17"/>                            "bcc", "resent-bcc", "message-id", "resent-message-id",
<a name="18"/>                            "in-reply-to", "references", "keywords", "subject", 
<a name="19"/>                            "comments", "encrypted")
<a name="20"/>   end
<a name="21"/>
<a name="22"/>   private 
<a name="23"/>      hostname,
<a name="24"/>      sent_helo
<a name="25"/>
<a name="26"/>   #
<a name="27"/>   # Set the hostname to use with the EHLO command; by default `&amp;host`.
<a name="28"/>   #
<a name="29"/>   public set_hostname(s)
<a name="30"/>      hostname := need_string(s)
<a name="31"/>      link
<a name="32"/>   end
<a name="33"/>
<a name="34"/>   public open()
<a name="35"/>      local s
<a name="36"/>      open_connection() | fail
<a name="37"/>      sent_helo := &amp;null
<a name="38"/>      unless s := read_response() then {
<a name="39"/>         close_connection()
<a name="40"/>         fail
<a name="41"/>      }
<a name="42"/>      unless s[1:4] == "220" then {
<a name="43"/>         close_connection()
<a name="44"/>         return error("Failed to get initial 220: " || s)
<a name="45"/>      }
<a name="46"/>      link
<a name="47"/>   end
<a name="48"/>
<a name="49"/>   public override close()
<a name="50"/>      local f
<a name="51"/>      send_command("QUIT", 221) | (f := &amp;why)
<a name="52"/>      close_connection() | (/f := &amp;why)
<a name="53"/>      link error_if(f)
<a name="54"/>   end
<a name="55"/>
<a name="56"/>   public send_message(m)
<a name="57"/>      local s, l, mb
<a name="58"/>
<a name="59"/>      if /sent_helo then {
<a name="60"/>         send_command("EHLO " || hostname, 250) | fail
<a name="61"/>         sent_helo := &amp;yes
<a name="62"/>      } else
<a name="63"/>         send_command("RSET", 250)
<a name="64"/>
<a name="65"/>      l := m.get_from() | return error("Invalid From address in message")
<a name="66"/>      if *l = 0 then
<a name="67"/>         return error("No From address in message")
<a name="68"/>      send_command("MAIL FROM: " || smtp_address(l[1]), 250) | fail
<a name="69"/>
<a name="70"/>      l := get_all_mailboxes(m.get_to()) | return error("Invalid To address in message")
<a name="71"/>      if *l = 0 then
<a name="72"/>         return error("No To address in message")
<a name="73"/>      every mb := !l do 
<a name="74"/>         send_command("RCPT TO: " || smtp_address(mb), 250)  | fail
<a name="75"/>
<a name="76"/>      send_command("DATA", 354) | fail
<a name="77"/>      send_headers(m) | fail
<a name="78"/>
<a name="79"/>      #
<a name="80"/>      # Transform the content to change any . starting a line to ..
<a name="81"/>      #
<a name="82"/>      s := ""
<a name="83"/>      m.get_content() ? {
<a name="84"/>         if ="." then {
<a name="85"/>            s ||:= ".."
<a name="86"/>         }
<a name="87"/>         while s ||:= tab(find("\r\n.")) do {
<a name="88"/>            move(3)
<a name="89"/>            s ||:= "\r\n.."
<a name="90"/>         }
<a name="91"/>         s ||:= tab(0)
<a name="92"/>      }
<a name="93"/>      write_line(s) | fail
<a name="94"/>      send_command(".", 250) | fail
<a name="95"/>
<a name="96"/>      link
<a name="97"/>   end
<a name="98"/>
<a name="99"/>   private smtp_address(mb)
<a name="100"/>      return "&lt;" || mb.get_local_part() || "@" || mb.get_domain() || "&gt;"
<a name="101"/>   end
<a name="102"/>
<a name="103"/>   private send_command(msg, reply)
<a name="104"/>      local s, rc
<a name="105"/>      write_line(msg) | fail
<a name="106"/>
<a name="107"/>      s := read_response() | fail
<a name="108"/>
<a name="109"/>      rc := integer(s[1:4]) | return error("Couldn't get return code")
<a name="110"/>      succeed (rc = reply) | error("Server responded " || s)
<a name="111"/>   end
<a name="112"/>
<a name="113"/>   private read_response()
<a name="114"/>      local s, t
<a name="115"/>
<a name="116"/>      t := ""
<a name="117"/>      repeat {
<a name="118"/>         s := expect_line() | fail
<a name="119"/>
<a name="120"/>         t ||:= s || "\n"
<a name="121"/>
<a name="122"/>         unless s[4] == "-" then
<a name="123"/>            return t
<a name="124"/>      }         
<a name="125"/>   end
<a name="126"/>
<a name="127"/>   # Output the first header with the key only
<a name="128"/>   private send_first_header(l, m, key)
<a name="129"/>      put(l, key || ": " || m.get_first_header(key))
<a name="130"/>   end
<a name="131"/>
<a name="132"/>   # Output all the headers with the key only, as separate header lines
<a name="133"/>   private send_headers_list(l, m, key)
<a name="134"/>      every put(l, key || ": " || m.gen_headers(key))
<a name="135"/>   end
<a name="136"/>
<a name="137"/>   # Output all the headers for the key catenated together
<a name="138"/>   private send_catenated_header(l, m, key)
<a name="139"/>      put(l, key || ": " || m.get_catenated_headers(key))
<a name="140"/>   end
<a name="141"/>
<a name="142"/>   private send_headers(m)
<a name="143"/>      local k, l
<a name="144"/>
<a name="145"/>      l := []
<a name="146"/>
<a name="147"/>      send_first_header(l, m, "Resent-Date")
<a name="148"/>      send_first_header(l, m, "Sender")
<a name="149"/>      send_first_header(l, m, "From")
<a name="150"/>      send_catenated_header(l, m, "Reply-To")
<a name="151"/>      send_first_header(l, m, "Resent-Sender")
<a name="152"/>      send_catenated_header(l, m, "Resent-From")
<a name="153"/>      send_catenated_header(l, m, "Resent-Reply-To")
<a name="154"/>      send_catenated_header(l, m, "To")
<a name="155"/>      send_catenated_header(l, m, "Resent-To")
<a name="156"/>      send_catenated_header(l, m, "cc")
<a name="157"/>      send_catenated_header(l, m, "Resent-cc")
<a name="158"/>      send_catenated_header(l, m, "bcc")
<a name="159"/>      send_catenated_header(l, m, "Resent-bcc")
<a name="160"/>      send_first_header(l, m, "Resent-Message-ID")
<a name="161"/>      send_first_header(l, m, "In-Reply-To")
<a name="162"/>      send_first_header(l, m, "References")
<a name="163"/>      send_first_header(l, m, "Keywords")
<a name="164"/>      send_first_header(l, m, "Subject")
<a name="165"/>      send_first_header(l, m, "Comments")
<a name="166"/>      send_first_header(l, m, "Encrypted")
<a name="167"/>
<a name="168"/>      every k := m.gen_header_keys() do
<a name="169"/>         member(RFC822_HEADERS, Text.lower(k)) | send_headers_list(l, m, k)
<a name="170"/>
<a name="171"/>      return write_lines(l)
<a name="172"/>   end
<a name="173"/>
<a name="174"/>   public override new()
<a name="175"/>      NetClient.new()
<a name="176"/>      set_port(25)
<a name="177"/>      set_server("localhost")
<a name="178"/>      set_hostname(&amp;host | "unknown")
<a name="179"/>      return
<a name="180"/>   end
<a name="181"/>end
</pre></body></html>
