package util

link random, posix

class Files()
   private static const FS

   private static init()
      FS := 
         if has_feature("MS Windows NT" | "MS-DOS") then 
            WindowsFileSystem()
         else if has_feature("UNIX" | "PLAN9") then
            UnixFileSystem()
         else
            stop("Can't init_file_system: unknown o/s type")
   end

   #
   # Read a directory.
   #
   public static list(s)
      return FS.list(s)
   end

   public static get_path(s)
      return FS.get_path(s)
   end

   public static get_path_from_list(l)
      return FS.get_path_from_list(l)
   end

   public static get_home()
      return FS.get_home()
   end

   public static get_temp()
      return FS.get_temp()
   end

   public static is_hidden(s)
      return FS.is_hidden(s)
   end

   public static is_relative_dir(s)
      return FS.is_relative_dir(s)
   end

   public static get_roots()
      return FS.get_roots()
   end

   public static get_separator()
      return FS.get_separator()
   end

   public static file_to_string(fn)
      local res, f
      f := open(fn, "ru") | fail
      res := ""
      while res ||:= reads(f, 8192)
      close(f)
      return res
   end

   public static string_to_file(fn, s)
      local f
      f := open(fn, "wu") | fail
      writes(f, s)
      close(f)
      return s
   end

   public static make_temp_filename(prefix, suffix, path, len)
      local p, name

      /prefix := ""
      /suffix := ""
      /path := Files.FS.get_temp()
      /len := 8

      randomize()

      p := Files.FS.get_path(path)
      repeat {
         ?1                                # change &random
         name := p.get_child(prefix || left(&random, 8, "0") || suffix).str()
         if not open(name) then {
            # Touch the filename to stop anyone else using it.
            close(open(name, "w"))
            return name
         }
      }
   end

   public static equal_files(n1, n2)
      local f1, f2, r

      stat(n1).size = stat(n2).size | fail

      f1 := open(n1, "ru") | fail
      f2 := open(n2, "ru") | {
         close(f1)
         fail
      }

      if equal_files1(f1, f2) then
         r := 1

      close(f1)
      close(f2)

      return \r
   end

   private static equal_files1(f1, f2)
      local s1, s2

      while s1 := reads(f1, 8192) do {
         s2 := reads(f2, 8192) | fail
         s1 == s2 | fail
      }
      
      return not(reads(f2))
   end

   public static is_directory(s)
      return stat(s).mode[1] == "d"
   end

   public static rename_file(s1, s2)
      if rename(s1, s2) then
         return
      copy_file(s1, s2) | fail
      remove(s1)
      return
   end

   public static copy_file(s1, s2)
      local f1, f2
      f1 := open(s1, "ru") | fail
      f2 := open(s2, "wu") | {
         close(f1)
         fail
      }
      # The writes will give a runtime error 214 on failure (eg device full).
      while writes(f2, reads(f1, 8192))
      close(f1)
      close(f2)
      return
   end

   public static append_file(s1, s2)
      local f1, f2
      f1 := open(s1, "ru") | fail
      f2 := open(s2, "au") | {
         close(f1)
         fail
      }
      # The writes will give a runtime error 214 on failure (eg device full).
      while writes(f2, reads(f1, 8192))
      close(f1)
      close(f2)
      return
   end

   public static ensure_unique_filename(stem)
      local i, p, s
      stat(stem) | return stem
      i := 1
      every p := find(".", stem)
      repeat {
         s := stem
         if /p then
            s ||:= "_" || i
         else
            s[p] := "_" || i || s[p]
         stat(s) | return s
         i +:= 1
      }
   end
end

class FileSystem(Error)
end

class FilePath()
end

class DirEntry()
   private readable name, 
               dev,
               ino,
               mode,
               nlink,
               uid,
               gid,
               rdev,
               size,
               atime,
               mtime,
               ctime,
               blksize,
               blocks,
               symlink

   package new(name, ps)
      self.name := name
      self.dev := ps.dev
      self.ino := ps.ino
      self.mode := ps.mode
      self.nlink := ps.nlink
      self.uid := ps.uid
      self.gid := ps.gid
      self.rdev := ps.rdev
      self.size := ps.size
      self.atime := ps.atime
      self.mtime := ps.mtime
      self.ctime := ps.ctime
      self.blksize := ps.blksize
      self.blocks := ps.blocks
      self.symlink := ps.symlink
      return
   end
end

class UnixFilePath(FilePath)
   private l

   public str()
      local e, s
      s := ""
      every e := !l do {
         if s[-1] ~== "/" then 
            s ||:= "/"
         s ||:= e
      }
      return s
   end

   public append(other)
      return UnixFilePath(l ||| other.l)
   end

   public add(x)
      put(l, x)
   end

   public get_last()
      return l[-1]
   end

   public get_parent()
      if *l > 1 then
         return UnixFilePath(l[1:-1])
   end

   public get_child(x)
      return UnixFilePath(l ||| [x])
   end

   public is_absolute()
      return l[1] == "/"
   end

   public get_absolute()
      if is_absolute() then
         return self
      return Files.get_path(chdir()).append(self)
   end

   public get_clean()
      local e, r
      r := []
      every e := !l do {
         if e == "." then
            next
         else if e == ".." then {
            # /.. -> /
            if r[-1] ~== "/" then
               pull(r)
         } else
            put(r, e)
      }
      return UnixFilePath(r)
   end

   #
   # Canonicalize a path.  This involves :-
   #   - expanding non-absolute paths to absolute ones using chdir()
   #   - removing any ".." or "." directories
   #
   public get_canonical()
      return get_absolute().get_clean()
   end

   package new(l)
      self.l := l
      return
   end
end

class UnixFileSystem(FileSystem)
   #
   # Read a directory.
   #
   public list(s)
      local l, p, s2, sr
      if (*s > 1) & (s[-1] == "/") then 
         s[-1] := ""
      p := open(s) | return error("Can't open " || image(s))
      if s[-1] ~== "/" then 
         s ||:= "/"
      l := []
      while s2 := read(p) do {
         sr := stat(s || s2) | return error("Can't stat " || image(s || s2))
         put(l, DirEntry(s2, sr))
      }
      close(p)
      return l
   end

   public get_path(s)
      local l, t
      l := []
      s ? {
         put(l, ="/")
         while not pos(0) do {
            t := tab(upto('/') | 0)
            if *t > 0 then
               put(l, t)
            move(1)
         }
      }
      return UnixFilePath(l)
   end

   public get_path_from_list(l)
      return UnixFilePath(l)
   end

   public get_home()
      return getenv("HOME")
   end

   public get_temp()
      return getenv("TEMP") | "/tmp"
   end

   public is_hidden(s)
      return any('.', s)
   end

   public is_relative_dir(s)
      return s == ("." | "..")
   end

   public get_roots()
      return "/"
   end

   public get_separator()
      return "/"
   end
end

class WindowsFilePath(FilePath)
   private l

   public str()
      local e, s
      s := ""
      every e := !l do {
         if s[-1] ~== "\\" then 
            s ||:= "\\"
         s ||:= e
      }
      return s
   end

   public append(other)
      return WindowsFilePath(l ||| other.l)
   end

   public add(x)
      put(l, x)
   end

   public get_last()
      return l[-1]
   end

   public get_parent()
      if *l > 1 then
         return WindowsFilePath(l[1:-1])
   end

   public get_child(x)
      return WindowsFilePath(l ||| [x])
   end

   public is_absolute()
      return l[1][2:0] == ":\\"
   end

   public get_absolute()
      if is_absolute() then
         return self
      return Files.get_path(chdir()).append(self)
   end

   public get_clean()
      local e, r
      r := []
      every e := !l do {
         if e == "." then
            next
         else if e == ".." then
            pull(r)
         else
            put(r, e)
      }
      return WindowsFilePath(r)
   end

   #
   # Canonicalize a path.  This involves :-
   #   - expanding non-absolute paths to absolute ones using chdir()
   #   - removing any ".." or "." directories
   #
   public get_canonical()
      return get_absolute().get_clean()
   end

   package new(l)
      self.l := l
      return
   end
end

class WindowsFileSystem(FileSystem)
   #
   # Read a directory.
   #
   public list(s)
      local l, p, s2, sr
      s := map(s, "/", "\\")
      if s[2:4] == ":\\" then {
         if *s > 3 & s[-1] == "\\" then
            s[-1] := ""
      } else {
         if *s > 1 & s[-1] == "\\" then
            s[-1] := ""
      }
      p := open(s) | return error("Can't open " || image(s))
      if s[-1] ~== "\\" then 
         s ||:= "\\"
      l := []
      while s2 := read(p) do {
         sr := stat(s || s2) | return error("Can't stat " || image(s || s2))
         put(l, DirEntry(s2, sr))
      }
      close(p)
      return l
   end

   public get_path(s)
      local l
      l := []
      s := map(s, "/", "\\")
      s ? {
         if &subject[2:4] == ":\\" then
            put(l, move(3))
         while put(l, tab(upto("\\"))) do 
            move(1)
         pos(0) | put(l, tab(0))
      }
      return WindowsFilePath(l)
   end

   public get_path_from_list(l)
      return WindowsFilePath(l)
   end

   public get_home()
      return getenv("HOME")
   end

   public get_temp()
      return getenv("TEMP") | "C:\\TEMP"
   end

   public is_hidden(s)
   end

   public is_relative_dir(s)
      return s == ("." | "..")
   end

   public get_roots()
      suspend "A:\\" | "B:\\" | "C:\\"
   end

   public get_separator()
      return "\\"
   end
end
