<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>selectablescrollarea.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: selectablescrollarea.icn 9036 2021-04-10 00:31:43Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package gui
<a name="10"/>
<a name="11"/>import 
<a name="12"/>   util, 
<a name="13"/>   lang, 
<a name="14"/>   graphics,
<a name="15"/>   ipl.sets,
<a name="16"/>   ipl.numbers,
<a name="17"/>   ipl.pdco
<a name="18"/>
<a name="19"/>#
<a name="20"/># This class extends LineBasedScrollArea to provide selection on lines,
<a name="21"/># event handling and selection handling.
<a name="22"/>#
<a name="23"/># Mouse and key movements are briefly as follows.
<a name="24"/>#
<a name="25"/># * Mouse movements.
<a name="26"/>#   * middle and right mouse just move the cursor and don't select
<a name="27"/>#   * left mouse moves the cursor and selects.  In select many mode :-
<a name="28"/>#       * shift modifier selects all from old cursor to new
<a name="29"/>#       * ctrl modifier toggles one row on or off
<a name="30"/># 
<a name="31"/># * Key movements.  In selection on key moves mode :-
<a name="32"/>#   * control modifier means just move, no selection.
<a name="33"/>#   * shift modifier means (in select many mode) select all from old cursor
<a name="34"/>#     to new.
<a name="35"/># 
<a name="36"/># * Return key.
<a name="37"/>#   * In select many mode, shift or control modifier means toggle the cursor
<a name="38"/>#     row's selection.
<a name="39"/>#   * Otherwise, the cursor row alone is selected.
<a name="40"/>#
<a name="41"/># * Escape key clears the selection.
<a name="42"/>#
<a name="43"/># * Control-A selects all rows (in select many mode).
<a name="44"/>#
<a name="45"/>abstract class SelectableScrollArea(LineBasedScrollArea)
<a name="46"/>   public 
<a name="47"/>      contents,
<a name="48"/>      select_mode,
<a name="49"/>      dnd_mode,
<a name="50"/>      over,
<a name="51"/>      cursor,                                
<a name="52"/>      selections,
<a name="53"/>      old_over,
<a name="54"/>      old_cursor,
<a name="55"/>      old_highlight,
<a name="56"/>      old_highlight_part,
<a name="57"/>      old_selections,
<a name="58"/>      going_up,
<a name="59"/>      prev_cursor,
<a name="60"/>      on_a_line,
<a name="61"/>      highlight,
<a name="62"/>      highlight_part,
<a name="63"/>      show_over_flag,
<a name="64"/>      draggable_cursor_flag,
<a name="65"/>      motion_cursor_flag,
<a name="66"/>      selection_on_key_moves_flag,
<a name="67"/>      always_show_focus_cursor_flag,
<a name="68"/>      wrap_on_up_down_flag,
<a name="69"/>      scroll_ticker,
<a name="70"/>      scroll_ticker_interval
<a name="71"/>
<a name="72"/>   public static const
<a name="73"/>      TOP,
<a name="74"/>      MIDDLE,
<a name="75"/>      BOTTOM,
<a name="76"/>      MIDDLE_ONLY,
<a name="77"/>      EDGES_ONLY,
<a name="78"/>      MIDDLE_AND_EDGES,
<a name="79"/>      INTER_LINE_WIDTH
<a name="80"/>
<a name="81"/>   private static init()
<a name="82"/>      TOP := "t"
<a name="83"/>      MIDDLE := "m"
<a name="84"/>      BOTTOM := "b"
<a name="85"/>      MIDDLE_ONLY := "middle only"
<a name="86"/>      EDGES_ONLY := "edges only"
<a name="87"/>      MIDDLE_AND_EDGES := "middle and edges"
<a name="88"/>      INTER_LINE_WIDTH := env_int("OI_SCROLLAREA_INTER_LINE_WIDTH", 1) | 2 * Gui.FINE_WIDTH
<a name="89"/>   end
<a name="90"/>
<a name="91"/>   public override calculate_line_count()
<a name="92"/>      return *self.contents
<a name="93"/>   end
<a name="94"/>
<a name="95"/>   #
<a name="96"/>   # Set the data to be displayed.
<a name="97"/>   # :Parameters :
<a name="98"/>   # :  `x` - The list of data.
<a name="99"/>   #
<a name="100"/>   public set_contents(x)
<a name="101"/>      self.contents := need_list(x)
<a name="102"/>      contents_changed()
<a name="103"/>      link
<a name="104"/>   end
<a name="105"/>
<a name="106"/>   #
<a name="107"/>   # Ensure all the selections are valid lines.
<a name="108"/>   #
<a name="109"/>   private constrain_selections()
<a name="110"/>      local i
<a name="111"/>      every i := !self.selections do
<a name="112"/>         if i &gt; *self.contents then
<a name="113"/>            delete(self.selections, i)
<a name="114"/>   end
<a name="115"/>
<a name="116"/>   #
<a name="117"/>   # Call this method if the contents list, previously
<a name="118"/>   # set with `set_contents()`, has changed.
<a name="119"/>   #
<a name="120"/>   public contents_changed()
<a name="121"/>      constrain_selections()
<a name="122"/>      constrain_cursor(&amp;yes)
<a name="123"/>      invalidate_subject_width()
<a name="124"/>      invalidate_line_height()
<a name="125"/>      invalidate_line_count()
<a name="126"/>      compute_and_invalidate()
<a name="127"/>      link
<a name="128"/>   end
<a name="129"/>
<a name="130"/>   #
<a name="131"/>   # Keep the cursor within the bounds of the contents.
<a name="132"/>   # 
<a name="133"/>   private constrain_cursor(fl)
<a name="134"/>      if *contents = 0 then
<a name="135"/>         cursor := &amp;null
<a name="136"/>      else if \fl | \cursor then {
<a name="137"/>         /cursor := 1
<a name="138"/>         cursor &lt;:= 1
<a name="139"/>         cursor &gt;:= *contents
<a name="140"/>      }
<a name="141"/>   end
<a name="142"/>
<a name="143"/>   #
<a name="144"/>   # Clear the selections.
<a name="145"/>   #
<a name="146"/>   public clear_selections()
<a name="147"/>      return set_selections([])
<a name="148"/>   end
<a name="149"/>
<a name="150"/>   #
<a name="151"/>   # Configure the object so that drags move the cursor (precludes using d&amp;d with the
<a name="152"/>   # component).
<a name="153"/>   #
<a name="154"/>   public set_draggable_cursor(s)
<a name="155"/>      self.draggable_cursor_flag := need_flag(s)
<a name="156"/>      link
<a name="157"/>   end
<a name="158"/>
<a name="159"/>   #
<a name="160"/>   # Configure whether or not cursor up and down keys should wrap
<a name="161"/>   # around the contents.  Default is no.
<a name="162"/>   #
<a name="163"/>   public set_wrap_on_up_down(s)
<a name="164"/>      self.wrap_on_up_down_flag := need_flag(s)
<a name="165"/>      link
<a name="166"/>   end
<a name="167"/>
<a name="168"/>   #
<a name="169"/>   # Configure the object so that mouse motion moves the cursor.
<a name="170"/>   #
<a name="171"/>   public set_motion_cursor(s)
<a name="172"/>      self.motion_cursor_flag := need_flag(s)
<a name="173"/>      link
<a name="174"/>   end
<a name="175"/>
<a name="176"/>   #
<a name="177"/>   # Configure the object so that the row the mouse is over is indicated.
<a name="178"/>   #
<a name="179"/>   public set_show_over(s)
<a name="180"/>      self.show_over_flag := need_flag(s)
<a name="181"/>      link
<a name="182"/>   end
<a name="183"/>
<a name="184"/>   #
<a name="185"/>   # Configure the object so that the focus (red) cursor is always
<a name="186"/>   # displayed, even if focus is not held.
<a name="187"/>   #
<a name="188"/>   public set_always_show_focus_cursor(s)
<a name="189"/>      self.always_show_focus_cursor_flag := need_flag(s)
<a name="190"/>      link
<a name="191"/>   end
<a name="192"/>
<a name="193"/>   #
<a name="194"/>   # Configure whether moving the cursor via the keyboard alters the
<a name="195"/>   # selection (the default behaviour).
<a name="196"/>   #
<a name="197"/>   public set_selection_on_key_moves(s)
<a name="198"/>      self.selection_on_key_moves_flag := need_flag(s)
<a name="199"/>      link
<a name="200"/>   end
<a name="201"/>
<a name="202"/>   #
<a name="203"/>   # Configure the selection mode.
<a name="204"/>   # :Parameters :
<a name="205"/>   # :  `s` - a constant from `Select`
<a name="206"/>   #
<a name="207"/>   public set_select_mode(s)
<a name="208"/>      self.select_mode := s
<a name="209"/>      link
<a name="210"/>   end
<a name="211"/>
<a name="212"/>   #
<a name="213"/>   # Configure the dnd mode, which indicates whether drags should be
<a name="214"/>   # be over whole lines, edges of lines, or both.  As a more flexible
<a name="215"/>   # alternative, which allows the mode to change depending on the
<a name="216"/>   # line, the `get_dnd_mode` method may be overridden.
<a name="217"/>   # 
<a name="218"/>   # :Parameters :
<a name="219"/>   # :  `s` - a constant, one of `MIDDLE_ONLY`, `EDGES_ONLY`, or `MIDDLE_AND_EDGES`
<a name="220"/>   #
<a name="221"/>   public set_dnd_mode(s)
<a name="222"/>      self.dnd_mode := s
<a name="223"/>      link
<a name="224"/>   end
<a name="225"/>
<a name="226"/>   #
<a name="227"/>   # Return item currently under the clicked cursor
<a name="228"/>   # :Returns :
<a name="229"/>   # :  The item number
<a name="230"/>   #
<a name="231"/>   public get_cursor()
<a name="232"/>      return \self.cursor
<a name="233"/>   end
<a name="234"/>
<a name="235"/>   #
<a name="236"/>   # Return object currently under the clicked cursor
<a name="237"/>   # :Returns :
<a name="238"/>   # :  The object
<a name="239"/>   #
<a name="240"/>   public object_get_cursor()
<a name="241"/>      return self.contents[\self.cursor]
<a name="242"/>   end
<a name="243"/>
<a name="244"/>   #
<a name="245"/>   # Return item currently under the dnd highlight
<a name="246"/>   # :Returns :
<a name="247"/>   # :  The item number
<a name="248"/>   #
<a name="249"/>   public get_highlight()
<a name="250"/>      return \self.highlight
<a name="251"/>   end
<a name="252"/>
<a name="253"/>   #
<a name="254"/>   # Return the part of the item currently under the dnd highlight;
<a name="255"/>   # one of `TOP`, `MIDDLE` or `BOTTOM`.
<a name="256"/>   #
<a name="257"/>   public get_highlight_part()
<a name="258"/>      return \self.highlight_part
<a name="259"/>   end
<a name="260"/>
<a name="261"/>   #
<a name="262"/>   # Return object currently under the dnd highlight
<a name="263"/>   # :Returns :
<a name="264"/>   # :  The object
<a name="265"/>   #
<a name="266"/>   public object_get_highlight()
<a name="267"/>      return self.contents[\self.highlight]
<a name="268"/>   end
<a name="269"/>
<a name="270"/>   #
<a name="271"/>   # Find the line which contains the given object, or fail
<a name="272"/>   #
<a name="273"/>   public find_line(o)
<a name="274"/>      return keyof(contents, o)
<a name="275"/>   end
<a name="276"/>
<a name="277"/>   #
<a name="278"/>   # Return a list of items selected (highlighted), in ascending order.
<a name="279"/>   # :Returns :
<a name="280"/>   # :  A list of items currently selected
<a name="281"/>   #
<a name="282"/>   public get_selections()
<a name="283"/>      return sort(selections)
<a name="284"/>   end
<a name="285"/>
<a name="286"/>   #
<a name="287"/>   # Return a list of objects selected (highlighted)
<a name="288"/>   # :Returns :
<a name="289"/>   # :  A list of objects currently selected
<a name="290"/>   #
<a name="291"/>   public object_get_selections()
<a name="292"/>      return ipl.pdco.List{ object_gen_selections() }
<a name="293"/>   end
<a name="294"/>
<a name="295"/>   #
<a name="296"/>   # Generate the selected (highlighted) objects.
<a name="297"/>   #
<a name="298"/>   public object_gen_selections()
<a name="299"/>      suspend contents[!sort(selections)]
<a name="300"/>   end
<a name="301"/>
<a name="302"/>   #
<a name="303"/>   # Return the first selected (highlighted) object (if any).
<a name="304"/>   #
<a name="305"/>   public object_first_selection()
<a name="306"/>      return object_gen_selections()
<a name="307"/>   end
<a name="308"/>
<a name="309"/>   #
<a name="310"/>   # Set the current selections to the list l, which is a list of
<a name="311"/>   # item numbers.
<a name="312"/>   # :Parameters :
<a name="313"/>   # :  `l` - The list of item numbers.
<a name="314"/>   #
<a name="315"/>   public set_selections(l)
<a name="316"/>      local i, t
<a name="317"/>      if is_live() then {
<a name="318"/>         i := get_line_info()
<a name="319"/>         t := copy(selections)
<a name="320"/>         self.selections := elementset(l)
<a name="321"/>         constrain_selections()
<a name="322"/>         every invalidate_line(!(t -- selections) | !(selections -- t), i)
<a name="323"/>      } else {
<a name="324"/>         self.selections := elementset(l)
<a name="325"/>         constrain_selections()
<a name="326"/>      }
<a name="327"/>      link
<a name="328"/>   end
<a name="329"/>
<a name="330"/>   #
<a name="331"/>   # Select the given line number
<a name="332"/>   #
<a name="333"/>   public select_line(i)
<a name="334"/>      i := need_integer(i)
<a name="335"/>      if (0 &lt; i &lt;= *self.contents) &amp; not member(self.selections, i) then {
<a name="336"/>         insert(self.selections, i)
<a name="337"/>         invalidate_line(i)
<a name="338"/>      }
<a name="339"/>      link
<a name="340"/>   end
<a name="341"/>
<a name="342"/>   #
<a name="343"/>   # De-select the given line number
<a name="344"/>   #
<a name="345"/>   public deselect_line(i)
<a name="346"/>      i := need_integer(i)
<a name="347"/>      if member(self.selections, i) then {
<a name="348"/>         delete(self.selections, i)
<a name="349"/>         invalidate_line(i)
<a name="350"/>      }
<a name="351"/>      link
<a name="352"/>   end
<a name="353"/>
<a name="354"/>   #
<a name="355"/>   # Select the given object
<a name="356"/>   #
<a name="357"/>   public select_object(o)
<a name="358"/>      return select_line(find_line(o))
<a name="359"/>   end
<a name="360"/>
<a name="361"/>   #
<a name="362"/>   # De-select the given object
<a name="363"/>   #
<a name="364"/>   public deselect_object(o)
<a name="365"/>      local i
<a name="366"/>      every i := !self.selections do {
<a name="367"/>         if self.contents[i] === o then {
<a name="368"/>            delete(self.selections, i)
<a name="369"/>            invalidate_line(i)
<a name="370"/>            break
<a name="371"/>         }
<a name="372"/>      }
<a name="373"/>      link
<a name="374"/>   end
<a name="375"/>
<a name="376"/>   #
<a name="377"/>   # Set the current selections to the list l, which is a list of objects
<a name="378"/>   # :Parameters :
<a name="379"/>   # :  `l` - The list of objects.
<a name="380"/>   #
<a name="381"/>   public object_set_selections(l)
<a name="382"/>      local i, t, s
<a name="383"/>      s := set()
<a name="384"/>      t := elementset(l)
<a name="385"/>      every i := 1 to *self.contents do {
<a name="386"/>         if member(t, self.contents[i]) then
<a name="387"/>            insert(s, i)
<a name="388"/>      }
<a name="389"/>      return set_selections(s)
<a name="390"/>   end
<a name="391"/>
<a name="392"/>   #
<a name="393"/>   # Succeed iff the index `i` is currently selected.
<a name="394"/>   #
<a name="395"/>   public is_selected(i)
<a name="396"/>      succeed member(selections, need_integer(i))
<a name="397"/>   end
<a name="398"/>
<a name="399"/>   #
<a name="400"/>   # Succeed iff the index `o` is currently selected.
<a name="401"/>   #
<a name="402"/>   public object_is_selected(o)
<a name="403"/>      succeed member(selections, find_line(o))
<a name="404"/>   end
<a name="405"/>
<a name="406"/>   #
<a name="407"/>   # Set the cursor to the given object.  Has no effect if o is not
<a name="408"/>   # in the contents list.
<a name="409"/>   #
<a name="410"/>   public object_set_cursor(o)
<a name="411"/>      return set_cursor(find_line(o))
<a name="412"/>   end
<a name="413"/>
<a name="414"/>   #
<a name="415"/>   # Set the cursor to the given line
<a name="416"/>   #
<a name="417"/>   public set_cursor(line)
<a name="418"/>      line := need_integer(\line)
<a name="419"/>      if line ~=== self.cursor then {
<a name="420"/>         invalidate_line(\self.cursor)
<a name="421"/>         self.cursor := line
<a name="422"/>         constrain_cursor()
<a name="423"/>         invalidate_line(\self.cursor)
<a name="424"/>      }
<a name="425"/>      link
<a name="426"/>   end
<a name="427"/>
<a name="428"/>   #
<a name="429"/>   # Return the contents of the `ScrollArea`
<a name="430"/>   #
<a name="431"/>   public get_contents()
<a name="432"/>      return self.contents
<a name="433"/>   end
<a name="434"/>
<a name="435"/>   #
<a name="436"/>   # Return the given line from the contents list.
<a name="437"/>   #
<a name="438"/>   public get_line(i)
<a name="439"/>      return self.contents[i]
<a name="440"/>   end
<a name="441"/>
<a name="442"/>   #
<a name="443"/>   # Delete lines from content
<a name="444"/>   # :Parameters :
<a name="445"/>   # :  `l` - the list of lines in ascending order.
<a name="446"/>   #
<a name="447"/>   public delete_lines(l)
<a name="448"/>      local i, t1, t2
<a name="449"/>      if *l &gt; 0 then {
<a name="450"/>         t1 := sort(self.selections)
<a name="451"/>         t2 := set()
<a name="452"/>         every i := 1 to *l do {
<a name="453"/>            delete(self.contents, l[i] - i + 1)
<a name="454"/>            while t1[1] &lt; l[i] do
<a name="455"/>               insert(t2, pop(t1) - i + 1)
<a name="456"/>            if t1[1] = l[i] then
<a name="457"/>               pop(t1)
<a name="458"/>         }
<a name="459"/>         # Note that i is not null, since *l &gt; 0
<a name="460"/>         while insert(t2, pop(t1) - i)
<a name="461"/>         self.selections := t2
<a name="462"/>
<a name="463"/>         constrain_cursor()
<a name="464"/>
<a name="465"/>         invalidate_subject_width()
<a name="466"/>         invalidate_line_height()
<a name="467"/>         invalidate_line_count()
<a name="468"/>         compute_and_invalidate()
<a name="469"/>      }
<a name="470"/>      link
<a name="471"/>   end
<a name="472"/>
<a name="473"/>   #
<a name="474"/>   # Set the given lines in the content starting at pos n.  Any elements out
<a name="475"/>   # of the bounds of the current content are ignored.
<a name="476"/>   # :Parameters :
<a name="477"/>   # :  `l` - the lines
<a name="478"/>   # :  `n` - the position
<a name="479"/>   #
<a name="480"/>   public set_lines(l, n)
<a name="481"/>      local i
<a name="482"/>      if *l &gt; 0 then {
<a name="483"/>         every i := 1 to *l do
<a name="484"/>            self.contents[i + n - 1] := l[i]
<a name="485"/>         invalidate_subject_width()
<a name="486"/>         invalidate_line_height()
<a name="487"/>         compute_and_invalidate()
<a name="488"/>      }
<a name="489"/>      link
<a name="490"/>   end
<a name="491"/>
<a name="492"/>   #
<a name="493"/>   # Insert lines into content at pos n
<a name="494"/>   # :Parameters :
<a name="495"/>   # :  `l` - the lines
<a name="496"/>   # :  `n` - the position
<a name="497"/>   #
<a name="498"/>   public insert_lines(l, n)
<a name="499"/>      local i, e, t, p
<a name="500"/>      if *l &gt; 0 then {
<a name="501"/>         p := *self.contents
<a name="502"/>
<a name="503"/>         every i := 1 to *l do
<a name="504"/>            insert(self.contents, i + n - 1, l[i])
<a name="505"/>
<a name="506"/>         t := set()
<a name="507"/>         every e := !self.selections do {
<a name="508"/>            if e &gt;= n then
<a name="509"/>               e +:= *l
<a name="510"/>            insert(t, e)
<a name="511"/>         }
<a name="512"/>         self.selections := t
<a name="513"/>
<a name="514"/>         # If the list was empty, set the cursor.
<a name="515"/>         if p = 0 then
<a name="516"/>            set_cursor(1)
<a name="517"/>         invalidate_subject_width()
<a name="518"/>         invalidate_line_height()
<a name="519"/>         invalidate_line_count()
<a name="520"/>         compute_and_invalidate()
<a name="521"/>      }
<a name="522"/>      link
<a name="523"/>   end
<a name="524"/>
<a name="525"/>   #
<a name="526"/>   # Move the given list of lines to the given position.
<a name="527"/>   # :Parameters :
<a name="528"/>   # :  `l` - the lines in ascending order
<a name="529"/>   # :  `n` - the position
<a name="530"/>   #
<a name="531"/>   public move_lines(l, n)
<a name="532"/>      local t, s, e, n1, i, tc
<a name="533"/>
<a name="534"/>      if *l &gt; 0 then {
<a name="535"/>         # Save the moving lines into a list
<a name="536"/>         t := ipl.pdco.List{ contents[!l] }
<a name="537"/>         # Get the place to insert after we've deleted l.
<a name="538"/>         n1 := n
<a name="539"/>         every e := !l do
<a name="540"/>            if e &lt; n then
<a name="541"/>               n1 -:= 1
<a name="542"/>
<a name="543"/>         # Get the selections we need to add after re-insertion.
<a name="544"/>         s := set()
<a name="545"/>         every i := 1 to *l do {
<a name="546"/>            if member(self.selections, l[i]) then
<a name="547"/>               insert(s, n1 + i - 1)
<a name="548"/>         }
<a name="549"/>
<a name="550"/>         # Delete, re-insert and adjust selections.  Save and restore cursor
<a name="551"/>         # since delete_lines constrains it in the temporarily shortened list.
<a name="552"/>         tc := self.cursor
<a name="553"/>         delete_lines(l)
<a name="554"/>         insert_lines(t, n1)
<a name="555"/>         self.selections ++:= s
<a name="556"/>         set_cursor(tc)
<a name="557"/>      }
<a name="558"/>      link
<a name="559"/>   end
<a name="560"/>
<a name="561"/>   private select_range(from)
<a name="562"/>      if \from then {
<a name="563"/>         if from &gt; cursor then
<a name="564"/>            every insert(selections, cursor to from)
<a name="565"/>         else
<a name="566"/>            every insert(selections, from to cursor)
<a name="567"/>      } else
<a name="568"/>         insert(selections, cursor)
<a name="569"/>   end
<a name="570"/>
<a name="571"/>   private select_cursor()
<a name="572"/>      selections := set(cursor)
<a name="573"/>   end
<a name="574"/>
<a name="575"/>   private toggle_select_cursor()
<a name="576"/>      if member(selections, cursor) then
<a name="577"/>         delete(selections, cursor) 
<a name="578"/>      else
<a name="579"/>         insert(selections, cursor)
<a name="580"/>   end
<a name="581"/>
<a name="582"/>   private move_cursor_on_key(e, line)
<a name="583"/>      local t
<a name="584"/>      t := self.cursor
<a name="585"/>      self.cursor := line
<a name="586"/>      constrain_cursor()
<a name="587"/>      if \cursor &amp; /e.ctrl &amp; \self.selection_on_key_moves_flag &amp; (self.select_mode ~=== Select.NONE) then {
<a name="588"/>         if \e.shift &amp; (self.select_mode === Select.MANY) then
<a name="589"/>            select_range(t)
<a name="590"/>         else
<a name="591"/>            select_cursor()
<a name="592"/>      }
<a name="593"/>      ensure_line_visible(self.cursor)
<a name="594"/>   end
<a name="595"/>
<a name="596"/>   public start_handle(e)
<a name="597"/>      self.old_cursor := self.cursor
<a name="598"/>      self.old_over := self.over
<a name="599"/>      self.old_highlight := self.highlight
<a name="600"/>      self.old_highlight_part := self.highlight_part
<a name="601"/>      self.old_selections := copy(self.selections)
<a name="602"/>   end
<a name="603"/>
<a name="604"/>   public end_handle(e)
<a name="605"/>      local i, cursor_moved, selection_changed
<a name="606"/>      i := get_line_info()
<a name="607"/>      if self.cursor ~=== self.old_cursor then {
<a name="608"/>         invalidate_line(\self.old_cursor, i)
<a name="609"/>         invalidate_line(\self.cursor, i)
<a name="610"/>         cursor_moved := &amp;yes
<a name="611"/>      }
<a name="612"/>      if self.highlight ~=== self.old_highlight then {
<a name="613"/>         invalidate_line(\self.highlight, i)
<a name="614"/>         invalidate_line(\self.old_highlight, i)
<a name="615"/>      } else if self.highlight_part ~=== self.old_highlight_part then {
<a name="616"/>         invalidate_line(\self.highlight, i)
<a name="617"/>      }
<a name="618"/>      if self.over ~=== self.old_over then {
<a name="619"/>         invalidate_line(\self.old_over, i)
<a name="620"/>         invalidate_line(\self.over, i)
<a name="621"/>      }
<a name="622"/>      unless lang.equals(self.old_selections, self.selections) then {
<a name="623"/>         every invalidate_line(!(old_selections -- selections) | !(selections -- old_selections), i)
<a name="624"/>         selection_changed := &amp;yes
<a name="625"/>      }
<a name="626"/>
<a name="627"/>      # Fire events
<a name="628"/>      if \cursor_moved then
<a name="629"/>         fire(Event.CURSOR_MOVED, e)
<a name="630"/>      if \selection_changed then
<a name="631"/>         fire(Event.SELECTION_CHANGED, e)
<a name="632"/>   end
<a name="633"/>
<a name="634"/>   public handle_return(e)
<a name="635"/>      if /self.cursor | (self.select_mode === Select.NONE) then
<a name="636"/>         return
<a name="637"/>      start_handle(e)
<a name="638"/>      if (self.select_mode === Select.MANY) &amp; (\e.shift | \e.ctrl) then
<a name="639"/>         toggle_select_cursor()
<a name="640"/>      else
<a name="641"/>         select_cursor()
<a name="642"/>      end_handle(e)
<a name="643"/>   end
<a name="644"/>
<a name="645"/>   public handle_key_page_up(e)
<a name="646"/>      local c
<a name="647"/>      start_handle(e)
<a name="648"/>      c := if \cursor then
<a name="649"/>         get_page_movement(cursor, -1)
<a name="650"/>      else
<a name="651"/>         *contents
<a name="652"/>      move_cursor_on_key(e, c)
<a name="653"/>      end_handle(e)
<a name="654"/>   end
<a name="655"/>
<a name="656"/>   public handle_key_page_down(e)
<a name="657"/>      local c
<a name="658"/>      start_handle(e)
<a name="659"/>      c := if \cursor then
<a name="660"/>         get_page_movement(cursor, 1)
<a name="661"/>      else
<a name="662"/>         1
<a name="663"/>      move_cursor_on_key(e, c)
<a name="664"/>      end_handle(e)
<a name="665"/>   end
<a name="666"/>
<a name="667"/>   public handle_key_up(e)
<a name="668"/>      local c
<a name="669"/>      start_handle(e)
<a name="670"/>      c := if \cursor then {
<a name="671"/>         if /wrap_on_up_down_flag then
<a name="672"/>            cursor - 1
<a name="673"/>         else
<a name="674"/>            mod1(cursor - 1, *contents)
<a name="675"/>      } else
<a name="676"/>         *contents
<a name="677"/>      move_cursor_on_key(e, c)
<a name="678"/>      end_handle(e)
<a name="679"/>   end
<a name="680"/>
<a name="681"/>   public handle_key_down(e)
<a name="682"/>      local c
<a name="683"/>      start_handle(e)
<a name="684"/>      c := if \cursor then {
<a name="685"/>         if /wrap_on_up_down_flag then
<a name="686"/>            cursor + 1
<a name="687"/>         else
<a name="688"/>            mod1(cursor + 1, *contents)
<a name="689"/>      } else
<a name="690"/>         1
<a name="691"/>      move_cursor_on_key(e, c)
<a name="692"/>      end_handle(e)
<a name="693"/>   end
<a name="694"/>
<a name="695"/>   public handle_key_left(e)
<a name="696"/>      \self.hsb | fail
<a name="697"/>      start_handle(e)
<a name="698"/>      set_area_x(get_area_x() - self.hsb.increment_size)
<a name="699"/>      end_handle(e)
<a name="700"/>   end
<a name="701"/>
<a name="702"/>   public handle_key_right(e)
<a name="703"/>      \self.hsb | fail
<a name="704"/>      start_handle(e)
<a name="705"/>      set_area_x(get_area_x() + self.hsb.increment_size)
<a name="706"/>      end_handle(e)
<a name="707"/>   end
<a name="708"/>
<a name="709"/>   public handle_key_home(e)
<a name="710"/>      start_handle(e)
<a name="711"/>      move_cursor_on_key(e, 1)
<a name="712"/>      end_handle(e)
<a name="713"/>   end
<a name="714"/>
<a name="715"/>   public handle_key_end(e)
<a name="716"/>      start_handle(e)
<a name="717"/>      move_cursor_on_key(e, *self.contents)
<a name="718"/>      end_handle(e)
<a name="719"/>   end
<a name="720"/>
<a name="721"/>   public handle_lpress(e)
<a name="722"/>      local l
<a name="723"/>      # on_a_line indicates whether the current ldrag started over a line.
<a name="724"/>      self.on_a_line := &amp;null
<a name="725"/>      self.prev_cursor := self.cursor
<a name="726"/>      l := get_line_under_pointer(e) | fail
<a name="727"/>      start_handle(e)
<a name="728"/>      self.cursor := l
<a name="729"/>      self.on_a_line := &amp;yes
<a name="730"/>      ensure_line_visible(self.cursor)
<a name="731"/>      end_handle(e)
<a name="732"/>   end
<a name="733"/>
<a name="734"/>   private move_cursor_to_pointer(e)
<a name="735"/>      local l
<a name="736"/>      l := get_line_under_pointer(e) | fail
<a name="737"/>      start_handle(e)
<a name="738"/>      self.cursor := l
<a name="739"/>      ensure_line_visible(self.cursor)
<a name="740"/>      end_handle(e)
<a name="741"/>   end
<a name="742"/>
<a name="743"/>   public handle_rpress(e)
<a name="744"/>      move_cursor_to_pointer(e)
<a name="745"/>   end
<a name="746"/>
<a name="747"/>   public handle_mpress(e)
<a name="748"/>      move_cursor_to_pointer(e)
<a name="749"/>   end
<a name="750"/>
<a name="751"/>   public handle_select_all(e)
<a name="752"/>      self.select_mode === Select.MANY | fail
<a name="753"/>      start_handle(e)
<a name="754"/>      every insert(self.selections, 1 to *self.contents)
<a name="755"/>      end_handle(e)
<a name="756"/>   end
<a name="757"/>
<a name="758"/>   public handle_move(e)
<a name="759"/>      \self.motion_cursor_flag | fail
<a name="760"/>      start_handle(e)
<a name="761"/>      self.cursor := get_nearest_line_to_pointer(e)
<a name="762"/>      ensure_line_visible(self.cursor)
<a name="763"/>      end_handle(e)
<a name="764"/>   end
<a name="765"/>
<a name="766"/>   public handle_in_chain(e)
<a name="767"/>      \show_over_flag | fail
<a name="768"/>      start_handle(e)
<a name="769"/>      self.over := get_line_under_pointer(e) | &amp;null
<a name="770"/>      end_handle(e)
<a name="771"/>   end
<a name="772"/>
<a name="773"/>   public handle_exit(e)
<a name="774"/>      if \self.motion_cursor_flag then {
<a name="775"/>         # We don't move the motion cursor on a drag.  Also, we
<a name="776"/>         # don't change the cursor from null on an exit.
<a name="777"/>         (\cursor &amp; parent_dialog.get_held_count() = 0) | fail
<a name="778"/>         start_handle(e)
<a name="779"/>         self.cursor := get_nearest_line_to_pointer(e)
<a name="780"/>         ensure_line_visible(self.cursor)
<a name="781"/>         end_handle(e)
<a name="782"/>      } else if \show_over_flag then {
<a name="783"/>         start_handle(e)
<a name="784"/>         self.over := &amp;null
<a name="785"/>         end_handle(e)
<a name="786"/>      } 
<a name="787"/>   end
<a name="788"/>
<a name="789"/>   public override on_vsb(e)
<a name="790"/>      self.refresh()
<a name="791"/>      #
<a name="792"/>      # Simulate drag events if appropriate in order to
<a name="793"/>      # keep the cursor in synch.
<a name="794"/>      #
<a name="795"/>      if view.is_held(Mouse.LEFT_PRESS) then
<a name="796"/>         handle_ldrag(e)
<a name="797"/>   end
<a name="798"/>
<a name="799"/>   public handle_ldrag(e)
<a name="800"/>      \self.draggable_cursor_flag | fail
<a name="801"/>
<a name="802"/>      #
<a name="803"/>      # This ensures we don't start scrolling with the ticker until we
<a name="804"/>      # have crossed one line (or started on a line).   Needed for
<a name="805"/>      # DropDown's list so that we don't scroll immediately the button is
<a name="806"/>      # pressed.
<a name="807"/>      #
<a name="808"/>      /self.on_a_line := if get_line_under_pointer(e) then &amp;yes
<a name="809"/>      \self.on_a_line | fail
<a name="810"/>
<a name="811"/>      start_handle(e)
<a name="812"/>      if e.y &lt; self.view.y then {
<a name="813"/>         self.going_up := &amp;yes
<a name="814"/>         check_ticker(self.view.y - e.y)
<a name="815"/>      } else if e.y &gt;= self.view.y + self.view.h then {
<a name="816"/>         self.going_up := &amp;null
<a name="817"/>         check_ticker(e.y - (self.view.y + self.view.h))
<a name="818"/>      } else {
<a name="819"/>         self.cursor := get_nearest_line_to_pointer(e)
<a name="820"/>         ensure_line_visible(self.cursor)
<a name="821"/>         scroll_ticker.stop()
<a name="822"/>      }
<a name="823"/>      end_handle(e)
<a name="824"/>   end
<a name="825"/>
<a name="826"/>   private check_ticker(d)
<a name="827"/>      scroll_ticker_interval := Gui.style.distance2ticker_rate(d)
<a name="828"/>      scroll_ticker.change_time(scroll_ticker_interval)
<a name="829"/>      # Start it (if it isn't already running)
<a name="830"/>      scroll_ticker.start()
<a name="831"/>   end
<a name="832"/>
<a name="833"/>   private scroll_tick()
<a name="834"/>      local i
<a name="835"/>      repeat {
<a name="836"/>         if i := get_line_info() then {
<a name="837"/>            start_handle()
<a name="838"/>            if \self.highlight then {
<a name="839"/>               if \going_up then {
<a name="840"/>                  self.highlight := i.first_whole - 1
<a name="841"/>                  self.highlight &lt;:= 1
<a name="842"/>                  goto_first(self.highlight)
<a name="843"/>                  highlight_part := if get_dnd_mode() === MIDDLE_ONLY then MIDDLE else TOP
<a name="844"/>               } else {
<a name="845"/>                  self.highlight := i.last_whole + 1
<a name="846"/>                  self.highlight &gt;:= *self.contents 
<a name="847"/>                  goto_last(self.highlight)
<a name="848"/>                  highlight_part := if get_dnd_mode() === MIDDLE_ONLY then MIDDLE else BOTTOM
<a name="849"/>               }
<a name="850"/>               parent_dialog.update_drop()
<a name="851"/>            } else {
<a name="852"/>               if \going_up then {
<a name="853"/>                  self.cursor := i.first_whole - 1
<a name="854"/>                  self.cursor &lt;:= 1
<a name="855"/>                  goto_first(self.cursor)
<a name="856"/>               } else {
<a name="857"/>                  self.cursor := i.last_whole + 1
<a name="858"/>                  self.cursor &gt;:= *self.contents 
<a name="859"/>                  goto_last(self.cursor)
<a name="860"/>               }
<a name="861"/>            }
<a name="862"/>            end_handle()
<a name="863"/>         }
<a name="864"/>         scroll_ticker.sleep(scroll_ticker_interval)
<a name="865"/>      }
<a name="866"/>   end
<a name="867"/>
<a name="868"/>   public handle_lrelease(e)
<a name="869"/>      start_handle(e)
<a name="870"/>      scroll_ticker.stop()
<a name="871"/>      if (self.select_mode ~=== Select.NONE) &amp; (get_line_under_pointer(e) = self.cursor) then {
<a name="872"/>         if (self.select_mode === Select.MANY) &amp; (\e.shift | \e.ctrl) then {
<a name="873"/>            if \e.ctrl then
<a name="874"/>               toggle_select_cursor()
<a name="875"/>            else {
<a name="876"/>               \prev_cursor &gt;:= *contents
<a name="877"/>               select_range(prev_cursor)
<a name="878"/>            }
<a name="879"/>         } else
<a name="880"/>            select_cursor()
<a name="881"/>      }
<a name="882"/>      ensure_line_visible(\self.cursor)
<a name="883"/>      end_handle(e)
<a name="884"/>   end
<a name="885"/>
<a name="886"/>   public handle_interrupted()
<a name="887"/>      scroll_ticker.stop()
<a name="888"/>   end
<a name="889"/>
<a name="890"/>   public handle_key_escape(e)
<a name="891"/>      start_handle(e)
<a name="892"/>      self.selections := set()
<a name="893"/>      end_handle(e)
<a name="894"/>   end
<a name="895"/>
<a name="896"/>   public handle_key(e)
<a name="897"/>      case e.code of {
<a name="898"/>         Key.HOME : handle_key_home(e)
<a name="899"/>         Key.END : handle_key_end(e)
<a name="900"/>         Key.PGUP : handle_key_page_up(e)
<a name="901"/>         Key.PGDN : handle_key_page_down(e)
<a name="902"/>         Key.UP : handle_key_up(e)
<a name="903"/>         Key.DOWN : handle_key_down(e)
<a name="904"/>         Key.LEFT : handle_key_left(e)
<a name="905"/>         Key.RIGHT : handle_key_right(e)
<a name="906"/>         "\r" | "\l": handle_return(e)
<a name="907"/>         "\e" : handle_key_escape(e)
<a name="908"/>         "\^a" : handle_select_all(e)
<a name="909"/>      }
<a name="910"/>   end
<a name="911"/>
<a name="912"/>   public override keeps(e)
<a name="913"/>      succeed member(Key.CURSOR, e.code)
<a name="914"/>   end
<a name="915"/>
<a name="916"/>   public object_get_gesture_selections()
<a name="917"/>      \self.cursor | fail
<a name="918"/>      return if member(self.selections, self.cursor) then
<a name="919"/>         object_get_selections()
<a name="920"/>      else
<a name="921"/>         [self.contents[self.cursor]]
<a name="922"/>   end
<a name="923"/>
<a name="924"/>   public get_gesture_selections()
<a name="925"/>      \self.cursor | fail
<a name="926"/>      return if member(self.selections, self.cursor) then
<a name="927"/>         get_selections()
<a name="928"/>      else
<a name="929"/>         [self.cursor]
<a name="930"/>   end
<a name="931"/>
<a name="932"/>   public override draw()
<a name="933"/>      local xp, yp, i, info, h, lh, sel, cur, r, hi, ov
<a name="934"/>
<a name="935"/>      r := view.get_cbwin_clip()
<a name="936"/>
<a name="937"/>      info := get_line_info(r) | fail
<a name="938"/>      h := get_line_height()
<a name="939"/>      yp := r.y - info.offset
<a name="940"/>      xp := get_subject_x()
<a name="941"/>
<a name="942"/>      #
<a name="943"/>      # Write the lines
<a name="944"/>      #
<a name="945"/>      every i := info.first to info.last do {
<a name="946"/>         hi := if i = \self.highlight then
<a name="947"/>            self.highlight_part
<a name="948"/>         else
<a name="949"/>            &amp;null
<a name="950"/>         cur := if i = \self.cursor then {
<a name="951"/>            # cf should_draw_focus() in Component.
<a name="952"/>            if (\always_show_focus_cursor_flag | has_focus())\1  &amp; is_unshaded() &amp;
<a name="953"/>                   (\parent_dialog).is_unblocked() &amp; (\parent_dialog).is_focus_in() then
<a name="954"/>               "f"
<a name="955"/>            else
<a name="956"/>               "d"
<a name="957"/>         } else
<a name="958"/>            &amp;null
<a name="959"/>         
<a name="960"/>         sel := if member(self.selections, i) then &amp;yes else &amp;no
<a name="961"/>         ov := if i = \self.over then &amp;yes else &amp;no
<a name="962"/>
<a name="963"/>         lh := integer(h) | h[i]
<a name="964"/>         
<a name="965"/>         # Draw the line
<a name="966"/>         draw_line(xp, yp, lh, i, sel, cur, hi, ov)
<a name="967"/>         yp +:= lh
<a name="968"/>      }
<a name="969"/>   end
<a name="970"/>
<a name="971"/>   public override focus_changed(e) 
<a name="972"/>      invalidate_line(\self.cursor)
<a name="973"/>   end
<a name="974"/>
<a name="975"/>   #
<a name="976"/>   # This method is overridden by the subclass to draw the given 
<a name="977"/>   # line at the given position, as well as the selection drawing.
<a name="978"/>   # Alternatively, the simpler method `draw_line_data()` below
<a name="979"/>   # can be overridden - this just has to draw the data, and leaves the selection drawing to
<a name="980"/>   # be done by this class.
<a name="981"/>   #
<a name="982"/>   # :Parameters :
<a name="983"/>   # :  `xp` - The x position it should be drawn at
<a name="984"/>   # :  `yp` - The y position it should be drawn at
<a name="985"/>   # :  `lh` - The line height allowed for this line
<a name="986"/>   # :  `i` - The line number to draw
<a name="987"/>   # :  `sel` - If non-null, the line must be drawn as selected
<a name="988"/>   # :  `cur` - Indicates the cursor for this row; &amp;null indicates none, "f" indicates 
<a name="989"/>   #            focus cursor "d" indicates disabled cursor.
<a name="990"/>   # :  `hi` - Indicates the dnd highlight for this row; &amp;null indicates none, "t" indicates top
<a name="991"/>   #            highlight, "m" indicates middle highlight, "b" indicates bottom highlight.
<a name="992"/>   # :  `ov` - If non-null, the line must be drawn as showing the cursor over the line
<a name="993"/>   #
<a name="994"/>   public override draw_line(xp, yp, lh, i, sel, cur, hi, ov)
<a name="995"/>      draw_line_data(xp, yp, lh, i)
<a name="996"/>      draw_line_sel_cur(self.view.x, yp, self.view.w, lh, sel, cur, hi, ov)
<a name="997"/>   end
<a name="998"/>
<a name="999"/>   #
<a name="1000"/>   # A helper method to draw the selection and cursor in the given rectangle.
<a name="1001"/>   #
<a name="1002"/>   public draw_line_sel_cur(x, y, w, h, sel, cur, hi, ov)
<a name="1003"/>      if \sel then
<a name="1004"/>         Gui.style.fill_selection_rectangle(view.cbwin, x, y, w, h)
<a name="1005"/>      case \cur of {
<a name="1006"/>         "f": Gui.style.draw_focus_rectangle(view.cbwin, x, y, w, h)
<a name="1007"/>         "d": Gui.style.draw_dashed_rectangle(view.cbwin, x, y, w, h)
<a name="1008"/>      }
<a name="1009"/>      case \hi of {
<a name="1010"/>         "t": Gui.style.fill_highlight_rectangle(view.cbwin, x, y, w, INTER_LINE_WIDTH)
<a name="1011"/>         "b": Gui.style.fill_highlight_rectangle(view.cbwin, x, y + h - INTER_LINE_WIDTH, w, INTER_LINE_WIDTH)
<a name="1012"/>         "m": Gui.style.draw_highlight_rectangle(view.cbwin, x, y, w, h)
<a name="1013"/>      }
<a name="1014"/>      if \ov then
<a name="1015"/>         Gui.style.fill_over_rectangle(view.cbwin, x, y, w, h)
<a name="1016"/>   end
<a name="1017"/>
<a name="1018"/>   public optional draw_line_data(xp, yp, lh, i)
<a name="1019"/>
<a name="1020"/>   public override can_drag(ev)
<a name="1021"/>      if view.is_held(Mouse.LEFT_PRESS) &amp; /self.draggable_cursor_flag &amp; \self.on_a_line then
<a name="1022"/>         return self.object_get_gesture_selections()
<a name="1023"/>   end
<a name="1024"/>
<a name="1025"/>   #
<a name="1026"/>   # Given the highlight is set, return the dnd_mode for that line.
<a name="1027"/>   # By default just returns `dnd_mode`, but may be overridden to
<a name="1028"/>   # return different modes for different rows (eg in a Tree, a folder
<a name="1029"/>   # may allow `MIDDLE_AND_EDGES`, but a leaf `EDGES_ONLY`.
<a name="1030"/>   #
<a name="1031"/>   protected get_dnd_mode()
<a name="1032"/>      return dnd_mode
<a name="1033"/>   end
<a name="1034"/>
<a name="1035"/>   private calc_highlight_part(e)
<a name="1036"/>      local a, b
<a name="1037"/>      highlight_part := case get_dnd_mode() of {
<a name="1038"/>         MIDDLE_ONLY:
<a name="1039"/>            MIDDLE
<a name="1040"/>         EDGES_ONLY: {
<a name="1041"/>            a := e.y - get_subject_y() - get_cum_line_height(highlight)
<a name="1042"/>            b := get_height_for_line(highlight)
<a name="1043"/>            if a &lt; b / 2 then
<a name="1044"/>               TOP
<a name="1045"/>            else
<a name="1046"/>               BOTTOM
<a name="1047"/>         }
<a name="1048"/>         MIDDLE_AND_EDGES: {
<a name="1049"/>            a := e.y - get_subject_y() - get_cum_line_height(highlight)
<a name="1050"/>            b := get_height_for_line(highlight)
<a name="1051"/>            if a &lt; b / 4 then
<a name="1052"/>               TOP
<a name="1053"/>            else if a &gt; b - b / 4 then
<a name="1054"/>               BOTTOM
<a name="1055"/>            else
<a name="1056"/>               MIDDLE
<a name="1057"/>         }
<a name="1058"/>         default:
<a name="1059"/>            runerr("Invalid value for dnd_mode", dnd_mode)
<a name="1060"/>      }
<a name="1061"/>   end
<a name="1062"/>
<a name="1063"/>   public override drag_event(drag, e)
<a name="1064"/>      local hold
<a name="1065"/>      start_handle(e)
<a name="1066"/>      # Don't show the over indication during a drag
<a name="1067"/>      over := &amp;null
<a name="1068"/>      # Where are we in relation to the view?
<a name="1069"/>      #
<a name="1070"/>      if self.view.x &lt;= e.x &lt; self.view.x + self.view.w then {
<a name="1071"/>         if e.y &lt; self.view.y then {
<a name="1072"/>            # Above the view, start going up if we have a vsb and a highlight.
<a name="1073"/>            #
<a name="1074"/>            if \vsb &amp; \highlight then {
<a name="1075"/>               self.going_up := &amp;yes
<a name="1076"/>               check_ticker(self.view.y - e.y)
<a name="1077"/>               hold := &amp;yes
<a name="1078"/>            }
<a name="1079"/>         } else if e.y &gt;= self.view.y + self.view.h then {
<a name="1080"/>            # Below the view, start going down if we have a vsb and a highlight.
<a name="1081"/>            #
<a name="1082"/>            if \vsb &amp; \highlight then {
<a name="1083"/>               self.going_up := &amp;null
<a name="1084"/>               check_ticker(e.y - (self.view.y + self.view.h))
<a name="1085"/>               hold := &amp;yes
<a name="1086"/>            }
<a name="1087"/>         } else {
<a name="1088"/>            # In the view
<a name="1089"/>            if self.highlight := get_nearest_line_to_pointer(e) then {
<a name="1090"/>               calc_highlight_part(e)
<a name="1091"/>               ensure_line_visible(self.highlight)
<a name="1092"/>            } else
<a name="1093"/>               self.highlight := self.highlight_part := &amp;null
<a name="1094"/>            hold := &amp;yes
<a name="1095"/>            scroll_ticker.stop()
<a name="1096"/>         }
<a name="1097"/>      } else {
<a name="1098"/>         # We've gone to the left or right of the view, so stop being drag holder.
<a name="1099"/>         scroll_ticker.stop()
<a name="1100"/>      }
<a name="1101"/>
<a name="1102"/>      # If not holding, then we clear the highlight
<a name="1103"/>      if /hold then
<a name="1104"/>         self.highlight := self.highlight_part := &amp;null
<a name="1105"/>
<a name="1106"/>      end_handle(e)
<a name="1107"/>      return \hold
<a name="1108"/>   end
<a name="1109"/>
<a name="1110"/>   public override can_drop(drag, e)
<a name="1111"/>      return self.object_get_highlight() | &amp;null
<a name="1112"/>   end
<a name="1113"/>
<a name="1114"/>   public override drag_reset(e)
<a name="1115"/>      start_handle(e)
<a name="1116"/>      self.highlight := self.highlight_part := &amp;null
<a name="1117"/>      scroll_ticker.stop()
<a name="1118"/>      end_handle(e)
<a name="1119"/>   end
<a name="1120"/>
<a name="1121"/>   public override finally()
<a name="1122"/>      scroll_ticker.stop()
<a name="1123"/>      LineBasedScrollArea.finally()
<a name="1124"/>   end
<a name="1125"/>
<a name="1126"/>   public override new()
<a name="1127"/>      LineBasedScrollArea.new()
<a name="1128"/>      scroll_ticker := Dispatcher.new_task{scroll_tick()}
<a name="1129"/>      self.set_accepts_focus(&amp;yes)
<a name="1130"/>      self.select_mode := Select.NONE
<a name="1131"/>      self.dnd_mode := MIDDLE_ONLY
<a name="1132"/>      self.contents := []
<a name="1133"/>      self.selections := set()
<a name="1134"/>      self.selection_on_key_moves_flag := &amp;yes
<a name="1135"/>      view.
<a name="1136"/>         connect(self.handle_lpress, Event.MOUSE_LEFT_PRESS).
<a name="1137"/>         connect(self.handle_rpress, Event.MOUSE_RIGHT_PRESS).
<a name="1138"/>         connect(self.handle_mpress, Event.MOUSE_MIDDLE_PRESS).
<a name="1139"/>         connect(self.handle_ldrag, Event.MOUSE_LEFT_DRAG).
<a name="1140"/>         connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE).
<a name="1141"/>         connect(self.handle_move, Event.MOUSE_MOVEMENT).
<a name="1142"/>         connect(self.handle_in_chain, Event.IN_POINT_CHAIN).
<a name="1143"/>         connect(self.handle_exit, Event.MOUSE_EXIT)
<a name="1144"/>      connect(handle_key, Event.KEY_PRESS)
<a name="1145"/>      connect(handle_interrupted, Event.INTERRUPTED)
<a name="1146"/>      return
<a name="1147"/>   end
<a name="1148"/>end
</pre></body></html>
