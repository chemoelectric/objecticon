package ipl.browser

import 
   gui, 
   lang, 
   mail,
   http,
   util,
   io,
   net,
   xml,
   posix,
   graphics(Window,Key,Selection,Mouse),
   xdg,
$ifndef _PLAN9
   ipl.childwait,
$endif
   ipl.lists,
   ipl.pdco,
   ipl.io,
   ipl.sort,
   ipl.strings,
   ipl.scan,
   ipl.timegui,
   ipl.colorgui,
   ipl.filegui,
   ipl.numbers,
   ipl.imagedetect,
   ipl.charset,
   ipl.dataurl,
   ipl.functional

$load BROKEN_LINK "rpp.BROKEN_LINK_24.gif"

class Req()
   public const
      client, url, referer, callback, kind, form_data, on_status

   public new(client, url, referer, callback, kind, form_data, on_status)
      self.client := client
      self.url := url
      self.referer := referer
      self.callback := callback
      self.kind := kind
      self.form_data := form_data
      self.on_status := on_status
      return
   end
end

class Resp()
   public const
      req, err, url, data, fname, content_type, content_disposition, data_file

   public new(req, err, url, data, fname, content_type, content_disposition, data_file)
      self.req := req
      self.err := err
      self.url := url
      self.data := data
      self.fname := fname
      self.content_type := content_type
      self.content_disposition := content_disposition
      self.data_file := data_file
      return
   end
end

class StaticData()
   public const
      data, fname, content_type, content_disposition

   public new(data, fname, content_type, content_disposition)
      self.data := data
      self.fname := fname
      self.content_type := content_type
      self.content_disposition := content_disposition
      return
   end
end

record CacheControl(expiry, last_modified, etag)

abstract class CacheEntry()
   public const
      url
   protected readable
      expiry

   public set_expiry(exp)
      self.expiry := exp
      return self
   end

   public hasnt_expired(now)
      /now := Time.get_system_seconds()
      if /expiry | (expiry > now) then
         return
   end

   public abstract is_valid(now)
end

class CacheAlias(CacheEntry)
   public const
      dest

   public is_valid(now)
      return hasnt_expired(now)
   end

   public new(url, expiry, dest)
      self.url := url
      self.expiry := expiry
      self.dest := dest
      return
   end
end

class CacheData(CacheEntry, StaticData)
   public const
      last_modified, etag

   public is_valid(now)
      return hasnt_expired(now) | may_revalidate()
   end

   public may_revalidate()
      if \ (last_modified | etag) then
         return
   end

   public new(url, expiry, data, fname, content_type, content_disposition, last_modified, etag)
      self.url := url
      self.data := data
      self.fname := fname
      self.content_type := content_type
      self.content_disposition := content_disposition
      self.expiry := expiry
      self.last_modified := last_modified
      self.etag := etag
      return
   end
end

class HttpRequestHelperImpl(HttpRequestHelper)
   public const
      worker
   private readable
      cache_entry

   public get_authentication(httpc, dom, realm)
      return worker.pool.owner.get_authentication(httpc, dom, realm)
   end

   public modify_redirect(httpc, hreq, hresp)
      local ce
      #write("modify redirect? ", hreq.url.str())
      # Just in case we have made an if-modified request that's been
      # answered with a redirect, we don't want the headers to go
      # forward in the request.
      cache_entry := &null
      hreq.
         unset_header("if-modified-since").
         unset_header("if-none-match")

      # Never use the cache on a refresh
      if worker.req.kind === Worker.REFRESH then
         fail
      # .. or on anything other than a GET
      (hreq.method == "GET") | fail

      ce := worker.pool.cache.get(hreq.url) | fail
      if ce.hasnt_expired() then {
         # The cache can be used to satisfy the request; use a custom
         # status code so the client can identify it.  It also avoids
         # the possibility of muddling things up if a redirection
         # leads to a genuine http error (eg circular redirection).
         #
         hresp.set_status("HTTP/1.1 999 Satisfied By Cache")
         cache_entry := ce
         return
      } else {
         # The cache can be used to satisfy the request, but with
         # validation, so setup the headers.
         cache_entry := ce
         # At least one of these should succeed
         hreq.set_header("if-modified-since", \ce.last_modified)
         hreq.set_header("if-none-match", \ce.etag)
      }
   end

   public get_cache_entry()
      return .\self.cache_entry
   end

   public new(worker, ce)
      self.worker := worker
      self.cache_entry := ce
      return
   end
end

class Cache()
   private t, size, id

   public set_size(x)
      self.size := x
      return self
   end

   public tidy()
      local now, ce, total
      now := Time.get_system_seconds()
      total := 0
      every ce := !t do {
         if ce.is_valid(now) then {
            case classof(ce) of {
               CacheData: total +:= *ce.data
               CacheAlias: member(t, ce.dest.str()) | delete(t, ce.url.str())
            }
         } else
            delete(t, ce.url.str())
      }
      while *t > 0 & total > size do {
         ce := ?t
         delete(t, ce.url.str())
         if is(ce, CacheData) then
            total -:= *ce.data
      }
      return self
   end

   public get(url)
      local ce
      every 1 to 2 do {
         ce := member(t, url.str()) | fail
         ce.is_valid() | fail
         if is(ce, CacheData) then
            return ce
         url := ce.dest
      }
   end

   public clear()
      default.clear(t)
      return self
   end

   public update_expiry(url, exp)
      local ce
      ce := member(t, url.str()) | fail
      ce.set_expiry(exp)
      return self
   end

   public add_data(url, expiry, data, fname, content_type, content_disposition, last_modified, etag)
      insert(t, url.str(), CacheData(url, expiry, data, fname, content_type, content_disposition, last_modified, etag))
      return self
   end

   public add_alias(url, expiry, dest)
      insert(t, url.str(), CacheAlias(url, expiry, dest))
      return self
   end

   public create_url(expiry, data, fname, content_type, content_disposition)
      local url
      /expiry := Time.get_system_seconds() + 60
      url := URL(u"cache:" || (id +:= 1))
      add_data(url, expiry, data, fname, content_type, content_disposition)
      return url
   end

   private static format_expiry(v)
      if /v then
         return "never"
      v -:= Time.get_system_seconds()
      if v < 0 then
         fail
      if v < 300 then
         return v || "&nbsp;secs"
      v /:= 60
      if v < 120 then
         return v || "&nbsp;mins"
      v /:= 60
      if v <= 48 then
         return v || "&nbsp;hours"
      v /:= 24
      if v < 365 * 2 then
         return v || "&nbsp;days"
      v /:= 365
      return v || "&nbsp;years"
   end

   public get_status()
      local s1, s2, ce, n, sz, exp, ct, total
      s1 := Browser.TABLE_TAG ||
         "<tr><th align=left>Filename</th><th align=right>Size&nbsp;</th><th>Expiry</th><th align=left>Content&nbsp;type</th><th align=left>URL</th></tr>"
      s2 := Browser.TABLE_TAG ||
         "<tr><th align=left>Dest</th><th>Expiry</th><th align=left>URL</th></tr>"
      total := 0
      every ce := !t do {
         case classof(ce) of {
            CacheData: {
               exp := format_expiry(ce.expiry) | (if ce.may_revalidate() then "revalidate" else "expired")
               n := Browser.limit_text(\ce.fname, scale(200)) | "-"
               sz := Format.numeric_to_string(*ce.data, 0, ',')
               ct := (\ce.content_type).to_rfc2616() | "-"
               s1 ||:= "<tr><td>" || Browser.to_content(n) || "</td><td align=right>" || sz || "&nbsp;</td><td>" || exp ||
                  "</td><td>" || Browser.to_content(ct) || "</td>" || Browser.mk_anchor_cell(ce.url) || "</tr>" 
               total +:= *ce.data
            }
            CacheAlias: {
               exp := format_expiry(ce.expiry) | "expired"
               s2 ||:= "<tr>" || Browser.mk_anchor_cell(ce.dest) || "<td>" || exp || "</td>" || Browser.mk_anchor_cell(ce.url) || "</tr>" 
            }
         }
      }
      s1 ||:= "</table>"
      s2 ||:= "</table>"

      return "<html><title>Cache status</title>" || s1 || "<p>" || s2 || "<p>" ||
            "Usage " || Format.numeric_to_string(total, 0, ',') || " / " || 
            Format.numeric_to_string(size, 0, ',') || " (" || integer((total * 100) / size) || "%)" ||
            "</html>"
   end

   public new(size)
      /size := 4 * 1024*1024
      t := table()
      self.size := size
      id := 0
      return
   end
end

abstract class SubWorker()
   public abstract cancel()
   public abstract get_read()
   public abstract get_length()
   public abstract get_data(worker)
end

class ProgSubWorker(SubWorker)
   private 
      data

   public cancel() end
   public get_length() end

   public get_read()
      return data.tell() - 1
   end

   public get_data(worker)
      local ts, f, d, ps
      if (\worker.req.referer).scheme == (u"http" | u"https") then
         return error("Can't run a prog from an http page")
      f := worker.req.url.get_decoded_path()
$ifdef _PLAN9
      d := use {
         ts := TaskStream(NonBlockStream(ps := ProgInputStream("/bin/rc", ["-c", f]),, 1048576), worker.task),
         StaticData(read_all(ts), "")     # Return StaticData in order to set a blank filename.
      } | fail
$else
      d := use {
         ts := TaskStream(ps := ProgInputStream("/bin/sh", ["-c", f]), worker.task),
         StaticData(read_all(ts), "")     # Return StaticData in order to set a blank filename.
      } | fail
$endif
      return if ps.get_exit_info().succeeded() then
         d
      else
         error("Program failed: " || &why)
   end

   private read_all(ts)
      return use {
         data := RamStream(),
         ts.copy_to(data) & data.str()
      }
   end
end

class FileSubWorker(SubWorker)
   private 
      data

   public cancel() end
   public get_length() end

   public get_read()
      return data.tell() - 1
   end

   private static grname(gid)
      return System.getgr(gid).name | gid
   end

   private static uname(uid)
      return System.getpw(uid).name | uid
   end

   public get_data(worker)
      local f, g, e, l, t, path, rs, now, tf, gcache, ucache
$ifndef _MS_WIN32
      local ts
$endif

      # This will fail if, on Unix (but not Windows), the file has a
      # non-local host.
      #
      f := Files.url_to_file(worker.req.url) | fail

      if Files.is_directory(f) then {
         l := qsort(Files.ucs_list(f), Files.name_cmp) | fail
         now := Time.get_system_seconds()
         ucache := memoize1(uname)
         gcache := memoize1(grname)
         return use {
            rs := RamStream(),
            {
               rs.out("<html><title>Directory " || f || "</title>" || Browser.TABLE_TAG)
               path := FilePath(f)
               every e := !l do {
                  t := e.lstat
                  tf := if now - t.mtime > 180 * 86400 then
                     Time(t.mtime + Time.SYSTEM_BASE_OFFSET).format("NNN'&nbsp;'dd'&nbsp;&nbsp;'yyyy")
                  else
                     Time(t.mtime + Time.SYSTEM_BASE_OFFSET).format("NNN'&nbsp;'dd'&nbsp;'HH:mm")
                  g := path.child(e.name).canonical().to_url()
                  rs.out("<tr><td>" || t.mode_str || "&nbsp;</td><td>" || ucache(t.uid) || "&nbsp;</td><td>" || gcache(t.gid) ||
                         "&nbsp;</td><td align=right>" || Format.numeric_to_string(t.size, 0, ',') || "&nbsp;</td><td>" || string(tf) || "&nbsp;</td>" ||
                         "<td nowrap><a href=\"" || g || "\">" || 
                                 Browser.to_content(e.name) || "</a></td></tr>\n")
               }
               rs.out("</table></html>")
               rs.str()
            }
         }
      } else {
$ifdef _MS_WIN32
         # Can't poll a file under win32.
         return Files.file_to_string(f)
$else
         return use {
$ifdef _PLAN9
            ts := TaskStream(NonBlockStream(FileStream(f),, 1048576), worker.task),
$else
            ts := TaskStream(FileStream(f), worker.task),
$endif
            read_all(ts)
         }
$endif
      }
   end

   private read_all(ts)
      return use {
         data := RamStream(),
         ts.copy_to(data) & data.str()
      }
   end
end

class HttpSubWorker(SubWorker)
   private 
      httpc, tmp_file

   public cancel()
      httpc.abort()
      rm_tmp()
   end

   private rm_tmp()
      if \tmp_file then {
         save_why{Files.remove(tmp_file)}
         tmp_file := &null
      }
   end

   public get_length()
      return httpc.get_length()
   end

   public get_read()
      return httpc.get_read()
   end

   private static get_control(hres)
      local s, t, now, exp, lm, etag, ma
      now := Time.get_system_seconds()
      if t := HttpClient.parse_generic_header(hres.get_first_header("Cache-Control")) then {
         ma := integer(member(t, "max-age"))
         lm := hres.get_first_header("Last-modified")
         etag := hres.get_first_header("Etag")
         exp := now + \ma
         if /exp &
            s := hres.get_first_header("Expires") then {
               exp := Time.parse(s, "E, d MMM yyyy hh:mm:ss z").get_unix_seconds() | fail
            }
         if \ (lm | etag) then
            return CacheControl(exp, lm, etag)
         if member(t, "no-cache") then
            fail
         if \ma then
            return CacheControl(now + (0 < ma))
      }
      if s := hres.get_first_header("Expires") then {
         exp := Time.parse(s, "E, d MMM yyyy hh:mm:ss z").get_unix_seconds() | fail
         return CacheControl(now < exp)
      }
      return CacheControl()
   end

   private static get_expiry(hres)
      return \get_control(hres).expiry
   end

   # Copy the fragment part of url1 to url2, unless url2 has its own fragment.
   # See s4.1 at http://www.w3.org/TR/cuap#uri
   #
   private static adjust_fragment(url1, url2)
      local f
      if f := url1.get_fragment() &
         not url2.get_fragment() then
         url2 := clone(url2).set_fragment(f)
      return url2
   end

   private static update_aliases(pool, hres, url)
      local exp
      repeat {
         case hres.get_status_code() of {
            # Moved permanently, so cache permanently
            301: pool.cache.add_alias(hres.url,, url)
            # Redirect, cache only if we had an expiry
            302: if exp := get_expiry(hres) then 
               pool.cache.add_alias(hres.url, exp, url)
         }
         hres := hres.get_previous_response() | break
      }
   end

   private static update_cache_with_entry(pool, hres, ce)
      local exp
      if hres.get_status_code() = 304 then {
         if exp := get_expiry(hres) then
            ce.set_expiry(exp)
         update_aliases(pool, hres.get_previous_response(), ce.url)
      } else
         update_aliases(pool, hres, ce.url)
   end

   private static update_cache_with_data(pool, hres, data, fname, ct, cd)
      local ctrl
      ctrl := get_control(hres) | fail
      pool.cache.add_data(hres.url, ctrl.expiry, data, fname, ct, cd, ctrl.last_modified, ctrl.etag)
      update_aliases(pool, hres.get_previous_response(), hres.url)
   end

   public get_data(worker)
      local req, s, data, hreq, hres, fname, ct, cd, ce, sc, req_url_no_frag, helper
      httpc := worker.httpc
      req := worker.req
      # The request URL without the fragment
      req_url_no_frag := clone(req.url).set_fragment()

      if req.kind ~=== Worker.REFRESH & /req.form_data then
         ce := worker.pool.cache.get(req_url_no_frag)

      return if (\ce).hasnt_expired() then {
         Resp(req,, adjust_fragment(req.url, ce.url), ce.data, ce.fname, ce.content_type, ce.content_disposition)
      } else {
         helper := HttpRequestHelperImpl(worker, ce)
         hreq := HttpRequest().
            set_helper(helper).
            set_header("accept-charset", "UTF-8, ISO-8859-1")
         if (\req.referer).scheme == (u"http" | u"https") then
            hreq.set_referer(req.referer)

         if req.kind === Worker.DOWNLOAD then {
            tmp_file := Files.make_temp_filename("http_oibrowser.", ".bin") | stop("Couldn't create temp file: ", &why)
            use {
               s := BufferStream(FileStream(tmp_file, 
                                            ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT))).
                  set_buff_size(8192),
               {
                  hreq.set_output_stream(s)
                  if /ce then 
                     hreq.set_url(req_url_no_frag)
                  else {
                     hreq.set_url(ce.url)
                     # At least one of these should succeed
                     hreq.set_header("if-modified-since", \ce.last_modified)
                     hreq.set_header("if-none-match", \ce.etag)
                  }
                  if hres := httpc.retrieve(hreq) then {
                     fname := hres.get_filename()
                     ct := ContentType.parse_rfc2616(hres.get_first_header("Content-Type"))
                     cd := ContentDisposition.parse_rfc2616(hres.get_first_header("Content-Disposition"))
                     Resp(req,, adjust_fragment(req.url, hres.url),, fname, ct, cd, tmp_file)
                  } else {
                     rm_tmp()
                     if httpc.get_http_error() & 
                        hres := httpc.get_response() &
                        sc := hres.get_status_code() &
                        ce := helper.get_cache_entry() &
                        sc = (304 | 999) then 
                     {
                        # Redirect or 304 not modified with a cache entry, so return
                        # the cached data.
                        update_cache_with_entry(worker.pool, hres, ce)
                        Resp(req,, adjust_fragment(req.url, ce.url), ce.data, ce.fname, ce.content_type, ce.content_disposition)
                     } else
                        Resp(req, &why, req.url)
                  }
               }
            }
         } else use {
            s := RamStream(),
            {
               hreq.set_output_stream(s)
               if /ce then 
                  hreq.set_url(req_url_no_frag)
               else {
                  hreq.set_url(ce.url)
                  # At least one of these should succeed
                  hreq.set_header("if-modified-since", \ce.last_modified)
                  hreq.set_header("if-none-match", \ce.etag)
               }
               if \req.form_data then {
                  if is(req.form_data, Message) then
                     hreq.set_multipart_form_data(req.form_data)
                  else
                     hreq.set_html_form_data(req.form_data)
               }

               if hres := httpc.retrieve(hreq) then {
                  data := s.str()
                  fname := hres.get_filename()
                  ct := ContentType.parse_rfc2616(hres.get_first_header("Content-Type"))
                  cd := ContentDisposition.parse_rfc2616(hres.get_first_header("Content-Disposition"))
                  # Check whether to cache any data, including redirections.  POST requests are never cached.
                  if hreq.method == "GET" then
                     update_cache_with_data(worker.pool, hres, data, fname, ct, cd)
                  Resp(req,, adjust_fragment(req.url, hres.url), data, fname, ct, cd)
               } else {
                  if httpc.get_http_error() & 
                     hres := httpc.get_response() &
                     sc := hres.get_status_code() then 
                  {
                     if ce := helper.get_cache_entry() & 
                        sc = (304 | 999) then 
                     {
                        # Redirect or 304 not modified with a cache entry, so return
                        # the cached data.
                        update_cache_with_entry(worker.pool, hres, ce)
                        Resp(req,, adjust_fragment(req.url, ce.url), ce.data, ce.fname, ce.content_type, ce.content_disposition)
                     } else if (sc = 300) | (400 <= sc <= 599) &
                        data := s.str() &
                        *data > 0 then
                     {
                        # Include http content together with the error
                        # message, so it can be displayed
                        fname := hres.get_filename()
                        ct := ContentType.parse_rfc2616(hres.get_first_header("Content-Type"))
                        cd := ContentDisposition.parse_rfc2616(hres.get_first_header("Content-Disposition"))
                        Resp(req, &why, adjust_fragment(req.url, hres.url), data, fname, ct, cd)
                     } else
                        Resp(req, &why, req.url)
                  } else
                     Resp(req, &why, req.url)
               }
            }
         }
      }
   end
end

class Worker()
   private readable
      pool, httpc, cancelled, req, task, sub_worker

   public static const NORMAL, NAVIGATE, REFRESH, DOWNLOAD

   private static init()
      NORMAL := "normal"
      NAVIGATE := "navigate"
      REFRESH := "refresh"
      DOWNLOAD := "download"
   end

   public initially()
      task.start()
   end

   public finally()
      if \req then
         cancel()
      else {
         # httpc may be null, since we may have started but never been run
         (\httpc).close()
         task.stop()
      }
   end

   public cancel()
      if \req then {
         cancelled := &yes
         task.interrupt()
         (\sub_worker).cancel()
      }
   end

   public read()
      return (\sub_worker).get_read()
   end

   public length()
      return (\sub_worker).get_length()
   end

   private dwrite(a[])
      writes("[", serial(self), "] ")
      write!a
   end

   private writing_line(ev)
      dwrite("Sent: ", ev)
   end

   private read_line(ev)
      dwrite("Got : ", ev)
   end

   private read_string(ev)
      dwrite("Got : data - 0x", Format.int_to_string(*ev, 16), " bytes")
   end

   private writing_string(ev)
      dwrite("Sent: data - 0x", Format.int_to_string(*ev, 16), " bytes")
   end

   private connecting(ev, src)
      dwrite("Connecting to ", src.server, ":", src.port)
   end

   private connected(ev)
      dwrite("Connected to ", ev)
   end

   private failed(ev)
      dwrite("Failed: ", &why)
   end

   private retrying(ev)
      dwrite("Retrying: ", &why)
   end

   private other(ev, src, type)
      dwrite(type)
   end

   private status(ev, src, type)
      (\(\req).on_status)(ev, src, type)
   end

   private setup_httpc()
      httpc := HttpClient().
         set_task(task).
         set_cookies(pool.cookies).
         set_authentications(pool.authentications).
         set_retry_while_data(&yes)
      httpc.set_user_agent(\pool.user_agent)

      every httpc.connect(status, 
                          NetClient.CONNECTING_EVENT |
                          NetClient.CONNECTED_EVENT |
                          NetClient.CLOSED_EVENT |
                          HttpClient.COMPLETE_EVENT |
                          HttpClient.FAILED_EVENT |
                          HttpClient.ABORTED_EVENT |
                          HttpClient.RETRYING_EVENT) 

      if \pool.log_http_flag then {
         httpc.connect(failed, HttpClient.FAILED_EVENT).
            connect(retrying, HttpClient.RETRYING_EVENT).
            connect(read_line, NetClient.READ_LINE_EVENT).
            connect(read_string, NetClient.READ_STRING_EVENT).
            connect(writing_line, NetClient.WRITING_LINE_EVENT).
            connect(writing_string, NetClient.WRITING_STRING_EVENT).
            connect(connecting, NetClient.CONNECTING_EVENT).
            connect(connected, NetClient.CONNECTED_EVENT).
            connect(other, NetClient.CLOSED_EVENT).
            connect(other, HttpClient.COMPLETE_EVENT)
      }
   end

$ifdef _PLAN9
   private handle_launch_req()
      local pid, f
      if (\req.referer).scheme == (u"http" | u"https") then
         return error("Can't launch a prog from an http page")
      f := req.url.get_decoded_path()
      pid := System.fork(ior(ForkOpt.RFPROC, ForkOpt.RFCFDG, ForkOpt.RFNAMEG, ForkOpt.RFENVG,
                             ForkOpt.RFNOTEG, ForkOpt.RFREND, ForkOpt.RFNOWAIT)) | fail
      if pid > 0 then
         return
      Files.unmount_windows()
      Files.chdir(Files.get_home())
      null_stdio()
      System.exec("/bin/rc", ["-c", "exec " || f]) | stop(&why)
      syserr("Not reached")
   end
$else
   private handle_launch_req()
      local pid, f
      if (\req.referer).scheme == (u"http" | u"https") then
         return error("Can't launch a prog from an http page")
      f := req.url.get_decoded_path()
      pid := System.fork() | fail
      if pid > 0 then {
         ChildWait.add_pid(pid)
         return
      }
      Files.chdir(Files.get_home())
      System.setpgid()
      null_stdio()
      Files.bulk_close(100)
      System.exec("/bin/sh", ["-c", "exec " || f]) | stop(&why)
      syserr("Not reached")
   end
$endif

   private handle_cache_req()
      return pool.cache.get(req.url) | error("Cache entry expired")
   end

   private handle_func(f)
      local x, s
      if x := f(self) then {
         if /cancelled then {
            if is(x, SubWorker) then {
               sub_worker := x
               handle_func(x.get_data)
            } else if is(x, Resp) then
               req.callback(x)
            else if is(x, StaticData) then
               req.callback(Resp(req,, req.url, x.data, x.fname, x.content_type, x.content_disposition))
            else if s := string(x) then
               req.callback(Resp(req,, req.url, s, req.url.get_decoded_path_last()))
            else if \x then
               runerr(103, x)
         }
      } else {
         if /cancelled then
            req.callback(Resp(req, &why, req.url))
      }
   end

   private handle_data_req()
      local du
      return if du := DataURL(req.url) then
         Resp(req,, req.url, du.data,, du.content_type)
      else
         Resp(req, &why, req.url)
   end

   private handle_req()
      local f, t
      t := string(req.url.scheme)
      case t of {
         "file": handle_func(FileSubWorker)
         "data": handle_func(handle_data_req)
         "prog": handle_func(ProgSubWorker)
         "launch": handle_func(handle_launch_req)
         "cache": handle_func(handle_cache_req)
         "http"|"https": handle_func(HttpSubWorker)
         default: {
            if f := member(pool.scheme_handlers, t) then
               handle_func(f)
            else
               req.callback(Resp(req, "Unknown url scheme", req.url))
         }
      }
   end

   private run()
      setup_httpc()
      repeat {
         while /pool.active do {
            # finally() has been called; close resources and revert
            httpc.close()
            task.revert()
         }
         until req := pool.queue_get() do
            task.sleep()
         insert(pool.req_worker, req, self)
         cancelled := &null
         handle_req()
         delete(pool.req_worker, req)
         sub_worker := req := &null
      }
   end

   public new(pool)
      self.pool := pool
      task := Dispatcher.new_task{run()}
      return
   end
end

abstract class WorkerPoolOwner()
   public abstract get_authentication(httpc, dom, realm)
end

class WorkerPool()
   private
      queue,
      workers
   package
      req_worker         # table mapping Req to Worker
   private readable
      owner,
      active,
      log_http_flag,
      cookies,
      user_agent,
      cache,
      authentications,
      scheme_handlers

   public set_log_http(s)
      self.log_http_flag := check_flag(s)
      return self
   end

   public initially()
      active := &yes
      every (!workers).initially()
   end

   public finally()
      active := &null
      every (!workers).finally()
      clear(queue)
   end

   # Cancel all requests for a given client
   public cancel_all(client)
      local w
      delete(queue, client)
      every w := !workers do 
         if (\w.req).client === client then
            w.cancel()
      return self
   end

   # Cancel an individual request
   public cancel_req(req)
      local l, i
      if l := member(queue, req.client) then {
         if i := keyof(l, req) then {
            delete(l, i)
            if *l = 0 then
               delete(queue, req.client)
            return self
         }
      }
      # Not found in queue, so look in the workers.
      get_worker(req).cancel()
      return self
   end

   public get_worker(req)
      return member(req_worker, req)
   end

   public enqueue(req)
      local w, l
      if l := member(queue, req.client) then
         put(l, req)
      else
         insert(queue, req.client, [req])
      # Wake up a sleeping task if possible.  Take care not to notify
      # a sleeping task that is processing a request, or to notify a
      # non-sleeping task (may be in ready state).
      every w := !workers do
         if /w.req & w.task.is_sleeping() then {
            w.task.notify()
            break
         }
      return self
   end

   public queue_size()
      local i
      i := 0
      every i +:= *!queue
      return i
   end

   package queue_get()
      local l, r
      l := ?queue | fail
      r := get(l) | syserr("Empty list in queue table")
      if *l = 0 then
         delete(queue, r.client)
      return r
   end

   public count(client)
      local i, w
      i := *member(queue, client) | 0
      every w := !workers do 
         if (\w.req).client === client then
            i +:= 1
      return i
   end

   # Return the amount read by this client's current requests.
   #
   public read(client)
      local i, w
      i := 0
      every w := !workers do
         if (\w.req).client === client then
            i +:= w.read()
      return i
   end

   # Return a length giving the remaining data to be downloaded for
   # this client; fails if that is unknown.
   #
   public length(client)
      local i, w
      if member(queue, client) then
         fail
      i := 0
      every w := !workers do
         if (\w.req).client === client then
            i +:= w.length() | fail
      return i
   end

   public set_cookies(cookies)
      self.cookies := cookies
      return self
   end

   public set_authentications(m)
      self.authentications := m
      return self
   end

   public set_cache(c)
      self.cache := c
      return self
   end

   public set_scheme_handlers(m)
      self.scheme_handlers := m
      return self
   end

   public add_scheme_handler(scheme, func)
      insert(scheme_handlers, scheme, func)
      return self
   end

   #
   # Set the user-agent identification
   #
   public set_user_agent(s)
      self.user_agent := s
      return self
   end

   public get_status()
      local s, w, st, t, l, r
      s := "<html><title>Worker pool status</title>"

      s ||:= "<h1>Workers</h1>" || Browser.TABLE_TAG || "<tr><th align=left>Serial</th><th align=left>Status</th><th align=left>URL</th></tr>"
      every w := !workers do {
         t := w.task
         st := if t.is_current() then "current"
         else if t.is_sleeping() then "sleeping"
         else if t.is_polling() then "polling"
         else if t.is_ready() then "ready"
         else if t.is_active() then "active"
         else "stopped"
         s ||:= "<tr><td>" || serial(w) || "</td><td>" || st || "</td>"
         if l := (\w.req).url then
            s ||:= Browser.mk_anchor_cell(l)
         else
            s ||:= "<td/>"
         s ||:= "</tr>"          
      }
      s ||:= "</table>"

      if *queue > 0 then {
         s ||:= "<h1>Queue</h1>" || Browser.TABLE_TAG || "<tr><th align=left>Client</th><th align=left>Kind</th><th align=left>URL</th></tr>"
         every r := !!queue do {
            s ||:= "<tr><td>" || Class.get_name(r.client) || "#" || serial(r.client) || "</td><td>" ||
                    r.kind || "</td>" || Browser.mk_anchor_cell(r.url) || "</tr>"
         }
         s ||:= "</table>"
      }

      s ||:= "</html>"
      return s
   end

   public new(owner, n)
      /n := 6
      self.owner := owner
      queue := table()
      cookies := table()
      cache := Cache(8*1024*1024)
      authentications := table()
      scheme_handlers := table()
      workers := []
      every 1 to n do
         put(workers, Worker(self))
      req_worker := table()
      return
   end
end

class TblContent(Component)
   private
      hrules, vrules

   public whose_point(ex, ey)
      local c
      every c := layout_delegate.computed_g.cells_in_range(ey - y, 1).obj do {
         if c.is_unhidden() & c.inside(ex, ey) then
            return c
      }
   end

   public display()
      local ci, r, g, t
      r := get_cbwin_clip()
      g := layout_delegate.computed_g
      every ci := g.cells_in_range(r.y - y, r.h) do {
         display_child(ci.obj)
         if \vrules | \hrules then {
            t := Rect(x + g.a_col_x[ci.x],
                      y + g.a_row_y[ci.y],
                      Grid.slice(ci.x, ci.w, g.a_col_w),
                      Grid.slice(ci.y, ci.h, g.a_row_h))
            if r.intersect(t) then {
               if member(\vrules, ci.x) then
                  cbwin.fill_rectangle(t.x, t.y, Gui.FINE_WIDTH, t.h)
               if member(\hrules, ci.y) then
                  cbwin.fill_rectangle(t.x, t.y, t.w, Gui.FINE_WIDTH)
            }
         }
      }
   end

   public set_hrules(r)
      self.hrules := r
      return self
   end

   public set_vrules(r)
      self.vrules := r
      return self
   end
end

class Tbl(Border, HasMaxWidth)
   public get_max_width()
      local w1
      w1 := content.layout_delegate.get_max_width() + border.get_total_width()
      return if \title then
         max(w1, title.get_max_width() + 2 * TITLE_OFFSET)
      else
         w1
   end

   public new()
      Border.new()
      set_content(TblContent(). 
                    set_layout(TableLayout()))
      set_border(NullBorder())
      return
   end
end

abstract class HasLastHighlight()
   public abstract set_last_highlight(u)
   package abstract save_last_highlight(he)
   package abstract restore_last_highlight(n, url)
end

class Img(Image, HasLastHighlight)
   public const
      browser, context, form, img_url, alt, bg_area
   private readable
      over, img_data, img_name, map, map_id, held, err, highlight, last_highlight

   package got_data(res)
      local iw, ih
      if \res.err then {
         err := res.err
         set_cache("rpp.BROKEN_LINK")
         every remove_constraint("fix_w" | "fix_h" | "pct_w")
      } else {
         set_image(res.data)
         if /win then {
            err := &why
            set_cache("rpp.BROKEN_LINK")
            every remove_constraint("fix_w" | "fix_h" | "pct_w")
         } else {
            # Set width and perhaps height based on constraints.
            #
            # If pct_w is set, then set a small minimal value, since
            # otherwise the actual width of the image would be the
            # preferred width, and hence the minimum size which
            # TextFlow would allocate, whereas we want to allow the
            # image to shrink below its actual width.
            #
            if iw := integer(member(constraints, "fix_w")) then
               set_width(iw + border.get_total_width())
            else if integer(member(constraints, "pct_w")) then
               set_width(1 + border.get_total_width())
            if ih := integer(member(constraints, "fix_h")) then {
               if /w_spec then 
                  set_width(ih * win.get_width() / win.get_height() + border.get_total_width())
               else 
                  set_height(ih + border.get_total_height())
            }
            # If neither set (/w_spec should imply /h_spec), ensure a
            # scaled image with the true ratio.
            if /w_spec then
               set_width(scale(win.get_width()) + border.get_total_width())

            img_name := res.fname
            img_data := res.data
            set_fill_dimensions(2)
         }
      }
   end

   private handle_rpress(e)
      local pm, pm_menu
      parent_dialog.get_held_count() = 1 | fail
      if pm_menu := browser.create_image_menu(self) then {
         set_highlight(over)
         set_over()
         pm := PopupMenu()
         pm.connect(on_popup_closed, Event.POPUP_CLOSED)
         pm.popup(self, pm_menu, e.x, e.y)
      }
   end

   private on_popup_closed()
      set_highlight()
   end

   private handle_lrelease(e, src)
      \held | fail
      if \over then {
         set_highlight()
         browser.link_left_clicked(over)
      }
      held := &null
   end

   private handle_mrelease(e)
      \held | fail
      if \over then {
         set_highlight()
         browser.link_middle_clicked(over)
      }
      held := &null
   end

   private handle_form_lrelease(e, src)
      if in_region(e) then
         form.submit(e, src)
   end

   private handle_exit(e)
      parent_dialog.get_held_count() = 0 | fail
      set_over()
   end

   private handle_interrupted(e)
      set_highlight()
      set_over()
      held := &null
   end

   package gen_areas()
      # Non-null bg_area implies we have some areas (ie, links) (see constructor below).
      if \bg_area then
         suspend get_map().gen_areas() | bg_area
   end

   private get_map()
      /map := browser.get_map(\map_id) | ipl.browser.Map()
      return map
   end

   private which_area(e)
      in_region(e) | fail
      return get_map().which_area(e.x - x - border.get_l_inset(), 
                                  e.y - y - border.get_t_inset()) | bg_area
   end

   private handle_lmpress(e)
      parent_dialog.get_held_count() = 1 | fail
      if \over then {
         set_highlight(over)
         held := over
      }
   end

   private set_over(u)
      if u ~=== over then {
         over := u
         if visible_border() then
            invalidate()
         if /over then
            browser.msg()
         else
            browser.msg(over.str())
      }
      return self
   end

   public set_last_highlight(u)
      if u ~=== last_highlight then {
         last_highlight := u
         invalidate()
      }
      return self
   end

   package save_last_highlight(he)
      local a, u, n
      n := 0
      every a := gen_areas() do {
         if u := \a.url then {
            n +:= 1
            if last_highlight === u then {
               he.last_highlight_index := n
               he.last_highlight := u
               return self
            }
         }
      }
   end

   package restore_last_highlight(n, url)
      local a, u
      every a := gen_areas() do {
         if u := \a.url then {
            n -:= 1
            if n = 0 then {
               URL.equiv(url, u) | fail
               last_highlight := u
               return self
            }
         }
      }
   end

   private set_highlight(u)
      if u ~=== highlight then {
         browser.set_last_highlight(self, \u)
         # Avoid resetting since that will reload the image data, which is slow.
         if visible_border() then {
            set_fg(if \u then browser.page_alink_color else context.fg)
            reset()
         }
         highlight := u
      }
      return self
   end

   private handle_lmdrag(e)
      \held | fail
      if \which_area(e).url === held then {
         set_over(held)
         set_highlight(held)
      } else {
         set_over()
         set_highlight()
      }
   end

   package wants_lpress(e)
      return \over | \form
   end

   package handle_in_chain(e)
      local u, t, a, f
      parent_dialog.get_held_count() = 0 | fail
      if e.code === (Key.CONTROL_L | Key.CONTROL_R) then {
         if /e.release then
            f := &yes
      } else f := \e.ctrl
      t := which_area(e)
      a := (\t).title
      set_tooltip(a)
      if /f & (u := \ (\t).url) then {
         set_over(u)
         set_pointer("hand1")
      } else {
         set_over()
         set_pointer()
      }
   end

   private visible_border()
      return not is(border, NullBorder | EmptyBorder)
   end

   public display()
      local r, W
      Image.display()
      if r := browser.is_banded(self) then
         Gui.style.fill_selection_rectangle(cbwin, x, y, w, h)
      if \last_highlight then
         Gui.style.draw_dashed_rectangle(cbwin, x, y, w, h)
      if \over & visible_border() then {
         # Make the border colour consistent with foreground link text colour.
         use {
            W := Gui.style.get_over_clone(cbwin),
            border.draw_rect(W, self)
         }
      }
   end

   public new(browser, context, img_url, alt, form, map_id)
      Image.new()
      clear_constraints()
      self.browser := browser
      self.context := context
      self.img_url := img_url
      self.form := form
      self.alt := alt
      self.map_id := map_id
      if \form then {
         set_pointer("hand1")
         connect(handle_form_lrelease, Event.MOUSE_LEFT_RELEASE)
      } else if \map_id | \context.url then {
         connect(handle_lmdrag, Event.MOUSE_LEFT_DRAG)
         connect(handle_lmpress, Event.MOUSE_LEFT_PRESS)
         connect(handle_lrelease, Event.MOUSE_LEFT_RELEASE)
         connect(handle_lmdrag, Event.MOUSE_MIDDLE_DRAG)
         connect(handle_lmpress, Event.MOUSE_MIDDLE_PRESS)
         connect(handle_mrelease, Event.MOUSE_MIDDLE_RELEASE)
         connect(handle_exit, Event.MOUSE_EXIT)
         connect(handle_interrupted, Event.INTERRUPTED)
         bg_area := MapArea(,, context.url, context.title)
      }
      connect(handle_rpress, Event.MOUSE_RIGHT_PRESS)
      set_border(NullBorder())
      return
   end
end

abstract class FormEntry()
   package readable
      form_name, form_save_key, form_id, form_tabindex

   public validate_form()
      return
   end
                  
   public get_save_key()
      return \form_save_key
   end

   public reset_form() end
   public get_save_value() end
   public restore_value(val) end

   public abstract get_form_value(ev, src, multipart_flag)
end

class FormToggle(ToggleTextButton, FormEntry)
   private const
      value,
      init_checked

   public reset_form()
      set_is_checked(init_checked)
   end

   public get_form_value(ev, src)
      if is_checked() then 
         return value
   end

   public get_save_value()
      return get_status()
   end

   public restore_value(val)
      set_is_checked(val)
   end

   public new(value, init_checked)
      ToggleTextButton.new()
      self.value := value
      self.init_checked := init_checked
      set_is_checked(init_checked)
      return
   end
end

class FormButton(TextButton, FormEntry, HasAscent)
   private const
      value

   public get_form_value(ev, src)
      if src === self then
         return value
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset()
   end

   public new(value)
      TextButton.new()
      self.value := value
      set_label(value)
      return
   end
end

class FormTextFlowButton(Button, FormEntry, HasMaxWidth, HasAscent)
   public const
      tf, value, form, type

   public get_form_value(ev, src)
      if src === self then
         return value
   end

   private handle_action(e, src)
      case type of { 
         "submit": form.submit(e, src)
         "reset": form.reset_form()
      }
   end

   public display()
      display_children()
      if \self.is_down then {
         Gui.style.fill_down_rectangle(self.cbwin, self.x, self.y, self.w, self.h)
         tf.border.draw_rev_rect(self.cbwin, self)
      }
      if self.has_focus() & self.is_unshaded() then
         tf.border.draw_focus_rect(self.cbwin, self)
   end

   #
   # Prevent children from getting in the point chain.
   #
   public build_point_chain()
   end

   public get_default_width()
      return tf.get_preferred_width()
   end

   public get_max_width()
      return tf.get_max_width()
   end

   public get_default_height(dw)
      return tf.get_preferred_height(dw)
   end

   public get_ascent(dw)
      return tf.get_ascent(dw)
   end

   public layout()
      tf.x := x
      tf.y := y
      tf.w := w
      tf.h := h
      tf.layout()
   end

   public new(form, value, type)
      Button.new()
      tf := TextFlow(form.browser).
         set_border(CompoundBorder().
                    set_outer(RaisedBorder()).
                    set_inner(EmptyBorder()))
      add(tf)
      self.value := value
      self.form := form
      self.type := type
      connect(self.handle_action, Event.ACTION)
      return
   end
end

class Hidden(FormEntry)
   private const
      value

   public get_form_value()
      return value
   end

   public new(value)
      self.value := value
      return
   end
end

class FormLabel()
   public const
      id,
      form
   public
      comp

   public new(id, form)
      self.id := id
      self.form := form
      return
   end
end

class FormBrowse(Component, FormEntry, HasAscent)
   private const
      tf,
      browser

   public get_form_value(ev, src, multipart_flag)
      local s
      s := tf.get_contents()
      if *s = 0 then
         return ""
      return if /multipart_flag then
         tf.get_contents()
      else
         Files.file_to_string(s)
   end

   public validate_form()
      local s
      s := tf.get_contents()
      if *s = 0 then
         return
      return Files.access(s) | error("No such file")
   end

   public get_filename()
      return FilePath(tf.get_contents()).get(-1) | u""
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + tf.border.get_t_inset()
   end

   public reset_form()
      tf.set_contents(u"")
   end

   public get_save_value()
      return tf.get_contents()
   end

   public restore_value(val)
      tf.set_contents(val)
   end

   private on_browse(ev)
      tf.assign_contents(ucs(browser.browse_for_file(tf.get_contents())),, ev)
   end

   public new(browser, tf_size)
      Component.new()
      self.browser := browser
      set_layout(GridLayout().set_doi(0).set_dii(0))
      tf := FileSuggestField().set_size(tf_size).set_contents(u"")
      add(tf)
      add(TextButton().set_label("Browse...").connect(on_browse, Event.ACTION))
      return
   end
end

class FormImgX(FormEntry)
   private const
      img

   public get_form_value(ev, src)
      if src === img then
         return round((ev.x - img.x) / Gui.SCALE)
   end

   public new(img)
      self.img := img
      return
   end
end

class FormImgY(FormEntry)
   private const
      img

   public get_form_value(ev, src)
      if src === img then
         return round((ev.y - img.y) / Gui.SCALE)
   end

   public new(img)
      self.img := img
      return
   end
end

class FormTextField(SuggestField, FormEntry, HasAscent)
   private const
      browser,
      init_val,
      datalist_id

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset()
   end

   public reset_form()
      set_contents(init_val)
   end

   public get_form_value()
      return get_contents()
   end

   public get_save_value()
      return get_contents()
   end

   public restore_value(val)
      set_contents(val)
   end

   public create_popup()
      return FormOptionList()
   end

   public convert_element(o)
      return o.value
   end

   protected do_request()
      local l, t, e, s
      l := browser.get_datalist(\datalist_id) | fail
      s := map(contents)
      t := []
      every e := !l do {
         if match(s, map(e.value)) then
            put(t, e)
      }
      return t
   end

   public handle_return(e)
      if \popup then
         keep_closed()
      else
         TextField.handle_return(e)
   end

   public new(browser, init_val, datalist_id)
      SuggestField.new()
      self.browser := browser
      self.init_val := init_val
      self.datalist_id := datalist_id
      set_contents(init_val)
      return
   end
end

class FormURLField(TextField, FormEntry, HasAscent)
   private const
      init_val

   public get_ascent()
      return cbwin.get_font_ascent() + border.get_t_inset()
   end

   public reset_form()
      set_contents(init_val)
   end

   public get_form_value()
      return get_contents()
   end

   public validate_form()
      return URL(get_contents()) | error("Bad URL")
   end

   public get_save_value()
      return get_contents()
   end

   public restore_value(val)
      set_contents(val)
   end

   public new(init_val)
      TextField.new()
      self.init_val := init_val
      set_contents(init_val)
      return
   end
end

class FormDateField(DateField, FormEntry, HasAscent)
   private const
      init_val

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset() + view.border.get_t_inset()
   end

   public reset_form()
      set_value(init_val)
   end

   public validate_form()
      return get_value() | error("Bad date format")
   end

   public get_form_value()
      return get_value().format("yyyy-MM-dd")
   end

   public get_save_value()
      return last_val
   end

   public restore_value(val)
      set_value(val)
   end

   public new(init_val)
      DateField.new(init_val)
      self.init_val := init_val
      return
   end
end

class FormWeekField(WeekField, FormEntry, HasAscent)
   private const
      init_val

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset() + view.border.get_t_inset()
   end

   public reset_form()
      set_value(init_val)
   end

   public validate_form()
      return get_value() | error("Bad week format")
   end

   public get_form_value()
      return get_value().format("vvvv'-W'ww")
   end

   public static parse(s)
      local w, y
      s ? {
         (y := integer(tab(many(&digits))) &
          1000 <= y <= 9999 &
          ="-W" &
          w := integer(tab(many(&digits))) &
          1 <= w <= 53 &
          pos(0)) | fail
      }
      return Time.get_week_of_year(y, w)
   end

   public get_save_value()
      return last_val
   end

   public restore_value(val)
      set_value(val)
   end

   public new(init_val)
      WeekField.new(init_val)
      self.init_val := init_val
      return
   end
end

class FormTimeField(TimeField, FormEntry, HasAscent)
   private const
      init_val

   public reset_form()
      set_value(init_val)
   end

   public validate_form()
      return get_value() | error("Bad time format")
   end

   public get_form_value()
      return get_value().format("HH':'mm':'ss")
   end

   public get_save_value()
      return last_val
   end

   public restore_value(val)
      set_value(val)
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset() + view.border.get_t_inset()
   end

   public static parse(s)
      s ?:= tab(upto('.'))
      return Time.parse(s, "HH':'mm':'ssx")
   end

   public new(init_val)
      TimeField.new(init_val)
      self.init_val := init_val
      return
   end
end

class FormDateTimeLocalField(Component, FormEntry, HasAscent)
   private const
      date,
      time

   public get_ascent() 
      return date.get_ascent()
   end

   public reset_form()
      date.reset_form()
      time.reset_form()
   end

   public validate_form()
      return date.validate_form() & time.validate_form()
   end

   public static parse(s)
      s ?:= tab(upto('.'))
      return Time.parse(s, "yyyy-MM-dd'T'HH':'mm':'ssx")
   end

   public get_form_value()
      return date.get_form_value() || "T" || time.get_form_value()
   end

   public get_save_value()
      return [date.get_save_value(), time.get_save_value()]
   end

   public restore_value(val)
      date.restore_value(val[1])
      time.restore_value(val[2])
   end

   public new(init_val)
      Component.new()
      set_layout(GridLayout().set_doi(0).set_dii(0))
      add(date := FormDateField(init_val))
      add(time := FormTimeField(init_val))
      return
   end
end

class FormTimezoneField(TimezoneField, FormEntry, HasAscent)
   private const
      init_val

   public reset_form()
      set_value(init_val)
   end

   public validate_form()
      return get_value() | error("Bad timezone format")
   end

   public get_form_value()
      local zone
      zone := get_value() | fail
      return if zone.offset = 0 then
         "Z"
      else (if zone.offset < 0 then "-" else "+") ||
         right(abs(zone.offset) / 3600, 2, "0") || ":" ||
         right((abs(zone.offset) % 3600) / 60, 2, "0")
   end

   public get_save_value()
      return last_val
   end

   public restore_value(val)
      set_value(val)
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset() + view.border.get_t_inset()
   end

   public new(init_val)
      TimezoneField.new(init_val)
      self.init_val := init_val
      return
   end
end

class FormYearField(YearField, FormEntry, HasAscent)
   private const
      init_val

   public reset_form()
      set_value(init_val)
   end

   public validate_form()
      return get_value() | error("Bad timezone format")
   end

   public get_form_value()
      return string(get_value())
   end

   public get_save_value()
      return last_val
   end

   public restore_value(val)
      set_value(val)
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset() + view.border.get_t_inset()
   end

   public new(init_val)
      YearField.new()
      set_value(init_val)
      self.init_val := init_val
      return
   end
end

class FormMonthField(MonthField, FormEntry, HasAscent)
   private const
      init_val

   public reset_form()
      set_selection(init_val)
   end

   public get_form_value()
      return string(get_selection())
   end

   public get_save_value()
      return get_selection()
   end

   public restore_value(val)
      set_selection(val)
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset() + view.border.get_t_inset()
   end

   public new(init_val)
      MonthField.new()
      set_selection(init_val)
      self.init_val := init_val
      return
   end
end

class FormDateTimeField(Component, FormEntry, HasAscent)
   private const
      date,
      time,
      zone

   public get_ascent() 
      return date.get_ascent()
   end

   public reset_form()
      date.reset_form()
      time.reset_form()
      zone.reset_form()
   end

   public validate_form()
      return date.validate_form() & time.validate_form() & zone.validate_form()
   end

   public static parse(s)
      s ? {
         if s := tab(upto('.')) then {
            move(1)
            tab(many(&digits))
            s ||:= tab(0)
         }
      }
      return Time.parse(s, "yyyy-MM-dd'T'HH':'mm':'ssTx")
   end

   public get_form_value()
      return date.get_form_value() || "T" || time.get_form_value() || zone.get_form_value()
   end

   public get_save_value()
      return [date.get_save_value(), time.get_save_value(), zone.get_save_value()]
   end

   public restore_value(val)
      date.restore_value(val[1])
      time.restore_value(val[2])
      zone.restore_value(val[3])
   end

   public new(init_val)
      Component.new()
      set_layout(GridLayout().set_doi(0).set_dii(0))
      add(date := FormDateField(init_val))
      add(time := FormTimeField(init_val))
      add(zone := FormTimezoneField(init_val.zone))
      return
   end
end

class FormMonthYearField(Component, FormEntry, HasAscent)
   private const
      month,
      year,
      init_val

   public get_ascent() 
      return month.get_ascent()
   end

   public reset_form()
      month.reset_form()
      year.reset_form()
   end

   public validate_form()
      return year.validate_form()
   end

   public static parse(s)
      local y, m
      s ? {
         (y := integer(tab(many(&digits))) &
          1000 <= y <= 9999 &
          ="-" &
          m := integer(tab(many(&digits))) &
          1 <= m <= 12 &
          pos(0)) | fail
      }
      return Time(y, m)
   end

   public get_form_value()
      return year.get_form_value() || "-" || month.get_form_value()
   end

   public get_save_value()
      return [year.get_save_value(), month.get_save_value()]
   end

   public restore_value(val)
      year.restore_value(val[1])
      month.restore_value(val[2])
   end

   public new(init_val)
      Component.new()
      set_layout(GridLayout().set_doi(0).set_dii(0))
      add(month := FormMonthField(init_val.month))
      add(year := FormYearField(init_val.year))
      return
   end
end

class FormRange(Slider, FormEntry)
   private const
      init_val

   public reset_form()
      set_value(init_val)
   end

   public get_form_value()
      return get_value()
   end

   public get_save_value()
      return get_value()
   end

   public restore_value(val)
      set_value(val)
   end

   public new(init_val)
      Slider.new()
      set_value(init_val)
      self.init_val := init_val
      return
   end
end

class FormNumberField(RangeSpin, FormEntry, HasAscent)
   private const
      init_val

   public reset_form()
      set_value(init_val)
   end

   public validate_form()
      return get_value() | error("Invalid number")
   end

   public get_form_value()
      return string(get_value())
   end

   public get_save_value()
      return last_val
   end

   public restore_value(val)
      set_value(val)
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset() + view.border.get_t_inset()
   end

   public new(init_val)
      RangeSpin.new()
      set_value(init_val)
      self.init_val := init_val
      return
   end
end

class FormColorField(ColorField, FormEntry, HasAscent)
   private const
      init_val

   public reset_form()
      set_value(init_val)
   end

   public validate_form()
      return get_value() | error("Bad color format")
   end

   public get_form_value()
      local l, s
      l := Window.parse_color(get_value()) | fail
      s := "#"
      every s ||:= Format.int_to_string(l[1 to 3] / 256, 16, 2)
      return s
   end

   public get_save_value() 
      return last_val
   end

   public restore_value(val)
      set_value(val)
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + b.border.get_t_inset()
   end

   public static parse(s)
      return Window.color_value(s)
   end

   public new(init_val)
      ColorField.new(init_val)
      self.init_val := init_val
      set_opaque(&yes)
      return
   end
end

class FormEditableTextList(EditableTextList, FormEntry)
   private const
      init_val

   public reset_form()
      set_contents_str(init_val)
      set_cursor(1, 1)
   end

   public get_form_value()
      return list2str(contents, "\r\n")
   end

   public get_save_value()
      return get_contents()
   end

   public restore_value(val)
      set_contents(val)
   end

   public new(init_val)
      EditableTextList.new()
      self.init_val := init_val
      set_contents_str(init_val)
      return
   end
end

class FormOption()
   public const
      txt, label, value, selected, disabled, optgroup

   public new(txt, label, value, selected, disabled, optgroup)
      self.txt := txt
      self.label := label
      self.value := value
      self.selected := selected
      self.disabled := disabled
      self.optgroup := optgroup
      return
   end
end

class FormOptionList(SelectableScrollArea, FormEntry)
   private const
      init_val

   public end_handle(e)
      local i
      every i := !selections do {
         if /contents[i].value then
            delete(selections, i)
      }
      SelectableScrollArea.end_handle(e)
   end

   public get_form_value(ev, src)
      suspend \contents[!selections].value
   end

   public reset_form()
      set_selections(init_val)
   end

   public get_save_value()
      return get_selections()
   end

   public restore_value(val)
      set_selections(val)
   end

   public calculate_line_height()
      return view.cbwin.get_line_height()
   end

   public calculate_subject_width()
      local mw, o
      mw := 0
      every o := !contents do
         mw <:= view.cbwin.text_width(o.txt)
      return mw + 2 * Gui.TEXT_INSET
   end

   public draw_line_data(xp, yp, lh, i)
      local o, W
      o := contents[i]
      if \o.disabled then {
         use {
            W := view.cbwin.clone(),
            W.set_fg("gray").
              draw_string(xp + Gui.TEXT_INSET, yp + W.get_line_ascent(), o.txt)
         }
      } else 
         view.cbwin.draw_string(xp + Gui.TEXT_INSET, yp + view.cbwin.get_line_ascent(), o.txt)
   end

   public new(init_val)
      SelectableScrollArea.new()
      self.init_val := init_val
      return
   end
end

class FormList(gui.List, FormEntry, HasAscent)
   private const
      init_val

   public get_ascent() 
      return cbwin.get_font_ascent() + view.border.get_t_inset() + border.get_t_inset()
   end

   private find_value(seq, e)
      local i
      while i := @seq do {
         if \selection_list[i].value then {
            start_change(e)
            set_selection(i, e)
            end_change(e)
            break
         }
      }
   end

   public do_increment(e)
      if /selection then
         find_value(create *selection_list to 1 by -1, e)
      else
         find_value(create (selection - 1 to 1 by -1) | (*selection_list to selection + 1 by -1), e)
   end

   public do_decrement(e)
      if /selection then
         find_value(create 1 to *selection_list, e)
      else
         find_value(create (1 + selection to *selection_list) | (1 to selection - 1), e)
   end

   public reset_form()
      set_selection(init_val)
   end

   public get_form_value(ev, src)
      return \object_get_selection().value
   end

   public get_save_value()
      return get_selection()
   end

   public restore_value(val)
      set_selection(val)
   end

   public create_popup()
      return FormOptionList()
   end

   public convert_element(o)
      return o.label
   end

   public get_default_width()
      local mw, o
      mw := 0
      every o := !selection_list do
         if \o.value then
            mw <:= view.cbwin.text_width(o.label)
      return border.get_total_width() + b.get_preferred_width() + mw + view.border.get_total_width()
   end

   public new(init_val)
      gui.List.new()
      self.init_val := init_val
      return
   end
end

class Form()
   public const
      id,
      url,
      save_key,
      browser,
      method,
      enctype,
      items,
      labels,
      id_table,
      cbgs
   private readable
      autofocus

   private make_cgi_table(ev, src)
      local t, k, c, v
      t := table()
      every c := !items do {
         if k := \c.form_name then {
            every v := c.get_form_value(ev, src) do
               put(member(t, k), v) | insert(t, k, [v])
         }
      }
      return t
   end

   private static escape_1521_value(s)
      local t, ch
      t := u"\""
      s ? repeat {
         t ||:= tab(many(&uset -- '\"\\\r'))
         ch := move(1) | break
         t ||:= u"\\" || ch
      }
      return t || u"\""
   end

   private make_cgi_message(ev, src)
      local k, v, c, m, mp, m2, fn, mt
      m := Message()
      mp := Multipart()
      every c := !items do {
         if k := \c.form_name then {
            every v := c.get_form_value(ev, src, &yes) do {
               m2 := Message()
               if is(c, FormBrowse) then {
                  fn := c.get_filename()
                  mt := Mime.get_mime_type_for_file(fn) | "application/octet-stream"
                  m2.set_header("Content-Disposition", 
                                "form-data; name=" || escape_1521_value(k) || 
                                "; filename=" || escape_1521_value(fn))
                  m2.set_header("Content-Type", mt)
               } else 
                  m2.set_header("Content-Disposition", 
                                "form-data; name=" || escape_1521_value(k))
               m2.set_decoded_content(v)
               mp.add_part(m2)
            }
         }
      }
      m.set_header("Content-Type", "multipart/form-data")
      m.set_content_object(mp) | stop("Failed to set_content_object:", &why)
      return m
   end

   public reset_form()
      every (!items).reset_form()
   end

   public submit(ev, src)
      local c
      \url | fail
      # Validate form.
      every c := !items do
         c.validate_form() | {
            if is(c, Component) then
               browser.parent_dialog.set_focus(c.gen_focusable())
            browser.msg("Invalid form: " || &why)
            fail
         }

      if method == "post" then {
         if map(enctype) == "multipart/form-data" then
            browser.goto(url, browser.page_url, make_cgi_message(ev, src))
         else 
            browser.goto(url, browser.page_url, make_cgi_table(ev, src))
      } else
         browser.goto(url.with_cgi_parameters(make_cgi_table(ev, src)), browser.page_url)
   end

   public add(name, item)
      put(items, item)
      item.form_name := name
   end

   public add_component(context, el, item)
      local l
      put(items, item)
      if el.get_attribute(u"AUTOFOCUS") then
         autofocus := item
      item.form_name := el.get_attribute(u"NAME")
      if item.form_id := el.get_attribute(u"ID") then
         insert(id_table, item.form_id, item)
      item.form_save_key := Class.get_name(item) || u":" || (\item.form_name | \item.form_id | u"?") || u":" || *items
      item.form_tabindex := integer(el.get_attribute(u"TABINDEX"))
      l := context.form_label
      # If we have a label in the context, and the for and id tags
      # make sense, link the component item to the label.
      if \l & (/l.id | /item.form_id | l.id == item.form_id) then
         /l.comp := item
   end

   public get_item_by_id(id)
      return member(id_table, id)
   end

   public get_autofocus()
      return \autofocus
   end

   public get_cbg(name)
      local x
      (x := member(cbgs, name)) | insert(cbgs, name, x := CheckBoxGroup())
      return x
   end

   public get_tab_children()
      local l, c
      l := []
      every c := !items do {
         if is(c, Component) then {
            if /c.form_tabindex | (c.form_tabindex >= 0) then
               put(l, c)
         }
      }
      return isort(l, tabindex_sort)
   end

   private tabindex_sort(c)
      return \c.form_tabindex | keyof(items, c)
   end

   public get_save_key()
      return save_key
   end

   public resolve_labels()
      local l
      every l := !labels do
         /l.comp := get_item_by_id(\l.id)
   end

   public new(browser, save_key, id, url, method, enctype)
      self.browser := browser
      self.save_key := save_key
      self.id := id
      self.url := url
      self.method := method
      self.enctype := enctype
      self.items := []
      self.labels := []
      self.id_table := table()
      self.cbgs := table()
      return
   end
end

package record TableContext(tbl, caption, x, y, occ, cell_border, tr, rowgroups, colgroups, curr_colgroup)
package record TableColGroup(align, valign, width, span, cols)
package record TableCol(align, valign, width, span)
package record ListContext(tbl, index, type, kind)
package record DefListContext(tbl)
package record FieldSetContext(legend)
package record MapContext(map)
package record SelectContext(options, optgroup)
package record DataListContext(options)
package record Context(form, form_label, title, url, fg, font, align, pre, nowrap, underline, strike, underdash, mark,
                       family, size, bold, italic, table, list, def_list, fieldset, select, map, datalist)

class MapArea()
   public const
      shape, coords, url, title

   public contains(x, y)
      return case shape of {
         "rect": check_rect(x, y)
         "poly": check_poly(x, y)
         "circle": check_circle(x, y)
         "default": &null
      }
   end

   private check_rect(x, y)
      return (coords[1] <= x <= coords[3]) & (coords[2] <= y <= coords[4])
   end

   private check_circle(x, y)
      return (x - coords[1]) ^ 2 + (y - coords[2]) ^ 2 <= coords[3] ^ 2
   end

   # Adapted from :-
   # http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
   #
   private check_poly(x, y)
      local i, j, n, c, xi, yi, xj, yj, b1, b2
      if *coords % 2 = 1 | *coords < 6 then
         fail
      j := n := *coords / 2
      c := 0
      every i := 1 to n do {
         xi := coords[2 * i - 1]
         yi := coords[2 * i]
         xj := coords[2 * j - 1]
         yj := coords[2 * j]
         b1 := if yi > y then 1 else 0
         b2 := if yj > y then 1 else 0
         if b1 ~= b2 & (x < (xj - xi) * (y - yi) / (yj - yi) + xi) then
            c +:= 1
         j := i
      }
      return c % 2 = 1
   end

   public new(shape, coords, url, title)
      self.shape := shape
      self.coords := coords
      self.url := url
      self.title := title
      return
   end
end

class Map()
   private const
      l

   public gen_areas()
      suspend .!l
   end

   public which_area(x, y)
      local e
      every e := !l do {
         if e.contains(x, y) then
            return e
      }
   end

   public add_area(area)
      put(l, area)
      return self
   end

   public new()
      l := []
      return
   end
end

record HistoryEntry(url,          # URL displayed (on a redirect may differ from that requested) 
                    title,        # Page title
                    referer,      # referer URL
                    form_values,  # Cached values of form components; updated when we move away from the page 
                    form_data,    # POST data used to get the page; on a redirect will always be null
                    focus_index,  # Index of focused component on moving away
                    last_highlight_component_index,  # Child index of last_highlight_component
                    last_highlight_index,            # Index of last_highlight within last_highlight_component
                    last_highlight,                  # Last highlight URL
                    area_x,
                    area_y
                    ) 

abstract class BrowserUI()
   public abstract msg(s, n)
   public abstract page_loaded()
   public abstract page_fully_loaded()
   public abstract update_grey(gs)
   public abstract link_left_clicked(url)
   public abstract link_middle_clicked(url)
   public abstract create_link_menu(url)
   public abstract create_page_menu()
   public abstract create_image_menu(img)
   public abstract browse_for_file(s)
   public abstract is_visited(url)
   public abstract display_search()
   public abstract display_externally(res)
   public abstract goto_externally(url)
   public abstract save_attachment(file, res)
end

package class BrowserPrimarySelectionOwner(TextSelectionOwner)
   private parent

   protected get_text()
      return \parent.primary
   end

   public lost_ownership()
      parent.on_lost_primary_ownership()
   end

   public new(parent)
      self.parent := parent
      return
   end
end

record GreyState(prev, nxt, history, refresh, copy_page, save_page, stop, copy_text, copy_links)

class Browser(ComponentScrollArea, WorkerPoolOwner)
   private
      ui,
      shared_worker_pool_flag,
      status_ticker,
      maps,
      datalists,
      forms,
      form_tab_children,
      scroll_ticker,
      scroll_ticker_interval,
      h_direction,
      v_direction,
      primary_selection_owner,
      outermost_border,
      tidy_cache_task

   private readable
      history,
      history_pos,
      history_size,
      curr_history_entry,   # History entry currently being viewed.  Note this may not be history[history_pos]
                            # if we've just done a navigation to a slowly loading page.  It may even be &null
                            # on a new browser or one with a cloned history.
      worker_pool,
      page_url,
      page_data,
      page_name,
      page_title,
      page_links,
      page_base,
      page_resp,
      page_charset,
      page_text_color,
      page_link_color,
      page_alink_color,
      page_vlink_color,
      page_favicon_resp,
      page_favicon_url,
      running,
      primary,
      mark_x,
      mark_y,
      cursor_x,
      cursor_y,
      banded,
      searched,                # Map of TextOut to list of TextSelection, giving the highlighted
                               # search result elements for each TextOut.
      sorted_searched,         # List of SearchMatch
      highlighted_searched,    # SearchMatch, one of sorted_searched, currently the highlighted search
      searched_term,           # List of words being searched for.
      text_selection,
      links_selection,
      done_set_top_data,
      last_highlight_component,
      font_factor

   public static const 
      COLORS,
      SIZES,
      SCROLL_INCREMENT,
      DEFAULT_HISTORY_SIZE,
      TABLE_TAG

   private static const
      default_font_clone

   private static init()
      local t
      COLORS := table(,
                      "aliceblue", "#F0F8FF",
                      "antiquewhite", "#FAEBD7",
                      "aqua", "#00FFFF",
                      "aquamarine", "#7FFFD4",
                      "azure", "#F0FFFF",
                      "beige", "#F5F5DC",
                      "bisque", "#FFE4C4",
                      "black", "#000000",
                      "blanchedalmond", "#FFEBCD",
                      "blue", "#0000FF",
                      "blueviolet", "#8A2BE2",
                      "brown", "#A52A2A",
                      "burlywood", "#DEB887",
                      "cadetblue", "#5F9EA0",
                      "chartreuse", "#7FFF00",
                      "chocolate", "#D2691E",
                      "coral", "#FF7F50",
                      "cornflowerblue", "#6495ED",
                      "cornsilk", "#FFF8DC",
                      "crimson", "#DC143C",
                      "cyan", "#00FFFF",
                      "darkblue", "#00008B",
                      "darkcyan", "#008B8B",
                      "darkgoldenrod", "#B8860B",
                      "darkgray", "#A9A9A9",
                      "darkgreen", "#006400",
                      "darkkhaki", "#BDB76B",
                      "darkmagenta", "#8B008B",
                      "darkolivegreen", "#556B2F",
                      "darkorange", "#FF8C00",
                      "darkorchid", "#9932CC",
                      "darkred", "#8B0000",
                      "darksalmon", "#E9967A",
                      "darkseagreen", "#8FBC8F",
                      "darkslateblue", "#483D8B",
                      "darkslategray", "#2F4F4F",
                      "darkturquoise", "#00CED1",
                      "darkviolet", "#9400D3",
                      "deeppink", "#FF1493",
                      "deepskyblue", "#00BFFF",
                      "dimgray", "#696969",
                      "dimgrey", "#696969",
                      "dodgerblue", "#1E90FF",
                      "firebrick", "#B22222",
                      "floralwhite", "#FFFAF0",
                      "forestgreen", "#228B22",
                      "fuchsia", "#FF00FF",
                      "gainsboro", "#DCDCDC",
                      "ghostwhite", "#F8F8FF",
                      "gold", "#FFD700",
                      "goldenrod", "#DAA520",
                      "gray", "#808080",
                      "green", "#008000",
                      "greenyellow", "#ADFF2F",
                      "honeydew", "#F0FFF0",
                      "hotpink", "#FF69B4",
                      "indianred", "#CD5C5C",
                      "indigo", "#4B0082",
                      "ivory", "#FFFFF0",
                      "khaki", "#F0E68C",
                      "lavender", "#E6E6FA",
                      "lavenderblush", "#FFF0F5",
                      "lawngreen", "#7CFC00",
                      "lemonchiffon", "#FFFACD",
                      "lightblue", "#ADD8E6",
                      "lightcoral", "#F08080",
                      "lightcyan", "#E0FFFF",
                      "lightgoldenrodyellow", "#FAFAD2",
                      "lightgray", "#D3D3D3",
                      "lightgreen", "#90EE90",
                      "lightpink", "#FFB6C1",
                      "lightsalmon", "#FFA07A",
                      "lightseagreen", "#20B2AA",
                      "lightskyblue", "#87CEFA",
                      "lightslategray", "#778899",
                      "lightsteelblue", "#B0C4DE",
                      "lightyellow", "#FFFFE0",
                      "lime", "#00FF00",
                      "limegreen", "#32CD32",
                      "linen", "#FAF0E6",
                      "magenta", "#FF00FF",
                      "maroon", "#800000",
                      "mediumaquamarine", "#66CDAA",
                      "mediumblue", "#0000CD",
                      "mediumorchid", "#BA55D3",
                      "mediumpurple", "#9370DB",
                      "mediumseagreen", "#3CB371",
                      "mediumslateblue", "#7B68EE",
                      "mediumspringgreen", "#00FA9A",
                      "mediumturquoise", "#48D1CC",
                      "mediumvioletred", "#C71585",
                      "midnightblue", "#191970",
                      "mintcream", "#F5FFFA",
                      "mistyrose", "#FFE4E1",
                      "moccasin", "#FFE4B5",
                      "navajowhite", "#FFDEAD",
                      "navy", "#000080",
                      "oldlace", "#FDF5E6",
                      "olive", "#808000",
                      "olivedrab", "#6B8E23",
                      "orange", "#FFA500",
                      "orangered", "#FF4500",
                      "orchid", "#DA70D6",
                      "palegoldenrod", "#EEE8AA",
                      "palegreen", "#98FB98",
                      "paleturquoise", "#AFEEEE",
                      "palevioletred", "#DB7093",
                      "papayawhip", "#FFEFD5",
                      "peachpuff", "#FFDAB9",
                      "peru", "#CD853F",
                      "pink", "#FFC0CB",
                      "plum", "#DDA0DD",
                      "powderblue", "#B0E0E6",
                      "purple", "#800080",
                      "red", "#FF0000",
                      "rosybrown", "#BC8F8F",
                      "royalblue", "#4169E1",
                      "saddlebrown", "#8B4513",
                      "salmon", "#FA8072",
                      "sandybrown", "#F4A460",
                      "seagreen", "#2E8B57",
                      "seashell", "#FFF5EE",
                      "sienna", "#A0522D",
                      "silver", "#C0C0C0",
                      "skyblue", "#87CEEB",
                      "slateblue", "#6A5ACD",
                      "slategray", "#708090",
                      "snow", "#FFFAFA",
                      "springgreen", "#00FF7F",
                      "steelblue", "#4682B4",
                      "tan", "#D2B48C",
                      "teal", "#008080",
                      "thistle", "#D8BFD8",
                      "tomato", "#FF6347",
                      "turquoise", "#40E0D0",
                      "violet", "#EE82EE",
                      "wheat", "#F5DEB3",
                      "white", "#FFFFFF",
                      "whitesmoke", "#F5F5F5",
                      "yellow", "#FFFF00",
                      "yellowgreen", "#9ACD32")

      t := Window.get_default_font_size()
      SIZES := [0.5 * t, 0.75 * t, t, 1.25 * t, 1.5 * t, 1.75 * t, 2.0 * t]
      ImageCache.name_image("rpp.BROKEN_LINK", BROKEN_LINK)
      default_font_clone := Window().set_font("sans")
      SCROLL_INCREMENT := env_scale("OI_BROWSER_SCROLL_INCREMENT") | scale(20)
      DEFAULT_HISTORY_SIZE := env_int("OI_BROWSER_DEFAULT_HISTORY_SIZE", 0) | 100
      TABLE_TAG := "<table cellspacing=4>"
   end

   public get_map(s)
      return member(maps, s)
   end

   public get_datalist(s)
      return member(datalists, s)
   end

   public set_last_highlight(c, u)
      if c ~=== \last_highlight_component then
         last_highlight_component.set_last_highlight()
      last_highlight_component := c
      last_highlight_component.set_last_highlight(u)
      return self
   end

   private convert_color(el, name)
      local s
      if s := el.get_attribute(name) then {
         return if s[1] == "#" then
            s
         else
            member(COLORS, map(trim(string(s))))
      }
   end

   public traverse_tab_order()
      coact(self)
      every (!self.form_tab_children).traverse_tab_order()
   end

   private synch_font(context)
      local s
      s := context.family
      if \context.bold then
         s ||:= ",bold"
      if \context.italic then
         s ||:= ",italic"
      s ||:= "," || (SIZES[context.size] * font_factor)
      context.font := s
   end

   private status()
      local i, r, s, l
      repeat {
         status_ticker.sleep(200)
         i := worker_pool.count(self)
         if (i > 0) | (i ~=== running) then {
            if i = 0 then {
               msg("Done", 1500)
               # This flag will be &null if we haven't called
               # set_top_data; this may happen if we cancel a
               # request before downloading the top page data; in
               # that case there is no need to do anything.
               if \done_set_top_data then {
                  done_set_top_data := &null
                  page_fully_loaded()
               }
            } else {
               r := worker_pool.read(self)
               s := i || " running requests"
               if r > 0 then {
                  if l := (0 < worker_pool.length(self)) then
                     s ||:= ", read " || r || " of " || l || " bytes (" || ((r * 100) / l) || "%)"
                  else
                     s ||:= ", read " || r || " bytes"
               }
               msg(s)
            }
            if i ~=== running then {
               running := i
               do_update_grey()
            }
         }
      }
   end

   public link_left_clicked(url)
      (\ui).link_left_clicked(url)
      return self
   end

   public link_middle_clicked(url)
      (\ui).link_middle_clicked(url)
      return self
   end

   public create_link_menu(url)
      return (\ui).create_link_menu(url)
   end

   public create_page_menu()
      return (\ui).create_page_menu()
   end

   public is_visited(url)
      return (\ui).is_visited(url)
   end

   public create_image_menu(img)
      return (\ui).create_image_menu(img)
   end

   public set_ui(ui)
      self.ui := ui
      return self
   end

   public msg(s, n)
      (\ui).msg(s, n)
      return self
   end

   public page_loaded()
      (\ui).page_loaded()
      return self
   end

   public update_grey(gs)
      (\ui).update_grey(gs)
      return self
   end

   public get_authentication(httpc, dom, realm)
      local d
      parent_dialog.exit_menu_mode()
      d := AuthenticationDialog(dom, realm)
      d.show_modal(parent_dialog)
      return \d.result
   end

   public do_update_grey()
      update_grey(GreyState(No { history_pos < *history },
                            No { history_pos > 1 },
                            Yes{ *history = 0 },
                            Yes{ /curr_history_entry },
                            Yes{ /page_url },
                            Yes{ /page_data },
                            Yes{ running === 0 },
                            Yes{ /text_selection },
                            Yes{ /links_selection }))
      return self
   end

   private page_fully_loaded()
      local xp, yp, f, k
      reset_all_layouts()
      layout()
      invalidate()
      k := page_resp.req.kind
      # Goto named anchor and maybe set focus unless user has started to scroll page
      if get_area_y() = get_area_x() = 0 then {
         # The test for Worker.NORMAL ensures that when we click on a
         # link to a page from within the page itself we reload and go
         # back to the top of the page.
         if yp := (k ~=== Worker.NORMAL & \curr_history_entry.area_y) | (lookup_named_anchor(page_url.get_fragment()) - view.y) then {
            set_area_y(yp)
            if xp := (k ~=== Worker.NORMAL & \curr_history_entry.area_x) then
               set_area_x(xp)
         }
         # If the user has placed the focus in a component in the new
         # page, just ensure it's still visible; otherwise set the
         # focus to any history/autofocus component; this will scroll
         # to the component if necessary (see focus_scroll).  Note
         # that if this browser's tab is not current, then the various
         # focus methods fail and no change to the focus is made.
         if view === (f := parent_dialog.get_focus()).gen_parents() then
            focus_scroll(, f)
         else if k === Worker.NAVIGATE then
            parent_dialog.set_focus(get_nth_focusable(\curr_history_entry.focus_index))
         else {
            if f := (!forms).get_autofocus() then
               parent_dialog.set_focus(f.gen_focusable())
         }
      }
      parent_dialog.resynch_pointer()
      (\ui).page_fully_loaded()
   end

   private lookup_named_anchor(name)
      local c, yp
      every c := Seq{traverse_postorder()} do
         if is(c,TextFlow) & yp := c.lookup_named_anchor(name) then
            return yp
   end

   public static limit_text(s, n)
      return gui.limit_text(default_font_clone, s, n)
   end

   public initially()
      ComponentScrollArea.initially()
      if /shared_worker_pool_flag then
         worker_pool.initially()
      status_ticker.start()
      tidy_cache_task.start()
      do_update_grey()
   end

   public finally()
      ComponentScrollArea.finally()
      if /shared_worker_pool_flag then
         worker_pool.finally()
      else
         worker_pool.cancel_all(self)
      running := 0
      scroll_ticker.stop()
      status_ticker.stop()
      tidy_cache_task.stop()
   end
   
   public do_next()
      local he
      (history_pos > 1) | fail
      he := history[history_pos -:= 1] 
      goto(he.url, he.referer, he.form_data, Worker.NAVIGATE)
      do_update_grey()
      return self
   end

   public do_prev()
      local he
      (history_pos < *history) | fail
      he := history[history_pos +:= 1] 
      goto(he.url, he.referer, he.form_data, Worker.NAVIGATE)
      do_update_grey()
      return self
   end

   public do_jump(he)
      history_pos := keyof(history, he) | fail
      goto(he.url, he.referer, he.form_data, Worker.NAVIGATE)
      do_update_grey()
      return self
   end

   private redo_search()
      local c, i
      \searched_term | fail
      i := keyof(sorted_searched, highlighted_searched)
      clear(searched)
      sorted_searched := []
      every c := Seq{traverse_postorder()} do
         if is(c,TextFlow) then
            c.search(searched_term, searched, sorted_searched)
      qsort(sorted_searched, Point.cmp_yx)
      highlighted_searched := sorted_searched[\i] | &null
   end

   public do_search(s)
      local c, l
      s := map(s)
      l := ipl.pdco.List{words(s)}
      if *l > 0 then {
         searched_term := l
         clear(searched)
         sorted_searched := []
         every c := Seq{traverse_postorder()} do
            if is(c,TextFlow) then
               c.search(l, searched, sorted_searched)
         highlighted_searched := &null
         qsort(sorted_searched, Point.cmp_yx)
      } else
         clear_searched()
      refresh()
      return self
   end

   private clear_searched()
      clear(searched)
      searched_term := sorted_searched := highlighted_searched := &null
   end

   public goto_searched(n)
      local t
      t := (\sorted_searched)[n] | fail
      (\highlighted_searched).textflow.invalidate(highlighted_searched.get_bounds())
      highlighted_searched := t
      highlighted_searched.textflow.invalidate(highlighted_searched.get_bounds())
      ensure_region_visible(convert_to_area(highlighted_searched.get_bounds()).pad(scale(10), scale(30)))
      return self
   end

   private reset_history_pos()
      if history_pos ~=:= keyof(history, curr_history_entry) then
         do_update_grey()
      return self
   end

   public do_stop()
      cancel()
      # Since we may have done a navigate, then stopped it, we may as
      # well reset the history pos back to the thing we're viewing.
      reset_history_pos()
      return self
   end

   public do_refresh()
      \curr_history_entry | fail
      goto(curr_history_entry.url, curr_history_entry.referer, 
           curr_history_entry.form_data, Worker.REFRESH)
      return self
   end

   public browse_for_file(s)
      return (\ui).browse_for_file(s)
   end

   public display_externally(res)
      return (\ui).display_externally(res)
   end

   public goto_externally(url)
      return (\ui).goto_externally(url)
   end

   public save_attachment(file, res)
      return (\ui).save_attachment(file, res)
   end

   public cancel()
      worker_pool.cancel_all(self)
      return self
   end

   private enqueue(req)
      worker_pool.enqueue(req)
      running := &null
   end

   private static is_image(ct, s)
      if map((\ct).type) == "image" then
         return
      return match("\x89PNG\x0D\x0A\x1A\x0A" |
                   "\xFF\xD8" |
                   "GIF87a" | "GIF89a", s)
   end

   private static is_text(ct, s)
      \ct | fail
      if (map(ct.type) == "text") |
         (map(ct.type) == "application" & map(ct.subtype) == "json") then
         return
   end

   private static is_html(ct, s)
      if map((\ct).subtype) == "html" then
         return
      s ? {
         while tab(upto('<')) do {
            if caseless_match("<!doctype" | "<html" | "<meta") then
               return
            # Expect html comment (see htmlparser.icn)
            ="<!" | fail
            =(">" | "->" | "-->" | "--->") | {
               ="--"
               tab(find("-->")) | fail
            }
         }
      }
   end

   private save_form_values()
      local f, c, t1, t2
      t1 := table()
      every f := !forms do {
         t2 := table()
         insert(t1, f.get_save_key(), t2)
         every c := !f.items do
            insert(t2, c.get_save_key(), c.get_save_value())
      }
      curr_history_entry.form_values := t1
   end

   private restore_last_highlight()
      local c
      if c := get_nth_child(\curr_history_entry.last_highlight_component_index) &
         is(c, HasLastHighlight) &
         c.restore_last_highlight(\curr_history_entry.last_highlight_index, \curr_history_entry.last_highlight) then
         last_highlight_component := c
   end

   private restore_form_values()
      local f, c, t1, t2
      t1 := \curr_history_entry.form_values | fail
      every f := !forms do {
         if t2 := member(t1, f.get_save_key()) then {
            every c := !f.items do
               c.restore_value(member(t2, c.get_save_key()))
         }
      }
   end

   public static to_content(s)
      local t, ch
      t := ""
      string(s) ? repeat {
         t ||:= tab(upto('<&') | 0)
         ch := move(1) | break
         t ||:= case ch of {
            "<": "&lt;"
            "&": "&amp;"
         }
      }
      return t
   end

   public static to_attr(s)
      local t, ch
      t := ""
      string(s) ? repeat {
         t ||:= tab(upto('\"\'&') | 0)
         ch := move(1) | break
         t ||:= case ch of {
            "\"": "&quot;"
            "\'": "&apos;"
            "&": "&amp;"
         }
      }
      return t
   end

   public static mk_anchor(url, lim)
      local s1, s2
      /lim := scale(1000)
      s1 := s2 := url.str()
      s2 := limit_text(s2, lim)
      return "<a href=\"" || to_attr(s1) || "\">" || Browser.to_content(s2) || "</a>"
   end

   public static mk_anchor_cell(url, lim)
      return "<td nowrap>" || mk_anchor(url, lim) || "</td>"
   end

   private get_nth_focusable(n)
      local c
      every c := view.gen_focusable() do {
         n -:= 1
         if n = 0 then
            return c
      }
   end

   private get_focusable_index(focus)
      local n, c
      n := 0
      every c := view.gen_focusable() do {
         n +:= 1
         if focus === c then
            return n
      }
   end

   private get_nth_child(n)
      local c
      every c := Seq{view.traverse_preorder()} do {
         n -:= 1
         if n = 0 then
            return c
      }
   end

   private get_child_index(child)
      local n, c
      n := 0
      every c := Seq{view.traverse_preorder()} do {
         n +:= 1
         if child === c then
            return n
      }
   end

   # Set a border around the outermost (top level) `TextFlow`; by
   # default this is a `NullBorder`.
   #
   public set_outermost_border(b)
      self.outermost_border := b
      return self
   end

   # Convert string s to ucs based on charset cs.  If cs is utf-8, or
   # unknown, then just fail (the conversion is done by the caller).
   private static convert_not_utf8(cs, s)
      local i
      map(cs) ? {
         if ="iso-8859-" & i := integer(tab(many(&digits))) then
            # This fails if i is an invalid number.
            return ISO8859.to_ucs(s, i)
      }
   end

   private static get_meta_charset(doc)
      local meta, cs, ct
      every meta := doc.get_root_element().search_tree(u"META") do
         if (map(meta.get_attribute(u"HTTP-EQUIV")) == u"content-type" &
                 ct := ContentType.parse_rfc2616(string(meta.get_attribute(u"CONTENT"))) & 
                 cs := ct.get_parameter("charset")) |
             (cs := string(meta.get_attribute(u"CHARSET"))) then 
            return cs
   end

   private set_top_data(res)
      local doc, s, row, c, cu, id, cs, s2, cd, file
      if \res.err & /res.data then {
         s := "<html><title>Error</title>" || 
            "<h1>Error:</h1>Getting " || mk_anchor(res.url) || "<br><br>" || res.err || "</html>"
         page_data := &null
      } else {
         if cd := \res.content_disposition & map(cd.get_type()) == "attachment" then {
            file := cd.get_filename() | res.fname
            save_attachment(file, res)
            return
         } else if is_html(res.content_type, res.data) then
            s := res.data
         else if is_text(res.content_type, res.data) then
            s := "<html><title>" || to_content(res.fname) || "</title>" || 
               "<pre>" || to_content(res.data) || "</pre></html>"
         else if is_image(res.content_type, res.data) then {
            cu := worker_pool.cache.create_url(, res.data, res.fname, res.content_type)
            s := "<html><title>" || to_content(res.fname) || "</title><img src=\"" || to_attr(cu.str()) || "\""
            # Set width and height param if possible; this allows the
            # image to display before any favicon is loaded.
            if id := detect(res.data) then
               s ||:= " width=" || id.width || " height=" || id.height
            s ||:= "/></html>"
         } else if display_externally(res) then
            return
         else
            s := "<html><title>Problem</title>" || 
               "<h1>Problem:</h1>Displaying " || mk_anchor(res.url) || "<br><br>This does not seem to be an HTML or text document or an image, or an externally viewable object</html>"
         page_data := res.data
      }
      if \curr_history_entry then {
         save_form_values()
         curr_history_entry.area_x := get_area_x()
         curr_history_entry.area_y := get_area_y()
         curr_history_entry.focus_index := get_focusable_index(parent_dialog.get_focus()) | &null
         # Save last highlight stuff
         curr_history_entry.last_highlight_component_index := 
            curr_history_entry.last_highlight_index := curr_history_entry.last_highlight := &null
         if curr_history_entry.last_highlight_component_index := get_child_index(\last_highlight_component) then
            last_highlight_component.save_last_highlight(curr_history_entry)
      }
      set_area_y(0)
      set_area_x(0)
      page_name := res.fname
      page_resp := res
      page_url := res.url
      clear_searched()
      if res.req.kind === Worker.NORMAL &
         not URL.equiv(history[history_pos].url, page_url) then
      {
         every 1 to history_pos - 1 do
            pop(history)
         # Fields are set below
         push(history, HistoryEntry())
         history_pos := 1
         while *history > history_size do
            pull(history)
      }
      curr_history_entry := history[history_pos]
      # Note that the url/form_data may change even on a
      # navigate/refresh, if the server behaved differently (eg
      # redirect instead of error).
      curr_history_entry.url := page_url
      curr_history_entry.referer := res.req.referer
      curr_history_entry.form_data := if URL.equiv(page_url, res.req.url) then res.req.form_data else &null
      do_update_grey()

      maps := table()
      datalists := table()
      forms := []
      form_tab_children := []
      # Check for content type charset in metadata
      if cs := (\res.content_type).get_parameter("charset") then {
         page_charset := cs || " (from metadata)"
         s2 := convert_not_utf8(cs, s) | Text.liberal_ucs(s)
         doc := HtmlParser().parse(s2)
      } else {
         # No charset info, so assume ucs to start with.
         page_charset := "UTF-8 (assumed)"
         s2 := Text.liberal_ucs(s)
         doc := HtmlParser().parse(s2)
         # Check for meta tag content attribute
         if cs := get_meta_charset(doc) then {
            page_charset := cs || " (from META tag)"
            if s2 := convert_not_utf8(cs, s) then {
               # Our assumption of ucs was wrong, so re-parse.
               doc := HtmlParser().parse(s2)
            }
         }
      }

      page_base := page_url
      row := TextFlow(self).
         set_border(outermost_border)
      page_favicon_resp := page_favicon_url := page_title := &null
      page_links := []
      page_alink_color := Style.FOCUS_COLOR
      page_vlink_color := "#800080"
      page_link_color := "blue"
      page_text_color := "black"
      c := Context()
      c.family := "sans"
      c.fg := page_text_color
      c.size := 3
      c.align := Align.L
      synch_font(c)
      traverse(doc, row, c)
      if \page_data then
         get_favicon()
      curr_history_entry.title := page_title
      if page_resp.req.kind === Worker.NAVIGATE then
         restore_form_values()
      every form_tab_children |||:= (!forms).get_tab_children()
      set_inner(row)
      layout()
      invalidate()
      last_highlight_component := &null
      if page_resp.req.kind === Worker.NAVIGATE then
         restore_last_highlight()
      parent_dialog.resynch_pointer()
      setup_tabbing()
      page_loaded()
      done_set_top_data := &yes
   end

   private focus_scroll(e, c)
      local d
      # Try and find a parent component which has this component as
      # its preferred focus (eg a Spin with a TextField); if found
      # then make the (larger) parent visible, rather than the child.
      every d := c.parent.gen_parents() do {
         if d.get_preferred_focus() === c then {
            c := d
            break
         }
      }
      ensure_region_visible(convert_to_area(c).pad(scale(10), scale(30)))
   end

   private setup_tabbing()
      local c
      every c := Seq{(!self.form_tab_children).traverse_tab_order()} do {
         # Note that c may be hidden (since the browser tab may be not
         # be the current one), so the test is not the same as say in
         # find_focus().
         if c.accepts_focus() & c.is_unshaded() then
            c.connect(focus_scroll, Event.GOT_FOCUS)
      }
   end

   private mk_link(s)
      return URL(s) | page_base.get_relative(s)
   end

   private traverse_a(e, p, context)
      local url, c, na
      if na := e.get_attribute(u"NAME") then {
         put(p.input, NamedAnchorCmd(na, context))
         traverse(e, p, context)
      }
      else if url := mk_link(e.get_attribute(u"HREF")) then {
         put(page_links, url)
         c := copy(context)
         c.url := url
         c.fg := if is_visited(url) then page_vlink_color else page_link_color
         traverse(e, p, c)
      } else
         traverse(e, p, context)
   end

   private check_id(e, p, context)
      local id
      if id := e.get_attribute(u"ID") then
         put(p.input, NamedAnchorCmd(id, context))
   end

   private traverse_hN(e, p, context)
      local c
      put_para1(e, p, context)
      c := copy(context)
      c.size := 7 - e.name[-1]
      c.bold := &yes
      synch_font(c)
      traverse(e, p, c)
      put_para(p, c)
   end

   private parse_size(s, curr)
      local i
      i := if any('+\-', s[1]) then
         curr + integer(s)
      else
         integer(s)
      return (0 < \i <= 7, i)
   end

   private static valid_family(fam)
      local w
      return use {
         w := Window(),
         w.set_font(fam) & fam
      }
   end

   private static select_family(faces)
      local e
      every e := map(trim(separate(string(faces)))) do {
         # If we have one of the four standard families (or their html
         # equivalent names), return that.
         if e := case e of {
            "serif": "serif"
            "sans"|"sans-serif": "sans"
            "mono"|"monospace": "mono"
            "typewriter": "typewriter"
         } then
            return e
         # If the face is usable as a family, return it.
         if valid_family(e) then
            return e
      }
      # Having failed with all alternatives, try a mapping of common
      # families based on the last family in the input list.
      if e := case e of {
         "cursive"|"fantasy"|"times"|"times new roman": "serif"
         "helvetica"|"arial": "sans"
         "courier": "typewriter"
      } then
         return e
   end

   private traverse_font(e, p, context)
      local c
      c := copy(context)
      c.fg := convert_color(e, u"COLOR")
      c.family := select_family(e.get_attribute(u"FACE"))
      c.size := parse_size(e.get_attribute(u"SIZE"), c.size)
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_tt(e, p, context)
      local c
      c := copy(context)
      c.family := "mono"
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_big(e, p, context)
      local c
      c := copy(context)
      if c.size < 7 then {
         c.size +:= 1
         synch_font(c)
      }
      traverse(e, p, c)
   end

   private traverse_small(e, p, context)
      local c
      c := copy(context)
      if c.size > 1 then {
         c.size -:= 1
         synch_font(c)
      }
      traverse(e, p, c)
   end

   private traverse_sup(e, p, context)
      local c
      c := copy(context)
      if c.size > 1 then {
         c.size -:= 1
         synch_font(c)
      }
      put(p.input, SupStartCmd(c))
      traverse(e, p, c)
      put(p.input, SupEndCmd(c))
   end

   private traverse_sub(e, p, context)
      local c
      c := copy(context)
      if c.size > 1 then {
         c.size -:= 1
         synch_font(c)
      }
      put(p.input, SubStartCmd(c))
      traverse(e, p, c)
      put(p.input, SubEndCmd(c))
   end

   private traverse_b(e, p, context)
      local c
      c := copy(context)
      c.bold := &yes
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_i(e, p, context)
      local c
      c := copy(context)
      c.italic := &yes
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_mark(e, p, context)
      local c
      c := copy(context)
      c.mark := &yes
      traverse(e, p, c)
   end

   private traverse_address(e, p, context)
      local c
      c := copy(context)
      c.italic := &yes
      synch_font(c)
      put_new_row1(e, p, c)
      traverse(e, p, c)
      put_new_row(p, c)
   end

   private traverse_u(e, p, context)
      local c
      c := copy(context)
      c.underline := &yes
      traverse(e, p, c)
   end

   private traverse_s(e, p, context)
      local c
      c := copy(context)
      c.strike := &yes
      traverse(e, p, c)
   end

   private traverse_form(e, p, context)
      local m, c, t, url, id, save_key
      m := map(string(e.get_attribute(u"METHOD"))) | "get"
      t := string(e.get_attribute(u"ENCTYPE")) | "application/x-www-form-urlencoded"
      url := mk_link(e.get_attribute(u"ACTION"))
      id := e.get_attribute(u"ID" | u"NAME")
      save_key :=  (\id | (\url).ucs() | u"?") || u":" || (*forms + 1)
      c := copy(context)
      c.form := Form(self, save_key, id, url, m, t)
      put(forms, c.form)
      put_new_row1(e, p, c)
      traverse(e, p, c)
      put_new_row(p, c)
      c.form.resolve_labels()
   end

   private traverse_label(e, p, context)
      local c, l, id
      \context.form | fail
      id := e.get_attribute(u"FOR")
      l := FormLabel(id, context.form)
      put(context.form.labels, l)
      c := copy(context)
      c.form_label := l
      traverse(e, p, c)
   end

   private dump_forms()
      local f, i
      every f := !forms do {
         every write(to_string(f,3,,1))
         every i := !f.items do {
            write("\t",image(i.form_id), "->", to_string(i,3,,0))
         }
      }
   end

   private add_component(p, c, context, align)
      /align := "absbottom"
      put(p.input, ComponentCmd(c, context, align))
      c.set_tooltip(context.title).
         set_fg(context.fg).
         set_font(context.font)
      p.add(c)
   end

   private traverse_button(e, p, context)
      local q, v, type
      \context.form | fail
      v := e.get_attribute(u"VALUE") | u""
      type := map(string(e.get_attribute(u"TYPE"))) | "submit"
      q := FormTextFlowButton(context.form, v, type)
      add_form_component(e, p, q, context)
      traverse(e, q.tf, context)
   end

   private traverse_img(e, p, context)
      local q, url, border, align, map, s, alt, hspace, vspace
      url := mk_link(e.get_attribute(u"SRC")) | fail
      if (s := e.get_attribute(u"USEMAP")) & (s[1] == u"#") then
         map := default.map(string(s[2:0]))
      alt := e.get_attribute(u"ALT")
      q := Img(self, context, url, alt,, map)
      do_width_param(e, q)
      do_height_param(e, q)
      # % width not allowed if no breaking mode, since it
      # would mean we couldn't calculate the blob widths in
      # the row (and hence the preferred width of the
      # TextFlow).
      if \context.nowrap | \context.pre then
         q.remove_constraint("pct_w")
      border := scale(0 < integer(e.get_attribute(u"BORDER"))) | 0
      hspace := scale(0 < integer(e.get_attribute(u"HSPACE"))) | 0
      vspace := scale(0 < integer(e.get_attribute(u"VSPACE"))) | 0
      if (hspace | vspace) > 0 then {
         if border > 0 then
            q.set_border(CompoundBorder().
                            set_outer(EmptyBorder().set_insets(hspace, hspace, vspace, vspace)).
                            set_inner(PlainBorder().set_line_width(border)))
         else
            q.set_border(EmptyBorder().set_insets(hspace, hspace, vspace, vspace))
      } else if border > 0 then
         q.set_border(PlainBorder().set_line_width(border))
      enqueue(Req(self, url, page_url, q.got_data, page_resp.req.kind))
      align := convert_comp_align(e, u"ALIGN") | Align.B
      add_component(p, q, context, align)
   end

   private add_form_component(e, p, q, context)
      if e.get_attribute(u"DISABLED") then
         q.set_is_shaded(&yes)
      else
         context.form.add_component(context, e, q)
      add_component(p, q, context, Align.B)
   end

   private traverse_select(e, p, context)
      local q, c, sc, size, mW, h, w, o, sel, sels, i, mode
      \context.form | fail
      sc := SelectContext()
      sc.options := []
      sc.optgroup := 0
      c := copy(context)
      c.select := sc
      traverse(e, p, c)
      sels := []
      every i := 1 to *sc.options do
         if \sc.options[i].selected then
            put(sels, i)
      if size := (1 < integer(e.get_attribute(u"SIZE"))) then {
         use {
            mW := cbwin.clone(),
            {
               mW.set_font(context.font)
               w := 0
               every o := !sc.options do
                  w <:= mW.text_width(o.txt)
               w +:= 2 * Gui.TEXT_INSET + 2 * Gui.BORDER_WIDTH
               h := (2 * Gui.BORDER_WIDTH + size * mW.get_line_height())
               if size < *sc.options then
                  w +:= ScrollArea.SCROLLBAR_SIZE
            }
         }
         if e.get_attribute(u"MULTIPLE") then
            mode := Select.MANY
         else {
            mode := Select.ONE
            while *sels > 1 do
               pull(sels)
         }
         q := FormOptionList(sels).
            set_contents(sc.options).
            set_size(w, h).
            set_select_mode(mode).
            set_selections(sels)
      } else {
         if *sels = 0 then {
            every i := 1 to *sc.options do
               if \sc.options[i].value then {
                  sel := i
                  break
               }
         } else
            sel := sels[1]
         q := FormList(sel).
            set_selection_list(sc.options).
            set_selection(sel)
      }
      add_form_component(e, p, q, context)
   end

   private traverse_option(e, p, context)
      local dc, sc, v, txt, label, disabled, selected
      if sc := \context.select then {
         label := e.get_trimmed_string_content()
         if e.get_attribute(u"DISABLED") then
            disabled := &yes
         else {
            v := e.get_attribute(u"VALUE") | label
            if e.get_attribute(u"SELECTED") then
               selected := &yes
         }
         txt := repl(u"    ", sc.optgroup) || label
         put(sc.options, FormOption(txt, label, v, selected, disabled))
      } else if dc := \context.datalist then {
         label := (u"" ~== e.get_trimmed_string_content())
         v := e.get_attribute(u"VALUE")
         /label := v
         /v := label
         if (not e.get_attribute(u"DISABLED")) & \label then
            put(dc.options, FormOption(label, label, v))
      }
   end

   private traverse_optgroup(e, p, context)
      local sc, label
      sc := \context.select | fail
      label := e.get_attribute(u"LABEL") | u""
      put(sc.options, FormOption(repl(u"    ", sc.optgroup) || u"--- " || label || u" ---", label,,,, &yes))
      sc.optgroup +:= 1
      traverse(e, p, context)
      sc.optgroup -:= 1
   end

   private traverse_textarea(e, p, context)
      local q, w, h, mW
      \context.form | fail
      use {
         mW := cbwin.clone(),
         {
            mW.set_font(context.font)
            w := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + mW.text_width(repl("x", integer(e.get_attribute(u"COLS"))))) | scale(200)
            h := (2 * Gui.BORDER_WIDTH + integer(e.get_attribute(u"ROWS")) * mW.get_line_height()) | scale(100)
         }
      }
      # The ucs conversion is used here since an empty node will return "" (not u"").
      strip_newlines(e)
      q := FormEditableTextList(ucs(e.get_trimmed_string_content())).
         set_size(w, h)
      if e.get_attribute(u"READONLY") then
         q.set_is_editable(&no)
      add_form_component(e, p, q, context)
   end

   private traverse_input(e, p, context)
      local q, s, k, v, size, mW, url, checked, align, min, max, step, alt, did
      \context.form | fail
      s := string(map(e.get_attribute(u"TYPE"))) | "text"
      case s of {
         "file": {
            use {
               mW := cbwin.clone(),
               {
                  mW.set_font(context.font)
                  size := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + mW.text_width(repl("x", integer(e.get_attribute(u"SIZE"))))) | scale(160)
               }
            }
            q := FormBrowse(self, size)
            add_form_component(e, p, q, context)
         }
         "submit" : {
            v := e.get_attribute(u"VALUE")
            if /v | (*v = 0) then
               v := u"Submit"
            q := FormButton(v).
                  connect(context.form.submit, Event.ACTION)
            add_form_component(e, p, q, context)
         }
         "button" : {
            v := e.get_attribute(u"VALUE") | u""
            q := FormButton(v)
            add_form_component(e, p, q, context)
         }
         "image" : {
            if url := mk_link(e.get_attribute(u"SRC")) then {
               alt := e.get_attribute(u"ALT")
               q := Img(self, context, url, alt, context.form)
               do_width_param(e, q)
               do_height_param(e, q)
               # % width not allowed if no breaking mode, since it
               # would mean we couldn't calculate the blob widths in
               # the row (and hence the preferred width of the
               # TextFlow).
               if \context.nowrap | \context.pre then
                  q.remove_constraint("pct_w")
               enqueue(Req(self, url, page_url, q.got_data, page_resp.req.kind))
               if e.get_attribute(u"DISABLED") then
                  q.set_is_shaded(&yes)
               else {
                  if k := e.get_attribute(u"NAME") then {
                     context.form.add(k || ".x", FormImgX(q))
                     context.form.add(k || ".y", FormImgY(q))
                  } else {
                     context.form.add("x", FormImgX(q))
                     context.form.add("y", FormImgY(q))
                  }
               }
               align := convert_comp_align(e, u"ALIGN") | Align.B
               add_component(p, q, context, align)
            }
         }
         "reset" : {
            v := e.get_attribute(u"VALUE")
            if /v | (*v = 0) then
               v := u"Reset"
            q := FormButton(v).
               connect(context.form.reset_form, Event.ACTION)
            add_form_component(e, p, q, context)
         }
         "hidden": {
            context.form.add(e.get_attribute(u"NAME"), Hidden(e.get_attribute(u"VALUE")))
         }
         "radio": {
            v := e.get_attribute(u"VALUE") | u"on"
            checked := Yes{ e.get_attribute(u"CHECKED") }
            q := FormToggle(v, checked).
               set_paint(ImagePaint().set_cache("gui.DIAMOND_UP")).
               set_paint_down(ImagePaint().set_cache("gui.DIAMOND_DOWN")).
               set_border(NullBorder())
            add_form_component(e, p, q, context)
            context.form.get_cbg(e.get_attribute(u"NAME")).add(q)
         }
         "checkbox": {
            v := e.get_attribute(u"VALUE") | u"on"
            checked := Yes{ e.get_attribute(u"CHECKED") }
            q := FormToggle(v, checked).
               set_paint(ImagePaint().set_cache("gui.BOX_UP")).
               set_paint_down(ImagePaint().set_cache("gui.BOX_DOWN")).
               set_border(NullBorder())
            add_form_component(e, p, q, context)
         }
         "date": {
            v := Time.parse(e.get_attribute(u"VALUE"), "yyyy-MM-dd") | Time()
            q := FormDateField(v)
            add_form_component(e, p, q, context)
         }
         "time": {
            v := FormTimeField.parse(e.get_attribute(u"VALUE")) | Time()
            q := FormTimeField(v)
            add_form_component(e, p, q, context)
         }
         "week": {
            v := FormWeekField.parse(e.get_attribute(u"VALUE")) | Time()
            q := FormWeekField(v)
            add_form_component(e, p, q, context)
         }
         "month": {
            v := FormMonthYearField.parse(e.get_attribute(u"VALUE")) | Time()
            q := FormMonthYearField(v)
            add_form_component(e, p, q, context)
         }
         "datetime": {
            v := FormDateTimeField.parse(e.get_attribute(u"VALUE")) | Time()
            q := FormDateTimeField(v)
            add_form_component(e, p, q, context)
         }
         "datetime-local": {
            v := FormDateTimeLocalField.parse(e.get_attribute(u"VALUE")) | Time()
            q := FormDateTimeLocalField(v)
            add_form_component(e, p, q, context)
         }
         "color": {
            v := FormColorField.parse(e.get_attribute(u"VALUE")) | "white"
            q := FormColorField(v)
            add_form_component(e, p, q, context)
         }
         "range": {
            min := numeric(e.get_attribute(u"MIN")) | 0
            v := e.get_attribute(u"STEP")
            step := if /v then 1 else if map(v) == u"any" then 1.0 else (0 < numeric(v)) | 1
            # If min and step are both integer, then the values must be too.
            if type(min) == type(step) == "integer" then {
               max := integer(e.get_attribute(u"MAX")) | (min + 10)
               v := integer(e.get_attribute(u"VALUE")) | min
            } else {
               min := real(min)
               step := real(step)
               max := real(e.get_attribute(u"MAX")) | (min + 10.0)
               v := real(e.get_attribute(u"VALUE")) | min
            }
            q := FormRange(v).
               set_range(min, max).
               set_snaps(step).
               set_is_horizontal(&yes).
               set_width(160)
            add_form_component(e, p, q, context)
         }
         "number": {
            min := numeric(e.get_attribute(u"MIN"))
            v := e.get_attribute(u"STEP")
            step := if /v then 1 else if map(v) == u"any" then 1.0 else (0 < numeric(v)) | 1
            # If min is null or integer, and step is integer, then the values must be integer too.
            if (/min | type(min) == "integer") & (type(step) == "integer") then {
               max := integer(e.get_attribute(u"MAX"))
               v := integer(e.get_attribute(u"VALUE")) | \min | 0
            } else {
               min := real(min)
               step := real(step)
               max := real(e.get_attribute(u"MAX"))
               v := real(e.get_attribute(u"VALUE")) | \min | 0.0
            }
            q := FormNumberField(v).
               set_range(min, max).
               set_increment_size(step)
            if /max then
               q.set_width(scale(100))
            add_form_component(e, p, q, context)
         }
         "url": {
            v := e.get_attribute(u"VALUE") | u""
            use {
               mW := cbwin.clone(),
               {
                  mW.set_font(context.font)
                  size := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + 
                           mW.text_width(repl("x", integer(e.get_attribute(u"SIZE"))))) | scale(160)
               }
            }
            q := FormURLField(v).
               set_width(size).
               connect(context.form.submit, Event.ACTION)
            if e.get_attribute(u"READONLY") then
               q.set_is_editable(&no)
            q.set_placeholder(e.get_attribute(u"PLACEHOLDER"))
            add_form_component(e, p, q, context)
         }
         # Assume something textual; could be password, text, email etc.
         default: {
            v := e.get_attribute(u"VALUE") | u""
            did := map(string(e.get_attribute(u"LIST")))
            use {
               mW := cbwin.clone(),
               {
                  mW.set_font(context.font)
                  size := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + 
                           mW.text_width(repl("x", integer(e.get_attribute(u"SIZE"))))) | scale(160)
               }
            }
            q := FormTextField(self, v, did).
               set_width(size).
               connect(context.form.submit, Event.ACTION)
            if s == "password" then
               q.set_displaychar("*")
            if e.get_attribute(u"READONLY") then
               q.set_is_editable(&no)
            q.set_placeholder(e.get_attribute(u"PLACEHOLDER"))
            add_form_component(e, p, q, context)
         }
      }
      traverse(e, p, context)
   end

   private show_parents(c)
      write("chain of ",image(c))
      while \c do {
         write("\tc=",image(c))
         c := c.parent
      }
   end

   private show_input(ii, l)
      local s,a
      case classof(ii) of {
         TextCmd: {
            s := ii.s
            if *s > 30 then 
               s[30:0] := "...("||*s||")"
            a := ""
            a ||:= "fg="|| \ii.attr.fg
            a ||:= " font="|| \ii.attr.font
            write(repl("   ",l), image(s),"  ",a) 
         }
         ComponentCmd: show_structure(ii.c, l)
         default: write(repl("   ",l),image(ii))
      }
   end

   private show_output(xo, l)
      local s,a
      s := "Text @"||xo.x||","||xo.y
      s ||:= xo.s
      if *s > 30 then 
         s[30:0] := "...("||*s||")"
      a := ""
      a ||:= "fg="|| \xo.attr.fg
      a ||:= " font="|| \xo.attr.font
      write(repl("   ",l), image(s),"  ",a) 
   end

   private show_structure(c, l)
      local s, v, short
      /l := 0
      short := s := ""
      short ||:= "w="||\c.w||" h="||\c.h
      if is(c, TextFlow) then short ||:= "  " || *c.input || " items"
      if c.get_constraint("eol") then s ||:= "eol "
      if \c.get_constraint("x_fill") then s ||:= "x_fill "
      if v := c.get_constraint("x_weight") then s ||:= "x_weight=" || v
      if v := c.get_constraint("x_align") then s ||:= "x_align=" || v
      write(repl("   ",l), image(c),short,"\t\t\t",s)
      if is(c, TextFlow) then {
         every show_input((!c.input), l+1)
      } else
         every show_structure((!c.children), l+1)
   end

   private traverse_div(e, p, context)
      put_new_row1(e, p, context)
      traverse(e, p, context)
   end

   private traverse_br(e, p, context)
      local clear
      clear := case string(map(e.get_attribute(u"CLEAR"))) of {
         "left": Align.L
         "right": Align.R
         "all"|"both": "all"
      }
      put(p.input, BreakCmd(clear, context))
   end

   private traverse_nobr(e, p, context)
      local c
      c := copy(context)
      c.nowrap := &yes
      traverse(e, p, c)
   end

   private traverse_hr(e, p, context)
      local l, c
      l := Line().
         set_width(1)
      do_width_param(e, l) | l.set_constraint("pct_w", 100)
      c := copy(context)
      put_new_row1(e, p, c)
      c.align := convert_halign(e, u"ALIGN") | Align.C
      add_component(p, l, c)
      put_new_row(p, c)
   end

   private traverse_q(e, p, context)
      put(p.input, TextCmd(u"\u201c", context))
      traverse(e, p, context)
      put(p.input, TextCmd(u"\u201d", context))
   end

   private traverse_p(e, p, context)
      local c
      c := copy(context)
      put_para1(e, p, c)
      c.align := convert_halign(e, u"ALIGN")
      traverse(e, p, c)
      put_para(p, c)
   end

   # Strip optional start and end newlines from the child content
   private static strip_newlines(e)
      local s
      text(e.children[1]) ? {
         if =(u"\n" | u"\r\n") then {
            s := tab(0)
            if *s = 0 then
               delete(e.children, 1)
            else
               e.children[1] := s
         }
      }
      text(e.children[-1]) ? {
         tab(0)
         if (move(-2) == u"\r\n") | (move(-1) == u"\n") then {
            s := tab(1)
            if *s = 0 then
               delete(e.children, -1)
            else
               e.children[-1] := s
         }
      }
   end

   private traverse_pre(e, p, context)
      local c
      put_para1(e, p, context)
      c := copy(context)
      c.family := "mono"
      strip_newlines(e)
      synch_font(c)
      c.pre := &yes
      traverse(e, p, c)
      put_para(p, c)
   end

   private put_para(p, context)
      put(p.input, ParaCmd(context))
   end

   private put_para1(e, p, context)
      put_para(p, context)
      check_id(e, p, context)
   end

   private put_new_row(p, context)
      put(p.input, NewRowCmd(context))
   end

   private put_new_row1(e, p, context)
      put_new_row(p, context)
      check_id(e, p, context)
   end

   private traverse_center(e, p, context)
      local c
      c := copy(context)
      c.align := Align.C
      put_new_row1(e, p, context)
      traverse(e, p, c)
      put_new_row(p, context)
   end

   private convert_valign(el, name)
      return case string(map(el.get_attribute(name))) of {
         "top": Align.T
         "middle": Align.C
         "bottom": Align.B
         "baseline": "baseline"
      }
   end

   private convert_halign(el, name)
      return case string(map(el.get_attribute(name))) of {
         "left": Align.L
         "center": Align.C
         "right": Align.R
      }
   end

   private convert_cap_align(el, name)
      return case string(map(el.get_attribute(name))) of {
         "left": Align.L
         "right": Align.R
         "top": Align.T
         "bottom": Align.B
      }
   end

   private convert_comp_align(el, name)
      return case map(string(el.get_attribute(name))) of {
         "left": Align.L
         "right": Align.R
         "baseline"|"bottom": Align.B
         "texttop"|"top": Align.T
         "middle" | "center" | "centre": Align.C
         "absbottom":  "absbottom"
         "absmiddle":  "absmiddle"
      }
   end

   private do_width_param(e, c, def_w)
      local width
      return if width := (e.get_attribute(u"WIDTH") | \def_w) then {
         if width := scale(0 <= integer(width)) then
            c.set_constraint("fix_w", width)
         else if width[-1] == "%" & width := (0 <= integer(width[1:-1])) then
            c.set_constraint("pct_w", width)
      }
   end

   private do_height_param(e, c)
      local height
      if height := scale(0 <= integer(e.get_attribute(u"HEIGHT"))) then
         return c.set_constraint("fix_h", height)
   end

   private traverse_table(e, p, context)
      local ct, tbl, border, hspace, vspace, cellpadding, cellspacing, cell_border, align, c, i, t

      tbl := Tbl()
      border := scale(0 < integer(e.get_attribute(u"BORDER"))) | 0
      # hspace, vspace are non-standard, but firefox has them.
      hspace := scale(0 < integer(e.get_attribute(u"HSPACE"))) | 0
      vspace := scale(0 < integer(e.get_attribute(u"VSPACE"))) | 0
      cellpadding := scale(0 < integer(e.get_attribute(u"CELLPADDING"))) | 0
      cellspacing := scale_even(0 <= integer(e.get_attribute(u"CELLSPACING")) | 4)

      tbl.content.layout_delegate.set_doi(cellspacing).set_dii(cellspacing / 2)
      tbl.set_bg(convert_color(e, u"BGCOLOR"))

      cell_border := if border > 0 & not(e.get_attribute(u"RULES")) then
         CompoundBorder().
            set_outer(PlainBorder().set_line_width(Gui.FINE_WIDTH)).
            set_inner(EmptyBorder().set_insets(cellpadding, cellpadding, cellpadding, cellpadding))
         else
            EmptyBorder().set_insets(cellpadding, cellpadding, cellpadding, cellpadding)
      # The align param is a bit of a hybrid.  If left or right, then
      # it behaves like a left/right aligned image.  If center, then
      # it is like enclosing the table in <center>.
      align := convert_halign(e, u"ALIGN")
      c := copy(context)
      c.align := (align === Align.C)
      c.table := ct := TableContext()
      ct.tbl := tbl
      ct.x := ct.y := 1
      ct.occ := set()
      ct.cell_border := cell_border
      ct.rowgroups := []
      ct.colgroups := []
      traverse(e, p, c)
      case string(map(e.get_attribute(u"RULES"))) of {
         "groups": {
            # NB - either of these lists may be empty
            tbl.content.set_hrules(set!ct.rowgroups[2:0])
            tbl.content.set_vrules(set!get_colgroup_cols(ct)[2:0])
         }
         "all": {
            i := 1
            every i <:= (!tbl.content.children).get_constraint("x")
            tbl.content.set_vrules(Set{2 to i})
            tbl.content.set_hrules(Set{2 to ct.y - 1})
         }
         "cols": {
            i := 1
            every i <:= (!tbl.content.children).get_constraint("x")
            tbl.content.set_vrules(Set{2 to i})
         }
         "rows": {
            tbl.content.set_hrules(Set{2 to ct.y - 1})
         }
      }

      if t := \c.table.caption then {
         if (hspace | vspace) > 0 then
            t.set_border(EmptyBorder().set_insets(hspace, hspace, vspace, vspace))
         if border > 0 then
            tbl.set_border(PlainBorder().set_line_width(border))
      } else {
         if (hspace | vspace) > 0 then {
            if border > 0 then
               tbl.set_border(CompoundBorder().
                              set_outer(EmptyBorder().set_insets(hspace, hspace, vspace, vspace)).
                              set_inner(PlainBorder().set_line_width(border)))
            else
               tbl.set_border(EmptyBorder().set_insets(hspace, hspace, vspace, vspace))
         } else if border > 0 then
            tbl.set_border(PlainBorder().set_line_width(border))
         t := tbl
      }

      do_width_param(e, t)
      do_height_param(e, t)

      if align === (Align.L | Align.R) then
         add_component(p, t, c, align)
      else {
         put_new_row1(e, p, c)
         add_component(p, t, c, Align.B)
         put_new_row(p, c)
      }
   end

   private traverse_tbody(e, p, context)
      local ct
      ct := \context.table | fail
      put(ct.rowgroups, ct.y)
      traverse(e, p, context)
   end

   private traverse_caption(e, p, context)
      local ct, cap, main, c, align
      ct := \context.table | fail
      /ct.caption | fail

      # A Tbl with two TextFlows; the caption and another containing just the table itself.
      ct.caption := Tbl()
      cap := TextFlow(self).set_dominant_width(TextFlow.PREFERRED_WIDTH)
      c := copy(context)
      c.align := Align.C
      traverse(e, cap, c)
      main := TextFlow(self)
      add_component(main, ct.tbl, context)
      ct.tbl.set_constraint("pct_w", 100)
      align := convert_cap_align(e, u"ALIGN") | Align.T
      case align of {
         Align.T: {
            cap.set_constraint("eol", &yes)
            ct.caption.content.add(cap).add(main)
         }
         Align.B: {
            main.set_constraint("eol", &yes)
            ct.caption.content.add(main).add(cap)
         }
         Align.L: {
            ct.caption.content.add(cap).add(main)
         }
         Align.R: {
            ct.caption.content.add(main).add(cap)
         }
      }
   end

   private traverse_colgroup(e, p, context)
      local ct, cg
      ct := \context.table | fail
      cg := TableColGroup()
      cg.span := (0 < integer(e.get_attribute(u"SPAN"))) | 1
      cg.width := e.get_attribute(u"WIDTH")
      cg.valign := convert_valign(e, u"VALIGN")
      cg.align := convert_halign(e, u"ALIGN")
      cg.cols := []
      put(ct.colgroups, cg)
      ct.curr_colgroup := cg
      traverse(e, p, context)
      ct.curr_colgroup := &null
   end

   private traverse_col(e, p, context)
      local ct, cg, tc
      ct := \context.table | fail
      cg := \ct.curr_colgroup | fail
      tc := TableCol()
      tc.span := (0 < integer(e.get_attribute(u"SPAN"))) | 1
      tc.width := e.get_attribute(u"WIDTH") | cg.width
      tc.valign := convert_valign(e, u"VALIGN") | cg.valign
      tc.align := convert_halign(e, u"ALIGN") | cg.align
      put(cg.cols, tc)
   end

   private traverse_tr(e, p, context)
      local ct
      ct := \context.table | fail
      ct.tr := e
      if ct.x > 1 then {
         ct.x := 1
         ct.y +:= 1
      }
      traverse(e, p, context)
      if ct.x > 1 then {
         ct.x := 1
         ct.y +:= 1
      }
      ct.tr := &null
   end

   private get_col_info(ct, n)
      local i, e, f
      i := 0
      every e := !ct.colgroups do {
         if *e.cols > 0 then {
            every f := !e.cols do {
               if i + f.span >= n then
                  return f
               i +:= f.span
            }
         } else {
            if i + e.span >= n then
               return e
            i +:= e.span
         }
      }
   end

   private get_colgroup_cols(ct)
      local i, e, l
      i := 1
      l := []
      every e := !ct.colgroups do {
         put(l, i)
         if *e.cols > 0 then
            every i +:= (!e.cols).span
         else
            i +:= e.span
      }
      return l
   end

   private traverse_td(e, p, context)
      local ct, row, c, colspan, rowspan, valign, col, def_w
      ct := \context.table | fail
      while member(ct.occ, ct.x || "," || ct.y) do
         ct.x +:= 1
      col := get_col_info(ct, ct.x)
      valign := convert_valign(e | \ct.tr, u"VALIGN") | \ (\col).valign | Align.C
      row := TextFlow(self).
         set_constraint("x", ct.x). 
         set_constraint("y", ct.y).
         set_border(ct.cell_border).
         set_v_align(valign)
      colspan := (0 < integer(e.get_attribute(u"COLSPAN"))) | 1
      row.set_constraint("w", colspan)
      rowspan := (0 < integer(e.get_attribute(u"ROWSPAN"))) | 1
      row.set_constraint("h", rowspan)
      row.set_bg(convert_color(e | \ct.tr, u"BGCOLOR"))
      every insert(ct.occ, (ct.x to ct.x + colspan - 1) || "," || (ct.y to ct.y + rowspan - 1))
      if colspan = 1 then
         def_w := (\col).width
      do_width_param(e, row, def_w)
      do_height_param(e, row)
      ct.tbl.content.add(row)

      c := copy(context)
      if e.get_attribute(u"NOWRAP") then
         c.nowrap := &yes
      if e.name == u"TH" then {
         c.bold := &yes
         c.size := min(c.size + 1, 7)
         synch_font(c)
         c.align := convert_halign(e | \ct.tr, u"ALIGN") | \ (\col).align | Align.C
      } else
         c.align := convert_halign(e | \ct.tr, u"ALIGN") | \ (\col).align | Align.L
      ct.x +:= colspan

      traverse(e, row, c)
   end

   private traverse_list(e, p, context)
      local tbl, lc, c
      tbl := Tbl()
      c := copy(context)
      lc := ListContext()
      lc.tbl := tbl
      lc.index := integer(e.get_attribute(u"START")) | 1
      lc.type := e.get_attribute(u"TYPE")
      lc.kind := e.name
      c.list := lc
      traverse(e, p, c)
      put_new_row1(e, p, c)
      add_component(p, tbl, context, Align.B)
      put_new_row(p, c)
   end

   private traverse_li(e, p, context)
      local lc, row, val, type, c
      lc := \context.list | fail
      row := TextFlow(self).set_v_align("baseline")
      type := e.get_attribute(u"TYPE") | lc.type
      if lc.kind == u"OL" then {
         val := integer(e.get_attribute(u"VALUE")) | lc.index
         if val > 0 then {
            val := case string(type) of {
               "a": map(alphaseq(val))
               "A": alphaseq(val)
               "i": map(roman(val))
               "I": roman(val)
            }
         }
         # Integers are right aligned, others left aligned.
         c := copy(context)
         c.align := if default.type(val) == "integer" then Align.R else Align.L
         put(row.input, TextCmd(val || u".\ua0\ua0\ua0", c))
         lc.index +:= 1
      } else {
         /type := "disc"
         val := case map(string(type)) of {
            "circle": u"o"
            "square": u"\u25ca"
            default: u"\u2022"
         }
         put(row.input, TextCmd(val || u"\ua0\ua0\ua0", context))
      }
      lc.tbl.content.add(row)
      row := TextFlow(self).
         set_trim(&no).
         set_v_align("baseline").
         set_constraint("eol", &yes)
      lc.tbl.content.add(row)
      traverse(e, row, context)
   end

   private traverse_dl(e, p, context)
      local tbl, dc, c
      tbl := Tbl()
      tbl.content.layout_delegate.set_fix_col1(&yes)
      dc := DefListContext()
      dc.tbl := tbl
      c := copy(context)
      c.def_list := dc
      traverse(e, p, c)
      put_new_row1(e, p, c)
      add_component(p, tbl, context, Align.B)
      put_new_row(p, c)
   end

   private traverse_dt(e, p, context)
      local dc, row
      dc := \context.def_list | fail
      row := TextFlow(self).
         set_trim(&no).
         set_constraint("eol", &yes).
         set_constraint("w", 2)
      dc.tbl.content.add(row)
      traverse(e, row, context)
   end

   private traverse_dd(e, p, context)
      local dc, row
      dc := \context.def_list | fail
      row := TextFlow(self).
         set_v_align("baseline").
         set_constraint("eol", &no)
      put(row.input, TextCmd(u"\ua0\ua0\ua0\ua0\ua0", context))
      dc.tbl.content.add(row)
      row := TextFlow(self).
         set_trim(&no).
         set_v_align("baseline").
         set_constraint("eol", &yes)
      dc.tbl.content.add(row)
      traverse(e, row, context)
   end

   private traverse_blockquote(e, p, context)
      local tbl, row
      put_new_row1(e, p, context)
      tbl := Tbl()
      add_component(p, tbl, context)
      row := TextFlow(self)
      put(row.input, TextCmd(u"\ua0\ua0\ua0\ua0", context))
      tbl.content.add(row)
      row := TextFlow(self).
         set_trim(&no).
         set_constraint("eol", &yes)
      tbl.content.add(row)
      traverse(e, row, context)
      put_new_row(p, context)
   end

   private traverse_fieldset(e, p, context)
      local tbl, row, c, fc
      put_new_row1(e, p, context)
      tbl := Tbl().set_border(CompoundBorder().
                              set_outer(SunkenBorder().set_line_width(Gui.FINE_WIDTH)).
                              set_inner(EmptyBorder()))
      add_component(p, tbl, context)
      row := TextFlow(self)
      tbl.content.add(row)
      fc := FieldSetContext()
      c := copy(context)
      c.fieldset := fc
      traverse(e, row, c)
      tbl.set_title(\fc.legend)
      put_new_row(p, context)
   end

   private traverse_legend(e, p, context)
      local fc
      fc := \context.fieldset | fail
      /fc.legend | fail
      fc.legend := TextFlow(self).
         set_dominant_width(TextFlow.MAX_WIDTH)
      traverse(e, fc.legend, context)
   end

   private traverse_map(e, p, context)
      local c, mc
      mc := MapContext()
      mc.map := ipl.browser.Map()
      c := copy(context)
      c.map := mc
      traverse(e, p, c)
      insert(maps, map(string(e.get_attribute(u"NAME"))), mc.map)
   end

   private traverse_datalist(e, p, context)
      local c, dc
      dc := DataListContext()
      dc.options := []
      c := copy(context)
      c.datalist := dc
      traverse(e, p, c)
      insert(datalists, map(string(e.get_attribute(u"ID"))), dc.options)
   end

   private traverse_area(e, p, context)
      local mc, coords
      mc := \context.map | fail
      coords := []
      every put(coords, scale(integer(separate(e.get_attribute(u"COORDS"), ',; '))))
      mc.map.add_area(MapArea(map(string(e.get_attribute(u"SHAPE"))), 
                              coords,
                              mk_link(e.get_attribute(u"HREF")),
                              context.title))
   end

   private traverse_abbr(e, p, context)
      local c
      c := copy(context)
      c.underdash := &yes
      traverse(e, p, c)
   end

   private traverse_body(e, p, context)
      local c
      c := copy(context)
      c.fg := page_text_color := convert_color(e, u"TEXT")
      page_link_color := convert_color(e, u"LINK")
      page_alink_color := convert_color(e, u"ALINK")
      page_vlink_color := convert_color(e, u"VLINK")
      p.set_bg(convert_color(e, u"BGCOLOR"))
      traverse(e, p, c)
   end

   private traverse_base(e, p, context)
      page_base := URL(e.get_attribute(u"HREF"))
   end

   private traverse_wbr(e, p, context)
      put(p.input, WbrCmd(context))
   end

   private traverse_text(e, p, context)
      put(p.input, TextCmd(e, context))
   end

   private traverse_title(e, p, context)
      page_title := e.get_trimmed_string_content()
   end

   private got_favicon(res)
      page_favicon_resp := res
   end

   private get_favicon()
      if /page_favicon_url then {
         page_url.scheme == (u"http" | u"https") | fail
         page_favicon_url := clone(page_url).set_path(u"/favicon.ico")
      }
      enqueue(Req(self, page_favicon_url, page_url, got_favicon, page_resp.req.kind))
   end

   private traverse_link(e, p, context)
      if map(e.get_attribute(u"REL")) == (u"icon" | u"shortcut icon") then {
         # Favour png file if available
         if /page_favicon_url | (map(e.get_attribute(u"TYPE")) == u"image/png") then
            page_favicon_url := mk_link(e.get_attribute(u"HREF"))
      }
   end

   # Convert a "title" attribute into a grid paint string if it
   # contains CR or NL chars; this allows multi-line tooltips.
   private static title_grid(s)
      local t
      if upto('\r\n', s) then {
         t := u".cell\n.x_ialign l\n"
         every t ||:= separate_lines(s) || u"\n.br\n"
         return t
      } else
         return s
   end

   private traverse(n, p, context)
      local e, title, c
      every e := !n.children do {
         if text(e) then
            traverse_text(e, p, context)
         else if is(e, HtmlElement) then {
            check_id(e, p, context)
            if title := (u"" ~== e.get_attribute(u"TITLE")) then {
               c := copy(context)
               c.title := title_grid(title)
            } else
               c := context
            case string(e.name) of {
               "META"|"SCRIPT"|"STYLE": {}
               "LINK": traverse_link(e, p, c)
               "TITLE": traverse_title(e, p, c)
               "A": traverse_a(e, p, c)
               "FORM": traverse_form(e, p, c)
               "BUTTON": traverse_button(e, p, c)
               "LABEL": traverse_label(e, p, c)
               "FONT": traverse_font(e, p, c)
               "IMG": traverse_img(e, p, c)
               "SELECT": traverse_select(e, p, c)
               "OPTION": traverse_option(e, p, c)
               "OPTGROUP": traverse_optgroup(e, p, c)
               "TEXTAREA": traverse_textarea(e, p, c)
               "INPUT": traverse_input(e, p, c)
               "DIV": traverse_div(e, p, c)
               "BIG": traverse_big(e, p, c)
               "SMALL": traverse_small(e, p, c)
               "SAMP"|"KBD"|"CODE"|"TT": traverse_tt(e, p, c)
               "STRONG"|"DFN"|"B": traverse_b(e, p, c)
               "EM"|"CITE"|"I"|"VAR": traverse_i(e, p, c)
               "MARK": traverse_mark(e, p, c)
               "ADDRESS": traverse_address(e, p, c)
               "BR": traverse_br(e, p, c)
               "NOBR": traverse_nobr(e, p, c)
               "HR": traverse_hr(e, p, c)
               "CENTER": traverse_center(e, p, c)
               "H" || (1 to 6): traverse_hN(e, p, c)
               "TABLE": traverse_table(e, p, c)
               "THEAD"|"TBODY"|"TFOOT": traverse_tbody(e, p, c)
               "CAPTION": traverse_caption(e, p, c)
               "COLGROUP": traverse_colgroup(e, p, c)
               "COL": traverse_col(e, p, c)
               "TR": traverse_tr(e, p, c)
               "TD"|"TH": traverse_td(e, p, c)
               "DIR"|"MENU"|"OL"|"UL": traverse_list(e, p, c)
               "LI": traverse_li(e, p, c)
               "DL": traverse_dl(e, p, c)
               "DT": traverse_dt(e, p, c)
               "DD": traverse_dd(e, p, c)
               "BLOCKQUOTE": traverse_blockquote(e, p, c)
               "P": traverse_p(e, p, c)
               "Q": traverse_q(e, p, c)
               "INS"|"U": traverse_u(e, p, c)
               "DEL"|"STRIKE"|"S": traverse_s(e, p, c)
               "SUP": traverse_sup(e, p, c)
               "SUB": traverse_sub(e, p, c)
               "LISTING"|"PRE"|"XMP": traverse_pre(e, p, c)
               "FIELDSET": traverse_fieldset(e, p, c)
               "LEGEND": traverse_legend(e, p, c)
               "MAP": traverse_map(e, p, c)
               "AREA": traverse_area(e, p, c)
               "DATALIST": traverse_datalist(e, p, c)
               "WBR": traverse_wbr(e, p, c)
               "ABBR"|"ACRONYM": traverse_abbr(e, p, c)
               "BASE": traverse_base(e, p, c)
               "BODY": traverse_body(e, p, c)
               default : traverse(e, p, c)
            }
         }
      }
   end

   public set_worker_pool(worker_pool)
      self.worker_pool := worker_pool
      self.shared_worker_pool_flag := &yes
      return self
   end

   public set_shared_worker_pool(s)
      self.shared_worker_pool_flag := check_flag(s)
      return self
   end

   public goto(url, referer, form_data, kind)
      /kind := Worker.NORMAL
      cancel()
      # Anything other than a navigate puts us back at the page we're viewing.
      if kind ~=== Worker.NAVIGATE then
         reset_history_pos()
      goto_externally(url) |
         enqueue(Req(self, url, referer, set_top_data, kind, form_data))
      return self
   end

   private handle_lpress(e)
      parent_dialog.get_held_count() = 1 | fail
      /mark_x | fail
      running === 0 | fail
      can_lpress(e) | fail
      set_cursor_from_pos(e)
      mark_x := cursor_x
      mark_y := cursor_y
      view.inner.invalidate(calculate_banded_rect())
      clear_selections()
   end

   private set_cursor_from_pos(e)
      cursor_x := e.x - view.inner.x
      cursor_y := e.y - view.inner.y
      cursor_x <:= get_area_x()
      cursor_x >:= get_area_x() + view.w
      cursor_y <:= get_area_y()
      cursor_y >:= get_area_y() + view.h
   end

   private handle_ldrag(e)
      \mark_x | fail

      view.inner.invalidate(get_band_rect())
      view.inner.invalidate(calculate_banded_rect())
      set_cursor_from_pos(e)
      calculate_banded()
      view.inner.invalidate(get_band_rect())
      view.inner.invalidate(calculate_banded_rect())

      if cursor_y > 0 & e.y < self.view.y then {
         v_direction := "up"
         check_scroll_ticker(self.view.y - e.y)
      } else if cursor_y < view.inner.h & e.y >= self.view.y + self.view.h then {
         v_direction := "down"
         check_scroll_ticker(e.y - (self.view.y + self.view.h))
      } else
         v_direction := &null

      if cursor_x > 0 & e.x < self.view.x then {
         h_direction := "left"
         check_scroll_ticker(self.view.x - e.x)
      } else if cursor_x < view.inner.w & e.x >= self.view.x + self.view.w then {
         h_direction := "right"
         check_scroll_ticker(e.x - (self.view.x + self.view.w))
      } else
         h_direction := &null

      if /v_direction & /h_direction then
         scroll_ticker.stop()
   end

   public get_band_rect()
      local x1, y1, x2, y2
      \mark_x | fail
      if mark_x = mark_y & cursor_x = cursor_y then
         fail
      y1 := mark_y
      y2 := cursor_y
      if y2 < y1 then
         y1 :=: y2
      else if y2 = y1 then
         y2 +:= 1
      x1 := mark_x
      x2 := cursor_x
      if x2 < x1 then
         x1 :=: x2
      else if x2 = x1 then
         x2 +:= 1
      return Rect(view.inner.x + x1, view.inner.y + y1, x2 - x1, y2 - y1)
   end

   public layout()
      ComponentScrollArea.layout()
      clear_mark()
      clear_selections()
      redo_search()
      scroll_ticker.stop()
   end

   public display()
      local W, r
      ComponentScrollArea.display()
      if r := get_band_rect() then {
         use {
            W := view.cbwin.clone(),
            W.set_fg("purple").
              set_masked_pattern("gray").
              draw_rectangle(r.x, r.y, r.w, r.h, Gui.FINE_WIDTH)
         }
      }
   end

   package check_scroll_ticker(d)
      scroll_ticker_interval := Gui.style.distance2ticker_rate(d)
      scroll_ticker.change_time(scroll_ticker_interval)
      # Start it (if it isn't already running)
      scroll_ticker.start()
   end

   package is_banded(o)
      return member(banded, o)
   end

   package is_searched(o)
      suspend !member(searched, o)
   end

   private tidy_cache()
      repeat {
         worker_pool.cache.tidy()
         tidy_cache_task.sleep(15000)
      }
   end

   private scroll_tick()
      local f
      repeat {
         f := &null
         case v_direction of {
            "up": {
               if cursor_y > 0 then {
                  cursor_y := max(0, cursor_y - SCROLL_INCREMENT)
                  set_area_y(cursor_y)
                  f := &yes
               }
            }
            "down": {
               if cursor_y < view.inner.h then {
                  cursor_y := min(view.inner.h, cursor_y + SCROLL_INCREMENT)
                  set_area_y(cursor_y - view.h)
                  f := &yes
               }
            }
         }
         case h_direction of {
            "left": {
               if cursor_x > 0 then {
                  cursor_x := max(0, cursor_x - SCROLL_INCREMENT)
                  set_area_x(cursor_x)
                  f := &yes
               }
            }
            "right": {
               if cursor_x < view.inner.w then {
                  cursor_x := min(view.inner.w, cursor_x + SCROLL_INCREMENT)
                  set_area_x(cursor_x - view.w)
                  f := &yes
               }
            }
         }
         if \f then
            calculate_banded()

         scroll_ticker.sleep(scroll_ticker_interval)
      }
   end

   private clear_mark()
      cursor_x := cursor_y := mark_x := mark_y := &null
   end

   private clear_selections()
      clear(banded)
      text_selection := links_selection := &null
      do_update_grey()
   end

   package on_lost_primary_ownership()
      view.inner.invalidate(calculate_banded_rect())
      clear_selections()
      primary := &null
   end

   private calculate_banded()
      local c, br
      clear(banded)
      br := get_band_rect() | fail
      every c := Seq{traverse_intersecting(view.inner, br)} do {
         if is(c, TextFlow) then
            c.calculate_banded(br, banded)
         else if is(c, Img) then
            insert(banded, c, c)
      }
   end

   private static traverse_intersecting(c, r)
      r := c.intersect(r) | fail
      coact(c)
      if is(c, TblContent) then
         every traverse_intersecting(c.layout_delegate.computed_g.cells_in_range(r.y - c.y, r.h).obj, r)
      else
         every traverse_intersecting(!c.children, r)
   end

   private show_bounds()
      local c
      every c := !banded do {
         if is(c, TextSelection) then
            write(image(c), " -> ", to_string(c.get_bounds()))
      }
   end

   private calculate_banded_rect()
      local c, t, r
      every c := !banded do {
         t := if is(c, TextSelection) then
            c.get_bounds()
         else if is(c, Img) then
            c
         r := (\r).union(t) | t
      }
      return \r
   end

   # This is used to forward an in chain event to Imgs and TextFlows
   # in the point chain.  The reason they don't simply listen
   # themselves is that they would then process the event in the wrong
   # order.  Since the bottom components come last (ie the base
   # TextFlow), when the mouse leaves a link in the top-level and
   # moves to a link in another TextFlow (above the base one), the
   # base TextFlow would process the event last, and would clear the
   # UI message, overwriting the new message written by the upper
   # level link.  So this traverses the point chain backwards, which
   # is the correct order for this case.
   #
   private handle_in_chain(e)
      local c
      every c := back(parent_dialog.get_point_chain()) do {
         if is(c, Img | TextFlow) then
            c.handle_in_chain(e)
      }
   end

   public get_current_text_selection()
      return \.text_selection
   end

   private calculate_text_selection()
      local br, s, c, l, e, y1
      text_selection := &null
      br := calculate_banded_rect() | fail
      l := []
      every c := Seq{traverse_intersecting(view.inner, br)} do {
         if is(c, TextFlow) then
            c.get_selected_text(br, l)
      }
      qsort(l, Point.cmp_yx)
      s := u""
      every e := !l do {
         if *s > 0 then
            s ||:= if e.y > y1 then u"\n" else u" "
         s ||:= e.val
         y1 := e.y
      }
      if *s > 0 then
         text_selection := s
   end

   public get_current_links_selection()
      return \.links_selection
   end

   private calculate_links_selection()
      local l, c, u, b, seen
      links_selection := &null
      l := []
      seen := set()
      every c := !banded do {
         if is(c, TextSelection) then {
            if u := \c.textout.attr.url & not member(seen, u) then {
               b := c.get_bounds()
               insert(seen, u)
               put(l, PointResult(b.x, b.y, u))
            }
         } else if is(c, Img) then {
            every u := \c.gen_areas().url do {
               if not member(seen, u) then {
                  insert(seen, u)
                  put(l, PointResult(c.x, c.y, u))
               }
            }
         }
      }
      if *l > 0 then {
         qsort(l, Point.cmp_yx)
         links_selection := ipl.pdco.List{ (!l).val }
      }
   end

   private handle_lrelease(e)
      scroll_ticker.stop()
      if \mark_x then {
         view.inner.invalidate(get_band_rect())
         clear_mark()
      }
      calculate_text_selection()
      calculate_links_selection()
      do_update_grey()
      if primary := \text_selection then
         parent_dialog.own_selection(Selection.PRIMARY, primary_selection_owner)
   end

   private handle_interrupted()
      if view.is_held(Mouse.LEFT_PRESS) then
         handle_lrelease()
   end

   public handle_select_all(e)
      /mark_x | fail
      running === 0 | fail
      mark_x := mark_y := 0
      cursor_x := view.inner.w
      cursor_y := view.inner.h
      calculate_banded()
      handle_lrelease(e)
   end

   private can_rpress(e)
      local c
      is(parent_dialog.get_point_chain()[1], TextFlow | TblContent | Tbl) | fail
      every c := !parent_dialog.get_point_chain() do {
         if is(c, TextFlow) & c.wants_rpress(e) then
            fail
      }
      return
   end

   private can_lpress(e)
      local c
      is(parent_dialog.get_point_chain()[1], Img | TextFlow | TblContent | Tbl) | fail
      every c := !parent_dialog.get_point_chain() do {
         if is(c, TextFlow | Img) & c.wants_lpress(e) then
            fail
      }
      return
   end

   private handle_rpress(e)
      local pm, pm_menu
      parent_dialog.get_held_count() = 1 | fail
      can_rpress(e) | fail
      if pm_menu := create_page_menu() then {
         pm := PopupMenu()
         pm.popup(self, pm_menu, e.x, e.y)
      }
   end

   public get_page_info()
      local e, s, l, t, c, n, sz, m, f, imgs, ct

      \page_url | fail
      s := "<html><title>Page info</title>"
      s ||:= "<h1>Page</h1>"

      s ||:= "URL: " || mk_anchor(page_url) || "<p>"
      if sz := *\page_data then
         s ||:= "Size: " || Format.numeric_to_string(sz, 0, ',') || " bytes<p>"
      if \page_charset then
         s ||:= "Charset: " || to_content(page_charset) || "<p>"
      if *\page_name > 0 then
         s ||:= "Name: " || to_content(page_name) || "<p>"
      if *\page_title > 0 then
         s ||:= "Title: " || to_content(page_title) || "<p>"
      if ct := \page_resp.content_type then
         s ||:= "Content-type: " || to_content(ct.to_rfc2616()) || "<p>"
      if l := \page_resp.req.referer & (l.scheme == (u"http" | u"https")) then
         s ||:= "Referer: " || mk_anchor(l) || "<p>"
      if e := \page_resp.err then
         s ||:= "Error: " || to_content(e) || "<p>"

      imgs := []
      t := table(u"")
      every c := Seq{traverse_postorder()} do {
         if is(c, TextFlow) then
            c.calculate_link_text(t)
         else if is(c, Img) then
            put(imgs, c)
      }

      if *forms > 0 then {
         s ||:= "<h1>Forms</h1>" || TABLE_TAG || "<tr><th align=left>Name<th align=left>Method<th align=left>URL</tr>"
         every f := !forms do {
            if l := \f.url then {
               n := \f.id | "-"
               m := \f.method | "-"
               s ||:= "<tr><td>" || to_content(n) || "<td>" || m || mk_anchor_cell(l) || "</tr>" 
            }
         }
         s ||:= "</table>"
      }

      if *imgs > 0 then {
         s ||:= "<h1>Images</h1>" || TABLE_TAG || "<tr><th align=left>Name<th align=right>Size&nbsp;<th align=left>URL</tr>"
         every c := !imgs do {
            l := c.img_url
            n := limit_text(\c.img_name, scale(200)) | "-"
            sz := Format.numeric_to_string(*\c.img_data, 0, ',') | "-"
            s ||:= "<tr><td>" || to_content(n) || "<td align=right>" || sz || "&nbsp;" || mk_anchor_cell(l) || "</tr>"
         }
         s ||:= "</table>"
      }

      if *page_links > 0 then {
         s ||:= "<h1>Links</h1>" || TABLE_TAG || "<tr><th align=left>Name<th align=left>URL</tr>"
         every l := !page_links do {
            n := limit_text(t[l], scale(200))
            s ||:= "<tr><td nowrap>" || to_content(n) || mk_anchor_cell(l) || "</tr>" 
         }      
         s ||:= "</table>"
      }
      s ||:= "</html>"
      return s
   end

   public get_cache()
      return worker_pool.cache
   end

   public handle_copy(e)
      local s
      if s := \text_selection then
         parent_dialog.own_selection(Selection.CLIPBOARD, StaticTextSelectionOwner(s))
   end

   private static scale_font(s, f)
      return s ? tab(backto(',')) || real(tab(0)) * f
   end

   # Magnify the fonts in the page by multiplying by the given factor.
   #
   public magnify(f)
      local c, i, seen, s
      seen := set()
      every c := Seq{traverse_postorder()} do {
         if is(c,TextFlow) then {
            every i := !c.input do {
               if not member(seen, i.attr) then {
                  insert(seen, i.attr)
                  i.attr.font := scale_font(i.attr.font, f)
               }
            }
         }
         if s := c.get_wattrib(WAttrib.FONT) then
            c.set_font(scale_font(s, f))
      }
      # We could just call reset() here, but that would mean we
      # couldn't use this function during page loading (since it would
      # reset the worker pool).  So just reset the view() and call
      # layout() and invalidate() as reset() would have done.
      view.reset()
      layout()
      invalidate()
      return self
   end

   # Increase the fonts by 5%
   #
   public do_increase_font()
      return magnify(1.05)
   end

   # Decrease the fonts by 5%
   # 
  public do_decrease_font()
      return magnify(1.0/1.05)
   end

   private additional_keys(e)
      case e.code of {
         "-" : if \e.ctrl then do_decrease_font()
         "=" : if \e.ctrl then do_increase_font()
         "\^c" :  handle_copy(e)
         "\^a" :  handle_select_all(e)
         "\^f" : (\ui).display_search()
      }
   end

   # Set a scaling factor to apply to all fonts (default 1.0).
   #
   public set_font_factor(n)
      self.font_factor := n
      return self
   end

   #
   # Set the maximum size of the history, default 100
   #
   public set_history_size(n)
      self.history_size := n
      return self
   end

   public handle_wheel_up(e)
      if /e.ctrl then
         (\vsb).handle_wheel_up(e)
      else
         do_increase_font()
   end

   public handle_wheel_down(e)
      if /e.ctrl then
         (\vsb).handle_wheel_down(e)
      else
         do_decrease_font()
   end

   public clone_history(other)
      local he
      # Note that we don't clone curr_history_entry, since we're not
      # actually looking at that page in the cloned browser tab.
      history := clone(other.history)
      history_pos := other.history_pos
      curr_history_entry := &null
      do_update_grey()
      he := history[history_pos]
      goto(he.url, he.referer, he.form_data, Worker.NAVIGATE)
      return self
   end

   public new()
      ComponentScrollArea.new()
      scroll_ticker := Dispatcher.new_task{scroll_tick()}
      tidy_cache_task := Dispatcher.new_task{tidy_cache()}
      worker_pool := WorkerPool(self)
      status_ticker := Dispatcher.new_task{status()}
      primary_selection_owner := BrowserPrimarySelectionOwner(self)
      set_inner(TextFlow(self))
      set_use_default_keys(&yes)
      set_vertical_increment(SCROLL_INCREMENT)
      set_horizontal_increment(SCROLL_INCREMENT)
      connect(additional_keys, Event.KEY_PRESS)
      history := []
      history_pos := 0
      history_size := DEFAULT_HISTORY_SIZE
      running := 0
      banded := table()
      searched := table()
      outermost_border := NullBorder()
      font_factor := 1.0
      view.connect(self.handle_ldrag, Event.MOUSE_LEFT_DRAG).
         connect(self.handle_lpress, Event.MOUSE_LEFT_PRESS).
         connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE).
         connect(self.handle_rpress, Event.MOUSE_RIGHT_PRESS).
         connect(self.handle_in_chain, Event.IN_POINT_CHAIN)
      connect(handle_interrupted, Event.INTERRUPTED)
      return
   end
end

#
# A `BrowserUI` to use with `SimpleBrowser`
#
class SimpleBrowserUI(BrowserUI)
   public const browser

   public msg(s, n) end

   public page_loaded()
      browser.fire(SimpleBrowser.PAGE_LOADED)
   end

   public page_fully_loaded()  
      browser.fire(SimpleBrowser.PAGE_FULLY_LOADED)
   end

   public update_grey(gs) end

   public link_left_clicked(url)
      browser.fire(SimpleBrowser.LINK_LEFT_CLICKED, url)
   end

   public link_middle_clicked(url)
      browser.fire(SimpleBrowser.LINK_MIDDLE_CLICKED, url)
   end

   protected copy_link(url)
      browser.parent_dialog.own_selection(Selection.CLIPBOARD, URLSelectionOwner([url]))
   end

   protected copy_links(urls)
      browser.parent_dialog.own_selection(Selection.CLIPBOARD, URLSelectionOwner(urls))
   end

   protected copy_text(s)
      browser.parent_dialog.own_selection(Selection.CLIPBOARD, StaticTextSelectionOwner(s))
   end

   protected populate_link_menu(url, m)
      m.add(TextMenuItem().
            set_label("Copy link").
            connect(create copy_link(url), Event.ACTION))
   end

   protected on_select_all(e)
      browser.handle_select_all(e)
   end

   protected is_external(url)
      return not(url.scheme == (u"page" | u"img"))
   end

   public create_link_menu(url)
      local m
      m := Menu()
      populate_link_menu(url, m)
      return m
   end

   public create_page_menu()
      local m, s, l, u, i
      m := Menu()
      if u := \browser.page_url & is_external(u) then {
         m.add(TextMenuItem().
               set_label("Copy page").
               connect(create copy_link(u), Event.ACTION))
      }
      if \browser.page_data then {
         i := TextMenuItem().
               set_label("Select all").
               connect(on_select_all, Event.ACTION)
         if browser.accepts_focus() then
            i.set_label_right("^A")
         m.add(i)
      }
      if s := browser.get_current_text_selection() then {
         i := TextMenuItem().
               set_label("Copy text").
               connect(create copy_text(s), Event.ACTION)
         if browser.accepts_focus() then
            i.set_label_right("^C")
         m.add(i)
      }
      if l := browser.get_current_links_selection() then
         m.add(TextMenuItem().
               set_label("Copy links").
               connect(create copy_links(l), Event.ACTION))
      if *m.children > 0 then
         return m
   end

   public create_image_menu(img)
      local m, url
      url := if img.img_url.scheme == u"cache" then browser.page_url else img.img_url
      m := Menu()
      if is_external(url) then
         m.add(TextMenuItem().
               set_label("Copy image").
               connect(create copy_link(url), Event.ACTION))
      if \img.over then
         populate_link_menu(img.over, m)
      if *m.children > 0 then
         return m
   end

   public browse_for_file(s) end
   public is_visited(url) end
   public display_search() end
   public display_externally(res) end
   public goto_externally(url) end
   public save_attachment(file, res) end

   public new(browser)
      self.browser := browser
      return
   end
end

# A simple subclass of `Browser`, intended for displaying HTML pages
# with no user navigation and a minimalist interface.
#
# An HTML document may be shown by calling `set_page`, passing the
# document in string form.  Images may be included in the page by
# either specifying a normal external URL, or with URL img:name, where
# name is a name in the image cache (eg: <img src="img:gui.HOME_24">).
#
class SimpleBrowser(Browser)
   private readable
      page

   public static const
      LINK_LEFT_CLICKED,
      LINK_MIDDLE_CLICKED,
      PAGE_LOADED,
      PAGE_FULLY_LOADED

   private static init()
      LINK_LEFT_CLICKED := "link_left_clicked"
      LINK_MIDDLE_CLICKED := "link_middle_clicked" 
      PAGE_LOADED := "page loaded"
      PAGE_FULLY_LOADED := "page fully loaded"
   end

   # Set the page to display as a string representing an HTML
   # document.
   #
   public set_page(page)
      self.page := page
      goto(URL("page:"))
      return self
   end

   private page_handler(worker)
      return \page | return error("No page set")
   end

   private img_handler(worker)
      local n
      n := string(worker.req.url.get_path())
      return ImageCache.get_named_image(n) | error("Unknown image")
   end

   public new()
      Browser.new()
      set_ui(SimpleBrowserUI(self))
      worker_pool.
         add_scheme_handler("page", page_handler).
         add_scheme_handler("img", img_handler)
      return
   end
end
