#
# Support procedures for ieval.
#

package ipl.ieval

import io, lang, ipl.colmize, parser, eval, util, ipl.pdco, ipl.sort, ipl.lambda

procedure map1(x)
   return map(x[1])
end

procedure show_env(env)
   local t, k
   t := []
   every k := key(env) do
      put(t, [k, to_string(env[k], 3)])
   print_table(isort(t, map1))
end

procedure list_syms(imports)
   local s, e
   s := set()
   every e := lang.Prog.get_global_names() do
      if e ? ((not upto('.')) | (=!imports & ="." & (not upto('.')))) then
         insert(s, e)
   every write(colmize(isort(s, map), LineEditorStream.get_console_size()[1]))
end

procedure show_parse(x, level)
   /level := 0
   if is(x, Token) then
      write(repl("\t", level), x.s)
   else
      every show_parse(x.gen(), level + 1)
end

procedure flags_string(f)
   local s
   s := ""
   if iand(f, lang.Class.Method) ~= 0 then
      s ||:= "Method "
   if iand(f, lang.Class.Private) ~= 0 then
      s ||:= "Private "
   if iand(f, lang.Class.Public) ~= 0 then
      s ||:= "Public "
   if iand(f, lang.Class.Protected) ~= 0 then
      s ||:= "Protected "
   if iand(f, lang.Class.Package) ~= 0 then
      s ||:= "Package "
   if iand(f, lang.Class.Static) ~= 0 then
      s ||:= "Static "
   if iand(f, lang.Class.Const) ~= 0 then
      s ||:= "Const "
   if iand(f, lang.Class.Readable) ~= 0 then
      s ||:= "Readable "
   if iand(f, lang.Class.Defer) ~= 0 then
      s ||:= "Defer "
   if iand(f, lang.Class.Final) ~= 0 then
      s ||:= "Final "
   if iand(f, lang.Class.Special) ~= 0 then
      s ||:= "Special "
   s[-1] := ""
   return s
end

procedure comma_string(e)
   local s
   s := ""
   while s ||:= @e || ", "
   s[-2:0] := ""
   return s
end

procedure supers_string(c)
   return comma_string{lang.Class.get_name(lang.Class.get_supers(c))} 
end

procedure implements_string(c)
   return comma_string{lang.Class.get_name(lang.Class.get_implemented_classes(c))}
end

procedure fields_string(c)
   return comma_string{Constructor.get_field_names(c)}
end

procedure locn_string(l)
   return "at line " || l.line || " in " || l.file
end

procedure kind_string(f)
   return case f of {
      Proc.Procedure: "Procedure"
      Proc.Function: "Function"
      Proc.Keyword: "Keyword"
      Proc.Operator: "Operator"
      Proc.Internal: "Internal"
   }
end

procedure var_string(f)
   return case f of {
      Proc.Argument: "Argument"
      Proc.Dynamic: "Dynamic"
      Proc.Static: "Static"
   }
end

procedure args_string(f)
   local s
   s := Proc.get_n_arguments(f)
   if Proc.has_varargs(f) then
      s ||:= "[]"
   return s
end

procedure print_table(t)
   local w, widths, col, row
   widths := []
   every col := 1 to *t[1] - 1 do {
      w := 0
      every w <:= *(!t)[col]
      put(widths, w)
   }
   every row := !t do {
      every col := 1 to *t[1] - 1 do
         writes(left(row[col], 4 + widths[col]))
      write(row[-1])
   }
end

procedure dir(c)
   local f, t
   case type(c) of {
      "object"|"cast"|"class": {
         write(if iand(lang.Class.get_class_flags(c), lang.Class.Final) ~= 0 then "final class " else "class ",
               lang.Class.get_name(c), "(", supers_string(c), ")")
         write("   ", locn_string(lang.Class.get_location(c))) 
         write("   implements ", implements_string(c))
         t := []
         every f := lang.Class.get_field_names(c) do
            put(t, [f, 
                    lang.Class.get_name(lang.Class.get_field_defining_class(c, f)), 
                    right(lang.Class.get_field_index(c, f), *lang.Class.get_n_fields(c)),
                    flags_string(lang.Class.get_field_flags(c, f))])
         print_table(isort(t, map1))
      }
      "procedure"|"methp": {
         write(kind_string(Proc.get_kind(c)), " ", Proc.get_name(c), "(", args_string(c), ")")
         write("   ", locn_string(Proc.get_location(c))) 
         write("   method of ", lang.Class.get_name(Proc.get_defining_class(c)))
         t := []
         every f := Proc.get_local_names(c) do
            put(t, [f,
                    var_string(Proc.get_local_kind(c, f))])
         print_table(t)
      }
      "record"|"constructor": {
         write("constructor ",
               Constructor.get_name(c), "(", fields_string(c), ")")
         write("   ", locn_string(Constructor.get_location(c))) 
      }

      default: {
         to_stdout(c, 3)
         write()
      }
   }
end

procedure show_history(in)
   local i, e
   is(in, LineEditorStream) | fail
   i := in.get_history_start_no()
   every e := !in.get_history() do {
      write(right(i, 4), "  ", e)
      i +:= 1
   }
end

procedure exit_repl(n)
   runerr("exit(" || n || ") invoked")
end

procedure main_impl(imports, files, opts)
   local env, s, t, ev, prompt, f, quiet_flag, par, 
      n, trace_flag, parse_flag, last_runerr, ee, in, hist_line, run, tv, hlim,
      hfile, elim, i, v

   par := Parser()
   env := table()
   ee := DefaultEvaluatorEnv(env)
   if \opts["w"] then
      ee.set_write_globals(&yes)
   ev := Evaluator().
      set_env(ee).
      set_imports(imports)

   env["env"] := create show_env(env)
   env["trace"] := create trace_flag := toggle_flag(trace_flag)
   env["parse"] := create parse_flag := toggle_flag(parse_flag)
   env["quiet"] := create quiet_flag := toggle_flag(quiet_flag)
   env["traceback"] := create { Coexpression.traceback(\last_runerr, &yes) ; &fail }
   env["dir"] := lambda{ if *_a = 0 then list_syms(imports) else dir(_a[1]) }
   env["hist"] := create show_history(in)
   env["cmd"] := lambda{{ if is(in, LineEditorStream) then hist_line := in.get_history_item(_a[1]) ; &fail}}
   env["elim"] := lambda{{ elim := (10 < _a[1]) ; elim }}
   env["hlim"] := lambda{{ hlim := (10 < _a[1]) ; hlim }}
   run := create
      with_var{ with_var{ Safe{ev.eval()}, &trace, tv }, exit, exit_repl}

   hlim := (10 < \opts["hlim"]) | 500
   elim := (10 < \opts["elim"]) | 35

   f := Files.get_path(Files.get_home()).child(".ieval").str()
   if Files.access(f) then
      push(files, f)
   every f := !files do {
      s := Files.file_to_string(f) | stop("Couldn't load ", f, ": ", &why)
      n := par.parse_expression(s) | stop("Couldn't parse ", f,  ": ", &why)
      ev.set_node(n) | stop("Couldn't parse ", f,  ": ", &why) 
      ev.eval()
   }

   s := ""
   prompt := "> "
   if \opts["s"] then
      in := FileStream.stdin
   else {
      in := LineEditorStream().
         set_history_limit(hlim) | stop("Failed to create LineEditorStream: ", &why)
      hfile := Files.get_path(Files.get_home()).child(".ieval_history").str()
      in.set_history(decode(Files.file_to_string(hfile)))
   }
   repeat {
      if \hist_line then {
         write(prompt, hist_line)
         t := hist_line
         hist_line := &null
      } else {
         if is(in, LineEditorStream) then
            in.set_prompt(prompt)
         else
            writes(prompt)
         t := in.read_line() | stop("Failed to read file: ", &why)
         if /t then break
      }
      s ||:= t
      if s[-1] == "\\" then {
         prompt := ">> "
         next
      }
      if n := par.parse_expression(s, "UTF-8") then {
         if \parse_flag & s ~== "!parse" then
            show_parse(n)
         else {
            tv := if \trace_flag then -1 else 0
            if ev.set_node(n) then {
               if \quiet_flag then
                  !run
               else {
                  i := elim
                  every v := !run do {
                     i -:= 1
                     if i < 0 then {
                        write(".... (result sequence truncated)")
                        break
                     }
                     to_stdout(v, 3)
                     write()
                  }
               }
               if &errortext then {
                  if &errornumber then
                     ewrite("Runtime error ", &errornumber, ": ", &errortext)
                  else
                     ewrite("Runtime error: ", &errortext)
                  ewrite("offending value: ", image(&errorvalue))
                  last_runerr := &errorcoexpr
                  errorclear()
               }
            } else
               ewrite("Couldn't parse: ", &why)
         }
      } else
         ewrite("Couldn't parse: ", &why)
      prompt := "> "
      s := ""
   }
   if \hfile then
      Files.string_to_file(hfile, encode(in.get_history())) | ewrite("History not saved: ", &why)
   write("Ciao")
end
