package util

import lang(Class),
   ipl.lists(ldel1),
   posix(System)


#
# Succeed iff the sequence generated by `&features` contains the given
# string.
#
procedure has_feature(x)
   static s
   initial {
      s := set()
      every insert(s, &features)
   }
   succeed member(s, x)
end

#
# Convenient procedure to set `&why` to the given string and fail.
#
procedure error(s)
   &why := s
end

#
# Extract an error code number from `&why`.
#
# If `&why` was set by a native method which failed due to an error
# which has a corresponding error code number (usually the value of
# errno), then it may set `&why` to a string in a format which
# includes that number.  This procedure parses the string and extracts
# the value.  `k` is optional and matches the name of the error
# variable; if omitted then any variable matches.
#
procedure errno(k)
   local i
   &why ? { 
      every tab(upto('(')) &
         move(1) &
         (if /k then tab(many(&letters ++ &digits ++ '_')) else =k) &
         ="=" &
         i := integer(tab(many(&digits))) &
         any(')') do
         suspend i
   }
end

# This class just provides a simple constructor which initializes the
# instance fields in the order they were defined in the class, from
# the given parameters.  In other words, rather like a record
# constructor.  The fields in the subclass must of course be
# accessible to this class's constructor.
#
# Example :-
# ~
#    class Abc(SimpleConstructor) public const a, b, c end
#    ...
#    x := Abc(1,2,3)  # Sets a,b,c to 1,2,3 respectively
# ~
class SimpleConstructor()
   public new(a[])
      every Class.get(self, 1 to Class.get_n_instance_fields(self)) := pop(a)
      return
   end
end

# Invoke co-expression `e`, generating its results, in such a way that
# changes to `var` made by `e` will not be seen by the caller, and
# vice versa.
#
# :Parameters :
# :  `e` - a co-expression to evaluate
# :  `var` - a co-expression generating a global variable.
# :  `i` - an optional initial value for the global variable
#        within e
#
# Example :-
# ~
#   # Cleanup some io stuff, without affecting global vars g.
#   save_var{ io_cleanup(), g }
# ~
procedure save_var(e, var, i)
   suspend save_state(e, VarState(var, i))
end

#
# A common case, having the same effect as `save_state(e, WhyState())`.
#
procedure save_why(e)
   suspend save_state(e, WhyState())
end

# This function saves `&why` before evaluating `e`.  If `e` succeeds,
# `&why` is restored, and the result returned; otherwise `&why` is not
# restored and the procedure fails.
#
procedure protect_why(e)
   local t
   t := &why
   return 1(@e, &why := t)
end

# Produce a string showing a min, max range (one of the two params may
# be &null).
#
procedure range_string(min, max)
   local s
   s := "("
   if \min then
      s ||:= ">= " || min
   if \max then {
      if \min then
         s ||:= " and "
      s ||:= "<= " || max
   }
   s ||:= ")"
   return s
end

# Convert to an integer or signal a runtime error
#
procedure need_integer(x, min, max)
   x := integer(x) | runerr(101, x)
   if x < \min | x > \max then
      runerr("Integer value out of valid range " || range_string(min, max), x)
   return x
end

# Convert to a real or signal a runtime error
#
procedure need_real(x, min, max)
   x := real(x) | runerr(102, x)
   if x < \min | x > \max then
      runerr("Real value out of valid range " || range_string(min, max), x)
   return x
end

# Convert to a numeric (real or integer) or signal a runtime error
#
procedure need_numeric(x, min, max)
   x := numeric(x) | runerr(102, x)
   if x < \min | x > \max then
      runerr("Numeric value out of valid range " || range_string(min, max), x)
   return x
end

# Convert to a string or signal a runtime error
#
procedure need_string(x)
   return string(x) | runerr(103, x)
end

# Convert to a ucs or signal a runtime error
#
procedure need_ucs(x)
   return ucs(x) | runerr(128, x)
end

# Convert to text (string or ucs) or signal a runtime error
#
procedure need_text(x)
   return text(x) | runerr(129, x)
end

# Convert to a cset or signal a runtime error
#
procedure need_cset(x)
   return cset(x) | runerr(104, x)
end

# Check that x is a list, signalling a runtime error otherwise.
#
procedure need_list(x)
   type(x) == "list" | runerr(108, x)
   return x
end

# Check that x is a set, signalling a runtime error otherwise.
#
procedure need_set(x)
   type(x) == "set" | runerr(119, x)
   return x
end

# Check that x is a table, signalling a runtime error otherwise.
#
procedure need_table(x)
   type(x) == "table" | runerr(124, x)
   return x
end

# Stores a list of cleanup expressions to be run.  See `use` and `clean`.
#
package global cleanup

#
# This procedure is used to automatically close a `Stream` or other
# resource.  The first expression `e1` produces the resource, the
# second `e2` uses it, and the third expression `e3` then closes it.
# The result of `e2` is returned, if all three expressions succeed,
# otherwise the procedure fails.
#
# `e3` is optional and defaults to calling `close` on the resource.
#
# Example :-
# ~
#     s := use { f := open("some.txt"),
#                do_something_with(f) }
# ~
procedure use(e1, e2, e3)
   local x, v, f
   x := @e1 | fail
   /e3 := create x.close()
   push(\cleanup, e3)
   /e2 | (v := @e2) | (f := &why)
   ldel1(\cleanup, e3)
   @e3 | (/f := &why)
   return if /f then v else error(f)
end

#
# This is like `use()`, but generates all results from `e2`.  So
# unless the sequence is generated to its end, then the cleanup code
# `e3` will not be run; in that case, the call should be wrapped in
# `clean()`.
#
procedure use_seq(e1, e2, e3)
   local x
   x := @e1 | fail
   /e3 := create x.close()
   push(\cleanup, e3)
   suspend |@\e2
   ldel1(\cleanup, e3)
   @e3
end

# This procedure can be used in conjunction with `use` to ensure that
# all cleanup expressions are performed.  `e` is evaluated for its
# first result only.  Then any outstanding cleanup expressions are
# performed.  If `e` failed, or any of the cleanup expressions failed,
# then the procedure fails; otherwise the first result of `e` is
# returned.
#
procedure clean(e)
   local t, v, f, x
   t := cleanup
   cleanup := []
   (v := @e) | (f := &why)
   while x := pop(cleanup) do
      @x | (/f := &why)
   cleanup := t
   return if /f then v else error(f)
end

# Convert an index position based on a length, to an absolute index,
# using Icon semantics of indices <= 0.  Fails if pos is out of range.
#
procedure cvpos(pos, len)
   pos := need_integer(pos)
   len := need_integer(len)
   if pos < -len | pos > len + 1 then
      fail
   if pos > 0 then
      return pos
   return pos + len + 1
end

# Convert an index position based on a length, to an absolute index,
# using Icon semantics of indices <= 0.  Fails if pos is out of range,
# or points at the end of the range (pos = 0 or equivalent).
#
procedure cvpos_item(pos, len)
   pos := need_integer(pos)
   len := need_integer(len)
   if pos < -len | pos > len | pos = 0 then
      fail
   if pos > 0 then
      return pos
   return pos + len + 1
end

package record Slice(lo, hi)

#
# Normalize an icon slice specification (along the lines of
# s[pos1:pos2]).  Returned is a record with lo, hi elements, giving
# the extent of the slice.  Failure occurs if pos1 or pos2 are out of
# range.
#
procedure cvslice(pos1, pos2, len)
   pos1 := cvpos(pos1, len) | fail
   pos2 := cvpos(pos2, len) | fail
   if pos1 > pos2 then
      pos1 :=: pos2
   return Slice(pos1, pos2)
end

#
# Like cvslice above, but pos1 defaults to 1, pos2 to 0.
#
procedure cvslice_def(pos1, pos2, len)
   /pos1 := 1
   /pos2 := 0
   return cvslice(pos1, pos2, len)
end

# This class can be used by a class which has various capabilities or
# permitted operations, and needs to give clients a simple way of
# seeing what it is capable of, by way of an integer bit flag
# combination.
#
abstract class HasMode()
   #
   # Succeed iff the object's mode has all the flags in `c`
   #
   public can(c)
      succeed iand(get_mode(), c) = c
   end

   # This method is implemented to return the integer bit flag
   # describing the object's capabilities.
   #
   public abstract get_mode()
end

# This class is used to save and restore some arbitrary global state.
#
abstract class State()
   # Called once to initialize the saved state from the global state,
   # and perhaps to initialize the global state.
   public abstract begin()

   # Called several times to swap the saved state with the global state
   public abstract swap()
end

#
# A `State` instance which saves an arbitrary global variable,
# specified as a co-expression generating that variable.  An initial
# value may also be specified.
#
class VarState(State)
   private var, t, i

   public begin()
      t := !var
      !var := i
   end

   public swap()
      !var :=: t
   end

   public new(var, i)
      self.var := var
      self.i := i
      return
   end
end

# A `State` which saves &subject and &pos.  Initial values of &subject
# and &pos may optionally be specified.
#
class ScanState(State)
   private is, ip, s, p

   public begin()
      s := &subject
      p := &pos
      &subject := is
      &pos := ip
   end

   public swap()
      local t
      t := &pos
      &subject :=: s
      &pos := p
      p := t
   end

   public new(is, ip)
      /is := ""
      /ip := 1
      self.is := is
      self.ip := ip
      return
   end
end

# A `State` which saves &pos.  An initial value may be specified.
#
class PosState(State)
   private i, p

   public begin()
      p := &pos
      &pos := i
   end

   public swap()
      &pos :=: p
   end

   public new(i)
      /i := 1
      self.i := i
      return
   end
end

# A `State` to save the global cleanup list used by `clean` and `use`.
#
class CleanupState(State)
   private t

   public begin()
      t := cleanup
      cleanup := &null
   end

   public swap()
      cleanup :=: t
   end
end

# A `State` to save `&why`.
#
class WhyState(State)
   private w, i

   public begin()
      w := &why
      &why := i
   end

   public swap()
      &why :=: w
   end

   public new(i)
      /i := ""
      self.i := i
      return
   end
end

# A `State` to save `&trace`.
#
class TraceState(State)
   private t, i

   public begin()
      t := &trace
      &trace := i
   end

   public swap()
      &trace :=: t
   end

   public new(i)
      /i := 0
      self.i := i
      return
   end
end

# A `State` to save `&handler`.  An initial value may be specified.
#
class HandlerState(State)
   private h, i

   public begin()
      h := &handler
      &handler := i
   end

   public swap()
      &handler :=: h
   end

   public new(i)
      self.i := i
      return
   end
end

# A `State` which just brings a list of several other `State`s together.
#
class States(State)
   private l

   public begin()
      every (!l).begin()
   end

   public swap()
      every (!l).swap()
   end

   public new(l[])
      self.l := l
      return
   end
end

# Evaluate the given co-expression `e`, suspending its results, whilst
# using the given `State` instance to save and restore some global
# state.
#
procedure save_state(e, state)
   state.begin()
   suspend 1(|@e, { state.swap() ; &null} ) do
      state.swap()
   state.swap()
end

#
# Return a non-empty string from the environment.
#
procedure env_string(s)
   return "" ~== System.getenv(s)
end

#
# Return a valid flag value from the environment.
#
procedure env_flag(s)
   local v
   v := env_string(s) | fail
   v := flag(v) | runerr("Flag value expected for " || s, v)
   return v
end

#
# Get a real-valued environment variable.  Fails if the variable isn't
# defined, returns the real value otherwise.  `min` and `max` provide
# optional bounds checking.
#
procedure env_real(s, min, max)
   local v
   v := env_string(s) | fail
   v := real(v) | runerr("Real value expected for " || s, v)
   if v < \min | v > \max then
      runerr("Value of " || s || " out of valid range " || range_string(min, max), v)
   return v
end

#
# Get an integer-valued environment variable.  Fails if the variable isn't
# defined, returns the integer value otherwise.  `min` and `max` provide
# optional bounds checking.
#
procedure env_int(s, min, max)
   local v
   v := env_string(s) | fail
   v := integer(v) | runerr("Integer value expected for " || s, v)
   if v < \min | v > \max then
      runerr("Value of " || s || " out of valid range " || range_string(min, max), v)
   return v
end

# Helper function to convert an optional parameter specified in a pdco
# invocation.  `v` is the parameter (the value itself or a
# coexpression giving the value, or &null).  `def` is a default value
# if `v` is &null.  If v is a coexpression and it fails to produce a
# result, the procedure fails.
#
procedure ce_param(v, def)
   if type(v) == "co-expression" then
      v := @v | fail
   /v := def
   return v
end
