#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

import 
   undo, 
   lang, 
   util, 
   ipl.lists,
   ipl.strings,
   graphics

#
# A scrollable editable text area.  
# An Event.CONTENT_CHANGED is generated whenever the contents
# are changed by the user, a Event.CURSOR_MOVED when the cursor moves,
# and a Event.SELECTION_CHANGED whenver the selection changes.
#
class EditableTextList(LineBasedScrollArea)
   public 
      contents,                                     
      is_editable_flag,        # Are we editable?
      menu_on_rpress_flag,     # Show context menu on mouse right press event?
      move_on_rpress_flag,     # Move on mouse right press event?
      constrain_cursor_on_scroll_flag,
      need_constrain_line,     # Indicate next end_handle to always constrain_line
      cursor_x,                #                
      cursor_y,                #                
      mark_x,                  #
      mark_y,                  #
      direction,               #
      long_line,               #
      undo_manager,
      primary,
      old_view_list_size,
      old_mw,
      old_cursor_x,
      old_cursor_y,
      old_mark_x,
      old_mark_y,
      old_has_region,
      old_region,
      no_drag,                 # Don't allow drag to set the cursor
      view_list,
      view_list_split_width,
      tab_width,
      wrap_mode,
      split_words_flag,
      line_splitter,
      last_split,
      changed,
      primary_selection_owner,
      scroll_ticker,
      scroll_ticker_interval,
      cursor_ticker,
      cursor_on,
      tx,
      tw

   public get_split(sw)
      local s, i, pos, j, p, l, ll, v

      if \last_split &
         (/wrap_mode | wrap_mode ~== "width" | last_split.width === sw) then
         return last_split

      l := []
      every i := 1 to *self.contents do {
         pos := 1
         s := self.contents[i]
         every j := line_splitter.split(s, sw) do {
            p := s[pos:j]
            put(l, ViewLine(i, p, pos, j - 1, 
                            text_width_ex(view.cbwin, p,,, self.tab_width)))
            pos := j
         }
         l[-1].last +:= 1
      }
      ll := l[1] | &null
      every v := !l do {
         if v.tw > ll.tw then
            ll := v
      }
      return last_split := TextSplit(sw, l, ll)
  end

   public get_default_subject_height(dw)
      local spl
      spl := get_split(dw  - 2 * Gui.TEXT_INSET)
      return get_line_height() * *spl.lines
   end

   public get_default_subject_width()
      local spl
      spl := get_split()
      return 2 * Gui.TEXT_INSET + ((\spl.long_line).tw | 0)
   end

   public calculate_line_count()
      if /view_list then
         create_view_list()
      return *self.view_list
   end

   public get_contents()
      return self.contents
   end

   #
   # Set the undo manager used by this instance.
   #
   public set_undo_manager(u)
      undo_manager := u
      return self
   end

   public initially()
      LineBasedScrollArea.initially()
      cursor_ticker.start()
   end
   
   public finally()
      scroll_ticker.stop()
      cursor_ticker.stop()
      LineBasedScrollArea.finally()
      # In case the component changes the contents and is then re-inited.
      clear_split_list()
   end

   #
   # Useful method to get the contents as a string, with each line
   # separated by the end-of-line character.
   #
   public get_contents_str()
      return cat_lines(self.contents)
   end

   #
   # Useful method to set the contents from a string in which each line
   # is separated by the end-of-line character.
   #
   public set_contents_str(s)
      set_contents(break_lines(s))
      return self
   end

   #
   # Set the contents of the component.
   #
   # @param x the contents, as a list of strings
   #
   public set_contents(x)
      self.contents := x
      contents_changed()
      return self
   end

   #
   # Call this method if the contents list, previously
   # set with {set_contents()}, has changed.
   #
   public contents_changed()
      local t

      if *self.contents = 0 then
         #
         # Must have somewhere for the cursor to go.
         #
         self.contents := [""]

      #
      # Ensure elements all of the same type
      #
      t := type(self.contents[1])
      if type(!self.contents) ~== t then
         runerr("Contents of EditableTextList must be all string or all ucs")

      if is_live() then {
         clear_split_list()
         clear_mark()
         ensure_valid_cursor()
         compute_and_invalidate()
         constrain_line()
         undo_manager.clear()
      }
      return self
   end
   
   public ensure_valid_cursor()
      self.cursor_y >:= *self.contents
      self.cursor_x >:= *self.contents[self.cursor_y] + 1
   end

   #
   # Convenient function to move the cursor to the given x, y position as though
   # the mouse had been clicked there.
   #
   public move_cursor(x, y, shift, e)
      start_handle(e)

      # Same as keyboard mark...
      if \shift then {
         /mark_x := cursor_x
         /mark_y := cursor_y
      } else
         clear_mark()

      if \y then {
         y <:= 1
         y >:= *self.contents
         self.cursor_y := y
      }
      if \x then {
         x <:= 1
         x >:= *self.contents[self.cursor_y] + 1
         self.cursor_x := x
      }
      end_handle(e)
      return self
   end

   #
   # Append lines of text and go to the bottom of the content.
   # @param l a list of lines to append
   # @param max optional maximum length of resulting contents
   #
   public log(l, max)
      local n, t
      # Overwite an initial empty line, otherwise append.
      if *self.contents = 1 & *self.contents[1] = 0 then {
         if *l > \max then
            set_contents(l[-max:0])
         else
            set_contents(l)
         if is_live() then {
            goto_last(get_line_count())
            # Make sure the cursor is valid, and on the screen.
            ensure_valid_cursor()
            constrain_cursor()
         }
      } else {
         # Check type
         t := type(self.contents[1])
         if type(!l) ~== t then
            runerr("Type of log list inconsistent with contents - must be all string or all ucs")

         every put(self.contents, !l)
         if is_live() then {
            clear_mark()
            update_view_list(*self.contents - *l + 1, 0, *l)
            if (n := *self.contents - \max) > 0 then {
               every 1 to n do
                  pop(self.contents)
               update_view_list(1, n, 0)
            }
            invalidate_line_count()
            invalidate_subject_width()
            compute_and_invalidate()
            undo_manager.clear()
            goto_last(get_line_count())
            # Make sure the cursor is valid, and on the screen.
            ensure_valid_cursor()
            constrain_cursor()
         } else {
            while *self.contents > \max do
               pop(self.contents)
         }
      }
      return self
   end

   # Similar to `log()`, but log a string, rather than a list of
   # lines.  The string is separated into lines and the first is
   # appended to the last content line; the remaining lines (if any)
   # are appended to the content.
   #
   public log_str(s, max)
      local t, n, fl

      # Check type unless we have empty contents.
      (*self.contents = 1 & *self.contents[1] = 0) | type(self.contents[1]) == type(s) |
            runerr("Type of log_str string inconsistent with contents - must be all string or all ucs")

      n := *contents
      every t := separate_lines(s) do {
         if /fl then {
            contents[-1] ||:= t
            fl := &yes
         } else
            put(contents, t)
      }
      if is_live() then {
         clear_mark()
         update_view_list(n, 1, 1 + *contents - n)
         if (n := *self.contents - \max) > 0 then {
            every 1 to n do
               pop(self.contents)
            update_view_list(1, n, 0)
         }
         invalidate_line_count()
         invalidate_subject_width()
         compute_and_invalidate()
         undo_manager.clear()
         goto_last(get_line_count())
         # Make sure the cursor is valid, and on the screen.
         ensure_valid_cursor()
         constrain_cursor()
      } else {
         while *self.contents > \max do
            pop(self.contents)
      }
      return self
   end

   #
   # Move cursor so that it is in the text area, if possible.  May not be possible
   # if cursor at end of line to the left of the text area.
   #     
   public constrain_cursor()
      local vi, v, s, i, ax, info
      vi := get_view_list_index()
      info := get_line_info() | fail
      if vi < info.first_whole then {
         v := view_list[info.first_whole]
         self.cursor_y := v.index
         self.cursor_x := v.first
      }
      else if vi > info.last_whole then {
         v := view_list[info.last_whole]
         self.cursor_y := v.index
         self.cursor_x := v.first
      }
      else
         v := view_list[vi]
      s := v.str
      i := text_width_ex(view.cbwin, s, 1, self.cursor_x - v.first + 1, self.tab_width)
      ax := get_area_x()
      if ax > i then {
         while (self.cursor_x < v.last) & (ax > i) do {
            self.cursor_x +:= 1
            i := text_width_ex(view.cbwin, s, 1, self.cursor_x - v.first + 1, self.tab_width)
         }
      } else { 
         while (self.cursor_x > v.first) & (ax + self.tw < i) do {
            self.cursor_x -:= 1
            i := text_width_ex(view.cbwin, s, 1, self.cursor_x - v.first + 1, self.tab_width)
         }
      }
   end

   #
   # Set the editable status of the component.
   #
   public set_is_editable(s)
      self.is_editable_flag := check_flag(s)
      return self
   end

   #
   # Move the cursor on mouse right press?  Only relevant if the context menu is disabled.
   #
   public set_move_on_rpress(s)
      self.move_on_rpress_flag := check_flag(s)
      return self
   end

   #
   # Show the context menu on mouse right press?
   #
   public set_menu_on_rpress(s)
      self.menu_on_rpress_flag := check_flag(s)
      return self
   end

   #
   # Configure whether the cursor is kept within the view when the
   # scrollbar (or wheel) is used; by default no.
   #
   public set_constrain_cursor_on_scroll(s)
      self.constrain_cursor_on_scroll_flag := check_flag(s)
      return self
   end

   #
   # Move the text area displayed so that the cursor is on the screen.
   #
   public constrain_line()
      local vi, v, s, i, ax
      vi := get_view_list_index()

      ensure_line_visible(vi)

      v := self.view_list[vi]
      s := v.str
      i := text_width_ex(view.cbwin, s, 1, self.cursor_x - v.first + 1, self.tab_width)
      ax := get_area_x()
      if ax > i then
         set_area_x(i)
      else if ax + self.tw < i then
         set_area_x(i - self.tw)
   end

   public handle_cut(e)
      local l
      \self.is_editable_flag | fail
      start_handle(e)
      if l := get_region_list() then {
         parent_dialog.own_selection(Selection.CLIPBOARD, StaticTextSelectionOwner(cat_lines(l)))
         delete_region(e)
      }
      end_handle(e)
   end

   public handle_copy(e)
      local l
      start_handle(e)
      if l := get_region_list() then
         parent_dialog.own_selection(Selection.CLIPBOARD, StaticTextSelectionOwner(cat_lines(l)))
      end_handle(e)
   end

   public is_editable()
      return \is_editable_flag
   end

   public has_contents()
      return *contents > 1 | *contents[1] > 0
   end

   public can_undo()
      return undo_manager.can_undo()
   end

   public can_redo()
      return undo_manager.can_redo()
   end

   public apply_filter(t)
      local s
      # Apply the filter to the string to paste
      s := ""
      t ? {
         while tab(upto(Gui.PRINTABLE_N)) do
            s ||:= tab(many(Gui.PRINTABLE_N))
      }
      if *s > 0 then
         return s
   end

   private handle_paste_response(target_type, data, e)
      insert_string(selection_convert(target_type, \data), e)
   end

   public handle_paste(e)
      parent_dialog.request_selection(Selection.CLIPBOARD, 
                                      [Selection.UTF8_STRING_TARGET, Selection.STRING_TARGET], 
                                      handle_paste_response, 
                                      e)
   end

   #
   # Insert a string as though it had been pasted via the clipboard.
   #
   public insert_string(s, e)
      local ce, ed

      \self.is_editable_flag | fail
      s := apply_filter(text_convert(s, type(self.contents[1]))) | fail

      start_handle(e)
      ce := CompoundEdit()
      if has_region() then {
         ed := EditableTextListDeleteRegionEdit(self)
         ed.doit()
         ce.add_edit(ed)
      }
      ed := EditableTextListPasteEdit(self, s)
      ed.doit()
      ce.add_edit(ed)
      ce.close()
      undo_manager.add_edit(ce)
      end_handle(e)
      return self
   end

   public on_vsb(ev)
      if \constrain_cursor_on_scroll_flag then {
         start_handle(ev)
         constrain_cursor()
         end_handle(ev)
      } else
         need_constrain_line := &yes
      refresh()
      #
      # Simulate a drag event if appropriate in order to keep the
      # cursor in synch.
      #
      if view.is_held(Mouse.LEFT_PRESS) then
         handle_ldrag(ev)
   end

   public on_hsb(ev)
      if \constrain_cursor_on_scroll_flag then {
         start_handle(ev)
         constrain_cursor()
         end_handle(ev)
      } else
         need_constrain_line := &yes
      refresh()
   end

   public start_handle(e)
      old_view_list_size := *view_list
      old_mw := long_line.tw
      old_cursor_x := cursor_x
      old_cursor_y := cursor_y
      old_mark_x := mark_x
      old_mark_y := mark_y
      old_has_region := has_region() | &null
      old_region := get_region_list() | &null
      changed := &null
   end

   public end_handle(e)
      local r, i, cursor_moved, t

      if r := get_region_list() &
         not equals(primary, r) &
         not view.is_held(Mouse.LEFT_PRESS) then {
         parent_dialog.own_selection(Selection.PRIMARY, self.primary_selection_owner)
         self.primary := r
      }

      if \changed then {
         if (*view_list ~= old_view_list_size) | 
            (old_mw ~= long_line.tw) then 
         {
            #
            # Contents changed.  Re-compute all internal fields, ensure on
            # screen and re-display whole object.
            #
            invalidate_line_count()
            invalidate_subject_width()
            compute_and_invalidate()
            self.constrain_line()
         } else {
            self.constrain_line()
            self.refresh()
         }
         cursor_on := -1
      }

      if (cursor_x ~= old_cursor_x) | (cursor_y ~= old_cursor_y) then {
         if /changed then
            constrain_line()
         cursor_on := -1
         cursor_moved := &yes
      } else if \need_constrain_line then {
         constrain_line()
         need_constrain_line := &no
      }

      # Invalidate on cursor/mark changes
      if /changed & 
         (\cursor_moved | (mark_x ~=== old_mark_x) | (mark_y ~=== old_mark_y)) & 
         (i := get_line_info()) then 
      {
         t := [get_view_list_index(old_cursor_x, old_cursor_y),
               get_view_list_index()]
         if not has_region() & /old_has_region then
            # No regions, so just invalidate cursor lines
            every invalidate_line(!t, i)
         else {
            # Have and/or had regions, so invalidate whole range of lines involved
            put(t, get_view_list_index(\old_mark_x, \old_mark_y))
            put(t, get_view_list_index(\mark_x, \mark_y))
            invalidate_lines(min!t, max!t, i)
         }
      }

      # Fire events
      if \changed then
         fire(Event.CONTENT_CHANGED, e)
      if \cursor_moved then
         fire(Event.CURSOR_MOVED, e)
      if not equals(old_region, r) then
         fire(Event.SELECTION_CHANGED, e)
   end

   public handle_key(e)
      case e.code of {
         Key.HOME : handle_key_home(e)
         Key.END : handle_key_end(e)
         Key.PGUP : handle_key_page_up(e)
         Key.PGDN : handle_key_page_down(e)
         Key.UP : handle_key_up(e)
         Key.DOWN : handle_key_down(e)
         Key.LEFT : handle_key_left(e)
         Key.RIGHT : handle_key_right(e)
         "\b" : handle_delete_left(e)
         "\r" | "\l": handle_return(e)
         "\^k" : handle_delete_line(e)
         "\^a" : handle_select_all(e)
         "\^e" : handle_end_of_line(e)
         "\d" | "\^d" : handle_delete_right(e)
         "\^x" :  handle_cut(e)
         "\^c" :  handle_copy(e)
         "\^v" :  handle_paste(e)
         Key.INSERT :  if \e.ctrl then handle_copy(e) else if \e.shift then handle_paste(e)
         "\^z" :  handle_undo(e)
         "\^y" :  handle_redo(e)
         default : handle_default(e)
      }
   end

   #
   # Given a ViewLine v and a pixel offset d in that line (which may extend past the end),
   # calculate the new cursor_x and cursor_y.
   #
   public set_cursor_in_view_line(v, d)
      local s, i, t
      self.cursor_y := v.index
      s := v.str
      i := v.first
      t := 0
      while (i < v.last) & ((.t + (t := text_width_ex(view.cbwin, s, 1, i - v.first + 2, self.tab_width))) / 2  < d) do
         i +:= 1
      self.cursor_x := i
   end

   #
   # Set cursor from the given event
   #
   public set_cursor_from_pos(e)
      set_cursor_in_view_line(self.view_list[get_nearest_line_to_pointer(e)],
                              e.x - self.tx + get_area_x())
   end

   public clear_mark()
      mark_x := mark_y := &null
      return self
   end

   public set_mark(mx, my)
      self.mark_x := mx
      self.mark_y := my
      return self
   end

   public set_cursor(cx, cy)
      self.cursor_x := cx
      self.cursor_y := cy
      return self
   end

   public has_region()
      return \mark_x & (mark_x ~= cursor_x | mark_y ~= cursor_y)
   end

   public handle_lpress(e)
      start_handle(e)
      # Move to cursor position.
      if \e.shift then {
         /self.mark_y := self.cursor_y
         /self.mark_x := self.cursor_x
         set_cursor_from_pos(e)
      } else {
         set_cursor_from_pos(e)
         case (parent_dialog.get_click_count() - 1) % 3 of {
            0 : {
               self.mark_y := self.cursor_y
               self.mark_x := self.cursor_x
            }
            1 : {
               self.mark_y := self.cursor_y
               self.mark_x := self.cursor_x
               while any(~'\t ', self.contents[self.cursor_y], self.cursor_x) do
                  self.cursor_x +:= 1
               while any(~'\t ', self.contents[self.cursor_y], self.mark_x - 1) do
                  self.mark_x -:= 1
               no_drag := &yes
            }
            2 : {
               self.cursor_x := *self.contents[self.cursor_y] + 1
               self.mark_y := self.cursor_y
               self.mark_x := 1
               no_drag := &yes
            }
         }
      }
      end_handle(e)
   end

   public create_context_menu(e)
      return TextContextMenu(self)
   end

   public handle_rpress(e)
      local m, pm
      if \menu_on_rpress_flag then {
         if m := create_context_menu(e) & *m.children > 0 then {
            pm := PopupMenu()
            pm.popup(self, m, e.x, e.y)
         }
      } else if \move_on_rpress_flag then {
         start_handle(e)
         set_cursor_from_pos(e)
         clear_mark()
         end_handle(e)
      }
   end

   private handle_mpress_response(target_type, data, e)
      local s, ed
      \data | fail
      \self.is_editable_flag | fail

      start_handle(e)

      set_cursor_from_pos(e)
      clear_mark()
      if s := apply_filter(text_convert(selection_convert(target_type, data),
                                        type(self.contents[1]))) then {
         ed := EditableTextListPasteEdit(self, s)
         ed.doit()
         undo_manager.add_edit(ed)
      }
      end_handle(e)
   end

   public handle_mpress(e)
      parent_dialog.request_selection(Selection.PRIMARY, 
                                      [Selection.UTF8_STRING_TARGET, Selection.STRING_TARGET], 
                                      handle_mpress_response, 
                                      e)
   end

   public handle_undo(e)
      \self.is_editable_flag | fail

      start_handle(e)
      if undo_manager.can_undo() then
         undo_manager.undo()
      end_handle(e)
   end

   public handle_redo(e)
      \self.is_editable_flag | fail

      start_handle(e)
      if undo_manager.can_redo() then
         undo_manager.redo()
      end_handle(e)
   end

   public handle_ldrag(e)
      local vi, v

      /no_drag | fail

      start_handle(e)

      vi := get_view_list_index()
      v := view_list[vi]

      if vi > 1 & e.y < self.view.y then {
         direction := "up"
         check_scroll_ticker(self.view.y - e.y)
      } else if vi < *view_list & e.y >= self.view.y + self.view.h then {
         direction := "down"
         check_scroll_ticker(e.y - (self.view.y + self.view.h))
      } else if self.cursor_x > v.first & e.x < self.tx then {
         direction := "left"
         check_scroll_ticker(self.tx - e.x)
      } else if self.cursor_x < v.last & e.x >= self.tx + self.tw then {
         direction := "right"
         check_scroll_ticker(e.x - (self.tx + self.tw))
      } else {
         direction := &null
         scroll_ticker.stop()
         set_cursor_from_pos(e)
      }

      end_handle(e)
   end

   public check_scroll_ticker(d)
      scroll_ticker_interval := Gui.style.distance2ticker_rate(d)
      scroll_ticker.change_sleep(scroll_ticker_interval)
      # Start it (if it isn't already running)
      scroll_ticker.start()
   end

   public scroll_tick()
      local ax, s, v, vi, i
      repeat {
         start_handle()

         vi := get_view_list_index()
         
         case self.direction of {
            "up" : {
               if vi > 1 & i := get_line_info() then {
                  vi := i.first_whole - 1
                  vi <:= 1
                  v := view_list[vi]
                  self.cursor_y := v.index
                  self.cursor_x := v.first
               }
            }
            "down" : {
               if vi < *view_list & i := get_line_info() then {
                  vi := i.last_whole + 1
                  vi >:= *view_list
                  v := view_list[vi]
                  self.cursor_y := v.index
                  # Set cursor_x to start of line, not end of line -
                  # this prevents the horizontal scroll bar jiggling
                  # about as we scroll down (as the cursor is
                  # constrained to be visible).
                  self.cursor_x := v.first
               }
            }
            "left" : {
               v := view_list[vi]
               ax := get_area_x()
               s := v.str
               while (self.cursor_x > v.first) & 
                  text_width_ex(view.cbwin, s, 1, self.cursor_x - v.first + 1, 
                                self.tab_width) >= ax do {
                                   self.cursor_x -:= 1
                                }
            }
            "right" : {
               v := view_list[vi]
               ax := get_area_x()
               s := v.str
               while (self.cursor_x < v.last) & 
                  text_width_ex(view.cbwin, s, 1, self.cursor_x - v.first + 1, 
                                self.tab_width) <= ax + self.tw do {
                                   self.cursor_x +:= 1
                                }
            }
         }

         end_handle()
         scroll_ticker.sleep(scroll_ticker_interval)
      }
   end

   public handle_lrelease(e)
      start_handle(e)
      #
      # Mouse released after being held down.  Clear flag.  If there
      # is no region (mouse released where it was pressed), then clear
      # the mark.  This prevents selecting when using the scrollbars
      # after release.
      #
      has_region() | clear_mark()
      scroll_ticker.stop()
      no_drag := &null
      end_handle(e)
   end

   public keyboard_mark(e)
      if \e.shift then {
         /mark_x := cursor_x
         /mark_y := cursor_y
      } else
         clear_mark()
   end

   public handle_start_of_line(e)
      start_handle(e)
      keyboard_mark(e)
      cursor_x := 1
      end_handle(e)
   end

   public handle_end_of_line(e)
      start_handle(e)
      keyboard_mark(e)
      cursor_x := *contents[cursor_y] + 1
      end_handle(e)
   end

   public adjust_view_list_index(off)
      local e1, e2, v1, v2
      v1 := get_view_list_index()
      v2 := v1 + off
      v2 <:= 1
      v2 >:= *self.view_list
      if v1 = v2 then
         return
      e1 := view_list[v1]
      e2 := view_list[v2]
      set_cursor_in_view_line(e2, 
                              text_width_ex(view.cbwin, e1.str, 1, self.cursor_x - e1.first + 1, self.tab_width))
   end

   public handle_key_up(e)
      start_handle(e)
      keyboard_mark(e)
      adjust_view_list_index(-1)
      end_handle(e)
   end

   public handle_key_home(e)
      start_handle(e)
      keyboard_mark(e)
      if \e.ctrl then
         cursor_y := 1
      cursor_x := 1
      end_handle(e)
   end

   public handle_key_end(e)
      start_handle(e)
      keyboard_mark(e)
      if \e.ctrl then
         cursor_y := *contents
      cursor_x := *contents[cursor_y] + 1
      end_handle(e)
   end

   public handle_select_all(e)
      start_handle(e)
      mark_x := mark_y := 1
      cursor_y := *contents
      cursor_x := *contents[cursor_y] + 1
      end_handle(e)
   end

   public handle_key_down(e)
      start_handle(e)
      keyboard_mark(e)
      adjust_view_list_index(1)
      end_handle(e)
   end

   public handle_key_left(e)
      start_handle(e)
      keyboard_mark(e)
      if self.cursor_x = 1 then {
         if self.cursor_y > 1 then {
            self.cursor_y -:= 1
            self.cursor_x := *self.contents[self.cursor_y] + 1
         }
      } else
         self.cursor_x -:= 1
      end_handle(e)
   end

   public handle_key_right(e)
      start_handle(e)
      keyboard_mark(e)
      if self.cursor_x = *self.contents[self.cursor_y] + 1 then {
         if self.cursor_y < *self.contents then {
            self.cursor_x := 1
            self.cursor_y +:= 1
         }
      } else
         self.cursor_x +:= 1
      end_handle(e)
   end

   public handle_key_page_up(e)
      start_handle(e)
      keyboard_mark(e)
      adjust_view_list_index(-self.view.h / self.line_height)
      end_handle(e)
   end

   public handle_key_page_down(e)
      start_handle(e)
      keyboard_mark(e)
      adjust_view_list_index(self.view.h / self.line_height)
      end_handle(e)
   end

   public handle_delete_line(e)
      local ed
      \self.is_editable_flag | fail
      start_handle(e)
      if (cursor_y < *self.contents) | (*self.contents[cursor_y] > 0) then {
         ed := EditableTextListDeleteLineEdit(self)
         ed.doit()
         undo_manager.add_edit(ed)
      }
      end_handle(e)
   end

   #
   # Get the region as a list of strings, each element representing one line, ie in
   # the same format as that supplied to {set_contents()}.
   #
   public get_region_list()
      local l
      has_region() | fail

      if self.mark_y < self.cursor_y then {
         l := self.contents[self.mark_y + 1:self.cursor_y]
         push(l, self.contents[self.mark_y][self.mark_x:0])
         put(l, self.contents[self.cursor_y][1:self.cursor_x])
      } else if self.mark_y > self.cursor_y then {
         l := self.contents[self.cursor_y + 1:self.mark_y]
         push(l, self.contents[self.cursor_y][self.cursor_x:0])
         put(l, self.contents[self.mark_y][1:self.mark_x])
      } else {
         # mark_y = cursor_y
         l := [self.contents[self.cursor_y][self.cursor_x:self.mark_x]]
      }
      return l
   end

   #
   # Get the region as a string, with lines separated by the end-of-line character.
   #
   public get_region()
      return cat_lines(get_region_list())
   end

   public delete_region(e)
      local ed 
      ed := EditableTextListDeleteRegionEdit(self)
      ed.doit()
      undo_manager.add_edit(ed)
   end

   public handle_delete_left(e)
      local ed
      \self.is_editable_flag | fail
      start_handle(e)
      if has_region() then 
         delete_region(e)
      else if (self.cursor_x > 1) | (self.cursor_y > 1) then {
         ed := EditableTextListDeleteLeftEdit(self)
         ed.doit()
         undo_manager.add_edit(ed)
      }
      end_handle(e)
   end

   public handle_delete_right(e)
      local ed
      \self.is_editable_flag | fail
      start_handle(e)
      if has_region() then
         delete_region(e)
      else if (self.cursor_x <= *contents[cursor_y]) | (self.cursor_y < *contents) then {
         ed := EditableTextListDeleteRightEdit(self)
         ed.doit()
         undo_manager.add_edit(ed)
      }
      end_handle(e)
   end

   public handle_return(e)
      local ce, ed
      \self.is_editable_flag | fail
      start_handle(e)
      if has_region() then {
         ce := CompoundEdit()
         ed := EditableTextListDeleteRegionEdit(self)
         ed.doit()
         ce.add_edit(ed)
         ed := EditableTextListReturnEdit(self)
         ed.doit()
         ce.add_edit(ed)
         ce.close()
         undo_manager.add_edit(ce)
      } else {
         ed := EditableTextListReturnEdit(self)
         ed.doit()
         undo_manager.add_edit(ed)
      }
      end_handle(e)
   end

   public handle_default(e)
      local ce, ed, ec

      ec := e.code

      if /self.is_editable_flag | not(type(ec) == ("string" | "ucs")) |
         \e.ctrl | \e.meta | not(any(Gui.PRINTABLE_N, ec)) then
         fail

      ec := text_convert(ec, type(self.contents[1]))

      start_handle(e)
      # 
      # Add the printable character at cursor position
      #
      if has_region() then {
         ce := CompoundEdit().set_liberal(&yes)
         ed := EditableTextListDeleteRegionEdit(self)
         ed.doit()
         ce.add_edit(ed)
         ed := EditableTextListDefaultEdit(self, ec)
         ed.doit()
         ce.add_edit(ed)
         ce.close()
         undo_manager.add_edit(ce)
      } else {
         ed := EditableTextListDefaultEdit(self, ec)
         ed.doit()
         undo_manager.add_edit(ed)
      }
      end_handle(e)
   end

   public layout()
      if \wrap_mode == "width" then
         clear_view_list()
      ScrollArea.layout()
      self.constrain_line()
   end

   public set_internal_fields()
      local had_vsb
      had_vsb := self.vsb
      LineBasedScrollArea.set_internal_fields()
      self.tx := self.view.x + Gui.TEXT_INSET
      self.tw := self.view.w - 2 * Gui.TEXT_INSET
      if \wrap_mode == "width" & had_vsb ~=== self.vsb then {
         clear_split_list()
         set_internal_fields()
      }
   end

   public shift(dx, dy)
      LineBasedScrollArea.shift(dx, dy)
      self.tx +:= dx
   end

   public cursor_tick()
      local t
      repeat {
         if self.has_focus() & self.is_unshaded() & self.is_unhidden() then {
            t := cursor_on
            cursor_on := if dont_blink(self) then
               0
            else
               (cursor_on + 1) % 3
            if (t | cursor_on) = 2 then
               invalidate_line(get_view_list_index())
         }
         cursor_ticker.sleep(Gui.CURSOR_BLINK)
      }
   end

   public focus_changed(e) 
      if is_live() then
         invalidate_line(get_view_list_index())
   end

   public draw()
      local xp, yp, i, info, r

      r := view.get_cbwin_clip()

      info := get_line_info(r) | fail
      yp := r.y - info.offset
      xp := tx - get_area_x()

      #
      # Write the lines
      #
      every i := info.first to info.last do {
         draw_line(xp, yp, i)
         yp +:= self.line_height
      }
   end

   public draw_line(xp, yp, i)
      local si, s, off1, off2, v, r

      v := self.view_list[i]
      s := v.str
      si := self.cursor_x - v.first + 1
      view.cbwin.draw_string(xp, yp + view.cbwin.get_line_ascent(), detab(s, self.tab_width + 1))
      #
      # Note use of v.first + *s, rather than v.last.  v.last is
      # the last permissible cursor pos, rather than the last
      # permissible char to highlight.  If we have a split line and
      # it is say wholly selected, using v.last would leave the
      # last char unhighlighted.
      #
      if \mark_y &
         (r := if (self.mark_y < v.index < self.cursor_y) | (self.mark_y > v.index > self.cursor_y) then {
                  # Whole line selected
                  Range(v.first, v.first + (0 < *s))
               } else if v.index = self.mark_y = self.cursor_y then {
                  # Part of line
                  range1(v.first, v.first + *s, self.cursor_x, self.mark_x)
               } else if v.index = self.mark_y then {
                  if self.mark_y < self.cursor_y then
                     range1(v.first, v.first + *s, self.mark_x, *self.contents[v.index] + 1)
                  else
                     range1(v.first, v.first + *s, 1, self.mark_x)
               } else if v.index = self.cursor_y then {
                  if self.mark_y > self.cursor_y then
                     range1(v.first, v.first + *s, self.cursor_x, *self.contents[v.index] + 1)
                  else
                     range1(v.first, v.first + *s, 1, self.cursor_x)
               })
      then {
         off1 := text_width_ex(view.cbwin, s, 1, r.lo - v.first + 1, self.tab_width)
         off2 := text_width_ex(view.cbwin, s, 1, r.hi - v.first + 1, self.tab_width)
         Gui.style.fill_selection_rectangle(view.cbwin, xp + off1, yp,  off2 - off1, self.line_height)
      }

      if (v.index = \self.cursor_y) & (v.first <= \self.cursor_x <= v.last) then {
         if self.has_focus() & self.is_unshaded() then {
            if self.cursor_on ~= 2 then
               Gui.style.draw_text_cursor(view.cbwin,
                                          xp + text_width_ex(view.cbwin, s, 1, si, self.tab_width), 
                                          yp + view.cbwin.get_absolute_leading(), 
                                          view.cbwin.get_font_height())
         } else if \self.is_editable_flag & \self.accepts_focus_flag then
            Gui.style.draw_shadow_text_cursor(view.cbwin,
                                              xp + text_width_ex(view.cbwin, s, 1, si, self.tab_width), 
                                              yp + view.cbwin.get_absolute_leading(), 
                                              view.cbwin.get_font_height())
      }
   end
   
   public calculate_line_height()
      return view.cbwin.get_line_height()
   end

   public keeps(e)
      # This component keeps all events if editable, but just the four
      # cursor keys otherwise.
      if \is_editable_flag then
         return
      return member(Key.CURSOR, e.code)
   end

   public calculate_subject_width()
      if /view_list then
         create_view_list()
      return self.long_line.tw + 2 * Gui.TEXT_INSET
   end

   #
   # Return the index into view_list containing the
   # content position x, y.  Binary search is used.
   # 
   public get_view_list_index(x, y)
      local i, j, mid, v
      /x := self.cursor_x
      /y := self.cursor_y
      # A search is not necessary with wrap mode off, since
      # view_list[i].index=i for every line.
      if is(line_splitter, DefaultLineSplitter) then {
         v := view_list[y]
         return (v.index = y) & (v.first <= x <= v.last) & y
      }
      i := 1
      j := *view_list
      while i <= j do {
         mid := (i+j) / 2
         v := view_list[mid]
         if (v.index = y) & (v.first <= x <= v.last) then
            return mid
         if (v.index < y) | (v.index = y & v.last < x) then
            i := mid + 1
         else
            j := mid - 1
      }
   end

   #
   # Create the view_list from the contents.
   # 
   public create_view_list()
      local spl
      spl := get_split(predict_view_width(w, vsb) - 2 * Gui.TEXT_INSET)
      view_list := spl.lines
      view_list_split_width := spl.width
      long_line := spl.long_line
   end

   #
   # Clear the view list, forcing it to be re-created next
   # time it's needed.
   # 
   public clear_split_list()
      last_split := &null
      clear_view_list()
   end

   public clear_view_list()
      view_list := long_line := &null
      invalidate_subject_width()
      invalidate_line_count()
   end

   #
   # Run through the view list looking for the longest line.
   # 
   public find_long_line()
      local v
      long_line := view_list[1]
      every v := !view_list do {
         if v.tw > long_line.tw then
            long_line := v
      }
   end

   #
   # Update the view list, given that the contents have changed.
   # This takes care to minimize the work that has to be done.  The
   # first param is an index into the contents list.  The second param
   # indicates some view_list lines corresponding to those beginning
   # with index should be removed; the third param says that some should
   # be added.
   #
   # Any subject_width/line_count invalidations are done by the caller (or
   # end_handle).
   #
   public update_view_list(index, del, add)
      local vi, i, pos, j, v, p, s

      # We allow adding new lines past the end of the current view_list.
      if del = 0 & index = view_list[-1].index + 1 then
         vi := *view_list + 1
      else {
         vi := get_view_list_index(1, index) | syserr("No such index" || index)
         # Do the deletions
         while view_list[vi].index <= index + del - 1 do {
            if view_list[vi] === long_line then
               long_line := &null
            delete(view_list, vi)
         }
         # Did we just get rid of long_line; if so get it again.
         if /long_line then
            find_long_line()
      }

      # Now do the additions
      every i := index to index + add - 1 do {
         pos := 1
         s := self.contents[i]
         every j := line_splitter.split(s, view_list_split_width) do {
            p := s[pos:j]
            v := ViewLine(i, p, pos, j - 1, text_width_ex(view.cbwin, p,,, self.tab_width))
            insert(view_list, vi, v)
            if /long_line | (v.tw > long_line.tw) then
               long_line := v
            pos := j
            vi +:= 1
         }
         view_list[vi - 1].last +:= 1
      }

      #
      # Adjust index values
      #
      if del ~= add then
         every view_list[vi to *view_list].index +:= (add - del)
 
     # Clear the cached split
      last_split := &null
   end

   #
   # Set the word-wrap mode, which should be one of the following
   # values :-
   #
   # &null, "false", "off", "no", meaning don't do word-wrap (the default).
   #
   # an integer (eg 20), meaning wrap at that line length.
   #
   # "width", meaning wrap at the width of the component.
   #
   public set_wrap_mode(s)
      local wc
      self.wrap_mode := s
      if /flag(s) then
         line_splitter := DefaultLineSplitter(self)
      else if wc := integer(s) then
         line_splitter := ColumnLineSplitter(self, wc)
      else if s == "width" then
         line_splitter := WidthLineSplitter(self)
      else
         runerr("Bad wrap mode", s)

      if is_live() then {
         clear_split_list()
         compute_and_invalidate()
         constrain_line()
      }
      return self
   end

   #
   # Indicate, if wrapping, whether to split words or not (default no).
   #
   public set_split_words(s)
      self.split_words_flag := check_flag(s)
      if is_live() then {
         clear_split_list()
         compute_and_invalidate()
         constrain_line()
      }
      return self
   end

   #
   # Set the tab width to use.  Default is from the style object.
   #
   public set_tab_width(n)
      self.tab_width := n
      if is_live() then {
         clear_split_list()
         compute_and_invalidate()
         constrain_line()
      }
      return self
   end

   public new()
      LineBasedScrollArea.new()
      scroll_ticker := Dispatcher.new_task{scroll_tick()}
      cursor_ticker := Dispatcher.new_task{cursor_tick()}
      cursor_on := -1
      self.set_accepts_focus(&yes)
      undo_manager := UndoManager()
      tab_width := Gui.TAB_WIDTH
      set_contents([])
      set_wrap_mode("off")
      self.cursor_x := self.cursor_y := 1
      self.is_editable_flag := &yes
      self.menu_on_rpress_flag := &yes
      self.move_on_rpress_flag := &yes
      self.primary_selection_owner := EditableTextListPrimarySelectionOwner(self)
      view.connect(self.handle_lpress, Event.MOUSE_LEFT_PRESS)
      view.connect(self.handle_rpress, Event.MOUSE_RIGHT_PRESS)
      view.connect(self.handle_mpress, Event.MOUSE_MIDDLE_PRESS)
      view.connect(self.handle_ldrag, Event.MOUSE_LEFT_DRAG)
      view.connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE)
      view.set_pointer("xterm")
      connect(self.handle_key, Event.KEY_PRESS)
      return
   end
end

class EditableTextListPrimarySelectionOwner(TextSelectionOwner)
   private parent

   protected get_text()
      return cat_lines(\parent.primary)
   end

   public lost_ownership()
      # Since we may retain ownership after having been disposed of.
      if parent.is_live() then {
         parent.start_handle()
         parent.clear_mark()
         parent.end_handle()
      } else
         parent.clear_mark()
      parent.primary := &null
   end

   public new(parent)
      self.parent := parent
      return
   end
end

class ViewLine()
   package readable 
      index, 
      str,
      first, 
      last,
      tw

   public new(index, str, first, last, tw)
      self.index := index
      self.str := str
      self.first := first
      self.last := last
      self.tw := tw
      return
   end
end

class TextSplit()
   public const 
      width, 
      lines, 
      long_line

   public new(width, lines, long_line)
      self.width := width
      self.lines := lines
      self.long_line := long_line
      return
   end
end

abstract class EditableTextListEdit(UndoableEdit)
   public
      parent,
      cursor_x, 
      cursor_y,
      mark_x,
      mark_y

   public doit()
      save()
      self.redo_impl()
      parent.changed := &yes
   end

   public redo()
      restore()
      self.redo_impl()
      parent.changed := &yes
   end

   public undo()
      self.undo_impl()
      restore()
      parent.changed := &yes
   end

   public abstract redo_impl()
   public abstract undo_impl()

   public save()
      self.cursor_x := parent.cursor_x
      self.cursor_y := parent.cursor_y
      self.mark_x := parent.mark_x
      self.mark_y := parent.mark_y
   end

   public restore()
      parent.cursor_x := self.cursor_x
      parent.cursor_y := self.cursor_y
      parent.mark_x := self.mark_x
      parent.mark_y := self.mark_y
   end

   public new(parent)
      self.parent := parent
      return
   end
end

class EditableTextListDefaultEdit(EditableTextListEdit)
   public s

   public add_edit(other)
      if is(other, gui.EditableTextListDefaultEdit) &
         (other.cursor_y = self.cursor_y) &
         (other.cursor_x = self.cursor_x + *s) then {
            s ||:= other.s
            return
      }
   end

   public redo_impl()      
      parent.contents[parent.cursor_y] := parent.contents[parent.cursor_y][1:parent.cursor_x] ||
                     s || parent.contents[parent.cursor_y][parent.cursor_x:0]
      parent.cursor_x +:= *s
      parent.clear_mark()
      parent.update_view_list(parent.cursor_y, 1, 1)
   end

   public undo_impl()
      parent.contents[self.cursor_y][self.cursor_x +: *s] := ""
      parent.update_view_list(self.cursor_y, 1, 1)
   end

   public new(parent, e)
      EditableTextListEdit.new(parent)
      self.s := e
      return
   end
end

class EditableTextListReturnEdit(EditableTextListEdit)
   public redo_impl()
      local s
      s := parent.contents[parent.cursor_y]
      parent.contents[parent.cursor_y] := s[1:parent.cursor_x]
      insert(parent.contents, parent.cursor_y + 1, s[parent.cursor_x:0])
      parent.update_view_list(parent.cursor_y, 1, 2)
      parent.cursor_y +:= 1
      parent.cursor_x := 1
   end

   public undo_impl()
      parent.contents[self.cursor_y] ||:= parent.contents[self.cursor_y + 1]
      delete(parent.contents, self.cursor_y + 1)
      parent.update_view_list(self.cursor_y, 2, 1)
   end
end

class EditableTextListDeleteRightEdit(EditableTextListEdit)
   public ch

   public add_edit(other)
      if is(other, EditableTextListDeleteRightEdit) &
         \ch & \other.ch &
         (cursor_y = other.cursor_y) &
         (cursor_x = other.cursor_x) then {
            ch ||:= other.ch
            return
      }
   end

   public redo_impl()
      if /ch then {
         # We know cursor_y < *contents from the handle method above.
         parent.contents[parent.cursor_y] ||:= parent.contents[parent.cursor_y + 1]
         delete(parent.contents, parent.cursor_y + 1)
         parent.update_view_list(parent.cursor_y, 2, 1)
      } else {
         # Cursor not at end of line
         parent.contents[parent.cursor_y][parent.cursor_x +: *ch] := ""
         parent.update_view_list(parent.cursor_y, 1, 1)
      }
      parent.clear_mark()
   end

   public undo_impl()
      local t
      if /ch then {
         t := parent.contents[cursor_y][cursor_x:0]
         parent.contents[cursor_y][cursor_x:0] := ""
         insert(parent.contents, cursor_y + 1, t)
         parent.update_view_list(cursor_y, 1, 2)
      } else {
         if cursor_x >  *parent.contents[cursor_y] then
            parent.contents[cursor_y] ||:= ch
         else
            parent.contents[cursor_y][cursor_x] := ch || parent.contents[cursor_y][cursor_x]
         parent.update_view_list(cursor_y, 1, 1)
      }
   end

   public new(parent)
      EditableTextListEdit.new(parent)
      if parent.cursor_x < *parent.contents[parent.cursor_y] + 1 then
         ch := parent.contents[parent.cursor_y][parent.cursor_x]
      return
   end
end

class EditableTextListDeleteLeftEdit(EditableTextListEdit)
   public ch, cut

   public add_edit(other)
      if is(other, EditableTextListDeleteLeftEdit) &
         \ch & \other.ch &
         (cursor_y = other.cursor_y) &
         (cursor_x = other.cursor_x + *ch) then {
            ch := other.ch || ch
            return
      }
   end

   public redo_impl()
      if /ch then {
         parent.cursor_x := cut
         parent.contents[parent.cursor_y - 1] ||:= parent.contents[parent.cursor_y]
         delete(parent.contents, parent.cursor_y)
         parent.update_view_list(parent.cursor_y - 1, 2, 1)
         parent.cursor_y -:= 1
      } else {
         # parent.cursor_x > 1
         parent.contents[parent.cursor_y][parent.cursor_x -: *ch] := ""
         parent.cursor_x -:= *ch
         parent.update_view_list(parent.cursor_y, 1, 1)
      }
      parent.clear_mark()
   end

   public undo_impl()
      local t
      if /ch then {
         t :=  parent.contents[cursor_y - 1][cut:0]
         parent.contents[cursor_y - 1][cut:0] := ""
         insert(parent.contents, cursor_y, t)
         parent.update_view_list(cursor_y - 1, 1, 2)
      } else {
         if cursor_x - *ch > *parent.contents[cursor_y] then
            parent.contents[cursor_y] ||:= ch
         else 
            parent.contents[cursor_y][cursor_x - *ch] := ch || parent.contents[cursor_y][cursor_x - *ch]
         parent.update_view_list(cursor_y, 1, 1)
      }
   end

   public new(parent)
      EditableTextListEdit.new(parent)
      if parent.cursor_x = 1 then
         # We know parent.cursor_y > 1 from the handle method
         cut := *parent.contents[parent.cursor_y - 1] + 1
      else
         ch := parent.contents[parent.cursor_y][parent.cursor_x - 1]
      return
   end
end

class EditableTextListDeleteLineEdit(EditableTextListEdit)
   public s, last

   public redo_impl()
      s := parent.contents[parent.cursor_y]
      if parent.cursor_y = *parent.contents then {
         parent.contents[parent.cursor_y][1:0] := ""
         parent.update_view_list(parent.cursor_y, 1, 1)
         self.last := &yes
      } else {
         delete(parent.contents, parent.cursor_y)
         parent.update_view_list(parent.cursor_y, 1, 0)
      }
      parent.cursor_x := 1
      parent.clear_mark()
   end

   public undo_impl()
      if \self.last then {
         parent.contents[self.cursor_y] := s
         parent.update_view_list(self.cursor_y, 1, 1)
      } else {
         insert(parent.contents, self.cursor_y, s)
         parent.update_view_list(self.cursor_y, 0, 1)
      }
   end
end

class EditableTextListDeleteRegionEdit(EditableTextListEdit)
   public l, pos

   public redo_impl()
      l := []
      if parent.mark_y < parent.cursor_y then {
         pos := parent.mark_y
         put(l, parent.contents[parent.mark_y])
         parent.contents[parent.mark_y] := parent.contents[parent.mark_y][1:parent.mark_x] || parent.contents[parent.cursor_y][parent.cursor_x:0] 
         every parent.mark_y + 1 to parent.cursor_y do {
            put(l, parent.contents[parent.mark_y + 1])
            delete(parent.contents, parent.mark_y + 1)
         }
         parent.cursor_x := parent.mark_x
         parent.cursor_y := parent.mark_y
      } else if parent.mark_y > parent.cursor_y then {
         pos := parent.cursor_y
         put(l,  parent.contents[parent.cursor_y])
         parent.contents[parent.cursor_y] := parent.contents[parent.cursor_y][1:parent.cursor_x] || parent.contents[parent.mark_y][parent.mark_x:0] 
         every parent.cursor_y + 1 to parent.mark_y do {
            put(l, parent.contents[parent.cursor_y + 1])
            delete(parent.contents, parent.cursor_y + 1)
         }
      } else {
         # parent.mark_y = cursor_y
         pos := parent.cursor_y
         put(l, parent.contents[parent.cursor_y])
         if parent.mark_x < parent.cursor_x then {
            parent.contents[parent.cursor_y][parent.mark_x:parent.cursor_x] := ""
            parent.cursor_x := parent.mark_x
         } else {
            parent.contents[parent.cursor_y][parent.cursor_x:parent.mark_x] := ""
         }
      }
      parent.update_view_list(pos, *l, 1)
      parent.clear_mark()
   end

   public undo_impl()
      local n
      n := *l
      delete(parent.contents, pos)
      while insert(parent.contents, pos, pull(l))
      parent.update_view_list(pos, 1, n)
   end
end

class EditableTextListPasteEdit(EditableTextListEdit)
   public s, pre, n

   public redo_impl()
      local t, nl

      n := 0
      pre := parent.contents[parent.cursor_y]

      s ? repeat {
         t := tab(upto('\n') | 0)
         if any('\n') then {
            if t[-1] == "\r" then
               t[-1] := ""
            nl := parent.contents[parent.cursor_y][parent.cursor_x:0]
            parent.contents[parent.cursor_y] := parent.contents[parent.cursor_y][1:parent.cursor_x] || t
            insert(parent.contents, parent.cursor_y + 1, nl)
            n +:= 1
            parent.cursor_y +:= 1
            parent.cursor_x := 1
            move(1)
         } else {
            parent.contents[parent.cursor_y] := parent.contents[parent.cursor_y][1:parent.cursor_x] || t || parent.contents[parent.cursor_y][parent.cursor_x:0]
            parent.cursor_x +:= *t
            break
         }
      }
      parent.update_view_list(self.cursor_y, 1, n + 1)
   end

   public undo_impl()
      parent.contents[self.cursor_y] := pre
      every 1 to n do
         delete(parent.contents, self.cursor_y + 1)
      parent.update_view_list(self.cursor_y, n + 1, 1)
   end

   public new(parent, s)
      EditableTextListEdit.new(parent)
      self.s := s
      return
   end
end

abstract class LineSplitter()
   public parent

   public abstract split(s)

   public new(parent)
      self.parent := parent
      return
   end
end

class ColumnLineSplitter(LineSplitter)
   public wrap_col

   public split(s)
      local ch, ds, p

      ds := ""
      s ? {
         while ch := move(1) do {
            ds ||:= ch
            if *detab(ds, parent.tab_width + 1) > wrap_col then {
               if *ds > 1 then {
                  ds[-1] := ""
                  move(-1)
               }
               if /parent.split_words_flag & upto('\t ', ds) then {
                  while any(~'\t ', ds[-1]) do {
                     ds[-1] := ""
                     move(-1)
                  }
               }
               p := &pos
               suspend p
               ds := ""
            }

         }
         if p ~=== &pos then
            suspend .&pos
      }
   end

   public new(parent, wrap_col)
      LineSplitter.new(parent)
      self.wrap_col := wrap_col
      return
   end
end

class DefaultLineSplitter(LineSplitter)
   public split(s)
      return *s + 1
   end
end

class WidthLineSplitter(LineSplitter)
   public split(s, width)
      local ch, ds, p
      \width | runerr("Need to specify width with 'width' wrap mode")
      ds := ""
      s ? {
         while ch := move(1) do {
            ds ||:= ch
            if text_width_ex(parent.view.cbwin, ds,,, parent.tab_width) > width then {
               if *ds > 1 then {
                  ds[-1] := ""
                  move(-1)
               }
               if /parent.split_words_flag & upto('\t ', ds) then {
                  while any(~'\t ', ds[-1]) do {
                     ds[-1] := ""
                     move(-1)
                  }
               }
               p := &pos
               suspend p
               ds := ""
            }

         }
         if p ~=== &pos then
            suspend .&pos
      }
   end
end
