/*
 * File: rxwin.ri - X11 system-specific graphics interface code.
 */

#define GetDepth(wd) DefaultDepth((wd)->display,DefaultScreen((wd)->display))
#define GetVisual(wd) DefaultVisual((wd)->display,DefaultScreen((wd)->display))
#define GetRoot(wd) DefaultRootWindow((wd)->display)

/*
 * Update the server time and window position, given one of the
 * various types of event carrying that information.
 */
#define UpdateCommon(ws, ev)  do {\
        (ws)->display->recent = (ev)->time; \
        synch_pos((ws), (ev)->x_root - (ev)->x, (ev)->y_root - (ev)->y); \
 } while (0)

/*
 * Poly edge and mode attributes to use with Pictures we draw onto
 * (pixwin and mask).
 */
#define PolyEdge PolyEdgeSmooth
#define PolyMode PolyModeImprecise

#define Copying(ws) ((ws)->win && !(ws)->holding)

/*
 * Global variables specific to X
 */
static wdp wdsplys;

struct lineinfo {
    double dx, dy;
    double len;
    XPointDouble p0, q0, p1, p2, q1, q2;
};

static struct
{
    XTrapezoid *traps;
    XTriangle *tris;
    int n;
    int alloc;
} drawlist;

/*
 * function prototypes
 */
static void handle_config(wsp ws, XConfigureEvent *event);
static void handle_client_message(wsp ws, XClientMessageEvent *event);
static int handle_incr_property(wdp wd, XPropertyEvent *event);
static void handle_property(wsp ws, XPropertyEvent *event);
static void handle_exposures(wsp ws, XExposeEvent *event);
static void handle_mouse(wsp ws, XButtonEvent *event);
static void handle_keypress(wsp ws, XKeyEvent *event);
static void handle_crossing(wsp ws, XCrossingEvent *event);
static void handle_selection_request(wsp ws, XSelectionRequestEvent *event);
static void handle_selection_clear(wsp ws, XSelectionClearEvent *event);
static void handle_selection_notify(wsp ws, XSelectionEvent *event);
static char *get_progname(void);
static void wmap(wbp w);
static wsp wsp_for_Window(wdp wd, Window w);
static void synch_cursor(wsp ws);
static void synch_cursors(wdp wd, struct wcursor *c);
static void setup_cursors(wdp wd);
static void setup_cursor(wdp wd, char *name, int id);
static struct SharedCursor *new_sharedcursor(wdp wd, Cursor cursor);
static struct SharedCursor *link_sharedcursor(struct SharedCursor *x);
static void unlink_sharedcursor(struct SharedCursor *x);
static struct wcursor *lookup_wcursor(wdp wd, char *name);
static struct wcursor *ensure_wcursor(wdp wd, char *name);
static int convert_KeySym_to_code_point(KeySym k);
static wfp newfont(wdp wd, char *s);
static wdp alcdisplay (char *s);
static void resizepixmap(wbp w);
static void clip(wbp w);
static void no_clip(wsp ws, int and_win);
static int make_mod(unsigned int state);
static char* property_to_string(wdp wd, Atom target, int number_items, void* data, int append);
static Atom convert_target(wdp wd, Atom desired_target);
static void get_atom_descriptor(wdp wd, Atom a, dptr dest);
static void synch_state(wsp ws);
static void synch_state1(wsp ws);
static void synch_net_wm_state(wsp ws, int desired_state);
static void close_screen_win(wsp ws);
static void fill2(wbp w, int op, XRenderColor  *color, int x, int y, int width, int height);
static void pat1(wbp w, int x, int y, int width, int height);
static void pat2(wbp w, int x, int y, int width, int height);
static void maskpic2(wbp w, Picture mask, int x, int y, int width, int height);
static Pixmap imgdata_to_Pixmap(wdp wd, struct imgdata *imd,
                                int ix, int iy, int iw, int ih,
                                int depth, XRenderPictFormat **format);
static Picture get_draw_picture(wcp wc);
static Picture get_mask_picture(wcp wc);
static void pix_to_win(wsp ws, int x, int y, int width, int height);
static void synch_pix_and_win(wsp ws, int x, int y, int width, int height);
static Picture getmask(wdp wd, int width, int height);
static XPointDouble doublept(double x, double y);
static XPointFixed fixedpt(XPointDouble *p);
static XTriangle triangle(XFixed x1, XFixed y1, XFixed x2, XFixed y2, XFixed x3, XFixed y3);
static XTrapezoid trapezoid(XFixed top, XFixed x1, XFixed x2, XFixed bottom, XFixed x3, XFixed x4);
static int needmask(wcp wc, int overlap);
static void drawlineinfos(wbp w, struct lineinfo *lis, int nlis, int closed);
static void getlineinfo(wcp wc, XPointDouble *p0, XPointDouble *q0, struct lineinfo *res);
static int which_selection_property(wdp wd, Atom a);
static void reset_receiving_helper(struct receiving_helper *h);
static wcp clonecontext(wcp wc);
static void freecontext(wcp wc);
static void freewindow(wsp ws);
static void apply_windowlabel(wsp ws);
static void apply_windowicon(wsp ws);
static double calc_pt(double *x, double *y, double rx, double ry, double th);
static double calc_progress_factor(double rx, double ry);
static int almost_straight(struct lineinfo *u, struct lineinfo *v);
static void synch_pos(wsp ws, int new_x, int new_y);
static char *get_atom_name(wdp wd, Atom a);
static void mk_hints(wsp ws, XSizeHints *h);
static char *resource_name, *resource_class, *display;
static int intersect(XPointDouble *res, XPointDouble *a1, XPointDouble *a2, XPointDouble *b1, XPointDouble *b2);
static void init_drawlist(int alloc, int tris);
static void ensure_drawlist(int need);
static void free_drawlist(void);
static void draw_drawlist(wdp wd, int op, Picture src, Picture dest);
static void add_trap(double top, double x1, double x2, double bottom, double x3, double x4);
static void add_rect(XPointDouble *tl, XPointDouble *br);
static void add_tri(XPointDouble *p1, XPointDouble *p2, XPointDouble *p3);
static void mk_polygon(struct point *points, int npoints, int rule);
static XftFont *fallback(wbp w, int ch);
static void reset_sending_helper(wdp wd, struct sending_helper *x);

static stringint drawops[] = {
   { 0, 12},
   {"atop",  PictOpAtop},
   {"clear",  PictOpClear},
   {"dest",  PictOpDst},
   {"dest atop",  PictOpAtopReverse},
   {"dest in",  PictOpInReverse},
   {"dest out",  PictOpOutReverse},
   {"dest over",  PictOpOverReverse},
   {"in",  PictOpIn},
   {"out",  PictOpOut},
   {"over",  PictOpOver},
   {"source",  PictOpSrc},
   {"xor",  PictOpXor},
};

static stringint linejoins[] = {
    {0, 3},
    {"bevel",     JoinBevel},
    {"miter",     JoinMiter},
    {"round",     JoinRound},
};

static stringint lineends[] = {
    {0, 4},
    {"flat",      EndFlat},
    {"point",     EndPoint},
    {"round",     EndRound},
    {"square",    EndSquare},
};

static stringint fillrules[] = {
    {0, 2},
    {"even-odd",   1},
    {"non-zero",   ~0},
};

static stringint canvastypes[] = {
    {0, 9},
    {"fullscreen",  FullScreenState},
    {"hidden",      HiddenState},
    {"iconic",      IconicState},
    {"maximized",   MaximizedState},
    {"normal",      NormalState},
    {"popup",       PopupState},
    {"root",        RootState},
    {"shaded",      ShadedState},
    {"withdrawn",   WithdrawnState},
};

#define SelectionHelperPurgeTime 20

static int max_selection_size = 2 * 1024 * 1024;
static int max_selection_chunk = 64 * 1024;
static int selection_debug = 0;
static int font_debug = 0;
static int poly_debug = 0;
static int draw_debug = 0;
static int triangles = 0;

#if 0
static void dump_all(void)
{
    int i,j,k;
    wsp x;
    wbp y;
    i = 0;
    for (y = wbndngs; y; y = y->next) {
        printf("Binding %p\n",y);
        printf("\tcanvas %p\n",y->window);
        printf("\tcontext %p\n",y->context);
        ++i;
    }
    printf("============\n");
    j = 0;
    for (x = wstates; x; x = x->next) {
        printf("Canvas %p\n",x);
        printf("\trefcount=%d\n", x->refcount);
        printf("\tlabel=%s\n", x->windowlabel);
        printf("\tgeometry=%d,%d %dx%d\n", x->x,x->y,x->width,x->height);
        printf("\twin=%d\n", (int)x->win);
        ++j; 
    }
    printf("============\n");
    k = 0;
    for (x = vwstates; x; x = x->vnext) {
        printf("Non-hidden Canvas %p\n",x);
        printf("\trefcount=%d\n", x->refcount);
        printf("\tlabel=%s\n", x->windowlabel);
        printf("\tgeometry=%d,%d %dx%d\n", x->x,x->y,x->width,x->height);
        printf("\twin=%d\n", (int)x->win);
        ++k; 
    }

    printf("Total %d bindings %d canvases (%d non-hidden)\n",i,j,k);
}
#endif
#if 0
static void dump_ximage(XImage *xi)
{
    int i,j;
    printf("XImage=%p\n",xi);
    printf("\twidth, height=%d %d\n", xi->width, xi->height);            /* size of image */
    printf("\txoffset=%d\n", xi->xoffset);                  /* number of pixels offset in X direction */
    printf("\tformat=%d\n", xi->format);                  /* XYBitmap, XYPixmap, ZPixmap */
    printf("\tbyte_order=%d\n", xi->byte_order);               /* data byte order, LSBFirst, MSBFirst */
    printf("\tbitmap_unit =%d\n", xi->bitmap_unit);             /* quant. of scanline 8, 16, 32 */
    printf("\tbitmap_bit_order =%d\n", xi->bitmap_bit_order);        /* LSBFirst, MSBFirst */
    printf("\tbitmap_pad   =%d\n", xi->bitmap_pad);            /* 8, 16, 32 either XY or ZPixmap */
    printf("\tdepth  =%d\n", xi->depth);              /* depth of image */
    printf("\tbytes_per_line=%d\n", xi->bytes_per_line);          /* accelerator to next scanline */
    printf("\tbits_per_pixel=%d\n", xi->bits_per_pixel);        /* bits per pixel (ZPixmap) */
    printf("\tred_mask=%lx\n", xi->red_mask);       /* bits in z arrangement */
    printf("\tgreen_mask=%lx\n", xi->green_mask);
    printf("\tblue_mask=%lx\n", xi->blue_mask);
    printf("\n");
    printf("\nPixel dump of region size %d,%d\n",xi->width,xi->height);
    
    for (j=0; j < xi->height; ++j) {
        unsigned long c0=-1;
        printf("\nrow %d:",j);
        for (i = 0; i < xi->width; ++i) {
            unsigned long c;            
            c=XGetPixel(xi,i,j);
            if (c!=c0) {
                printf("%lx ",c);
                c0=c;
            } else
                printf("-");
        }
    }
    printf("\n");
}



#endif

struct SharedPicture *new_sharedpicture(wdp wd, struct imgdata *imd, int depth)
{
    struct SharedPicture *res;
    XRenderPictureAttributes pa;
    XRenderPictFormat *format;
    GAlloc(res, SharedPicture);
    res->wd = wd;
    res->pix = imgdata_to_Pixmap(wd, imd, 0, 0, imd->width, imd->height, depth, &format);
    pa.repeat = 1;
    res->i = XRenderCreatePicture(wd->display, res->pix, format, CPRepeat, &pa);
    res->width = imd->width;
    res->height = imd->height;
    return res;
}

struct SharedPicture *link_sharedpicture(struct SharedPicture *x)
{
    ++x->refcount;
    return x;
}

void unlink_sharedpicture(struct SharedPicture *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        XRenderFreePicture(x->wd->display, x->i);
        XFreePixmap(x->wd->display, x->pix);
        free(x);
    }
}

struct SharedColor *new_sharedcolor(wdp wd, char *name, int r, int g, int b, int a)
{
    struct SharedColor *res;
    GAlloc(res, SharedColor);
    res->wd = wd;
    res->color.red = Mul16(r, a);
    res->color.green = Mul16(g, a);
    res->color.blue = Mul16(b, a);
    res->color.alpha = a;
    res->brush = XRenderCreateSolidFill(wd->display, &res->color);
    res->name = salloc(name);
    return res;
}

struct SharedColor *link_sharedcolor(struct SharedColor *x)
{
    ++x->refcount;
    return x;
}

void unlink_sharedcolor(struct SharedColor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        XRenderFreePicture(x->wd->display, x->brush);
        free(x->name);
        free(x);
    }
}

static struct SharedCursor *new_sharedcursor(wdp wd, Cursor cursor)
{
    struct SharedCursor *res;
    GAlloc(res, SharedCursor);
    res->wd = wd;
    res->cursor = cursor;
    return res;
}

static struct SharedCursor *link_sharedcursor(struct SharedCursor *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedcursor(struct SharedCursor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        XFreeCursor(x->wd->display, x->cursor);
        free(x);
    }
}

static struct wcursor *lookup_wcursor(wdp wd, char *name)
{
    struct wcursor *rv;
    int i;
    i = hasher(hashcstr(name), wd->cursors);
    for(rv = wd->cursors[i]; rv; rv = rv->next) {
        if (!strcmp(name, rv->name))
            return rv;
    }
    return 0;
}

static struct wcursor *ensure_wcursor(wdp wd, char *name)
{
    struct wcursor *rv;
    int i;
    i = hasher(hashcstr(name), wd->cursors);
    for(rv = wd->cursors[i]; rv; rv = rv->next) {
        if (!strcmp(name, rv->name))
            return rv;
    }
    rv = safe_zalloc(sizeof(struct wcursor));
    rv->name = salloc(name);
    rv->next = wd->cursors[i];
    wd->cursors[i] = rv;
    return rv;
}

void restore(wbp w, int x, int y, int width, int height)
{
    synch_pix_and_win(w->window, x, y, width, height);
}

int definepointer(wbp w, char *name, struct imgdata *imd, int x, int y)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    Pixmap pix;
    Picture pic;
    struct wcursor *rv;
    Cursor nc;
    XRenderPictFormat *format;

    pix = imgdata_to_Pixmap(wd, imd, 0, 0, imd->width, imd->height, 32, &format);
    pic = XRenderCreatePicture(wd->display, pix, format, 0, 0);
    nc = XRenderCreateCursor(wd->display, pic, x, y);
    rv = ensure_wcursor(wd, name);
    if (rv->shared_cursor) {
        struct SharedCursor *tmp = rv->shared_cursor;
        rv->shared_cursor = new_sharedcursor(wd, nc);
        synch_cursors(wd, rv);
        unlink_sharedcursor(tmp);
    } else
        rv->shared_cursor = new_sharedcursor(wd, nc);

    XFreePixmap(wd->display, pix);
    XRenderFreePicture(wd->display, pic);
    return Succeeded;
}

static void synch_cursors(wdp wd, struct wcursor *c)
{
    wsp x;
    for (x = wd->vwstates; x; x = x->vnext) {
        if (x->cursor == c)
            synch_cursor(x);
    }
}

int copypointer(wbp w, char *dest, char *src)
{
    struct wcursor *sc, *dc;
    wdp wd = w->window->display;
    sc = lookup_wcursor(wd, src);
    if (!sc)
        return Failed;
    dc = ensure_wcursor(wd, dest);
    if (sc != dc) {
        if (dc->shared_cursor) {
            struct SharedCursor *tmp = dc->shared_cursor;
            dc->shared_cursor = link_sharedcursor(sc->shared_cursor);
            synch_cursors(wd, dc);
            unlink_sharedcursor(tmp);
        } else
            dc->shared_cursor = link_sharedcursor(sc->shared_cursor);
    }
    return Succeeded;
}

static void setup_cursor(wdp wd, char *name, int id)
{
    int i;
    struct wcursor *rv;
    i = hasher(hashcstr(name), wd->cursors);
    rv = safe_zalloc(sizeof(struct wcursor));
    rv->name = name;
    rv->shared_cursor = new_sharedcursor(wd, XCreateFontCursor(wd->display, id));
    rv->next = wd->cursors[i];
    wd->cursors[i] = rv;
}

static void setup_cursors(wdp wd)
{
    setup_cursor(wd, "X cursor",	XC_X_cursor);
    setup_cursor(wd, "arrow",		XC_arrow);
    setup_cursor(wd, "based arrow down",XC_based_arrow_down);
    setup_cursor(wd, "based arrow up",	XC_based_arrow_up);
    setup_cursor(wd, "boat",		XC_boat);
    setup_cursor(wd, "bogosity",	XC_bogosity);
    setup_cursor(wd, "bottom left corner",XC_bottom_left_corner);
    setup_cursor(wd, "bottom right corner",XC_bottom_right_corner);
    setup_cursor(wd, "bottom side",	XC_bottom_side);
    setup_cursor(wd, "bottom tee",	XC_bottom_tee);
    setup_cursor(wd, "box spiral",	XC_box_spiral);
    setup_cursor(wd, "center ptr",	XC_center_ptr);
    setup_cursor(wd, "circle",		XC_circle);
    setup_cursor(wd, "clock",		XC_clock);
    setup_cursor(wd, "coffee mug",	XC_coffee_mug);
    setup_cursor(wd, "cross",		XC_cross);
    setup_cursor(wd, "cross reverse",	XC_cross_reverse);
    setup_cursor(wd, "crosshair",	XC_crosshair);
    setup_cursor(wd, "diamond cross",	XC_diamond_cross);
    setup_cursor(wd, "dot",		XC_dot);
    setup_cursor(wd, "dotbox",		XC_dotbox);
    setup_cursor(wd, "double arrow",	XC_double_arrow);
    setup_cursor(wd, "draft large",	XC_draft_large);
    setup_cursor(wd, "draft small",	XC_draft_small);
    setup_cursor(wd, "draped box",	XC_draped_box);
    setup_cursor(wd, "exchange",	XC_exchange);
    setup_cursor(wd, "fleur",		XC_fleur);
    setup_cursor(wd, "gobbler",		XC_gobbler);
    setup_cursor(wd, "gumby",		XC_gumby);
    setup_cursor(wd, "hand1",		XC_hand1);
    setup_cursor(wd, "hand2",		XC_hand2);
    setup_cursor(wd, "heart",		XC_heart);
    setup_cursor(wd, "icon",		XC_icon);
    setup_cursor(wd, "iron cross",	XC_iron_cross);
    setup_cursor(wd, "left ptr",	XC_left_ptr);
    setup_cursor(wd, "left side",	XC_left_side);
    setup_cursor(wd, "left tee",	XC_left_tee);
    setup_cursor(wd, "leftbutton",	XC_leftbutton);
    setup_cursor(wd, "ll angle",	XC_ll_angle);
    setup_cursor(wd, "lr angle",	XC_lr_angle);
    setup_cursor(wd, "man",		XC_man);
    setup_cursor(wd, "middlebutton",	XC_middlebutton);
    setup_cursor(wd, "mouse",		XC_mouse);
    setup_cursor(wd, "pencil",		XC_pencil);
    setup_cursor(wd, "pirate",		XC_pirate);
    setup_cursor(wd, "plus",		XC_plus);
    setup_cursor(wd, "question arrow",	XC_question_arrow);
    setup_cursor(wd, "right ptr",	XC_right_ptr);
    setup_cursor(wd, "right side",	XC_right_side);
    setup_cursor(wd, "right tee",	XC_right_tee);
    setup_cursor(wd, "rightbutton",	XC_rightbutton);
    setup_cursor(wd, "rtl logo",	XC_rtl_logo);
    setup_cursor(wd, "sailboat",	XC_sailboat);
    setup_cursor(wd, "sb down arrow",	XC_sb_down_arrow);
    setup_cursor(wd, "sb h double arrow",	XC_sb_h_double_arrow);
    setup_cursor(wd, "sb left arrow",	XC_sb_left_arrow);
    setup_cursor(wd, "sb right arrow",	XC_sb_right_arrow);
    setup_cursor(wd, "sb up arrow",	XC_sb_up_arrow);
    setup_cursor(wd, "sb v double arrow",	XC_sb_v_double_arrow);
    setup_cursor(wd, "shuttle",		XC_shuttle);
    setup_cursor(wd, "sizing",		XC_sizing);
    setup_cursor(wd, "spider",		XC_spider);
    setup_cursor(wd, "spraycan",	XC_spraycan);
    setup_cursor(wd, "star",		XC_star);
    setup_cursor(wd, "target",		XC_target);
    setup_cursor(wd, "tcross",		XC_tcross);
    setup_cursor(wd, "top left arrow",	XC_top_left_arrow);
    setup_cursor(wd, "top left corner",	XC_top_left_corner);
    setup_cursor(wd, "top right corner",XC_top_right_corner);
    setup_cursor(wd, "top side",	XC_top_side);
    setup_cursor(wd, "top tee",		XC_top_tee);
    setup_cursor(wd, "trek",		XC_trek);
    setup_cursor(wd, "ul angle",	XC_ul_angle);
    setup_cursor(wd, "umbrella",	XC_umbrella);
    setup_cursor(wd, "ur angle",	XC_ur_angle);
    setup_cursor(wd, "watch",		XC_watch);
    setup_cursor(wd, "xterm",		XC_xterm);
}

#begdef CheckUnhidden(ws)
do {
   if (!ws->win) {
      LitWhy("Window is hidden");
      return Failed;
   }
} while(0)
#enddef

static time_t curr_secs()
{
    struct timeval tp;
    if (gettimeofday(&tp, 0) < 0)
        return 0;
    return tp.tv_sec;
}

/*
 * A convenient wrapper around XGetAtomName, which returns a pointer
 * to a static string.
 */
static char *get_atom_name(wdp wd, Atom a)
{
    static char *t;
    /* XGetAtomName raises an error on None. */
    if (a == None)
        return "(None)";
    if (t)
        XFree(t);
    MemProtect(t = XGetAtomName(wd->display, a));
    return t;
}

/*
 * Get the string name of the given Atom into the descriptor pointed
 * to by dest, which should be tended.
 */
static void get_atom_descriptor(wdp wd, Atom a, dptr dest)
{
    cstr2string(get_atom_name(wd, a), dest);
}

static Atom convert_target(wdp wd, Atom desired_target)
{
    /* Check for common cases. */
    if ( (desired_target == ATOM(wd, TIMESTAMP))    ||
         (desired_target == ATOM(wd, LIST_LENGTH) ) ||
         (desired_target == ATOM(wd, SPAN) ) ||
         (desired_target == ATOM(wd, CHARACTER_POSITION) ) ||
         (desired_target == ATOM(wd, LENGTH) ) ) {
        return XA_INTEGER;
    }

    if ( desired_target == ATOM(wd, TARGETS) ) {
        return XA_ATOM;
    }

    if ( desired_target == ATOM(wd, CLIENT_WINDOW) ) {
        return XA_WINDOW;
    }

    /* Otherwise, no need to convert target. */
    return desired_target;
}

static char* property_to_string(wdp wd, Atom target, int number_items, void* data, int append)
{
    char *result = 0;
    int i, length;

    /* Convert target, if necessary. */
    target = convert_target(wd, target);

    switch (target) {
        case XA_ATOM: {
            int curr_len, total_len;
            unsigned long *long_array = (unsigned long *)data;

            length = number_items * 10 + 1;
            result = safe_malloc(length);
            *result = 0;
            total_len = 0;

            /* Convert to atom names. */
            for (i = 0; i < number_items; i++) { 
                char *atom_name = get_atom_name(wd, long_array[i]);
                curr_len = strlen(atom_name) + 1;    /* +1 for the \n */
                if (total_len + curr_len + 1 > length) {  /* +1 for the \0 */
                    length = total_len + curr_len + 1;
                    result = safe_realloc(result, length);
                }
                sprintf(result + total_len, "%s\n", atom_name);
                total_len += curr_len;
            }
            break;
        }
        case XA_INTEGER: {
            long *long_array = (long *)data;
            length = number_items * 20 + 1;
            result = safe_malloc(length);
            *result = 0;
            for (i = 0; i < number_items; i++) {
                if (i > 0 || append)
                    strcat(result, " ");
                sprintf(result + strlen(result), "%ld", long_array[i]);
            }
            break;
        }
        case XA_WINDOW: {
            unsigned long *long_array = (unsigned long *)data;
            length = number_items * 12 + 1;
            result = safe_malloc(length);
            *result = 0;
            for (i = 0; i < number_items; i++) {
                if (i > 0 || append)
                    strcat(result, " ");
                sprintf(result + strlen(result), "0x%8.8lu", long_array[i]);
            }
            break;
        }
    }

    return result;
}

static wsp wsp_for_Window(wdp wd, Window w)
{
    wsp ws;
    for (ws = wd->vwstates; ws; ws = ws->vnext) {
        if (ws->win == w)
            return ws;
    }
    return 0;
}

static void show_helpers(wdp wd)
{
    int i;
    time_t now;
    now = curr_secs();
    printf("\tSending helpers:\n");
    for (i = 0; i < NUM_SENDING_HELPERS; ++i) {
        struct sending_helper *x;
        x = &wd->sending_helpers[i];
        if (x->target == None)
            printf("\t%d: is free\n", i);
        else {
            printf("\t%d: receiver=%lx data=(%p, %d) age=%d ", i,
                   (long)x->receiver, StrLoc(x->data), (int)StrLen(x->data),
                   (int)(now - x->active));
            printf("property=%s ", get_atom_name(wd, x->property));
            printf("target=%s\n", get_atom_name(wd, x->target));
        }
    }
    printf("\tReceiving helpers:\n");
    for (i = 0; i < NUM_PROP_ATOMS; ++i) {
        struct receiving_helper *x;
        x = &wd->receiving_helpers[i];
        if (x->target == None)
            printf("\t%d: is free\n", i);
        else {
            printf("\t%d: receiver=%lx expect=%d size=%d age=%d ", i,
                   (long)x->receiver, (int)x->expect, (int)x->size,
                   (int)(now - x->active));
            printf("selection=%s ", get_atom_name(wd, x->selection));
            printf("target=%s\n", get_atom_name(wd, x->target));
        }
    }
}

static int which_selection_property(wdp wd, Atom a)
{
    int i;
    for (i = 0; i < NUM_PROP_ATOMS; ++i) {
        if (a == wd->atoms[ATOM__OBJECTICON_PROP0 + i])
            return i;
    }
    return -1;
}

/*
 * Check whether we should stop listening for property changes when
 * resetting the given helper.
 */
static int should_stop_property_listener(wdp wd, struct sending_helper *x)
{
    int i;
    struct sending_helper *y;
    if (wsp_for_Window(wd, x->receiver))
        return 0;
    /* Check if we must keep listening because of another helper. */
    for (i = 0; i < NUM_SENDING_HELPERS; ++i) {
        y = &wd->sending_helpers[i];
        if (y != x && y->receiver == x->receiver) 
            return 0;
    }
    return 1;
}

/*
 * Called only once for each helper.
 */
static void init_sending_helper(struct sending_helper *x)
{
    x->data = nulldesc;
    x->property = x->target = None;
    x->receiver = None;
    x->active = 0;
    add_gc_global(&x->data);
}

/*
 * Called to reset a helper to its unused condition.
 */
static void reset_sending_helper(wdp wd, struct sending_helper *x)
{
    x->data = nulldesc;
    x->property = x->target = None;
    x->active = 0;
    if (x->receiver != None) {
        if (should_stop_property_listener(wd, x)) {
            if (selection_debug)
                printf("\tNo longer listening for PropertyNotify events on %lx\n", (long)x->receiver);
            XSelectInput(wd->display, x->receiver, 0);
        }
        x->receiver = None;
    }
}

/*
 * Reset any helpers that haven't been active for a while.
 */
static void purge_stale_helpers(wdp wd)
{
    int i;
    time_t now;
    now = curr_secs();
    for (i = 0; i < NUM_SENDING_HELPERS; ++i) {
        struct sending_helper *x;
        x = &wd->sending_helpers[i];
        if (x->active != 0 && now - x->active > SelectionHelperPurgeTime) {
            if (selection_debug)
                printf("\tPurging stale sending helper entry %d\n", i);
            reset_sending_helper(wd, x);
        }
    }        
    for (i = 0; i < NUM_PROP_ATOMS; ++i) {
        struct receiving_helper *x;
        x = &wd->receiving_helpers[i];
        if (x->active != 0 && now - x->active > SelectionHelperPurgeTime) {
            if (selection_debug)
                printf("\tPurging stale receiving helper entry %d\n", i);
            reset_receiving_helper(x);
        }
    }
}

/*
 * Choose a free helper; if one can't be found, evict one, and return
 * that.
 */
static struct sending_helper *get_free_sending_helper(wdp wd)
{
    int i;
    struct sending_helper *x;
    for (i = 0; i < NUM_SENDING_HELPERS; ++i) {
        x = &wd->sending_helpers[i];
        if (x->target == None)
            return x;
    }
    x = &wd->sending_helpers[0];
    reset_sending_helper(wd, x);
    return x;
}

/*
 * Search for a helper with matching receiver and property fields;
 * there must be at most one such entry.
 */
static struct sending_helper *match_sending_helper(wdp wd, Window receiver, Atom property)
{
    int i;
    struct sending_helper *x;
    for (i = 0; i < NUM_SENDING_HELPERS; ++i) {
        x = &wd->sending_helpers[i];
        if (x->receiver == receiver && x->property == property)
            return x;
    }        
    return 0;
}

/*
 * Called to reset a helper to its unused condition.
 */
static void reset_receiving_helper(struct receiving_helper *h)
{
    free(h->result);
    h->result = 0;
    h->size = h->expect = 0;
    h->target = h->selection = None;
    h->receiver = None;
    h->active = 0;
}

static void handle_selection_request(wsp ws, XSelectionRequestEvent *event)
{
    tended struct descrip tmp;
    wdp wd = ws->display;
    if (selection_debug) {
        printf("handle_selection_request:\n\towner=%lx requestor=%lx property=%s",
               (long)event->owner,
               (long)event->requestor,
               get_atom_name(wd, event->property));
        printf(" target=%s", get_atom_name(wd, event->target));
        printf(" selection=%s\n", get_atom_name(wd, event->selection));
    }

    MakeInt(SELECTIONREQUEST, &tmp);
    list_put(&ws->listp, &tmp);
    MakeInt((word)event->requestor, &tmp);
    list_put(&ws->listp, &tmp);
    get_atom_descriptor(wd, event->property, &tmp);
    list_put(&ws->listp, &tmp);
    get_atom_descriptor(wd, event->selection, &tmp);
    list_put(&ws->listp, &tmp);
    get_atom_descriptor(wd, event->target, &tmp);
    list_put(&ws->listp, &tmp);
    MakeInt(event->time, &tmp);
    list_put(&ws->listp, &tmp);
}

static void handle_selection_clear(wsp ws, XSelectionClearEvent *event)
{
    tended struct descrip tmp;
    wdp wd = ws->display;
    if (selection_debug)
        printf("handle_selection_clear: win=%lx selection=%s\n",
               (long)event->window,
               get_atom_name(wd, event->selection));
    MakeInt(SELECTIONCLEAR, &tmp);
    list_put(&ws->listp, &tmp);
    get_atom_descriptor(wd, event->selection, &tmp);
    list_put(&ws->listp, &tmp);
}

static void handle_selection_notify(wsp ws, XSelectionEvent *event)
{
    wdp wd = ws->display;
    Atom actual_type;
    int actual_format;
    unsigned long bytes_after, nitems;
    unsigned char *prop;
    word bytes_read;
    tended struct descrip tmp;
    int status, pn, err;
    char *conv_str;

    if (selection_debug) {
        printf("handle_selection_notify: requestor=%lx selection=%s",
               (long)event->requestor, get_atom_name(wd, event->selection));
        printf(" target=%s", get_atom_name(wd, event->target));
        printf(" property=%s\n", get_atom_name(wd, event->property));
    }

    prop = 0;
    err = 0;

    pn = which_selection_property(wd, event->property);
    if (pn < 0) {
        if (selection_debug)
            printf("\tXGetWindowProperty xselection.property == None or other unknown\n");
        err = 1;
    } else {
        status = XGetWindowProperty(wd->display,
                                    ws->win,
                                    event->property,
                                    0,
                                    max_selection_size / 4,
                                    True,
                                    AnyPropertyType,
                                    &actual_type,
                                    &actual_format,
                                    &nitems,
                                    &bytes_after,
                                    &prop);

        /* Check for various error conditions. */
        if (status != Success) {
            if (selection_debug)
                printf("\tXGetWindowProperty failed\n");
            err = 1;
        } else if (actual_type == None) {
            if (selection_debug)
                printf("\tXGetWindowProperty returned actual_type == None\n");
            err = 1;
        } else if (!prop) {
            if (selection_debug)
                printf("\tXGetWindowProperty set prop to null\n");
            err = 1;
        } else if (bytes_after > 0) {
            if (selection_debug)
                printf("\tSelection too big, bytes_after=%lu\n", bytes_after);
            err = 1;
        } else if (actual_type == ATOM(wd, INCR)) {
            long expect = *((long *)prop);
            if (expect > 0 && expect <= max_selection_size) {
                struct receiving_helper *h;
                if (selection_debug)
                    printf("\tIncremental selection started, expected size=%ld\n", expect);
                h = &wd->receiving_helpers[pn];
                reset_receiving_helper(h);
                h->selection = event->selection;
                h->target = event->target;
                h->expect = expect;
                h->receiver = ws->win;
                h->active = curr_secs();
            } else {
                if (selection_debug)
                    printf("\tIncremental selection expected size out of range (%ld)\n", expect);
                err = 1;
            }
        } else {
            /* Success */
            MakeInt(SELECTIONRESPONSE, &tmp);
            list_put(&ws->listp, &tmp);
            get_atom_descriptor(wd, event->selection, &tmp);
            list_put(&ws->listp, &tmp);
            get_atom_descriptor(wd, event->target, &tmp);
            list_put(&ws->listp, &tmp);
            bytes_read = nitems * (actual_format / 8);
            if (selection_debug)
                printf("\tGot %lu items x %d bits -> %ld bytes actual_type=%s\n",
                       nitems, actual_format, (long)bytes_read, get_atom_name(wd, actual_type));

            conv_str = property_to_string(wd,
                                          actual_type,
                                          nitems,
                                          prop,
                                          0);
            if (conv_str) {
                /* Make an Icon string out of the data */
                cstr2string(conv_str, &tmp);
                free(conv_str);
            } else {
                /* Make an Icon string out of the data */
                bytes2string((char *)prop, bytes_read, &tmp);
            }
            list_put(&ws->listp, &tmp);
        }
    }

    if (err) {
        MakeInt(SELECTIONRESPONSE, &tmp);
        list_put(&ws->listp, &tmp);
        get_atom_descriptor(wd, event->selection, &tmp);
        list_put(&ws->listp, &tmp);
        get_atom_descriptor(wd, event->target, &tmp);
        list_put(&ws->listp, &tmp);
        list_put(&ws->listp, &nulldesc);
    }
    if (prop)
        XFree(prop);
}

void pollevent(wbp w)
{
    wdp wd = w->window->display;
    XEvent event;
    Window evwin;
    wsp ws;
    while (XPending(wd->display)) {
        XNextEvent(wd->display, &event);
        /* Incremental selections may cause PropertyNotify events that
         * must be handled specially. */
        if (event.type == PropertyNotify && handle_incr_property(wd, (XPropertyEvent *)&event))
            continue;

        evwin = event.xexpose.window;  /* go ahead, criticize all you like */
        ws = wsp_for_Window(wd, evwin);
        if (!ws)
            continue;

        switch (event.type) {
            case SelectionRequest:
                handle_selection_request(ws, (XSelectionRequestEvent *)&event);
                break;
            case SelectionClear:
                handle_selection_clear(ws, (XSelectionClearEvent *)&event);
                break;
            case SelectionNotify:
                handle_selection_notify(ws, (XSelectionEvent *)&event);
                break;

            case KeyRelease:
            case KeyPress:
                handle_keypress(ws, (XKeyEvent *)&event);
                break;
            case ButtonPress:
            case ButtonRelease:
            case MotionNotify:
                handle_mouse(ws, (XButtonEvent *)&event);
                break;
            case LeaveNotify:
            case EnterNotify:
                handle_crossing(ws, (XCrossingEvent *)&event);
                break;
            case NoExpose:
                break;
            case Expose:
                handle_exposures(ws, (XExposeEvent *)&event);
                break;
            case PropertyNotify:
                handle_property(ws, (XPropertyEvent *)&event);
                break;
            case UnmapNotify:
            case MapNotify:
                break;
            case ConfigureNotify:
                handle_config(ws, (XConfigureEvent *)&event);
                break;
            case FocusIn:
                qeventcode(ws, FOCUSIN);
                break;
            case FocusOut:
                qeventcode(ws, FOCUSOUT);
                break;
            case ClientMessage:
                handle_client_message(ws, (XClientMessageEvent *)&event);
                break;
            default:
                break;
        }
    }
}

static void close_screen_win(wsp ws)
{
    wdp wd = ws->display;
    XRenderFreePicture(wd->display, ws->wpic);
    XDestroyWindow(wd->display, ws->win);
    XFlush(wd->display);
    ws->win = 0;
    ws->wpic = 0;
    ws->x = ws->y = -INT_MAX;
    GUnlink4(ws, wd->vwstates, vnext, vprevious);
    synch_state(ws);
}

/*
 * open a window
 */
wbp wopen(char *display)
{
    wbp w;
    wsp ws;
    wcp wc;
    wdp wd;
    XRenderPictureAttributes attr;

    if ((wd = alcdisplay(display)) == NULL) {
        /* alcdisplay will have set &why */
        return 0;
    }

    w = alcwbinding(wd);

    GAlloc(ws, _wstate);
    ws->listp = nulldesc;
    ws->windowlabel = defaultwindowlabel;
    add_gc_global(&ws->windowlabel);
    add_gc_global(&ws->listp);
    ws->cursor = lookup_wcursor(wd, "left ptr");
    ws->state = stringint_lookup(canvastypes, "hidden");
    ws->reqx = ws->reqy = ws->x = ws->y = -INT_MAX;
    ws->minwidth = ws->minheight = 1;
    ws->maxwidth = ws->maxheight = INT_MAX;
    ws->width = ws->height = ws->pixwidth = ws->pixheight = 1;
    ws->basewidth = ws->baseheight = 0;
    ws->incwidth = ws->incheight = 1;
    ws->minaspect = ws->maxaspect = 0.0;
    ws->display = wd;
    w->window = ws;
    create_list(64, &ws->listp);

    GAlloc(wc, _wcontext);
    wc->display = wd;
    wc->bg = link_sharedcolor(wd->white);
    wc->fg = link_sharedcolor(wd->black);
    wc->font = wd->defaultfont;
    wc->leading = defaultleading;
    wc->drawop = stringint_lookup(drawops, "over");
    wc->clipx = wc->clipy = 0;
    wc->clipw = wc->cliph = -1;
    wc->linewidth = 1;
    wc->linejoin = stringint_lookup(linejoins, "bevel");
    wc->lineend = stringint_lookup(lineends, "flat");
    wc->fillrule = stringint_lookup(fillrules, "even-odd");

    w->context = wc;

    /*
     * Create the 1x1 pixmap
     */
    ws->pix = XCreatePixmap(wd->display, GetRoot(wd),
                            ws->pixwidth, ws->pixheight,
                            32);
    attr.poly_edge = PolyEdge;
    attr.poly_mode = PolyMode;
    ws->ppic = XRenderCreatePicture(wd->display, ws->pix, wd->pixfmt, CPPolyEdge | CPPolyMode, &attr);

    /* Fill pixmap with background colour */
    XRenderFillRectangle(wd->display,
                         PictOpSrc,
                         ws->ppic,
                         &wc->bg->color,
                         0, 0, ws->width, ws->height);
    return w;
}

int setwindowicon(wbp w, struct imgdata *imd)
{
    wsp ws = w->window;
    int i, j, k;
    if (imd && (imd->width > 512 || imd->height > 512)) {
        LitWhy("Icon too big");
        return Failed;
    }
    free(ws->icondata);
    if (imd) {
        ws->iconlen = 2 + imd->width * imd->height;
        ws->icondata = safe_malloc(ws->iconlen * sizeof(unsigned long));
        k = 0;
        ws->icondata[k++] = imd->width;
        ws->icondata[k++] = imd->height;
        for (j = 0; j < imd->height; ++j) {
            for (i = 0; i < imd->width; ++i) {
                int r, g, b, a;
                imd->format->getpixel(imd, i, j, &r, &g, &b, &a);
                ws->icondata[k++] = ((a/256)<<24) | ((r/256)<<16) | ((g/256)<<8) | (b/256);
            }
        }
        if (ws->win)
            apply_windowicon(ws);
    } else {
        ws->icondata = 0;
        ws->iconlen = 0;
    }
    return Succeeded;
}

int setpattern(wbp w, struct imgdata *imd)
{
    wcp wc = w->context;
    wdp wd = w->window->display;
    if (wc->pattern)
        unlink_sharedpicture(wc->pattern);
    if (imd)
        wc->pattern = new_sharedpicture(wd, imd, 32);
    else
        wc->pattern = 0;
    return Succeeded;
}

int setmask(wbp w, struct imgdata *imd)
{
    wcp wc = w->context;
    wdp wd = w->window->display;
    if (wc->mask)
        unlink_sharedpicture(wc->mask);
    if (imd)
        wc->mask = new_sharedpicture(wd, imd, 8);
    else
        wc->mask = 0;
    return Succeeded;
}

int ishidden(wbp w)
{
    return w->window->win == 0;
}

/*
 * Return an allocated string giving the part of the prog name after the last '/'.
 */
static char *get_progname()
{
    int n;
    char *p, *s, *m;
    p = StrLoc(kywd_prog);
    s = p + StrLen(kywd_prog);
    while (s > p && s[-1] != '/')
        s--;				/* find tail of prog_name */
    n = p + StrLen(kywd_prog) - s;          /* no. of chars to copy */
    m = safe_malloc(n + 1);
    memcpy(m, s, n);
    m[n] = 0;
    return m;
}

static void synch_pos(wsp ws, int newx, int newy)
{
    if ((newx != ws->x) || (newy != ws->y)) {
        ws->x = newx;
        ws->y = newy;
        qeventcode(ws, WINDOWMOVED);
    }
}

/*
 *  Open the X window for a non-hidden icon window.
 */
static void wmap(wbp w)
{
    XWindowAttributes attrs;
    XSetWindowAttributes attr;
    char *m1, *m2;
    XWMHints wmhints;
    XClassHint clhints;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;

    /*
     * create the X window (or use the DefaultRootWindow if requested)
     */
    attr.background_pixel = 0xffffff;  /* TODO wc->bg->c; */

    switch (ws->state->i) {
        case RootState:
            ws->win = GetRoot(wd);
            break;
        case PopupState: {
            attr.override_redirect = True;
            ws->win = XCreateWindow(wd->display, GetRoot(wd),
                                    ws->reqx == -INT_MAX ? 0 : ws->reqx,
                                    ws->reqy == -INT_MAX ? 0 : ws->reqy, 
                                    ws->width, ws->height, 
                                    0,
                                    GetDepth(wd),
                                    InputOutput,
                                    CopyFromParent,
                                    CWBackPixel|CWOverrideRedirect,
                                    &attr);
            break;
        }
        default: {
            ws->win = XCreateWindow(wd->display, GetRoot(wd),
                                    ws->reqx == -INT_MAX ? 0 : ws->reqx,
                                    ws->reqy == -INT_MAX ? 0 : ws->reqy, 
                                    ws->width, ws->height, 
                                    0,
                                    GetDepth(wd),
                                    InputOutput,
                                    CopyFromParent,
                                    CWBackPixel,
                                    &attr);
            break;
        }
    }

    ws->wpic = XRenderCreatePicture(wd->display, ws->win, wd->winfmt, 0, NULL);

    /* Set the optional WM_TRANSIENT_FOR hint. */
    if (ws->transientfor && ws->transientfor->win)
        XSetTransientForHint(wd->display, ws->win, ws->transientfor->win);

    /* Turn off background; this prevents X filling the background on an expose
       and hence prevents unsightly flicker on a resize. */
    XSetWindowBackgroundPixmap(wd->display, ws->win, None);

    XSetWMProtocols(wd->display, ws->win, &ATOM(wd, WM_DELETE_WINDOW), 1);

    XClearWindow(wd->display, ws->win);

    GLink4(ws, wd->vwstates, vnext, vprevious);

    /* For RootState, need to fill since XClearWindow above fills with a pixmap */
    if (ws->state->i == RootState) {
        XRenderFillRectangle(wd->display,
                             PictOpSrc,
                             ws->wpic,
                             &wc->bg->color,
                             0, 0, ws->width, ws->height);
    } else {
        XSizeHints size_hints;
        mk_hints(ws, &size_hints);
        size_hints.flags |= PSize;
        size_hints.width = ws->width;
        size_hints.height= ws->height;
        if (ws->reqx != -INT_MAX && ws->reqy != -INT_MAX) {
            size_hints.flags |= USPosition;
            size_hints.x = ws->reqx;
            size_hints.y = ws->reqy;
        }
        apply_windowlabel(ws);
        XSetWMNormalHints(wd->display, ws->win, &size_hints);
        XSelectInput(wd->display, ws->win, 
                     ExposureMask | KeyPressMask | EnterWindowMask | LeaveWindowMask | FocusChangeMask |
                     ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | PropertyChangeMask |
                     StructureNotifyMask | PointerMotionMask | KeyReleaseMask);

        if (ws->icondata)
            apply_windowicon(ws);
    }

    wmhints.input = True;
    wmhints.flags = InputHint;
    switch (ws->state->i) {
        case IconicState: {
            wmhints.flags |= StateHint;
            wmhints.initial_state = IconicState;
            break;
        }
        case WithdrawnState: {
            wmhints.flags |= StateHint;
            wmhints.initial_state = WithdrawnState;
            break;
        }
        case RootState:
            break;
        default: {
            wmhints.flags |= StateHint;
            wmhints.initial_state = NormalState;
            break;
        }
    }
    XSetWMHints(wd->display, ws->win, &wmhints);

    /*
     * Set the class hints that name the program (for reference by the
     * window manager) following conventions given in O'Reilly.
     */
    if (resource_name) {
        clhints.res_name = resource_name;
        m1 = 0;
    } else {
        m1 = get_progname();
        clhints.res_name = m1;
    }
    if (resource_class) {
        clhints.res_class = resource_class;
        m2 = 0;
    } else {
        /* Defaults to prog name, with first letter capitalized (see X(7) manpage). */
        m2 = get_progname();
        m2[0] = oi_toupper(m2[0]);
        clhints.res_class = m2;
    }
    XSetClassHint(wd->display, ws->win, &clhints);
    free(m1);
    free(m2);

    /* This is a convenient way to set the WM_CLIENT_MACHINE and
     * WM_LOCALE_NAME properties. */
    XSetWMProperties(wd->display, ws->win, 0, 0, 0, 0, 0, 0, 0);

    switch (ws->state->i) {
        case MaximizedState: {
            Atom atoms[2];
            atoms[0] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
            atoms[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
            XChangeProperty(wd->display, ws->win,
                            ATOM(wd, _NET_WM_STATE),
                            XA_ATOM, 32,
                            PropModeReplace, (unsigned char *)atoms, 2);
            break;
        }
        case FullScreenState: {
            Atom atoms[1];
            atoms[0] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
            XChangeProperty(wd->display, ws->win,
                            ATOM(wd, _NET_WM_STATE),
                            XA_ATOM, 32,
                            PropModeReplace, (unsigned char *)atoms, 1);
            break;
        }
        case ShadedState: {
            Atom atoms[1];
            atoms[0] = ATOM(wd, _NET_WM_STATE_SHADED);
            XChangeProperty(wd->display, ws->win,
                            ATOM(wd, _NET_WM_STATE),
                            XA_ATOM, 32,
                            PropModeReplace, (unsigned char *)atoms, 1);
            break;
        }
    }

    if (ws->state->i != RootState && ws->state->i != WithdrawnState)
        XMapWindow(wd->display, ws->win);

    XGetWindowAttributes(wd->display, ws->win, &attrs);
    ws->width = attrs.width;
    ws->height = attrs.height;
    resizepixmap(w);

    synch_cursor(ws);

    XSync(wd->display, False);

    /*
     * This is a guess, but it is indispensable for popups, since
     * those will never receive an update, even via UpdateCommon
     * (because of mouse/keyboard grabs).
     */
    synch_pos(ws,
              ws->reqx == -INT_MAX ? 0 : ws->reqx,
              ws->reqy == -INT_MAX ? 0 : ws->reqy);
}

static void synch_net_wm_state(wsp ws, int desired_state)
{
    XEvent e;
    wdp wd = ws->display;
    e.xclient.type = ClientMessage;
    e.xclient.serial = 0;
    e.xclient.display = 0;
    e.xclient.send_event = True;
    e.xclient.message_type = ATOM(wd, _NET_WM_STATE);
    e.xclient.format = 32;
    e.xclient.window = ws->win;
    e.xclient.data.l[3] = 0;
    switch (desired_state) {
        case NormalState: {
            e.xclient.data.l[0] = _NET_WM_STATE_REMOVE;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
            e.xclient.data.l[2] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_SHADED);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            break;
        }
        case MaximizedState: {
            e.xclient.data.l[0] = _NET_WM_STATE_REMOVE;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_SHADED);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[0] = _NET_WM_STATE_ADD;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
            e.xclient.data.l[2] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            break;
        }
        case FullScreenState: { 
            e.xclient.data.l[0] = _NET_WM_STATE_REMOVE;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
            e.xclient.data.l[2] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_SHADED);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[0] = _NET_WM_STATE_ADD;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            break;
        }
        case ShadedState: { 
            e.xclient.data.l[0] = _NET_WM_STATE_REMOVE;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
            e.xclient.data.l[2] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[0] = _NET_WM_STATE_ADD;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_SHADED);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            break;
        }
        default: {
            syserr("Invalid desired_state");
            break;
        }
    }
    XSync(wd->display, False);
}

static void mk_hints(wsp ws, XSizeHints *h)
{
    h->flags = PMinSize | PMaxSize;
    if (ws->resizable) {
        h->min_width = ws->minwidth;
        h->min_height = ws->minheight;
        h->max_width = ws->maxwidth;
        h->max_height = ws->maxheight;
        if (ws->minaspect != 0.0 || ws->maxaspect != 0.0) {
            h->flags |= PAspect;
            h->min_aspect.x = 10000 * ws->minaspect;
            h->min_aspect.y = 10000;
            if (ws->maxaspect != 0.0) {
                h->max_aspect.x = 10000 * ws->maxaspect;
                h->max_aspect.y = 10000;
            } else {
                h->max_aspect.x = INT_MAX;
                h->max_aspect.y = 1;
            }
        }
        if (ws->incwidth != 1 || ws->incheight != 1) {
            h->flags |= PResizeInc;
            h->width_inc = ws->incwidth;
            h->height_inc = ws->incheight;
        }
        if (h->flags & (PAspect | PResizeInc)) {
            h->flags |= PBaseSize;
            h->base_width = ws->basewidth;
            h->base_height = ws->baseheight;
        }
    }
    else {
        h->min_width = h->max_width = ws->width;
        h->min_height = h->max_height = ws->height;
    }
}

void doconfig(wbp w, int status)
{
    wsp ws = w->window;
    wdp wd = ws->display;

    if (ws->win) {
        if (status & (C_SIZE | C_MINSIZE | C_MAXSIZE | C_RESIZE |
                      C_MINASPECT | C_MAXASPECT | C_BASESIZE | C_INCSIZE)) {
            XSizeHints size_hints;
            mk_hints(ws, &size_hints);
            XSetWMNormalHints(wd->display, ws->win, &size_hints);
        }
        switch (status & (C_POS | C_SIZE)) {
            case C_POS: {
                XMoveWindow(wd->display, ws->win, ws->reqx, ws->reqy);
                break;
            }
            case C_SIZE: {
                XResizeWindow(wd->display, ws->win, ws->width, ws->height);
                break;
            }
            case C_POS | C_SIZE: {
                XMoveResizeWindow(wd->display, ws->win, ws->reqx, ws->reqy, ws->width, ws->height);
                break;
            }
        }
    }
    if (status & C_SIZE)
        resizepixmap(w);
}

static int (*default_XErrorHandler)(Display *, XErrorEvent *);

static int custom_XErrorHandler(Display *display, XErrorEvent *err)
{
    /*
     * A BadWindow can occur when handling selections, when a window
     * closes unexpectedly.  The three problematic calls are
     * XChangeProperty(), XSendEvent() or a XSelectInput().
     */
    if (err->error_code == BadWindow && 
         (err->request_code == X_ChangeProperty ||
          err->request_code == X_SendEvent ||
          err->request_code == X_ChangeWindowAttributes)) {
        return 0;
    }
    return default_XErrorHandler(display, err);
}

static convert_to_macro(INT32)

/*
 * data is a safe pointer into a frame.
 */
int sendselectionresponse(wbp w, word requestor, char *property, char *selection, char *target, word time, dptr data)
{
    Atom property_atom, target_atom, selection_atom, target_list[32];
    XEvent ev;
    struct lgstate state;
    tended struct b_lelem *le;
    tended char *cstr_target;
    int target_cnt = 1;
    struct sending_helper *h;
    wsp ws = w->window;
    wdp wd = ws->display;

    if (selection_debug)
        printf("sendselectionresponse:\n\trequestor=%lx "
               "property=%s target=%s selection=%s time=%ld\n",
               (long)requestor, property, target, selection, (long)time);

    property_atom = XInternAtom(wd->display, property, False);
    target_atom = XInternAtom(wd->display, target, False);
    selection_atom = XInternAtom(wd->display, selection, False);

    if (selection_debug)
        show_helpers(wd);

    purge_stale_helpers(wd);

    /* Check for an existing matching helper; we must not have more
     * than one helper with the same receiver/property combination,
     * and even if this response isn't an incremental one, we don't
     * want the property changes below to get muddled up with an
     * incremental send to the same destination.
     */
    h = match_sending_helper(wd, requestor, property_atom);
    if (h) {
        if (selection_debug)
            printf("\tResetting existing sending_helper matching requestor, property pair (no %d)\n", (int)(h - wd->sending_helpers));
        reset_sending_helper(wd, h);
    }

    if (target_atom == ATOM(wd, TARGETS)) {
        if (!is:list(*data))
            ReturnErrVal(108, *data, Error);
        target_list[0] = ATOM(wd, TARGETS);
        for (le = lgfirst(&ListBlk(*data), &state); le;
             le = lgnext(&ListBlk(*data), &state, le)) {
            if (!cnv:C_string(le->lslots[state.result], cstr_target))
                ReturnErrVal(148, le->lslots[state.result], Error);
            if (target_cnt < ElemCount(target_list)) {
                target_list[target_cnt++] = XInternAtom(wd->display, cstr_target, False);
                if (selection_debug)
                    printf("\tAdding target:%s\n", cstr_target);
            }
        }
        XChangeProperty(wd->display,
                        requestor,
                        property_atom,
                        XA_ATOM,
                        32,
                        PropModeReplace,
                        (unsigned char *)target_list,
                        target_cnt);
        ev.xselection.property = property_atom;
    } else if (is:null(*data)) {
        /* Can't handle this target type */
        if (selection_debug)
            printf("\tSetting property to None\n");
        ev.xselection.property = None;
    } else if (convert_target(wd, target_atom) == XA_INTEGER) {
        INT32 i32;
        long l;
        if (!cnv:integer(*data, *data))
            ReturnErrVal(101, *data, Error);
        if (!convert_to_INT32(data, &i32))
            /* the convert function has set the error values itself */
            return Error;
        /* The data is sent as a long regardless of whether that is 32 or 64 bits. */
        l = i32;
        if (selection_debug)
            printf("\tSetting property to INTEGER data %ld\n", l);
        XChangeProperty(wd->display,
                        requestor,
                        property_atom,
                        XA_INTEGER,
                        32,
                        PropModeReplace,
                        (unsigned char *)&l,
                        1);
        ev.xselection.property = property_atom;
    } else {
        if (!cnv:string(*data, *data))
            ReturnErrVal(103, *data, Error);
        if (StrLen(*data) > max_selection_size) {
            if (selection_debug)
                printf("\tSelection too big; setting property to None\n");
            ev.xselection.property = None;
        } else if (StrLen(*data) > max_selection_chunk) {
            long l;
            if (selection_debug)
                printf("\tStarting INCR transfer, total %d bytes of data\n", (int)StrLen(*data));
            l = StrLen(*data);
            XChangeProperty(wd->display,
                            requestor,
                            property_atom,
                            ATOM(wd, INCR),
                            32,
                            PropModeReplace,
                            (unsigned char *)&l,
                            1);
            /* Choose a free helper. */
            h = get_free_sending_helper(wd);
            if (selection_debug)
                printf("\tUsing sending_helper %d\n", (int)(h - wd->sending_helpers));
            h->data = *data;
            h->property = property_atom;
            h->receiver = requestor;
            h->target = target_atom;
            h->active = curr_secs();
            /* Note that we mustn't check here whether we seem to be
             * already listening by checking the other helpers; those
             * Window IDs may be stale ones that have since been
             * reused.
             */
            if (!wsp_for_Window(wd, requestor)) {
                if (selection_debug)
                    printf("\tListening for PropertyNotify events on %lx\n", (long)requestor);
                XSelectInput(wd->display, requestor, PropertyChangeMask);
            }
            ev.xselection.property = property_atom;
        } else {
            if (selection_debug)
                printf("\tSetting property to %d bytes of data\n", (int)StrLen(*data));
            XChangeProperty(wd->display,
                            requestor,
                            property_atom,
                            target_atom,
                            8,
                            PropModeReplace,
                            (unsigned char *)StrLoc(*data),
                            StrLen(*data));
            ev.xselection.property = property_atom;
        }
    }

    ev.type = SelectionNotify;
    ev.xselection.serial = 0;
    ev.xselection.display = 0;
    ev.xselection.send_event = True;
    ev.xselection.requestor = requestor;
    ev.xselection.selection = selection_atom;
    ev.xselection.target = target_atom;
    ev.xselection.time = time;

    XSendEvent(wd->display,
               requestor,
               False, NoEventMask, &ev);

    return Succeeded;
}

int ownselection(wbp w, char *selname, word *time)
{
    Atom selection;
    Window curr;
    wsp ws = w->window;
    wdp wd = ws->display;

    CheckUnhidden(ws);

    selection = XInternAtom(wd->display, selname, False);
    curr = XGetSelectionOwner(wd->display, selection);

    /* Check for no change in selection */
    if (curr == ws->win) {
        if (selection_debug)
            printf("ownselection: Ownership of selection %s retained by %lx\n",
                   get_atom_name(wd, selection), (long)ws->win);
    } else {
        if (selection_debug)
            printf("ownselection: Owner of selection %s set from %lx -> %lx\n",
                   get_atom_name(wd, selection), (long)curr, (long)ws->win);

        /*
         * X doesn't send a SelectionClear event to us when the selection
         * changes between our own windows, so if the current owner is one
         * our windows, send it a "clear" message.
         */
        if (curr) {
            wsp x;
            for (x = wd->vwstates; x; x = x->vnext) {
                if (x->win == curr) {
                    tended struct descrip tmp;
                    if (selection_debug)
                        printf("\tEnqueueing artificial SELECTIONCLEAR to current owner %lx\n", (long)curr);
                    MakeInt(SELECTIONCLEAR, &tmp);
                    list_put(&x->listp, &tmp);
                    get_atom_descriptor(wd, selection, &tmp);
                    list_put(&x->listp, &tmp);
                    break;
                }
            }
        }
    }
    XSetSelectionOwner(wd->display, 
                       selection,
                       ws->win,
                       wd->recent);

    /*
     * Time is an unsigned quantity, maybe 64 bits, but the TIMESTAMP
     * selection must be returned as a 32 bit signed integer, so the
     * Time is cast here.  This may lead to a negative result.
     */

    *time = (word)(INT32)wd->recent;

    if (selection_debug)
        printf("\tSelection time was %lu, converted to " WordFmt "\n", 
               (unsigned long)wd->recent, *time);

    return Succeeded;
}

int requestselection(wbp w, char *selname, char *targetname)
{
    Atom selection, target, property;
    int pn;
    wsp ws = w->window;
    wdp wd = ws->display;
    CheckUnhidden(ws);
    selection = XInternAtom(wd->display, selname, False);
    target = XInternAtom(wd->display, targetname, False);
    /* 
     * Use 8 property atoms to allow multiple concurrent requests
     * without the results getting mixed up.  Obviously this isn't
     * perfect, but is better than nothing.
     */
    pn = (wd->propcount++) % NUM_PROP_ATOMS;
    property = wd->atoms[ATOM__OBJECTICON_PROP0 + pn];
    if (selection_debug) {
        printf("requestselection: calling XConvertSelection selection=%s", get_atom_name(wd, selection));
        printf(" target=%s", get_atom_name(wd, target));
        printf(" property=%s", get_atom_name(wd, property));
        printf(" requestor=%lx\n", (long)ws->win);
    }

    if (selection_debug)
        show_helpers(wd);

    purge_stale_helpers(wd);

    /* Clear any receiving_helper which would mistake the
     * SelectionNotify response property for part of an INCR
     * selection.
     */
    if (wd->receiving_helpers[pn].receiver == ws->win) {
        if (selection_debug)
            printf("\tResetting existing receiving_helper with matching window (no %d)\n", pn);
        reset_receiving_helper(&wd->receiving_helpers[pn]);
    }

    XConvertSelection(wd->display,
                      selection, 
                      target, 
                      property,
                      ws->win,
                      CurrentTime);

    return Succeeded;
}

int warppointer(wbp w, int x, int y)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    XWarpPointer(ws->display->display, None, ws->win, 0,0,0,0, x, y);
    return Succeeded;
}

static void apply_windowlabel(wsp ws)
{
    wdp wd = ws->display;
    XChangeProperty(wd->display, ws->win,
                    ATOM(wd, _NET_WM_NAME), 
                    ATOM(wd, UTF8_STRING),
                    8,
                    PropModeReplace, 
                    (unsigned char *)StrLoc(UcsBlk(ws->windowlabel).utf8),
                    StrLen(UcsBlk(ws->windowlabel).utf8));
}

static void apply_windowicon(wsp ws)
{
    wdp wd = ws->display;
    XChangeProperty(wd->display, ws->win,
                    ATOM(wd, _NET_WM_ICON), 
                    XA_CARDINAL, 
                    32,
                    PropModeReplace, 
                    (unsigned char *)ws->icondata,
                    ws->iconlen);
}

int setwindowlabel(wbp w, dptr val)
{
    wsp ws = w->window;
    ws->windowlabel = *val;
    if (ws->win)
        apply_windowlabel(ws);
    return Succeeded;
}

static void synch_cursor(wsp ws)
{
    XDefineCursor(ws->display->display, ws->win, ws->cursor->shared_cursor->cursor);
}

/*
 * setpointer() - define a mouse pointer shape
 */
int setpointer(wbp w, char *val)
{
    struct wcursor *c;
    wsp ws = w->window;
    c = lookup_wcursor(ws->display, val);
    if (!c)
        return Failed;
    ws->cursor = c;
    if (ws->win)
        synch_cursor(ws);
    return Succeeded;
}

/*
 * setdrawop() - set the drawing operation
 */
int setdrawop(wbp w, char *val)
{
    stringint *e;
    wcp wc = w->context;
    e = stringint_lookup(drawops, val);
    if (!e)
        return Failed;
    wc->drawop = e;
    return Succeeded;
}

wbp clonewindow(wbp w)
{
    wbp w2;
    w2 = alcwbinding(w->window->display);
    w2->window = linkwindow(w->window);
    w2->context = clonecontext(w->context);
    return w2;
}

wbp couplewindows(wbp w1, wbp w2)
{
    wbp w3;
    if (w1->window->display != w2->context->display) {
        LitWhy("Can't couple between different displays");
        return 0;
    }
    w3 = alcwbinding(w1->window->display);
    w3->window = linkwindow(w1->window);
    w3->context = linkcontext(w2->context);
    return w3;
}

static void clip(wbp w)
{
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;
    XRectangle rec;
    if (wc->clipw >= 0) {
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XRenderSetPictureClipRectangles(wd->display,
                                        ws->ppic,
                                        0, 0, &rec, 1);
        if (Copying(ws))
            XRenderSetPictureClipRectangles(wd->display,
                                            ws->wpic,
                                            0, 0, &rec, 1);
    } else
        no_clip(ws, 1);
}

static void no_clip(wsp ws, int and_win)
{
    XRenderPictureAttributes attr;
    wdp wd = ws->display;
    attr.clip_mask = None;
    XRenderChangePicture(wd->display,
                         ws->ppic,
                         CPClipMask,
                         &attr);
    if (and_win && Copying(ws))
        XRenderChangePicture(wd->display,
                             ws->wpic,
                             CPClipMask,
                             &attr);
}

/*
 *  Set the canvas type
 */
int setcanvas(wbp w, char *s)
{
    stringint *e;
    wsp ws = w->window;
    wdp wd = ws->display;
    e = stringint_lookup(canvastypes, s);
    if (!e)
        return Failed;
    if (e == ws->state)
        return Succeeded;

    if (!ws->win) {
        if (e->i != HiddenState) {
            ws->state = e;
            wmap(w);
        }
        return Succeeded;
    }

    switch (e->i) {
        case IconicState: {
            if (ws->state->i == RootState || ws->state->i == PopupState)
                return Failed;
            if (ws->state->i == WithdrawnState) {
                XWMHints wmhints;
                wmhints.flags = StateHint;
                wmhints.initial_state = IconicState;
                XSetWMHints(wd->display, ws->win, &wmhints);
                XMapWindow(wd->display, ws->win);
            } else
                XIconifyWindow(wd->display, ws->win, DefaultScreen(wd->display));
            break;
        }

        case WithdrawnState: {
            if (ws->state->i == RootState || ws->state->i == PopupState)
                return Failed;
            XWithdrawWindow(wd->display, ws->win, DefaultScreen(wd->display));
            break;
        }

        case NormalState:
        case MaximizedState:
        case FullScreenState:
        case ShadedState: {
            if (ws->state->i == RootState || ws->state->i == PopupState)
                return Failed;
            if (ws->state->i == WithdrawnState) {
                XWMHints wmhints;
                wmhints.flags = StateHint;
                wmhints.initial_state = NormalState;
                XSetWMHints(wd->display, ws->win, &wmhints);
            }
            /*
             * Use XMapRaised to try to give more consistent results
             * (kwin will restore an iconified window to its previous
             * position in the stack, whilst fvwm puts it to the top)
             */
            XMapRaised(wd->display, ws->win);
            synch_net_wm_state(ws, e->i);
            break;
        }

        case PopupState:
        case RootState:
            return Failed;

        case HiddenState: {
            close_screen_win(ws);
            break;
        }
        default:
            syserr("Unexpected canvas state");
    }
    return Succeeded;
}

/*
 * Set the context's line end style by name.
 */
int setlineend(wbp w, char *val)
{
    stringint *e;
    wcp wc = w->context;
    e = stringint_lookup(lineends, val);
    if (!e)
        return Failed;
    wc->lineend = e;
    return Succeeded;
}

/*
 * Set the context's line join style by name.
 */
int setlinejoin(wbp w, char *val)
{
    stringint *e;
    wcp wc = w->context;
    e = stringint_lookup(linejoins, val);
    if (!e)
        return Failed;
    wc->linejoin = e;
    return Succeeded;
}

/*
 * Set the context's line width
 */
int setlinewidth(wbp w, double linewid)
{
    wcp wc = w->context;
    wc->linewidth = linewid;
    return Succeeded;
}

/*
 * Set the context's fillrule style by name.
 */
int setfillrule(wbp w, char *val)
{
    stringint *e;
    wcp wc = w->context;
    e = stringint_lookup(fillrules, val);
    if (!e)
        return Failed;
    wc->fillrule = e;
    return Succeeded;
}

/*
 * Set the context's foreground color by name.
 */
int setfg(wbp w, char *s)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(s, &r, &g, &b, &a))
        return Failed;
    unlink_sharedcolor(wc->fg);
    wc->fg = new_sharedcolor(wc->display, s, r, g, b, a);
    return Succeeded;
}

/*
 * Set the window context's background color by name.
 */
int setbg(wbp w, char *s)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(s, &r, &g, &b, &a))
        return Failed;
    unlink_sharedcolor(wc->bg);
    wc->bg = new_sharedcolor(wc->display, s, r, g, b, a);
    return Succeeded;
}

char *getdisplay(wbp w)
{
    return w->window->display->name;
}

int getdisplaysize(wbp w, int *width, int *height)
{
    wdp wd = w->window->display;
    *width = DisplayWidth(wd->display, DefaultScreen(wd->display));
    *height = DisplayHeight(wd->display, DefaultScreen(wd->display));
    return Succeeded;
}

int getdisplaysizemm(wbp w, int *width, int *height)
{
    wdp wd = w->window->display;
    *width = DisplayWidthMM(wd->display, DefaultScreen(wd->display));
    *height = DisplayHeightMM(wd->display, DefaultScreen(wd->display));
    return Succeeded;
}

int getdepth(wbp w, int *res)
{
    *res = GetDepth(w->window->display);
    return Succeeded;
}

char *getfg(wbp w)
{
    return w->context->fg->name;
}

char *getbg(wbp w)
{
    return w->context->bg->name;
}

int grabpointer(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    if (XGrabPointer(ws->display->display, ws->win,False, 
                     ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | PointerMotionMask,
                     GrabModeAsync, GrabModeAsync, None, None, CurrentTime) != GrabSuccess) {
        LitWhy("XGrabPointer failed");
        return Failed;
    }
    return Succeeded;
}

int ungrabpointer(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    XUngrabPointer(ws->display->display, CurrentTime);
    return Succeeded;
}

int grabkeyboard(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    if (XGrabKeyboard(ws->display->display, ws->win,False, 
                      GrabModeAsync, GrabModeAsync, CurrentTime) != GrabSuccess) {
        LitWhy("XGrabKeyboard failed");
        return Failed;
    }
    return Succeeded;
}

int ungrabkeyboard(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    XUngrabKeyboard(ws->display->display, CurrentTime);
    return Succeeded;
}

/*
 * Set the window's font by name.
 */
int setfont(wbp w, char *s)
{
    wfp tmp;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;

    tmp = loadfont(wd, s);
    if (!tmp)
        return Failed;
    wc->font = tmp;
    return Succeeded;
}

/*
 * Copy the given region from pix to win, ignoring the clipping
 * region.  If holding is on, do nothing.
 */
static void synch_pix_and_win(wsp ws, int x, int y, int width, int height)
{
    wdp wd = ws->display;
    if (Copying(ws)) {
        no_clip(ws, 1);
        XRenderComposite(wd->display,
                         PictOpSrc,
                         ws->ppic,          /* src */
                         None,              /* mask */
                         ws->wpic,          /* dest */
                         x, y,              /* src x,y */
                         0, 0,              /* mask x,y */
                         x, y,              /* dest x,y */
                         width, height);
    }
}

/*
 * Copy the given area from pix to win.  The caller must have called clip()
 * beforehand.  If holding is on, do nothing.
 */
static void pix_to_win(wsp ws, int x, int y, int width, int height)
{
    wdp wd = ws->display;
    if (Copying(ws))
        XRenderComposite(wd->display,
                         PictOpSrc,
                         ws->ppic,           /* src */
                         None,               /* mask */
                         ws->wpic,           /* dest */
                         x, y,               /* src x,y */
                         0, 0,               /* mask x,y */
                         x, y,               /* dest x,y */
                         width, height);
}

/*
 * callback procedures
 */

static void handle_exposures(wsp ws, XExposeEvent *event)
{
    synch_pix_and_win(ws, event->x, event->y, event->width, event->height);
}

/*
 * resizepixmap(w,width,height) -- ensure w's backing pixmap is at least
 * width x height pixels.
 *
 * Resizes the backing pixmap, if needed.  Called when X resize events
 * arrive, as well as when programs make explicit resize requests.
 *
 */
static void resizepixmap(wbp w)
{
    Pixmap p;
    Picture pp;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;
    int old_w, old_h;
    XRenderPictureAttributes attr;

    if ((ws->width == ws->pixwidth) && (ws->height == ws->pixheight))
        return;

    old_w = ws->pixwidth;
    old_h = ws->pixheight;
    ws->pixheight = Max(1, ws->height);
    ws->pixwidth  = Max(1, ws->width);
    p = XCreatePixmap(wd->display, GetRoot(wd), ws->pixwidth, ws->pixheight, 32);
    attr.poly_edge = PolyEdge;
    attr.poly_mode = PolyMode;
    pp = XRenderCreatePicture(wd->display, p, wd->pixfmt, CPPolyEdge | CPPolyMode, &attr);
    /* Fill with bg colour */
    XRenderFillRectangle(wd->display,
                         PictOpSrc,
                         pp,
                         &wc->bg->color,
                         0, 0, ws->pixwidth, ws->pixheight);

    no_clip(ws, 0);
    XRenderComposite(wd->display,
                     PictOpSrc,
                     ws->ppic,          /* src */
                     None,              /* mask */
                     pp,                /* dest */
                     0, 0,              /* src x,y */
                     0, 0,              /* mask x,y */
                     0, 0,              /* dest x,y */
                     old_w, old_h);

    XFreePixmap(wd->display, ws->pix);	/* free old pixmap */
    XRenderFreePicture(wd->display, ws->ppic);
    ws->pix = p;
    ws->ppic = pp;
}

static void synch_state(wsp ws)
{
    int t;

    if (ws->win == 0) {
        ws->state = stringint_lookup(canvastypes, "hidden");
        return;
    }

    if (ws->state->i == PopupState || ws->state->i == RootState)
        return;

    t = ws->state->i;
    synch_state1(ws);
    if (t != ws->state->i)
        qeventcode(ws, WINDOWSTATE);
}

static void synch_state1(wsp ws)
{
    Atom actual_type;
    int actual_format;
    unsigned long bytes_after, nitems;
    unsigned char *prop;
    unsigned long state;
    wdp wd = ws->display;

    prop = 0;
    if (XGetWindowProperty(wd->display,
                           ws->win,
                           ATOM(wd, WM_STATE),
                           0,
                           1,
                           False,
                           ATOM(wd, WM_STATE),
                           &actual_type,
                           &actual_format,
                           &nitems,
                           &bytes_after,
                           &prop) != Success)
        return;
    
    if (actual_type == ATOM(wd, WM_STATE))
        state = *((unsigned long *)prop);
    else 
        /* WM_STATE absent => withdrawn */
        state = WithdrawnState;

    if (prop)
        XFree(prop);

    if (state == WithdrawnState || state == IconicState) {
        ws->state = stringint_rev_lookup(canvastypes, state);
        return;
    }

    /* Normal state, so check if maximized, etc */

    prop = 0;
    if (XGetWindowProperty(wd->display,
                           ws->win,
                           ATOM(wd, _NET_WM_STATE),
                           0,
                           8192,
                           False,
                           XA_ATOM,
                           &actual_type,
                           &actual_format,
                           &nitems,
                           &bytes_after,
                           &prop) != Success)
        return;

    if (actual_type == XA_ATOM) {
        int i, max = 0;
        Atom *atoms = (Atom *)prop;
        for (i = 0; i < nitems; ++i) {
            if (atoms[i] == ATOM(wd, _NET_WM_STATE_SHADED))
                max |= 8;
            else if (atoms[i] == ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT))
                max |= 1;
            else if (atoms[i] == ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ))
                max |= 2;
            else if (atoms[i] == ATOM(wd, _NET_WM_STATE_FULLSCREEN))
                max |= 4;
        }
        if (max == 3)
            state = MaximizedState;
        else if (max & 4)
            state = FullScreenState;
        else if (max & 8)
            state = ShadedState;
        else
            state = NormalState;
    } else
        /* Unexpected, assume normal state */
        state = NormalState;

    ws->state = stringint_rev_lookup(canvastypes, state);

    if (prop)
        XFree(prop);
}

static void do_selection_increment(wsp ws, int pn)
{
    wdp wd = ws->display;
    Atom property, actual_type;
    int actual_format;
    unsigned long bytes_after, nitems;
    unsigned char *prop;
    word bytes_read;
    tended struct descrip tmp;
    int status, err;
    char *conv_str;
    struct receiving_helper *h;

    property = wd->atoms[ATOM__OBJECTICON_PROP0 + pn];
    h = &wd->receiving_helpers[pn];

    if (selection_debug)
        printf("do_selection_increment: Incremental selection data property=%s\n", get_atom_name(wd, property));

    prop = 0;
    status = XGetWindowProperty(wd->display,
                                ws->win,
                                property,
                                0,
                                max_selection_size / 4,
                                True,
                                AnyPropertyType,
                                &actual_type,
                                &actual_format,
                                &nitems,
                                &bytes_after,
                                &prop);

    /* Check for various error conditions. */
    err = 0;
    if (status != Success) {
        if (selection_debug)
            printf("\tXGetWindowProperty failed\n");
        err = 1;
    } else if (actual_type == None) {
        if (selection_debug)
            printf("\tXGetWindowProperty returned actual_type == None\n");
        err = 1;
    } else if (!prop) {
        if (selection_debug)
            printf("\tXGetWindowProperty set prop to null\n");
        err = 1;
    } else if (bytes_after > 0) {
        if (selection_debug)
            printf("\tSelection too big, bytes_after=%lu\n", bytes_after);
        err = 1;
    } else {
        bytes_read = nitems * (actual_format / 8);
        if (bytes_read == 0) {
            if (selection_debug)
                printf("\tIncremental selection complete with size=%ld\n",
                       (long)h->size);
            MakeInt(SELECTIONRESPONSE, &tmp);
            list_put(&ws->listp, &tmp);
            get_atom_descriptor(wd, h->selection, &tmp);
            list_put(&ws->listp, &tmp);
            get_atom_descriptor(wd, h->target, &tmp);
            list_put(&ws->listp, &tmp);
            bytes2string(h->result, h->size, &tmp);
            list_put(&ws->listp, &tmp);
            reset_receiving_helper(h);
        } else {
            word new_size;
            if (selection_debug)
                printf("\tIncremental selection got %lu items x %d bits -> %ld bytes actual_type=%s\n",
                       nitems, actual_format, (long)bytes_read, get_atom_name(wd, actual_type));
            conv_str = property_to_string(wd,
                                          actual_type,
                                          nitems,
                                          prop,
                                          (h->size > 0));
            if (conv_str) {
                size_t len;
                len = strlen(conv_str);
                new_size = h->size + len;
                if (new_size >= max_selection_size) {
                    if (selection_debug)
                        printf("\tIncremental selection size grew too big (%ld)\n", (long)new_size);
                    err = 1;
                } else {
                    h->result = safe_realloc(h->result, Max(new_size, h->expect));
                    memcpy(h->result + h->size, conv_str, len);
                    h->size = new_size;
                    h->active = curr_secs();
                }
                free(conv_str);
            } else {
                new_size = h->size + bytes_read;
                if (new_size >= max_selection_size) {
                    if (selection_debug)
                        printf("\tIncremental selection size grew too big (%ld)\n", (long)new_size);
                    err = 1;
                } else {
                    h->result = safe_realloc(h->result, Max(new_size, h->expect));
                    memcpy(h->result + h->size, prop, bytes_read);
                    h->size = new_size;
                    h->active = curr_secs();
                }
            }
        }
    }

    if (err) {
        MakeInt(SELECTIONRESPONSE, &tmp);
        list_put(&ws->listp, &tmp);
        get_atom_descriptor(wd, h->selection, &tmp);
        list_put(&ws->listp, &tmp);
        get_atom_descriptor(wd, h->target, &tmp);
        list_put(&ws->listp, &tmp);
        list_put(&ws->listp, &nulldesc);
        reset_receiving_helper(h);
    }
    if (prop)
        XFree(prop);
}

/*
 * Possibly handle a property event related to an incremental
 * selection send; return 1 if it was handled, 0 if not.
 */
static int handle_incr_property(wdp wd, XPropertyEvent *event)
{
    word len;
    if (event->state == PropertyDelete) {
        struct sending_helper *x;
        /*
         * Purge before seeking a match, to reduce the risk of
         * matching a stale Window/Atom being used for other purposes
         * by its owner.
         */
        purge_stale_helpers(wd);
        x = match_sending_helper(wd, event->window, event->atom);
        if (x) {
            len = Min(max_selection_chunk, StrLen(x->data));
            if (selection_debug) {
                printf("handle_incr_property: receiver=%lx property=%s sending %ld bytes\n",
                       (long)x->receiver, get_atom_name(wd, x->property), (long)len);
            }
            /*
             * The ICCCM suggests we should append rather than replace
             * here; but as the property is supposed to have been
             * deleted, replace is preferable, since it can't give a
             * BadMatch error.
             */
            XChangeProperty(wd->display,
                            x->receiver,
                            x->property,
                            x->target,
                            8,
                            PropModeReplace,
                            (unsigned char *)StrLoc(x->data),
                            len);
            if (len == 0) {
                reset_sending_helper(wd, x);
                if (selection_debug)
                    printf("\tFinished INCR send\n");
            } else {
                /* Move the data field along len bytes. */
                MakeStr(StrLoc(x->data) + len, StrLen(x->data) - len, &x->data);
                x->active = curr_secs();
            }
            return 1;
        }
    }
    return 0;
}

static void handle_property(wsp ws, XPropertyEvent *event)
{
    wdp wd = ws->display;
    if (event->state == PropertyNewValue) {
        int pn = which_selection_property(wd, event->atom);
        if (pn >= 0) {
            /* Purge helpers for consistency, so that this function
             * isn't dependent on other unrelated selection
             * activities. */
            purge_stale_helpers(wd);
            if (wd->receiving_helpers[pn].receiver == ws->win)
                do_selection_increment(ws, pn);
            return;
        }
    }

    if (event->atom == ATOM(wd, WM_STATE) ||
        event->atom == ATOM(wd, _NET_WM_STATE))
        synch_state(ws);
}

static void handle_client_message(wsp ws, XClientMessageEvent *event)
{
    wdp wd = ws->display;
    /*
     * The only client message we handle at present are destroy requests
     */
    if (event->message_type == ATOM(wd, WM_PROTOCOLS) &&
        event->data.l[0] == ATOM(wd, WM_DELETE_WINDOW))
        qeventcode(ws, WINDOWCLOSED);
}

static void handle_config(wsp ws, XConfigureEvent *event)
{
    /*
     * According to the ICCCM ("Configuring the Window"), the x, y of
     * events with send_event False ("real" events) are in the parent
     * Window's co-ordinate space; with True ("synthetic events") they
     * are in the root space.
     */
    if (event->send_event)
        synch_pos(ws, event->x, event->y);
    if ((event->width != ws->width) || (event->height != ws->height)) {
        ws->width = event->width;
        ws->height = event->height;
        resizepixmap(findwbp(ws));
        qeventcode(ws, WINDOWRESIZED);
    }
}

static int make_mod(unsigned int state)
{
    int x = 0;

    if (state & ShiftMask)
        x |= MOD_SHIFT;
    if (state & LockMask)
        x |= MOD_LOCK;
    if (state & ControlMask)
        x |= MOD_CTRL;
    if (state & Mod1Mask)
        x |= MOD_META;
    if (state & Mod2Mask)
        x |= MOD_META2;
    if (state & Mod3Mask)
        x |= MOD_META3;
    if (state & Mod4Mask)
        x |= MOD_META4;
    if (state & Mod5Mask)
        x |= MOD_META5;
    return x;
}

static void handle_crossing(wsp ws, XCrossingEvent *event)
{
    struct descrip d;
    UpdateCommon(ws, event);
    MakeInt(event->type == EnterNotify ? MOUSEENTERED:MOUSEEXITED, &d);
    qevent(ws, &d, event->x, event->y,
           (word)event->time, 
           make_mod(event->state));
}

/*
 * Queue up characters for keypress events.
 */
static void handle_keypress(wsp ws, XKeyEvent *event)
{
    int i, j, fl;
    char s[10];
    tended struct descrip d;
    KeySym k;

    UpdateCommon(ws, event);
    fl = make_mod(event->state);
    if (event->type == KeyRelease)
        fl |= MOD_RELEASE;
    /* First try to convert the event to a simple char string, and a KeySym */
    i = XLookupString(event, s, sizeof(s), &k, NULL);
    if (i > 0) {
        /* Found a char string, so generate string event(s) */
        StrLen(d) = 1;
        for (j = 0; j < i; j++) {
            StrLoc(d) = &allchars[s[j] & 0xFF];
            qevent(ws, &d, event->x, event->y,
                   (word)event->time, fl);
        }
        return;
    }

    /* Second try is to convert to a unicode char; if found generate a 1-char
     * ucs/string */
    i = convert_KeySym_to_code_point(k);
    if (i > 0) {
        if (i < 256)
            MakeStr(&allchars[i], 1, &d);
        else
            MakeDesc(D_Ucs, make_one_char_ucs_block(i), &d);

        qevent(ws, &d, event->x, event->y,
               (word)event->time, fl);
        return;
    }

    /* Neither of those worked, so it must be a non-character key (cursor key, etc).
     * So just generate the numerical value of the KeySym as an integer.
     */
    MakeInt(k, &d);
    qevent(ws, &d, event->x, event->y,
           (word)event->time, fl);
}

#include "rxkeysyms.ri"

/*
 * Handle button presses and drag events.  In the case of drags, we should
 * really be looking at an XMotionEvent instead of an XButtonEvent, but
 * the structures are identical up to the button field (which we do not
 * examine for drag events).  Mouse coordinates are queued up after the event.
 */
static void handle_mouse(wsp ws, XButtonEvent *event)
{
    int state = 0;
    UpdateCommon(ws, event);
    /* Initialize state based on the three buttons that can be
     * held. */
    if (event->state & Button1Mask) state |= 1;
    if (event->state & Button2Mask) state |= 2;
    if (event->state & Button3Mask) state |= 4;
    switch (event->type) {
        case ButtonPress: {
            switch (event->button) {
                case Button1: state |= 1; break;
                case Button2: state |= 2; break;
                case Button3: state |= 4; break;
                case Button4: state |= 8; break;
                case Button5: state |= 16; break;
                case 6:       state |= 32; break;  /* Wheel left */
                case 7:       state |= 64; break;  /* Wheel right */
            }
            break;
        }
        case ButtonRelease: {
            switch (event->button) {
                case Button1: state &= ~1; break;
                case Button2: state &= ~2; break;
                case Button3: state &= ~4; break;
                default: return;
            }
            break;
        }
    }
    qmouseevents(ws, state, 
                 event->x, event->y, 
                 (word)event->time, 
                 make_mod(event->state));
}

/*
 * Given an ellipse with major/minor axes rx, ry and centre at origin,
 * return the polar coordinate radius for the given angle th.  Also
 * calculate the (x, y) position corresponding to (r, th).
 */
static double calc_pt(double *x, double *y, double rx, double ry, double th)
{
    double r;
    /* Get the polar coordinates radius relative to center */
    if (rx == ry)    /* Easy case if a circle */
        r = rx;
    else
        r = (rx * ry) / hypot(rx * sin(th), ry * cos(th));
    *x = r * cos(th);
    *y = r * sin(th);
    return r;
}

/*
 * Calculate a factor to use when progressing an angle around an arc,
 * given an ellipse's major and minor axes.
 */
static double calc_progress_factor(double rx, double ry)
{
    double min_r, max_r, arc_res;

    min_r = Min(rx, ry);
    max_r = Max(rx, ry);

    /* The smaller the radius in pixels, the fewer steps we need.  In
     * any case, limit within a range. */
    arc_res = 5.0 / max_r;
    arc_res = Max(arc_res, 0.0125);
    arc_res = Min(arc_res, 0.25);

    /*
     * The returned factor is divided by r, the polar radius for the
     * current angle in the iteration.  The longer r is compared to
     * the shorter axis, the more points we generate.
     */
    return arc_res * min_r;
}

void drawarc(wbp w, double cx, double cy, double rx, double ry, double angle1, double angle2)
{
    double th, r, pf, x, y;
    struct point *pts;
    int maxpts, npts;

    pf = calc_progress_factor(rx, ry);
    maxpts = 100;
    pts = safe_malloc(maxpts * sizeof(struct point));
    npts = 0;
    th = angle1;
    while (th < angle1 + angle2) {
        r = calc_pt(&x, &y, rx, ry, th);
        x += cx;
        y += cy;
        if (npts == 0 || fabs(pts[npts - 1].x - x) >= 1.0 || fabs(pts[npts - 1].y - y) >= 1.0) {
            if (npts == maxpts) {
                maxpts += 100;
                pts = safe_realloc(pts, maxpts * sizeof(struct point));
            }
            pts[npts].x = x;
            pts[npts].y = y;
            ++npts;
        }
        th += pf / r;
    }

    /* Space for the last point */
    if (npts == maxpts) {
        maxpts++;
        pts = safe_realloc(pts, maxpts * sizeof(struct point));
    }

    if (angle2 == TwoPi)
        pts[npts] = pts[0];  /* Ensure drawlines recognizes a closed arc */
    else {
        calc_pt(&x, &y, rx, ry, angle1 + angle2);
        pts[npts].x = cx + x;
        pts[npts].y = cy + y;
    }
    ++npts;

    drawlines(w, pts, npts);
    free(pts);
}

static void traps_mk_ellipse(double cx, double cy, double rx, double ry)
{
    double th, r, pf, x, y, t1x, b, b1, t, t1, b1x;

    pf = calc_progress_factor(rx, ry);
    th = 0.0;
    t1x = b1x = rx;
    b1 = t1 = cy;
    while (th < HalfPi) {
        r = calc_pt(&x, &y, rx, ry, th);
        t = cy - y;
        if (t < t1) {
            add_trap(t, cx - x, cx + x, t1, cx - t1x, cx + t1x);
            t1 = t;
            t1x = x;
        }

        b = cy + y;
        if (b > b1) {
            add_trap(b1, cx - b1x, cx + b1x, b, cx - x,  cx + x);
            b1 = b;
            b1x = x;
        }
        th += pf / r;
    }

    /* Fill in top/bottom, by setting th = HalfPi (calc_pt would give
     * r=y=ry, x=0) */
    t = cy - ry;
    if (t < t1)
        add_trap(t, cx, cx, t1, cx - t1x, cx + t1x);

    b = cy + ry;
    if (b > b1)
        add_trap(b1, cx - b1x, cx + b1x, b, cx,  cx);
}

static void tris_mk_arc(double cx, double cy, double rx, double ry, double angle1, double angle2)
{
    double th, r, pf;
    XPointDouble C, P, Q, F;

    pf = calc_progress_factor(rx, ry);
    C.x = cx;
    C.y = cy;

    r = calc_pt(&Q.x, &Q.y, rx, ry, angle1);
    Q.x += cx;
    Q.y += cy;
    F = Q;

    th = angle1 + pf / r;
    while (th < angle1 + angle2) {
        r = calc_pt(&P.x, &P.y, rx, ry, th);
        P.x += cx;
        P.y += cy;
        if (fabs(Q.x - P.x) >= 1.0 || fabs(Q.y - P.y) >= 1.0) {
            add_tri(&C, &P, &Q);
            Q = P;
        }
        th += pf / r;
    }

    /* Ensure the last triangle abuts the first, if we have a closed
     * arc; otherwise end with the exact last angle. */
    if (angle2 == TwoPi)
        P = F;
    else {
        calc_pt(&P.x, &P.y, rx, ry, angle1 + angle2);
        P.x += cx;
        P.y += cy;
    }
    add_tri(&C, &P, &Q);
}

static void mk_arc(double cx, double cy, double rx, double ry, double angle1, double angle2)
{
    if (drawlist.traps && angle2 == TwoPi)
        traps_mk_ellipse(cx, cy, rx, ry);
    else
        tris_mk_arc(cx, cy, rx, ry, angle1, angle2);
}

void fillarc(wbp w, double cx, double cy, double rx, double ry, double angle1, double angle2)
{
    int x, y, width, height;
    wsp ws = w->window;
    wdp wd = ws->display;
    wcp wc = w->context;

    /* Calculate the bounding box. */
    x = floor(cx - rx);
    y = floor(cy - ry);
    width = 2 * ceil(cx - x);
    height = 2 * ceil(cy - y);
    if (!reducerect(w, 1, &x, &y, &width, &height))
        return;

    init_drawlist(100, triangles > 0);
    clip(w);
    if (needmask(wc, 0)) {
        Picture mask;
        /*
         * Calculate width and height for the masks, and their x, y
         * position to draw onto the screen.
         */
        mk_arc(cx - x, cy - y,    /* centre */
               rx, ry,            /* x/y radius */
               angle1, angle2);
        mask = getmask(wd, width, height);
        draw_drawlist(wd, PictOpOver, wd->white->brush,  mask);
        maskpic2(w, mask, x, y, width, height);
        XRenderFreePicture(wd->display, mask);
    } else {
        mk_arc(cx, cy, rx, ry, angle1, angle2);
        draw_drawlist(wd,
                      wc->drawop->i,
                      get_draw_picture(wc),
                      ws->ppic);
        pix_to_win(ws, x, y, width, height);
    }

    free_drawlist();
}

/*
 * Some simple functions for accumulating an array of XTrapezoids or XTriangles.
 */

static void init_drawlist(int alloc, int tris)
{
    if (drawlist.traps || drawlist.tris)
        syserr("init_drawlist() called out of sequence");
    drawlist.n = 0;
    if (tris)
        drawlist.tris = safe_malloc(alloc * sizeof(XTriangle));
    else
        drawlist.traps = safe_malloc(alloc * sizeof(XTrapezoid));
    drawlist.alloc = alloc;
}

static void free_drawlist(void)
{
    free(drawlist.traps);
    free(drawlist.tris);
    drawlist.traps = 0;
    drawlist.tris = 0;
    drawlist.alloc = drawlist.n = 0;
}

static void show_drawlist(void)
{
    int i;
    printf("drawlist n=%d alloc=%d %s\n", drawlist.n, drawlist.alloc, drawlist.tris ? "triangles":"trapezoids");
    if (drawlist.tris) {
        for (i = 0; i < drawlist.n; ++i) {
            XTriangle t;
            t = drawlist.tris[i];
            printf("%2d:\tp1 = %d,%d (%f,%f)\n ", i, (int)t.p1.x, (int)t.p1.y, XFixedToDouble(t.p1.x), XFixedToDouble(t.p1.y));
            printf("\tp2 = %d,%d (%f,%f)\n", (int)t.p2.x, (int)t.p2.y, XFixedToDouble(t.p2.x), XFixedToDouble(t.p2.y));
            printf("\tp3 = %d,%d (%f,%f)\n", (int)t.p3.x, (int)t.p3.y, XFixedToDouble(t.p3.x), XFixedToDouble(t.p3.y));
        }
    } else {
        for (i = 0; i < drawlist.n; ++i) {
            XTrapezoid t;
            t = drawlist.traps[i];
            printf("%2d:\ttop      = %d (%f)\n ", i, (int)t.top, XFixedToDouble(t.top));
            printf("\tbottom   = %d (%f)\n", (int)t.bottom, XFixedToDouble(t.bottom));
            printf("\tleft  p1 = %d,%d (%f,%f)\n", (int)t.left.p1.x, (int)t.left.p1.y, XFixedToDouble(t.left.p1.x), XFixedToDouble(t.left.p1.y));
            printf("\t      p2 = %d,%d (%f,%f)\n", (int)t.left.p2.x, (int)t.left.p2.y, XFixedToDouble(t.left.p2.x), XFixedToDouble(t.left.p2.y));
            printf("\tright p1 = %d,%d (%f,%f)\n", (int)t.right.p1.x, (int)t.right.p1.y, XFixedToDouble(t.right.p1.x), XFixedToDouble(t.right.p1.y));
            printf("\t      p2 = %d,%d (%f,%f)\n", (int)t.right.p2.x, (int)t.right.p2.y, XFixedToDouble(t.right.p2.x), XFixedToDouble(t.right.p2.y));
        }
    }
    printf("============\n");
}

static void draw_drawlist(wdp wd, int op, Picture src, Picture dest)
{
    if (draw_debug)
        show_drawlist();

    if (drawlist.n == 0)
        return;

    /* src is either a white brush, or the foreground brush (never a
     * pattern). */
    if (drawlist.traps)
        XRenderCompositeTrapezoids(wd->display,
                                   op,
                                   src,
                                   dest,
                                   wd->maskfmt,
                                   0, 0,              /* src x,y */
                                   drawlist.traps,
                                   drawlist.n);
    else
        XRenderCompositeTriangles(wd->display,
                                  op,
                                  src,
                                  dest,
                                  wd->maskfmt,
                                  0, 0,              /* src x,y */
                                  drawlist.tris,
                                  drawlist.n);
}

static void ensure_drawlist(int need)
{
    if (drawlist.n + need > drawlist.alloc) {
        drawlist.alloc = 2 * (drawlist.n + need);
        if (drawlist.traps)
            drawlist.traps = safe_realloc(drawlist.traps, drawlist.alloc * sizeof(XTrapezoid) );
        else if (drawlist.tris)
            drawlist.tris = safe_realloc(drawlist.tris, drawlist.alloc * sizeof(XTriangle) );
        else
            syserr("ensure_drawlist() called out of sequence");
    }
}

#define Swap(a,b) { XPointFixed v; v = a; a = b; b = v; }

static void add_tri(XPointDouble *p10, XPointDouble *p20, XPointDouble *p30)
{
    XPointFixed p1, p2, p3;
    XTrapezoid t1, t2;
    int64_t i;

    p1 = fixedpt(p10);
    p2 = fixedpt(p20);
    p3 = fixedpt(p30);

    /* Compare the gradients of two of the three sides. */
    i = (int64_t)(p2.x - p1.x) * (int64_t)(p3.y - p2.y) - ((int64_t)(p3.x - p2.x) * (int64_t)(p2.y - p1.y));
    if (i == 0)     /* The triangle is a straight line. */
        return;

    if (drawlist.tris) {
        ensure_drawlist(1);
        drawlist.tris[drawlist.n++] = triangle(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
        return;
    }

    /* Sort the points into ascending y order. */
    if (p1.y > p3.y) { Swap(p1,p3); i = -i; }
    if (p1.y > p2.y) { Swap(p1,p2); i = -i; }
    if (p2.y > p3.y) { Swap(p2,p3); i = -i; }

    /*
     * Turning a triangle into 2 trapezoids falls into two cases.  In
     * the first case the left line is shared between the two and in
     * the second, the right line is shared.
     * 
     * Example first case :-
     * 
     *        -------x1---------------------------- y1
     *                \ \
     *                 \   \
     *                  \     \
     *                   \       \
     *        ------------\---------x2------------- y2
     *                     \      /
     *                      \   /
     *                       \/
     *        ---------------x3-------------------- y3
     * 
     * 
     * Example second case :-
     * 
     * 
     *        ----------------x1------------------- y1
     *                       / \
     *                      /   \
     *                     /     \
     *                    /       \
     *        -----------x2--------\--------------- y2
     *                     \        \
     *                        \      \
     *                           \    \
     *        -------------------------x3---------- y3
     * 
     * 
     * To distinguish the cases, decide if the point at which the line
     * p1->p3 crosses the horizontal line y2 is to the left or right
     * of x2.  This can be determined by comparing the gradients of
     * p1->p2 and p2->p3, which was calculated above.
     */

    t1.top = p1.y;
    t1.bottom = t2.top = p2.y;
    t2.bottom = p3.y;
    t1.right.p1 = t1.left.p1 = p1;
    if (i > 0)
    {
        t1.left.p2 = p3;
        t1.right.p2 = t2.right.p1 = p2;
        t2.left = t1.left;
        t2.right.p2 = t2.left.p2;
    }
    else {    /* i < 0 */
        t1.left.p2 = p2;
        t1.right.p2 = t2.left.p2 = p3;
        t2.left.p1 = t1.left.p2;
        t2.right = t1.right;
    }

    ensure_drawlist(2);
    if (t1.top != t1.bottom)
        drawlist.traps[drawlist.n++] = t1;
    if (t2.top != t2.bottom)
        drawlist.traps[drawlist.n++] = t2;
}

static void add_trap(double top0, double x10, double x20, double bottom0, double x30, double x40)
{
    XFixed top, bottom, x1, x2, x3, x4;
    top = XDoubleToFixed(top0);
    bottom = XDoubleToFixed(bottom0);
    x1 = XDoubleToFixed(x10);
    x2 = XDoubleToFixed(x20);
    x3 = XDoubleToFixed(x30);
    x4 = XDoubleToFixed(x40);

    if (top == bottom || x1 > x2 || x3 > x4 || (x1 == x2 && x3 == x4))
       return;
    
    if (drawlist.tris) {
        ensure_drawlist(2);
        if (x1 != x2)
            drawlist.tris[drawlist.n++] = triangle(x1, top, x2, top, x4, bottom);
        if (x3 != x4)
            drawlist.tris[drawlist.n++] = triangle(x1, top, x3, bottom, x4, bottom);
    } else {
        ensure_drawlist(1);
        drawlist.traps[drawlist.n++] = trapezoid(top, x1, x2, bottom, x3, x4);
    }
}

static void add_rect(XPointDouble *tl, XPointDouble *br)
{
    add_trap(tl->y, tl->x, br->x,  br->y, tl->x, br->x);
}

/*
 * The orientation of the computed corner points is always the same
 * (p0 and q0 are the given input points, linewidth comes from the
 * context), as follows :-
 *  
 *   p2 -------------------- q2      ^
 *   |                       |       |
 *   p0       -->--          q0   linewidth
 *   |                       |       |
 *   p1 ---------------------q1      v
 *
 *   <-------- len ---------->
 */

static void getlineinfo(wcp wc, XPointDouble *p0, XPointDouble *q0, struct lineinfo *res)
{
    double ex, ey;
    res->dx = q0->x - p0->x;
    res->dy = q0->y - p0->y;
    res->len = hypot(res->dx, res->dy);
    res->p0 = *p0;
    res->q0 = *q0;
    ex = (wc->linewidth * res->dy) / (2 * res->len);
    ey = -(wc->linewidth * res->dx) / (2 * res->len);
    res->p1 = doublept(p0->x - ex ,p0->y - ey);
    res->p2 = doublept(p0->x + ex, p0->y + ey);
    res->q1 = doublept(q0->x - ex ,q0->y - ey);
    res->q2 = doublept(q0->x + ex, q0->y + ey);
}

static double dotprod(struct lineinfo *u, struct lineinfo *v)
{
    return u->dx * v->dx + u->dy * v->dy;
}

static double crossprod(struct lineinfo *u, struct lineinfo *v)
{
    return u->dx * v->dy - u->dy * v->dx;
}

/*
 * Get the angle between two line segments.
 * 
 * This follows from the formula for sin(a - b).
 */
static double angle_diff(struct lineinfo *u, struct lineinfo *v)
{
    return asin(crossprod(u, v) / (u->len * v->len));
}

static int almost_straight(struct lineinfo *u, struct lineinfo *v)
{
    return fabs(angle_diff(u, v)) < 0.1;
}

/*
 * Return the angle a between two points, normalized to the
 * range 0 <= a < 2*Pi.
 * 
 *          p ---------+
 *         / a |
 *        /---/
 *       /
 *      /
 *     q      
 */
static double point_angle(XPointDouble *p, XPointDouble *q)
{
    return norm_angle(atan2(p->y - q->y, p->x - q->x));
}

/*
 * Get the miter point to draw, returning 0 if no point should be
 * drawn because the segments are too straight.
 */
static int get_miter_point(XPointDouble *res, struct lineinfo *prev, struct lineinfo *curr)
{
    if (almost_straight(prev, curr))
        return 0;
    if (crossprod(prev, curr) > 0)
        return intersect(res, &curr->p2, &curr->q2, &prev->p2, &prev->q2);
    else
        return intersect(res, &curr->p1, &curr->q1, &prev->p1, &prev->q1);
}

static void calc_extent(wcp wc, struct lineinfo *lis, int n, int closed, int *x, int *y, int *width, int *height)
{
    int i;
    double x1, x2, y1, y2;
    x1 = x2 = y1 = y2 = 0.0;
    for (i = 0; i < n; ++i) {
        XPointDouble m;
        struct lineinfo *li = &lis[i]; 
        if (i == 0) {
            x1 = x2 = li->p1.x;
            y1 = y2 = li->p1.y;

            if (closed && wc->linejoin->i == JoinMiter && get_miter_point(&m, &lis[n - 1], &lis[i])) {
                if (m.x < x1) x1 = m.x;
                if (m.x > x2) x2 = m.x;
                if (m.y < y1) y1 = m.y;
                if (m.y > y2) y2 = m.y;
            }

        } else {
            if (li->p1.x < x1) x1 = li->p1.x;
            if (li->p1.x > x2) x2 = li->p1.x;
            if (li->p1.y < y1) y1 = li->p1.y;
            if (li->p1.y > y2) y2 = li->p1.y;
            if (wc->linejoin->i == JoinMiter && get_miter_point(&m, &lis[i - 1], &lis[i])) {
                if (m.x < x1) x1 = m.x;
                if (m.x > x2) x2 = m.x;
                if (m.y < y1) y1 = m.y;
                if (m.y > y2) y2 = m.y;
            }
        }
        if (li->p2.x < x1) x1 = li->p2.x;
        if (li->p2.x > x2) x2 = li->p2.x;
        if (li->p2.y < y1) y1 = li->p2.y;
        if (li->p2.y > y2) y2 = li->p2.y;
        if (li->q1.x < x1) x1 = li->q1.x;
        if (li->q1.x > x2) x2 = li->q1.x;
        if (li->q1.y < y1) y1 = li->q1.y;
        if (li->q1.y > y2) y2 = li->q1.y;
        if (li->q2.x < x1) x1 = li->q2.x;
        if (li->q2.x > x2) x2 = li->q2.x;
        if (li->q2.y < y1) y1 = li->q2.y;
        if (li->q2.y > y2) y2 = li->q2.y;
    }
    x1 -= wc->linewidth / 2.0;
    y1 -= wc->linewidth / 2.0;
    x2 += wc->linewidth / 2.0;
    y2 += wc->linewidth / 2.0;
    range_extent(x1, y1, x2, y2, x, y, width, height);
}

static XPointDouble doublept(double x, double y)
{
    XPointDouble t;
    t.x = x;
    t.y = y;
    return t;
}

static XPointFixed fixedpt(XPointDouble *p)
{
    XPointFixed t;
    t.x = XDoubleToFixed(p->x);
    t.y = XDoubleToFixed(p->y);
    return t;
}

static XTriangle triangle(XFixed x1, XFixed y1, XFixed x2, XFixed y2, XFixed x3, XFixed y3)
{
    XTriangle t;
    t.p1.x = x1;
    t.p1.y = y1;
    t.p2.x = x2;
    t.p2.y = y2;
    t.p3.x = x3;
    t.p3.y = y3;
    return t;
}

static XTrapezoid trapezoid(XFixed top, XFixed x1, XFixed x2, XFixed bottom, XFixed x3, XFixed x4)
{
    XTrapezoid t;
    t.top = top;
    t.left.p1.x = x1;
    t.left.p1.y = t.right.p1.y= t.top;
    t.right.p1.x = x2;
    t.bottom = bottom;
    t.left.p2.x = x3;
    t.left.p2.y = t.right.p2.y = t.bottom;
    t.right.p2.x = x4;
    return t;
}

/*
 * Attempt to find the intersection of the two straight lines defined
 * by the pairs of points (a1,a2) and (b1,b2).  If successful, the
 * result is set in res, and 1 is returned.
 */
static int intersect(XPointDouble *res, XPointDouble *a1, XPointDouble *a2, XPointDouble *b1, XPointDouble *b2)
{
    double a, b, d;

    a = (a1->x * a2->y - a1->y * a2->x);
    b = (b1->x * b2->y - b1->y * b2->x);
    d = ( (a1->x - a2->x) * (b1->y - b2->y) - (a1->y - a2->y) * (b1->x -b2->x) );
    if (d == 0)
        return 0;
    *res = doublept((a * (b1->x -b2->x) - (a1->x - a2->x) * b ) / d,
                    (a * (b1->y- b2->y) - (a1->y - a2->y) * b ) / d);
    return 1;
}

/*
 * Given two points a and b on a straight line, extend the line d
 * units from b.  Positive d means away from a :-
 * 
 *    a                          b    d>0  r     
 *    +--------------------------+---------+
 * 
 * or
 * 
 *    a                 r  d<0   b     
 *    +-----------------+--------+
 * 
 * where r is the result.
 */
static XPointDouble nudge(XPointDouble *a, XPointDouble *b, double d)
{
    double dx, dy, ex, ey, h;

    dx = b->x - a->x;
    dy = b->y - a->y;

    if (dy == 0) {
        if (dx < 0)
            return doublept(b->x - d, b->y);
        else
            return doublept(b->x + d, b->y);
    }

    h = hypot(dx, dy);
    ex = dx * (h + d) / h;
    ey = dy * (h + d) / h;

    return doublept(a->x + ex, a->y + ey);
}

/*
 * Output a segment.
 */
static void drawlineinfo1(wcp wc, struct lineinfo *u)
{
    if (drawlist.tris) {
        add_tri(&u->p2, &u->p1, &u->q2);
        add_tri(&u->q1, &u->p1, &u->q2);
    } else if (u->dx == 0) {
        if (u->p1.y < u->q1.y)
            add_rect(&u->p1, &u->q2);
        else
            add_rect(&u->q2, &u->p1);
    } else if (u->dy == 0) {
        if (u->p1.x < u->q1.x)
            add_rect(&u->p2, &u->q1);
        else
            add_rect(&u->q1, &u->p2);
    } else {
        /*
         * Each of the four orientations has two cases, depending on
         * which of the two middle points is higher.  The following
         * shows the first orientation and second case (p1.y < q2.y).
         *
         *            p2 /----
         *              /     ----                     
         *             /          ---- 
         *         w  /               ----             
         *           /                    ----
         *          /          s             ---- 
         *         p1----.........................X---
         *          |    ----                         ----
         *          |        --Y-....................... ./ q2
         *          |            ----         s          /
         *        dy|                ----               /
         *          |                len ----          /
         *          |                        ----     /
         *          ____________________________ ----/ q1
         *                        dx
         *
         * 
         * p1 is extended horizontally rightwards to intersect p2-q2
         * at X, to give distance s, which is easily found since
         * p1-p2-X is similar to the triangle with sides dx, dy and
         * len, so s/w = len/dy.
         * 
         * This gives the top triangle (p1-p2-X).  The bottom one is
         * (q1-q2-Y), which is congruent to the top one, and (q2-Y) is
         * also of length s.
         * 
         * The middle trapezoid (p1-X-q2-Y) is empty if p1 and q2 are
         * the same height, but because those points are calculated
         * using hypot(), this doesn't occur at all frequently.
         * 
         * The first case is very similar, but there q2 is extended
         * leftwards to intersect p1-p2.  The length of this line (s)
         * is found from s/len = len/dx.
         */
        double s;
        if (u->dx > 0) {
            if (u->dy > 0) {
                if (u->p1.y > u->q2.y) {
                    s = (u->len * u->len) / u->dx;
                    add_trap(u->p2.y, u->p2.x, u->p2.x,
                             u->q2.y, u->q2.x - s, u->q2.x);
                    add_trap(u->q2.y, u->q2.x - s, u->q2.x,
                             u->p1.y, u->p1.x, u->p1.x + s);
                    add_trap(u->p1.y, u->p1.x, u->p1.x + s,
                             u->q1.y, u->q1.x, u->q1.x);
                } else {
                    s = (wc->linewidth * u->len) / u->dy;
                    add_trap(u->p2.y, u->p2.x, u->p2.x,
                             u->p1.y, u->p1.x, u->p1.x + s);
                    add_trap(u->p1.y, u->p1.x, u->p1.x + s,
                             u->q2.y, u->q2.x - s, u->q2.x);
                    add_trap(u->q2.y, u->q2.x - s, u->q2.x,
                             u->q1.y, u->q1.x, u->q1.x);
                }
            } else {           /* dx > 0, dy < 0 */
                if (u->p2.y < u->q1.y) {
                    s = (u->len * u->len) / u->dx;
                    add_trap(u->q2.y, u->q2.x, u->q2.x,
                             u->p2.y, u->p2.x, u->p2.x + s);
                    add_trap(u->p2.y, u->p2.x, u->p2.x + s,
                             u->q1.y, u->q1.x - s, u->q1.x);
                    add_trap(u->q1.y, u->q1.x - s, u->q1.x,
                             u->p1.y, u->p1.x, u->p1.x);
                } else {
                    s = (wc->linewidth * u->len) / -u->dy;
                    add_trap(u->q2.y, u->q2.x, u->q2.x,
                             u->q1.y, u->q1.x - s, u->q1.x);
                    add_trap(u->q1.y, u->q1.x - s, u->q1.x,
                             u->p2.y, u->p2.x, u->p2.x + s);
                    add_trap(u->p2.y, u->p2.x, u->p2.x + s,
                             u->p1.y, u->p1.x, u->p1.x);
                }
            }
        } else {             /* dx < 0 */
            if (u->dy > 0) {
                if (u->p2.y > u->q1.y) {
                    s = (u->len * u->len) / -u->dx;
                    add_trap(u->p1.y, u->p1.x, u->p1.x,
                             u->q1.y, u->q1.x, u->q1.x + s);
                    add_trap(u->q1.y, u->q1.x, u->q1.x + s,
                             u->p2.y, u->p2.x - s, u->p2.x);
                    add_trap(u->p2.y, u->p2.x - s, u->p2.x,
                             u->q2.y, u->q2.x, u->q2.x);
                } else {
                    s = (wc->linewidth * u->len) / u->dy;
                    add_trap(u->p1.y, u->p1.x, u->p1.x,
                             u->p2.y, u->p2.x - s, u->p2.x);
                    add_trap(u->p2.y, u->p2.x - s, u->p2.x,
                             u->q1.y, u->q1.x, u->q1.x + s);
                    add_trap(u->q1.y, u->q1.x, u->q1.x + s,
                             u->q2.y, u->q2.x, u->q2.x);
                }
            } else {         /* dx < 0, dy < 0 */
                if (u->p1.y < u->q2.y) {
                    s = (u->len * u->len) / -u->dx;
                    add_trap(u->q1.y, u->q1.x, u->q1.x,
                             u->p1.y, u->p1.x - s, u->p1.x);
                    add_trap(u->p1.y, u->p1.x - s, u->p1.x,
                             u->q2.y, u->q2.x, u->q2.x + s);
                    add_trap(u->q2.y, u->q2.x, u->q2.x + s,
                             u->p2.y, u->p2.x, u->p2.x);
                } else {
                    s = (wc->linewidth * u->len) / -u->dy;
                    add_trap(u->q1.y, u->q1.x, u->q1.x,
                             u->q2.y, u->q2.x, u->q2.x + s);
                    add_trap(u->q2.y, u->q2.x, u->q2.x + s,
                             u->p1.y, u->p1.x - s, u->p1.x);
                    add_trap(u->p1.y, u->p1.x - s, u->p1.x,
                             u->p2.y, u->p2.x, u->p2.x);
                }
            }
        }
    }
}

static void drawlineend(wcp wc,
                        struct lineinfo *u,
                        int end)
{
    XPointDouble *A0, *A1, *A2, *C0, N;
    struct lineinfo li;

    if (wc->lineend->i == EndFlat)
        return;

    if (end) {
        A0 = &u->q0;
        C0 = &u->p0;
        A1 = &u->q1;
        A2 = &u->q2;
    } else {
        A0 = &u->p0;
        C0 = &u->q0;
        A1 = &u->p2;
        A2 = &u->p1;
    }

    if (wc->lineend->i == EndRound) {
        double a, radius;
        radius = wc->linewidth / 2.0;
        a = point_angle(A0, A1);
        mk_arc(A0->x, A0->y,
               radius, radius,
               a, Pi);
        return;
    }

    N = nudge(C0, A0, wc->linewidth / 2);
    switch (wc->lineend->i) {
        case EndPoint: {
            add_tri(A1, A2, &N);
            break;
        }
        case EndSquare: {
            getlineinfo(wc, A0, &N, &li);
            drawlineinfo1(wc, &li);
            break;
        }
        default:
            syserr("Unexpected lineend");
    }
}

static void drawlineinfo(wcp wc,
                         struct lineinfo *prev,
                         struct lineinfo *curr,
                         struct lineinfo *next)
{
    /* Output the current segment. */
    drawlineinfo1(wc, curr);

    if (prev) {
        XPointDouble *A1, *A2, *C;

        /*
         *                  A1      A2
         *                  /\      /\
         *                 /   \   /   \
         *                /      \/C     \ 
         *               /       / \       \
         *              /       /    \       \
         *             /       /     /         \
         *            /         \   /            \
         *           /  prev      \/     curr      \
         *                        / \
         *                       /   \ 
         *                               
         * A1, A2 will be in clockwise order.
         * 
         */

        C = &curr->p0;
        if (crossprod(prev, curr) > 0) {
            A1 = &prev->q2;
            A2 = &curr->p2;
        } else {
            A1 = &curr->p1;
            A2 = &prev->q1;
        }

        /*
         * dotprod() determines whether the segments are aligned
         * end-to-end rather than overlapping.
         */
        if (wc->linejoin->i != JoinRound || (almost_straight(prev, curr) && dotprod(prev, curr) > 0)) {
            XPointDouble m;

            /*
             * The bevel triangle.
             */
            add_tri(C, A1, A2);

            /*
             * The miter triangle.
             */
            if (wc->linejoin->i == JoinMiter && get_miter_point(&m, prev, curr))
                add_tri(&m, A1, A2);

        } else {
            double radius, a1, a2;
            /*
             * Add an arc between the segments, in about the same
             * region as occupied by the bevel triangle above.
             */
            a1 = point_angle(A1, C);
            a2 = point_angle(A2, C);
            a2 = norm_angle(a2 - a1);
            radius = wc->linewidth / 2.0;
            mk_arc(C->x, C->y,
                   radius, radius,
                   a1, a2);
        }
    } else
        drawlineend(wc, curr, 0);

    if (!next)
        drawlineend(wc, curr, 1);
}

static void drawlineinfos_impl(wbp w, struct lineinfo *lis, int nlis, int closed)
{
    wcp wc = w->context;
    int i;
    for (i = 0; i < nlis; ++i) {
        struct lineinfo *prev, *next;
        if (i > 0)
            prev = &lis[i - 1];
        else
            prev = closed ? &lis[nlis - 1] : 0;
        if (i < nlis - 1)
            next = &lis[i + 1];
        else
            next = closed ? &lis[0] : 0;
        drawlineinfo(wc, prev, &lis[i], next);
    }
}

static XPointDouble adjustpoint(wcp wc, struct point *points, int npoints, int i, int closed)
{
    XPointDouble pd;
    pd.x = points[i].x;
    pd.y = points[i].y;
    /*
     * If the linewidth is odd, shift exactly horizontal and vertical
     * segments lying on exact pixel lines by 0.5 pixel so that they
     * are not output with anti-aliased edges.
     */
    if (fmod(wc->linewidth, 2) == 1) {
        struct point *next, *prev;
        if (i > 0)
            prev = &points[i - 1];
        else
            prev = closed ? &points[npoints - 1] : 0;
        if (i < npoints - 1)
            next = &points[i + 1];
        else
            next = closed ? &points[0] : 0;
        if ((prev && prev->x == points[i].x && fmod(prev->x, 1.0) == 0) || (next && next->x == points[i].x && fmod(next->x, 1.0) == 0))
            pd.x += 0.5;
        if ((prev && prev->y == points[i].y && fmod(prev->y, 1.0) == 0) || (next && next->y == points[i].y && fmod(next->y, 1.0) == 0))
            pd.y += 0.5;
    }
    return pd;
}
 
static void drawlineinfos(wbp w, struct lineinfo *lis, int nlis, int closed)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    wcp wc = w->context;
    int i, x, y, width, height;

    if (nlis == 0)
        return;

    calc_extent(wc, lis, nlis, closed, &x, &y, &width, &height);
    if (!reducerect(w, 1, &x, &y, &width, &height))
        return;

    init_drawlist(nlis * 3, triangles > 0);

    clip(w);
    if (needmask(wc, 1)) {
        Picture mask = getmask(wd, width, height);
        for (i = 0; i < nlis; ++i) {
            lis[i].p0.x -= x; lis[i].p0.y -= y;
            lis[i].p1.x -= x; lis[i].p1.y -= y;
            lis[i].p2.x -= x; lis[i].p2.y -= y;
            lis[i].q0.x -= x; lis[i].q0.y -= y;
            lis[i].q1.x -= x; lis[i].q1.y -= y;
            lis[i].q2.x -= x; lis[i].q2.y -= y;
        }
        drawlineinfos_impl(w, lis, nlis, closed);
        draw_drawlist(wd, PictOpOver, wd->white->brush, mask);
        maskpic2(w, mask, x, y, width, height);
        XRenderFreePicture(wd->display, mask);
    } else {
        drawlineinfos_impl(w, lis, nlis, closed);
        draw_drawlist(wd, wc->drawop->i, get_draw_picture(wc), ws->ppic);
        pix_to_win(ws, x, y, width, height);
    }

    free_drawlist();
}

void drawlines(wbp w, struct point *points, int npoints)
{
    wcp wc = w->context;
    struct lineinfo *lis;
    int nlis, i, closed;
    XPointDouble pd1, pd2;

    if (npoints < 2)
        return;
    closed = points[npoints - 1].x == points[0].x && points[npoints - 1].y == points[0].y;

    lis = safe_malloc((npoints - 1) * sizeof(struct lineinfo));
    pd1 = adjustpoint(wc, points, npoints, 0, closed);
    nlis = 0;
    for (i = 1; i < npoints; ++i) {
        if (points[i - 1].x != points[i].x || points[i - 1].y != points[i].y) {
            pd2 = adjustpoint(wc, points, npoints, i, closed);
            getlineinfo(wc, &pd1, &pd2, &lis[nlis]);
            nlis++;
            pd1 = pd2;
        }
    }

    drawlineinfos(w, lis, nlis, closed);
    free(lis);
}

static int needmask(wcp wc, int overlap)
{
    /* ops where influence of source pixel is 0 (clear, dest) */
    if (wc->drawop->i == PictOpClear || wc->drawop->i == PictOpDst)
        return 0;
    if (wc->pattern || wc->mask)
        return 1;
    if (!overlap)
        return 0;
    /* overlap doesn't matter if influence of dest pixel is 0 */
    if (wc->drawop->i == PictOpSrc)
        return 0;
    if (wc->fg->color.alpha == 0xffff && wc->drawop->i == PictOpOver)
        return 0;
    return 1;
}

static Picture getmask(wdp wd, int width, int height)
{
    Pixmap pix;
    Picture pic;
    XRenderPictureAttributes attr;
    pix = XCreatePixmap(wd->display, GetRoot(wd),
                        width,
                        height,
                        8);
    attr.poly_edge = PolyEdge;
    attr.poly_mode = PolyMode;
    pic = XRenderCreatePicture(wd->display, pix, wd->maskfmt, CPPolyEdge | CPPolyMode, &attr);
    XFreePixmap(wd->display, pix);
    XRenderFillRectangle(wd->display, PictOpSrc, pic, &wd->transparent->color, 0, 0, width ,height);
    return pic;
}

void drawrectangle(wbp w, int x, int y, int width, int height, int thick)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    wcp wc = w->context;
    /* If too small to give a gap in the middle, then simply fill a
     * rectangle, otherwise draw as four lines. */
    if (width <= 2 * thick || height <= 2 * thick)
        fillrectangle(w, x, y, width, height);
    else {
        clip(w);
        /* Note that we know the two vertical lines will be at least one pixel high, since
         * height > 2 * thick
         */
        if (wc->pattern || wc->mask) {
            pat1(w,
                 x, y,
                 width, thick);
            pat1(w,
                 x, y +  thick,
                 thick, height - 2 * thick);
            pat1(w,
                 x + width - thick, y + thick,
                 thick, height - 2 * thick);
            pat1(w,
                 x, y + height - thick,
                 width, thick);
        } else {
            XRectangle r[4];
            r[0].x = x;
            r[0].y = y;
            r[0].width = width;
            r[0].height = thick;
            r[1].x = x;
            r[1].y = y +  thick;
            r[1].width = thick;
            r[1].height = height - 2 * thick;
            r[2].x = x + width - thick;
            r[2].y = y + thick;
            r[2].width = thick;
            r[2].height = height - 2 * thick;
            r[3].x = x;
            r[3].y = y + height - thick;
            r[3].width = width;
            r[3].height = thick;
            XRenderFillRectangles(wd->display,
                                  wc->drawop->i,
                                  ws->ppic,
                                  &wc->fg->color,
                                  r, 4);
        }

        pix_to_win(ws, x, y, width, height);
    }
}

void fillpolygon(wbp w, struct point *points, int npoints)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    int x, y, width, height, i;
    if (npoints < 3)
        return;
    points_extent(points, npoints, &x, &y, &width, &height);
    if (!reducerect(w, 1, &x, &y, &width, &height))
        return;

    init_drawlist(npoints * 5, triangles > 1);
    clip(w);
    if (needmask(wc, 0)) {
        Picture mask;
        for (i = 0; i < npoints; ++i) {
            points[i].x -= x;
            points[i].y -= y;
        }
        mask = getmask(wd, width, height);
        mk_polygon(points, npoints, wc->fillrule->i);
        draw_drawlist(wd, PictOpOver, wd->white->brush,  mask);
        maskpic2(w, mask, x, y, width, height);
        XRenderFreePicture(wd->display, mask);
    } else {
        mk_polygon(points, npoints, wc->fillrule->i);
        draw_drawlist(wd,
                      wc->drawop->i,
                      get_draw_picture(wc),
                      ws->ppic);
        pix_to_win(ws, x, y, width, height);
    }
    free_drawlist();
}

void filltriangles(wbp w, struct triangle *tris, int ntris)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    int x, y, width, height, i;

    triangles_extent(tris, ntris, &x, &y, &width, &height);
    if (!reducerect(w, 1, &x, &y, &width, &height))
        return;

    init_drawlist(2 * ntris, triangles > 0);
    clip(w);
    if (needmask(wc, 1)) {
        Picture mask;
        for (i = 0; i < ntris; ++i) {
            tris[i].p1.x -= x; tris[i].p1.y -= y;
            tris[i].p2.x -= x; tris[i].p2.y -= y;
            tris[i].p3.x -= x; tris[i].p3.y -= y;
            add_tri((XPointDouble *)&tris[i].p1,
                    (XPointDouble *)&tris[i].p2,
                    (XPointDouble *)&tris[i].p3);
        }
        mask = getmask(wd, width, height);
        draw_drawlist(wd, PictOpOver, wd->white->brush,  mask);
        maskpic2(w, mask, x, y, width, height);
        XRenderFreePicture(wd->display, mask);
    } else {
        for (i = 0; i < ntris; ++i)
            add_tri((XPointDouble *)&tris[i].p1,
                    (XPointDouble *)&tris[i].p2,
                    (XPointDouble *)&tris[i].p3);
        draw_drawlist(wd,
                      wc->drawop->i,
                      get_draw_picture(wc),
                      ws->ppic);
        pix_to_win(ws, x, y, width, height);
    }
    free_drawlist();
}

static void maskpic2(wbp w, Picture mask, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    if (wc->mask) {
        XRenderComposite(wd->display,
                         PictOpInReverse,
                         get_mask_picture(wc),     /* src */
                         None,                     /* mask */
                         mask,                     /* dest */
                         x, y,                     /* src x,y */
                         0, 0,                     /* mask x,y */
                         0, 0,                     /* dest x,y */
                         width, height);
    }
    XRenderComposite(wd->display,
                     wc->drawop->i,
                     get_draw_picture(wc),         /* src */
                     mask,                         /* mask */
                     ws->ppic,                     /* dest */
                     x, y,                         /* src x,y */
                     0, 0,                         /* mask x,y */
                     x, y,                         /* dest x,y */
                     width, height);
    pix_to_win(ws, x, y, width, height);
}

static void pat1(wbp w, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    XRenderComposite(wd->display,
                     wc->drawop->i,
                     get_draw_picture(wc),         /* src */
                     get_mask_picture(wc),         /* mask */
                     ws->ppic,                     /* dest */
                     x, y,                         /* src x,y */
                     x, y,                         /* mask x,y */
                     x, y,                         /* dest x,y */
                     width, height);
}

static void pat2(wbp w, int x, int y, int width, int height)
{
    pat1(w, x, y, width, height);
    pix_to_win(w->window, x, y, width, height);
}

static void fill2(wbp w, int op, XRenderColor *color, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    XRenderFillRectangle(wd->display,
                         op,
                         ws->ppic,
                         color,
                         x, y, width, height);
    pix_to_win(ws, x, y, width, height);
}

static Pixmap imgdata_to_Pixmap1(wdp wd, struct imgdata *imd, int ix, int iy, int iw, int ih)
{
    XImage *xi;
    Pixmap pix;
    GC gc;
    int bpp, depth, stride;
    unsigned char *p;

    depth = imd->format->alpha_depth + imd->format->color_depth;
    bpp = depth / 8;
    p = imd->data + bpp * (iy * imd->width + ix);
    stride = bpp * imd->width;

    MemProtect(xi = XCreateImage(wd->display, 
                                 NULL,
                                 depth,            /* depth */
                                 ZPixmap, 
                                 0, 
                                 (char *)p, 
                                 iw, ih,
                                 depth,            /* bitmap_pad */
                                 stride));

    pix = XCreatePixmap(wd->display, GetRoot(wd),
                        iw, ih,
                        depth);
    gc = XCreateGC(wd->display, pix, 0, NULL);
    XPutImage(wd->display, pix, gc, xi,
              0,0, 0,0, iw, ih);
    xi->data = 0;
    XDestroyImage(xi);
    XFreeGC(wd->display, gc);
    return pix;
}

/*
 * Convert the given interior rectangle of the given imgdata to a
 * Pixmap.  depth (8 or 32) indicates the required depth if a
 * transformation of the imgdata has to be done; the returned Pixmap
 * won't necessarily be of this depth if it is already in a known
 * format.  The picture format matching the returned Pixmap is
 * returned in format.
 */
static Pixmap imgdata_to_Pixmap(wdp wd, struct imgdata *imd,
                                int ix, int iy, int iw, int ih,
                                int depth, XRenderPictFormat **format)
{
    struct imgdata *tmp;
    struct imgdataformat *cv_fmt = 0;
    Pixmap pix;
    if (imd->format == wd->format) {
        *format = wd->pixfmt;
        return imgdata_to_Pixmap1(wd, imd, ix, iy, iw, ih);
    }
    if (imd->format == &imgdataformat_A8) {
        *format = wd->maskfmt;
        return imgdata_to_Pixmap1(wd, imd, ix, iy, iw, ih);
    }
    /* Conversion needed */
    switch (depth) {
        case 8:  *format = wd->maskfmt; cv_fmt = &imgdataformat_A8; break;
        case 32: *format = wd->pixfmt; cv_fmt = wd->format; break;
        default: syserr("Invalid depth"); break;
    }
    tmp = initimgdata(iw, ih, cv_fmt);
    copyimgdata(tmp, imd, ix, iy);
    pix = imgdata_to_Pixmap1(wd, tmp, 0, 0, iw, ih);
    unlinkimgdata(tmp);
    return pix;
}

static Picture get_draw_picture(wcp wc)
{
    if (wc->pattern)
        return wc->pattern->i;
    else
        return wc->fg->brush;
}

static Picture get_mask_picture(wcp wc)
{
    if (wc->mask)
        return wc->mask->i;
    else
        return None;
}

/*
 * fill a rectangle
 */
void fillrectangle(wbp w, int x, int y, int width, int height)
{
    wcp wc = w->context;
    clip(w);
    /*
     * fill the rectangle with the pattern or foreground color
     */
    if (wc->pattern || wc->mask)
        pat2(w, 
             x, y, width, height);
    else
        fill2(w,
              wc->drawop->i,
              &wc->fg->color,
              x, y, width, height);
}

/*
 * erase an area
 */
void erasearea(wbp w, int x, int y, int width, int height)
{
    wcp wc = w->context;
    clip(w);
    /*
     * fill the rectangle with the background color
     */
    fill2(w,
          PictOpSrc,
          &wc->bg->color,
          x, y, width, height);
}

/*
 * copy an area
 */
void copyarea(wbp w, int x, int y, int width, int height, wbp w2, int x2, int y2)
{
    wsp ws1 = w->window;
    wsp ws2 = w2->window;
    wcp wc2 = w2->context;
    wdp wd1 = ws1->display;
    wdp wd2 = ws2->display;

    if (wd1 == wd2) {

        /*
         * Copying is between windows on one display, perhaps the same window.
         */
        no_clip(ws1, 0);
        clip(w2);

        /*
         * Copy the area.
         */
        XRenderComposite(wd1->display,
                         wc2->drawop->i,
                         ws1->ppic,              /* src */
                         get_mask_picture(wc2),  /* mask */
                         ws2->ppic,              /* dest */
                         x, y,                   /* src x,y */
                         x2, y2,                 /* mask x,y */
                         x2, y2,                 /* dst x,y */
                         width, height);
        pix_to_win(ws2, x2, y2, width, height);

    } else {

        /*
         * Copying is between different displays, and requires an intermediate buffer.
         */

        struct imgdata *imd;
        imd = newimgdata();
        imd->width = width;
        imd->height = height;
        captureimgdata(w, x, y, imd);
        drawimgdata(w2, x2, y2, imd, 0);
        unlinkimgdata(imd);
    }
}

void captureimgdata(wbp w, int x, int y, struct imgdata *imd)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    XImage *xi;
    MemProtect(xi = XGetImage(wd->display, ws->pix,
                              x, y, imd->width, imd->height,
                              AllPlanes, ZPixmap));
    imd->format = wd->format;
    imd->data = (unsigned char *)xi->data;
    xi->data = 0;
    XDestroyImage(xi);
}

void drawimgdata(wbp w, int x, int y, struct imgdata *imd, int copy)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    int ix, iy, iw, ih;
    Pixmap pix;
    Picture pic;
    XRenderPictFormat *format;

    ix = x; iy = y; iw = imd->width; ih = imd->height;
    if (!reducerect(w, 1, &ix, &iy, &iw, &ih))
        return;

    pix = imgdata_to_Pixmap(wd, imd, ix - x, iy - y, iw, ih, 32, &format);
    pic = XRenderCreatePicture(wd->display, pix, format, 0, 0);
    clip(w);

    if (copy)
        XRenderComposite(wd->display,
                         PictOpSrc,             /* op */
                         pic,                   /* src */
                         None,                  /* mask */
                         ws->ppic,              /* dest */
                         0, 0,                  /* src x,y */
                         0, 0,                  /* mask x,y */
                         ix, iy,                /* dst x,y */
                         iw, ih);
    else
        XRenderComposite(wd->display,
                         wc->drawop->i,         /* op */
                         pic,                   /* src */
                         get_mask_picture(wc),  /* mask */
                         ws->ppic,              /* dest */
                         0, 0,                  /* src x,y */
                         ix, iy,                /* mask x,y */
                         ix, iy,                /* dst x,y */
                         iw, ih);

    pix_to_win(ws, ix, iy, iw, ih);

    XFreePixmap(wd->display, pix);
    XRenderFreePicture(wd->display, pic);
}

struct imgdataformat *getimgdataformat(wbp w)
{
    return w->window->display->format;
}

int querypointer(wbp w, int *x, int *y)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    Window garbage1, garbage2;
    int root_x, root_y;
    unsigned int key_buttons;
    CheckUnhidden(ws);
    /* XQueryPointer returns false if the pointer is not on the X11 Screen. */
    if (XQueryPointer(wd->display, ws->win, &garbage1, &garbage2,
                      &root_x, &root_y, x, y, &key_buttons) == False) {
        LitWhy("Pointer not on screen");
        return Failed;
    }
    return Succeeded;
}

int queryrootpointer(wbp w, int *x, int *y)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    Window garbage1, garbage2;
    int win_x, win_y;
    unsigned int key_buttons;
    /* XQueryPointer returns false if the pointer is not on the X11 Screen. */
    if (XQueryPointer(wd->display, GetRoot(wd), &garbage1, &garbage2,
                      x, y, &win_x, &win_y, &key_buttons) == False) {
        LitWhy("Pointer not on screen");
        return Failed;
    }
    return Succeeded;
}

int focuswindow(wbp w)
{
    XWindowAttributes attr;
    wsp ws = w->window;
    wdp wd = ws->display;
    CheckUnhidden(ws);
    /* From the manpage : The specified focus window must be viewable
     * at the time XSetInputFocus is called, or a BadMatch error
     * results. */
    XGetWindowAttributes(wd->display, ws->win, &attr);
    if (attr.map_state != IsViewable) {
        LitWhy("Can't focus window that is not viewable");
        return Failed;
    }
    XSetInputFocus(wd->display, ws->win, RevertToParent, CurrentTime);
    return Succeeded;
}

int raisewindow(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    XRaiseWindow(ws->display->display, ws->win);
    return Succeeded;
}

int lowerwindow(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    XLowerWindow(ws->display->display, ws->win);
    return Succeeded;
}

int getwindowid(wbp w, char **s)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    *s = buffprintf("0x%lx", (unsigned long)ws->win);
    return Succeeded;
}

int getwindowfd(wbp w, int *v)
{
    *v = XConnectionNumber(w->window->display->display);
    return Succeeded;
}

int walert(wbp w, int volume)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    XBell(wd->display, volume);    
    XFlush(wd->display);
    return Succeeded;
}

/* Xft can't handle very long strings, and drawing very long ones can
 * cause an X error.  So the length of strings is limited when
 * calculating length or drawing. 
 */
#define MaxXftChunk 512

/*
 * The textwidth functions follow a similar pattern to the drawstring
 * functions below; see there for comments.
 */

static int textwidth8(wbp w, dptr str)
{
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;
    XGlyphInfo extents; 
    int width;
    word len;
    char *p;

    p = StrLoc(*str);
    len = StrLen(*str);
    width = 0;
    while (len > MaxXftChunk) {
        XftTextExtents8(wd->display,
                        wc->font->fsp,
                        (FcChar8 *)p,
                        MaxXftChunk,
                        &extents);
        width += extents.xOff & 0xffff;
        p += MaxXftChunk;
        len -= MaxXftChunk;
    }
    if (len) {
        XftTextExtents8(wd->display,
                        wc->font->fsp,
                        (FcChar8 *)p,
                        len,
                        &extents);
        width += extents.xOff & 0xffff;
    }
    return width;
}

static int textwidthUtf8(wbp w, dptr str)
{
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;
    XGlyphInfo extents; 
    int width, ch;
    word len, cn;
    char *p, *p1, *start;
    XftFont *font, *f1;

    width = 0;
    start = p = StrLoc(UcsBlk(*str).utf8);
    font = wc->font->fsp;
    len = UcsBlk(*str).length;
    cn = 0;
    while (len--) {
        p1 = p;
        ch = utf8_iter(&p);
        f1 = font;
        font = fallback(w, ch);
        if ((f1 != font && p1 != start) || cn == MaxXftChunk) {
            XftTextExtentsUtf8(wd->display,
                               f1,
                               (FcChar8 *)start,
                               p1 - start,
                               &extents);
            width += extents.xOff & 0xffff;
            start = p1;
            cn = 1;
        } else
            cn++;
    }
    if (p != start) {
        XftTextExtentsUtf8(wd->display,
                           font,
                           (FcChar8 *)start,
                           p - start,
                           &extents);
        width += extents.xOff & 0xffff;
    }
    return width;
}

int textwidth(wbp w, dptr str)
{
    if (is:string(*str))
        return textwidth8(w, str);
    else if (UcsBlk(*str).index_step == 0)
        /* ucs, but all ascii characters. */
        return textwidth8(w, &UcsBlk(*str).utf8);
    else
        return textwidthUtf8(w, str);
}

/*
 * Given a character and a window, return a suitable font for drawing
 * it, which will either be the context's font or a fallback based
 * upon it.
 */
static XftFont *fallback(wbp w, int ch)
{
    int i;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;
    wfp font = wc->font;

    /* For consistency with the all-ascii check in drawstring() and
     * textwidth(), assume any ascii character is in the base font. */
    if (ch < 128 || XftGlyphExists(wd->display, font->fsp, ch))
        return font->fsp;

    if (!font->fbpatterns) {
         FcResult status;
         int spacing;
         /* Turn the font name into a pattern. +3 skips over "fc:" */
         font->base = FcNameParse((FcChar8 *)(font->name + 3));
         if (font->base) {
             FcPatternAddBool(font->base, FC_SCALABLE, FcTrue);
             /* For a mono font, set FC_CHAR_WIDTH.  So far as I can tell,
              * this means that the resulting fonts will all be output as
              * monospaced, even if the source font was not. */
             spacing = -1;
             FcPatternGetInteger(font->base, FC_SPACING, 0, &spacing);
             if (spacing == FC_MONO)
                 FcPatternAddInteger(font->base, FC_CHAR_WIDTH, font->fsp->max_advance_width);
             FcConfigSubstitute(NULL, font->base, FcMatchPattern);
             /* This is a wrapper around FcDefaultSubstitute().  Of
              * particular note is that it sets the "dpi" attribute of
              * the pattern correctly (from Xft.dpi in X resources, or
              * calcuated via the usual X calls).  This means the
              * "pixelsize" setting is also made correctly. */
             XftDefaultSubstitute(wd->display, DefaultScreen(wd->display), font->base);
             /* Get the list of fallback patterns. */
             font->fbpatterns = FcFontSort(NULL, font->base, FcTrue, &font->fbcoverage, &status);
         }
         /* Set missing empty value, to avoid going through this setup
          * again.  Note that if font->fbcoverage is NULL, then that
          * is okay, since FcCharSetHasChar() treats NULL as the empty
          * set. */
         if (!font->fbpatterns) {
             MemProtect(font->fbpatterns = FcFontSetCreate());
             font->fbcoverage = NULL;
         }
         /* An array to store the fonts corresponding to the
          * patterns. */
         font->fbfonts = safe_zalloc(font->fbpatterns->nfont * sizeof(XftFont *));
         /* An array for quick lookup of the patterns' charsets.  The
          * same comment above about a NULL fbcoverage applies to
          * these sets too. */
         font->fbcs = safe_zalloc(font->fbpatterns->nfont * sizeof(FcCharSet *));
         for (i = 0; i < font->fbpatterns->nfont; i++)
             FcPatternGetCharSet(font->fbpatterns->fonts[i],
                                 FC_CHARSET, 0, &font->fbcs[i]);
         if (font_debug)
             printf("Font %s has %d fallbacks\n", font->name, font->fbpatterns->nfont);
    }

    /* Now font->fbpatterns has the fallback font patterns list, and
     * font->fbcoverage has the set of characters in those fonts. */

    if (FcCharSetHasChar(font->fbcoverage, ch)) {
        /* ch should be in the list somewhere. */
        for (i = 0; i < font->fbpatterns->nfont; i++) {
            if (FcCharSetHasChar(font->fbcs[i], ch)) {
                if (!font->fbfonts[i]) {
                    XftFont *f = NULL;
                    FcPattern *munge;
                    /* Now we munge the base pattern + the returned
                     * pattern together to get the font to open. */
                    munge = FcFontRenderPrepare(NULL,
                                                font->base,
                                                font->fbpatterns->fonts[i]);
                    if (munge) {
                        /* munge must only be destroyed if the following
                         * call returns null; see libXft's xftfont.c for
                         * several precedents.
                         */
                        f = XftFontOpenPattern(wd->display, munge);
                        if (!f)
                            FcPatternDestroy(munge);
                    }
                    if (font_debug) {
                        printf("Font %s loading fallback %d for char U+%04X\n", font->name, i, ch);
                        if (f) {
                            FcChar8 *t1, *t2;
                            t1 = t2 = (FcChar8 *)"?";
                            FcPatternGetString(f->pattern, FC_FAMILY, 0, &t1);
                            FcPatternGetString(f->pattern, FC_FILE, 0, &t2);
                            printf("\tResult: '%s' from %s\n", t1, t2);
                        } else
                            printf("\tFailed to load\n");
                    }
                    /* If we failed to get a font somehow, just insert the
                     * base font as a placeholder instead. */
                    if (!f)
                        f = font->fsp;
                    font->fbfonts[i] = f;
                }
                return font->fbfonts[i];
            }
        }
    }

    /* Nothing found */
    return font->fsp;
}

/*
 * Given an x position for drawing a string, does the window/clip size
 * indicate that no string need be drawn, however long it may be?
 */
static int gone_right(wbp w, int x)
{
    wcp wc = w->context;

    /*
     * Deduct two char widths from x to take into account strings that
     * render slightly to the left of their given x position (they
     * will have an XGlyphInfo with a x value > 0).
     */
    x -= 2 * wc->font->maxwidth;

    return x >= w->window->width ||
        (wc->clipw >= 0 && x >= wc->clipx + wc->clipw);
}

/*
 * Given a baseline y for drawing a string, does the window/clip size
 * indicate that nothing need be done?
 */
static int y_outside(wbp w, int y)
{
    wcp wc = w->context;
    int h, fh;

    fh = wc->font->ascent + wc->font->descent;

    /* y is one fh above the top ascent line, y+h is one fh below the
     * bottom descent line; so a safety margin of 1 fh on either side.
     */
    y -= wc->font->ascent + fh;
    h = 3 * fh;

    return !reducevline(w, 1, &y, &h);
}

/*
 * The drawstring functions below address several problems with Xft's
 * string drawing functions :-
 * 
 * 1) the absence of fallback font substitution (see fallback() above).
 * 
 * 2) incorrect behaviour if a very long string is drawn.  Hence it must be
 *    split up into several chunks to be given to Xft separately.
 * 
 * 3) incorrect behaviour if a large magnitude x location is used.
 *    Hence reducerect() must be used to ensure Xft isn't called with
 *    such an x.
 */


/*
 * Helper function to take an x, y location and a XGlyphInfo string
 * extents structure, and calculate the corresponding rectangle,
 * reduced by window and clip.  Returns true iff the result rectangle
 * is non-empty.
 */
static int reduce_extents(wbp w, int x, int y, XGlyphInfo *extents, int *xr, int *yr, int *wr, int *hr)
{
    *xr = x - extents->x;
    *wr = extents->width;
    *yr = y - extents->y;
    *hr = extents->height;
    return reducerect(w, 1, xr, yr, wr, hr);
}

static void text8(wbp w,
                  XftFont *font,
                  int x, int y,
                  FcChar8 *string, int len,
                  int *wx)
{
    XGlyphInfo extents; 
    int x1, y1, w1, h1;
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;

    XftTextExtents8(wd->display,
                    font,
                    string,
                    len,
                    &extents);
    if (wx)
        *wx = extents.xOff & 0xffff;

    if (!reduce_extents(w, x, y, &extents, &x1, &y1, &w1, &h1))
        return;

    if (needmask(wc, 0)) {
        Picture mask;
        mask = getmask(wd, w1, h1);
        XftTextRender8(wd->display,
                       PictOpOver,            /* op */
                       wd->white->brush,      /* src */
                       font,                  /* font */
                       mask,                  /* dest */
                       0, 0,                  /* src x,y */
                       x - x1, y - y1,        /* dest x,y */
                       string, len);
        maskpic2(w, mask, x1, y1, w1, h1);
        XRenderFreePicture(wd->display, mask);
    } else {
        XftTextRender8(wd->display,
                       wc->drawop->i,         /* op */
                       get_draw_picture(wc),  /* src */
                       font,                  /* font */
                       ws->ppic,              /* dest */
                       0, 0,                  /* src x,y */
                       x, y,                  /* dest x,y */
                       string, len);
        pix_to_win(ws, x1, y1, w1, h1);
    }
}

/*
 * Draw a simple byte string; no font substitution is done.  This
 * follows a similar pattern to the utf-8 case below; see there for
 * comments.
 */
static void drawstring8(wbp w, int x, int y, dptr str)
{
    word len;
    char *p;
    int wx;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;

    p = StrLoc(*str);
    len = StrLen(*str);

    if (len == 0 || y_outside(w, y) || gone_right(w, x))
        return;

    clip(w);

    while (len > MaxXftChunk) {
        text8(w,
              wc->font->fsp,
              x, y,
              (FcChar8 *)p,
              MaxXftChunk,
              &wx);
        x += wx;
        if (gone_right(w, x))
            return;

        p += MaxXftChunk;
        len -= MaxXftChunk;
    }

    /* len > 0 */
    if (needmask(wc, 0) || Copying(ws) || x < 0) {
        text8(w,
              wc->font->fsp,
              x, y,
              (FcChar8 *)p,
              len,
              NULL);
    } else {
        XftTextRender8(wd->display,
                       wc->drawop->i,         /* op */
                       get_draw_picture(wc),  /* src */
                       wc->font->fsp,         /* font */
                       ws->ppic,              /* dest */
                       0, 0,                  /* src x,y */
                       x, y,                  /* dest x,y */
                       (FcChar8 *)p,
                       len);
    }
}

/*
 * Helper to draw the given string at x,y, with reduction and masking.
 */
static void textUtf8(wbp w,
                     XftFont *font,
                     int x, int y,
                     FcChar8 *string, int len,
                     int *wx)
{
    XGlyphInfo extents; 
    int x1, y1, w1, h1;
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;

    /* Get the string extents */
    XftTextExtentsUtf8(wd->display,
                       font,
                       string,
                       len,
                       &extents);
    /* Store the string x size, for the caller to advance its x
     * position.  Field xOff is a short; on long strings it wraps
     * round at 32k, so anding with 0xffff doubles the range of
     * sensible result values. */
    if (wx)
        *wx = extents.xOff & 0xffff;

    /* Reduce the text rectangle to the drawable area. */
    if (!reduce_extents(w, x, y, &extents, &x1, &y1, &w1, &h1))
        return;

    /* Draw the reduced area with or without a mask as needed.  We
     * shouldn't actually need a mask if we have a context pattern and
     * no context mask, but there is a bug/inconsistency in the intel
     * X driver, which gets the source x,y parameters wrong (they are
     * added to dest x,y it seems).  So in that case a mask is used
     * anyway.
     */
    if (needmask(wc, 0)) {
        Picture mask;
        mask = getmask(wd, w1, h1);
        XftTextRenderUtf8(wd->display,
                          PictOpOver,            /* op */
                          wd->white->brush,      /* src */
                          font,                  /* font */
                          mask,                  /* dest */
                          0, 0,                  /* src x,y */
                          x - x1, y - y1,        /* dest x,y */
                          string, len);
        maskpic2(w, mask, x1, y1, w1, h1);
        XRenderFreePicture(wd->display, mask);
    } else {
        XftTextRenderUtf8(wd->display,
                          wc->drawop->i,         /* op */
                          get_draw_picture(wc),  /* src */
                          font,                  /* font */
                          ws->ppic,              /* dest */
                          0, 0,                  /* src x,y */
                          x, y,                  /* dest x,y */
                          string, len);
        pix_to_win(ws, x1, y1, w1, h1);
    }
}

static void drawstringUtf8(wbp w, int x, int y, dptr str)
{
    word len, cn;
    int wx, ch;
    char *p, *p1, *start;
    XftFont *font, *f1;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;

    p = StrLoc(UcsBlk(*str).utf8);
    len = UcsBlk(*str).length;

    /* Check for empty string, or x or y which won't produce
     * output. */
    if (len == 0 || y_outside(w, y) || gone_right(w, x))
        return;

    clip(w);

    start = p;
    font = wc->font->fsp;

    /* Invariant: cn == #utf-8 chars in the string at start, of length
     * (p - start); cn is only zero on 1st iteration. */
    cn = 0;
    while (len--) {
        p1 = p;
        ch = utf8_iter(&p);
        f1 = font;
        font = fallback(w, ch);
        if ((f1 != font && p1 != start) || cn == MaxXftChunk) {
            textUtf8(w,
                     f1,
                     x, y,
                     (FcChar8 *)start,
                     p1 - start,
                     &wx);
            x += wx;
            /* Check for early termination, if x is now past the right
             * of the drawing area. */
            if (gone_right(w, x))
                return;

            start = p1;
            cn = 1;
        } else
            cn++;
    }

    /* Now p != start, since we must have been around the above while
     * loop at least once, having checked for empty string at the top.
     *
     * This next test is an optimization to try to save a call to
     * XftTextExtentsUtf8() if we know we don't need a mask, or need
     * to call pix_to_win(), and x isn't in the range where Xft
     * malfunctions, namely with a very large -ve x.  Should that be
     * the case, we get the extents in textUft8 (that works), and then
     * expect reducerect to return false (since we know p-start is a
     * reasonable size, <= MaxXftChunk).
     */
    if (needmask(wc, 0) || Copying(ws) || x < 0) {
        textUtf8(w,
                 font,
                 x, y,
                 (FcChar8 *)start,
                 p - start,
                 NULL);
    } else {
        XftTextRenderUtf8(wd->display,
                          wc->drawop->i,         /* op */
                          get_draw_picture(wc),  /* src */
                          font,                  /* font */
                          ws->ppic,              /* dest */
                          0, 0,                  /* src x,y */
                          x, y,                  /* dest x,y */
                          (FcChar8 *)start,
                          p - start);
    }
}

void drawstring(wbp w, int x, int y, dptr str)
{
    if (is:string(*str))
        drawstring8(w, x, y, str);
    else if (UcsBlk(*str).index_step == 0)
        /* ucs, but all ascii characters. */
        drawstring8(w, x, y, &UcsBlk(*str).utf8);
    else
        drawstringUtf8(w, x, y, str);
}

/* This array must correspond with the NUM_ATOMS and ATOM_xxx constants defined in graphics.h. */
static char *atom_names[NUM_ATOMS] = {
    "CHARACTER_POSITION",
    "CLIENT_WINDOW",
    "CLIPBOARD",
    "HOSTNAME",
    "HOST_NAME",
    "LENGTH",
    "LIST_LENGTH",
    "NAME",
    "OWNER_OS",
    "SPAN",
    "TARGETS",
    "TIMESTAMP",
    "USER",
    "WM_DELETE_WINDOW",
    "_NET_WM_STATE_MAXIMIZED_VERT",
    "_NET_WM_STATE_MAXIMIZED_HORZ",
    "_NET_WM_STATE_FULLSCREEN",
    "_NET_WM_STATE",
    "_NET_WM_ICON",
    "_NET_WM_NAME",
    "UTF8_STRING",
    "WM_STATE",
    "_OBJECTICON_PROP0",
    "_OBJECTICON_PROP1",
    "_OBJECTICON_PROP2",
    "_OBJECTICON_PROP3",
    "_OBJECTICON_PROP4",
    "_OBJECTICON_PROP5",
    "_OBJECTICON_PROP6",
    "_OBJECTICON_PROP7",
    "_NET_WM_STATE_SHADED",
    "WM_PROTOCOLS",
    "INCR",
};

/*
 * allocate a window binding structure
 */
wbp alcwbinding(wdp wd)
{
    wbp w;
    w = safe_zalloc(sizeof(struct _wbinding));
    GLink(w, wd->wbndngs);
    return w;
}

/*
 * free a window binding.
 */
void freewbinding(wbp w)
{
    wdp wd = w->window->display;
    freewindow(w->window);
    freecontext(w->context);
    GUnlink(w, wd->wbndngs);
    free(w);
}

wbp findwbp(wsp ws)
{
    wbp wb;
    for (wb = ws->display->wbndngs; wb; wb = wb->next)
        if (wb->window == ws)
            return wb;
    syserr("Couldn't find wbp for wsp");
    return 0;  /* not reached */
}

/*
 * allocate a display on machine s
 */
static wdp alcdisplay(char *s)
{
    static int inited;
    wdp wd;
    int i, major_version, minor_version;

    if (!inited) {
        env_string("OI_RESOURCE_NAME", &resource_name);
        env_string("OI_RESOURCE_CLASS", &resource_class);
        env_string("DISPLAY", &display);
        env_int("OI_MAX_X_SELECTION_SIZE", &max_selection_size, 1024 * 512, INT_MAX);
        env_int("OI_MAX_X_SELECTION_CHUNK", &max_selection_chunk, 1024, INT_MAX);
        env_int("OI_X_SELECTION_DEBUG", &selection_debug, 0, 1);
        env_int("OI_X_FONT_DEBUG", &font_debug, 0, 1);
        env_int("OI_X_POLY_DEBUG", &poly_debug, 0, 1);
        env_int("OI_X_DRAW_DEBUG", &draw_debug, 0, 1);
        env_int("OI_X_TRIANGLES", &triangles, 0, 2);
        default_XErrorHandler = XSetErrorHandler(custom_XErrorHandler);
        inited = 1;
    }

    if (s == NULL) {
        s = display;
        if (s == NULL) {
            LitWhy("DISPLAY variable not set");
            return NULL;
        }
    }

    for(wd = wdsplys; wd; wd = wd->next)
        if (wd->program == curpstate && !strcmp(wd->name, s)) {
            return wd;
        }

    wd = safe_zalloc(sizeof(struct _wdisplay));

    wd->program = curpstate;
    wd->display = XOpenDisplay(s);
    if (wd->display == NULL) {
        LitWhy("Couldn't connect to display");
        free(wd);
        return NULL;
    }

    if (!XRenderQueryVersion(wd->display, &major_version, &minor_version)) {
        LitWhy("XRender extension not available on server");
        XCloseDisplay(wd->display);
        free(wd);
        return NULL;
    }

    wd->format = ImageByteOrder(wd->display) == LSBFirst ? &imgdataformat_X11BGRA32 : &imgdataformat_X11ARGB32;
    wd->maskfmt = XRenderFindStandardFormat(wd->display, PictStandardA8);
    wd->winfmt = XRenderFindVisualFormat(wd->display, GetVisual(wd));
    wd->defaultfont = loadfont(wd, defaultfont);
    if (wd->defaultfont == NULL) {
        LitWhy("Couldn't load default font");
        XCloseDisplay(wd->display);
        free(wd);
        return NULL;
    }
    wd->name = salloc(s);
    wd->pixfmt = XRenderFindStandardFormat(wd->display, PictStandardARGB32);
    wd->black = new_sharedcolor(wd, "black", 0, 0, 0, 65535);
    wd->white = new_sharedcolor(wd, "white", 65535, 65535, 65535, 65535);
    wd->transparent = new_sharedcolor(wd, "transparent", 0, 0, 0, 0);
    wd->recent = CurrentTime;
    XInternAtoms(wd->display, atom_names, NUM_ATOMS, False, wd->atoms);
    setup_cursors(wd);
    for (i = 0; i < NUM_PROP_ATOMS; ++i)
        reset_receiving_helper(&wd->receiving_helpers[i]);

    for (i = 0; i < NUM_SENDING_HELPERS; ++i)
        init_sending_helper(&wd->sending_helpers[i]);

    GLink(wd, wdsplys);
    return wd;
}

/*
 * Convert a given font spec, which may or may not be in icon font spec format,
 * into fontconfig (used by Xft) style format.
 * 
 * To avoid ambiguity, a spec can start with "fc:" to indicate it's in fontconfig
 * format; otherwise parsefont is called to decide the format.
 */
char *tofcpatternstr(char *s)
{
    static char *res;
    int flags;
    double size;
    char family[MAXFONTWORD];
    FcPattern *p;

    if (!strncmp(s, "fc:", 3))
        return s + 3;

    if (!parsefont(s, family, &flags, &size))
        return 0;

    MemProtect(p = FcPatternCreate());

    /*
     * Check first for special "standard" family names.
     */
    if (!strcmp(family, "fixed")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon fixed");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"mono");
        if ((flags & FONTATT_SPACING) == 0) flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "mono")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon mono");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"mono");
        if ((flags & FONTATT_SPACING) == 0) flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "typewriter")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon typewriter");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Courier");
        if ((flags & FONTATT_SPACING) == 0) flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "sans")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon sans");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Helvetica");
        if ((flags & FONTATT_SPACING) == 0) flags |= FONTFLAG_PROPORTIONAL;
    }
    else if (!strcmp(family, "serif")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon serif");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Times");
        if ((flags & FONTATT_SPACING) == 0) flags |= FONTFLAG_PROPORTIONAL;
    }
    else
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)family);

    FcPatternAddDouble(p, FC_SIZE, size);

    if (flags & FONTFLAG_SANS)
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"sans");
    else if (flags & FONTFLAG_SERIF)
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"serif");

    if (flags & FONTFLAG_THIN)
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_THIN);
    else if (flags & FONTFLAG_LIGHT)
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_LIGHT);
    else if (flags & FONTFLAG_MEDIUM)
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_MEDIUM);
    else if (flags & FONTFLAG_DEMIBOLD)
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_DEMIBOLD);
    else if (flags & FONTFLAG_BOLD)
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_BOLD);

    if (flags & FONTFLAG_ITALIC)
        FcPatternAddInteger(p, FC_SLANT, FC_SLANT_ITALIC);
    else if (flags & FONTFLAG_OBLIQUE)
        FcPatternAddInteger(p, FC_SLANT, FC_SLANT_OBLIQUE);
    else if (flags & FONTFLAG_ROMAN)
        FcPatternAddInteger(p, FC_SLANT, FC_SLANT_ROMAN);

    if (flags & FONTFLAG_PROPORTIONAL)
        FcPatternAddInteger(p, FC_SPACING, FC_PROPORTIONAL);
    else if (flags & FONTFLAG_MONO)
        FcPatternAddInteger(p, FC_SPACING, FC_MONO);

    if (flags & FONTFLAG_CONDENSED)
        FcPatternAddInteger(p, FC_WIDTH, FC_WIDTH_CONDENSED);
    else if (flags & FONTFLAG_NARROW)
        FcPatternAddInteger(p, FC_WIDTH, FC_WIDTH_SEMICONDENSED);
    else if (flags & FONTFLAG_NORMAL)
        FcPatternAddInteger(p, FC_WIDTH, FC_WIDTH_NORMAL);
    else if (flags & FONTFLAG_WIDE)
        FcPatternAddInteger(p, FC_WIDTH, FC_WIDTH_SEMIEXPANDED);
    else if (flags & FONTFLAG_EXTENDED)
        FcPatternAddInteger(p, FC_WIDTH, FC_WIDTH_EXPANDED);

    free(res);
    res = (char *)FcNameUnparse(p);
    FcPatternDestroy(p);

    return res;
}

/*
 * load a font and return a font structure.
 */

wfp loadfont(wdp wd, char *s)
{
    wfp rv;
    int i;

    /*
     * Convert to a system font name (without the fc: prefix)
     */
    s = tofcpatternstr(s);
    if (!s)
        return 0;

    /*
     * see if the font is already loaded on this display
     */
    i = hasher(hashcstr(s), wd->fonts);
    for(rv = wd->fonts[i]; rv; rv = rv->next) {
        if (!strcmp(s, rv->name + 3))
            return rv;
    }

    /*
     * load a new font
     */
    rv = newfont(wd, s);
    if (!rv)
        return 0;

    /*
     * link the font into this display's fontlist
     */
    rv->next = wd->fonts[i];
    wd->fonts[i] = rv;

    return rv;
}

static wfp newfont(wdp wd, char *s)
{
    wfp rv;
    XGlyphInfo	extents; 

    rv = safe_zalloc(sizeof(struct _wfont));
    rv->fsp = XftFontOpenName(wd->display, DefaultScreen(wd->display), s);
    if (!rv->fsp){
        free(rv);
        return 0;
    }

    rv->name = safe_malloc(strlen(s) + 3 + 1);
    sprintf(rv->name, "fc:%s", s);

    /*
     * Xft seems to sometimes give too-small values in its font
     * ascent/descent fields; therefore calculate the GlyphInfo
     * for the first 256 chars and take the maximum ascent/descent
     * of the sample and the font's reported values.
     */
    XftTextExtents8 (wd->display,
                     rv->fsp,
                     (FcChar8 *)allchars,
                     256,
                     &extents);
    rv->ascent = Max(rv->fsp->ascent, extents.y);
    rv->descent = Max(rv->fsp->descent, extents.height - extents.y);
    rv->maxwidth = rv->fsp->max_advance_width;
    return rv;
}

/*
 * allocate a context, cloning attributes from an existing context
 */
static wcp clonecontext(wcp wc)
{
    wcp rv;
    GAlloc(rv, _wcontext);
    rv->display = wc->display;
    rv->dx = wc->dx;
    rv->dy = wc->dy;
    rv->leading = wc->leading;
    rv->clipx = wc->clipx;
    rv->clipy = wc->clipy;
    rv->clipw = wc->clipw;
    rv->cliph = wc->cliph;
    rv->fg = link_sharedcolor(wc->fg);
    rv->bg = link_sharedcolor(wc->bg);
    if (wc->pattern)
        rv->pattern = link_sharedpicture(wc->pattern);
    if (wc->mask)
        rv->mask = link_sharedpicture(wc->mask);
    rv->font = wc->font;
    rv->lineend = wc->lineend;
    rv->linejoin = wc->linejoin;
    rv->linewidth = wc->linewidth;
    rv->fillrule = wc->fillrule;
    rv->drawop = wc->drawop;
    return rv;
}

/*
 * free a window state
 */
static void freewindow(wsp ws)
{
    ws->refcount--;
    if(ws->refcount == 0) {
        if (ws->win)
            close_screen_win(ws);
        XFreePixmap(ws->display->display, ws->pix);
        XRenderFreePicture(ws->display->display, ws->ppic);
        free(ws->icondata);
        del_gc_global(&ws->listp);
        del_gc_global(&ws->windowlabel);
        if (ws->transientfor)
            freewindow(ws->transientfor);
        free(ws);
    }
}

/*
 * free a window context
 */
static void freecontext(wcp wc)
{
    wc->refcount--;
    if(wc->refcount == 0) {
        unlink_sharedcolor(wc->fg);
        unlink_sharedcolor(wc->bg);
        if (wc->pattern)
            unlink_sharedpicture(wc->pattern);
        if (wc->mask)
            unlink_sharedpicture(wc->mask);
        free(wc);
    }
}

int readimagefileimpl(char *filename, struct imgdata *imd) 
{
    return NoCvt;
}

int writeimagefileimpl(char *filename, struct imgdata *imd)
{
    return NoCvt;
}

int readimagedataimpl(dptr data, struct imgdata *imd)
{
    return NoCvt;
}

int settransientfor(wbp w, wbp other)
{
    wsp ws = w->window;
    if (ws->win) {
        LitWhy("Can't set transient_for on an open window");
        return Failed;
    }
    if (other) {
        if (w->window->display != other->window->display) {
            LitWhy("Can't set transient_for with windows on different displays");
            return Failed;
        }
        if (ws->transientfor)
            freewindow(ws->transientfor);
        ws->transientfor = linkwindow(other->window);
    } else {
        if (ws->transientfor)
            freewindow(ws->transientfor);
        ws->transientfor = 0;
    }
    return Succeeded;
}

static void set_X11ARGB32(struct imgdata *imd, int x, int y, int r, int g, int b, int a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    b = Mul16(b, a);
    g = Mul16(g, a);
    r = Mul16(r, a);
    *s++ = a / 256;
    *s++ = r / 256;
    *s++ = g / 256;
    *s++ = b / 256;
}
static void get_X11ARGB32(struct imgdata *imd, int x, int y, int *r, int *g, int *b, int *a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    *a = 257 * (*s++);
    *r = 257 * (*s++);
    *g = 257 * (*s++);
    *b = 257 * (*s++);
    if (*a > 0) {
        *b = Div16(*b, *a);
        *g = Div16(*g, *a);
        *r = Div16(*r, *a);
    }
}

static void set_X11BGRA32(struct imgdata *imd, int x, int y, int r, int g, int b, int a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    b = Mul16(b, a);
    g = Mul16(g, a);
    r = Mul16(r, a);
    *s++ = b / 256;
    *s++ = g / 256;
    *s++ = r / 256;
    *s++ = a / 256;
}

static void get_X11BGRA32(struct imgdata *imd, int x, int y, int *r, int *g, int *b, int *a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    *b = 257 * (*s++);
    *g = 257 * (*s++);
    *r = 257 * (*s++);
    *a = 257 * (*s++);
    if (*a > 0) {
        *b = Div16(*b, *a);
        *g = Div16(*g, *a);
        *r = Div16(*r, *a);
    }
}

struct imgdataformat imgdataformat_X11ARGB32 =   {set_X11ARGB32,get_X11ARGB32,0,0,getlength_32,8,24,0,"X11ARGB32"};
struct imgdataformat imgdataformat_X11BGRA32 =   {set_X11BGRA32,get_X11BGRA32,0,0,getlength_32,8,24,0,"X11BGRA32"};

void registerplatformimgdataformats()
{
    registerimgdataformat(&imgdataformat_X11ARGB32);
    registerimgdataformat(&imgdataformat_X11BGRA32);
}

enum EventType { CROSS = 0, TOP, BOTTOM };

struct segment
{
    double dx, dy, angle;
    XPointDouble p0, p1;
    struct segment *ps, *ns;
};

struct event
{
    int type;
    XPointDouble pt;
    struct segment *seg1, *seg2;
};

struct eventtree
{
    struct event *ev;
    struct eventtree *left, *right;
};

static struct segment *segs;
static struct eventtree *Q;
static struct segment **L;
static int Ln, Lmax;

static int segment_num(struct segment *seg)
{
    return 1 + (seg - segs);
}

#if 0
static void show_eventtree(struct eventtree *tree, int level)
{
    int i;
    struct event *ev;
    char *tn[] = {"CROSS", "TOP", "BOTTOM"};
    if (tree == NULL)
        return;
    show_eventtree(tree->right, level + 1);
    for (i = 0; i < level; ++i)
        printf("   ");
    ev = tree->ev;
    printf("Event type = %s  pt = %f, %f", tn[ev->type], ev->pt.x, ev->pt.y);
    printf("  seg1 = %d  ", segment_num(ev->seg1));
    if (ev->seg2)
        printf("  seg2 = %d\n", segment_num(ev->seg2));
    else
        printf("  seg2 = -\n");
    show_eventtree(tree->left, level + 1);
}
#endif    

static double segment_x_at(struct segment *seg, double y)
{
    if (y == seg->p0.y)
        return seg->p0.x;
    if (y == seg->p1.y)
        return seg->p1.x;
    return seg->p0.x + ((y - seg->p0.y) * seg->dx) / seg->dy;
}

static int double_cmp(double a, double b)
{
    return (a > b) - (a < b);
}

static int compare_points(XPointDouble *p, XPointDouble *q)
{
    int i;
    i = double_cmp(p->y, q->y);
    if (i == 0)
        i = double_cmp(p->x, q->x);
    return i;
}

static void eventtree_insert(struct eventtree **tree0, struct event *ev)
{
    struct eventtree *tree, *nt;
    tree = *tree0;
    if (tree) {
        int i;
        i = compare_points(&ev->pt, &tree->ev->pt);
        if (i < 0)
            eventtree_insert(&tree->left, ev);
        else if (i > 0)
            eventtree_insert(&tree->right, ev);
        else {
            nt = safe_malloc(sizeof(struct eventtree));
            nt->ev = ev;
            nt->left = tree->left;
            nt->right = NULL;
            tree->left = nt;
        }
    } else {
        tree = safe_malloc(sizeof(struct eventtree));
        tree->ev = ev;
        tree->left = tree->right = NULL;
        *tree0 = tree;
    }
}

static int eventtree_contains(struct eventtree *tree, struct event *ev)
{
    if (tree) {
        int i;
        i = compare_points(&ev->pt, &tree->ev->pt);
        if (i < 0)
            return eventtree_contains(tree->left, ev);
        else if (i > 0)
            return eventtree_contains(tree->right, ev);
        else do {   /* Entries with the same key are contiguous leftwards */
                if (ev->type == tree->ev->type &&
                    ev->seg1 == tree->ev->seg1 &&
                    ev->seg2 == tree->ev->seg2)
                {
                    return 1;
                }
                tree = tree->left;
            }
            while (tree && 
                   compare_points(&ev->pt, &tree->ev->pt) == 0);
    }
    return 0;
}

static struct event *eventtree_pop(struct eventtree **tree0)
{
    struct eventtree *tree;
    tree = *tree0;
    if (tree->left == NULL) {
        struct event *res;
        res = tree->ev;
        *tree0 = tree->right;
        free(tree);
        return res;
    } else
        return eventtree_pop(&tree->left);
}

static void show_L(void)
{
    int i;
    printf("L = [ ");
    for (i = 0; i < Ln; ++i)
        printf("%d ", segment_num(L[i]));
    printf("]\n");
}

static int compare_event_segment(struct event *ev, struct segment *seg)
{
    int i;
    double x, y;
    x = ev->pt.x;
    y = ev->pt.y;
    i = double_cmp(x, segment_x_at(seg, y));
    if (i == 0)
        i = double_cmp(seg->angle, ev->seg1->angle);
    return i;
}

static int segment_in_range(struct segment *s, XPointDouble *p)
{
    return ( (s->p0.y <= p->y && p->y <= s->p1.y ) || (s->p1.y <= p->y && p->y <= s->p0.y) ) &&
         ( (s->p0.x <= p->x && p->x <= s->p1.x) || (s->p1.x <= p->x && p->x <= s->p0.x) );
}

static int segment_intersect(XPointDouble *res, struct segment *a, struct segment *b)
{
    return intersect(res, &a->p0, &a->p1, &b->p0, &b->p1) &&
        segment_in_range(a, res) &&
        segment_in_range(b, res);
}

static void cross_check(double y, struct segment *a, struct segment *b)
{
    XPointDouble p;
    struct event *ev;

    if (a->ns == b || a->ps == b)
        return;
    if (a > b) {
        struct segment *t;
        t = a; a = b; b = t;
    }
    if (poly_debug)
        printf("Cross check y = %f segs = %d %d\n", y, segment_num(a), segment_num(b));

    if (segment_intersect(&p, a, b) && p.y > y) {
        if (poly_debug)
            printf("\tIntersection found at (%f, %f)\n", p.x, p.y);
        ev = safe_malloc(sizeof(struct event));
        ev->pt = p;
        ev->seg1 = a;
        ev->seg2 = b;
        ev->type = CROSS;
        if (eventtree_contains(Q, ev)) {
            if (poly_debug)
                printf("\tDuplicate Cross event, discarding this one\n");
            free(ev);
        } else
            eventtree_insert(&Q, ev);
    }
}

static void handle_event_CROSS(struct event *ev)
{
    int i, i1, i2;
    if (poly_debug)
        printf("CROSS Event (%f, %f) segs = %d %d\n", ev->pt.x, ev->pt.y, segment_num(ev->seg1), segment_num(ev->seg2));
    i1 = i2 = -1;
    for (i = 0; i < Ln; ++i) {
        if (L[i] == ev->seg1)
            i1 = i;
        else if (L[i] == ev->seg2)
            i2 = i;
    }
    if (i1 >= 0 && i2 >= 0) {
        struct segment *t;
        if (poly_debug)
            printf("\tFound segments at positions %d and %d respectively\n", i1, i2);
        t = L[i1]; L[i1] = L[i2]; L[i2] = t;
        if (i1 > 0)
            cross_check(ev->pt.y, L[i1 - 1], L[i1]);
        if (i1 + 1 < Ln)
            cross_check(ev->pt.y, L[i1 + 1], L[i1]);
        if (i2 > 0)
            cross_check(ev->pt.y, L[i2 - 1], L[i2]);
        if (i2 + 1 < Ln)
            cross_check(ev->pt.y, L[i2 + 1], L[i2]);
    } else {
        if (poly_debug)
            printf("\tFailed to find both segments\n");
    }
}

static int search_L(struct event *ev)
{
    int i, l, r, m;
    l = 0;
    r = Ln - 1;
    while (l <= r) {
        m = (l + r) / 2;
        i = compare_event_segment(ev, L[m]);
        if (i < 0)
            r = m - 1;
        else if (i > 0)
            l = m + 1;
        else
            return m;
    }
    return l;
}

static void handle_event_TOP(struct event *ev)
{
    int i, j;
    if (poly_debug)
        printf("TOP Event (%f, %f) seg = %d\n", ev->pt.x, ev->pt.y, segment_num(ev->seg1));
    if (Ln == Lmax) {
        if (poly_debug)
            printf("Too many segments in L\n");
        return;
    }

    i = search_L(ev);
    if (poly_debug)
        printf("\tInserting segment %d into L at position %d\n", segment_num(ev->seg1), i);
    for (j = Ln; j > i; --j)
        L[j] = L[j - 1];
    L[i] = ev->seg1;
    ++Ln;
    if (i > 0)
        cross_check(ev->pt.y, L[i - 1], L[i]);
    if (i + 1 < Ln)
        cross_check(ev->pt.y, L[i], L[i + 1]);
}

static void handle_event_BOTTOM(struct event *ev)
{
    int i, j;
    if (poly_debug)
        printf("BOTTOM Event (%f, %f) seg = %d\n", ev->pt.x, ev->pt.y, segment_num(ev->seg1));
    i = 0;
    while (i < Ln && L[i] != ev->seg1)
        ++i;
    if (i < Ln) {
        if (poly_debug)
            printf("\tDeleting segment %d from L in position %d\n", segment_num(ev->seg1), i);
        for (j = i; j < Ln -1; ++j)
            L[j] = L[j + 1];
        --Ln;
        if (i > 0 && i < Ln)
            cross_check(ev->pt.y, L[i - 1], L[i]);
    } else {
        if (poly_debug)
            printf("\tSegment not found in L\n");
    }
}

static void add_segment_events(struct segment *seg)
{
    struct event *ev1, *ev2;

    if (seg->dy == 0)
        return;

    ev1 = safe_malloc(sizeof(struct event));
    ev2 = safe_malloc(sizeof(struct event));

    ev1->pt = seg->p0;
    ev2->pt = seg->p1;
    ev1->seg1 = ev2->seg1 = seg;
    ev1->seg2 = ev2->seg2 = NULL;
    if (seg->dy > 0) {
        ev1->type = TOP;
        ev2->type = BOTTOM;
    } else {             /* seg->dy < 0 */
        ev1->type = BOTTOM;
        ev2->type = TOP;
    }

    eventtree_insert(&Q, ev1);
    eventtree_insert(&Q, ev2);
}

static void process_line(int rule, double y0, double y1)
{
    int i, fl;
    double x1, x2, x3, x4;
    struct segment *s0, *s1;
    if (poly_debug)
        printf("Process lines %f to %f\n", y0, y1);
    fl = 0;
    for (i = 1; i < Ln; ++i) {
        s0 = L[i - 1];
        s1 = L[i];
        x1 = segment_x_at(s0, y0);
        x2 = segment_x_at(s1, y0);
        x3 = segment_x_at(s0, y1);
        x4 = segment_x_at(s1, y1);
        if (s0->dy < 0)
            ++fl;
        else
            --fl;
        if ((rule & fl)) {
            if (poly_debug)
                printf("\tTrap top=%f (%f, %f)  bottom=%f (%f, %f)\n", y0, x1, x2, y1, x3, x4);
            add_trap(y0, x1, x2, y1, x3, x4);
        }
    }
}

static void mk_polygon(struct point *points, int npoints, int rule)
{
    int i, fl;
    double a, y0, y1;

    Q = NULL;
    L = safe_malloc(npoints * sizeof(struct segment *));
    Ln = 0;
    Lmax = npoints;
    segs = safe_malloc(npoints * sizeof(struct segment));

    for (i = 0; i < npoints; ++i) {
        if (i == 0) {
            segs[0].p0 = *(XPointDouble *)&points[npoints - 1];
            segs[0].ps = &segs[npoints - 1];
            segs[npoints - 1].ns = &segs[0];
        } else {
            segs[i].p0 = *(XPointDouble *)&points[i - 1];
            segs[i].ps = &segs[i - 1];
            segs[i - 1].ns = &segs[i];
        }
        segs[i].p1 = *(XPointDouble *)&points[i];
        segs[i].dy = segs[i].p1.y - segs[i].p0.y;
        segs[i].dx = segs[i].p1.x - segs[i].p0.x;
        a = atan2(segs[i].dy, segs[i].dx);
        if (a < 0)
            a += Pi;
        segs[i].angle = a;
        add_segment_events(&segs[i]);
    }

    fl = 0;
    y0 = 0;
    while (Q) {
        struct event *ev;
        ev = eventtree_pop(&Q);
        y1 = ev->pt.y;
        if (fl && y0 != y1)
            process_line(rule, y0, y1);
        switch (ev->type) {
            case CROSS:
                handle_event_CROSS(ev);
                break;
            case TOP:
                handle_event_TOP(ev);
                break;
            case BOTTOM:
                handle_event_BOTTOM(ev);
                break;
        }
        free(ev);
        y0 = y1;
        fl = 1;
        if (poly_debug)
            show_L();
    }

    free(L);
    free(segs);
}
