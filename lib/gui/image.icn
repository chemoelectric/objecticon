#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

import util, ipl.graphics(Zoom), graphics

#
# This class scales and displays an image.  The image source can
# be an image string, an external file, or another window, and
# can be changed at any time.
#
# @field image=string : see {set_image}
# @field data=string : see {set_data}
# @field file=string : see {set_file}
# @field cache=string : see {set_cache}
# @field window={Window} : see {set_window}
# @field scale_up=flag : see {set_scale_up}
# @field see also {Component}
#
class Image(Component)
   public 
      image_file, 
      image_data,
      image_str,
      image_window,
      image_cache,
      win,
      zoom_win,
      scale_up_flag,
      dont_close

   #
   # Set the name of the file from which to load the image;
   # re-display the image from the new file if appropriate.
   #
   public set_file(x)
      self.image_file := self.image_data := self.image_str := self.image_cache := self.image_window := &null
      if is_initialized() then {
         close_image()
         self.image_file := x
         load_image()
         self.invalidate()
      } else
         self.image_file := x
   end

   #
   # Set the raw image data (gif, jpeg etc) from which to load the image.
   #
   public set_data(x)
      self.image_file := self.image_data := self.image_str := self.image_cache := self.image_window := &null
      if is_initialized() then {
         close_image()
         self.image_data := x
         load_image()
         self.invalidate()
      } else
         self.image_data := x
   end

   #
   # Set an image in Icon image format.
   #
   public set_image(x)
      self.image_file := self.image_data := self.image_str := self.image_cache := self.image_window := &null
      if is_initialized() then {
         close_image()
         self.image_str := x
         load_image()
         self.invalidate()
      } else
         self.image_str := x
   end

   #
   # Set the name of a cache entry (either a file on the {ImageCache} path, or a named
   # image data id, set with {ImageCache.name_data}).
   #
   public set_cache(x)
      self.image_file := self.image_data := self.image_str := self.image_cache := self.image_window := &null
      if is_initialized() then {
         close_image()
         self.image_cache := x
         load_image()
         self.invalidate()
      } else
         self.image_cache := x
   end

   #
   # Set a window to use as the image source.  It will not be closed
   # by this Component.
   #
   public set_window(x)
      self.image_file := self.image_data := self.image_str := self.image_cache := self.image_window := &null
      if is_initialized() then {
         close_image()
         self.image_window := x
         load_image()
         self.invalidate()
      } else
         self.image_window := x
   end

   #
   # Blank the image
   #
   public clear_image()
      self.image_file := self.image_data := self.image_str := self.image_cache := self.image_window := &null
      if is_initialized() then {
         close_image()
         self.invalidate()
      }
   end

   public initially()
      cast(self,Component).initially()
      load_image()
   end

   public load_image()
      if \self.image_str then {
         # Note we need foreground too for shade & highlight chars in image_str
         if win := Window.open("fg=",self.cbwin.get_fg(),
                               "bg=",self.cbwin.get_bg(),
                               "width=", (0 < image_width(self.image_str)),
                               "height=", (0 < image_height(self.image_str)),
                               "canvas=hidden") then
            draw_image_string_ex(win, 0, 0, self.image_str)
      } else if \self.image_data then
         win := Window.open_image_data(self.image_data, self.cbwin.get_bg())
      else if \self.image_file then
         win := Window.open_image_file(self.image_file, self.cbwin.get_bg())
      else if \self.image_cache then {
         if win := ImageCache.get(self.image_cache, self.cbwin.get_bg()) then
            dont_close := 1
      } else if \self.image_window then {
         win := self.image_window
         dont_close := 1
      }
   end

   #
   # If set, then the image will be scaled up to fit in the space
   # specified by {set_size()}.  The image will not be distorted, 
   # but will be expanded to fill one of the dimensions depending 
   # on its shape.  If the image is bigger than the specified size 
   # then it will always be scaled down.
   #
   public set_scale_up(s)
      self.scale_up_flag := check_flag(s)
   end

   public close_image()
      if \win & /dont_close then {
         Gui.style.dispose(win)
         win.close()
      }
      (\zoom_win).close()
      dont_close := win := zoom_win := &null
   end

   public get_default_width()
      return (\win).get_width() + border.get_total_width()
   end

   public get_default_height()
      return (\win).get_height() + border.get_total_height()
   end

   public display()
      local ir, img_w, img_h,
         asp_r, asp_max, zoom_w, zoom_h, pt

      border.draw_rect(self.cbwin, self)

      \win | fail

      ir := border.get_inner_rect(self)

      img_w := win.get_width()
      img_h := win.get_height()

      if img_w = ir.w & img_h = ir.h then {
         win.copy_to(self.cbwin,,,,, 
                     self.x + border.get_l_inset(),
                     self.y + border.get_l_inset())
      } else {
         #
         # Scale the image to the desired size
         #

         asp_r := real(img_w) / real(img_h)
         asp_max := real(ir.w) / real(ir.h)

         if /self.scale_up_flag & (img_w <= ir.w) & (img_h <= ir.h) then {
            zoom_w := img_w
            zoom_h := img_h
         } else {
            if asp_r > asp_max then {
               zoom_w := ir.w
               zoom_h := integer(ir.w / asp_r)
            } else {
               zoom_w := integer(ir.h * asp_r)
               zoom_h := ir.h
            }
         }

         pt := ir.float(Size(zoom_w, zoom_h), border)

         zoom_w <:= 1
         zoom_h <:= 1

         if \zoom_win &
            zoom_win.get_width() = zoom_w & 
            zoom_win.get_height() = zoom_h then
               zoom_win.copy_to(self.cbwin, , , , , pt.x, pt.y)
         else {
            (\zoom_win).close()
            zoom_win := Window.open("size=" || zoom_w || "," || zoom_h, 
                              "canvas=hidden") | syserr("Couldn't open temp window")
            Zoom(win, zoom_win, 0, 0, img_w, img_h, 0, 0, zoom_w, zoom_h)
            zoom_win.copy_to(self.cbwin, , , , , pt.x, pt.y)
         }
      }
   end

   public set_one(f)
      case f.attr of {
         "image" : set_image(f.string_val())
         "data" : set_data(f.string_val())
         "file" : set_file(f.string_val())
         "cache" : set_cache(f.string_val())
         "window" : set_window(f.object_val(Window))
         "scale_up" : set_scale_up(f.flag_val())
         default: return cast(self,Component).set_one(f)
      }
      return
   end

   public finally()
      cast(self,Component).finally()
      close_image()
   end

   public new(a[])
      cast(self,Component).new()
      self.set_constraint("x_fill", &yes)
      self.set_constraint("y_fill", &yes)
      self.set_constraint("x_weight", 1.0)
      self.set_constraint("y_weight",  1.0)
      set_border(RaisedBorder())
      set_fields(a)
      return
   end
end



