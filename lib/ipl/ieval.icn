#
# Support procedures for ieval.
#

package ipl.ieval

import io, gui, lang, ipl.colmize, parser, eval, util, ipl.pdco, ipl.sort, ipl.termdialog, ipl.lists

$load IEVAL_LOGO "rpp.IEVAL_LOGO.png"

record Activation(coex, info)

class Ieval()
   private 
      input, output, error, env, ev, quiet_flag, par, 
      trace_flag, parse_flag, last_runerr, ee, hist_line, hlim,
      elim, llim, imports, files, opts, history

   # Avoid !env printing the internals of Ieval.
   private object_output(oo)
      oo.object_string(self)
   end

   private static map1(x)
      return map(x[1])
   end

   private show_env()
      local t, k
      t := []
      every k := key(env) do
         put(t, [k, to_string(env[k], 3)])
      print_table(isort(t, map1))
   end

   private list_syms()
      local s, e, w
      w := if is(output, TermDialog) then
         output.get_term_width()
      else
         LineEditorStream.get_console_size()[1]
      s := set()
      every e := lang.Prog.get_global_names() do
         if e ? ((not upto('.')) | (=!imports & ="." & (not upto('.')))) then
            insert(s, e)
      every output.write(colmize(isort(s, map), w))
   end

   private show_parse(x, level)
      /level := 0
      if is(x, Token) then
         output.write(repl("\t", level), x.s)
      else
         every show_parse(x.gen(), level + 1)
   end

   private flags_string(f)
      local s
      s := ""
      if iand(f, lang.Class.Method) ~= 0 then
         s ||:= "Method "
      if iand(f, lang.Class.Private) ~= 0 then
         s ||:= "Private "
      if iand(f, lang.Class.Public) ~= 0 then
         s ||:= "Public "
      if iand(f, lang.Class.Protected) ~= 0 then
         s ||:= "Protected "
      if iand(f, lang.Class.Package) ~= 0 then
         s ||:= "Package "
      if iand(f, lang.Class.Static) ~= 0 then
         s ||:= "Static "
      if iand(f, lang.Class.Const) ~= 0 then
         s ||:= "Const "
      if iand(f, lang.Class.Readable) ~= 0 then
         s ||:= "Readable "
      if iand(f, lang.Class.Defer) ~= 0 then
         s ||:= "Defer "
      if iand(f, lang.Class.Final) ~= 0 then
         s ||:= "Final "
      if iand(f, lang.Class.Special) ~= 0 then
         s ||:= "Special "
      s[-1] := ""
      return s
   end

   private comma_string(e)
      local s
      s := ""
      while s ||:= @e || ", "
      s[-2:0] := ""
      return s
   end

   private supers_string(c)
      return comma_string{lang.Class.get_name(lang.Class.get_supers(c))} 
   end

   private implements_string(c)
      return comma_string{lang.Class.get_name(lang.Class.get_implemented_classes(c))}
   end

   private fields_string(c)
      return comma_string{Constructor.get_field_names(c)}
   end

   private locn_string(l)
      return "at line " || l.line || " in " || l.file
   end

   private kind_string(f)
      return case f of {
         Proc.Procedure: "Procedure"
         Proc.Function: "Function"
         Proc.Keyword: "Keyword"
         Proc.Operator: "Operator"
         Proc.Internal: "Internal"
      }
   end

   private var_string(f)
      return case f of {
         Proc.Argument: "Argument"
         Proc.Dynamic: "Dynamic"
         Proc.Static: "Static"
      }
   end

   private args_string(f)
      local s
      s := Proc.get_n_arguments(f)
      if Proc.has_varargs(f) then
         s ||:= "[]"
      return s
   end

   private print_table(t)
      local w, widths, col, row
      widths := []
      every col := 1 to *t[1] - 1 do {
         w := 0
         every w <:= *(!t)[col]
         put(widths, w)
      }
      every row := !t do {
         every col := 1 to *t[1] - 1 do
            output.writes(left(row[col], 4 + widths[col]))
         output.write(row[-1])
      }
   end

   private dir(c)
      local f, t
      case type(c) of {
         "null": list_syms()
         "object"|"cast"|"class": {
            output.write(if iand(lang.Class.get_class_flags(c), lang.Class.Final) ~= 0 then "final class " else "class ",
                         lang.Class.get_name(c), "(", supers_string(c), ")")
            output.write("   ", locn_string(lang.Class.get_location(c))) 
            output.write("   implements ", implements_string(c))
            t := []
            every f := lang.Class.get_field_names(c) do
               put(t, [f, 
                       lang.Class.get_name(lang.Class.get_field_defining_class(c, f)), 
                       right(lang.Class.get_field_index(c, f), *lang.Class.get_n_fields(c)),
                       flags_string(lang.Class.get_field_flags(c, f))])
            print_table(isort(t, map1))
         }
         "procedure"|"methp": {
            output.write(kind_string(Proc.get_kind(c)), " ", Proc.get_name(c), "(", args_string(c), ")")
            output.write("   ", locn_string(Proc.get_location(c))) 
            output.write("   method of ", lang.Class.get_name(Proc.get_defining_class(c)))
            t := []
            every f := Proc.get_local_names(c) do
               put(t, [f,
                       var_string(Proc.get_local_kind(c, f))])
            print_table(t)
         }
         "record"|"constructor": {
            output.write("constructor ",
                         Constructor.get_name(c), "(", fields_string(c), ")")
            output.write("   ", locn_string(Constructor.get_location(c))) 
         }

         default: {
            to_stdout(c, 3)
            output.write()
         }
      }
   end

   private hist()
      local i, e
      is(input, TermDialog|LineEditorStream) | fail
      i := input.get_history_start_no()
      every e := !input.get_history() do {
         output.write(right(i, 4), "  ", e)
         i +:= 1
      }
   end

   private wglob()
      ee.set_write_globals(toggle_flag(ee.write_globals_flag))
      return ee.write_globals_flag
   end

   private static exit_repl(n)
      runerr("exit(" || n || ") invoked")
   end

   private set_elim(n)
      elim := (10 < n)
      return elim
   end

   private set_hlim(n)
      hlim := (10 < n)
      if is(input, TermDialog|LineEditorStream) then
         input.set_history_limit(hlim)
      return hlim
   end

   private set_llim(n)
      llim := (10 < n)
      if is(input, TermDialog) then
         input.set_log_limit(llim)
      return llim
   end

   private traceback()
      local act_chain, depth, fe2, LIMIT, ae, fe, ce
      
      # Produce similar output to:-
      #    Coexpression.traceback(\last_runerr, &yes)

      ce := \last_runerr | fail
      act_chain := []
      until (!act_chain).coex === ce do {
         push(act_chain, Activation(ce, Coexpression.get_stack_info(ce)))
         ce := Coexpression.get_activator(ce) | break
      }

      depth := 0
      every depth +:= *(!act_chain).info

      LIMIT := 100
      output.write("Traceback:")
      every ae := !act_chain do {
         if depth - LIMIT >= *ae.info then
            depth -:= *ae.info
         else {
            if ce := Coexpression.get_activator(ae.coex) then
               output.write("co-expression#", serial(ae.coex), " activated by co-expression#", serial(ce))
            else
               output.write("co-expression#", serial(ae.coex), "  (never activated)")
            if depth > LIMIT then {
               if depth = LIMIT + 1 then
                  depth := LIMIT
               else
                  output.write("   ... ", depth - LIMIT, " calls omitted")
            }
            fe2 := &null
            every fe := back(ae.info) do {
               if depth <= LIMIT then {
                  output.writes("   ", fe.proc, "(", list2str(fe.args), ")")
                  if \fe2 then
                     output.write(" from line ", fe2.line, " in ", Files.get_path(fe2.file).get(-1))
                  else
                     output.write()
               }
               depth -:= 1
               fe2 := fe
            }
            if \fe2 then
               output.write("   at line ", fe2.line, " in ", Files.get_path(fe2.file).get(-1))
         }
      }
   end

   private cmd(n)
      if is(input, TermDialog|LineEditorStream) then 
         hist_line := input.get_history_item(n)
   end

   public new(imports, files, opts)
      self.imports := imports
      self.files := files
      self.opts := opts

      par := Parser()
      env := table()
      ee := DefaultEvaluatorEnv(env)
      if \opts["wglob"] then
         ee.set_write_globals(&yes)
      ev := Evaluator().
         set_env(ee).
         set_imports(imports)

      env["env"] := create show_env()
      env["trace"] := create trace_flag := toggle_flag(trace_flag)
      env["parse"] := create parse_flag := toggle_flag(parse_flag)
      env["quiet"] := create quiet_flag := toggle_flag(quiet_flag)
      env["wglob"] := create wglob()
      env["dir"] := dir
      env["hist"] := create hist()
      env["elim"] := set_elim
      env["hlim"] := set_hlim
      env["llim"] := set_llim
      env["traceback"] := create traceback()
      env["cmd"] := cmd

      hlim := (10 < \opts["hlim"]) | 500
      llim := (10 < \opts["llim"]) | 600
      elim := (10 < \opts["elim"]) | 35

      return
   end

   public run()
      local hfile
      prelim()
      if \opts["s"] then
         do_stdin()
      else {
         hfile := Files.get_path(Files.get_home()).child(".ieval_history").str()
         history := decode(Files.file_to_string(hfile)) | []
         if \opts["g"] then
            do_gui()
         else
            do_line_editor()
         Files.string_to_file(hfile, encode(input.get_history())) | ewrite("History not saved: ", &why)
      }
      write("Ciao")
   end

   private prelim()
      local f, s, n
      f := Files.get_path(Files.get_home()).child(".ieval").str()
      if Files.access(f) then
         push(files, f)
      every f := !files do {
         s := Files.file_to_string(f) | stop("Couldn't load ", f, ": ", &why)
         n := par.parse_expression(s) | stop("Couldn't parse ", f,  ": ", &why)
         ev.set_node(n) | stop("Couldn't parse ", f,  ": ", &why) 
         ev.eval()
      }
   end

   private body(s)
      local n, i, v, tv, run

      run := create
         with_var{ with_var{ Safe{ev.eval()}, &trace, tv }, exit, exit_repl}

      if n := par.parse_expression(s, "UTF-8") then {
         if \parse_flag & s ~== "!parse" then
            show_parse(n)
         else {
            tv := if \trace_flag then -1 else 0
            if ev.set_node(n) then {
               if \quiet_flag then
                  !run
               else {
                  i := elim
                  every v := !run do {
                     i -:= 1
                     if i < 0 then {
                        output.write(".... (result sequence truncated)")
                        break
                     }
                     ObjectOutputStream(output).set_indent(3).show(v)
                     output.write()
                  }
               }
               if &errortext then {
                  if &errornumber then
                     error.write("Runtime error ", &errornumber, ": ", &errortext)
                  else
                     error.write("Runtime error: ", &errortext)
                  error.write("offending value: ", image(&errorvalue))
                  last_runerr := &errorcoexpr
                  errorclear()
               }
            } else
               error.write("Couldn't parse: ", &why)
         }
      } else
         error.write("Couldn't parse: ", &why)
   end

   private do_gui()
      local s, t, prompt

      input := TermDialog().
         set_label("ieval").
         set_icon(IEVAL_LOGO).
         set_history_limit(hlim).
         set_log_limit(llim).
         set_history(history)
      error := output := input
      s := ""
      prompt := "> "
      input.connect(create {
         t := input.line
         repeat {
            output.write(prompt, t)
            hist_line := &null
            s ||:= t
            if s[-1] == "\\" then {
               s[-1] := ""
               prompt := ">> "
               break
            }
            body(s)
            prompt := "> "
            s := ""
            t := \hist_line | break
         }
      }, Event.ACTION)
      input.show_modal()
   end

   private do_stdin()
      local s, t, prompt

      output := FileStream.stdout
      error := FileStream.stderr
      input := FileStream.stdin
      s := ""
      prompt := "> "
      repeat {
         if \hist_line then {
            write(prompt, hist_line)
            t := hist_line
            hist_line := &null
         } else {
            writes(prompt)
            t := input.read_line() | stop("Failed to read file: ", &why)
            if /t then break
         }
         s ||:= t
         if s[-1] == "\\" then {
            s[-1] := ""
            prompt := ">> "
            next
         }
         body(s)
         prompt := "> "
         s := ""
      }
   end

   private do_line_editor()
      local s, t, prompt

      output := FileStream.stdout
      error := FileStream.stderr
      input := LineEditorStream().
         set_history_limit(hlim).
         set_history(history) | stop("Failed to create LineEditorStream: ", &why)
      s := ""
      prompt := "> "
      repeat {
         if \hist_line then {
            write(prompt, hist_line)
            t := hist_line
            hist_line := &null
         } else {
            input.set_prompt(prompt)
            t := input.read_line() | stop("Failed to read file: ", &why)
            if /t then break
         }
         s ||:= t
         if s[-1] == "\\" then {
            s[-1] := ""
            prompt := ">> "
            next
         }
         body(s)
         prompt := "> "
         s := ""
      }
   end
end
