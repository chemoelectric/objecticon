#
# $Id$
#

package datastruct

import ipl.pdco(Seq), lang, util

#
# This is a common superclass for several table-like data structures.
#
abstract class Table(ObjectOutput, ObjectHash, ObjectEquals)
   public const def

   #
   # Insert a new entry.  Always succeeds and returns {self}.
   #
   public abstract insert(key, val)

   #
   # Return the value for the given key (as a variable) if it is in
   # the table, or fail if it is not present.
   #
   public abstract member(key)

   #
   # Delete the entry with the given key.  Fails if the key was not
   # present, otherwise succeeds and returns {self}.
   #
   public abstract delete(key)

   #
   # Return the value with the given key, or the default value if
   # the key is not present.  Equivalent to {.t[k]} for a table.
   #
   public get(key)
      return .member(key) | def
   end

   #
   # Like {member}, but if the key is not present a new entry is added
   # (with the default value).  In any case a variable for the new
   # entry is returned.
   #
   # @example
   # @  # Word counting
   # @  t := SortTable(0)
   # @  every w := words() do
   # @     t.add(w) +:= 1
   #
   public add(key)
      return member(key) | (insert(key, def) & member(key))
   end

   #
   # Return a sorted list of key-value pairs.
   #
   public sort()
      return sortf(entry_list(), 1)
   end

   #
   # Generate the keys (cf the builtin key() function.)
   #
   public abstract key()

   #
   # Generate alternating key/values (cf the builtin keyval() function.)
   #
   public keyval()
      local k
      every k := key() do
         suspend k | member(k)
   end

   #
   # Generate the keys (cf the builtin key() function.) in reverse
   # order.  Only implemented for tables which store their keys in
   # sorted order.
   #
   public defer back_key()

   #
   # Generate alternating key/values (cf the builtin keyval()
   # function.) in reverse order.  Only implemented for tables which
   # store their keys in sorted order.
   #
   public back_keyval()
      local k
      every k := back_key() do
         suspend k | member(k)
   end

   #
   # Return the rank of the given key, ie its order number in the
   # table; fails if there is no matching key in the table.  Only
   # implemented for tables which store their keys in sorted order.
   #
   public defer rank(key)

   #
   # Return the `i`th key, in order, in the table.  Fails if `i` is
   # out of range, using standard icon indexing semantics.  Only
   # implemented for tables which store their keys in sorted order.
   #
   public defer select(i)

   #
   # Generate the values (cf !t for a table).
   #
   public gen()
      suspend member(key())
   end

   #
   # Return the size of the table.
   #
   public abstract size()

   #
   # Clear the table of all elements. Always succeeds and returns {self}.
   #
   public abstract clear()

   #
   # Generate key-value pairs as a sequence of 2-element lists.  NB - for each
   # invocation, the same list is returned every time, with the values replaced.
   #
   public entries()
      local l, e
      l := []
      every e := keyval() do {
         put(l, e)
         if *l = 2 then {
            suspend l
            default.clear(l)
         }
      }
   end

   # Return a flat list, with alternating key-value entries.
   public flatten()
      local l
      l := []
      every put(l, keyval())
      return l
   end

   # Return an (unsorted) list of pairs of key-values.
   public entry_list()
      local l, e, r
      r := []
      l := []
      every e := keyval() do {
         put(l, e)
         if *l = 2 then {
            put(r, l)
            l := []
         }
      }
      return r
   end

   #
   # Custom equals mirrors the {equals()} behaviour for builtin tables.
   #
   private object_equals(other, seen)
      other.size() = self.size() | fail
      equals(other.def, self.def, seen) | fail
      return hash_and_check(other.entry_list(), self.entry_list(), seen)
   end

   #
   # Custom hash mirrors the {hash()} behaviour for builtin tables.
   #
   private object_hash(depth)
      local n
      n := size()
      if depth > 1 then {
         n +:= hash(def, depth - 1)
         every n +:= hash(key(), depth - 1)
      }
      return n
   end

   #
   # Output object
   #
   private object_output(oo)
      local pairs, e, sep
      pairs := sort()
      if oo.simple{!!pairs | def} then {
         oo.object_start(self)
         if \def then {
            oo.writes1("default=").
               traverse(def)
            sep := 1
         }
         every e := !pairs do {
            if \sep then
               oo.writes1(";")
            oo.traverse(e[1]).
               writes1("->").
               traverse(e[2])
            sep := 1
         }
         oo.object_end(self)
      } else {
         oo.nl().
            object_start(self).
            iplus()
         if \def then {
            oo.nl().
               writes1("default=").
               iplus().
               traverse(def).
               iminus()
         }
         every e := !pairs do {
            oo.nl().
               traverse(e[1]).
               writes1("->").
               iplus().
               traverse(e[2]).
               iminus()
         }
         oo.iminus().
            nl().
            object_end(self)
      }
   end

   protected init_entries(entries)
      if *entries % 2 ~= 0 then
          runerr(134)
      while *entries > 0 do
         insert(default.get(entries), default.get(entries))
   end
end

#
# A class to provide an unmodifiable view of another table.
#
class UnmodifiableTable(Table)
   private const t

   public defer insert(key, val)

   public member(key)
      return .t.member(key)
   end

   public defer delete(key)

   public sort()
      return t.sort()
   end

   public key()
      suspend t.key()
   end

   public keyval()
      suspend .t.keyval()
   end

   public back_key()
      suspend t.back_key()
   end

   public back_keyval()
      suspend .t.back_keyval()
   end

   public rank(key)
      return t.rank(key)
   end

   public select(i)
      return t.select(i)
   end

   public gen()
      suspend .t.gen()
   end

   public size()
      return t.size()
   end

   public defer clear()

   public new(t)
      self.t := t
      self.def := t.def
      return
   end
end

#
# A {Table} that ignores case in its keys.
#
class ClTable(Table)
   private 
      t

   public insert(key, val)
      default.insert(t, map(key), [key, val])
      return self
   end

   public add(key)
      local mkey, e
      mkey := map(key)
      (e := default.member(t, mkey)) | default.insert(t, mkey, e := [key, def])
      return e[2]
   end

   public member(key)
      return default.member(t, map(key))[2]
   end

   public delete(key)
      return default.delete(t, map(key)) & self
   end

   public sort()
      local l
      l := []
      every put(l, (!default.sort(t))[2])
      return l
   end

   public key()
      suspend .(!t)[1]
   end

   public keyval()
      local e
      every e := !t do
         suspend .e[1] | e[2]
   end

   public gen()
      suspend (!t)[2]
   end

   public clear()
      default.clear(t)
      return self
   end

   public size()
      return *t
   end

   #
   # Create a new instance.
   #
   # @param def the default value
   # @param entries initial key-value entries.
   #
   public new(def, entries[])
      self.def := def
      t := table(def)
      init_entries(entries)
      return
   end
end

package class SortTableNode()
   public key, val,
      l, r, is_red_flag, N

   public new(k, v)
      self.key := k
      self.val := v
      self.is_red_flag := &yes
      self.N := 1
      return
   end
end

#
# A {Table} which uses a red-black binary tree so that its members are always
# in sorted order.
#
class SortTable(Table)
   private root
   public const cmp

   public insert(key, val)
      root := insert1(root, key, val)
      root.is_red_flag := &no
      return self
   end

   private insert1(n, key, val)
      local i
      if /n then
         return SortTableNode(key, val)
      i := cmp(key, n.key)
      if i < 0 then
         n.l := insert1(n.l, key, val)
      else if i > 0 then
         n.r := insert1(n.r, key, val)
      else {
         n.val := val
         return n
      }
      
      if is_red(n.r) & not is_red(n.l) then
         n := rotate_left(n)
      if is_red(n.l) & is_red(n.l.l) then
         n := rotate_right(n)
      if is_red(n.l) & is_red(n.r) then
         flip_colors(n)
      
      n.N := size1(n.l) + size1(n.r) + 1

      return n
   end

   public member(key)
      local n, i
      n := root
      while \n do {
         i := cmp(key, n.key)
         if i = 0 then
            return n.val
         n := if i < 0 then
            n.l
         else
            n.r
      }
   end

   public delete(key)
      member(key) | fail
      if not(is_red(root.l | root.r)) then
         root.is_red_flag := &yes
      root := delete1(root, key)
      (\root).is_red_flag := &no
      return self
   end

   private delete1(n, key)
      local x
      if cmp(key, n.key) < 0 then {
         if not(is_red(n.l | n.l.l)) then
            n := move_red_left(n)
         n.l := delete1(n.l, key)
      } else {
         if is_red(n.l) then
            n := rotate_right(n)
         if cmp(key, n.key) = 0 & /n.r then
            return
         if not(is_red(n.r | n.r.l)) then
            n := move_red_right(n)
         if cmp(key, n.key) = 0 then {
            x := min1(n.r)
            n.key := x.key
            n.val := x.val
            n.r := delete_min1(n.r)
         } else
            n.r := delete1(n.r, key)
      }
      return balance(n)
   end

   private min1(n)
      while \n.l do
         n := n.l
      return n
   end

   private delete_min1(n)
      if /n.l then
         return
      if not(is_red(n.l | n.l.l)) then
         n := move_red_left(n)
      n.l := delete_min1(n.l)
      return balance(n)
   end

   private balance(n)
      if is_red(n.r) then
         n := rotate_left(n)
      if is_red(n.l) & is_red(n.l.l) then
         n := rotate_right(n)
      if is_red(n.l) & is_red(n.r) then
         flip_colors(n)
      n.N := size1(n.l) + size1(n.r) + 1
      return n
   end

   private rotate_right(n)
      local x
      x := n.l
      n.l := x.r
      x.r := n
      x.is_red_flag := x.r.is_red_flag
      x.r.is_red_flag := &yes
      x.N := n.N
      n.N := size1(n.l) + size1(n.r) + 1
      return x
   end

   private rotate_left(n)
      local x
      x := n.r
      n.r := x.l
      x.l := n
      x.is_red_flag := x.l.is_red_flag
      x.l.is_red_flag := &yes
      x.N := n.N
      n.N := size1(n.l) + size1(n.r) + 1
      return x
   end
   
   private move_red_left(n)
      flip_colors(n)
      if is_red(n.r.l) then {
         n.r := rotate_right(n.r)
         n := rotate_left(n)
      }
      return n
   end

   private move_red_right(n)
      flip_colors(n)
      if is_red(n.l.l) then
         n := rotate_right(n)
      return n
   end

   private flip_colors(n)
      n.is_red_flag := toggle_flag(n.is_red_flag)
      n.l.is_red_flag := toggle_flag(n.l.is_red_flag)
      n.r.is_red_flag := toggle_flag(n.r.is_red_flag)
      return self
   end

   private traverse(n)
      \n | fail
      traverse(n.l)
      coact(n)
      traverse(n.r)
   end

   private back_traverse(n)
      \n | fail
      back_traverse(n.r)
      coact(n)
      back_traverse(n.l)
   end

   private is_red(n)
      return \ (\n).is_red_flag
   end

   private size1(n)
      return if /n then 0 else n.N
   end

   public sort()
      local e, l
      l := []
      every e := Seq{traverse(root)} do
         put(l, [e.key, e.val])
      return l
   end

   public key()
      suspend .Seq{traverse(root)}.key
   end

   public keyval()
      local e
      every e := Seq{traverse(root)} do
         suspend .e.key | e.val
   end

   public back_key()
      suspend .Seq{back_traverse(root)}.key
   end

   public back_keyval()
      local e
      every e := Seq{back_traverse(root)} do
         suspend .e.key | e.val
   end

   public gen()
      suspend Seq{traverse(root)}.val
   end

   public clear()
      root := &null
      return self
   end

   public size()
      return size1(root)
   end

   public select(i)
      i := cvpos_item(i, size()) | fail
      return .select1(root, i - 1).key
   end

   public rank(k)
      return rank1(root, k) + 1
   end

   private select1(n, i)
      local t
      t := size1(n.l)
      return if t > i then
         select1(n.l, i)
      else if t < i then
         select1(n.r, i - t - 1)
      else
         n
   end
   
   private rank1(n, k)
      local t
      \n | fail
      t := cmp(k, n.key)
      return if t < 0 then
         rank1(n.l, k)
      else if t > 0 then 
         1 + size1(n.l) + rank1(n.r, k)
      else 
         size1(n.l)
   end

   #
   # Check the table for internal consistency.
   #
   public check()
      is_bst(root) | return error("Not in symmetric order")
      is_size_consistent(root)  | return error("Subtree counts not consistent")
      is_rank_consistent(root)  | return error("Ranks not consistent")
      is_23(root) | return error("Not a 2-3 tree")
      is_balanced() | return error("Not balanced")
      return self
   end

   private is_balanced()
      local b, n
      b := 0
      n := root
      while \n do {
         is_red(n) | (b +:= 1)
         n := n.l
      }
      return is_balanced1(root, b)
   end

   private is_balanced1(n, b)
      if /n then return b = 0
      is_red(n) | (b -:= 1)
      return is_balanced1(n.l, b) & is_balanced1(n.r, b)
   end

   private is_23(n)
      if /n then return
      if is_red(n.r) then fail
      if n ~=== root & is_red(n) & is_red(n.l) then fail
      return is_23(n.l) & is_23(n.r)
   end

   private is_bst(n, min, max)
      if /n then return
      if cmp(n.key, \min) <= 0 then fail
      if cmp(n.key, \max) >= 0 then fail
      return is_bst(n.l, min, n.key) & is_bst(n.r, n.key, max)
   end

   private is_size_consistent(n)
      if /n then return
      (n.N = size1(n.l) + size1(n.r) + 1) | fail
      return is_size_consistent(n.l) & is_size_consistent(n.r)
   end

   private is_rank_consistent()
      local i, k
      every i := 1 to size() do
         (i = rank(select(i))) | fail
      every k := key() do
         (cmp(k, select(rank(k))) = 0) | fail
      return
   end

   #
   # Create a new instance.
   #
   # @param def the default value
   # @param cmp a comparator function taking two arbitrary values and
   # @   returning {-1}, {0} or {+1} by way of comparison.  The default
   # @   value is {Internal.compare}.
   # @param entries initial key-value entries.
   #
   public new(def, cmp, entries[])
      self.def := def
      /cmp := Internal.compare
      self.cmp := cmp
      init_entries(entries)
      return
   end
end

#
# A {Table} which uses the {lang.equals} procedure for key comparison,
# rather than the builtin {===} operator.
#
class EqTable(Table)
   private t, sz

   public insert(key, val)
      local h, l, e, n
      h := hash(key)
      l := t[h]
      every e := !\l do {
         if equals(e[1], key) then {
            e[2] := val
            return self
         }
      }
      n := [key, val]
      if \l then
         put(l, n)
      else
         default.insert(t, h, [n])
      sz +:= 1
      return self
   end

   public add(key)
      local h, l, e, n
      h := hash(key)
      l := t[h]
      every e := !\l do {
         if equals(e[1], key) then
            return e[2]
      }
      n := [key, def]
      if \l then
         put(l, n)
      else
         default.insert(t, h, [n])
      sz +:= 1
      return n[2]
   end

   public member(key)
      local e
      every e := !\t[hash(key)] do {
         if equals(e[1], key) then
            return e[2]
      }
   end

   public delete(key)
      local h, l, e, i
      h := hash(key)
      l := t[h]
      i := 1
      every e := !\l do {
         if equals(e[1], key) then {
            default.delete(l, i)
            if *l = 0 then
               default.delete(t, h)
            sz -:= 1
            return self
         }
         i +:= 1
      }
   end

   public sort()
      local l
      l := []
      every put(l, copy(!!t))
      return default.sortf(l, 1)
   end

   public key()
      suspend .(!!t)[1]
   end

   public keyval()
      local e
      every e := !!t do
         suspend .e[1] | e[2]
   end

   public gen()
      suspend (!!t)[2]
   end

   public size()
      return .sz
   end

   public clear()
      default.clear(t)
      sz := 0
      return self
   end

   #
   # Create a new instance.
   #
   # @param def the default value
   # @param entries initial key-value entries.
   #
   public new(def, entries[])
      self.def := def
      t := table()
      sz := 0
      init_entries(entries)
      return
   end
end

#
# A {Table} which is just a wrapper around a builtin table.
#
class BuiltinTable(Table)
   private t

   public insert(key, val)
      default.insert(t, key, val)
      return self
   end

   public member(key)
      return default.member(t, key)
   end

   public delete(key)
      return default.delete(t, key) & self
   end

   public sort()
      return default.sort(t)
   end

   public key()
      suspend default.key(t)
   end

   public keyval()
      suspend default.keyval(t)
   end

   public gen()
      suspend !t
   end

   public clear()
      default.clear(t)
      return self
   end

   public size()
      return *t
   end

   #
   # Create a new instance.
   #
   # @param t the table to wrap; if omitted then a new table is
   # @     created.
   #
   public new(t)
      /t := table()
      self.t := t
      self.def := t[[]]
      return
   end
end

#
# A {Table} which uses weak references
#
class WeakrefTable(Table)
   private 
      t, sz, last_purge

   public insert(key, val)
      local h, l, e, n
      maybe_purge()
      h := Internal.hash(key)
      l := t[h]
      every e := !\l do {
         if weakrefval(e[1]) === key then {
            e[2] := val
            return self
         }
      }
      n := [weakref(key), val] | runerr("Type of key cannot be used with weakref")
      if \l then
         put(l, n)
      else
         default.insert(t, h, [n])
      sz +:= 1
      return self
   end

   public add(key)
      local h, l, e, n
      maybe_purge()
      h := Internal.hash(key)
      l := t[h]
      every e := !\l do {
         if weakrefval(e[1]) === key then
            return e[2]
      }
      n := [weakref(key), def] | runerr("Type of key cannot be used with weakref")
      if \l then
         put(l, n)
      else
         default.insert(t, h, [n])
      sz +:= 1
      return n[2]
   end

   public member(key)
      local e
      maybe_purge()
      every e := !\t[Internal.hash(key)] do {
         if weakrefval(e[1]) === key then
            return e[2]
      }
   end

   public delete(key)
      local h, l, e, i
      maybe_purge()
      h := Internal.hash(key)
      l := t[h]
      i := 1
      every e := !\l do {
         if weakrefval(e[1]) === key then {
            default.delete(l, i)
            if *l = 0 then
               default.delete(t, h)
            sz -:= 1
            return self
         }
         i +:= 1
      }
   end

   public sort()
      local e, x
      maybe_purge()
      x := table()
      every e := !!t do
         default.insert(x, weakrefval(e[1]), e[2])
      return default.sort(x)
   end

   public key()
      maybe_purge()
      suspend weakrefval((!!t)[1])
   end

   public keyval()
      local e
      maybe_purge()
      every e := !!t do
         suspend weakrefval(e[1]) | e[2]
   end

   public gen()
      maybe_purge()
      suspend (!!t)[2]
   end

   public clear()
      default.clear(t)
      sz := 0
      return self
   end

   public size()
      maybe_purge()
      return .sz
   end

   public maybe_purge()
      if last_purge ~=== Prog.get_global_collection_count() then {
         last_purge := Prog.get_global_collection_count()
         purge()
      }
   end

   private purge()
      local h, l, i
      every h := default.key(t) do {
         l := t[h]
         i := 1
         while i <= *l do {
            if weakrefval(l[i][1]) then
               i +:= 1
            else {
               default.delete(l, i)
               sz -:= 1
            }
         }
         if *l = 0 then
            default.delete(t, h)
      }
   end

   #
   # Create a new instance.
   #
   # @param def the default value
   # @param entries initial key-value entries.
   #
   public new(def, entries[])
      self.def := def
      self.t := table()
      self.sz := 0
      init_entries(entries)
      return
   end
end
