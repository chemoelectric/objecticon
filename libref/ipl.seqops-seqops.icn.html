<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>seqops.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     seqops.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures to manipulate T-sequences
<a name="6"/>#
<a name="7"/>#	Author:   Ralph E. Griswold
<a name="8"/>#
<a name="9"/>#	Date:     June 11, 2001
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#  This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#  These procedures perform operations related to T-Sequences and to
<a name="18"/>#  analyze T-Sequences.
<a name="19"/>#
<a name="20"/>############################################################################
<a name="21"/>#
<a name="22"/>#  Requires:  Courage.
<a name="23"/>#
<a name="24"/>############################################################################
<a name="25"/>#
<a name="26"/>#   copyl(xargs[])	 copy list of lists
<a name="27"/>#   eval_tree(n)	 evaluate expression tree
<a name="28"/>#   expression_tree(n)	 create expression tree
<a name="29"/>#   fragment(s, i, p, arg)
<a name="30"/>#
<a name="31"/>#   get_analysis(s)	 analyze sequence
<a name="32"/>#   get_scollate(s)	 analyze for collation
<a name="33"/>#   get_splace(s)	 analyze for motif along a path
<a name="34"/>#   get_srepeat(s)	 analyze for repeat
<a name="35"/>#   get_srun(s)		 analyze for run
<a name="36"/>#   get_sruns(s)	 analyze for simple runs
<a name="37"/>#   is_scompact(x)	 test sequence for compactness
<a name="38"/>#   pimage(x)
<a name="39"/>#   remod(s, p)
<a name="40"/>#   sanalout()		 output analysis
<a name="41"/>#   sanalysis(x)	 over-all analysis
<a name="42"/>#   sbinop(op, xargs[])	 binary operation on terms
<a name="43"/>#   sbound(xargs[])	 compute sequence upper bound  FIX!
<a name="44"/>#   scollate(xargs[])	 sequence collation
<a name="45"/>#   scompress(xargs[])	 compact sequence
<a name="46"/>#   sconcat(xargs[])	 concatenate sequences
<a name="47"/>#   scpal(xargs[])	 closed sequence palindrome
<a name="48"/>#   sdecimate(xargs[])	 decimate sequence
<a name="49"/>#   sdecollate(order, x) decollate sequence
<a name="50"/>#   sdelta(x)		 get delta sequence
<a name="51"/>#   sdirection(x)	 "direction" of delta(x)
<a name="52"/>#   sequiv(x1, x2)	 test sequence equivalence
<a name="53"/>#   sextend(xargs[])	 extend sequence
<a name="54"/>#   sflatten(x)		 flatten nested sequence
<a name="55"/>#   sground(s, i)	 ground sequence to i
<a name="56"/>#   shaft_period(x1, x2) shaft period
<a name="57"/>#   simage(x, limit)	 string image of sequence
<a name="58"/>#   sinit()		 initialize sequence operations
<a name="59"/>#   slayer(xargs[])	 layer sequences
<a name="60"/>#   slength(x)		 compute sequence length
<a name="61"/>#   slocate(xargs[])	 sequences of first positions of terms
<a name="62"/>#   smap(xargs[])	 map terms in sequence
<a name="63"/>#   smin(xargs[])	 compute sequence lower bound	FIX
<a name="64"/>#   smissing(x)		 missing terms in sequence  BOGUS??
<a name="65"/>#   smod(xargs[])	 modular reduction
<a name="66"/>#   smutate(xargs[])	 mutation
<a name="67"/>#   snormal(x)		 normalize sequence
<a name="68"/>#   sopal(xargs[])	 create open sequence palindrome
<a name="69"/>#   sorder(x)		 positions of first occurrence
<a name="70"/>#   sparity(xargs[])	 adjust parity
<a name="71"/>#   speriod(s)		 sequence period
<a name="72"/>#   splace(xargs[])	 place motif along a path
<a name="73"/>#   splaceg(xargs[])	 generalized motifs along a path
<a name="74"/>#   spositions(x1, x2)	 shaft positions
<a name="75"/>#   spromote(x)		 promote term to sequence
<a name="76"/>#   srandom(x)		 random selection
<a name="77"/>#   sreflecth(xargs[])	 reflect sequence horizontally
<a name="78"/>#   sreflectr(xargs[])
<a name="79"/>#   sreflectv(xargs[])	 reflect sequence vertically
<a name="80"/>#   sremdupl(xargs[])	 remove duplicate adjacent terms
<a name="81"/>#   srepeat(xargs[])	 repeat sequence
<a name="82"/>#   srepl(xargs[])	 replicate sequence terms
<a name="83"/>#   srotatev(xargs[])	 rotate sequence vertically
<a name="84"/>#   srun(xargs[])	 create connected run
<a name="85"/>#   sruns(xargs[])	 create simple runs
<a name="86"/>#   sscale(xargs[])	 scale terms in sequence
<a name="87"/>#   sscollate(xargs[])	 collate entire sequences
<a name="88"/>#   sselect(xargs[])	 select terms from sequence
<a name="89"/>#   sshift(x, i)	 shift terms sequence
<a name="90"/>#   sunmod(x)		 modular expansion
<a name="91"/>#   sunop(op, xargs[])	 unary operation on terms
<a name="92"/>#   walk_tree(n, tree_list, tree_ptrs, depth)
<a name="93"/>#			 walk expression tree
<a name="94"/>#
<a name="95"/>############################################################################
<a name="96"/>#
<a name="97"/>#  Links:  factors, numbers
<a name="98"/>#
<a name="99"/>############################################################################
<a name="100"/>
<a name="101"/>package ipl.seqops
<a name="102"/>
<a name="103"/>import
<a name="104"/>   io(write),
<a name="105"/>   util(need_callable),
<a name="106"/>   ipl.factors(divisors),
<a name="107"/>   ipl.numbers(mod1),
<a name="108"/>   ipl.sets(elementset)
<a name="109"/>
<a name="110"/>global expressions
<a name="111"/>global node_gen
<a name="112"/>global saltparity
<a name="113"/>global scompact
<a name="114"/>global sfliph
<a name="115"/>global sflipv
<a name="116"/>global sflipr
<a name="117"/>global sflipl
<a name="118"/>
<a name="119"/>record node(name, seqlist)
<a name="120"/>
<a name="121"/>$define MaxTerms 300
<a name="122"/>
<a name="123"/># copy list of lists
<a name="124"/>procedure copyl(xargs[])		
<a name="125"/>   local new_xargs
<a name="126"/>
<a name="127"/>   new_xargs := []
<a name="128"/>
<a name="129"/>   every put(new_xargs, copy(spromote(!xargs)))
<a name="130"/>
<a name="131"/>   return new_xargs
<a name="132"/>
<a name="133"/>end
<a name="134"/>
<a name="135"/>procedure eval_tree(n)
<a name="136"/>   local i
<a name="137"/>
<a name="138"/>   n := integer(n)
<a name="139"/>
<a name="140"/>   is(n, node) | return n
<a name="141"/>
<a name="142"/>   every i := 1 to *n.seqlist do
<a name="143"/>      n.seqlist[i] := eval_tree(n.seqlist[i])
<a name="144"/>
<a name="145"/>   return n.name ! n.seqlist
<a name="146"/>
<a name="147"/>end
<a name="148"/>
<a name="149"/>procedure expression_tree(n)
<a name="150"/>   local result
<a name="151"/>
<a name="152"/>   n := integer(n)
<a name="153"/>
<a name="154"/>   case type(n) of {
<a name="155"/>      "list" | "integer"  :  return "[" || simage(n, MaxTerms) || "]"
<a name="156"/>      "string"            :  return n
<a name="157"/>      }
<a name="158"/>
<a name="159"/>   result :=  n.name || "("
<a name="160"/>
<a name="161"/>   every result ||:= expression_tree(!n.seqlist) || ","
<a name="162"/>
<a name="163"/>   return result[1:-1] || ")"
<a name="164"/>
<a name="165"/>end
<a name="166"/>
<a name="167"/>procedure fragment(s, i, p, arg)
<a name="168"/>   local results, j, k
<a name="169"/>
<a name="170"/>   if *s &lt;= i then return s
<a name="171"/>
<a name="172"/>   /p := 1
<a name="173"/>
<a name="174"/>   results := list(i)
<a name="175"/>
<a name="176"/>   every !results := []
<a name="177"/>
<a name="178"/>   k := 0
<a name="179"/>
<a name="180"/>   every j := 1 to i do
<a name="181"/>      every 1 to  *s / i do
<a name="182"/>         put(results[j], s[k +:= 1]) | break break
<a name="183"/>
<a name="184"/>   every j := 1 to i do
<a name="185"/>      results[j] := p(results[j], arg)
<a name="186"/>
<a name="187"/>   every j := 1 to i do
<a name="188"/>      results[j] := fragment(results[j], i, p, arg)
<a name="189"/>
<a name="190"/>   return results
<a name="191"/>
<a name="192"/>end
<a name="193"/>
<a name="194"/>$define MinLength 5	# minimum length for attempting analysis
<a name="195"/>
<a name="196"/>procedure get_analysis(seq)
<a name="197"/>   local expression
<a name="198"/>
<a name="199"/>   if *seq &lt; MinLength then return simageb(seq)
<a name="200"/>
<a name="201"/>   expression := (
<a name="202"/>      get_scollate(seq) |
<a name="203"/>      get_srepeat(seq) |
<a name="204"/>      remod(seq, get_srun) |	# before sruns(), which would subsume it
<a name="205"/>      remod(seq, get_sruns) |
<a name="206"/>      get_splace(seq) |		# would subsume some runs
<a name="207"/>      simageb(seq)
<a name="208"/>      )
<a name="209"/>
<a name="210"/>   return expression
<a name="211"/>
<a name="212"/>end
<a name="213"/>
<a name="214"/># find collation in sequence
<a name="215"/>procedure get_scollate(seq)		
<a name="216"/>   local bound, deltas, i, j, poses, positions, oper, seqs
<a name="217"/>   local   k, count, oseq, m
<a name="218"/>
<a name="219"/>   bound := (sbound ! seq)
<a name="220"/>
<a name="221"/>   speriod(seq) | fail		# only handle periodic case
<a name="222"/>
<a name="223"/>   deltas := table()
<a name="224"/>   positions := table()
<a name="225"/>
<a name="226"/>   every  i := 1 to bound do {
<a name="227"/>      poses := spositions(seq, i)
<a name="228"/>      positions[i] := poses
<a name="229"/>      j := sconstant(sdelta(poses)) | fail	# CONTRADICTION
<a name="230"/>      /deltas[j] := []
<a name="231"/>      put(deltas[j], i) 
<a name="232"/>      }
<a name="233"/>
<a name="234"/>   oseq := list(*seq, 1)		# decollation order sequence
<a name="235"/>
<a name="236"/>   count := 0
<a name="237"/>
<a name="238"/>   every k := key(deltas) do {
<a name="239"/>      count +:= 1
<a name="240"/>      every j := !deltas[k] do
<a name="241"/>         every m := !positions[j] do
<a name="242"/>            oseq[m] := count
<a name="243"/>      }
<a name="244"/>
<a name="245"/>   if *elementset(oseq) &lt; 2 then fail		# not enough sequences
<a name="246"/>
<a name="247"/>#  oseq := srun([1, get(facts)]) | fail
<a name="248"/>
<a name="249"/>   seqs := sdecollate(oseq, seq) | fail
<a name="250"/>
<a name="251"/>   oper := "scollate(" || (simageb(oseq[1+:speriod(oseq)]) |
<a name="252"/>      get_analysis(oseq))
<a name="253"/>
<a name="254"/>   every oper ||:= ", " || get_analysis(!seqs)
<a name="255"/>
<a name="256"/>   return oper || ")"
<a name="257"/>
<a name="258"/>end
<a name="259"/>
<a name="260"/># find motif along a path in sequence
<a name="261"/>procedure get_splace(seq)		
<a name="262"/>   local i, j, motif,  path
<a name="263"/>
<a name="264"/>   if i := sconstant(seq) then return "srepeat(" || i || "," || *seq || ")"
<a name="265"/>
<a name="266"/>   every i := divisors(*seq) do {
<a name="267"/>      motif := seq[1+:i]
<a name="268"/>      every j := i + 1 to *seq by i do
<a name="269"/>         unless sequiv(motif, sground(seq[j+:i], seq[1])) then break next
<a name="270"/>      path := []
<a name="271"/>      every put(path, seq[1 to *seq by i])
<a name="272"/>      return "splace(" || get_analysis(motif) || ", " || get_analysis(path) || ")"
<a name="273"/>      }
<a name="274"/>
<a name="275"/>   fail
<a name="276"/>
<a name="277"/>end
<a name="278"/>
<a name="279"/># find repeat in sequence
<a name="280"/>procedure get_srepeat(seq)		
<a name="281"/>   local i
<a name="282"/>
<a name="283"/>   i := speriod(seq) | fail
<a name="284"/>   return "srepeat(" || get_analysis(seq[1+:i]) || ", " || (*seq / i) || ")"
<a name="285"/>
<a name="286"/>end
<a name="287"/>
<a name="288"/>procedure get_srun(seq)
<a name="289"/>   local i, j, new_seq, dir
<a name="290"/>
<a name="291"/>   seq := copy(seq)
<a name="292"/>
<a name="293"/>   i := get(seq)
<a name="294"/>   j := get(seq)
<a name="295"/>
<a name="296"/>   if j = i - 1 then dir := -1		# down going
<a name="297"/>   else if j = i + 1 then dir := 1			# upgoing
<a name="298"/>   else fail
<a name="299"/>
<a name="300"/>   new_seq := [i]
<a name="301"/>
<a name="302"/>   while i := get(seq) do {
<a name="303"/>      if i = j + 1 then {
<a name="304"/>         if dir = -1 then put(new_seq, j)
<a name="305"/>         dir := 1
<a name="306"/>         }
<a name="307"/>      else if i =  j - 1 then {
<a name="308"/>         if dir = 1 then put(new_seq, j)
<a name="309"/>         dir := -1
<a name="310"/>         }
<a name="311"/>      else {
<a name="312"/>         put(new_seq, j)
<a name="313"/>         push(seq, i)		# put back non-continuing value
<a name="314"/>         break
<a name="315"/>         }
<a name="316"/>      j := i
<a name="317"/>      }
<a name="318"/>
<a name="319"/>   if *seq ~= 0 then fail
<a name="320"/>
<a name="321"/>   put(new_seq, j)
<a name="322"/>
<a name="323"/>   return "srun(" || get_analysis(new_seq) || ")"
<a name="324"/>
<a name="325"/>end
<a name="326"/>
<a name="327"/>procedure get_sruns(seq)
<a name="328"/>   local i, j, seq1, seq2, dir
<a name="329"/>
<a name="330"/>   seq1 := []
<a name="331"/>   seq2 := []
<a name="332"/>
<a name="333"/>   repeat {
<a name="334"/>      unless i := get(seq) then {
<a name="335"/>         put(seq2, j)
<a name="336"/>         break					# end of road
<a name="337"/>         }
<a name="338"/>      j := get(seq) | fail			# isolated end point
<a name="339"/>      if j = i - 1 then dir := -1		# down going
<a name="340"/>      else if j = i + 1 then dir := 1		# up going
<a name="341"/>      else fail
<a name="342"/>      put(seq1, i)				# beginning point
<a name="343"/>      while i := get(seq) do {
<a name="344"/>         if i = j + dir then {
<a name="345"/>            j := i
<a name="346"/>            next
<a name="347"/>            }
<a name="348"/>         else {
<a name="349"/>            push(seq, i)			# put back next value
<a name="350"/>            put(seq2, j)
<a name="351"/>            break
<a name="352"/>            }
<a name="353"/>         }
<a name="354"/>      }
<a name="355"/>
<a name="356"/>   return "sruns(" || get_analysis(seq1) || ", " || get_analysis(seq2) || ")"
<a name="357"/>
<a name="358"/>end
<a name="359"/>
<a name="360"/># test sequence for compactness
<a name="361"/>procedure is_scompact(x)		
<a name="362"/>   local bound
<a name="363"/>
<a name="364"/>   x := spromote(x)
<a name="365"/>
<a name="366"/>   bound := sbound ! x
<a name="367"/>
<a name="368"/>   if bound = *elementset(x) then return bound
<a name="369"/>   else fail
<a name="370"/>
<a name="371"/>end
<a name="372"/>
<a name="373"/># DOES THIS BELONG HERE?
<a name="374"/>procedure pimage(s)			
<a name="375"/>   local result, x
<a name="376"/>
<a name="377"/>   result := ""
<a name="378"/>
<a name="379"/>   every x := !s do {
<a name="380"/>      if integer(x) then result ||:= x else
<a name="381"/>         result ||:= pimage(x)
<a name="382"/>      result ||:= ","
<a name="383"/>      }
<a name="384"/>
<a name="385"/>   return "[" || result[1:-1] || "]"
<a name="386"/>
<a name="387"/>end
<a name="388"/>
<a name="389"/># handle modulus
<a name="390"/>procedure remod(seq, p)			
<a name="391"/>   local nseq, bound
<a name="392"/>
<a name="393"/>   nseq := sunmod(seq)
<a name="394"/>
<a name="395"/>   if (sbound ! nseq) &gt; (bound := sbound ! seq) then
<a name="396"/>      return "smod(" || p(nseq) || ", " || bound || ")"
<a name="397"/>   else return p(copy(seq))
<a name="398"/>
<a name="399"/>end
<a name="400"/>
<a name="401"/>procedure sanalout()
<a name="402"/>   local expression, var
<a name="403"/>
<a name="404"/>   write("link seqops")
<a name="405"/>   write("procedure main()")
<a name="406"/>
<a name="407"/>   expressions := sort(expressions, 4)
<a name="408"/>
<a name="409"/>   while expression := get(expressions) do
<a name="410"/>      write(var := get(expressions), " := ", expression)
<a name="411"/>
<a name="412"/>   write("every write(!", var, ")")
<a name="413"/>
<a name="414"/>   write("end")
<a name="415"/>
<a name="416"/>   expressions := table()
<a name="417"/>
<a name="418"/>   return
<a name="419"/>
<a name="420"/>end
<a name="421"/>
<a name="422"/>procedure sanalysis(x)
<a name="423"/>
<a name="424"/>#  sanalyze(x)
<a name="425"/>
<a name="426"/>   sanalout()
<a name="427"/>
<a name="428"/>   return
<a name="429"/>
<a name="430"/>end
<a name="431"/>
<a name="432"/># binary operation on terms
<a name="433"/>procedure sbinop(op, xargs[])		
<a name="434"/>   local lseq, i, x1, x2
<a name="435"/>
<a name="436"/>   x1 := spromote(xargs[1])
<a name="437"/>   x2 := spromote(xargs[2])
<a name="438"/>
<a name="439"/>   op := need_callable(op, 2)
<a name="440"/>
<a name="441"/>   lseq := []
<a name="442"/>
<a name="443"/>   every i := 1 to smin(*x1, *x2) do
<a name="444"/>      put(lseq, op(x1[i], x2[i]))
<a name="445"/>
<a name="446"/>   return lseq
<a name="447"/>
<a name="448"/>end
<a name="449"/>
<a name="450"/># compute sequence upper bound  FIX!
<a name="451"/>procedure sbound(xargs[])		
<a name="452"/>
<a name="453"/>   return sort(xargs)[-1]
<a name="454"/>
<a name="455"/>end
<a name="456"/>
<a name="457"/># sequence term collation
<a name="458"/>procedure scollate(xargs[])		
<a name="459"/>   local lseq, i, order
<a name="460"/>
<a name="461"/>   if \node_gen then return node("scollate", xargs)
<a name="462"/>
<a name="463"/>   order := get(xargs)
<a name="464"/>
<a name="465"/>   /order := srun(1, *xargs)
<a name="466"/>
<a name="467"/>   xargs := copyl ! xargs
<a name="468"/>
<a name="469"/>   lseq := []
<a name="470"/>
<a name="471"/>   while i := get(order) do {
<a name="472"/>      put(order, i)
<a name="473"/>      put(lseq, get(xargs[i])) | break
<a name="474"/>      }
<a name="475"/>
<a name="476"/>   put(lseq, get(xargs[get(order)]))		# ?????
<a name="477"/>
<a name="478"/>   return lseq
<a name="479"/>
<a name="480"/>end
<a name="481"/>
<a name="482"/># compact sequence
<a name="483"/>procedure scompress(xargs[])		
<a name="484"/>   local unique, target, x
<a name="485"/>
<a name="486"/>   if \node_gen then return node("compress", xargs)
<a name="487"/>
<a name="488"/>   x := spromote(xargs[1])
<a name="489"/>
<a name="490"/>   unique := elementset(x)
<a name="491"/>
<a name="492"/>   target := []
<a name="493"/>
<a name="494"/>   every put(target, 1 to *unique)
<a name="495"/>
<a name="496"/>   return smap(x, sort(unique), target)
<a name="497"/>
<a name="498"/>end
<a name="499"/>
<a name="500"/># concatenate sequences
<a name="501"/>procedure sconcat(xargs[])		
<a name="502"/>   local lseq
<a name="503"/>
<a name="504"/>   if \node_gen then return node("sconcat", xargs)
<a name="505"/>
<a name="506"/>   lseq := []
<a name="507"/>
<a name="508"/>   every lseq |||:= spromote(!xargs)
<a name="509"/>
<a name="510"/>   return lseq
<a name="511"/>
<a name="512"/>end
<a name="513"/>
<a name="514"/># test for constant sequence
<a name="515"/>procedure sconstant(seq)		
<a name="516"/>
<a name="517"/>   if *elementset(seq) = 1 then return !seq
<a name="518"/>   else fail
<a name="519"/>
<a name="520"/>end
<a name="521"/>
<a name="522"/># closed sequence palindrome
<a name="523"/>procedure scpal(xargs[])		
<a name="524"/>   local lseq, x1, x2, i
<a name="525"/>
<a name="526"/>   if \node_gen then return node("scpal", xargs)
<a name="527"/>
<a name="528"/>   x1 := spromote(xargs[1])
<a name="529"/>   x2 := spromote(xargs[2]) | [1]
<a name="530"/>
<a name="531"/>   i := 0
<a name="532"/>
<a name="533"/>   every i +:= !x2
<a name="534"/>
<a name="535"/>   lseq := srepeat(sopal(x1), i)
<a name="536"/>
<a name="537"/>   put(lseq, lseq[1])
<a name="538"/>
<a name="539"/>   return lseq
<a name="540"/>
<a name="541"/>end
<a name="542"/>
<a name="543"/># decimate sequence
<a name="544"/>procedure sdecimate(xargs[])		
<a name="545"/>   local lseq, j, k, x1, x2
<a name="546"/>
<a name="547"/>   x1 := spromote(xargs[1])
<a name="548"/>   x2 := sort(spromote(xargs[2]))
<a name="549"/>
<a name="550"/>   lseq := []
<a name="551"/>
<a name="552"/>   k := 1
<a name="553"/>
<a name="554"/>   while j := get(x2) do {
<a name="555"/>      every put(lseq, x1[k to j - 1])
<a name="556"/>      k := j + 1
<a name="557"/>      }
<a name="558"/>
<a name="559"/>   every put(lseq, x1[j + 1 to *x1])
<a name="560"/>
<a name="561"/>   return lseq
<a name="562"/>
<a name="563"/>end
<a name="564"/>
<a name="565"/>
<a name="566"/># sequence decollation
<a name="567"/>procedure sdecollate(order, x)		
<a name="568"/>   local lseq, i, j
<a name="569"/>
<a name="570"/>   x := spromote(x)
<a name="571"/>
<a name="572"/>   if *x = 0 then fail
<a name="573"/>
<a name="574"/>   order := copy(order)
<a name="575"/>
<a name="576"/>   lseq := list(sbound ! order)		# list of lists to return
<a name="577"/>
<a name="578"/>   every !lseq := []			# initially empty
<a name="579"/>
<a name="580"/>   every j := !x do {
<a name="581"/>      i := get(order)	| fail
<a name="582"/>      put(order, i)
<a name="583"/>      put(lseq[i], j)
<a name="584"/>      }
<a name="585"/>
<a name="586"/>   return lseq
<a name="587"/>
<a name="588"/>end
<a name="589"/>
<a name="590"/># sequence delta
<a name="591"/>procedure sdelta(seq)			
<a name="592"/>   local i, lseq, j
<a name="593"/>
<a name="594"/>   if *seq &lt; 2 then fail
<a name="595"/>
<a name="596"/>   seq := copy(seq)
<a name="597"/>
<a name="598"/>   i := get(seq)
<a name="599"/>
<a name="600"/>   lseq := []
<a name="601"/>
<a name="602"/>   while j := get(seq) do {
<a name="603"/>      put(lseq, j - i)
<a name="604"/>      i := j
<a name="605"/>      }
<a name="606"/>
<a name="607"/>   return lseq
<a name="608"/>
<a name="609"/>end
<a name="610"/>
<a name="611"/># sequence delta "direction"
<a name="612"/>procedure sdirection(x)			
<a name="613"/>   local lseq, i
<a name="614"/>
<a name="615"/>   x := sdelta(spromote(x)) | fail
<a name="616"/>
<a name="617"/>   lseq := []
<a name="618"/>
<a name="619"/>   while i := get(x) do
<a name="620"/>      put(lseq,
<a name="621"/>         if i &gt; 0 then 3
<a name="622"/>         else if i = 0 then 2
<a name="623"/>         else 1
<a name="624"/>         )
<a name="625"/>
<a name="626"/>   return lseq
<a name="627"/>
<a name="628"/>end
<a name="629"/>
<a name="630"/>procedure sdistrib(x)
<a name="631"/>   local lseq, i
<a name="632"/>
<a name="633"/>   x := copy(spromote(x))
<a name="634"/>
<a name="635"/>   lseq := list(sbound ! x, 0)
<a name="636"/>
<a name="637"/>   while i := get(x) do
<a name="638"/>      lseq[i] +:= 1
<a name="639"/>
<a name="640"/>   return lseq
<a name="641"/>
<a name="642"/>end
<a name="643"/>
<a name="644"/># test for sequence equivalence
<a name="645"/>procedure sequiv(x1, x2)		
<a name="646"/>   local i
<a name="647"/>
<a name="648"/>   x1 := spromote(x1)
<a name="649"/>   x2 := spromote(x2)
<a name="650"/>
<a name="651"/>   if *x1 ~= *x2 then fail
<a name="652"/>
<a name="653"/>   every i := 1 to *x1 do
<a name="654"/>      if x1[i] ~= x2[i] then fail
<a name="655"/>
<a name="656"/>   return x2
<a name="657"/>
<a name="658"/>end
<a name="659"/>
<a name="660"/># extend sequence
<a name="661"/>procedure sextend(xargs[])		
<a name="662"/>   local lseq, part, i, x1
<a name="663"/>
<a name="664"/>   if \node_gen then return node("sextend", xargs)
<a name="665"/>
<a name="666"/>   x1 := spromote(xargs[1])
<a name="667"/>
<a name="668"/>   lseq := []
<a name="669"/>
<a name="670"/>   every i := !spromote(xargs[2]) do {
<a name="671"/>      part := []
<a name="672"/>      until *part &gt;= i do
<a name="673"/>         part |||:= x1
<a name="674"/>      lseq |||:= part[1+:i]
<a name="675"/>      }
<a name="676"/>
<a name="677"/>   return lseq
<a name="678"/>
<a name="679"/>end
<a name="680"/>
<a name="681"/># flatten packet sequence  BELONGS HERE?
<a name="682"/>procedure sflatten(s)		
<a name="683"/>   local lseq, x
<a name="684"/>
<a name="685"/>   lseq := []
<a name="686"/>
<a name="687"/>   every x := !s do
<a name="688"/>      if type(x) == "list" then lseq |||:= sflatten(x)
<a name="689"/>      else put(lseq, x)
<a name="690"/>
<a name="691"/>   return lseq
<a name="692"/>
<a name="693"/>end
<a name="694"/>
<a name="695"/># ground sequence to i
<a name="696"/>procedure sground(seq, i)		
<a name="697"/>   local j
<a name="698"/>
<a name="699"/>   j := smin ! seq
<a name="700"/>
<a name="701"/>   every !seq -:= (j - i)
<a name="702"/>
<a name="703"/>   return seq
<a name="704"/>
<a name="705"/>end
<a name="706"/>
<a name="707"/># shaft period
<a name="708"/>procedure shaft_period(x1, x2)		
<a name="709"/>
<a name="710"/>
<a name="711"/>   x1 := spromote(x1)
<a name="712"/>   x2 := spromote(x2)
<a name="713"/>
<a name="714"/>   return sconstant(sdelta(spositions(x1, x2)))
<a name="715"/>
<a name="716"/>end
<a name="717"/>
<a name="718"/># string image of sequence
<a name="719"/>procedure simage(x, limit)		
<a name="720"/>   local str
<a name="721"/>
<a name="722"/>   x := spromote(x)
<a name="723"/>
<a name="724"/>   if *x = 0 then return "[]"
<a name="725"/>
<a name="726"/>   /limit := 2 ^ 16			# good enough
<a name="727"/>
<a name="728"/>   str:= ""
<a name="729"/>
<a name="730"/>   every str ||:= (!x \ limit) || ", "
<a name="731"/>
<a name="732"/>   if *x &gt; limit then str ||:= "...  "
<a name="733"/>
<a name="734"/>   return str[1:-2]
<a name="735"/>
<a name="736"/>end
<a name="737"/>
<a name="738"/># bracketed sequence image
<a name="739"/>procedure simageb(seq)			
<a name="740"/>
<a name="741"/>   if *seq = 1 then return seq[1]
<a name="742"/>
<a name="743"/>   return "sconcat(" || simage(seq) || ")"
<a name="744"/>
<a name="745"/>end
<a name="746"/>
<a name="747"/># initialize sequence operations
<a name="748"/>procedure sinit()			
<a name="749"/>
<a name="750"/>   saltparity := sparity
<a name="751"/>   scompact := scompress
<a name="752"/>   sfliph := sreflecth
<a name="753"/>   sflipv := sreflectv
<a name="754"/>   sflipr := sreflectr
<a name="755"/>#  sflipl := sreflectl
<a name="756"/>
<a name="757"/>   return
<a name="758"/>
<a name="759"/>end
<a name="760"/>
<a name="761"/># layer sequences
<a name="762"/>procedure slayer(xargs[])		
<a name="763"/>   local new_xargs, i, shift
<a name="764"/>
<a name="765"/>   if \node_gen then return node("slayer", xargs)
<a name="766"/>
<a name="767"/>   new_xargs := [xargs[1], xargs[2]] | fail
<a name="768"/>
<a name="769"/>   integer(xargs[2][1]) | return scollate ! xargs
<a name="770"/>
<a name="771"/>   shift := sbound ! xargs[2]
<a name="772"/>
<a name="773"/>   every i := 3 to *xargs do {
<a name="774"/>      put(new_xargs, sshift(xargs[i], shift))
<a name="775"/>      shift +:= sbound ! xargs[i]
<a name="776"/>      }
<a name="777"/>
<a name="778"/>   return scollate ! new_xargs
<a name="779"/>
<a name="780"/>end
<a name="781"/>
<a name="782"/># compute sequence length
<a name="783"/>procedure slength(x)			
<a name="784"/>
<a name="785"/>   return *spromote(x)
<a name="786"/>
<a name="787"/>end
<a name="788"/>
<a name="789"/># sequences of first positions of terms
<a name="790"/>procedure slocate(xargs[])		
<a name="791"/>   local count, i, lseq, x1, x2
<a name="792"/>
<a name="793"/>   if \node_gen then return node("slocate", xargs)
<a name="794"/>
<a name="795"/>   x1 := copy(spromote(xargs[1]))
<a name="796"/>   x2 := elementset(spromote(xargs[2]))
<a name="797"/>
<a name="798"/>   lseq := []
<a name="799"/>
<a name="800"/>   count := 0
<a name="801"/>
<a name="802"/>   while i := get(x1) do {
<a name="803"/>      count +:= 1
<a name="804"/>      if member(x2, integer(i)) then
<a name="805"/>         return count
<a name="806"/>      }
<a name="807"/>
<a name="808"/>   fail
<a name="809"/>
<a name="810"/>end
<a name="811"/>
<a name="812"/># map terms in sequence
<a name="813"/>procedure smap(xargs[])			
<a name="814"/>   local i, smaptbl, x1, x2, x3
<a name="815"/>   static tdefault
<a name="816"/>
<a name="817"/>   initial tdefault := []
<a name="818"/>
<a name="819"/>   x1 := copy(spromote(xargs[1]))
<a name="820"/>   x2 := spromote(xargs[2])
<a name="821"/>   x3 := spromote(xargs[3])
<a name="822"/>
<a name="823"/>   if *x2 ~= *x3 then fail
<a name="824"/>
<a name="825"/>   smaptbl := table(tdefault)		# mapping table
<a name="826"/>
<a name="827"/>   every i := 1 to *x2 do		# build the map
<a name="828"/>      smaptbl[x2[i]] := x3[i]
<a name="829"/>
<a name="830"/>   every i := 1 to *x1 do		# map the values
<a name="831"/>      x1[i] := (tdefault ~=== smaptbl[x1[i]])
<a name="832"/>
<a name="833"/>   return x1
<a name="834"/>
<a name="835"/>end
<a name="836"/>
<a name="837"/># compute sequence lower bound	FIX
<a name="838"/>procedure smin(xargs[])			
<a name="839"/>
<a name="840"/>   return sort(xargs)[1]
<a name="841"/>
<a name="842"/>end
<a name="843"/>
<a name="844"/># missing terms in sequence  BOGUS??
<a name="845"/>procedure smissing(x)			
<a name="846"/>   local lseq, i, result
<a name="847"/>
<a name="848"/>   x := spromote(x)
<a name="849"/>
<a name="850"/>   lseq := sorder(x)
<a name="851"/>
<a name="852"/>   result := []
<a name="853"/>
<a name="854"/>   every i := 1 to *lseq do
<a name="855"/>      if lseq[i] = 0 then put(result, i)
<a name="856"/>
<a name="857"/>   return result
<a name="858"/>
<a name="859"/>end
<a name="860"/>
<a name="861"/># modular reduction
<a name="862"/>procedure smod(xargs[])			
<a name="863"/>   local lseq, i, x1, x2
<a name="864"/>
<a name="865"/>   if \node_gen then return node("smod", xargs)
<a name="866"/>
<a name="867"/>   x1 := spromote(xargs[1])
<a name="868"/>   x2 := spromote(xargs[2])
<a name="869"/>
<a name="870"/>   lseq := []
<a name="871"/>
<a name="872"/>   every i := !x2 do
<a name="873"/>      every put(lseq, mod1(!x1, i))
<a name="874"/>
<a name="875"/>   return lseq
<a name="876"/>
<a name="877"/>end
<a name="878"/>
<a name="879"/># mutation
<a name="880"/>procedure smutate(xargs[])		
<a name="881"/>   local lseq, x1, x2
<a name="882"/>
<a name="883"/>   if \node_gen then return node("smutate", xargs)
<a name="884"/>
<a name="885"/>   x1 := spromote(xargs[1])
<a name="886"/>   x2 := spromote(xargs[2])
<a name="887"/>
<a name="888"/>   lseq := []
<a name="889"/>
<a name="890"/>   every put(lseq, x1[!x2])
<a name="891"/>
<a name="892"/>   return lseq
<a name="893"/>
<a name="894"/>end
<a name="895"/>
<a name="896"/># normalize sequence
<a name="897"/>procedure snormal(x)			
<a name="898"/>   local lseq, i, target, count	# maps shafts so they are numbered in order
<a name="899"/>				# first appearance
<a name="900"/>   x := spromote(x)
<a name="901"/>
<a name="902"/>   lseq := []
<a name="903"/>
<a name="904"/>   count := 0
<a name="905"/>
<a name="906"/>   target := table()
<a name="907"/>
<a name="908"/>   every i := !x do {
<a name="909"/>      /target[i] := (count +:= 1)
<a name="910"/>      put(lseq, target[i])
<a name="911"/>      }
<a name="912"/>
<a name="913"/>   return lseq
<a name="914"/>
<a name="915"/>end
<a name="916"/>
<a name="917"/># create open sequence palindrome
<a name="918"/>procedure sopal(xargs[])		
<a name="919"/>   local x
<a name="920"/>
<a name="921"/>   if \node_gen then return node("sopal", xargs)
<a name="922"/>
<a name="923"/>   x := spromote(xargs[1])
<a name="924"/>
<a name="925"/>   return x ||| sreflecth(x)[2:-1]
<a name="926"/>
<a name="927"/>end
<a name="928"/>
<a name="929"/># positions of first occurrence
<a name="930"/>procedure sorder(x)			
<a name="931"/>   local lseq, i, done		#  of terms in *compact* sequence
<a name="932"/>
<a name="933"/>   x := copy(spromote(x))
<a name="934"/>
<a name="935"/>   lseq := []
<a name="936"/>
<a name="937"/>   done := set()
<a name="938"/>
<a name="939"/>   while i := integer(get(x)) do {
<a name="940"/>      if member(done, i) then next
<a name="941"/>      else {
<a name="942"/>         put(lseq, i)
<a name="943"/>         insert(done, i)
<a name="944"/>         }
<a name="945"/>      }
<a name="946"/>
<a name="947"/>   return lseq
<a name="948"/>
<a name="949"/>end
<a name="950"/>
<a name="951"/># adjust parity
<a name="952"/>procedure sparity(xargs[])		
<a name="953"/>   local lseq, i, j, k, x1, x2
<a name="954"/>
<a name="955"/>   if \node_gen then return node("sparity", xargs)
<a name="956"/>
<a name="957"/>   x1 := spromote(xargs[1])
<a name="958"/>   x2 := spromote(xargs[2])
<a name="959"/>
<a name="960"/>   lseq := []
<a name="961"/>
<a name="962"/>   every i := 1 to *x1 do {
<a name="963"/>      j := x1[i]
<a name="964"/>      k := x2[i]
<a name="965"/>      if (j % 2) = (k % 2) then put(lseq, j)
<a name="966"/>      else every put(lseq, j + 1 | j)
<a name="967"/>      }
<a name="968"/>
<a name="969"/>   return lseq
<a name="970"/>
<a name="971"/>end
<a name="972"/>
<a name="973"/># period of sequence
<a name="974"/>procedure speriod(seq)			
<a name="975"/>   local i, segment
<a name="976"/>
<a name="977"/>   every i := divisors(*seq) do {
<a name="978"/>      segment := seq[1+:i]
<a name="979"/>      if sequiv(sextend(segment, *seq), seq) then return i
<a name="980"/>      }
<a name="981"/>
<a name="982"/>   fail
<a name="983"/>
<a name="984"/>end
<a name="985"/>
<a name="986"/># place motif along a path
<a name="987"/>procedure splace(xargs[])		
<a name="988"/>   local lseq, i, x1, x2
<a name="989"/>
<a name="990"/>   if \node_gen then return node("splace", xargs)
<a name="991"/>
<a name="992"/>   x1 := copy(spromote(xargs[1]))
<a name="993"/>   x2:= spromote(xargs[2])
<a name="994"/>
<a name="995"/>   lseq := []
<a name="996"/>
<a name="997"/>   every i := !x2 do
<a name="998"/>      every put(lseq, !x1 + i - 1)
<a name="999"/>
<a name="1000"/>   return lseq
<a name="1001"/>
<a name="1002"/>end
<a name="1003"/>
<a name="1004"/># generalized motifs along a path
<a name="1005"/>procedure splaceg(xargs[])		
<a name="1006"/>   local lseq, i, path, motif
<a name="1007"/>
<a name="1008"/>   if \node_gen then return node("splaceg", xargs)
<a name="1009"/>
<a name="1010"/>   path := copy(get(xargs))
<a name="1011"/>
<a name="1012"/>   xargs := copyl ! xargs
<a name="1013"/>
<a name="1014"/>   lseq := []
<a name="1015"/>
<a name="1016"/>   while i := get(path) do {
<a name="1017"/>      motif := get(xargs)
<a name="1018"/>      put(xargs, motif)
<a name="1019"/>      every put(lseq, !motif + i - 1)
<a name="1020"/>      }
<a name="1021"/>
<a name="1022"/>   return lseq
<a name="1023"/>
<a name="1024"/>end
<a name="1025"/>
<a name="1026"/># positions of values in sequence
<a name="1027"/>procedure spositions(x1, x2)		
<a name="1028"/>   local lseq, count, i
<a name="1029"/>
<a name="1030"/>   x1 := copy(spromote(x1))
<a name="1031"/>   x2 := elementset(spromote(x2))
<a name="1032"/>
<a name="1033"/>   lseq := []
<a name="1034"/>
<a name="1035"/>   count := 0
<a name="1036"/>
<a name="1037"/>   while i := get(x1) do {
<a name="1038"/>      count +:= 1
<a name="1039"/>      if member(x2, integer(i)) then
<a name="1040"/>         put(lseq, count)
<a name="1041"/>      }
<a name="1042"/>
<a name="1043"/>   return lseq
<a name="1044"/>
<a name="1045"/>end
<a name="1046"/>
<a name="1047"/># promote term to sequence
<a name="1048"/>procedure spromote(x)			
<a name="1049"/>
<a name="1050"/>   if type(x) ~== "list" then x := [x]
<a name="1051"/>
<a name="1052"/>   return x
<a name="1053"/>
<a name="1054"/>end
<a name="1055"/>
<a name="1056"/># random selection
<a name="1057"/>procedure srandom(x)			
<a name="1058"/>
<a name="1059"/>   return ?spromote(x)
<a name="1060"/>
<a name="1061"/>end
<a name="1062"/>
<a name="1063"/># reflect sequence horizontally
<a name="1064"/>procedure sreflecth(xargs[])		
<a name="1065"/>   local lseq
<a name="1066"/>
<a name="1067"/>   if \node_gen then return node("sreflecth", xargs)
<a name="1068"/>
<a name="1069"/>   lseq := []
<a name="1070"/>
<a name="1071"/>   every push(lseq, !spromote(xargs[1]))
<a name="1072"/>
<a name="1073"/>   return lseq
<a name="1074"/>
<a name="1075"/>end
<a name="1076"/>
<a name="1077"/>
<a name="1078"/>procedure sreflectr(xargs[])
<a name="1079"/>   local lseq, i, bound, x
<a name="1080"/>
<a name="1081"/>   if \node_gen then return node("sreflectr", xargs)
<a name="1082"/>
<a name="1083"/>   x := spromote(xargs[1])
<a name="1084"/>
<a name="1085"/>   bound := sbound ! x
<a name="1086"/>
<a name="1087"/>   lseq := []
<a name="1088"/>
<a name="1089"/>   every i := !x do
<a name="1090"/>      push(lseq, bound - i + 1)
<a name="1091"/>
<a name="1092"/>   return lseq
<a name="1093"/>
<a name="1094"/>end
<a name="1095"/>
<a name="1096"/># reflect sequence vertically
<a name="1097"/>procedure sreflectv(xargs[])		
<a name="1098"/>   local lseq, m, x
<a name="1099"/>
<a name="1100"/>   if \node_gen then return node("sreflectv", xargs)
<a name="1101"/>
<a name="1102"/>   x := spromote(xargs[1])
<a name="1103"/>
<a name="1104"/>   integer(x[1]) | return x
<a name="1105"/>
<a name="1106"/>   m := sbound ! x
<a name="1107"/>
<a name="1108"/>   lseq := []
<a name="1109"/>
<a name="1110"/>   every put(lseq, m - !x + 1)
<a name="1111"/>
<a name="1112"/>   return lseq
<a name="1113"/>
<a name="1114"/>end
<a name="1115"/>
<a name="1116"/># remove duplicate adjacent terms
<a name="1117"/>procedure sremdupl(xargs[])		
<a name="1118"/>   local lseq, i, x
<a name="1119"/>
<a name="1120"/>   if \node_gen then return node("sremdupl", xargs)
<a name="1121"/>
<a name="1122"/>   x := copy(spromote(xargs[1]))
<a name="1123"/>
<a name="1124"/>   lseq := [get(x)] | return []
<a name="1125"/>
<a name="1126"/>   while i := get(x) do
<a name="1127"/>      if lseq[-1] ~= i then
<a name="1128"/>         put(lseq, i)
<a name="1129"/>
<a name="1130"/>   return lseq
<a name="1131"/>
<a name="1132"/>end
<a name="1133"/>
<a name="1134"/># repeat sequence
<a name="1135"/>procedure srepeat(xargs[])		
<a name="1136"/>   local lseq, count, x1
<a name="1137"/>
<a name="1138"/>   if \node_gen then return node("srepeat", xargs)
<a name="1139"/>
<a name="1140"/>   x1 := spromote(xargs[1])
<a name="1141"/>
<a name="1142"/>   count := 0
<a name="1143"/>
<a name="1144"/>   every count +:= !spromote(xargs[2])
<a name="1145"/>
<a name="1146"/>   lseq := copy(x1)
<a name="1147"/>
<a name="1148"/>   every 2 to count do
<a name="1149"/>         lseq |||:= x1
<a name="1150"/>
<a name="1151"/>   return lseq
<a name="1152"/>
<a name="1153"/>end
<a name="1154"/>
<a name="1155"/># replicate sequence terms
<a name="1156"/>procedure srepl(xargs[])		
<a name="1157"/>   local lseq, i, j, x1, x2
<a name="1158"/>
<a name="1159"/>   if \node_gen then return node("srepl", xargs)
<a name="1160"/>
<a name="1161"/>   x1 := spromote(xargs[1])
<a name="1162"/>   x2 := spromote(xargs[2])
<a name="1163"/>
<a name="1164"/>   lseq := []
<a name="1165"/>
<a name="1166"/>   every i := !x2 do
<a name="1167"/>      every j := !x1 do
<a name="1168"/>         every 1 to i do
<a name="1169"/>            put(lseq, j)
<a name="1170"/>
<a name="1171"/>   return lseq
<a name="1172"/>
<a name="1173"/>end
<a name="1174"/>
<a name="1175"/># rotate sequence vertically
<a name="1176"/>procedure srotatev(xargs[])		
<a name="1177"/>   local lseq, m, x
<a name="1178"/>
<a name="1179"/>   if \node_gen then return node("srotatev", xargs)
<a name="1180"/>
<a name="1181"/>   x := spromote(xargs[1])
<a name="1182"/>
<a name="1183"/>   integer(x[1]) | return x
<a name="1184"/>
<a name="1185"/>   m := sbound ! x
<a name="1186"/>
<a name="1187"/>   lseq := []
<a name="1188"/>
<a name="1189"/>   every put(lseq, mod1(!x + 1, m))
<a name="1190"/>
<a name="1191"/>   return lseq
<a name="1192"/>
<a name="1193"/>end
<a name="1194"/>
<a name="1195"/># create connected runs
<a name="1196"/>procedure srun(xargs[])			
<a name="1197"/>   local lseq, i, j, x
<a name="1198"/>
<a name="1199"/>   if \node_gen then return node("srun", xargs)
<a name="1200"/>
<a name="1201"/>   x := copy(spromote(xargs[1]))
<a name="1202"/>
<a name="1203"/>   lseq := []
<a name="1204"/>
<a name="1205"/>   i := get(x) | return lseq
<a name="1206"/>
<a name="1207"/>   while j := get(x) do {
<a name="1208"/>      lseq |||:= sruns(i, j, 1)
<a name="1209"/>      pull(lseq)
<a name="1210"/>      i := j
<a name="1211"/>      }
<a name="1212"/>
<a name="1213"/>   put(lseq, i)
<a name="1214"/>
<a name="1215"/>   return lseq
<a name="1216"/>
<a name="1217"/>end     
<a name="1218"/>
<a name="1219"/># disconnected runs
<a name="1220"/>procedure sruns(xargs[])		
<a name="1221"/>   local lseq, i, j, k,  x1, x2, x3
<a name="1222"/>
<a name="1223"/>   if \node_gen then return node("sruns", xargs)
<a name="1224"/>
<a name="1225"/>   x1 := copy(spromote(xargs[1]))
<a name="1226"/>   x2 := copy(spromote(xargs[2]))
<a name="1227"/>   x3 := copy(spromote(xargs[3]) | [1])
<a name="1228"/>
<a name="1229"/>   lseq := []
<a name="1230"/>
<a name="1231"/>   repeat {
<a name="1232"/>      i := get(x1) | break
<a name="1233"/>      j := get(x2) | break
<a name="1234"/>      k := get(x3) | break
<a name="1235"/>      put(x3, k)			# cycle
<a name="1236"/>      if integer(j) &lt; integer(i) then k := -k
<a name="1237"/>      every put(lseq, i to j by k)
<a name="1238"/>      }
<a name="1239"/>
<a name="1240"/>   return lseq
<a name="1241"/>
<a name="1242"/>end
<a name="1243"/> 
<a name="1244"/># scale terms in sequence
<a name="1245"/>procedure sscale(xargs[])		
<a name="1246"/>   local lseq, j, i, x1
<a name="1247"/>
<a name="1248"/>   if \node_gen then return node("sscale", xargs)
<a name="1249"/>
<a name="1250"/>   x1 := spromote(xargs[1])
<a name="1251"/>
<a name="1252"/>   lseq := []
<a name="1253"/>
<a name="1254"/>   every i := !spromote(xargs[2]) do
<a name="1255"/>      every j := 1 to *x1 do
<a name="1256"/>          put(lseq, (x1[j] - 1) * i + 1)
<a name="1257"/>
<a name="1258"/>   return lseq	
<a name="1259"/>
<a name="1260"/>end
<a name="1261"/>
<a name="1262"/># entire sequence collation
<a name="1263"/>procedure sscollate(xargs[])		
<a name="1264"/>   local lseq, i, order
<a name="1265"/>
<a name="1266"/>   if \node_gen then return node("sscollate", xargs)
<a name="1267"/>
<a name="1268"/>   order := get(xargs)
<a name="1269"/>
<a name="1270"/>   /order := srun(1, *xargs)
<a name="1271"/>
<a name="1272"/>   xargs := copyl ! xargs
<a name="1273"/>
<a name="1274"/>   lseq := []
<a name="1275"/>
<a name="1276"/>   while i := get(order) do
<a name="1277"/>      lseq |||:= xargs[i]
<a name="1278"/>
<a name="1279"/>   return lseq
<a name="1280"/>
<a name="1281"/>end
<a name="1282"/>
<a name="1283"/># select terms from sequence
<a name="1284"/>procedure sselect(xargs[])		
<a name="1285"/>   local lseq, i, x1, x2
<a name="1286"/>
<a name="1287"/>   if \node_gen then return node("sselect", xargs)
<a name="1288"/>
<a name="1289"/>   x1 := spromote(xargs[1])
<a name="1290"/>   x2 := copy(spromote(xargs[2]))
<a name="1291"/>
<a name="1292"/>   lseq := []
<a name="1293"/>
<a name="1294"/>   while i := get(x2) do
<a name="1295"/>      put(lseq, x1[i])		# may fail
<a name="1296"/>
<a name="1297"/>   return lseq
<a name="1298"/>
<a name="1299"/>end
<a name="1300"/>
<a name="1301"/># shift terms sequence
<a name="1302"/>procedure sshift(x, i)			
<a name="1303"/>   local lseq
<a name="1304"/>
<a name="1305"/>   lseq := []
<a name="1306"/>
<a name="1307"/>   every put(lseq, !spromote(x) + i)
<a name="1308"/>
<a name="1309"/>   return lseq
<a name="1310"/>
<a name="1311"/>end
<a name="1312"/>
<a name="1313"/># modular expansion
<a name="1314"/>procedure sunmod(x)			
<a name="1315"/>   local base, bound, i, lseq, k
<a name="1316"/>
<a name="1317"/>   x := copy(spromote(x))
<a name="1318"/>
<a name="1319"/>   integer(x[1]) | return x
<a name="1320"/>
<a name="1321"/>   base := 0
<a name="1322"/>
<a name="1323"/>   bound := sbound ! x
<a name="1324"/>
<a name="1325"/>   lseq := [get(x)] | fail
<a name="1326"/>
<a name="1327"/>   while i := get(x) do {
<a name="1328"/>      if (i = 1) &amp; (lseq[-1] = base + bound) then
<a name="1329"/>         base +:= bound
<a name="1330"/>      else if (i = bound) &amp; (lseq[-1] = base + 1) then
<a name="1331"/>         base -:= bound
<a name="1332"/>      put(lseq, base + i)
<a name="1333"/>      }
<a name="1334"/>
<a name="1335"/>   k := (smin ! lseq)
<a name="1336"/>
<a name="1337"/>   if k &gt; 0 then return lseq
<a name="1338"/>
<a name="1339"/>   k := bound * (-k / bound + 1)
<a name="1340"/>
<a name="1341"/>   every !lseq +:= k
<a name="1342"/>
<a name="1343"/>   return lseq
<a name="1344"/>
<a name="1345"/>end
<a name="1346"/># unary operation on terms
<a name="1347"/>procedure sunop(op, xargs[])		
<a name="1348"/>   local lseq, i, x
<a name="1349"/>
<a name="1350"/>   if \node_gen then return node("sunop", xargs)
<a name="1351"/>
<a name="1352"/>   x := spromote(xargs[1])
<a name="1353"/>
<a name="1354"/>   op := need_callable(op, 1)
<a name="1355"/>
<a name="1356"/>   lseq := []
<a name="1357"/>
<a name="1358"/>   every i := 1 to *x do
<a name="1359"/>      put(lseq, op(x[i]))
<a name="1360"/>
<a name="1361"/>   return lseq
<a name="1362"/>
<a name="1363"/>end
<a name="1364"/>
<a name="1365"/>procedure walk_tree(n, tree_list, tree_ptrs, depth)
<a name="1366"/>   local indent
<a name="1367"/>
<a name="1368"/>   /tree_list := []
<a name="1369"/>   /tree_ptrs := []
<a name="1370"/>   /depth := 0
<a name="1371"/>
<a name="1372"/>   indent := repl(" ", 3 * depth)
<a name="1373"/>
<a name="1374"/>   n := integer(n)
<a name="1375"/>
<a name="1376"/>   case type(n) of {
<a name="1377"/>      "integer" | "list"  :  {
<a name="1378"/>         put(tree_list, indent || "[" || simage(n, MaxTerms) || "]")
<a name="1379"/>         put(tree_ptrs, n)
<a name="1380"/>         return [tree_list, tree_ptrs]
<a name="1381"/>         }
<a name="1382"/>      "string"            :  {
<a name="1383"/>         put(tree_list, indent || n)
<a name="1384"/>         put(tree_ptrs, n)
<a name="1385"/>         return [tree_list, tree_ptrs]
<a name="1386"/>         }
<a name="1387"/>      }
<a name="1388"/>
<a name="1389"/>   put(tree_list, indent || n.name)
<a name="1390"/>   put(tree_ptrs, n)
<a name="1391"/>
<a name="1392"/>   every walk_tree(!n.seqlist, tree_list, tree_ptrs, depth + 1)
<a name="1393"/>
<a name="1394"/>   return [tree_list, tree_ptrs]
<a name="1395"/>
<a name="1396"/>end
</pre></body></html>
