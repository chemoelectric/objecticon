#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package xml

import lang, util, ipl.scan, exception

#
# Holds detail of a parse position in a file
#
package class Diversion()
   public const
      base,
      id,
      subject, 
      pos

   public new(base, id, subject, pos)
      self.base := base
      self.id := id
      self.subject := subject
      self.pos := pos
      return
   end
end

#
# Instances of this class are fired to listeners on a parse problem.
#
class ProblemDetail()
   public const
      stack,
      msg

   package new(stack, msg)
      self.stack := stack
      self.msg := msg
      return
   end
end

#
# Holds a attribute usage of IDREF.  Just used for validation.
#
package class IdAttributeRef()
   public const
      val,
      pos

   public new(val, pos)
      self.val := val
      self.pos := pos
      return
   end
end

#
# An XML Parser
#
class XmlParser(Connectable)
   public static const
      SPACE,
      CHAR,
      INVALID_CHAR,
      NAME_START, 
      NAME_CHAR,
      PUBID_CHAR,
      WARNING_EVENT,
      VALIDITY_ERROR_EVENT, 
      FATAL_ERROR_EVENT

   private
      doc,
      current_divert_id,
      divert_stack,
      current_base,
      in_ext_subset,
      id_attribute_refs,
      dtd_insert_shown_error

   private readable
      resolver, 
      do_namespaces_flag,
      preserve_insignificant_whitespace_flag,
      preserve_comments_flag,
      validate_flag,
      utf8_flag

   #
   # Set the resolver
   #
   public set_resolver(r)
      self.resolver := r
      link
   end

   #
   # Get the resolver being used
   #
   public get_resolver()
      return .resolver
   end

   #
   # Configure whether the parser does namespace post-processing (the
   # default is yes).
   #
   public set_do_namespaces(s)
      self.do_namespaces_flag := need_flag(s)
      link
   end

   #
   # Configure whether the parser validates (the default is yes).
   #
   public set_validate(s)
      self.validate_flag := need_flag(s)
      link
   end

   #
   # Configure whether the parser preserves comments (the default is yes).
   #
   public set_preserve_comments(s)
      preserve_comments_flag := need_flag(s)
      link
   end

   #
   # Configure whether the parser always keeps insignificant whitespace
   # in the output document.  Generally only useful for testing purposes;
   # XML canonical form needs this flag to be set because it is a byte
   # for byte output which needs to include insignificate whitespace.
   #
   # The default is off.
   #
   public set_preserve_insignificant_whitespace(s)
      preserve_insignificant_whitespace_flag := need_flag(s)
      link
   end

   #
   # Parse the string `s` returning an `XmlDocument` object.  `base` is an
   # optional string parameter giving the URL of the source of `s`.  Providing
   # it can help resolve relative paths within the document.
   #
   # [1] document ::= prolog element Misc*
   #
   public parse(s, base)
      s := need_text(s)
      doc := XmlDocument()

      utf8_flag := Yes{ type(s) == "ucs" }

      # The predefined entities.  Note that the values are in each case valid content.
      # The chars "&" and "<" on their own would not be valid content.
      if \utf8_flag then {
         insert(doc.general_entities, u"lt", EntityDef(u"&#60;"))
         insert(doc.general_entities, u"gt", EntityDef(u">"))
         insert(doc.general_entities, u"amp", EntityDef(u"&#38;"))
         insert(doc.general_entities, u"apos", EntityDef(u"\'"))
         insert(doc.general_entities, u"quot", EntityDef(u"\""))
      } else {
         insert(doc.general_entities, "lt", EntityDef("&#60;"))
         insert(doc.general_entities, "gt", EntityDef(">"))
         insert(doc.general_entities, "amp", EntityDef("&#38;"))
         insert(doc.general_entities, "apos", EntityDef("\'"))
         insert(doc.general_entities, "quot", EntityDef("\""))
      }

      dtd_insert_shown_error := &null
      current_divert_id := "input"
      current_base := base
      divert_stack := []
      id_attribute_refs := []

      normalize_eol(s) ? try1{{
         parse_prolog()
         doc.add(parse_element())
         parse_misc_star()
         pos(0) | throw("Invalid content at end of input")
         validate_docname()
         validate_idrefs()
         validate_ndata_decls()
         validate_attribute_definitions()
         if \self.do_namespaces_flag then
            do_namespace_processing()
         cleanup_source_refs()
      }} | {
         save_why{fire(FATAL_ERROR_EVENT, ProblemDetail(where(), &why))}
         doc := id_attribute_refs := &null
         fail
      }
      return 1(.doc, doc := &null)
   end

   #
   # Remove any unwanted references to the source string from
   # self and doc.
   #
   private cleanup_source_refs()
      id_attribute_refs := &null
      every (!doc.general_entities).pos := &null
      every (!(!doc.attribute_lists).attribute_defs).pos := &null
   end

   private validate_ndata_decls()
      local x
      every x := !sort(doc.general_entities) do {
         if \x[2].notation then
            member(doc.notation_declarations, x[2].notation) | 
               invalid("ENTITY " || x[1] ||
                       ": NDATA declaration " || x[2].notation || " not declared as a NOTATION",
                       x[2].pos)
      }
   end

   private validate_attribute_definitions()
      local x, y, z
      every x := !sort(doc.attribute_lists) do  {
         every y := !sort(x[2].attribute_defs) do {
            case y[2].def_type of {
               "NOTATION": {
                  # Check for EMPTY/NOTATION clash.
                  if (\doc.element_declarations[x[1]]).content_spec.op == "EMPTY" then
                     invalid("ATTLIST for element " || x[1] || ", attribute " ||
                             y[1] || ": An EMPTY element can't have a NOTATION attribute",
                             y[2].pos)

                  # Check all notations declared.
                  every z := !y[2].def_set do {
                     member(doc.notation_declarations, z) | 
                        invalid("ATTLIST for element " || x[1] || ", attribute " ||
                                y[1] || ": " || z || " not declared as a NOTATION",
                                y[2].pos)
                  }
               }
               "ENTITY" | "ENTITIES" : {
                  # Check default value refers to an ENTITY.
                  if \y[2].default_value then {
                     member(doc.general_entities, y[2].default_value) | 
                        invalid("ATTLIST for element " || x[1] || ", attribute " ||
                                y[1] || ": default value " || y[2].default_value ||
                                " not declared as an ENTITY",
                                y[2].pos)
                  }
               }
            }
         }
      }
   end

   #
   # Validate idrefs
   #
   private validate_idrefs()
      local x
      every x := !id_attribute_refs do
         member(doc.id_attribute_values, x.val) | invalid("An IDREF(S) attribute " ||
                                                          x.val || " was used, which does not match any IDs",
                                                          x.pos)
   end

   private validate_docname()
      local docname, e

      every e := !doc.children do {
         if is(e, DocType) then {
            docname := e.get_name()
            break
         }
      }

      if \docname ~== doc.get_root_element().get_name() then
         invalid("The document name in the DOCTYPE declaration must match the name of the root element")
   end

   #
   # [3] S ::= (#x20 | #x9 | #xD | #xA)+
   #
   private spaces()
      any(SPACE) | throw("Space expected")
      return tab(many(SPACE))
   end

   private dtd_spaces()
      dtd_any(SPACE) | throw("Space expected")
      return tab(dtd_many(SPACE))
   end

   #
   # [5] Name ::= (Letter | '_' | ':') (NameChar)*
   #
   private parse_name(quiet)
      any(NAME_START) | throw("Valid name start character expected")
      return move(1) || tab(many0(NAME_CHAR))
   end

   #
   # Same as parse_name, but within a DTD
   #
   private dtd_parse_name()
      dtd_any(NAME_START) | throw("Valid name start character expected")
      return move(1) ||  tab(dtd_many0(NAME_CHAR))
   end

   #
   # [6] Names ::= Name (S Name)*
   #
   private parse_names() 
      local l

      l := []
      repeat {
         put(l, parse_name()) | fail
         looking_at_space_then_cset(NAME_START) | break
         spaces()
      }
      
      return l
   end

   #
   # Succeed iff a string is a valid Name.
   #
   private valid_name(s)
      return s ? 2(any(NAME_START), parse_name(), pos(0))
   end

   #
   # Succeed iff a string is a valid Names.
   #
   private valid_names(s)
      return s ? 2(any(NAME_START), parse_names(), pos(0))
   end

   #
   # [7] Nmtoken ::= (NameChar)+
   #
   private parse_nmtoken()
      any(NAME_CHAR) | throw("Valid name character expected")
      return tab(many(NAME_CHAR))
   end

   #
   # Same as parse_nmtoken, but within a DTD
   #
   private dtd_parse_nmtoken()
      dtd_any(NAME_CHAR) | throw("Valid name character expected")
      return tab(dtd_many(NAME_CHAR))
   end

   #
   # [8] Nmtokens ::=  Nmtoken (S Nmtoken)*
   #
   private parse_nmtokens() 
      local l

      l := []
      repeat {
         put(l, parse_nmtoken()) | fail
         looking_at_space_then_cset(NAME_CHAR) | break
         spaces()
      }
      
      return l
   end

   #
   # Succeed iff a string is a valid Nmtoken.
   #
   private valid_nmtoken(s)
      return s ? 2(any(NAME_CHAR), parse_nmtoken(), pos(0))
   end

   #
   # Succeed iff a string is a valid Nmtokens.
   #
   private valid_nmtokens(s)
      return s ? 2(any(NAME_CHAR), parse_nmtokens(), pos(0))
   end

   #
   # [9] EntityValue ::= '"' ([^%&"] | PEReference | Reference)* '"' |  "'" ([^%&'] | PEReference | Reference)* "'"
   #
   private parse_entity_value()
      local res, c
      c := tab(any('\'\"')) | throw("\' or \" expected")
      res := move(0)  # Empty string, same type as &subject
      repeat {
         if any('%') then {
            # Can't reference a pe in the internal subset; see ibm test ibm29n04.xml
            if /in_ext_subset then 
               throw("Cannnot reference a parameter entity in the internal subset")
            # In an entity value, perefs (%..;) are always expanded
            res ||:= resolve_entity(lookup_pe_reference(parse_pe_reference()))
         } else if match("&#") then
            # Char refs are expanded
            res ||:= parse_char_ref(&yes)
         else if any('&') then
            # General refs aren't
            res ||:= parse_entity_ref()
         else if =c then
            break
         else
            res ||:= tab(upto('%&' ++ c)) | throw("Unexpected eof")
      }
      check_is_char_data(res, "entity value data")
      return res
   end
   
   #
   # [10] AttValue ::= '"' ([^<&"] | Reference)* '"' |  "'" ([^<&'] | Reference)* "'"
   #
   private parse_attvalue()
      local res, c
      c := tab(any('\'\"')) | throw("\' or \" expected")
      res := move(0)  # Empty string, same type as &subject
      repeat {
         if any('&') then
            res ||:= parse_reference()
         else if any('<') then
            throw("'<' not allowed here")
         else if =c then
            break
         else
            res ||:= tab(upto('<&' ++ c)) | throw("Unexpected eof")
      }
      check_is_char_data(res, "attribute value data")
      return res
   end

   #
   # see s3.3.3 - attribute value normalization.
   # attlist is the attributelist for this element, or &null if unknown.
   # att is the name of the attribute.
   #
   private normalize_attvalue(s, attdef)
      local res

      #
      # Need to divert because the normalize_attvalue1 uses string scanning, and
      # returns errors.
      #
      start_divert(current_base, "attvalue")
      res := normalize_attvalue1(s)
      end_divert()

      #
      # Decide if it's a CDATA element.
      #
      if (\attdef).def_type == "CDATA" then
         return res

      #
      # Not a CDATA, so do extra processing on it.
      #
      res ? {
         tab(many(' '))
         res := ""
         while res ||:= tab(upto(' ')) do {
            tab(many(' '))
            # No trailing spaces.
            if not(pos(0)) then
               res ||:= " "
         }
         res ||:= tab(0)
      }

      return res
   end

   private normalize_attvalue1(s, circle)
      local res, ref, c2, o
      res := ""
      s ? {
         while res ||:= tab(upto('&' ++ SPACE)) do {
            if tab(any(SPACE)) then {
               res ||:= " "
            } else {   # an '&'
               # Char refs aren't recursively treated; entity refs are.
               if match("&#") then
                  res ||:= parse_char_ref(&yes)
               else {
                  ref := parse_entity_ref()
                  if member(\circle, ref) then
                     throw("Circular entity replacement")
                  c2 := copy(\circle) | set()
                  insert(c2, ref)
                  o := lookup_entity_ref(ref)

                  #
                  # If standalone "yes", then can't refernce the entity if it was defined in the external subset
                  #
                  if \doc.standalone & \o.in_ext_subset then
                     throw("Cannot reference an entity declared externally, in a standalone document")
                  #
                  # Can't have an external reference here.  See s3.1
                  #
                  \o.str | throw("Reference to external entity in attribute value")
                  #
                  # Can't have a < char; s3.1
                  #
                  if upto('<', o.str) then
                     throw("The replacement text in an attribute value cannot contain a '<' char")
                  #
                  # Recursively normalize the entity ref's value
                  #
                  res ||:= normalize_attvalue1(o.str, c2)
               }
            }
         }
         return res || tab(0)
      }
   end

   #
   # Normalize end-of-line characters.
   # \r\n combinations are replaced with \n
   # \rx combinations are replaced with \nx where x is any character other than \n
   #
   private normalize_eol(s)
      local res
      res := ""
      s ? {
         while res ||:= tab(upto('\r')) do {
            move(1)
            if any('\n') then
               move(1)
            res ||:= "\n"
         }
         return res || tab(0)
      }
   end

   #
   # [11] SystemLiteral ::= ('"' [^"]* '"') | ("'" [^']* "'") 
   #
   private parse_system_literal()
      local c, res
      c := tab(any('\'\"')) | throw("\' or \" expected")
      res := tab(upto(c)) | throw("Couldn't find " || c)
      move(1)
      check_is_char_data(res, "system literal value")
      return res
   end

   #
   # [12] PubidLiteral ::= '"' PubidChar* '"' | "'" (PubidChar - "'")* "'"
   #
   private parse_pubid_literal()
      local c, res, t
      if any('\'') then
         t := PUBID_CHAR -- '\''
      else if any('\"') then
         t := PUBID_CHAR
      else
         throw("\' or \" expected")
      c := move(1)
      res := tab(many(t)) | ""
      =c | throw(c || " expected")

      return res
   end

   #
   # [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
   #
   # Assume "<!--" already matched.
   #
   private parse_comment()
      local res, s, t
      res := Comment()
      s := ""
      repeat {
         t := tab(upto('-')) | throw("- expected")
         check_is_char_data(t, "comment")
         s ||:= t
         # A double-hypen cannot be within the comment and must signify the end.
         if match("--") then
            break
         s ||:= move(1)
      }
      ="-->" | throw("'-->' expected")
      res.comment := s
      return res
   end

   #
   # [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'
   #
   #  Assume "<?" already matched.
   #
   private parse_pi()
      local res
      res := ProcessingInstruction()
      res.target := parse_pi_target()
      if any(SPACE) then {
         spaces()
         res.content := tab(find("?>")) | throw("Missing '?>'")
         check_is_char_data(res.content, "PI")
      }
      ="?>" | throw("'?>' expected")
      return res
   end

   #
   # [17] PITarget ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))
   #
   private parse_pi_target()
      local s
      s := parse_name()
      if map(s) == "xml" then
         throw("Can't have 'xml' here")
      return s
   end

   #
   # [18] CDSect ::= CDStart CData CDEnd
   # [19] CDStart ::= '<![CDATA['
   # [20] CData ::= (Char* - (Char* ']]>' Char*)) 
   # [21] CDEnd ::= ']]>'
   #
   # Assume "<![CDATA[" already matched.
   #
   private parse_cdsect()
      local res
      res := CData()
      res.content := tab(find("]]>")) | throw("No corresponding ']]>' in CDATA section")
      check_is_char_data(res.content, "CDATA")
      ="]]>"
      return res
   end

   #
   # [22] prolog ::= XMLDecl? Misc* (doctypedecl Misc*)?
   #
   private parse_prolog()
      if ="<?xml" then
         doc.add(parse_xml_decl())

      parse_misc_star()

      if ="<!DOCTYPE" then {
         doc.add(parse_doctype_decl())
         parse_misc_star()
      }

      return
   end

   #
   # [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
   #
   # Assume "<?xml" already matched
   #
   private parse_xml_decl() 
      local res
      res := XmlDecl()
      res.version := parse_version_info()

      if looking_at_space_then("encoding") then
         res.encoding := parse_encoding_decl()

      if looking_at_space_then("standalone") then
         res.standalone := parse_sdecl()

      opt_spaces()

      ="?>" | throw("'?>' expected")

      return res
   end

   #
   # [24] VersionInfo ::= S 'version' Eq ("'" VersionNum "'" | '"' VersionNum '"')
   #
   private parse_version_info()
      local c, res
      spaces()
      ="version" | throw("'version' expected")

      parse_eq()

      c := tab(any('\'\"')) | throw("\' or \" expected")

      res := parse_version_num()

      if not(=c) then
         throw(c || " expected")

      return res
   end

   #
   # [25] Eq ::= S? '=' S?
   #
   private parse_eq()
      opt_spaces()
      ="=" | throw("'=' expected")
      opt_spaces()
      return
   end      

   #
   # [26] VersionNum ::= ([a-zA-Z0-9_.:] | '-')+
   #
   private parse_version_num()
      local c
      c := 'a-zA-Z0-9_.:\-'
      any(c) | throw("Expected " || image(c))
      return tab(many(c))
   end

   #
   # Misc*
   # [27] Misc ::= Comment | PI | S
   #
   private parse_misc_star()
      repeat {
         if ="<!--" then
            parse_and_maybe_add_comment(doc)
         else if ="<?" then
            doc.add(parse_pi())
         else if any(SPACE) then
            spaces()
         else
            break
      }
      return
   end

   #
   # Parse and add a comment to the parent node, but only if the
   # preserve_comments_flag is set.
   #
   private parse_and_maybe_add_comment(parent)
      local c

      c := parse_comment()

      if \preserve_comments_flag then
         parent.add(c)

      return c
   end

   #
   # [28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S? ('[' (markupdecl | DeclSep)* ']' S?)? '>'
   #
   # Assume "<!DOCTYPE" already matched.
   #
   private parse_doctype_decl()
      local res, r
      res := DocType()
      spaces()
      res.name := parse_name()
      if looking_at_space_then("SYSTEM" | "PUBLIC") then {
         spaces()
         res.external_id := parse_external_id(res)
      }
      opt_spaces()
      if ="[" then {
         parse_markup_decls(res)
         ="]" | throw("']' expected")
         opt_spaces()
      }
      =">" | throw("'>' expected")

      if \res.external_id then {
         # Resolve and parse the external subset 
         r := resolve(current_base, res.external_id)
         start_divert(r.base, to_string(res.external_id))
         in_ext_subset := &yes
         r.content ? {
            parse_ext_subset()
            pos(0) | throw("Extraneous content")
         }
         in_ext_subset := &null
         end_divert()
      } 

      return res
   end

   #
   # Parse (markupdecl | DeclSep) *
   #
   # [28a] DeclSep ::= PEReference | S
   # [29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl | NotationDecl | PI | Comment 
   #
   private parse_markup_decls()
      local ref, o, r
      repeat {
         if ="<!ELEMENT" then
            parse_element_decl()
         else if ="<!ATTLIST" then
            parse_attlist_decl()
         else if ="<!ENTITY" then
            parse_entity_decl()
         else if ="<!NOTATION" then
            parse_notation_decl()
         else if ="<?" then
            doc.add(parse_pi())
         else if ="<!--" then
            parse_and_maybe_add_comment(doc)
         else if any('%') then {
            # Recursively parse the value of the pe.
            ref := parse_pe_reference()
            o := lookup_pe_reference(ref)
            if \o.str then { 
               start_divert(current_base, "macro")
               o.str ? {
                  parse_markup_decls()
                  pos(0) | throw("Extraneous content")
               }
               end_divert()
            } else {
               if \o.notation then
                  throw("Unparsed entity not allowed")
               # Resolve the external entity, parse it appropriately.
               r := resolve(current_base, o.external_id)
               start_divert(r.base, to_string(o.external_id))
               r.content ? {
                  parse_markup_decls()
                  pos(0) | throw("Extraneous content")
               }
               end_divert()
            }
         } else if any(SPACE) then
            spaces()
         else 
            break
      }
      return
   end
   
   #
   # [30] extSubset ::= TextDecl? extSubsetDecl
   #
   private parse_ext_subset()
      if ="<?xml" then
         parse_text_decl()
      return parse_ext_subset_decl()
   end

   #
   # [31] extSubsetDecl ::= ( markupdecl | conditionalSect | DeclSep)*
   #
   private parse_ext_subset_decl()
      local ref, o, r
      repeat {
         if ="<![" then
            parse_conditional_sect()
         else if ="<!ELEMENT" then
            parse_element_decl()
         else if ="<!ATTLIST" then
            parse_attlist_decl()
         else if ="<!ENTITY" then
            parse_entity_decl()
         else if ="<!NOTATION" then
            parse_notation_decl()
         else if ="<?" then
            doc.add(parse_pi())
         else if ="<!--" then
            parse_and_maybe_add_comment(doc)
         else if any('%') then {
            # Recursively parse the value of the pe.
            ref := parse_pe_reference()
            o := lookup_pe_reference(ref)
            if \o.str then { 
               start_divert(current_base, "macro")
               o.str ? {
                  parse_ext_subset_decl()
                  pos(0) | throw("Extraneous content")
               }
               end_divert()
            } else {
               if \o.notation then
                  throw("Unparsed entity not allowed")
               # Resolve the external entity, parse it appropriately.
               r := resolve(current_base, o.external_id)
               start_divert(r.base, to_string(o.external_id))
               r.content ? {
                  parse_ext_subset_decl()
                  pos(0) | throw("Extraneous content")
               }
               end_divert()
            }
         } else if any(SPACE) then
            spaces()
         else 
            break
      }
      return
   end

   #
   # [32] SDDecl ::= S 'standalone' Eq (("'" ('yes' | 'no') "'") | ('"' ('yes' | 'no') '"')) 
   #
   private parse_sdecl()
      local c, res
      spaces()
      ="standalone" | throw("'standalone' expected")

      parse_eq()

      c := tab(any('\'\"')) | throw("\' or \" expected")

      res := ="yes" | ="no" | throw("'yes' or 'no' expected")

      if res == "yes" then
         doc.standalone := &yes

      if not(=c) then
         throw(c || " expected")

      return res
   end

   #
   # [39] element ::= EmptyElemTag | STag content ETag
   # [40] STag ::= '<' Name (S Attribute)* S? '>'
   # [44] EmptyElemTag ::= '<' Name (S Attribute)* S? '/>'
   #
   private parse_element(parent_el)
      local res, attlist, xs
      res := XmlElement()
      ="<" | throw("'<' expected")
      res.name := parse_name()

      #
      # Get a reference to the attlist for this element.  This is convenient here
      # to avoid doing it many times during parse_attribute()'s call to
      # normalize_attvalue.
      #
      attlist := doc.attribute_lists[res.name]

      while looking_at_space_then_cset(NAME_START) do {
         spaces()
         parse_attribute(res, attlist)
      }
      opt_spaces()

      #
      # Validate the attributes
      #
      if \validate_flag then
         validate_attributes(res)

      #
      # Process the xml:space attribute.
      #
      if xs := member(res.attributes, "xml:space" | u"xml:space") then {
         if xs == "preserve" then
            res.xml_space_preserve := &yes
         else if xs ~== "default" then
            throw("xml:space has invalid value")
      } else {
         #
         # Not present, so the value is inherited from the parent
         #
         res.xml_space_preserve := (\parent_el).xml_space_preserve
      }

      if =">" then {
         parse_content(res)
         parse_etag(res)
      } else {
         ="/>" | throw("'>' or '/>' expected")
      }

      #
      # By default the whitespace_children is the same as the children, but validation
      # may change this by removing "insignificant" whitespace.
      #
      res.whitespace_children := res.children

      if \validate_flag then
         validate_children(res)

      return res
   end

   #
   # [41] Attribute ::= Name Eq AttValue
   #
   private parse_attribute(el, attlist)
      local att, val, attdef
      att := parse_name()
      parse_eq()

      #
      # Try to get the AttributeDef for this attribute.  
      #
      attdef := (\attlist).attribute_defs[att]

      val := normalize_attvalue(parse_attvalue(), attdef)
      if member(el.attributes, att) then
         throw("Duplicated attribute declaration: " || att)
      insert(el.attributes, att, val)
      return
   end

   #
   # [42] ETag ::= '</' Name S? '>'
   #
   private parse_etag(el)
      local t
      ="</" | throw("'</' expected")
      t := parse_name()
      t == el.name | throw("Mismatched tags: " || el.name || " expected")
      opt_spaces()
      =">" | throw("'>' expected")
      return
   end

   #
   # [43] content ::= CharData? ((element | Reference | CDSect | PI | Comment) CharData?)*
   # [14] CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)
   #
   private parse_content(parent, circle)
      local r, o, c2, ref, cd

      until pos(0) do {
         if any('&') then {
            if match("&#") then
               parent.add_string(parse_char_ref(&yes))
            else {
               ref := parse_entity_ref()
               if member(\circle, ref) then
                  throw("Circular entity replacement")
               c2 := copy(\circle) | set()
               insert(c2, ref)
               o := lookup_entity_ref(ref)
               #
               # If standalone "yes", then can't reference the entity if it was defined in the external subset
               #
               if \doc.standalone & \o.in_ext_subset then
                  throw("Cannot reference an entity declared externally, in a standalone document")
               if \o.str then { 
                  # Simple expansion, parsed as content.
                  start_divert(current_base, "macro")
                  o.str ? {
                     parse_content(parent, c2)
                     pos(0) | throw("Extraneous content")
                  }
                  end_divert()
               } else {
                  if \o.notation then
                     throw("Unparsed entity not allowed")
                  # Resolve the external entity, parse it appropriately.
                  r := resolve(current_base, o.external_id)
                  start_divert(r.base, to_string(o.external_id))
                  r.content ? {
                     parse_external_parsed_entity(parent, c2)
                     pos(0) | throw("Extraneous content")
                  }
                  end_divert()
               }
            }
         } else if ="<!--" then
            parse_and_maybe_add_comment(parent)
         else if ="<?" then
            parent.add(parse_pi())
         else if ="<![CDATA[" then
            parent.add(parse_cdsect())
         else if any('<') then {
            if match("</") then
               break
            parent.add(parse_element(parent))
         } else {
            #
            # Must have more chars and initially not a < or an &
            #
            cd := tab(many(~'<&'))
            if find("]]>", cd) then
               throw("Cannot have ']]>' in character content")

            check_is_char_data(cd, "content character data")

            parent.add_string(cd)
         }
      }
      return parent
   end

   private check_is_char_data(s, msg)
      local j
      if j := upto(INVALID_CHAR, s) then
         throw("Invalid char (" || image(s[j]) || ") in " || msg)
      return
   end

   #
   # [45] elementdecl ::=  '<!ELEMENT' S Name S contentspec S? '>'
   #
   # Assume "<!ELEMENT" already matched
   #
   private parse_element_decl()
      local name, content_spec, element_decl

      dtd_spaces()
      name := dtd_parse_name()
      dtd_spaces()
      content_spec := parse_content_spec()
      dtd_opt_spaces()
      =">" | throw("'>' expected")
      element_decl := ElementDecl()
      element_decl.in_ext_subset := in_ext_subset
      element_decl.content_spec := content_spec
      if member(doc.element_declarations, name) then
         invalid("Multiple element declarations for element " || name)
      else
         insert(doc.element_declarations, name, element_decl)
      return 
   end

   #
   # [46] contentspec ::= 'EMPTY' | 'ANY' | Mixed | children 
   #
   private parse_content_spec()
      local a, i
      if dtd_tabmat("EMPTY") then
         return ContentSpec("EMPTY")
      else if dtd_tabmat("ANY") then {
         a := ContentSpec("ANY")
         a.is_mixed_flag := &yes
         return a
      }
      else if dtd_match("(") then {
         # Awkward lookahead.
         i := &pos
         if dtd_tabmat("(") & tab(dtd_many0(SPACE)) & dtd_match("#PCDATA") then {
            &pos := i
            return parse_mixed()
         } else {
            &pos := i
            return parse_children()
         }
      } else
         throw("'EMPTY', 'ANY' or '(' expected")
   end

   #
   # [47] children ::= (choice | seq) ('?' | '*' | '+')?
   #
   private parse_children()
      local x, op
      x := parse_choiceseq()
      return if op := tab(dtd_any('?*+')) then
         ContentSpec(string(op), x)
      else
         x
   end

   #
   # [48] cp ::= (Name | choice | seq) ('?' | '*' | '+')?
   #
   private parse_cp()
      local x, op

      if dtd_any('(') then
         x := parse_choiceseq()
      else if dtd_any(NAME_START) then
         x := ContentSpec("name", dtd_parse_name())
      else
         throw("Name or ( expected")
      return if op := tab(dtd_any('?*+')) then
         return ContentSpec(string(op), x)
      else
         x
   end

   #
   # [49] choice ::= '(' S? cp ( S? '|' S? cp )+ S? ')'
   # [50] seq ::= '(' S? cp ( S? ',' S? cp )* S? ')'
   #
   private parse_choiceseq()
      local res, op, a, t

      dtd_tabmat("(") | throw("'(' expected")
      dtd_opt_spaces()
      a := parse_cp()
      dtd_opt_spaces()

      if op := tab(dtd_any('|,')) then {
         res := t := ContentSpec(string(op), a)
         repeat {
            dtd_opt_spaces()
            a := parse_cp()
            dtd_opt_spaces()
            dtd_tabmat(op) | break
            t.arg2 := ContentSpec(string(op), a)
            t := t.arg2
         }
         t.arg2 := a
      } else
         res := a

      dtd_tabmat(")") | throw("')' expected")
      return res
   end

   #
   # [51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? Name)* S? ')*' | '(' S? '#PCDATA' S? ')' 
   # Converts to a string with spaces removed.
   #
   private parse_mixed()
      local res, t, a, seen, n

      dtd_tabmat("(") | throw("( expected")
      dtd_opt_spaces()
      a := ContentSpec(string(dtd_tabmat("#PCDATA"))) | throw("'#PCDATA' expected")
       
      dtd_opt_spaces()

      seen := set()

      if dtd_tabmat("|") then {
         res := t := ContentSpec("|", a)
         repeat {
            dtd_opt_spaces()
            n := dtd_parse_name()
            if member(seen, n) then
               invalid("Name " || n || " appeared multiple times in mixed content spec")
            else
               insert(seen, n)
            a := ContentSpec("name", n)
            dtd_opt_spaces()
            dtd_tabmat("|") | break
            t.arg2 := ContentSpec("|", a)
            t := t.arg2
         }
         t.arg2 := a

         dtd_tabmat(")*") | throw("')*' expected")
         a := ContentSpec("*", res)
      } else {
         dtd_tabmat(")") | throw("')' expected")
         if dtd_tabmat("*") then
            a :=  ContentSpec("*", a)
      }

      a.is_mixed_flag := &yes

      return a
   end

   #
   # [52] AttlistDecl ::= '<!ATTLIST' S Name AttDef* S? '>'
   # [53] AttDef ::= S Name S AttType S DefaultDecl
   #
   # Assume "<!ATTLIST" already matched.
   #
   private parse_attlist_decl()
      local element_name, t, attr_name, attribute_def, res
      dtd_spaces()
      element_name := dtd_parse_name()
      #
      # See if we already have an AttList defined for this element.  If so,
      # new AttDefs are merged into it.  In any case, multiple defs generate
      # a warning.
      #
      if t := member(doc.attribute_lists, element_name) then
         warn("Multiple ATTLIST definitions for element " || element_name)
      else {
         t := AttList()
         insert(doc.attribute_lists, element_name, t)
      }

      repeat {
         dtd_looking_at_space_then_cset(NAME_START) | break
         dtd_spaces()
         attr_name := dtd_parse_name()
         dtd_spaces()
         attribute_def := AttributeDef()
         attribute_def.pos := where()
         attribute_def.in_ext_subset := in_ext_subset
         parse_att_type(attribute_def)
         dtd_spaces()
         parse_default_decl(attribute_def)

         # Check for multiple IDs
         if attribute_def.def_type == "ID" & \t.has_id then
            invalid("Multiple ID declarations for this element type")

         #
         # Second and subsequent definitions are ignored, but this generates a warning.
         #
         if member(t.attribute_defs, attr_name) then
            warn("Multiple attribute defs for attribute " || attr_name || " in element " || element_name)
         else
            t.add_attribute_def(attr_name, attribute_def)
      }
      dtd_opt_spaces()
      dtd_tabmat(">") | throw("'>' expected")

      return res
   end

   #
   # [54] AttType ::= StringType | TokenizedType | EnumeratedType 
   # [55] StringType ::= 'CDATA'
   # [56] TokenizedType ::= 'ID' | 'IDREF'| 'IDREFS' | 'ENTITY' | 'ENTITIES' | 'NMTOKEN' | 'NMTOKENS'
   # [57] EnumeratedType ::= NotationType | Enumeration 
   #
   private parse_att_type(attribute_def)
      local s

      if s := dtd_tabmat("CDATA" | "IDREFS" | "IDREF"| "ID" | "ENTITY" | "ENTITIES" | "NMTOKENS" | "NMTOKEN") then
         attribute_def.def_type := string(s)
      else if dtd_match("NOTATION") then {
         attribute_def.def_type := "NOTATION"
         attribute_def.def_set := parse_notation_type()
      } else if dtd_any('(') then {
         attribute_def.def_type := "ENUMERATION"
         attribute_def.def_set := parse_enumeration()
      } else
         throw("Syntax error")

      return attribute_def
   end

   #
   # [58] NotationType ::= 'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')' 
   #
   private parse_notation_type()
      local res, t

      res := set()
      dtd_tabmat("NOTATION") | throw("'NOTATION' expected")
      dtd_spaces()
      dtd_tabmat("(") | throw("'(' expected")
      repeat {
         dtd_opt_spaces()
         t := dtd_parse_name()
         if member(res, t) then
            invalid("Duplicated name in notation enumeration declaration: " || t)
         insert(res, t)
         dtd_opt_spaces()
         dtd_tabmat("|") | break
      }
      opt_spaces()
      dtd_tabmat(")") | throw("')' expected")

      return res
   end

   #
   # [59] Enumeration ::= '(' S? Nmtoken (S? '|' S? Nmtoken)* S? ')'
   #
   private parse_enumeration()
      local res, t

      res := set()
      dtd_tabmat("(") | throw("'(' expected")
      repeat {
         dtd_opt_spaces()
         t := dtd_parse_nmtoken()
         if member(res, t) then
            invalid("Duplicated token in enumeration declaration: " || t)
         insert(res, t)
         dtd_opt_spaces()
         dtd_tabmat("|") | break
      }
      dtd_opt_spaces()
      dtd_tabmat(")") | throw("')' expected")

      return res
   end

   #
   # [60] DefaultDecl ::= '#REQUIRED' | '#IMPLIED' | (('#FIXED' S)? AttValue)
   #
   private parse_default_decl(attribute_def)
      local s, val
      if s := dtd_tabmat("#REQUIRED" | "#IMPLIED") then
         attribute_def.default_decl := string(s)
      else {
         if s := dtd_tabmat("#FIXED") then {
            attribute_def.default_decl := string(s)
            dtd_spaces()
         }
         val := attribute_def.default_value := normalize_attvalue(parse_attvalue(), attribute_def)

         if attribute_def.def_type == "ID" then
            invalid("An attribute with type ID must have a default declaration of #IMPLIED or #REQUIRED")

         #
         # Validate default value
         #
         case attribute_def.def_type of {
            "CDATA" : {
            }
            "ID" : {
               valid_name(val) |
                  invalid("Default attribute value " || val || " must be a valid name")
            }
            "IDREF" : {
               valid_name(val) |
                  invalid("Default attribute value " || val || " must be a valid name")
            }
            "IDREFS" : {
               valid_names(val) |
                  invalid("Default attribute value " || val || " must be comprised of valid names")
            }
            "ENTITY" : {
               valid_name(val) |
                  invalid("Default attribute value " || val || " must be a valid name")
            }
            "ENTITIES" : {
               valid_names(val) |
                  invalid("Default attribute value " || val || " must be comprised of valid names")
            }
            "NMTOKEN" : {
               valid_nmtoken(val) |
                  invalid("Default attribute value " || val || " must be a valid nmtoken")
            }
            "NMTOKENS" : {
               valid_nmtokens(val) |
                  invalid("Default attribute value " || val || " must be comprised of valid nmtokens")
            }
            "ENUMERATION" : { 
               if not(member(attribute_def.def_set, val)) then
                  invalid("Default attribute value " || val || " is not one of the declared enumerations")
            }
            "NOTATION" : { 
               if not(member(attribute_def.def_set, val)) then
                  invalid("Default attribute value " || val || " is not one of the declared notations")
            }
         }
      }
      return attribute_def
   end

   #
   # [61] conditionalSect ::= includeSect | ignoreSect 
   # [62] includeSect ::= '<![' S? 'INCLUDE' S? '[' extSubsetDecl ']]>' 
   # [63] ignoreSect ::= '<![' S? 'IGNORE' S? '[' ignoreSectContents* ']]>'
   #
   # Assume "<![" already matched.
   #
   private parse_conditional_sect()
      dtd_opt_spaces()
      if dtd_tabmat("INCLUDE") then {
         dtd_opt_spaces()
         dtd_tabmat("[") | throw("'[' expected")
         parse_ext_subset_decl()
      } else if dtd_tabmat("IGNORE") then {
         dtd_opt_spaces()
         dtd_tabmat("[") | throw("'[' expected")
         parse_ignore_sect_contents()
      } else 
         throw("'INCLUDE' or 'IGNORE' expected")

      dtd_tabmat("]]>") | throw("']]>' expected")

      return
   end

   #
   # [64] ignoreSectContents ::= Ignore ('<![' ignoreSectContents ']]>' Ignore)*
   # [65] Ignore ::= Char* - (Char* ('<![' | ']]>') Char*) 
   #
   private parse_ignore_sect_contents()
      repeat {
         tab(upto('<]')) | throw("Ignore section not closed")
         if match("]]>") then 
            return
         else if ="<![" then {
            parse_ignore_sect_contents()
            ="]]>" | throw("']]>' expected")
         } else
            move(1)
      }
   end

   #
   # [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'
   # [2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
   #
   private parse_char_ref(expand)
      local digs, i, j
      j := &pos
      ="&#" | throw("'&#' expected")
      if ="x" then {
         digs := tab(many('0-9a-fA-F')) | throw("Hex digit expected")
         i := Format.string_to_int(digs)
      } else {
         digs := tab(many(&digits)) | throw("Digit expected")
         i := integer(digs)
      }
      =";" | throw("';' expected")

      if /expand then
         return &subject[j:&pos]
      else {
         if Text.has_ord(CHAR, i) then {
            return if \utf8_flag then
               uchar(i)
            else
               char(256 > i | 63)
         }
         throw("Invalid char number: " || digs)
      }
   end

   #
   # [67] Reference ::= EntityRef | CharRef
   #
   private parse_reference()
      if match("&#") then
         return parse_char_ref()
      if any('&') then
         return parse_entity_ref()
      else
         throw("'&' expected")
   end

   #
   # [68] EntityRef ::= '&' Name ';'
   #
   private parse_entity_ref()
      local res
      res := ="&" | throw("'&' expected")
      res ||:= parse_name()
      res ||:= =";" | throw("';' expected")
      return res
   end

   #
   # [69] PEReference ::= '%' Name ';'
   #
   private parse_pe_reference()
      local res
      res := ="%" | throw("'%' expected")
      res ||:= parse_name()
      res ||:= =";" | throw("';' expected")
      return res
   end

   #
   # Lookup a pe in the table, returning its value.
   #
   private lookup_pe_reference(s)
      local name
      name := s[2:-1]
      return member(doc.parameter_entities, name) |
         throw("No such parameter entity defined: " || name)
   end

   #
   # Lookup a general entity in the table, returning its value.
   #
   private lookup_entity_ref(s)
      local name
      name := s[2:-1]
      return member(doc.general_entities, name) |
         throw("No such general entity defined: " || name)
   end

   #
   # Convenience method to take a value from one of the entity tables and return it
   # as a string, resolving it externally if necessary.
   #
   private resolve_entity(o)
      if \o.str then
         return o.str
      if \o.notation then
         throw("Unparsed entity not allowed")
      # Resolve with base set to the current_base of the place where defined.
      return resolve(o.pos[1].base, o.external_id).content
   end

   #
   # [70] EntityDecl ::= GEDecl | PEDecl
   # [71] GEDecl ::= '<!ENTITY' S Name S EntityDef S? '>'
   # [72] PEDecl ::= '<!ENTITY' S '%' S Name S PEDef S? '>'
   #
   # Assume "<!ENTITY" already matched.
   #
   private parse_entity_decl()
      local name, val
      #
      # This could be more sophisticated to try to cover for example
      # <!ENTITY%x; abc 'def >   where %x -> ' %'
      #
      spaces()
      if ="%" then {
         dtd_spaces()
         name := dtd_parse_name()
         dtd_spaces()
         val := parse_pe_def()
         # Second and subsequent definitions generate a warning, and are ignored.
         if member(doc.parameter_entities, name) then
            warn("Multiple parameter entity definitions for " || name)
         else
            insert(doc.parameter_entities, name, val)
      } else {
         name := dtd_parse_name()
         dtd_spaces()
         val := parse_entity_def()
         # Second and subsequent definitions generate a warning, and are ignored.
         if member(doc.general_entities, name) then
            warn("Multiple parameter entity definitions for " || name)
         else
            insert(doc.general_entities, name, val)
      }         
      dtd_opt_spaces()
      dtd_tabmat(">") | throw("'>' expected")
      return
   end

   #
   # [73] EntityDef ::= EntityValue | (ExternalID NDataDecl?)
   # return a string or an ExternalID
   #
   private parse_entity_def()
      local res

      res := EntityDef()
      res.pos := where()
      res.in_ext_subset := in_ext_subset
      if dtd_match("SYSTEM" | "PUBLIC") then {
         res.external_id := parse_external_id()
         if looking_at_space_then("NDATA") then
            res.notation := parse_ndata_decl()
      } else 
         res.str := parse_entity_value()
      return res
   end
   
   #
   # [74] PEDef ::= EntityValue | ExternalID
   # return a string or an ExternalID
   #
   private parse_pe_def()
      local res
         
      res := EntityDef()
      res.pos := where()
      res.in_ext_subset := in_ext_subset
      if dtd_match("SYSTEM" | "PUBLIC") then
         res.external_id := parse_external_id()
      else 
         res.str := parse_entity_value()
      return res
   end

   #
   #
   # [75] ExternalID ::= 'SYSTEM' S SystemLiteral | 'PUBLIC' S PubidLiteral S SystemLiteral 
   #
   private parse_external_id()
      local res
      res := ExternalID()
      if dtd_tabmat("SYSTEM") then {
         dtd_spaces()
         res.system_id := parse_system_literal()
      } else if dtd_tabmat("PUBLIC") then {
         dtd_spaces()
         res.public_id := parse_pubid_literal()
         dtd_spaces()
         res.system_id := parse_system_literal()
      } else
         throw("SYSTEM or PUBLIC expected")
      return res
   end

   #
   # [76] NDataDecl ::= S 'NDATA' S Name
   #
   private parse_ndata_decl()
      local n
      dtd_spaces()
      dtd_tabmat("NDATA") | throw("'NDATA' expected")
      dtd_spaces()
      n := dtd_parse_name()
      return n
   end

   #
   # [77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'
   #
   # Assume "<?xml" already matched.
   #
   private parse_text_decl()
      if looking_at_space_then("version") then
         parse_version_info()
      
      parse_encoding_decl()

      opt_spaces()

      ="?>" | throw("'?>' expected")

      return
   end

   #
   # [78] extParsedEnt ::= TextDecl? content
   #
   private parse_external_parsed_entity(parent, circle)
      if ="<?xml" then
         parse_text_decl()
      return parse_content(parent, circle)
   end

   #
   # [80] EncodingDecl ::= S 'encoding' Eq ('"' EncName '"' | "'" EncName "'" ) 
   #
   private parse_encoding_decl()
      local c, res
      spaces()
      ="encoding" | throw("'encoding' expected")

      parse_eq()

      c := tab(any('\'\"')) | throw("\' or \" expected")

      res := parse_enc_name()

      if not(=c) then
         throw(c || " expected")

      return res
   end

   #
   # [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
   #
   private parse_enc_name()
      local c1, c2
      c1 := 'A-Za-z'
      c2 := 'A-Za-z0-9._\-'
      any(c1) | throw("Letter expected")
      return tab(many(c2))
   end

   #
   # [82] NotationDecl ::= '<!NOTATION' S Name S (ExternalID | PublicID) S? '>'
   # [83] PublicID ::= 'PUBLIC' S PubidLiteral 
   #
   # Assume "<!NOTATION" already matched.
   #
   private parse_notation_decl()
      local res, name, pub, sys
      res := NotationDecl()
      dtd_spaces()
      name := dtd_parse_name()
      dtd_spaces()
      if dtd_tabmat("PUBLIC") then {
         dtd_spaces()
         pub := parse_pubid_literal()
         if looking_at_space_then_cset('\'\"') then {
            dtd_spaces()
            sys := parse_system_literal()
            res.external_id := ExternalID(sys, pub)
         } else
            res.public_id := pub
      } else if dtd_match("SYSTEM") then
         res.external_id := parse_external_id()
      else
         throw("SYSTEM or PUBLIC expected")
      dtd_opt_spaces()
      dtd_tabmat(">") | throw("'>' expected")

      /doc.notation_declarations[name] := res

      return res
   end

   #
   # S?
   #
   private opt_spaces()
      return if any(SPACE) then
         spaces()
      else
         ""
   end

   private dtd_opt_spaces()
      return if dtd_any(SPACE) then
         dtd_spaces()
      else
         ""
   end

   #
   # Validate the given element child content; this may fail on error or just emit a warning
   #
   private validate_children(el) 
      local element_decl, tl

      #
      # Validate the element structure
      #
      if not member(doc.element_declarations, el.name) then {
         invalid(el.name || " is an undeclared element name")
         return 
      }

      element_decl := doc.element_declarations[el.name]

      #
      # If the spec isn't a mixed spec (ie one which contains #PCDATA),
      # then we remove all whitespace-only string elements in the child list.
      #
      if element_decl.content_spec.isnt_mixed() then {
         #
         # Possibly change children to be a new list with the whitespace-only
         # element removed.
         #
         tl := el.get_children_no_whitespace()
         if *tl ~= *el.children then {
            el.children := tl
            #
            # A standalone document is not allowed to have w/s removed for an element
            # when that occurs as a result of a ELEMENT declaration in an external subset.
            #
            if \doc.standalone & \element_decl.in_ext_subset then
               invalid(el.name || " had insignificant whitespace removed in a standalone document")
         }
      }

      if not(element_decl.content_spec.pattern_match_element(el)) then
         invalid(el.name || " does not match the declared pattern : " || to_string(element_decl.content_spec))

      #
      # If appropriate, put the children back to equal to the original whitespace_children;
      # the former may have changed above.
      #
      if \el.xml_space_preserve | \self.preserve_insignificant_whitespace_flag then {
         el.children := el.whitespace_children
      }
   end

   #
   # Validate the attributes of an element
   #
   private validate_attributes(el)
      local attlist, x

      if not(member(doc.attribute_lists, el.name)) then {
         if *el.attributes ~= 0 then
            invalid(el.name || " has attributes but none were declared")
         return
      }

      #
      # The AttList for this particular element type.
      #
      attlist := doc.attribute_lists[el.name]

      #
      # Check for any missing required attributes, and add any default attributes.
      #
      every x := !sort(attlist.attribute_defs) do {
         if member(el.attributes, x[1]) then {
            # A #FIXED attribute value must match the default.
            if x[2].default_decl === "#FIXED" then {
               if el.attributes[x[1]] ~=== x[2].default_value then
                  invalid("Attribute value " || el.attributes[x[1]] || " doesn't match the defined FIXED value " || x[2].default_value)
            }
         } else {
            # A #REQUIRED attribute must be present.
            if x[2].default_decl === "#REQUIRED" then
               invalid("The attribute " || x[1] || " is required, but not present")
            else {
               # Cannot insert a default from an attdef defined in the external subset, if standalone is "yes"
               if \doc.standalone & \x[2].in_ext_subset then
                  invalid("Cannot use a default from an attribute declared externally, in a standalone document")
               # Insert any default value.
               insert(el.attributes, x[1], \x[2].default_value)
            }
         }       
      }

      #
      # Validate each of the attributes values.
      #
      every x := !sort(el.attributes) do {
         if member(attlist.attribute_defs, x[1]) then {
            validate_attribute_value(el.name, attlist.attribute_defs[x[1]], x[1], x[2])
         } else {
            invalid(x[1] || " is not a defined attribute for element " || el.name)
         }
      }
   end

   private validate_attribute_value(element_name, attdef, name, val) 
      local l, entity_def, n
      case attdef.def_type of {
         "CDATA" : {
         }
         "ID" : {
            valid_name(val) |
               invalid("Attribute value " || val || " must be a valid name")
            # Store the value of the id
            if member(doc.id_attribute_values, val) then
               invalid("Duplicated ID attribute value: " || val)
            else
               insert(doc.id_attribute_values, val)
         }
         "IDREF" : {
            valid_name(val) |
               invalid("Attribute value " || val || " must be a valid name")
            put(id_attribute_refs, IdAttributeRef(val, where()))
         }
         "IDREFS" : {
            if l := valid_names(val) then
               every put(id_attribute_refs, IdAttributeRef(!l, where()))
            else
               invalid("Attribute value " || val || " must be comprised of valid names")
         }
         "ENTITY" : {
            if valid_name(val) then {
               if member(doc.general_entities, val) then {
                  entity_def := doc.general_entities[val]
                  if /entity_def.notation then
                     invalid("Attribute val " || val || " does not match an external entity")
               } else
                  invalid("Attribute val " || val || " does not match an external entity")
            } else
               invalid("Attribute value " || val || " must be a valid name")
         }
         "ENTITIES" : {
            if l := valid_names(val) then {
               every n := !l do {
                  if member(doc.general_entities, n) then {
                     entity_def := doc.general_entities[n]
                     if /entity_def.notation then
                        invalid("Attribute val " || n || " does not match an external entity")
                  } else
                     invalid("Attribute val " || n || " does not match an external entity")
               }
            } else
               invalid("Attribute value " || val || " must be comprised of valid names")
         }
         "NMTOKEN" : {
            valid_nmtoken(val) |
               invalid("Attribute value " || val || " must be a valid nmtoken")
         }
         "NMTOKENS" : {
            valid_nmtokens(val) |
               invalid("Attribute value " || val || " must be comprised of valid nmtokens")
         }
         "ENUMERATION" : { 
            if not(member(attdef.def_set, val)) then
               invalid("Attribute value " || val || " is not one of the declared enumerations")
         }
         "NOTATION" : { 
            if not(member(attdef.def_set, val)) then
               invalid("Attribute value " || val || " is not one of the declared notations")
         }
      }
   end

   private start_divert(base, id) 
      push(divert_stack, Diversion(current_base, current_divert_id, &subject, &pos))
      current_divert_id := id
      current_base := base
   end

   private end_divert()
      local t
      t := pop(divert_stack)
      current_divert_id := t.id
      current_base := t.base
   end

   private where()
      local stack
      stack := copy(divert_stack)
      push(stack, Diversion(current_base, current_divert_id, &subject, &pos))
      return stack
   end

   #
   # A warning
   #
   private warn(s, loc)
      /loc := where()
      fire(WARNING_EVENT, ProblemDetail(loc, s))
      doc.warnings +:= 1
   end

   #
   # A validity error
   #
   private invalid(s, loc)
      # Ignore if not validating
      if /validate_flag then
         fail
      /loc := where()
      fire(VALIDITY_ERROR_EVENT, ProblemDetail(loc, s))
      doc.validity_errors +:= 1
   end

   #
   # Utility: succeed if we are looking at S s, fail otherwise.
   # Does not change &pos.
   #
   private looking_at_space_then(s)
      local res, i
      any(SPACE) | fail
      i := &pos
      tab(many(SPACE))
      res := match(s)
      &pos := i
      return \res
   end

   #
   # DTD version of above
   #
   private dtd_looking_at_space_then(s)
      local res, i
      dtd_any(SPACE) | fail
      i := &pos
      tab(dtd_many(SPACE))
      res := dtd_match(s)
      &pos := i
      return \res
   end

   #
   # As above, but looks for chars in the set.
   #
   private looking_at_space_then_cset(c)
      local res, i
      any(SPACE) | fail
      i := &pos
      tab(many(SPACE))
      res := any(c)
      &pos := i
      return \res
   end

   #
   # DTD version of above
   #
   private dtd_looking_at_space_then_cset(c)
      local res, i
      dtd_any(SPACE) | fail
      i := &pos
      tab(dtd_many(SPACE))
      res := dtd_any(c)
      &pos := i
      return \res
   end

   #
   # Equivalent to match(), but checks for pe expansions
   #
   private dtd_match(s)
      local i, x, c
      i := &pos
      repeat {
         if x := match(s) then
            return x
         every c := !s do
            =c | break
         try_dtd_insert(i) | fail
      }
   end

   #
   # Equivalent to =s, but checks for pe expansions
   #
   private dtd_tabmat(s)
      local i, x, c
      i := &pos
      repeat {
         if x := =s then
            return x
         every c := !s do
            =c | break
         try_dtd_insert(i) | fail
      }
   end
   
   #
   # Equivalent to any(), but checks for pe expansions
   #
   private dtd_any(c)
      local i, x
      i := &pos
      repeat {
         if x := any(c) then
            return x
         try_dtd_insert(i) | fail
      }
   end

   #
   # Equivalent to many(), but checks for pe expansions
   #
   private dtd_many(c)
      local i, x
      i := &pos
      repeat {
         if x := many(c) then {
            tab(x)
            try_dtd_insert(i) | return x
         }
         else
            try_dtd_insert(i) | fail
      }
   end

   #
   # Equivalent to many0(), but checks for pe expansions
   #
   private dtd_many0(c)
      return dtd_many(c) | .&pos
   end

   #
   # If the current char is %, try and insert a pe value.  If successful, return
   # otherwise fail.  &pos is always set to i on exit.
   #
   private try_dtd_insert(i)
      local j, t
      if any('%') then {
         if \in_ext_subset then {
            j := &pos
            t := resolve_entity(lookup_pe_reference(parse_pe_reference()))
            # The entity is expanded by one leading and one trailing space (4.4.8)
            &subject := &subject[1:j] || " " || t || " " || &subject[&pos:0]
            &pos := i
            return
         }
         # Only show an error once; this prevents the same error message
         # being produced several times.
         if /dtd_insert_shown_error then 
            invalid("Cannot reference a pe except in the external dtd")
         dtd_insert_shown_error := &yes
      }
      &pos := i
   end

   #
   # Resolve the given external_id, using the current resolver
   #
   private resolve(base, external_id)
      local t
      t := resolver.resolve(base, external_id)  | throw("Couldn't resolve: " || to_string(external_id) || ": " || &why)
      if \utf8_flag then
         t.content := ucs(t.content) | throw("Couldn't convert " || to_string(external_id) || " to UTF-8")
      t.content := normalize_eol(t.content)
      return t
   end

   #
   # This method post-processes the parsed tree to fill in the 
   # global names in the XmlElement structures.
   #
   private do_namespace_processing()
      local t
      
      t := table()
      if \utf8_flag then
         insert(t, u"xml", u"http://www.w3.org/XML/1998/namespace")
      else
         insert(t, "xml", "http://www.w3.org/XML/1998/namespace")

      return do_namespace_processing_element(t, doc.get_root_element())
   end

   #
   # Do namespace processing for a single element.
   # :Parameters :
   # :  `resolve_table` - a table of mappings from namespace prefixes
   #        to URI's to use for the conversion.
   # :Parameters :
   # :  `el` - the element to process
   #
   private do_namespace_processing_element(resolve_table, el)
      local k, sub
      #
      # Could be comment, cdata
      #
      if not is(el, Element) then
         return

      #
      # Make the map from namespace prefixes -> uri's
      #
      el.namespace_declarations := make_declarations_map(el)

      if *el.namespace_declarations > 0 then {
         #
         # Create a new resolve_table for this level.  It is a copy of the
         # parent, plus any defs at this level.
         #
         resolve_table := copy(resolve_table)
         every k := key(el.namespace_declarations) do {
            insert(resolve_table, k, el.namespace_declarations[k])
         }
      }

      #
      # Convert the element to create the global name and attribute
      # table.
      #
      convert_element(resolve_table, el)

      #
      # Process the children
      #
      every sub := !el.children do
         text(sub) | do_namespace_processing_element(resolve_table, sub)

      return el
   end

   #
   # Convert a single element.  This completes the global name field and
   # sets up the global attributes.
   #
   private convert_element(resolve_table, el)
      local k
      el.global_name := convert_name(resolve_table, el.name)

      every k := key(el.attributes) do {
         k ? {
            if ="xmlns" then {
               next
            }
            insert(el.attributes_global_name, 
                   convert_name(resolve_table, k), el.attributes[k])
         }
      }

      return
   end

   #
   # Given a name "eg SOAP-ENV:Envelope", return the global name, using the 
   # given resolve table for the conversion.  The returned value is a
   # GlobalName instance.
   #
   private convert_name(resolve_table, name)
      local prefix, local_name, uri

      name ? {
         if prefix := tab(upto(':')) then {
            move(1)
            local_name := tab(0)
            member(resolve_table, prefix) | throw("Couldn't resolve namespace: " || prefix)
            uri := resolve_table[prefix]
            return GlobalName(local_name, uri)
         }

         if uri := member(resolve_table, "") then {
            if *uri > 0 then
               return GlobalName(name, uri)
         }

         return GlobalName(name)
      }
   end

   # 
   # Make a map of namespace id's to uri's from the attributes in the
   # given element.  
   #
   private make_declarations_map(el)
      local k, uri, prefix, t

      t := table()

      every k := key(el.attributes) do {
         k ? {
            if ="xmlns" then {
               uri := el.attributes[k]
               if pos(0) then {
                  insert(t, "", uri)
               }
               else if =":" then {
                  prefix := tab(0)
                  if *prefix = 0 then
                     throw("Badly formed xmlns attribute: " || k)
                  if match("xml", map(prefix)) then
                     throw("xmlns namespace can't start with 'xml': " || k)
                  insert(t, prefix, uri)
               }
               else
                  throw("Badly formed xmlns attribute: " || k)
            }
         }
      }

      return t
   end

   private static init()
      #
      # [3] S ::= (#x20 | #x9 | #xD | #xA)+
      #
      SPACE := '\x20\x09\x0D\x0A'

      #
      # [2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | 
      #                     [#x10000-#x10FFFF]
      CHAR := '\x09\x0A\x0D\x20-\ud7ff\ue000-\ufffd\U10000-\U10ffff'
      INVALID_CHAR := ~CHAR

      #
      # [4] NameStartChar ::= ":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | 
      #                       [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | 
      #                       [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | 
      #                       [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
      NAME_START := 
        ':A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF_
         \u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF_
         \uFDF0-\uFFFD\U10000-\UEFFFF'

      #
      # [4a] NameChar ::= NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
      #
      NAME_CHAR := NAME_START ++ '\-.0-9\xB7\u0300-\u036F\u203F-\u2040'

      # [13] PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]
      PUBID_CHAR := '\x20\x0D\x0Aa-zA-Z0-9\-\'()+,./:=?;!*#@$_%'

      WARNING_EVENT := "Warning"
      VALIDITY_ERROR_EVENT := "Validity error"
      FATAL_ERROR_EVENT := "Fatal error"
   end

   public override new()
      Connectable.new()
      resolver := DefaultResolver()
      do_namespaces_flag := &yes
      validate_flag := &yes
      preserve_comments_flag := &yes
      return
   end
end
