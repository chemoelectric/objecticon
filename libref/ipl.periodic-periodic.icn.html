<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>periodic.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     periodic.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures related to periodic sequences
<a name="6"/>#
<a name="7"/>#	Author:   Ralph E. Griswold
<a name="8"/>#
<a name="9"/>#	Date:     June 10, 2001
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#  Sqrt(i, j) produces a rational approximation to the square root of i
<a name="14"/>#  with j iterations of the half-way method.  j defaults to 5.
<a name="15"/>#
<a name="16"/>############################################################################
<a name="17"/>#
<a name="18"/>#  Requires:  Large-integer arithmetic  
<a name="19"/>#
<a name="20"/>############################################################################
<a name="21"/>#
<a name="22"/>#  Links:  lists, numbers, rational, strings
<a name="23"/>#
<a name="24"/>############################################################################
<a name="25"/>
<a name="26"/>package ipl.periodic
<a name="27"/>
<a name="28"/>import
<a name="29"/>   ipl.lists(lequiv, lextend),
<a name="30"/>   util(Math),
<a name="31"/>   numbers(Rat)
<a name="32"/>
<a name="33"/>record perseq(pre, rep)
<a name="34"/>
<a name="35"/># rational approximate to square root
<a name="36"/>procedure Sqrt(i, j)		
<a name="37"/>   local rat, half
<a name="38"/>
<a name="39"/>   /j := 5
<a name="40"/>
<a name="41"/>   half := Rat(1, 2)
<a name="42"/>
<a name="43"/>   rat := Rat(integer(Math.sqrt(i)))	# initial approximation
<a name="44"/>
<a name="45"/>   i := Rat(i)
<a name="46"/>
<a name="47"/>   every 1 to j do
<a name="48"/>      rat := half.mul(rat.add(i.div(rat)))
<a name="49"/>
<a name="50"/>   return rat
<a name="51"/>
<a name="52"/>end
<a name="53"/>
<a name="54"/># continued fraction sequence for rational
<a name="55"/>procedure rat2cf(i, j)		
<a name="56"/>   local r, result
<a name="57"/>
<a name="58"/>   result := []
<a name="59"/>
<a name="60"/>   repeat {
<a name="61"/>     put(result, integer(i / j))
<a name="62"/>     r := i % j
<a name="63"/>     i := j
<a name="64"/>     j := r
<a name="65"/>     if j = 0 then break
<a name="66"/>     }
<a name="67"/>
<a name="68"/>   return perseq(result, [])
<a name="69"/>
<a name="70"/>end
<a name="71"/>
<a name="72"/># continued-fraction approximation
<a name="73"/>procedure cfapprox(lst)		
<a name="74"/>   local prev_n, prev_m, n, m, t
<a name="75"/>
<a name="76"/>   lst := copy(lst)
<a name="77"/>
<a name="78"/>   prev_n := [1]
<a name="79"/>   prev_m := [0, 1]
<a name="80"/>
<a name="81"/>   put(prev_n, get(lst).d) | fail
<a name="82"/>
<a name="83"/>   while t := get(lst) do {
<a name="84"/>      n := t.d * get(prev_n) + t.n * prev_n[1]
<a name="85"/>      m := t.d * get(prev_m) + t.n * prev_m[1]
<a name="86"/>      suspend Rat(n, m)
<a name="87"/>      put(prev_n, n)
<a name="88"/>      put(prev_m, m)
<a name="89"/>      if t.d ~= 0 then {		# renormalize
<a name="90"/>         every !prev_n /:= t.d
<a name="91"/>         every !prev_m /:= t.d
<a name="92"/>         }
<a name="93"/>      }
<a name="94"/>
<a name="95"/>end
<a name="96"/>
<a name="97"/># convert repeating decimal to rational
<a name="98"/>procedure dec2rat(pre, rep)	
<a name="99"/>   local s
<a name="100"/>
<a name="101"/>   s := ""
<a name="102"/>
<a name="103"/>   every s ||:= (!pre | |!rep) \ (*pre + *rep)
<a name="104"/>
<a name="105"/>   return Rat(s - left(s, *pre),
<a name="106"/>      10 ^ (*pre + *rep) - 10 ^ *pre)
<a name="107"/>
<a name="108"/>end
<a name="109"/>
<a name="110"/># decimal expansion of rational
<a name="111"/>procedure rat2dec(numer, denom)		
<a name="112"/>   local  result, remainders, count, seq
<a name="113"/>
<a name="114"/>   result := ""
<a name="115"/>
<a name="116"/>   remainders := table()
<a name="117"/>
<a name="118"/>   numer %:= denom
<a name="119"/>   numer *:= 10
<a name="120"/>
<a name="121"/>   count := 0
<a name="122"/>
<a name="123"/>   while numer &gt; 0 do {
<a name="124"/>      count +:= 1
<a name="125"/>      if member(remainders, numer) then {	# been here; done that
<a name="126"/>         seq := perseq()
<a name="127"/>         result ? {
<a name="128"/>            seq.pre := move(remainders[numer] - 1)
<a name="129"/>            seq.rep := tab(0)
<a name="130"/>            }
<a name="131"/>         return seq
<a name="132"/>         }
<a name="133"/>      else insert(remainders, numer, count)
<a name="134"/>      result ||:= numer / denom
<a name="135"/>      numer %:= denom
<a name="136"/>      numer *:= 10
<a name="137"/>      }
<a name="138"/>
<a name="139"/>   return perseq([denom], [])		# WRONG!!!
<a name="140"/>
<a name="141"/>end
<a name="142"/>
<a name="143"/># find repeat in sequence
<a name="144"/>procedure repeater(seq, ratio, limit)		
<a name="145"/>   local i, prefix, results, segment, span
<a name="146"/>
<a name="147"/>   /ratio := 2
<a name="148"/>   /limit := 0.75
<a name="149"/>
<a name="150"/>   results := copy(seq)
<a name="151"/>
<a name="152"/>   prefix := []
<a name="153"/>
<a name="154"/>   repeat {
<a name="155"/>      span := *results / ratio
<a name="156"/>      every i := 1 to span do {
<a name="157"/>         segment := results[1+:i] | next
<a name="158"/>         if lequiv(lextend(segment, *results), results) then
<a name="159"/>            return perseq(prefix, segment)
<a name="160"/>         }
<a name="161"/>      put(prefix, get(results)) |		# first term to prefix
<a name="162"/>         return perseq(prefix, results)
<a name="163"/>      if *prefix &gt; limit * *seq then return perseq(seq, [])
<a name="164"/>      }
<a name="165"/>
<a name="166"/>end
<a name="167"/>
<a name="168"/># sequence image
<a name="169"/>procedure seqimage(seq)		
<a name="170"/>   local result
<a name="171"/>
<a name="172"/>   result := ""
<a name="173"/>
<a name="174"/>   every result ||:= !seq.pre || ","
<a name="175"/>
<a name="176"/>   result ||:= "["
<a name="177"/>
<a name="178"/>   if *seq.rep &gt; 0 then {
<a name="179"/>      every result ||:= !seq.rep || ","
<a name="180"/>      result[-1] := "]"
<a name="181"/>      }
<a name="182"/>   else result ||:= "]"
<a name="183"/>
<a name="184"/>   return result
<a name="185"/>
<a name="186"/>end
</pre></body></html>
