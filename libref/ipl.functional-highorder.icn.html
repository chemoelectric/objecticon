<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>highorder.icn</title></head><body><pre>
<a name="1"/>package ipl.functional
<a name="2"/>
<a name="3"/>import
<a name="4"/>   lang(Class),
<a name="5"/>   util(need_string,need_callable),
<a name="6"/>   ipl.lists(lreverse_mod),
<a name="7"/>   ipl.pdco(List,Parallel),
<a name="8"/>   datastruct(EqTable,BuiltinTable)
<a name="9"/>
<a name="10"/>#
<a name="11"/># Implementation class for `partial`
<a name="12"/>#
<a name="13"/>package class Partial()
<a name="14"/>   private const
<a name="15"/>      f, spec, v
<a name="16"/>
<a name="17"/>   public call(a[])
<a name="18"/>      local e, c, r
<a name="19"/>      e := create !v
<a name="20"/>      r := []
<a name="21"/>      every c := !spec do {
<a name="22"/>         case c of {
<a name="23"/>            "v": put(r, @e | &amp;null)
<a name="24"/>            "V": while put(r, @e)
<a name="25"/>            "a": put(r, get(a) | &amp;null)
<a name="26"/>            "A": while put(r, get(a))
<a name="27"/>            "-": get(a)
<a name="28"/>            default: runerr("Invalid spec char to partial", c)
<a name="29"/>         }
<a name="30"/>      }
<a name="31"/>      suspend f!r
<a name="32"/>   end
<a name="33"/>
<a name="34"/>   public new(f, spec, v)
<a name="35"/>      self.f := f
<a name="36"/>      self.spec := spec
<a name="37"/>      self.v := v
<a name="38"/>      return
<a name="39"/>   end
<a name="40"/>end
<a name="41"/>
<a name="42"/># Returns a function which modifies its arguments according to `spec`,  before applying them
<a name="43"/># to f.  The modification is specified by the following characters in spec:-
<a name="44"/>#    "v": add the next value from the arguments which follow the spec
<a name="45"/>#         parameter, or `&amp;null` if none remain.
<a name="46"/>#    "V": add the remaining values.
<a name="47"/>#    "a": add the next argument, or `&amp;null` if none remain.
<a name="48"/>#    "A": add the remaining arguments.
<a name="49"/>#    "-": skip the next argument.
<a name="50"/>#
<a name="51"/># Example :-
<a name="52"/># ~
<a name="53"/>#     f := partial(write, "vvvAV", "a", "b", "c", "p", "q", "r")
<a name="54"/>#     f("x","y","z")   # writes abcxyzpqr
<a name="55"/># ~
<a name="56"/>procedure partial(f, spec, l[])
<a name="57"/>   return Partial(need_callable(f), need_string(spec), l).call
<a name="58"/>end
<a name="59"/>
<a name="60"/>#
<a name="61"/># Implementation class for `lpartial` and `rpartial`
<a name="62"/>#
<a name="63"/>package class LRPartial()
<a name="64"/>   private const
<a name="65"/>      f, x
<a name="66"/>
<a name="67"/>   public lcall(a[])
<a name="68"/>      suspend f!(x ||| a)
<a name="69"/>   end
<a name="70"/>
<a name="71"/>   public lcall1(a[])
<a name="72"/>      suspend f!push(a, x)
<a name="73"/>   end
<a name="74"/>
<a name="75"/>   public rcall(a[])
<a name="76"/>      suspend f!(a ||| x)
<a name="77"/>   end
<a name="78"/>
<a name="79"/>   public rcall1(a[])
<a name="80"/>      suspend f!put(a, x)
<a name="81"/>   end
<a name="82"/>
<a name="83"/>   public new(f, x)
<a name="84"/>      self.f := f
<a name="85"/>      self.x := x
<a name="86"/>      return
<a name="87"/>   end
<a name="88"/>end
<a name="89"/>
<a name="90"/>#
<a name="91"/># Partial application to function f, prepending l to the arguments.
<a name="92"/>#
<a name="93"/>procedure lpartial(f, l[])
<a name="94"/>   f := need_callable(f)
<a name="95"/>   return if *l = 1 then
<a name="96"/>      LRPartial(f, l[1]).lcall1
<a name="97"/>   else
<a name="98"/>      LRPartial(f, l).lcall
<a name="99"/>end
<a name="100"/>
<a name="101"/>#
<a name="102"/># Partial application to function f, appending l to the arguments.
<a name="103"/>#
<a name="104"/>procedure rpartial(f, l[])
<a name="105"/>   f := need_callable(f)
<a name="106"/>   return if *l = 1 then
<a name="107"/>      LRPartial(f, l[1]).rcall1
<a name="108"/>   else
<a name="109"/>      LRPartial(f, l).rcall
<a name="110"/>end
<a name="111"/>
<a name="112"/>#
<a name="113"/># Implementation class for `compose`
<a name="114"/>#
<a name="115"/>package class Compose()
<a name="116"/>   private const
<a name="117"/>      f, g
<a name="118"/>
<a name="119"/>   public call(a[])
<a name="120"/>      suspend f(g!a)
<a name="121"/>   end
<a name="122"/>
<a name="123"/>   public new(f, g)
<a name="124"/>      self.f := f
<a name="125"/>      self.g := g
<a name="126"/>      return
<a name="127"/>   end
<a name="128"/>end
<a name="129"/>
<a name="130"/>#
<a name="131"/># Compose functions f and g
<a name="132"/>#
<a name="133"/>procedure compose(f, g)
<a name="134"/>   return Compose(need_callable(f), need_callable(g)).call
<a name="135"/>end
<a name="136"/>
<a name="137"/># Convenient function to get the binary operator `op`, partially
<a name="138"/># applied with `x` as the left argument.  For example
<a name="139"/># ~
<a name="140"/>#    lpb(2, "*")
<a name="141"/># ~
<a name="142"/># returns a function which doubles its argument, whilst
<a name="143"/># ~
<a name="144"/>#    lpb(0, "&lt;")
<a name="145"/># ~
<a name="146"/># returns a function which succeeds and returns its argument if it is
<a name="147"/># greater than 0.
<a name="148"/>#
<a name="149"/>procedure lpb(x, op)
<a name="150"/>   return LRPartial(need_callable(op, 2), x).lcall1
<a name="151"/>end
<a name="152"/>
<a name="153"/># Convenient function to get the binary operator `op`, partially
<a name="154"/># applied with `x`, as the right argument.  For example
<a name="155"/># ~
<a name="156"/>#   rpb("/", 2)
<a name="157"/># ~
<a name="158"/># returns a function which halves its argument.
<a name="159"/>#
<a name="160"/>procedure rpb(op, x)
<a name="161"/>   return LRPartial(need_callable(op, 2), x).rcall1
<a name="162"/>end
<a name="163"/>
<a name="164"/>#
<a name="165"/># Implementation class for `methodf`, `fieldf`
<a name="166"/>#
<a name="167"/>package class Field()
<a name="168"/>   private const
<a name="169"/>      field
<a name="170"/>
<a name="171"/>   public methodf(obj, a[])
<a name="172"/>      suspend Class.get(obj, field)!a
<a name="173"/>   end
<a name="174"/>
<a name="175"/>   public fieldf(obj)
<a name="176"/>      return Class.get(obj, field)
<a name="177"/>   end
<a name="178"/>
<a name="179"/>   public new(field)
<a name="180"/>      self.field := field
<a name="181"/>      return
<a name="182"/>   end
<a name="183"/>end
<a name="184"/>
<a name="185"/># Returns a function that takes its first argument, obtains the given
<a name="186"/># field from it, and then applies the remaining arguments to the
<a name="187"/># resulting method.
<a name="188"/>#
<a name="189"/># Example :-
<a name="190"/># ~
<a name="191"/>#   f := methodf("abc")
<a name="192"/>#   f(obj, 1, 2, 3)   # invokes obj.abc(1, 2, 3)
<a name="193"/># ~
<a name="194"/>procedure methodf(field)
<a name="195"/>   return Field(field).methodf
<a name="196"/>end
<a name="197"/>
<a name="198"/># Returns a function that takes one parameter (an object), and which
<a name="199"/># returns the given field of that object.
<a name="200"/>#
<a name="201"/># Example :-
<a name="202"/># ~
<a name="203"/>#   f := fieldf("abc")
<a name="204"/>#   f(obj)       # returns obj.abc
<a name="205"/># ~
<a name="206"/>#
<a name="207"/>procedure fieldf(field)
<a name="208"/>   return Field(field).fieldf
<a name="209"/>end
<a name="210"/>
<a name="211"/># Implementation class for `flip` and `revargs`.
<a name="212"/>package class Func()
<a name="213"/>   private const f
<a name="214"/>
<a name="215"/>   public two(a, b)
<a name="216"/>      suspend f(b, a)
<a name="217"/>   end
<a name="218"/>
<a name="219"/>   public all(a[])
<a name="220"/>      suspend f!lreverse_mod(a)
<a name="221"/>   end
<a name="222"/>
<a name="223"/>   public new(f)
<a name="224"/>      self.f := f
<a name="225"/>      return
<a name="226"/>   end
<a name="227"/>end
<a name="228"/>
<a name="229"/># This function takes a binary function and returns another function
<a name="230"/># which invokes the original, but swapping its two arguments.
<a name="231"/>#
<a name="232"/>procedure flip(f)
<a name="233"/>   return Func(need_callable(f, 2)).two
<a name="234"/>end
<a name="235"/>
<a name="236"/># This function takes a function and returns another function which
<a name="237"/># invokes the original, but reversing all its arguments.  This is like
<a name="238"/># `flip` above, but more general (and slower).
<a name="239"/>#
<a name="240"/>procedure revargs(f)
<a name="241"/>   return Func(need_callable(f)).all
<a name="242"/>end
<a name="243"/>
<a name="244"/># Implementation class for `memoize` and `memoize1`
<a name="245"/>package class Memoize()
<a name="246"/>   private const
<a name="247"/>      f, t
<a name="248"/>
<a name="249"/>   public call(a[])
<a name="250"/>      local l
<a name="251"/>      (l := t.member(a)) | t.insert(a, l := List{f!a})
<a name="252"/>      suspend .!l
<a name="253"/>   end
<a name="254"/>
<a name="255"/>   public call1(a)
<a name="256"/>      local l
<a name="257"/>      (l := t.member(a)) | t.insert(a, l := f(a)) | fail
<a name="258"/>      return l
<a name="259"/>   end
<a name="260"/>
<a name="261"/>   public new(f, t)
<a name="262"/>      self.f := f
<a name="263"/>      self.t := t
<a name="264"/>      return
<a name="265"/>   end
<a name="266"/>end
<a name="267"/>
<a name="268"/># This procedure returns a function which memoizes the passed
<a name="269"/># function.  Subsequent arguments to and results from this function
<a name="270"/># are cached in a `datastruct.Table` so that the underlying function
<a name="271"/># is only called for parameters that haven't been seen before.
<a name="272"/>#
<a name="273"/># :Parameters :
<a name="274"/># :  `f` - the function to memoize
<a name="275"/># :  `t` - the `Table` to use to cache results; by default an
<a name="276"/>#          `EqTable`.  Note that the keys of this table will
<a name="277"/>#          always be distinct lists, so using, for example,
<a name="278"/>#           a `BuiltinTable` makes no sense.
<a name="279"/>#
<a name="280"/>procedure memoize(f, t)
<a name="281"/>   /t := EqTable()
<a name="282"/>   return Memoize(need_callable(f), t).call
<a name="283"/>end
<a name="284"/>
<a name="285"/># This is a simpler (but faster) version of `memoize()`.  Only a
<a name="286"/># single parameter is passed to the given function, and only a single
<a name="287"/># result is cached.  Further, by default a `BuiltinTable` is used to
<a name="288"/># cache results, rather than an `EqTable`.
<a name="289"/>#
<a name="290"/># :Parameters :
<a name="291"/># :  `f` - the function to memoize
<a name="292"/># :  `t` - the `Table` to use to cache results; by default an
<a name="293"/>#          `BuiltinTable`.  An `EqTable` could be used if the cost
<a name="294"/>#          of evaluating `f` were large compared to the cost of
<a name="295"/>#          `lang.hash` and `lang.equals`.
<a name="296"/>#
<a name="297"/>procedure memoize1(f, t)
<a name="298"/>   /t := BuiltinTable()
<a name="299"/>   return Memoize(need_callable(f, 1), t).call1
<a name="300"/>end
<a name="301"/>
<a name="302"/># Implementation class for `adjoin`.
<a name="303"/>package class Adjoin()
<a name="304"/>   private const f
<a name="305"/>
<a name="306"/>   private mk(f, a)
<a name="307"/>      return create f!a
<a name="308"/>   end
<a name="309"/>
<a name="310"/>   public call(a[])
<a name="311"/>      suspend Parallel!List{mk(!f, a)}
<a name="312"/>   end
<a name="313"/>
<a name="314"/>   public new(f)
<a name="315"/>      self.f := f
<a name="316"/>      return
<a name="317"/>   end
<a name="318"/>end
<a name="319"/>
<a name="320"/># This procedure puts several functions together and returns another
<a name="321"/># function.  When the returned function is called, the results of the
<a name="322"/># individual functions are generated in parallel, and a sequence of
<a name="323"/># lists containing those results is generated.
<a name="324"/>#
<a name="325"/>procedure adjoin(f[])
<a name="326"/>   return Adjoin(List{need_callable(!f)}).call
<a name="327"/>end
</pre></body></html>
