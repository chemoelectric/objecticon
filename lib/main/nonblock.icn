package io

import lang, ipl.lists

class WorkerStream(Stream)
   private readable
      timeout,
      other,
      when_timeout,
      io_group, 
      coex,
      poll_for

   public sched(x)
      when_timeout := Prog.get_runtime_millis() + timeout
      self.poll_for := x
      self.coex := &current
      io_group.add_stream(self)
      return @io_group.coex
   end

   public in(n)
      sched(Poll.IN) | fail
      return other.in(n)
   end

   public out(s)
      sched(Poll.OUT) | fail
      return other.out(s)
   end

   public close()
      return other.close()
   end

   public eof()
      return other.eof()
   end

   public get_mode()
      return other.get_mode()
   end

   public flag(on, off)
      return other.flag(on, off)
   end

   public connect(addr)
      return other.connect(addr)
   end

   public new(other, io_group, timeout)
      self.other := other
      self.io_group := io_group
      self.timeout := timeout
      return
   end
end

class IoGroup()
   private readable coex
   private starters, streams, caller, poll_l

   public new()
      streams := []
      starters := set()
      return
   end

   public add_starter(w)
      insert(starters, w)
   end

   public add_stream(w)
      put(streams, w)
      poll_l := &null
   end

   #
   # Do some i/o work.  A maximum of {n} bits of work are done; the
   # default is 1.  If {n} is negative, work is done until no more is
   # ready.  Succeeds if any work was done; fails if no work was done.
   #
   public work(n)
      local r
      /n := 1
      coex := &current
      until n = 0 do {
         do_work() | break
         r := 1
         n -:= 1
      }
      coex := &null
      return \r
   end

   public empty()
      return not(*(starters | streams) > 0)
   end

   private do_work()
      local e, t, now, r
      if *starters > 0 then {
         e := ?starters
         delete(starters, e)
         # Don't use coact, since this should be a new coexpression.
         @e
         return
      } 
      if *streams > 0 then {
         if /poll_l then {
            poll_l := []
            every e := !streams do {
               put(poll_l, e.other)
               put(poll_l, ior(e.poll_for,Poll.ERR))
            }
         }

         r := DescStream.poll(poll_l, 0) | {
            ewrite("poll failed:",&why)
            fail
         }
         now := Prog.get_runtime_millis()
         if \r then
            *r = *streams | syserr("Odd result from poll")
         every e := !streams do {
            t := pop(\r) | 0
            case t of {
               e.poll_for: {
                  ldel(streams, e)
                  poll_l := &null
                  coact(, e.coex)
                  return
               }
               Poll.ERR: {
                  ldel(streams, e)
                  poll_l := &null
                  &why := "Socket error"
                  coact(, e.coex,, 1)
                  return
               }
               0: {
                  if now > e.when_timeout then {
                     ldel(streams, e)
                     poll_l := &null
                     &why := "Timeout"
                     coact(, e.coex,, 1)
                     return
                  }
               }
               default: syserr("Odd value from poll:" || t)
            }
         }
      }
   end
end
