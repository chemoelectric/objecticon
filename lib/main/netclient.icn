#
# $Id$
#

package net

import 
   util, 
   io,
   posix

#
# Common base class for a client class which holds a connection to a
# server and communicates using CRLF-terminated lines.
#
# @field timeout=integer: see {set_timeout}
# @field server=string: see {set_server}
# @field path=string: see {set_path}
# @field port=integer: see {set_port}
# @field io_group=object: see {set_io_group}
#
class NetClient(Connectable, SetFields)
   public static const 
      CONNECTING_EVENT,
      CONNECTED_EVENT,
      CLOSED_EVENT,
      WRITING_STRING_EVENT,
      WRITING_LINE_EVENT,
      READ_LINE_EVENT,
      READ_STRING_EVENT,
      EVENT_TABLE
   
   private static init()
      CONNECTING_EVENT := "Connecting"
      CONNECTED_EVENT := "Connected"
      CLOSED_EVENT := "Closed"
      WRITING_STRING_EVENT := "Writing string"
      WRITING_LINE_EVENT := "Writing line"
      READ_LINE_EVENT := "Read line"
      READ_STRING_EVENT := "Read string"
      EVENT_TABLE := table(,
                           "connecting", CONNECTING_EVENT,
                           "connected", CONNECTED_EVENT,
                           "closed", CLOSED_EVENT,
                           "writing_string", WRITING_STRING_EVENT,
                           "writing_line", WRITING_LINE_EVENT,
                           "read_line", READ_LINE_EVENT,
                           "read_string", READ_STRING_EVENT)
   end

   private readable
      path,
      server,
      port,
      timeout,
      io_group

   private
      connection,
      sbuff

   # 
   # Fail and set the error code, and close the connection.
   #
   protected error_and_close(a)
      error(a)
      close()
   end

   #
   # Set the timeout in ms to use.  If a figure of zero, or &null, is given (the default)
   # then no timeout will be used.
   #
   public set_timeout(timeout)
      self.timeout := timeout
   end

   #
   # Open the connection.
   #
   protected open()
      local r, domain, addr

      if \server then {
         domain := ProtocolFormat.INET
         addr := "inet:" || server || ":" || port
      } else if \path then {
         domain := ProtocolFormat.UNIX
         addr := "unix:" || path
      } else
         runerr("Neither server/port nor path set")

      close() | fail

      if \io_group then {
         \timeout | runerr("Must set a timeout when using an io_group")
         connection := WorkerStream(SocketStream.socket(domain), 
                                    io_group,
                                    timeout)
         connection.flag(FileOpt.NONBLOCK) | fail
         fire(CONNECTING_EVENT)

         connection.connect(addr) | {
            if errno() = Errno.EINPROGRESS then {
               connection.sched(Poll.OUT) | {
                  close()
                  return error("Couldn't connect to " || addr || ": " || &why)
               }
            } else {
               close()
               return error("Couldn't connect to " || addr || ": " || &why)
            }
         }
      } else {
         connection := SocketStream.socket(domain)

         # If we are using a timeout, put the socket into non-blocking mode
         if \timeout > 0 then
            connection.flag(FileOpt.NONBLOCK) | fail

         fire(CONNECTING_EVENT)
         connection.connect(addr) | {
            if \timeout > 0 & errno() = Errno.EINPROGRESS then {
               r := DescStream.poll(connection, Poll.OUT, timeout) | {
                  close()
                  return error("Couldn't connect to " || addr || ": " || &why)
               }
               if /r then {
                  close()
                  return error("Couldn't connect to " || addr || " (timeout)")
               }
               r[1] = Poll.OUT | {
                  close()
                  return error("Couldn't connect to " || addr || " (socket error)")
               }
            } else {
               close()
               return error("Couldn't connect to " || addr || ": " || &why)
            }
         }
      }
      sbuff := ""
      fire(CONNECTED_EVENT)
      return
   end

   #
   # Close the connection
   #
   public close()
      if \connection then {
         connection.close() | return error("Failed to close connection: " || &why)
         fire(CLOSED_EVENT)
         connection := &null
      }
      return
   end

   #
   # Set the path to use (implies using PF_UNIX socket domain)
   #
   public set_path(s)
      path := s
   end

   #
   # Set the server to use (implies using PF_INET socket domain)
   #
   public set_server(s)
      server := s
   end

   #
   # Set the port
   #
   public set_port(n)
      port := n
   end

   #
   # Low-level write on the connection. 
   #
   private send(s)
      local i, r

      while *s > 0 do {
         if /io_group & (\timeout > 0) then {
            r := DescStream.poll(connection, Poll.OUT, timeout) | fail
            if /r then return error("Send failed (timeout)")
            r[1] = Poll.OUT | return error("Send failed (socket error)")
         }
         i := connection.out(s) | fail
         s := s[i+1 : 0]
      }
      return
   end

   #
   # Low-level read on the connection. 
   #
   private recv(len)
      local r

      if /io_group & (\timeout > 0) then {
         r := DescStream.poll(connection, Poll.IN, timeout) | fail
         if /r then return error("Receive failed (timeout)")
         r[1] = Poll.IN | return error("Receive failed (socket error)")
      }
      return connection.in(len)
   end

   #
   # Write the given string to the connection.
   #
   protected write_str(s)
      fire(WRITING_STRING_EVENT, s)
      return send(s)
   end

   #
   # Write a single line to the connection, appending CRLF to the output stream.
   # 
   protected write_line(s)
      /s := ""
      fire(WRITING_LINE_EVENT, s)
      return send(s || "\r\n") 
   end

   #
   # Read a single line from the connection, and return it.
   #
   protected read_line()
      local line

      repeat {
         #
         # Look for a line and if found return it.
         #
         sbuff ? {
            if line := tab(find("\r\n")) then {
               move(2)
               sbuff := tab(0)
               fire(READ_LINE_EVENT, line)
               return line
            }
         }
         sbuff ||:= recv(1024) | fail
      }
   end

   #
   # Read up to len bytes on the connection.
   #
   protected read_str(len)
      local t
      #
      # Use the line buffer if it has anything in it.
      #
      if *sbuff > 0 then {
         sbuff ? {
            t := move(len) | tab(0)
            sbuff := tab(0)
         }
      } else {
         t := recv(len) | fail
      }
      fire(READ_STRING_EVENT, t)
      return t
   end

   protected is_open()
      if \self.connection then
         return
   end

   protected eof()
      return connection.eof()
   end

   #
   # Set an {IoGroup} to use when creating the connection object.
   # This allows several clients to be used together in a non-blocking
   # fashion (using co-expressions for each task).
   #
   public set_io_group(g)
      self.io_group := g
   end

   protected set_one(f)
      case f.attr of {
         "timeout": set_timeout(f.int_val())
         "server": set_server(f.string_val())
         "path": set_path(f.string_val())
         "port": set_port(f.int_val())
         "io_group": set_io_group(f.object_val(IoGroup))
         default: return try_event(f, EVENT_TABLE)
      }
      return
   end

   protected new(a[])
      cast(self,Connectable).new()
      sbuff := ""
      set_fields(a)
      return
   end
end
