/*
 * File: rxwin.ri - X11 system-specific graphics interface code.
 */

#define CONVERT_ANGLE(ang) (-(ang) * 180 / Pi * 64)

#define GetDepth(wd) DefaultDepth((wd)->display,DefaultScreen((wd)->display))
#define GetVisual(wd) DefaultVisual((wd)->display,DefaultScreen((wd)->display))
#define GetColormap(wd) DefaultColormap((wd)->display,DefaultScreen((wd)->display))
#define GetGC(wd) DefaultGC((wd)->display,DefaultScreen((wd)->display))
#define GetWidth(wd) DisplayWidth((wd)->display,DefaultScreen((wd)->display))
#define GetHeight(wd) DisplayHeight((wd)->display,DefaultScreen((wd)->display))
#define GetRoot(wd) DefaultRootWindow((wd)->display)

/*
 * Polyedge to use with pixwin; set to PolyEdgeSharp or PolyEdgeSmooth
 */

#define PolyEdge PolyEdgeSmooth

/*
 * Global variables specific to X
 */
wdp wdsplys;

/* List of windows with win non-null */
static wsp vwstates;

/*
 * function prototypes
 */
static void handle_config(wsp w, XConfigureEvent *event);
static void handle_property(wsp ws, XPropertyEvent *event);
static void handle_exposures(wsp ws, XExposeEvent *event);
static void handle_mouse(wsp ws, XButtonEvent *event);
static void handle_keypress(wsp ws, XKeyEvent *event);
static void handle_crossing(wsp ws, XCrossingEvent *event);
static void wmap(wbp w);
static void synch_cursor(wsp ws);
static int convert_KeySym_to_code_point(KeySym k);
static char *convertspec(wdp wd, char *s);
int xft_stringwidth(wbp w, char *s, int n);
static wfp newfont(wdp wd, char *s);
static wdp alcdisplay (char *s);
static wfp loadfont(wdp wd, char *s);
static void resizepixmap(wbp w);
static void clip(wbp w);
static void unclip(wbp w);
static int make_mod(unsigned int state);
static char* property_to_string(wdp wd, Atom target, int number_items, void* data);
static Atom convert_target(wdp wd, Atom desired_target);
static void get_atom_descriptor(wsp ws, Atom a, dptr dest);
static void synch_state(wsp ws);
static void synch_net_wm_state(wsp ws, int desired_state);
static void close_screen_win(wsp ws);
static struct SharedColor *new_sharedcolor(wdp wd, char *name, int r, int g, int b, int a);
static void fill2(wbp w, int op, XRenderColor  *color, int x, int y, int width, int height);
static void poly2(wbp w, XPointDouble *points, int npoints);
static void pic2(wbp w, Picture src, int x, int y, int width, int height);
static void maskpic2(wbp w, Picture src, Picture mask, int x, int y, int width, int height);
static struct SharedPicture *new_sharedpicture(wdp wd, struct imgdata *imd);
static struct SharedPicture *link_sharedpicture(struct SharedPicture *x);
static void unlink_sharedpicture(wdp wd, struct SharedPicture *x);
static Picture get_draw_picture(wcp wc);
static void pix_to_win(wsp ws, int x, int y, int w, int h);
static Pixmap imgdata_to_Pixmap(wdp wd, struct imgdata *imd);
static Picture getmask(wdp wd, int width, int height);
static XPointDouble doublept(double x, double y);
static XTriangle triangle(double x1, double y1, double x2, double y2, double x3, double y3);
static XTrapezoid trapezoid(double top, double x1, double x2, double bottom, double x3, double x4);
static int needmask(wcp wc, int overlap);

static struct imgdataformat imgdataformat_X11ARGB32;
static struct imgdataformat imgdataformat_X11BGRA32;

static stringint drawops[] = {
   { 0, 12},
   {"atop",  PictOpAtop},
   {"clear",  PictOpClear},
   {"dest",  PictOpDst},
   {"dest atop",  PictOpAtopReverse},
   {"dest in",  PictOpInReverse},
   {"dest out",  PictOpOutReverse},
   {"dest over",  PictOpOverReverse},
   {"in",  PictOpIn},
   {"out",  PictOpOut},
   {"over",  PictOpOver},
   {"source",  PictOpSrc},
   {"xor",  PictOpXor},
};

static stringint linestyles[] = {
    {0, 5},
    {"dashed",      LineOnOffDash},
    {"doubledash",  LineDoubleDash},
    {"onoff",       LineOnOffDash},
    {"solid",       LineSolid},
    {"striped",     LineDoubleDash},
};

static stringint canvastypes[] = {
    {0, 8},
    {"fullscreen",  FullScreenState},
    {"hidden",      HiddenState},
    {"iconic",      IconicState},
    {"maximized",   MaximizedState},
    {"normal",      NormalState},
    {"popup",       PopupState},
    {"root",        RootState},
    {"withdrawn",   WithdrawnState},
};

static stringint cursors[] = {
  { 0, NUMCURSORSYMS},
  {"X cursor",		XC_X_cursor},
  {"arrow",		XC_arrow},
  {"based arrow down",	XC_based_arrow_down},
  {"based arrow up",	XC_based_arrow_up},
  {"boat",		XC_boat},
  {"bogosity",		XC_bogosity},
  {"bottom left corner",XC_bottom_left_corner},
  {"bottom right corner",XC_bottom_right_corner},
  {"bottom side",	XC_bottom_side},
  {"bottom tee",	XC_bottom_tee},
  {"box spiral",	XC_box_spiral},
  {"center ptr",	XC_center_ptr},
  {"circle",		XC_circle},
  {"clock",		XC_clock},
  {"coffee mug",	XC_coffee_mug},
  {"cross",		XC_cross},
  {"cross reverse",	XC_cross_reverse},
  {"crosshair",		XC_crosshair},
  {"diamond cross",	XC_diamond_cross},
  {"dot",		XC_dot},
  {"dotbox",		XC_dotbox},
  {"double arrow",	XC_double_arrow},
  {"draft large",	XC_draft_large},
  {"draft small",	XC_draft_small},
  {"draped box",	XC_draped_box},
  {"exchange",		XC_exchange},
  {"fleur",		XC_fleur},
  {"gobbler",		XC_gobbler},
  {"gumby",		XC_gumby},
  {"hand1",		XC_hand1},
  {"hand2",		XC_hand2},
  {"heart",		XC_heart},
  {"icon",		XC_icon},
  {"iron cross",	XC_iron_cross},
  {"left ptr",		XC_left_ptr},
  {"left side",		XC_left_side},
  {"left tee",		XC_left_tee},
  {"leftbutton",	XC_leftbutton},
  {"ll angle",		XC_ll_angle},
  {"lr angle",		XC_lr_angle},
  {"man",		XC_man},
  {"middlebutton",	XC_middlebutton},
  {"mouse",		XC_mouse},
  {"pencil",		XC_pencil},
  {"pirate",		XC_pirate},
  {"plus",		XC_plus},
  {"question arrow",	XC_question_arrow},
  {"right ptr",		XC_right_ptr},
  {"right side",	XC_right_side},
  {"right tee",		XC_right_tee},
  {"rightbutton",	XC_rightbutton},
  {"rtl logo",		XC_rtl_logo},
  {"sailboat",		XC_sailboat},
  {"sb down arrow",	XC_sb_down_arrow},
  {"sb h double arrow",	XC_sb_h_double_arrow},
  {"sb left arrow",	XC_sb_left_arrow},
  {"sb right arrow",	XC_sb_right_arrow},
  {"sb up arrow",	XC_sb_up_arrow},
  {"sb v double arrow",	XC_sb_v_double_arrow},
  {"shuttle",		XC_shuttle},
  {"sizing",		XC_sizing},
  {"spider",		XC_spider},
  {"spraycan",		XC_spraycan},
  {"star",		XC_star},
  {"target",		XC_target},
  {"tcross",		XC_tcross},
  {"top left arrow",	XC_top_left_arrow},
  {"top left corner",	XC_top_left_corner},
  {"top right corner",	XC_top_right_corner},
  {"top side",		XC_top_side},
  {"top tee",		XC_top_tee},
  {"trek",		XC_trek},
  {"ul angle",		XC_ul_angle},
  {"umbrella",		XC_umbrella},
  {"ur angle",		XC_ur_angle},
  {"watch",		XC_watch},
  {"xterm",		XC_xterm},
  {"num glyphs",	XC_num_glyphs},
};


static int selection_debug = 0;

#if 0
static void dump_all(void)
{
    int i,j,k;
    wsp x;
    wbp y;
    i = 0;
    for (y = wbndngs; y; y = y->next) {
        printf("Binding %p\n",y);
        printf("\tcanvas %p\n",y->window);
        printf("\tcontext %p\n",y->context);
        ++i;
    }
    printf("============\n");
    j = 0;
    for (x = wstates; x; x = x->next) {
        printf("Canvas %p\n",x);
        printf("\trefcount=%d\n", x->refcount);
        printf("\tlabel=%s\n", x->windowlabel);
        printf("\tgeometry=%d,%d %dx%d\n", x->x,x->y,x->width,x->height);
        printf("\twin=%d\n", (int)x->win);
        ++j; 
    }
    printf("============\n");
    k = 0;
    for (x = vwstates; x; x = x->vnext) {
        printf("Non-hidden Canvas %p\n",x);
        printf("\trefcount=%d\n", x->refcount);
        printf("\tlabel=%s\n", x->windowlabel);
        printf("\tgeometry=%d,%d %dx%d\n", x->x,x->y,x->width,x->height);
        printf("\twin=%d\n", (int)x->win);
        ++k; 
    }

    printf("Total %d bindings %d canvases (%d non-hidden)\n",i,j,k);
}
#endif
#if 0
static void dump_ximage(XImage *xi)
{
    int i,j;
    printf("XImage=%p\n",xi);
    printf("\twidth, height=%d %d\n", xi->width, xi->height);            /* size of image */
    printf("\txoffset=%d\n", xi->xoffset);                  /* number of pixels offset in X direction */
    printf("\tformat=%d\n", xi->format);                  /* XYBitmap, XYPixmap, ZPixmap */
    printf("\tbyte_order=%d\n", xi->byte_order);               /* data byte order, LSBFirst, MSBFirst */
    printf("\tbitmap_unit =%d\n", xi->bitmap_unit);             /* quant. of scanline 8, 16, 32 */
    printf("\tbitmap_bit_order =%d\n", xi->bitmap_bit_order);        /* LSBFirst, MSBFirst */
    printf("\tbitmap_pad   =%d\n", xi->bitmap_pad);            /* 8, 16, 32 either XY or ZPixmap */
    printf("\tdepth  =%d\n", xi->depth);              /* depth of image */
    printf("\tbytes_per_line=%d\n", xi->bytes_per_line);          /* accelerator to next scanline */
    printf("\tbits_per_pixel=%d\n", xi->bits_per_pixel);        /* bits per pixel (ZPixmap) */
    printf("\tred_mask=%lx\n", xi->red_mask);       /* bits in z arrangement */
    printf("\tgreen_mask=%lx\n", xi->green_mask);
    printf("\tblue_mask=%lx\n", xi->blue_mask);

    for (i=0;i<32;++i)
        printf("%d ", (int)imd->data[i]);
    printf("\n");
    printf("\nPixel dump of region %d,%d size %d,%d\n",x,y,xi->width,xi->height);
    
    for (j=0; j < xi->height; ++j) {
        unsigned long c0=-1;
        printf("\nrow %d:",j);
        for (i = 0; i < xi->width; ++i) {
            unsigned long c;            
            c=XGetPixel(xi,i,j);
            if (c!=c0) {
                printf("%lx ",c);
                c0=c;
            } else
                printf("-");
        }
    }
    printf("\n");
}



#endif

#define ATOM(d, x) ((d)->atoms[ATOM_##x])

static struct SharedPicture *new_sharedpicture(wdp wd, struct imgdata *imd)
{
    struct SharedPicture *res;
    XRenderPictureAttributes pa;
    GRFX_ALLOC(res, SharedPicture);
    res->pix = imgdata_to_Pixmap(wd, imd);
    pa.repeat = 1;
    res->i = XRenderCreatePicture(wd->display, res->pix, wd->pixfmt, CPRepeat, &pa);
    res->width = imd->width;
    res->height = imd->height;
    return res;
}

static struct SharedPicture *link_sharedpicture(struct SharedPicture *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedpicture(wdp wd, struct SharedPicture *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        if (x->i)
            XRenderFreePicture(wd->display, x->i);
        if (x->pix)
            XFreePixmap(wd->display, x->pix);
        free(x);
    }
}

static struct SharedColor *new_sharedcolor(wdp wd, char *name, int r, int g, int b, int a)
{
    struct SharedColor *res;
    GRFX_ALLOC(res, SharedColor);
    res->color.red = Mul16(r, a);
    res->color.green = Mul16(g, a);
    res->color.blue = Mul16(b, a);
    res->color.alpha = a;
    res->brush = XRenderCreateSolidFill(wd->display, &res->color);
    res->name = salloc(name);
    return res;
}

static struct SharedColor *link_sharedcolor(struct SharedColor *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedcolor(wdp wd, struct SharedColor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        XRenderFreePicture(wd->display, x->brush);
        free(x->name);
        free(x);
    }
}

static char *atom_fmt(wsp ws,Atom a) {
    static int n = 0;
    static char buff[8][96];
    char *s, *r;
    r = buff[n];
    if (a == None)
        return "None(0)";

    s = XGetAtomName(ws->display->display, a);
    if (s) {
        sprintf(r, "%.64s(%ld)", s, (long)a);
        XFree(s);
    } else {
        sprintf(r, "?unknown atom(%ld)", (long)a);
    }

    n = (n + 1) % 8;
    return r;
}

/*
 * Get the string name of the given Atom into dest.  The string is
 * allocated in the string region.
 */
static void get_atom_descriptor(wsp ws, Atom a, dptr dest)
{
    char *s = XGetAtomName(ws->display->display, a);
    cstr2string(s, dest);
    XFree(s);
}

static Atom convert_target(wdp wd, Atom desired_target)
{
    /* Check for common cases. */
    if ( (desired_target == ATOM(wd, TIMESTAMP))    ||
         (desired_target == ATOM(wd, LIST_LENGTH) ) ||
         (desired_target == ATOM(wd, SPAN) ) ||
         (desired_target == ATOM(wd, CHARACTER_POSITION) ) ||
         (desired_target == ATOM(wd, LENGTH) ) ) {
        return XA_INTEGER;
    }

    if ( desired_target == ATOM(wd, TARGETS) ) {
        return XA_ATOM;
    }

    if ( desired_target == ATOM(wd, CLIENT_WINDOW) ) {
        return XA_WINDOW;
    }

    /* Otherwise, no need to convert target. */
    return desired_target;
}

static char* property_to_string(wdp wd, Atom target, int number_items, void* data)
{
    char *result = 0;
    int i, length;

    /* Convert target, if necessary. */
    target = convert_target(wd, target);

    switch (target) {
        case XA_ATOM: {
            int curr_len, total_len;
            unsigned long *long_array = (unsigned long*) data;

            length = 32;
            MemProtect(result = malloc(length));
            *result = 0;
            total_len = 0;

            /* Convert to atom names. */
            for (i = 0; i < number_items; i++) {
                char *atom_name = XGetAtomName(wd->display, long_array[i] );
                if (atom_name) {
                    curr_len = strlen(atom_name) + 1;    /* +1 for the \n */
                    if (total_len + curr_len + 1 > length) {  /* +1 for the \0 */
                        length = total_len + curr_len + 1;
                        MemProtect(result = realloc(result, length));
                    }
                    sprintf(result + total_len, "%s\n", atom_name);
                    total_len += curr_len;
                    XFree(atom_name);
                }
            }
            break;
        }
        case XA_INTEGER: {
            long *int_array = (long*) data;
            length = number_items * 20 + 1;
            MemProtect(result = malloc(length));
            *result = 0;
            for (i = 0; i < number_items; i++)
                sprintf(result + strlen(result), "%ld ", int_array[i]);
            break;
        }
        case XA_WINDOW: {
            unsigned long *long_array = (unsigned long*) data;
            length = number_items * 12 + 1;
            MemProtect(result = malloc(length));
            *result = 0;
            for (i = 0; i < number_items; i++)
                sprintf(result + strlen(result), "0x%8.8lu ", long_array[i]);
            break;
        }
    }

    return result;

}

void pollevent(wbp w)
{
    wdp wd = w->window->display;
    XEvent event;
    Window evwin;
    wsp ws = 0;
    while (XPending(wd->display)) {

        XNextEvent(wd->display, &event);
        evwin = event.xexpose.window;  /* go ahead, criticize all you like */

        for (ws = vwstates; ws; ws = ws->vnext) {
            if (ws->display == wd && ws->win == evwin) 
                break;
        }
        if (!ws) continue;

        switch (event.type) {
            case SelectionRequest: {
                tended struct descrip tmp;
                if (selection_debug)
                    printf("SelectionRequest event:\n\towner=%lx requestor=%lx "
                           "property=%s target=%s selection=%s\n",
                           (long)event.xselectionrequest.owner,
                           (long)event.xselectionrequest.requestor,
                           atom_fmt(ws, event.xselectionrequest.property),
                           atom_fmt(ws, event.xselectionrequest.target),
                           atom_fmt(ws, event.xselectionrequest.selection)
                        );

                MakeInt(SELECTIONREQUEST, &tmp);
                list_put(&ws->listp, &tmp);
                MakeInt((word)event.xselectionrequest.requestor, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselectionrequest.property, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselectionrequest.selection, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselectionrequest.target, &tmp);
                list_put(&ws->listp, &tmp);
                MakeInt(event.xselectionrequest.time, &tmp);
                list_put(&ws->listp, &tmp);
                break;
            }

            case SelectionClear: {
                tended struct descrip tmp;
                if (selection_debug)
                    printf("SelectionClear event win=%lx selection=%s\n",
                           (long)event.xselectionclear.window,
                           atom_fmt(ws, event.xselectionclear.selection));
                MakeInt(SELECTIONCLEAR, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselectionclear.selection, &tmp);
                list_put(&ws->listp, &tmp);
                break;
            }

            case SelectionNotify: {
                Atom actual_type;
                int actual_format;
                unsigned long bytes_after, nitems;
                unsigned char *prop;
                word bytes_read;
                tended struct descrip tmp;
                int status;
                char *conv_str;

                if (selection_debug)
                    printf("SelectionNotify: requestor=%lx selection=%s target=%s property=%s\n",
                           (long)event.xselection.requestor,
                           atom_fmt(ws, event.xselection.selection),
                           atom_fmt(ws, event.xselection.target),
                           atom_fmt(ws, event.xselection.property));

                MakeInt(SELECTIONRESPONSE, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselection.selection, &tmp);
                list_put(&ws->listp, &tmp);
                get_atom_descriptor(ws, event.xselection.target, &tmp);
                list_put(&ws->listp, &tmp);

                if (event.xselection.property == None) {
                    if (selection_debug)
                        printf("XGetWindowProperty xselection.property == None\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                status = XGetWindowProperty(ws->display->display,
                                            ws->win,
                                            ATOM(ws->display, _OBJECTICON_PROP),
                                            0,
                                            8192,   /* Means we won't get back > 32kb of stuff */
                                            True,
                                            AnyPropertyType,
                                            &actual_type,
                                            &actual_format,
                                            &nitems,
                                            &bytes_after,
                                            &prop);

                if (status != Success) {
                    if (selection_debug)
                        printf("XGetWindowProperty failed\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                if (actual_type == None) {
                    if (selection_debug)
                        printf("XGetWindowProperty returned actual_type == None\n");
                    list_put(&ws->listp, &nulldesc);
                    if (prop) XFree(prop);
                    break;
                }

                /* Shouldn't ever happen */
                if (!prop) {
                    if (selection_debug)
                        printf("XGetWindowProperty set prop to null\n");
                    list_put(&ws->listp, &nulldesc);
                    break;
                }

                bytes_read = nitems * (actual_format/8);
                if (selection_debug)
                    printf("Got %lu items x %d bits -> %ld bytes\n",nitems, actual_format, (long)bytes_read);

                conv_str = property_to_string(ws->display,
                                              actual_type,
                                              nitems,
                                              prop);
                if (conv_str) {
                    /* Make an Icon string out of the data */
                    cstr2string(conv_str, &tmp);
                    free(conv_str);
                } else {
                    /* Make an Icon string out of the data */
                    bytes2string((char *)prop, bytes_read, &tmp);
                }
                list_put(&ws->listp, &tmp);

                XFree(prop);
                    
                break;
            }

            case KeyRelease: {
                if (ws->inputmask & IM_KEY_RELEASE)
                    handle_keypress(ws, (XKeyEvent *)&event);
                break;
            }
            case KeyPress:
                handle_keypress(ws, (XKeyEvent *)&event);
                break;
            case ButtonPress:
            case ButtonRelease:
            case MotionNotify:
                handle_mouse(ws, (XButtonEvent *)&event);
                break;
            case LeaveNotify:
            case EnterNotify:
                handle_crossing(ws, (XCrossingEvent *)&event);
                break;
            case NoExpose:
                break;
            case Expose:
                handle_exposures(ws, (XExposeEvent *)&event);
                break;
            case PropertyNotify:
                handle_property(ws, (XPropertyEvent *)&event);
                break;
            case UnmapNotify:
            case MapNotify:
                break;
            case ConfigureNotify:
                handle_config(ws, (XConfigureEvent *)&event);
                break;
            case ClientMessage: {
                /*
                 * only client message we handle at present are destroy requests
                 */
                if (event.xclient.data.l[0] == ATOM(ws->display, WM_DELETE_WINDOW))
                    qeventcode(ws, WINDOWCLOSED);
                break;
            }
            default:
                break;
        }
    }
}

static void close_screen_win(wsp ws)
{
    wdp wd = ws->display;
    XRenderFreePicture(wd->display, ws->wpic);
    XDestroyWindow(wd->display, ws->win);
    XFlush(wd->display);
    ws->win = 0;
    GRFX_GENUNLINK(ws, vwstates, vnext, vprevious);
    synch_state(ws);
}

/*
 * open a window
 */
wbp wopen(char *display)
{
    wbp w;
    wsp ws;
    wcp wc;
    wdp wd;
    XRenderPictureAttributes attr;

    if ((wd = alcdisplay(display)) == NULL) {
        /* alcdisplay will have set &why */
        return 0;
    }

    w = alcwbinding();

    GRFX_ALLOC(ws, _wstate);
    ws->listp = nulldesc;
    ws->cursor = stringint_lookup(cursors, "left ptr");
    ws->state = HiddenState;
    ws->x = ws->y = -INT_MAX;
    ws->minwidth = ws->minheight = 1;
    ws->maxwidth = ws->maxheight = INT_MAX;
    ws->width = ws->height = ws->pixwidth = ws->pixheight = 1;
    ws->pxft = NULL;
    ws->windowlabel = salloc(DEFAULT_WINDOW_LABEL);
    ws->display = wd;
    GRFX_LINK(ws, wstates);

    w->window = ws;
    create_list(64, &ws->listp);

    GRFX_ALLOC(wc, _wcontext);
    wc->display = wd;
    wc->bg = link_sharedcolor(wd->white);
    wc->fg = link_sharedcolor(wd->black);
    wc->font = wd->defaultfont;
    wc->drawop = stringint_lookup(drawops, "over");
    wc->clipx = wc->clipy = 0;
    wc->clipw = wc->cliph = -1;
    wc->linewidth = 1;
    wc->linestyle = stringint_lookup(linestyles, "solid");
    GRFX_LINK(wc, wcntxts);

    w->context = wc;

    /*
     * Create the 1x1 pixmap
     */
    ws->pix = XCreatePixmap(wd->display, GetRoot(wd),
                            ws->pixwidth, ws->pixheight,
                            32);
    attr.poly_edge = PolyEdge;
    ws->ppic = XRenderCreatePicture(wd->display, ws->pix, wd->pixfmt, CPPolyEdge, &attr);

    /* Fill pixmap with background colour */
    XRenderFillRectangle(wd->display,
                         PictOpSrc,
                         ws->ppic,
                         &wc->bg->color,
                         0, 0, ws->width, ws->height);
    return w;
}

int setwindowicon(wbp w, struct imgdata *imd)
{
    wsp ws = w->window;
    int i, j, k;
    if (ws->icondata)
        free(ws->icondata);
    ws->iconlen = 2 + imd->width * imd->height;
    MemProtect(ws->icondata = malloc(ws->iconlen * sizeof(unsigned long)));
    k = 0;
    ws->icondata[k++] = imd->width;
    ws->icondata[k++] = imd->height;
    for (j = 0; j < imd->height; ++j) {
        for (i = 0; i < imd->width; ++i) {
            int r, g, b, a;
            imd->format->getpixel(imd, i, j, &r, &g, &b, &a);
            ws->icondata[k++] = ((a/256)<<24) | ((r/256)<<16) | ((g/256)<<8) | (b/256);
        }
    }
    if (ws->win) {
        XChangeProperty(ws->display->display, ws->win,
                        ATOM(ws->display, _NET_WM_ICON), 
                        XA_CARDINAL, 
                        32,
                        PropModeReplace, 
                        (unsigned char *)ws->icondata,
                        ws->iconlen);
    }
    return Succeeded;
}

int setpattern(wbp w, struct imgdata *imd)
{
    wcp wc = w->context;
    wdp wd = w->window->display;
    if (wc->pattern)
        unlink_sharedpicture(wd, wc->pattern);
    if (imd)
        wc->pattern = new_sharedpicture(wd, imd);
    else
        wc->pattern = 0;
    return Succeeded;
}

/*
 *  Open the X window for a non-hidden icon window.
 */
static void wmap(wbp w)
{
    XWindowAttributes attrs;
    XSetWindowAttributes attr;
    char *s;
    XWMHints wmhints;
    XClassHint clhints;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;

    /*
     * create the X window (or use the DefaultRootWindow if requested)
     */
    attr.background_pixel = 0xffffff;  /* TODO wc->bg->c; */

    switch (ws->state) {
        case RootState:
            ws->win = GetRoot(wd);
            break;
        case PopupState: {
            attr.override_redirect = True;
            ws->win = XCreateWindow(wd->display, GetRoot(wd),
                                    ws->x < 0 ? 0 : ws->x,
                                    ws->y < 0 ? 0 : ws->y, 
                                    ws->width, ws->height, 
                                    0,
                                    GetDepth(wd),
                                    InputOutput,
                                    CopyFromParent,
                                    CWBackPixel|CWOverrideRedirect,
                                    &attr);
            break;
        }
        default: {
            ws->win = XCreateWindow(wd->display, GetRoot(wd),
                                    ws->x < 0 ? 0 : ws->x,
                                    ws->y < 0 ? 0 : ws->y, 
                                    ws->width, ws->height, 
                                    0,
                                    GetDepth(wd),
                                    InputOutput,
                                    CopyFromParent,
                                    CWBackPixel,
                                    &attr);
            break;
        }
    }

    ws->wpic = XRenderCreatePicture(wd->display, ws->win, wd->winfmt, 0, NULL);

    /* If the window has a parent, set the WM_TRANSIENT_FOR hint. */
    if (ws->transientfor)
        XSetTransientForHint(wd->display, ws->win, ws->transientfor);

    /* Turn off background; this prevents X filling the background on an expose
       and hence prevents unsightly flicker on a resize. */
    XSetWindowBackgroundPixmap(wd->display, ws->win, None);

    XSetWMProtocols(wd->display, ws->win, &ATOM(wd, WM_DELETE_WINDOW), 1);

    XClearWindow(wd->display, ws->win);

    GRFX_GENLINK(ws, vwstates, vnext, vprevious);

    /* For RootState, need to fill since XClearWindow above fills with a pixmap */
    if (ws->state == RootState) {
        XRenderFillRectangle(wd->display,
                             PictOpSrc,
                             ws->wpic,
                             &wc->bg->color,
                             0, 0, ws->width, ws->height);
    } else {
        XSizeHints size_hints;
        size_hints.flags = PSize | PMinSize | PMaxSize;
        size_hints.width = ws->width;
        size_hints.height= ws->height;
        if (ws->x != -INT_MAX && ws->y != -INT_MAX) {
            size_hints.flags |= USPosition;
            size_hints.x = ws->x;
            size_hints.y = ws->y;
        }
        if (ws->resizable) {
            size_hints.min_width = ws->minwidth;
            size_hints.min_height = ws->minheight;
            size_hints.max_width = ws->maxwidth;
            size_hints.max_height = ws->maxheight;
        }
        else {
            size_hints.min_width = size_hints.max_width = ws->width;
            size_hints.min_height = size_hints.max_height = ws->height;
        }
        XChangeProperty(wd->display, ws->win,
                        ATOM(wd, _NET_WM_NAME), 
                        ATOM(wd, UTF8_STRING),
                        8,
                        PropModeReplace, 
                        (unsigned char *)ws->windowlabel,
                        strlen(ws->windowlabel));

        XSetWMNormalHints(wd->display, ws->win, &size_hints);
        XSelectInput(wd->display, ws->win, 
                     ExposureMask | KeyPressMask | EnterWindowMask | LeaveWindowMask |
                     ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | PropertyChangeMask |
                     StructureNotifyMask | PointerMotionMask | KeyReleaseMask);

        if (ws->icondata) {
            XChangeProperty(wd->display, ws->win,
                            ATOM(ws->display, _NET_WM_ICON), 
                            XA_CARDINAL, 
                            32,
                            PropModeReplace, 
                            (unsigned char *)ws->icondata,
                            ws->iconlen);
        }
    }

    wmhints.input = True;
    wmhints.flags = InputHint;
    if (ws->state == IconicState) {
        wmhints.flags |= StateHint;
        wmhints.initial_state = IconicState;
    } else if (ws->state == WithdrawnState) {
        wmhints.flags |= StateHint;
        wmhints.initial_state = WithdrawnState;
    } else if (ws->state != RootState) {
        wmhints.flags |= StateHint;
        wmhints.initial_state = NormalState;
    }
    XSetWMHints(wd->display, ws->win, &wmhints);

    /*
     * Set the class hints that name the program (for reference by the
     * window manager) following conventions given in O'Reilly.
     */
    if ((s = getenv("RESOURCE_NAME")))
        clhints.res_name = s;
    else {
        int i;
        char *p, sbuf[256];
        p = StrLoc(kywd_prog);
        s = p + StrLen(kywd_prog);
        while (s > p && s[-1] != '/')
            s--;				/* find tail of prog_name */
        for (i = 0; i < sizeof(sbuf) - 1 && s < p + StrLen(kywd_prog); ) 
            sbuf[i++] = *s++;
        sbuf[i] = '\0';
        clhints.res_name = sbuf;
    }
    clhints.res_class = "ObjectIconProg";
    XSetClassHint(wd->display, ws->win, &clhints);
    XSync(wd->display, False);

    if (ws->state == MaximizedState) {
        Atom atoms[2];
        atoms[0] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
        atoms[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
        XChangeProperty(wd->display, ws->win,
                        ATOM(wd, _NET_WM_STATE),
                        XA_ATOM, 32,
                        PropModeReplace, (unsigned char *)atoms, 2);
    } else if (ws->state == FullScreenState) {
        Atom atoms[1];
        atoms[0] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
        XChangeProperty(wd->display, ws->win,
                        ATOM(wd, _NET_WM_STATE),
                        XA_ATOM, 32,
                        PropModeReplace, (unsigned char *)atoms, 1);
    }

    if (ws->state != RootState && ws->state != WithdrawnState)
        XMapWindow(wd->display, ws->win);

    XGetWindowAttributes(wd->display, ws->win, &attrs);
    ws->width = attrs.width;
    ws->height = attrs.height;
    resizepixmap(w);

    synch_cursor(ws);

    XSync(wd->display, False);
}

static void synch_net_wm_state(wsp ws, int desired_state)
{
    XEvent e;
    wdp wd = ws->display;
    e.xclient.type = ClientMessage;
    e.xclient.serial = 0;
    e.xclient.send_event = True;
    e.xclient.display = wd->display;
    e.xclient.message_type = ATOM(wd, _NET_WM_STATE);
    e.xclient.format = 32;
    e.xclient.window = ws->win;
    e.xclient.data.l[3] = 0;
    switch (desired_state) {
        case NormalState: {
            e.xclient.data.l[0] = _NET_WM_STATE_REMOVE;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
            e.xclient.data.l[2] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            break;
        }
        case MaximizedState: {
            e.xclient.data.l[0] = _NET_WM_STATE_REMOVE;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[0] = _NET_WM_STATE_ADD;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
            e.xclient.data.l[2] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            break;
        }
        case FullScreenState: { 
            e.xclient.data.l[0] = _NET_WM_STATE_REMOVE;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT);
            e.xclient.data.l[2] = ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ);
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            e.xclient.data.l[0] = _NET_WM_STATE_ADD;
            e.xclient.data.l[1] = ATOM(wd, _NET_WM_STATE_FULLSCREEN);
            e.xclient.data.l[2] = 0;
            XSendEvent(wd->display, GetRoot(wd), False,
                       SubstructureNotifyMask | SubstructureRedirectMask, &e);
            break;
        }
        default: {
            syserr("Invalid desired_state");
            break;
        }
    }
    XSync(wd->display, False);
}

void doconfig(wbp w, int status)
{
    wsp ws = w->window;
    wdp wd = ws->display;

    if (ws->win) {
        if (status & (C_POS | C_SIZE | C_MINSIZE | C_MAXSIZE | C_RESIZE)) {
            if (status != C_POS) {
                XSizeHints size_hints;
                size_hints.flags = PMinSize | PMaxSize;
                if (ws->resizable) {
                    size_hints.min_width = ws->minwidth;
                    size_hints.min_height = ws->minheight;
                    size_hints.max_width = ws->maxwidth;
                    size_hints.max_height = ws->maxheight;
                }
                else {
                    size_hints.min_width = size_hints.max_width = ws->width;
                    size_hints.min_height = size_hints.max_height = ws->height;
                }
                XSetWMNormalHints(wd->display, ws->win, &size_hints);
            }

            switch (status & (C_POS|C_SIZE)) {
                case C_POS: {
                    XMoveWindow(wd->display, ws->win, ws->x, ws->y);
                    break;
                }
                case C_SIZE: {
                    XResizeWindow(wd->display, ws->win, ws->width, ws->height);
                    break;
                }
                case C_POS|C_SIZE: {
                    XMoveResizeWindow(wd->display, ws->win, ws->x, ws->y, ws->width, ws->height);
                    break;
                }
            }
        }
    }
    if (status & C_SIZE)
        resizepixmap(w);
}

/*
 * data is a safe pointer into a frame.
 */
int sendselectionresponse(wbp w, word requestor, char *property, char *selection, char *target, word time, dptr data)
{
    Atom property_atom, target_atom, selection_atom, XA_TARGETS, target_list[32];
    XEvent theevent;
    struct lgstate state;
    tended struct b_lelem *le;
    tended char *cstr_target;
    int target_cnt = 1;
    wsp ws = w->window;
    wdp wd = ws->display;

    if (selection_debug)
        printf("sendselectionresponse:\n\trequestor=%lx "
               "property=%s target=%s selection=%s time=%ld\n",
               (long)requestor, property, target, selection, (long)time);

    property_atom = XInternAtom(wd->display, property, False);
    target_atom = XInternAtom(wd->display, target, False);
    selection_atom = XInternAtom(wd->display, selection, False);
    XA_TARGETS = ATOM(wd, TARGETS);

    if (target_atom == XA_TARGETS) {
        if (!is:list(*data))
            ReturnErrVal(108, *data, Error);
        target_list[0] = XA_TARGETS;
        for (le = lgfirst(&ListBlk(*data), &state); le;
             le = lgnext(&ListBlk(*data), &state, le)) {
            if (!cnv:C_string(le->lslots[state.result], cstr_target))
                ReturnErrVal(148, le->lslots[state.result], Error);
            target_list[target_cnt++] = XInternAtom(wd->display, cstr_target, False);
            if (selection_debug)
                printf("\tAdding target:%s\n", cstr_target);
        }
        XChangeProperty(wd->display,
                        requestor,
                        property_atom,
                        target_atom,
                        32,
                        PropModeReplace,
                        (unsigned char *)target_list,
                        target_cnt);
        theevent.xselection.property = property_atom;
    } else if (is:null(*data)) {
        /* Can't handle this target type */
        if (selection_debug)
            printf("\tSetting property to None\n");
        theevent.xselection.property = None;
    } else {
        if (!cnv:string(*data, *data))
            ReturnErrVal(103, *data, Error);
        if (selection_debug)
            printf("\tSetting property to %d bytes of data\n", (int)StrLen(*data));
        XChangeProperty(wd->display,
                        requestor,
                        property_atom,
                        target_atom,
                        8,
                        PropModeReplace,
                        (unsigned char *)StrLoc(*data),
                        StrLen(*data));
        theevent.xselection.property = property_atom;
    }

    theevent.type = SelectionNotify;
    theevent.xselection.serial = 0; /*event.xselectionrequest.serial;*/
    theevent.xselection.send_event = True;
    theevent.xselection.requestor = requestor;
    theevent.xselection.selection = selection_atom;
    theevent.xselection.target = target_atom;
    theevent.xselection.time = time;

    XSendEvent(wd->display,
               requestor,
               False, NoEventMask, &theevent);

    return Succeeded;
}

int ownselection(wbp w, char *selname)
{
    Atom selection;
    Window curr;
    wsp ws = w->window;
    wdp wd = ws->display;

    if (!ws->win)
        return Failed;

    selection = XInternAtom(wd->display, selname, False);

    curr = XGetSelectionOwner(wd->display, selection);
    /* Check for no change in selection */
    if (curr == ws->win)
        return Succeeded;

    if (selection_debug)
        printf("Owner of selection %s set from %lx -> %lx\n", 
               atom_fmt(ws, selection),
               (long)curr,
               (long)ws->win);

    /*
     * X doesn't send a SelectionClear event to us when the selection
     * changes between our own windows, so if the current owner is one
     * our windows, send it a "clear" message.
     */
    if (curr) {
        wsp x;
        for (x = vwstates; x; x = x->vnext) {
            if (x->win == curr) {
                tended struct descrip tmp;
                if (selection_debug)
                    printf("Enqueueing artificial SELECTIONCLEAR to current owner %lx\n",(long)curr);
                MakeInt(SELECTIONCLEAR, &tmp);
                list_put(&x->listp, &tmp);
                get_atom_descriptor(x, selection, &tmp);
                list_put(&x->listp, &tmp);
                break;
            }
        }
    }

    XSetSelectionOwner(wd->display, 
                       selection,
                       ws->win,
                       CurrentTime);

    return Succeeded;
}

int requestselection(wbp w, char *selname, char *targetname)
{
    Atom selection, target;
    wsp ws = w->window;
    wdp wd = ws->display;
    if (!ws->win)
        return Failed;
    selection = XInternAtom(wd->display, selname, False);
    target = XInternAtom(wd->display, targetname, False);
    if (selection_debug)
        printf("getselectioncontent: calling XConvertSelection selection=%s target=%s requestor=%lx\n",
               atom_fmt(ws, selection),
               atom_fmt(ws, target),
               (long)ws->win);

    XConvertSelection(wd->display,
                      selection, 
                      target, 
                      ATOM(wd, _OBJECTICON_PROP), 
                      ws->win,
                      CurrentTime);

    return Succeeded;
}

int warppointer(wbp w, int x, int y)
{
    wsp ws = w->window;
    if (!ws->win)
        return Failed;
    XWarpPointer(ws->display->display, None, ws->win, 0,0,0,0, x, y);
    return Succeeded;
}

/*
 * setwindowlabel
 */
int setwindowlabel(wbp w, char *s)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    if (ws->windowlabel)
        free(ws->windowlabel);
    ws->windowlabel = salloc(s);

    if (ws->win)
        XChangeProperty(wd->display, ws->win,
                        ATOM(wd, _NET_WM_NAME), 
                        ATOM(wd, UTF8_STRING),
                        8,
                        PropModeReplace, 
                        (unsigned char *)ws->windowlabel,
                        strlen(ws->windowlabel));

    return Succeeded;
}

static void synch_cursor(wsp ws)
{
    int i;
    wdp wd = ws->display;
    i = ws->cursor->i >> 1;
    if (!wd->cursors[i])
        wd->cursors[i] = XCreateFontCursor(wd->display, 2 * i);
    XDefineCursor(wd->display, ws->win, wd->cursors[i]);
}

/*
 * setpointer() - define a mouse pointer shape
 */
int setpointer(wbp w, char *val)
{
    stringint *e;
    wsp ws = w->window;
    e = stringint_lookup(cursors, val);
    if (!e)
        return Failed;
    ws->cursor = e;
    if (ws->win)
        synch_cursor(ws);
    return Succeeded;
}

/*
 * setdrawop() - set the drawing operation
 */
int setdrawop(wbp w, char *val)
{
    stringint *e;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;
    XSync(wd->display, False);
    e = stringint_lookup(drawops, val);
    if (!e)
        return Failed;
    wc->drawop = e;
    return Succeeded;
}

/*
 * rebind() - bind w's context to that of w2.
 */
int rebind(wbp w, wbp w2)
{
    if (w->window->display != w2->context->display) {
        LitWhy("Can't couple between different displays");
        return Failed;
    }
    w->context = w2->context;
    return Succeeded;
}

static void clip(wbp w)
{
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;
    XRectangle rec;
    if (wc->clipw >= 0) {
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XRenderSetPictureClipRectangles(wd->display,
                                        ws->ppic,
                                        0, 0, &rec, 1);
        if (ws->wpic)
            XRenderSetPictureClipRectangles(wd->display,
                                             ws->wpic,
                                             0, 0, &rec, 1);
    }
}

static void unclip(wbp w)
{
    XRenderPictureAttributes attr;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;
    if (wc->clipw >= 0) {
        attr.clip_mask = None;
        XRenderChangePicture(wd->display,
                             ws->ppic,
                             CPClipMask,
                             &attr);
        if (ws->wpic)
            XRenderChangePicture(wd->display,
                                 ws->wpic,
                                 CPClipMask,
                                 &attr);
    }
}

char *getcanvas(wbp w)
{
    char *v = stringint_int2str(canvastypes, w->window->state);
    if (!v)
        syserr("Invalid value of state");
    return v;
}

/*
 *  Set the canvas type
 */
int setcanvas(wbp w, char *s)
{
    stringint *e;
    wsp ws = w->window;
    wdp wd = ws->display;
    e = stringint_lookup(canvastypes, s);
    if (!e)
        return Failed;
    if (e->i == ws->state)
        return Succeeded;

    if (!ws->win) {
        if (e->i != HiddenState) {
            ws->state = e->i;
            wmap(w);
        }
        return Succeeded;
    }

    switch (e->i) {
        case IconicState: {
            if (ws->state == RootState || ws->state == PopupState)
                return Failed;
            if (ws->state == WithdrawnState) {
                XWMHints wmhints;
                wmhints.flags = StateHint;
                wmhints.initial_state = IconicState;
                XSetWMHints(wd->display, ws->win, &wmhints);
                XMapWindow(wd->display, ws->win);
            } else
                XIconifyWindow(wd->display, ws->win, DefaultScreen(wd));
            break;
        }

        case WithdrawnState: {
            if (ws->state == RootState || ws->state == PopupState)
                return Failed;
            XWithdrawWindow(wd->display, ws->win, DefaultScreen(wd));
            break;
        }

        case NormalState:
        case MaximizedState:
        case FullScreenState: {
            if (ws->state == RootState || ws->state == PopupState)
                return Failed;
            if (ws->state == WithdrawnState) {
                XWMHints wmhints;
                wmhints.flags = StateHint;
                wmhints.initial_state = NormalState;
                XSetWMHints(wd->display, ws->win, &wmhints);
            }
            XMapWindow(wd->display, ws->win);
            synch_net_wm_state(ws, e->i);
            break;
        }

        case PopupState:
        case RootState:
            return Failed;

        case HiddenState: {
            close_screen_win(ws);
            break;
        }
        default:
            syserr("Unexpected canvas state");
    }
    return Succeeded;
}

/*
 * Set the context's line style by name.
 */
int setlinestyle(wbp w, char *val)
{
    stringint *e;
    wcp wc = w->context;
    e = stringint_lookup(linestyles, val);
    if (!e)
        return Failed;
    wc->linestyle = e;
    return Succeeded;
}

/*
 * Set the context's line width
 */
int setlinewidth(wbp w, int linewid)
{
    wcp wc = w->context;
    if (linewid < 0) return Error;
    wc->linewidth = linewid;
    return Succeeded;
}

int getlinewidth(wbp w)
{
    return w->context->linewidth;
}

/*
 * Set the context's foreground color by name.
 */
int setfg(wbp w, char *s)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(s, &r, &g, &b, &a))
        return Failed;
    if (wc->fg)
        unlink_sharedcolor(wc->display, wc->fg);
    wc->fg = new_sharedcolor(wc->display, s, r, g, b, a);
    return Succeeded;
}

/*
 * Set the window context's background color by name.
 */
int setbg(wbp w, char *s)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(s, &r, &g, &b, &a))
        return Failed;
    if (wc->bg)
        unlink_sharedcolor(wc->display, wc->bg);
    wc->bg = new_sharedcolor(wc->display, s, r, g, b, a);
    return Succeeded;
}

char *getdisplay(wbp w)
{
    char *tmp;
    wdp wd = w->window->display;
    if (!strcmp(wd->name, "")) {
        if ((tmp = getenv("DISPLAY")) != NULL)
            return tmp;
        else
            return "";
    }
    else return wd->name;
}

char *getwindowlabel(wbp w)
{
    return w->window->windowlabel;
}

int getdisplaysize(wbp w, int *width, int *height)
{
    *width = GetWidth(w->window->display);
    *height = GetHeight(w->window->display);
    return Succeeded;
}

int getdepth(wbp w, int *res)
{
    *res = GetDepth(w->window->display);
    return Succeeded;
}

/*
 * getpos() - update the window state's notion of its current position
 */
int getpos(wbp w)
{
    Window garbage1, garbage2;
    int root_x, root_y, win_x, win_y;
    unsigned int key_buttons;
    wsp ws = w->window;
    wdp wd = ws->display;
    if (!ws->win) return Failed;
    /*
     * This call is made because it is guaranteed to generate
     * a synchronous request of the server, not just ask Xlib
     * what the window position was last it knew.
     */
    if (XQueryPointer(wd->display, ws->win, &garbage1, &garbage2,
                      &root_x, &root_y, &win_x, &win_y, &key_buttons) ==
        False) {
        return Failed;
    }
    ws->x = root_x - win_x;
    ws->y = root_y - win_y;
    return Succeeded;
}

char *getfg(wbp w)
{
    return w->context->fg->name;
}

char *getbg(wbp w)
{
    return w->context->bg->name;
}

char *getlinestyle(wbp w)
{
    return w->context->linestyle->s;
}

char *getpointer(wbp w)
{
    return w->window->cursor->s;
}

char *getdrawop(wbp w)
{
    return w->context->drawop->s;
}

int grabpointer(wbp w)
{
    wsp ws = w->window;
    if (!ws->win)
        return Failed;
    if (XGrabPointer(ws->display->display, ws->win,False, 
                     ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | PointerMotionMask,
                     GrabModeAsync, GrabModeAsync, None, None, CurrentTime) == GrabSuccess)
        return Succeeded;
    else
        return Failed;
}

int ungrabpointer(wbp w)
{
    wsp ws = w->window;
    if (!ws->win)
        return Failed;
    XUngrabPointer(ws->display->display, CurrentTime);
    return Succeeded;
}

/*
 * Set the window's font by name.
 */
int setfont(wbp w, char *s)
{
    wfp tmp;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;

    tmp = loadfont(wd, s);
    if (!tmp)
        return Failed;
    wc->font = tmp;
    return Succeeded;
}

static void pix_to_win(wsp ws, int x, int y, int w, int h)
{
    wdp wd = ws->display;
    if (ws->win)
        XRenderComposite(wd->display, PictOpSrc, ws->ppic, 0, ws->wpic,
                         x,y,0,0,x,y,w,h);
}

/*
 * callback procedures
 */

static void handle_exposures(wsp ws, XExposeEvent *event)
{
    pix_to_win(ws, event->x, event->y, event->width, event->height);
}

/*
 * resizepixmap(w,width,height) -- ensure w's backing pixmap is at least
 * width x height pixels.
 *
 * Resizes the backing pixmap, if needed.  Called when X resize events
 * arrive, as well as when programs make explicit resize requests.
 *
 */
static void resizepixmap(wbp w)
{
    Pixmap p;
    Picture pp;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;
    int old_w, old_h;
    XRenderPictureAttributes attr;

    if ((ws->width == ws->pixwidth) && (ws->height == ws->pixheight))
        return;

    old_w = ws->pixwidth;
    old_h = ws->pixheight;
    ws->pixheight = Max(1, ws->height);
    ws->pixwidth  = Max(1, ws->width);
    p = XCreatePixmap(wd->display, GetRoot(wd), ws->pixwidth, ws->pixheight, 32);
    attr.poly_edge = PolyEdge;
    pp = XRenderCreatePicture(wd->display, p, wd->pixfmt, CPPolyEdge, &attr);
    /* Fill with bg colour */
    XRenderFillRectangle(wd->display,
                         PictOpSrc,
                         pp,
                         &wc->bg->color,
                         0, 0, ws->pixwidth, ws->pixheight);

    XRenderComposite(wd->display, PictOpSrc, ws->ppic, 0, pp,
                     0,0,0,0,0,0, old_w, old_h);

    XFreePixmap(wd->display, ws->pix);	/* free old pixmap */
    XRenderFreePicture(wd->display, ws->ppic);
    ws->pix = p;
    ws->ppic = pp;
    if (ws->pxft) {
        XftDrawDestroy(ws->pxft);
        ws->pxft = NULL;
    }
}

static void synch_state(wsp ws)
{
    Atom actual_type;
    int actual_format;
    unsigned long bytes_after, nitems;
    unsigned char *prop;
    unsigned long state;
    wdp wd = ws->display;

    if (ws->win == (Window) NULL) {
        ws->state = HiddenState;
        return;
    }

    if (ws->state == PopupState || ws->state == RootState)
        return;

    if (XGetWindowProperty(wd->display,
                           ws->win,
                           ATOM(wd, WM_STATE),
                           0,
                           1,
                           False,
                           ATOM(wd, WM_STATE),
                           &actual_type,
                           &actual_format,
                           &nitems,
                           &bytes_after,
                           &prop) != Success)
        return;
    
    if (actual_type == ATOM(wd, WM_STATE))
        state = *((unsigned long *)prop);
    else 
        /* WM_STATE absent => withdrawn */
        state = WithdrawnState;

    if (prop) XFree(prop);

    if (state == WithdrawnState || state == IconicState) {
        ws->state = state;
        return;
    }

    /* Normal state, so check if maximized, etc */

    if (XGetWindowProperty(wd->display,
                           ws->win,
                           ATOM(wd, _NET_WM_STATE),
                           0,
                           8192,
                           False,
                           XA_ATOM,
                           &actual_type,
                           &actual_format,
                           &nitems,
                           &bytes_after,
                           &prop) != Success)
        return;

    if (actual_type == XA_ATOM) {
        int i, max = 0;
        Atom *atoms = (Atom *)prop;
        for (i = 0; i < nitems; ++i) {
            if (atoms[i] == ATOM(wd, _NET_WM_STATE_MAXIMIZED_VERT))
                max |= 1;
            else if (atoms[i] == ATOM(wd, _NET_WM_STATE_MAXIMIZED_HORZ))
                max |= 2;
            else if (atoms[i] == ATOM(wd, _NET_WM_STATE_FULLSCREEN))
                max |= 4;
        }
        if (max == 3)
            ws->state = MaximizedState;
        else if (max == 4)
            ws->state = FullScreenState;
        else
            ws->state = NormalState;
    } else
        /* Unexpected, assume normal state */
        ws->state = NormalState;

    if (prop) XFree(prop);
}

static void handle_property(wsp ws, XPropertyEvent *event)
{
    if (event->atom == ATOM(ws->display, WM_STATE) ||
        event->atom == ATOM(ws->display, _NET_WM_STATE))
        synch_state(ws);
}

/*
 * Resize operations are made as painless as possible, but the
 * user program is informed anyhow.  The integer coordinates are
 * the new size of the window, in pixels.
 */
static void handle_config(wsp ws, XConfigureEvent *event)
{
    /*
     * Update X-Icon's information about the window's configuration
     */

    ws->x = event->x;
    ws->y = event->y;

    /*
     * If this was not a resize, drop it
     */
    if ((event->width == ws->width) && (event->height == ws->height))
        return;

    ws->width = event->width;
    ws->height = event->height;

    resizepixmap(findwbp(ws));

    qeventcode(ws, WINDOWRESIZED);
}

static int make_mod(unsigned int state)
{
    int x = 0;

    if (state & ShiftMask)
        x |= MOD_SHIFT;
    if (state & LockMask)
        x |= MOD_LOCK;
    if (state & ControlMask)
        x |= MOD_CTRL;
    if (state & Mod1Mask)
        x |= MOD_META;
    if (state & Mod2Mask)
        x |= MOD_META2;
    if (state & Mod3Mask)
        x |= MOD_META3;
    if (state & Mod4Mask)
        x |= MOD_META4;
    if (state & Mod5Mask)
        x |= MOD_META5;
    return x;
}

static void handle_crossing(wsp ws, XCrossingEvent *event)
{
    struct descrip d;
    if (event->mode != NotifyNormal)
        return;
    MakeInt(event->type == EnterNotify ? MOUSEENTERED:MOUSEEXITED, &d);
    qevent(ws, &d, event->x, event->y,
           (uword)event->time, 
           make_mod(event->state));
}

/*
 * Queue up characters for keypress events.
 */
static void handle_keypress(wsp ws, XKeyEvent *event)
{
    int i, j, fl;
    char s[10];
    tended struct descrip d;
    KeySym k;

    fl = make_mod(event->state);
    if (event->type == KeyRelease)
        fl |= MOD_RELEASE;
    /* First try to convert the event to a simple char string, and a KeySym */
    i = XLookupString(event, s, sizeof(s), &k, NULL);
    if (i > 0) {
        /* Found a char string, so generate string event(s) */
        StrLen(d) = 1;
        for (j = 0; j < i; j++) {
            StrLoc(d) = &allchars[s[j] & 0xFF];
            qevent(ws, &d, event->x, event->y,
                   (uword)event->time, fl);
        }
        return;
    }

    /* Second try is to convert to a unicode char; if found generate a 1-char
     * ucs/string */
    i = convert_KeySym_to_code_point(k);
    if (i > 0) {
        if (i < 256) {
            StrLen(d) = 1;
            StrLoc(d) = &allchars[i];
        } else {
            d.dword = D_Ucs;
            BlkLoc(d) = (union block *)make_one_char_ucs_block(i);
        }
        qevent(ws, &d, event->x, event->y,
               (uword)event->time, fl);
        return;
    }

    /* Neither of those worked, so it must be a non-character key (cursor key, etc).
     * So just generate the numerical value of the KeySym as an integer.
     */
    MakeInt(k, &d);
    qevent(ws, &d, event->x, event->y,
           (uword)event->time, fl);
}

#include "rxkeysyms.ri"

/*
 * Handle button presses and drag events.  In the case of drags, we should
 * really be looking at an XMotionEvent instead of an XButtonEvent, but
 * the structures are identical up to the button field (which we do not
 * examine for drag events).  Mouse coordinates are queued up after the event.
 */
static void handle_mouse(wsp ws, XButtonEvent *event)
{
    int state = 0;
    if (event->state & Button1Mask) state |= 1;
    if (event->state & Button2Mask) state |= 2;
    if (event->state & Button3Mask) state |= 4;
    if (event->state & Button4Mask) state |= 8;
    if (event->state & Button5Mask) state |= 16;
    switch (event->type) {
        case ButtonPress: {
            switch (event->button) {
                case Button1: state |= 1; break;
                case Button2: state |= 2; break;
                case Button3: state |= 4; break;
                case Button4: state |= 8; break;
                case Button5: state |= 16; break;
            }
            break;
        }
        case ButtonRelease: {
            switch (event->button) {
                case Button1: state &= ~1; break;
                case Button2: state &= ~2; break;
                case Button3: state &= ~4; break;
                case Button4: state &= ~8; break;
                case Button5: state &= ~16; break;
            }
            break;
        }
    }
    qmouseevents(ws, state, 
                 event->x, event->y, 
                 (uword)event->time, 
                 make_mod(event->state));
}

void drawarc(wbp w, int x, int y, int width, int height, double angle1, double angle2)
{
}

void fillarc(wbp w, int x, int y, int width, int height, double angle1, double angle2)
{ 
    XPointDouble *pol;
    double th, r1, r2, cx, cy, x1, y1;
    int d, i, segs, pc;
    r1 = width / 2.0;
    r2 = height / 2.0;
    cx = x + r1;
    cy = y + r2;
    d = Max(width, height);
    if (d < 5)
        segs = 4;
    else if (d < 10)
        segs = 8;
    else if (d < 20)
        segs = 10;
    else if (d < 30)
        segs = 15;
    else if (d < 100)
        segs = 20;
    else
        segs = 25;
    segs *= (angle2 - angle1) / (2 * Pi);
    segs = Max(segs, 2);
    pol = alloca((segs + 2) * sizeof(XPointDouble));
    if (angle1 == 0.0 && angle2 == 2 * Pi) {
        pc = 0;
    } else {
        pol[0].x = cx;
        pol[0].y = cy;
        pc = 1;
    }
    for (i = 0; i < segs; ++i) {
        th = angle1 + (angle2 - angle1) * i / segs;
        x1 = cx + r1 * cos(th);
        y1 = cy + r2 * sin(th);
        pol[pc].x = x1;
        pol[pc].y = y1;
        ++pc;
    }
    pol[pc].x = cx + r1 * cos(angle2);
    pol[pc].y = cy + r2 * sin(angle2);
    ++pc;
    clip(w);
    poly2(w, pol, pc);
    unclip(w);
}

/*
 * The orientation of the computed corner points is always the same
 * (p0 and q0 are the given input points), as follows :-
 *  
 *   p2 -------------------- q2      ^
 *   |                       |       |
 *   p0       -->--          q0   linewidth
 *   |                       |       |
 *   p1 ---------------------q1      v
 *
 *   <-------- len ---------->
 * 
 * p1,p2,q1,q2 have double elements, but for horizontal or vertical
 * lines, the values will be whole numbers, so that these lines can be
 * drawn as simple rectangles without antialiasing having an effect.
 */

struct lineinfo {
    struct point *p0, *q0;
    int dx, dy;
    double len;
    XPointDouble p1, p2, q1, q2;
};

static void getlineinfo(wcp wc, struct point *p0, struct point *q0, struct lineinfo *res)
{
    res->p0 = p0;
    res->q0 = q0;
    res->dx = q0->x - p0->x;
    res->dy = q0->y - p0->y;
    if (res->dx == 0) {
        if (res->dy > 0) {
            res->len = res->dy;
            res->p1 = doublept(p0->x - wc->linewidth / 2, p0->y);
            res->p2 = doublept(res->p1.x + wc->linewidth, p0->y);
            res->q1 = doublept(res->p1.x, q0->y);
            res->q2 = doublept(res->p2.x, q0->y);
        } else {
            res->len = -res->dy;
            res->p2 = doublept(p0->x - wc->linewidth / 2, p0->y);
            res->p1 = doublept(res->p2.x + wc->linewidth, p0->y);
            res->q2 = doublept(res->p2.x, q0->y);
            res->q1 = doublept(res->p1.x, q0->y);
        }
    } else if (res->dy == 0) {
        if (res->dx > 0) {
            res->len = res->dx;
            res->p2 = doublept(p0->x, p0->y - wc->linewidth / 2);
            res->p1 = doublept(p0->x, res->p2.y + wc->linewidth);
            res->q2 = doublept(q0->x, res->p2.y);
            res->q1 = doublept(q0->x, res->p1.y);
        } else {
            res->len = -res->dx;
            res->p1 = doublept(p0->x, p0->y - wc->linewidth / 2);
            res->p2 = doublept(p0->x, res->p1.y + wc->linewidth);
            res->q1 = doublept(q0->x, res->p1.y);
            res->q2 = doublept(q0->x, res->p2.y);
        }
    } else {
        double ex, ey;
        res->len = hypot(res->dx, res->dy);
        ex = (wc->linewidth * res->dy) / (2 * res->len);
        ey = -(wc->linewidth * res->dx) / (2 * res->len);
        res->p1 = doublept(p0->x - ex ,p0->y - ey);
        res->p2 = doublept(p0->x + ex, p0->y + ey);
        res->q1 = doublept(q0->x - ex ,q0->y - ey);
        res->q2 = doublept(q0->x + ex, q0->y + ey);
    }
}

#if 0
static void printlineinfo(struct lineinfo *li)
{
    printf("from p0(%d,%d) to q0(%d,%d) : len=%f dx=%d dy=%d p1(%f,%f) p2(%f,%f) q1(%f,%f) q2(%f,%f)\n",
           li->p0->x, li->p0->y,
           li->q0->x, li->q0->y,
           li->len, li->dx, li->dy,
           li->p1.x, li->p1.y,
           li->p2.x, li->p2.y,
           li->q1.x, li->q1.y,
           li->q2.x, li->q2.y);
}
#endif

static void calc_extent(struct lineinfo *lis, int n, int *x, int *y, int *width, int *height)
{
    int i;
    int x1, x2, y1, y2;
    for (i = 0; i < n; ++i) {
        struct lineinfo *li = &lis[i]; 
        if (i == 0) {
            x1 = x2 = li->p1.x;
            y1 = y2 = li->p1.y;
        } else {
            if (li->p1.x < x1) x1 = li->p1.x;
            if (li->p1.x > x2) x2 = li->p1.x;
            if (li->p1.y < y1) y1 = li->p1.y;
            if (li->p1.y > y2) y2 = li->p1.y;
        }
        if (li->p2.x < x1) x1 = li->p2.x;
        if (li->p2.x > x2) x2 = li->p2.x;
        if (li->p2.y < y1) y1 = li->p2.y;
        if (li->p2.y > y2) y2 = li->p2.y;
        if (li->q1.x < x1) x1 = li->q1.x;
        if (li->q1.x > x2) x2 = li->q1.x;
        if (li->q1.y < y1) y1 = li->q1.y;
        if (li->q1.y > y2) y2 = li->q1.y;
        if (li->q2.x < x1) x1 = li->q2.x;
        if (li->q2.x > x2) x2 = li->q2.x;
        if (li->q2.y < y1) y1 = li->q2.y;
        if (li->q2.y > y2) y2 = li->q2.y;
    }
    *x = x1 - 1;
    *y = y1 - 1;
    *width = x2 - x1 + 2;
    *height = y2 - y1 + 2;
}

static XPointDouble doublept(double x, double y)
{
    XPointDouble t;
    t.x = x;
    t.y = y;
    return t;
}

static XTriangle triangle(double x1, double y1, double x2, double y2, double x3, double y3)
{
    XTriangle t;
    t.p1.x = XDoubleToFixed(x1);
    t.p1.y = XDoubleToFixed(y1);
    t.p2.x = XDoubleToFixed(x2);
    t.p2.y = XDoubleToFixed(y2);
    t.p3.x = XDoubleToFixed(x3);
    t.p3.y = XDoubleToFixed(y3);
    return t;
}

static XTrapezoid trapezoid(double top, double x1, double x2, double bottom, double x3, double x4)
{
    XTrapezoid t;
    t.top = XDoubleToFixed(top);
    t.left.p1.x = XDoubleToFixed(x1);
    t.left.p1.y = t.top;
    t.right.p1.x = XDoubleToFixed(x2);
    t.right.p1.y = t.top;
    t.bottom = XDoubleToFixed(bottom);
    t.left.p2.x = XDoubleToFixed(x3);
    t.left.p2.y = t.bottom;
    t.right.p2.x = XDoubleToFixed(x4);
    t.right.p2.y = t.bottom;
    return t;
}

static void traps(wbp w,
                  int op,
                  Picture src,
                  Picture dest,
                  XPointDouble p1, double top, double x1, double x2,  double bottom, double x3, double x4, XPointDouble p2)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    XTriangle tri[2];
    XTrapezoid trap;
    top = round(top);
    bottom = round(bottom);
    tri[0] = triangle(p1.x,p1.y, x1,top, x2,top);
    tri[1] = triangle(p2.x,p2.y, x3,bottom, x4,bottom);
    XRenderCompositeTriangles(wd->display, op, src, dest, 0,0,0, tri, 2);
    trap = trapezoid(top, x1, x2, bottom, x3, x4);
    XRenderCompositeTrapezoids(wd->display, op, src,  dest, 0, 0, 0, &trap, 1);
}

static void drawlineinfo(wbp w,
                         int op,
                         Picture src,
                         Picture dest,
                         struct lineinfo *prev,
                         struct lineinfo *curr)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    wcp wc = w->context;

    if (curr->dx == 0 || curr->dy == 0) {
        int x, y, width, height;
        /*
         * This is equivalent to rendering using a trapezoid based on the 4 corner points.
         */
        if (curr->dx == 0) {
            width = wc->linewidth;
            height = curr->len;
            x = curr->p0->x - wc->linewidth / 2;
            y = Min(curr->p0->y, curr->q0->y);
        } else {   /* curr->dy == 0 */
            width = curr->len;
            height = wc->linewidth;
            x = Min(curr->p0->x, curr->q0->x);
            y = curr->p0->y - wc->linewidth / 2;
        }
        XRenderComposite(wd->display,
                         op,
                         src,          /* src */
                         None,         /* mask */
                         dest,         /* dest */
                         0,0,          /* src x,y */
                         0,0,          /* mask x,y */
                         x, y,         /* dst x,y */
                         width, height);
    } else {
        if (curr->q1.y > curr->p1.y && curr->p1.y > curr->q2.y) {
            traps(w, op, src, dest, 
                  curr->p2, 
                  curr->q2.y,  curr->p2.x - (curr->dy*curr->dy)/curr->dx, curr->q2.x,
                  curr->p1.y,  curr->p1.x, curr->q1.x + (curr->dy*curr->dy)/curr->dx,
                  curr->q1);
        } else if (curr->q1.y > curr->q2.y && curr->q2.y  > curr->p1.y) {
            traps(w, op, src, dest, 
                  curr->p2, 
                  curr->p1.y,  curr->p1.x,curr->p1.x + (wc->linewidth*curr->len)/curr->dy,
                  curr->q2.y,  curr->q2.x - (wc->linewidth*curr->len)/curr->dy,curr->q2.x,
                  curr->q1);
        } else if (curr->q2.y > curr->q1.y && curr->q1.y > curr->p2.y) {
            traps(w, op, src, dest, 
                  curr->p1, 
                  curr->p2.y,  curr->p2.x - (wc->linewidth*curr->len)/curr->dy,curr->p2.x,
                  curr->q1.y,  curr->q1.x,curr->q1.x + (wc->linewidth*curr->len)/curr->dy,
                  curr->q2);
        } else if (curr->q2.y > curr->p2.y && curr->p2.y > curr->q1.y) {
            traps(w, op, src, dest, 
                  curr->p1, 
                  curr->q1.y,  curr->q1.x,curr->p1.x - (curr->dy*curr->dy)/curr->dx,
                  curr->p2.y,  curr->q2.x + (curr->dy*curr->dy)/curr->dx,curr->p2.x,
                  curr->q2);
        } else if (curr->p2.y > curr->q2.y && curr->q2.y > curr->p1.y) {
            traps(w, op, src, dest, 
                  curr->q1, 
                  curr->p1.y,  curr->q1.x + (curr->dy*curr->dy)/curr->dx,curr->p1.x,
                  curr->q2.y,  curr->q2.x,curr->p2.x - (curr->dy*curr->dy)/curr->dx,
                  curr->p2);
        } else if (curr->p2.y > curr->p1.y && curr->p1.y > curr->q2.y) {
            traps(w, op, src, dest, 
                  curr->q1, 
                  curr->q2.y,  curr->q2.x,curr->q2.x - (wc->linewidth*curr->len)/curr->dy,
                  curr->p1.y,  curr->p1.x + (wc->linewidth*curr->len)/curr->dy,curr->p1.x,
                  curr->p2);
        } else if (curr->p1.y > curr->p2.y && curr->p2.y > curr->q1.y) {
            traps(w, op, src, dest, 
                  curr->q2, 
                  curr->q1.y,  curr->q1.x + (wc->linewidth*curr->len)/curr->dy,curr->q1.x,
                  curr->p2.y, curr->p2.x, curr->p2.x - (wc->linewidth*curr->len)/curr->dy,
                  curr->p1);
        } else if (curr->p1.y > curr->q1.y && curr->q1.y > curr->p2.y) {
            traps(w, op, src, dest, 
                  curr->q2, 
                  curr->p2.y,  curr->p2.x,curr->q2.x + (curr->dy*curr->dy)/curr->dx,
                  curr->q1.y, curr->p1.x - (curr->dy*curr->dy)/curr->dx,curr->q1.x, 
                  curr->p1);
        }
    }

    if (prev) {
        XTriangle tri;

        if (wc->linewidth == 1) {
            /*
             * This is a cosmetic corner-case where the adjustments to
             * a vertical/horizontal 1-pixel wide line to avoid
             * antialiasing cause a 1 pixel gap in the join corner.
             */
            if ((curr->dy == 0 && prev->dx == 0) || (curr->dx == 0 && prev->dy == 0))
                XRenderComposite(wd->display,
                                 op,
                                 src,          /* src */
                                 None,         /* mask */
                                 dest,         /* dest */
                                 0,0,          /* src x,y */
                                 0,0,          /* mask x,y */
                                 curr->p0->x, curr->p0->y,         /* dst x,y */
                                 1, 1);

        } else {
            /*
             * Fill in the gap between the current and previous line with a triangle.
             */
            if (curr->dx * prev->dy > curr->dy * prev->dx)
                tri = triangle(prev->q1.x, prev->q1.y, curr->p0->x, curr->p0->y, curr->p1.x, curr->p1.y);
            else
                tri = triangle(prev->q2.x, prev->q2.y, curr->p0->x, curr->p0->y, curr->p2.x,curr-> p2.y);
            XRenderCompositeTriangles(wd->display, op, src, dest, 0,0,0, &tri, 1);
        }
    }
}

static void drawlines_impl(wbp w, int op, Picture src, Picture dest, struct lineinfo *lis, int nlis)
{
    int i;
    for (i = 0; i < nlis; ++i) {
        if (i == 0) {
            if (nlis > 2 && 
                lis[nlis - 1].q0->x == lis[0].p0->x &&
                lis[nlis - 1].q0->y == lis[0].p0->y)
                drawlineinfo(w, op, src, dest, &lis[nlis - 1], &lis[i]);
            else
                drawlineinfo(w, op, src, dest, 0, &lis[i]);
        } else
            drawlineinfo(w, op, src, dest, &lis[i - 1], &lis[i]);
    }
}

void drawlines(wbp w, struct point *points, int npoints)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    wcp wc = w->context;
    struct lineinfo *lis;
    int nlis, i, x, y, width, height;

    nlis = npoints - 1;
    lis = alloca(nlis * sizeof(struct lineinfo));

    for (i = 1; i < npoints; ++i)
        getlineinfo(wc, &points[i - 1], &points[i], &lis[i - 1]);

    calc_extent(lis, nlis, &x, &y, &width, &height);
    /*printf("Extent : %d %d %d %d\n",x,y,width,height);*/

    clip(w);
    if (needmask(wc, 1)) {
        Picture mask = getmask(wd, width, height);
        for (i = 0; i < npoints; ++i) {
            points[i].x -= x;
            points[i].y -= y;
        }
        for (i = 0; i < nlis; ++i) {
            lis[i].p1.x -= x; lis[i].p1.y -= y;
            lis[i].p2.x -= x; lis[i].p2.y -= y;
            lis[i].q1.x -= x; lis[i].q1.y -= y;
            lis[i].q2.x -= x; lis[i].q2.y -= y;
        }
        drawlines_impl(w, PictOpOver, wd->white->brush, mask, lis, nlis);
        maskpic2(w, get_draw_picture(wc), mask, x, y, width, height);
        XRenderFreePicture(wd->display, mask);
    } else {
        drawlines_impl(w, wc->drawop->i, get_draw_picture(wc), ws->ppic, lis, nlis);
        pix_to_win(ws, x, y, width, height);
    }
    unclip(w);
}

void drawpoint(wbp w, int x, int y)
{
    fillrectangle(w, x, y, 1, 1);
}

static int needmask(wcp wc, int overlap)
{
    if (wc->pattern)
        return 1;
    if (!overlap)
        return 0;
    if (wc->drawop->i != PictOpOver)
        return 1;
    if (wc->fg->color.alpha != 0xffff)
        return 1;
    return 0;
}

static Picture getmask(wdp wd, int width, int height)
{
    Pixmap pix;
    Picture pic;
    XRenderPictureAttributes attr;
    pix = XCreatePixmap(wd->display, GetRoot(wd),
                        width, height,
                        8);
    attr.poly_edge = PolyEdge;
    pic = XRenderCreatePicture(wd->display, pix, wd->maskfmt, CPPolyEdge, &attr);
    XFreePixmap(wd->display, pix);
    XRenderFillRectangle(wd->display, PictOpSrc, pic, &wd->transparent->color, 0, 0, width ,height);
    return pic;
}

void drawrectangle(wbp w, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    wcp wc = w->context;
    int d = wc->linewidth / 2;

    /* If too small to give a gap in the middle, then simply fill a
     * rectangle, otherwise draw as four lines. */
    if (width <= wc->linewidth + 1 || height <= wc->linewidth + 1)
        fillrectangle(w, x - d, y - d, width + wc->linewidth - 1, height + wc->linewidth - 1);
    else {
        clip(w);
        /* Note that we know the two vertical lines will be at least one pixel high, since
         * height > wc->linewidth + 1.
         */
        if (needmask(wc, 0)) {
            Picture mask = getmask(wd, width + wc->linewidth - 1, height + wc->linewidth - 1);
            XRenderFillRectangle(wd->display, PictOpOver, mask, &wd->white->color, 0, 0 , width + wc->linewidth - 1, wc->linewidth);
            XRenderFillRectangle(wd->display, PictOpOver, mask, &wd->white->color, width - 1, wc->linewidth , wc->linewidth, height - wc->linewidth - 1);
            XRenderFillRectangle(wd->display, PictOpOver, mask, &wd->white->color, 0, wc->linewidth,  wc->linewidth, height - wc->linewidth - 1);
            XRenderFillRectangle(wd->display, PictOpOver, mask, &wd->white->color, 0, height - 1 , width + wc->linewidth - 1,  wc->linewidth);
            maskpic2(w, wc->pattern->i, mask, x - d, y - d, width + wc->linewidth - 1, height + wc->linewidth - 1);
            XRenderFreePicture(wd->display, mask);
        } else {
            fill2(w, wc->drawop->i, &wc->fg->color, x - d, y - d , width + wc->linewidth - 1, wc->linewidth);
            fill2(w, wc->drawop->i, &wc->fg->color, x - d + width - 1,    y - d +  wc->linewidth , wc->linewidth, height - wc->linewidth - 1);
            fill2(w, wc->drawop->i, &wc->fg->color, x - d,     y - d +  wc->linewidth,  wc->linewidth, height - wc->linewidth - 1);
            fill2(w, wc->drawop->i, &wc->fg->color, x - d, y - d + height - 1, width + wc->linewidth - 1,  wc->linewidth);
        }
        unclip(w);
    }
}

void fillpolygon(wbp w, struct point *points, int npoints)
{
    XPointDouble *xpoints;
    int i;
    xpoints = alloca(npoints * sizeof(XPointDouble));
    for (i = 0; i < npoints; ++i) {
        xpoints[i].x = points[i].x;
        xpoints[i].y = points[i].y;
    }
    clip(w);
    poly2(w, xpoints, npoints);
    unclip(w);
}

static void maskpic2(wbp w, Picture src, Picture mask, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    XRenderComposite(wd->display,
                     wc->drawop->i,
                     src,          /* src */
                     mask,         /* mask */
                     ws->ppic,     /* dest */
                     0,0,          /* src x,y */
                     0,0,          /* mask x,y */
                     x, y,         /* dst x,y */
                     width, height);
    pix_to_win(ws, x, y, width, height);
}

static void pic2(wbp w, Picture src, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    XRenderComposite(wd->display,
                     wc->drawop->i,
                     src,          /* src */
                     None,         /* mask */
                     ws->ppic,     /* dest */
                     0,0,          /* src x,y */
                     0,0,          /* mask x,y */
                     x, y,         /* dst x,y */
                     width, height);
    pix_to_win(ws, x, y, width, height);
}

static void fill2(wbp w, int op, XRenderColor *color, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    XRenderFillRectangle(wd->display,
                         op,
                         ws->ppic,
                         color,
                         x, y, width, height);
    pix_to_win(ws, x, y, width, height);
}

static void poly2(wbp w, XPointDouble *points, int npoints)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    int x1, y1, x2, y2, i;
    if (npoints == 0)
        return;

    XRenderCompositeDoublePoly(wd->display, 
                               wc->drawop->i,
                               get_draw_picture(wc),
                               ws->ppic, 
                               None, 0, 0, 0, 0,
                               points, npoints, 0);
    x1 = x2 = points[0].x;
    y1 = y2 = points[0].y;
    for (i = 1; i < npoints; ++i) {
        if (points[i].x < x1)
            x1 = points[i].x;
        if (points[i].y < y1)
            y1 = points[i].y;
        if (points[i].x > x2)
            x2 = points[i].x;
        if (points[i].y > y2)
            y2 = points[i].y;
    }
    pix_to_win(ws, x1, y1, x2 - x1 + 1, y2 - y1 + 1);
}

static Pixmap imgdata_to_Pixmap(wdp wd, struct imgdata *imd)
{
    XImage *xi;
    Pixmap pix;
    GC gc;
    if (imd->format != wd->format)
        syserr("wrong imgdata format");

    MemProtect(xi = XCreateImage(wd->display, 
                                 GetVisual(wd), 
                                 32,            /* depth */
                                 ZPixmap, 
                                 0, 
                                 (char *)imd->data, 
                                 imd->width, imd->height, 
                                 BitmapPad(wd->display),
                                 0));

    pix = XCreatePixmap(wd->display, GetRoot(wd),
                      imd->width, imd->height,
                      32);
    gc = XCreateGC(wd->display, pix, 0, NULL);
    XPutImage(wd->display, pix, gc, xi,
              0,0, 0,0, imd->width, imd->height);
    xi->data = 0;
    XDestroyImage(xi);
    XFreeGC(wd->display, gc);
    return pix;
}

static Picture get_draw_picture(wcp wc)
{
    if (wc->pattern)
        return wc->pattern->i;
    else
        return wc->fg->brush;
}

/*
 * fill a rectangle
 */
void fillrectangle(wbp w, int x, int y, int width, int height)
{
    wcp wc = w->context;
    clip(w);
    /*
     * fill the rectangle with the pattern or foreground color
     */
    if (wc->pattern)
        pic2(w, 
             wc->pattern->i, 
             x, y, width, height);
    else
        fill2(w,
              wc->drawop->i,
              &wc->fg->color,
              x, y, width, height);
    unclip(w);
}

/*
 * erase an area
 */
void erasearea(wbp w, int x, int y, int width, int height)
{
    wcp wc = w->context;
    clip(w);
    /*
     * fill the rectangle with the background color
     */
    fill2(w,
          PictOpSrc,
          &wc->bg->color,
          x, y, width, height);
    unclip(w);
}

/*
 * copy an area
 */
int copyarea(wbp w, int x, int y, int width, int height, wbp w2, int x2, int y2)
{
    wsp ws1 = w->window;
    wsp ws2 = w2->window;
    wcp wc2 = w2->context;
    wdp wd1 = ws1->display;
    wdp wd2 = ws2->display;

    if (wd1->display != wd2->display) {
        LitWhy("Can't copy between different displays");
        return Failed;
    }

    /*
     * Copying is between windows on one display, perhaps the same window.
     */
    clip(w2);

    /*
     * Copy the area.
     */
    XRenderComposite(wd1->display,
                     wc2->drawop->i,
                     ws1->ppic,    /* src */
                     None,         /* mask */
                     ws2->ppic,    /* dest */
                     x, y,         /* src_x,y */
                     0, 0,         /* mask x,y */
                     x2, y2,       /* dst x,y */
                     width, height);
    pix_to_win(ws2, x2, y2, width, height);
    unclip(w2);
    return Succeeded;
}

void captureimgdata(wbp w, int x, int y, struct imgdata *imd)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    XImage *xi;
    MemProtect(xi = XGetImage(wd->display, ws->pix,
                              x, y, imd->width, imd->height,
                              AllPlanes, ZPixmap));
    imd->format = wd->format;
    imd->data = (unsigned char *)xi->data;
    xi->data = 0;
    XDestroyImage(xi);
}

void outputimgdata(wbp w, int x, int y, struct imgdata *imd)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    Pixmap pix;
    Picture pic;
    pix = imgdata_to_Pixmap(wd, imd);
    pic = XRenderCreatePicture(wd->display, pix, wd->pixfmt, 0, 0);
    clip(w);
    pic2(w,
         pic,
         x, y, imd->width, imd->height);
    unclip(w);
    XFreePixmap(wd->display, pix);
    XRenderFreePicture(wd->display, pic);
}

struct imgdataformat *getimgdataformat(wbp w)
{
    return w->window->display->format;
}

int querypointer(wbp w, int *x, int *y)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    Window garbage1, garbage2;
    int root_x, root_y;
    unsigned int key_buttons;
    if (!ws->win)
        return Failed;
    XQueryPointer(wd->display, ws->win, &garbage1, &garbage2,
                  &root_x, &root_y, x, y, &key_buttons);
    return Succeeded;
}

int queryrootpointer(wbp w, int *x, int *y)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    Window garbage1, garbage2;
    int win_x, win_y;
    unsigned int key_buttons;
    XQueryPointer(wd->display, GetRoot(wd), &garbage1, &garbage2,
                  x, y, &win_x, &win_y, &key_buttons);
    return Succeeded;
}

int raisewindow(wbp w)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    if (!ws->win)
        return Failed;

    XMapRaised(wd->display, ws->win);

    /* Wait for the window to become viewable before giving
       it the focus. */
    for (;;) {
        XWindowAttributes attr;
        XGetWindowAttributes(wd->display, ws->win, &attr);
        if (attr.map_state == IsViewable)
            break;
        /* Not viewable yet, so wait for a MapNotify event. */
        pollevent(w);
    }

    /* Now it is viewable, so give it the focus. */
    XSetInputFocus(wd->display, ws->win, RevertToParent, CurrentTime);

    return Succeeded;
}

int lowerwindow(wbp w)
{
    wsp ws = w->window;
    if (!ws->win)
        return Failed;
    XLowerWindow(ws->display->display, ws->win);
    return Succeeded;
}

int walert(wbp w, int volume)
{
    wsp ws = w->window;
    wdp wd = ws->display;
    XBell(wd->display, volume);    
    XFlush(wd->display);
    return Succeeded;
}

int textwidth(wbp w, char *s, int n)
{
    XGlyphInfo	extents; 
    XftTextExtents8 (w->window->display->display,
                     w->context->font->fsp,
                     (FcChar8 *)s,
                     n,
                     &extents);
    return extents.xOff;
}

int utf8width(wbp w, char *s, int n, int nchars)
{
    XGlyphInfo	extents; 
    XftTextExtentsUtf8 (w->window->display->display,
                        w->context->font->fsp,
                        (FcChar8 *)s,
                        n,
                        &extents);
    return extents.xOff;
}

static void prepare_xft(wbp w)
{
    XRectangle rec;
    wcp wc = w->context;
    wsp ws = w->window;
    wdp wd = ws->display;

    if (!ws->pxft)
        MemProtect(ws->pxft = XftDrawCreateAlpha(wd->display, ws->pix, 32));

    if (wc->clipw >= 0) {
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XftDrawSetClipRectangles(w->window->pxft, 0, 0, &rec, 1);
    } else
        XftDrawSetClip(w->window->pxft, 0);
}

void drawstring(wbp w, int x, int y, char *str, int slen)
{
    XftColor color;
    wcp wc = w->context;
    wsp ws = w->window;
    prepare_xft(w);
    color.pixel = 0;
    color.color = wc->fg->color;
    XftDrawString8 (ws->pxft,
                    &color,
                    wc->font->fsp,
                    x,
                    y,
                    (FcChar8 *)str,
                    slen);
    clip(w);
    pix_to_win(ws, x, y - wc->font->ascent, textwidth(w, str, slen) + wc->font->maxwidth, wc->font->height);
    unclip(w);
}

void drawutf8(wbp w, int x, int y, char *str, int slen, int nchars)
{
    XftColor color;
    wcp wc = w->context;
    wsp ws = w->window;
    prepare_xft(w);
    color.pixel = 0;
    color.color = wc->fg->color;
    XftDrawStringUtf8 (ws->pxft,
                       &color,
                       wc->font->fsp,
                       x,
                       y,
                       (FcChar8 *)str,
                       slen);
    clip(w);
    pix_to_win(ws, x, y - wc->font->ascent, utf8width(w, str, slen, nchars) + wc->font->maxwidth, wc->font->height);
    unclip(w);
}

/* This array must correspond with the NUMATOMS and ATOM_xxx constants defined in xwin.h. */
char *atom_names[NUMATOMS] = {
    "CHARACTER_POSITION",
    "CLIENT_WINDOW",
    "HOSTNAME",
    "HOST_NAME",
    "LENGTH",
    "LIST_LENGTH",
    "NAME",
    "OWNER_OS",
    "SPAN",
    "TARGETS",
    "TIMESTAMP",
    "USER",
    "WM_DELETE_WINDOW",
    "_OBJECTICON_PROP",
    "_NET_WM_STATE_MAXIMIZED_VERT",
    "_NET_WM_STATE_MAXIMIZED_HORZ",
    "_NET_WM_STATE_FULLSCREEN",
    "_NET_WM_STATE",
    "_NET_WM_ICON",
    "_NET_WM_NAME",
    "UTF8_STRING",
    "WM_STATE",
};

/*
 * allocate a display on machine s
 */
static wdp alcdisplay(char *s)
{
    wdp wd;
    Visual *vis;
    XVisualInfo xvi, *xvi_ret;
    int nitems_return;
    int major_version, minor_version;

    if (s == NULL) s = getenv("DISPLAY");
    if (s == NULL) s = "";
    for(wd = wdsplys; wd; wd = wd->next)
        if (wd->program == curpstate && !strcmp(wd->name,s)) {
            return wd;
        }

    MemProtect(wd = calloc(1, sizeof(struct _wdisplay)));

    strcpy(wd->name,s);
    wd->program = curpstate;
    wd->display = XOpenDisplay((*s=='\0') ? NULL : s);
    if (wd->display == NULL) {
        LitWhy("Couldn't connect to display");
        free(wd);
        return NULL;
    }

    if (!XRenderQueryVersion(wd->display, &major_version, &minor_version)) {
        LitWhy("XRender extension not available on server");
        XCloseDisplay(wd->display);
        free(wd);
        return NULL;
    }

    vis = GetVisual(wd);
    /*
     * Get info about the default visual, check it's suitable and
     * extract the rgb shift masks.
     */
    xvi.visualid = XVisualIDFromVisual(vis);
    xvi_ret = XGetVisualInfo(wd->display, VisualIDMask, &xvi, &nitems_return);
    if (nitems_return != 1) {
        LitWhy("Couldn't get default visual's info");
        XCloseDisplay(wd->display);
        free(wd);
        return NULL;
    }
    wd->format = ImageByteOrder(wd->display) == LSBFirst ? &imgdataformat_X11BGRA32 : &imgdataformat_X11ARGB32;
    wd->maskfmt = XRenderFindStandardFormat(wd->display, PictStandardA8);
    if (xvi_ret->class == TrueColor && xvi_ret->depth == 24 && xvi_ret->bits_per_rgb == 8) {
        wd->winfmt = XRenderFindStandardFormat(wd->display, PictStandardRGB24);
    } else {
        LitWhy("Unsupported display type");
        XCloseDisplay(wd->display);
        free(wd);
        return NULL;
    }
    XFree(xvi_ret);

    wd->pixfmt = XRenderFindStandardFormat(wd->display, PictStandardARGB32);
    wd->black = new_sharedcolor(wd, "black", 0, 0, 0, 65535);
    wd->white = new_sharedcolor(wd, "white", 65535, 65535, 65535, 65535);
    wd->transparent = new_sharedcolor(wd, "transparent", 0, 0, 0, 0);
    wd->defaultfont = loadfont(wd, getdefaultfont());
    if (wd->defaultfont == NULL) {
        unlink_sharedcolor(wd, wd->white);
        unlink_sharedcolor(wd, wd->black);
        XCloseDisplay(wd->display);
        free(wd);
        LitWhy("Couldn't load default font");
        return NULL;
    }
    wd->xfont = XLoadQueryFont(wd->display, "fixed");
    XInternAtoms(wd->display, atom_names, NUMATOMS, False, wd->atoms);
    GRFX_LINK(wd, wdsplys);
    return wd;
}

/*
 * Convert a given font spec, which may or may not be in icon font spec format,
 * into fontconfig (used by Xft) style format.  The result is never null.
 * 
 * To avoid ambiguity, a spec can start with "fc:" to indicate it's in fontconfig
 * format; otherwise parsefont is called to decide the format.
 */
static char *convertspec(wdp wd, char *s)
{
    static char res[256];
    int flags, size;
    char *t, family[MAXFONTWORD];
    FcPattern *p;

    if (!strncmp(s, "fc:", 3))
        return s + 3;

    if (!parsefont(s, family, &flags, &size))
        return s;

    p = FcPatternCreate();

    /*
     * Check first for special "standard" family names.
     */
    if (!strcmp(family, "fixed")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon fixed");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"mono");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "mono")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon mono");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"mono");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "typewriter")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon typewriter");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"courier");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "sans")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon sans");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"helvetica");
        flags |= FONTFLAG_PROPORTIONAL;
    }
    else if (!strcmp(family, "serif")) {
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"Object Icon serif");
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)"times");
        flags |= FONTFLAG_PROPORTIONAL;
    }
    else
        FcPatternAddString(p, FC_FAMILY, (FcChar8 *)family);

    if (size > 0)
        FcPatternAddDouble(p, FC_SIZE, (double)size);
    else {
        /* Only use a default font size if explicitly set via OIFONTSIZE */
        int t = getdefaultfontsize(-1);
        if (t > 0)
            FcPatternAddDouble(p, FC_SIZE, (double)t);
    }
    if (flags & FONTFLAG_MEDIUM)
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_MEDIUM);
    else if ((flags & FONTFLAG_DEMI) && (flags & FONTFLAG_BOLD))
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_DEMIBOLD);
    else if (flags & FONTFLAG_BOLD)
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_BOLD);
    else if (flags & FONTFLAG_LIGHT)
        FcPatternAddInteger(p, FC_WEIGHT, FC_WEIGHT_LIGHT);

    if (flags & FONTFLAG_ITALIC)
        FcPatternAddInteger(p, FC_SLANT, FC_SLANT_ITALIC);
    else if (flags & FONTFLAG_OBLIQUE)
        FcPatternAddInteger(p, FC_SLANT, FC_SLANT_OBLIQUE);
    else if (flags & FONTFLAG_ROMAN)
        FcPatternAddInteger(p, FC_SLANT, FC_SLANT_ROMAN);

    if (flags & FONTFLAG_PROPORTIONAL)
        FcPatternAddInteger(p, FC_SPACING, FC_PROPORTIONAL);
    if (flags & FONTFLAG_MONO)
        FcPatternAddInteger(p, FC_SPACING, FC_MONO);

    t = (char *)FcNameUnparse(p);
    strncpy(res, t, sizeof(res) - 1);
    free(t);
    FcPatternDestroy(p);

    return res;
}

/*
 * load a font and return a font structure.
 */

static wfp loadfont(wdp wd, char *s)
{
    wfp rv;

    /*
     * Convert to a system font name (without the fc: or x11: prefix)
     */
    s = convertspec(wd, s);

    /*
     * see if the font is already loaded on this display
     */
    for(rv = wd->fonts; rv; rv = rv->next) {
        if (!strcmp(s, rv->name + 3))
            return rv;
    }

    /*
     * load a new font
     */
    rv = newfont(wd, s);
    if (rv == NULL)
        return NULL;

    /*
     * link the font into this display's fontlist
     */
    GRFX_LINK(rv, wd->fonts);
    return rv;
}

static wfp newfont(wdp wd, char *s)
{
    wfp rv;
    GRFX_ALLOC(rv, _wfont);
    rv->fsp = XftFontOpenName(wd->display, DefaultScreen(wd->display), s);
    if (rv->fsp == NULL){
        free(rv);
        return NULL;
    }

    MemProtect(rv->name = malloc(strlen(s) + 3 + 1));
    sprintf(rv->name, "fc:%s", s);
    {
        XGlyphInfo	extents; 
        /*
         * Xft seems to sometimes give too-small values in its font
         * ascent/descent fields; therefore calculate the GlyphInfo
         * for the first 256 chars and take the maximum ascent/descent
         * of the sample and the font's reported values.
         */
        XftTextExtents8 (wd->display,
                         rv->fsp,
                         (FcChar8 *)allchars,
                         256,
                         &extents);
        rv->ascent = Max(rv->fsp->ascent, extents.y);
        rv->descent = Max(rv->fsp->descent, extents.height - extents.y);
        rv->maxwidth = rv->fsp->max_advance_width;
    }
    rv->height = rv->ascent + rv->descent;
    return rv;
}

/*
 * allocate a context, cloning attributes from an existing context
 */
wcp clonecontext(wbp w)
{
    wcp wc, rv;
    wdp wd;

    wc = w->context;
    wd = w->context->display;

    GRFX_ALLOC(rv, _wcontext);
    rv->display = wd;
    rv->dx = wc->dx;
    rv->dy = wc->dy;
    rv->clipx = wc->clipx;
    rv->clipy = wc->clipy;
    rv->clipw = wc->clipw;
    rv->cliph = wc->cliph;
    rv->fg = link_sharedcolor(wc->fg);
    rv->bg = link_sharedcolor(wc->bg);
    if (wc->pattern)
        rv->pattern = link_sharedpicture(wc->pattern);
    rv->font = wc->font;
    rv->linestyle = wc->linestyle;
    rv->linewidth = wc->linewidth;
    rv->drawop = wc->drawop;
    GRFX_LINK(rv, wcntxts);
    return rv;
}

/*
 * free a window state
 */
void freewindow(wsp ws)
{
    ws->refcount--;
    if(ws->refcount == 0) {
        if (ws->win)
            close_screen_win(ws);

        if (ws->pxft) {
            XftDrawDestroy(ws->pxft);
            ws->pxft = NULL;
        }

        if (ws->pix) {
            XFreePixmap(ws->display->display, ws->pix);
            ws->pix = 0;
        }

        if (ws->ppic) {
            XRenderFreePicture(ws->display->display, ws->ppic);
            ws->ppic = 0;
        }

        if (ws->icondata) {
            free(ws->icondata);
            ws->icondata = 0;
        }

        if (ws->windowlabel) { 
           free(ws->windowlabel); 
           ws->windowlabel = 0;
        }

        GRFX_UNLINK(ws, wstates);
        free(ws);
    }
}

/*
 * free a window context
 */
void freecontext(wcp wc)
{
    wc->refcount--;
    if(wc->refcount == 0) {
        if (wc->fg)
            unlink_sharedcolor(wc->display, wc->fg);
        if (wc->bg)
            unlink_sharedcolor(wc->display, wc->bg);
        if (wc->pattern)
            unlink_sharedpicture(wc->display, wc->pattern);
        GRFX_UNLINK(wc, wcntxts);
        free(wc);
    }
}

int readimagefileimpl(char *filename, struct imgdata *imd) 
{
    return NoCvt;
}

int writeimagefileimpl(char *filename, struct imgdata *imd)
{
    return NoCvt;
}

int readimagedataimpl(dptr data, struct imgdata *imd)
{
    return NoCvt;
}

int settransientfor(wbp w, wbp other)
{
    wsp ws = w->window;
    if (ws->win)
        return Failed;
    if (other) {
        if (!other->window->win)
            return Failed;
        ws->transientfor = other->window->win;
    } else
        ws->transientfor = (Window) NULL;
    return Succeeded;
}

static void set_X11ARGB32(struct imgdata *imd, int x, int y, int r, int g, int b, int a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    *s++ = a / 256;
    *s++ = r / 256;
    *s++ = g / 256;
    *s++ = b / 256;
}
static void get_X11ARGB32(struct imgdata *imd, int x, int y, int *r, int *g, int *b, int *a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    *a = 257 * (*s++);
    *r = 257 * (*s++);
    *g = 257 * (*s++);
    *b = 257 * (*s++);
}

static void set_X11BGRA32(struct imgdata *imd, int x, int y, int r, int g, int b, int a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;

    b = (((unsigned)b) * a) / 65535;
    g = (((unsigned)g) * a) / 65535;
    r = (((unsigned)r) * a) / 65535;

    *s++ = b / 256;
    *s++ = g / 256;
    *s++ = r / 256;
    *s++ = a / 256;
}
static void get_X11BGRA32(struct imgdata *imd, int x, int y, int *r, int *g, int *b, int *a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    *b = 257 * (*s++);
    *g = 257 * (*s++);
    *r = 257 * (*s++);
    *a = 257 * (*s++);
    if (*a > 0) {
        *b = (((unsigned)*b) * 65535) / *a;
        *g = (((unsigned)*g) * 65535) / *a;
        *r = (((unsigned)*r) * 65535) / *a;
    }
}

static struct imgdataformat imgdataformat_X11ARGB32 =   {set_X11ARGB32,get_X11ARGB32,0,0,getlength_32,8,24,0,"X11ARGB32"};
static struct imgdataformat imgdataformat_X11BGRA32 =   {set_X11BGRA32,get_X11BGRA32,0,0,getlength_32,8,24,0,"X11BGRA32"};

struct imgdataformat *platform_parseimgdataformat(char *s)
{
    if (strcmp(s, imgdataformat_X11ARGB32.name) == 0)
        return &imgdataformat_X11ARGB32;
    if (strcmp(s, imgdataformat_X11BGRA32.name) == 0)
        return &imgdataformat_X11BGRA32;
    return 0;
}
