#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package util

import lang, posix, io

# This class is a convenient way of creating a sub-process in a
# program.  It sets up a socket connection between the parent and
# child processes to allow them to communicate in a bi-directional
# fashion.
#
class Process(HasTask, HasBgProc)
   private readable
      p,
      sock

   #
   # Called by the parent process to start the child
   #
   public start()
      local l
      /pid | runerr("start() called out of sequence", self)
      l := SocketStream.socketpair() | fail
      (l[1].dflag(DescOpt.CLOEXEC) &
       l[2].dflag(DescOpt.CLOEXEC) &
       pid := System.fork()) | {
          l[1].close()
          l[2].close()
          fail
       }
      if pid > 0 then {
         # Parent
         sock := l[2]
         l[1].close()
         return
      } else {
         # Child
         pid := task := &null
         sock := l[1]
         l[2].close()
         run()
         close_sock()
         exit(0)
      }
   end

   #
   # Send an object to the other process.
   # 
   public send(obj)
      local s
      # The message format is <len><nl><encoded-data>; knowing the
      # length in advance lets us potentially get all the encoded data
      # in one low-level socket read, which is much faster.
      s := encode(obj, 1)
      sock.write(*s) | fail
      return sock.writes(s)
   end

   #
   # Receive an object from the other process.
   #
   public receive()
      local s, n
      s := sock.read() | fail
      n := integer(s) | return error("Expected integer size, got: " || s)
      return decode(sock.reads(n))
   end

   #
   # Attempt to get an object from the socket, failing if one is not
   # ready immediately.
   #
   public attempt()
      return poll(0)
   end

   #
   # Poll the socket for some available data, waiting for {t}
   # milliseconds.  If data becomes available then return it, else
   # fail.
   #
   public poll(t)
      local r
      r := do_poll(Poll.IN, t) | fail
      if /r then
         return error("Timeout")
      if poll_in_test(r[1]) then
         return receive()
      return error("i/o error on reading from socket")
   end

   #
   # Do a {poll} on the socket.
   #
   protected do_poll(for, timeout)
      return choose_poll([sock, for], timeout)
   end

   #
   # Return the socket
   #
   public get_sock()
      return .\sock
   end

   private close_sock()
      sock.shutdown(Shut.RDWR)
      sock.close()
      sock := &null
   end

   #
   # Called by the parent.  The method waits for the child to terminate.  The
   # child process will no longer exist after this call, so it resets pid to
   # &null and closes the socket.
   #
   public join()
      do_wait() | fail
      close_sock()
      return
   end

   #
   # Called by the parent to kill the child.  Then the {join} method is invoked.
   #
   public stop()
      \pid | runerr("stop() called out of sequence", self)
      System.kill(pid, Signal.SIGTERM) | fail
      join() | fail
      return
   end

   #
   # Invoke the code of the process.
   #
   protected run()
      return p()
   end

   #
   # Set the procedure to run as the body of the process; alternatively
   # subclass and override the {run()} method.
   #
   public set_proc(p)
      self.p := p
      return self
   end

   public new(p)
      self.p := p
      return
   end
end

