package lang

import io, util, ipl.tables

#
# Convert the object to string, descending structures to the given depth.  See
# also {ObjectOutputStream}.
#
# @param o       The object to be converted.
# @param indent  Output newlines and indentation to show the object structure
# @param depth   The depth of recursion; default is all levels
#
procedure to_string(o, indent, depth)
   local sb
   sb := RamStream()
   ObjectOutputStream("indent=",indent, 
                      "depth=",depth).show(o, sb)
   return sb.done()
end

#
# Like {to_string}, but send the output direct to {FileStream.stdout}.  See
# also {ObjectOutputStream}.
#
# @param o       The object to be output.
# @param indent  Output newlines and indentation to show the object structure
# @param depth   The depth of recursion; default is all levels
#
procedure to_stdout(o, indent, depth)
   return ObjectOutputStream("indent=",indent, 
                             "depth=",depth).show(o, FileStream.stdout)
end

#
# Like {to_string}, but send the output direct to {FileStream.stderr}.  See
# also {ObjectOutputStream}.
#
# @param o       The object to be output.
# @param indent  Output newlines and indentation to show the object structure
# @param depth   The depth of recursion; default is all levels
#
procedure to_stderr(o, indent, depth)
   return ObjectOutputStream("indent=",indent, 
                             "depth=",depth).show(o, FileStream.stderr)
end

#
# This class can be used to output a human-readable image of an
# arbitrary icon object.
#
# @example
# @  oo := ObjectOutputStream("indent=3")
# @  oo.show(my_object, FileStream.stdout)
# @  oo.show(another_object, FileStream.stdout)
#
# Note that most of the public methods in this class are intended for
# use by other classes which implement custom output (by having an
# {object_output} method).  Only the setter and {show} methods should
# be used by a client.
#
# For simpler procedure interfaces to this class, see {to_string},
# {to_stdout} and {to_stderr}.
#
# @field indent=integer : see {set_indent}
# @field depth=integer : see {set_depth}
# @field ignore_object_output=flag : see {set_ignore_object_output}
# @field always_structure=flag : see {set_always_structure}
#
class ObjectOutputStream(Stream, SetFields)
   private readable
      depth,
      indent,
      level,
      ilevel
      
   private
      stuff,
      seen, 
      file,
      ignore_object_output_flag,
      always_structure_flag

   #
   # Reset everything and output a new object.
   #
   public show(o, file)
      /file := FileStream.stdout
      self.file := file
      file.can(Stream.WRITE) | runerr("ObjectOutputStream: stream not writable: ", file)
      self.seen := table()
      self.level := 0
      self.ilevel := 0
      if traverse(o) then {
         self.seen := &null
         return
      } else {
         self.seen := &null
         fail
      }
   end

   public out(s)
      stuff := 1
      return file.out(s)
   end

   public get_mode()
      return WRITE
   end

   public nl()
      if \stuff then {
         write() | fail
         writes(repl(" ", indent * ilevel)) | fail
         stuff := &null
      }
      return
   end

   public iplus()
      ilevel +:= 1
   end

   public iminus()
      ilevel -:= 1
   end

   public traverse(o)
      local ty, s, i, e, pairs, mp, sep, desc

      if s := \seen[o] then
         return writes("ref ", s)

      ty := type(o)
      level +:= 1
      if /depth | (level <= depth) then
         desc := 1

      case ty of {
         "record" : {
            s := ty || " " || Constructor.get_name(o) || "#" || serial(o)
            seen[o] := s
            if /desc then 
               writes(s) | fail
            else if simple{!o} then {
               writes(s, "(") | fail
               i := 1
               every s := Constructor.get_field_names(o) do {
                  if i > 1 then
                     writes(";") | fail
                  writes(s, "=") | fail
                  traverse(o[i]) | fail
                  i +:= 1
               }
               writes(")") | fail
            } else {
               nl() | fail
               writes(s, "(") | fail
               iplus()
               i := 1
               every s := Constructor.get_field_names(o) do {
                  nl() | fail
                  iplus()
                  writes(s, "=") | fail
                  traverse(o[i]) | fail
                  iminus()
                  i +:= 1
               }
               iminus()
               nl() | fail
               writes(")") | fail
            }
         }

         "object" : {
            s := type(o) || " " || Class.get_name(o) || "#" || serial(o)
            seen[o] := s
            if /desc then
               writes(s) | fail
            else if /ignore_object_output_flag & (mp := Class.getq(o, "object_output")) then
               mp(self) | fail
            else if simple{Class.getf(o, 1 to Class.get_n_instance_fields(o))} then {
               writes(s, "(") | fail
               every i := 1 to Class.get_n_instance_fields(o) do {
                  if i > 1 then
                     writes(";") | fail
                  writes(Class.get_field_name(o, i), "=") | fail
                  traverse(Class.getf(o, i)) | fail
                  i +:= 1
               }
               writes(")") | fail
            } else {
               nl() | fail
               writes(s, "(") | fail
               iplus()
               every i := 1 to Class.get_n_instance_fields(o) do {
                  nl() | fail
                  writes(Class.get_field_name(o, i), "=") | fail
                  iplus()
                  traverse(Class.getf(o, i)) | fail
                  iminus()
                  i +:= 1
               }
               iminus()
               nl() | fail
               writes(")") | fail
            }
         }

         "set" : {
            s := ty || "#" || serial(o)
            seen[o] := s
            if /desc then
               writes(s) | fail
            else if simple{!o} then {
               writes(s, "{") | fail
               every e := !sort(o) do {
                  if \sep then
                     writes(",") | fail
                  traverse(e) | fail
                  sep := 1
               }
               writes("}") | fail
            } else {
               nl() | fail
               writes(s, "{") | fail
               iplus()
               every e := !sort(o) do {
                  if \sep then
                     writes(",") | fail
                  nl() | fail
                  traverse(e) | fail
                  sep := 1
               }
               iminus()
               nl() | fail
               writes("}") | fail
            }
         }

         "list" : {
            s := ty || "#" || serial(o)
            seen[o] := s
            if /desc then
               writes(s) | fail
            else if simple{!o} then {
               writes(s, "[") | fail
               every e := !o do {
                  if \sep then
                     writes(",") | fail
                  traverse(e) | fail
                  sep := 1
               }
               writes("]") | fail
            } else {
               nl() | fail
               writes(s, "[") | fail
               iplus()
               every e := !o do {
                  if \sep then
                     writes(",") | fail
                  nl() | fail
                  traverse(e) | fail
                  sep := 1
               }
               iminus()
               nl() | fail
               writes("]")
            }
         }

         "table" : {
            s := ty || "#" || serial(o)
            seen[o] := s
            if /desc then
               writes(s) | fail
            else if simple{o[[]] | keyval(o)} then {
               writes(s) | fail
               if \o[[]] then {
                  writes(";def=") | fail
                  traverse(o[[]]) | fail
               }
               pairs := sort(o)
               writes("{") | fail
               every e := !pairs do {
                  if \sep then
                     writes(";") | fail
                  traverse(e[1]) | fail
                  writes("->") | fail
                  traverse(e[2]) | fail
                  sep := 1
               }
               writes("}") | fail
            } else {
               nl() | fail
               writes(s) | fail
               if \o[[]] then {
                  writes(";def=") | fail
                  iplus()
                  traverse(o[[]]) | fail
                  iminus()
               }
               pairs := sort(o)
               writes("{") | fail
               iplus()
               every e := !pairs do {
                  nl() | fail
                  traverse(e[1]) | fail
                  writes("->") | fail
                  iplus()
                  traverse(e[2]) | fail
                  iminus()
               }
               iminus()
               nl() | fail
               writes("}") | fail
            }
         }

         "methp" : {
            if /desc then 
               writes("methp()") | fail
            else if simple{Class.get_methp_object(o)} then {
               writes("methp(") | fail
               traverse(Class.get_methp_object(o)) | fail
               writes(",", image(Class.get_methp_proc(o)), ")") | fail
            } else {
               nl() | fail
               writes("methp(") | fail
               iplus()
               nl() | fail
               traverse(Class.get_methp_object(o)) | fail
               writes(",") | fail
               nl() | fail
               writes(image(Class.get_methp_proc(o))) | fail
               iminus()
               nl() | fail
               writes(")")
            }
         }

         "cast" : {
            if /desc then 
               writes("cast()") | fail
            else if simple{Class.get_cast_object(o)} then {
               writes("cast(") | fail
               traverse(Class.get_cast_object(o)) | fail
               writes(",", image(Class.get_cast_class(o)), ")") | fail
            } else {
               nl() | fail
               writes("cast(") | fail
               iplus()
               nl() | fail
               traverse(Class.get_cast_object(o)) | fail
               writes(",") | fail
               nl() | fail
               writes(image(Class.get_cast_class(o))) | fail
               iminus()
               nl() | fail
               writes(")")
            }
         }

         default : 
            writes(image(o)) | fail
      }

      level -:= 1
      return
   end
   
   public object_start(o)
      return writes(type(o), " ", Class.get_name(o), "#", serial(o), "(")
   end

   public object_end(o)
      return writes(")")
   end

   public object_string(o, s)
      object_start(o) | fail
      writes(s) | fail
      return object_end(o)
   end

   public object_selected(o, fields[])
      local s, sep
      if simple{Class.getf(o, !fields)} then {
         object_start(o) | fail
         every s := !fields do {
            if \sep then
               writes(";") | fail
            writes(s, "=") | fail
            traverse(Class.getf(o, s)) | fail
            sep := 1
         }
         object_end(o) | fail
      } else {
         nl() | fail
         object_start(o) | fail
         iplus()
         every s := !fields do {
            nl() | fail
            writes(s, "=") | fail
            iplus()
            traverse(Class.getf(o, s)) | fail
            iminus()
         }
         iminus()
         nl() | fail
         object_end(o) | fail
      }
      return
   end

   public simple(x)
      local e
      static s
      initial s := set("null", "string", "ucs", "cset", "integer", "class",
                       "real", "co-expression", "constructor", "procedure")
      if /indent | (level = \depth) then
         return
      if \always_structure_flag then
         fail
      while e := @x do
         member(seen, e) | member(s, type(e)) | fail
      return 
   end

   # When set to an integer, output is structured over many lines,
   # with the given value as an indent to show structure.  When null,
   # all output is on one line.
   #
   public set_indent(i)
      self.indent := i
   end

   # The maximum depth into which strucutures are recursed; if null
   # then no limit.
   #
   public set_depth(i)
      self.depth := i
   end

   # If set, then any custom {object_output} methods in objects are
   # ignored, and the default object output format is used instead.
   #
   public set_ignore_object_output(s)
      self.ignore_object_output_flag := check_flag(s)
   end

   # When indent is set (ie output is over many lines and indented to
   # show structure), certain objects will still be written on one
   # line if they just contain simple elements like integers and
   # strings.  This flag forces even these objects to be written over
   # many lines.
   #
   public set_always_structure(s)
      self.always_structure_flag := check_flag(s)
   end

   protected set_one(f)
      case f.attr of {
         "indent" : set_indent(f.int_val())
         "depth" : set_depth(f.int_val())
         "ignore_object_output" : set_ignore_object_output(f.flag_val())
         "always_structure" : set_always_structure(f.flag_val())
         default: fail
      }
      return
   end
end

#
# Clone the given object
#
procedure clone(o, seen)
   local e, ty, res, i, mp

   /seen := table()

   if res := \seen[o] then
      return res

   ty := type(o)

   case ty of {
      "object" : {
         if mp := Class.getq(o, "object_clone") then {
            res := mp(seen)
            seen[o] := res
         } else {
            #
            # Create an instance
            #
            res := Class.create_raw(classof(o))
            # The members of res may reference it...
            seen[o] := res
            every i := 1 to Class.get_n_instance_fields(res) do
               Class.get(res, i) := clone(Class.get(o, i), seen)
            Class.complete_raw(res)
         }
         return res
      }

      "record" : {
         res := classof(o)()
         seen[o] := res
         every i := 1 to *o do
            res[i] := clone(o[i], seen)
         return res
      }

      "set" : {
         res := set()
         seen[o] := res
         every insert(res, clone(!o, seen))
         return res
      }

      "list" : {
         res := []
         seen[o] := res
         every put(res, clone(!o, seen))
         return res
      }

      "table" : {
         res := table(clone(o[[]], seen))
         seen[o] := res
         every e := entries(o) do
            insert(res, clone(e[1], seen), clone(e[2], seen))
         return res
      }

      "cast" : {
         return cast(clone(Class.get_cast_object(o), seen),
                     Class.get_cast_class(o))
      }

      default : 
         return o
   }
end

#
# Return a hash code for this object.  For any two objects for which {equals} indicates
# equality, the returned hash code should be the same.
#
procedure hash(x, depth)
   local n, i, l, mp

   /depth := 2
   if depth = 0 then
      return 0
   
   case type(x) of {
      "object" : {
         if mp := Class.getq(x, "object_hash") then
            n := mp(depth)
         else {
            l := n := Class.get_n_instance_fields(x)
            if depth > 1 then {
               every i := hash(Class.get(x, 1 to l) \ 10, depth - 1) do
                  n := 37 * iand(n, 16rffffff)  + i
            }
         }
      }

      "record" | "list" : {
         n := *x
         if depth > 1 then {
            every i := hash(!x \ 10, depth - 1) do
               n := 37 * iand(n, 16rffffff)  + i
         }
      }

      "set" : {
         n := *x
         if depth > 1 then
            every n +:= hash(!x, depth - 1)
      }

      "table" : {
         n := *x
         if depth > 1 then {
            n +:= hash(x[[]], depth - 1)
            every n +:= hash(key(x), depth - 1)
         }
      }

      "cast" :
         n := hash(Class.get_cast_object(x), depth - 1) +
                   hash(Class.get_cast_class(x), depth - 1)

      "methp" :
         n := hash(Class.get_methp_object(x), depth - 1) +
                   hash(Class.get_methp_proc(x), depth - 1)

      default :
         n := Internal.hash(x)
   }
   return iand(n, 16r7fffffff)
end

#
# Compare this object with another by recursively comparing all
# members of the object.
#
procedure equals(x, y, seen)
   if x === y then
      return

   type(x) == type(y) | fail

   /seen := table()
   if member(\seen[x], y) | member(\seen[y], x) then
      return
   /seen[x] := set()
   insert(seen[x], y)
   if equals_impl(x, y, seen) then
      return
   delete(seen[x], y)
end

procedure equals_impl(x, y, seen)
   local i, mp
   case type(x) of {
      "object" : {
         if mp := Class.getq(x, "object_equals") then {
            # x has an object_equals method, so y must inherit the
            # same object_equals method as x.
            return (Proc.get_defining_class(mp) === Class.get_field_defining_class(y, "object_equals")) &
               mp(y, seen)
         }
         classof(x) === classof(y) | fail
         every i := 1 to Class.get_n_instance_fields(x) do 
            equals(Class.get(x, i), Class.get(y, i), seen) | fail
         return
      }

      "record" : {
         *x = *y | fail
         classof(x) === classof(y) | fail
         every i := 1 to *x do
            equals(x[i], y[i], seen) | fail
         return
      }

      "list" : {
         *x = *y | fail
         every i := 1 to *x do
            equals(x[i], y[i], seen) | fail
         return
      }

      "set" : {
         *x = *y | fail
         return hash_and_check(x, y, seen)
      }

      "table" : {
         *x = *y | fail
         equals(x[[]], y[[]], seen) | fail
         return hash_and_check(entrylist(x), entrylist(y), seen)
      }

      "methp": {
         Class.get_methp_proc(x) === Class.get_methp_proc(y) | fail
         equals(Class.get_methp_object(x),
                Class.get_methp_object(y), seen) | fail
         return
      }

      "cast": {
         Class.get_cast_class(x) === Class.get_cast_class(y) | fail
         equals(Class.get_cast_object(x),
                Class.get_cast_object(y), seen) | fail
         return
      }

      default : {
         # Since x ~=== y, we just fail for all other types.
         fail
      }
   }
end

#
# Check that all elements of s2 are in s1, by using a table indexed on
# hash-codes.
#
procedure hash_and_check(s1, s2, seen)
   local t, e, i
   t := table()
   every e := !s1 do {
      i := hash(e)
      (/t[i] := [e]) | put(t[i], e)
   }
   every e := !s2 do
      in_bucket(e, \t[hash(e)], seen) | fail
   return
end

#
# Search for element e in hash bucket l.  If found, the bucket element is
# removed, so that it is matched only once.
#
procedure in_bucket(e, l, seen)
   local i
   every i := 1 to *l do {
      if equals(e, l[i], seen) then {
         delete(l, i)
         return
      }
   }
end

#
# This class has some static methods that give access to some useful internal
# interpreter functions.
#
class Internal()
   #
   # This method gives access to the internal ordering method used by
   # the interpreter, for example in the builtin {sort} function.  The
   # two values are compared and either {-1}, {0}, or {+1} is returned
   # depending on whether {x} is less than, equal to, or greater than
   # {y}, respectively.
   #
   public static defer compare(x, y)

   #
   # This method gives access to the internal hash method used
   # by the interpreter, for example in implementing tables and sets.
   # It is distinct from the {lang.hash()} procedure.
   #
   public static defer hash(x)
end

class NoCopy()
   private final object_clone()
      return self
   end

   private final object_encode()
      &why := "Not encodable: " || image(self)
   end
end

