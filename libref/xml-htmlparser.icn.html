<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>htmlparser.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: htmlparser.icn 9179 2021-09-09 19:59:20Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package xml
<a name="10"/>
<a name="11"/>import io, lang, util, ipl.scan
<a name="12"/>
<a name="13"/>package class Tag()
<a name="14"/>   public const
<a name="15"/>      attributes
<a name="16"/>   private readable
<a name="17"/>      name,
<a name="18"/>      closed,
<a name="19"/>      empty
<a name="20"/>
<a name="21"/>   #
<a name="22"/>   # Set the name of the tag, which is converted to upper case.  Any
<a name="23"/>   # leading "/" should be omitted.
<a name="24"/>   #
<a name="25"/>   public set_name(s) 
<a name="26"/>      name := Text.upper(s)
<a name="27"/>      link
<a name="28"/>   end
<a name="29"/>
<a name="30"/>   #
<a name="31"/>   # Indicate that the tag is a closing tag, ie has a leading "/"
<a name="32"/>   #
<a name="33"/>   public set_closed()
<a name="34"/>      closed := &amp;yes
<a name="35"/>      link
<a name="36"/>   end
<a name="37"/>
<a name="38"/>   #
<a name="39"/>   # Indicate that the tag is an empty tag.
<a name="40"/>   #
<a name="41"/>   public set_empty()
<a name="42"/>      empty := &amp;yes
<a name="43"/>      link
<a name="44"/>   end
<a name="45"/>
<a name="46"/>   #
<a name="47"/>   # Set an attribute for this tag.
<a name="48"/>   #
<a name="49"/>   public set_attribute(key, value)
<a name="50"/>      insert(attributes, Text.upper(key), value)
<a name="51"/>      link
<a name="52"/>   end
<a name="53"/>
<a name="54"/>   public new()
<a name="55"/>      self.attributes := table()
<a name="56"/>      return
<a name="57"/>   end
<a name="58"/>end
<a name="59"/>
<a name="60"/>package record TagInfo(limit, autoclose)
<a name="61"/>
<a name="62"/>#
<a name="63"/># An HTML parser.
<a name="64"/>#
<a name="65"/>class HtmlParser()
<a name="66"/>   private 
<a name="67"/>      node_stack
<a name="68"/>
<a name="69"/>   private readable
<a name="70"/>      utf8_flag,
<a name="71"/>      debug_recovery_flag
<a name="72"/>
<a name="73"/>   public static const
<a name="74"/>      IDINTRO,
<a name="75"/>      IDCHARS,
<a name="76"/>      KEYINTRO,
<a name="77"/>      KEYCHARS,
<a name="78"/>      VALCHARS, 
<a name="79"/>      DELIM,
<a name="80"/>      SPACE,
<a name="81"/>      STANDALONE,
<a name="82"/>      ENTITIES,
<a name="83"/>      PUBID_CHAR,
<a name="84"/>      TAG_INFO
<a name="85"/>   
<a name="86"/>   private static init()
<a name="87"/>      local container
<a name="88"/>
<a name="89"/>      # See http://www.w3.org/TR/html-markup/terminology.html#space
<a name="90"/>      SPACE := ' \t\n\r\f'
<a name="91"/>      IDINTRO := 'A-Za-z'
<a name="92"/>      IDCHARS := 'A-Za-z0-9.\-'
<a name="93"/>      KEYINTRO := 'A-Za-z_'
<a name="94"/>      KEYCHARS := 'A-Za-z_0-9.\-'
<a name="95"/>      VALCHARS := ~' \t\n\r\f/&gt;'
<a name="96"/>      DELIM := '\"\''
<a name="97"/>      PUBID_CHAR := ' \n\rA-Za-z0-9\-\'()+,./:=?;!*#@$_%'
<a name="98"/>      STANDALONE := set("IMG", "BR", "HR", "META", "BASE", "INPUT", "AREA", 
<a name="99"/>                        "BASEFONT", "BGSOUND", "COL", "ISINDEX", "PARAM",
<a name="100"/>                        "LINK", "NEXTID", "SPACER", "WBR")
<a name="101"/>
<a name="102"/>      container := set("LI", "DD", "DT", "TD", "TR", "TH", "THEAD", "TBODY", "TFOOT", "TABLE",
<a name="103"/>                       "UL", "OL", "DL", "BUTTON", "CAPTION", "BLOCKQUOTE", "FIELDSET", "LEGEND",
<a name="104"/>                       "FORM", "BODY", "HTML")
<a name="105"/>
<a name="106"/>      TAG_INFO := table(TagInfo(container, set()),
<a name="107"/>                        "LI", TagInfo(set("UL", "OL"), set("LI")),
<a name="108"/>                        "P", TagInfo(container, set("P")),
<a name="109"/>                        "A", TagInfo(container, set("A")),
<a name="110"/>                        "DD", TagInfo(set("DL"), set("DD", "DT")),
<a name="111"/>                        "DT", TagInfo(set("DL"), set("DT", "DD")),
<a name="112"/>                        "TR", TagInfo(set("TABLE"), set("TR", "TD", "TH")),
<a name="113"/>                        "TD", TagInfo(set("TABLE"), set("TD", "TH")),
<a name="114"/>                        "TH", TagInfo(set("TABLE"), set("TD", "TH")),
<a name="115"/>                        "THEAD", TagInfo(set("TABLE"), set("THEAD", "TFOOT", "TBODY")),
<a name="116"/>                        "TBODY", TagInfo(set("TABLE"), set("THEAD", "TFOOT", "TBODY")),
<a name="117"/>                        "TFOOT", TagInfo(set("TABLE"), set("THEAD", "TFOOT", "TBODY")),
<a name="118"/>                        "COLGROUP", TagInfo(set("TABLE"), set("COLGROUP")),
<a name="119"/>                        "TABLE", TagInfo(set(), set()),
<a name="120"/>                        "UL", TagInfo(set(), set()),
<a name="121"/>                        "OL", TagInfo(set(), set()),
<a name="122"/>                        "DL", TagInfo(set(), set()),
<a name="123"/>                        "BUTTON", TagInfo(set(), set()),
<a name="124"/>                        "FORM", TagInfo(set(), set()),
<a name="125"/>                        "CAPTION", TagInfo(set(), set()),
<a name="126"/>                        "BLOCKQUOTE", TagInfo(set(), set()),
<a name="127"/>                        "FIELDSET", TagInfo(set(), set()),
<a name="128"/>                        "LEGEND", TagInfo(set(), set()),
<a name="129"/>                        "BODY", TagInfo(set(), set()),
<a name="130"/>                        "HTML", TagInfo(set(), set()),
<a name="131"/>                        "OPTGROUP", TagInfo(set("SELECT"), set()),
<a name="132"/>                        "OPTION", TagInfo(set("SELECT", "DATALIST"), set("OPTION")))
<a name="133"/>
<a name="134"/>      ENTITIES := table(,
<a name="135"/>                        "quot", 34, "amp", 38, "apos", 39, "lt", 60, "gt", 62, "OElig", 338,
<a name="136"/>                        "oelig", 339, "Scaron", 352, "scaron", 353, "Yuml", 376, "circ", 710,
<a name="137"/>                        "tilde", 732, "ensp", 8194, "emsp", 8195, "thinsp", 8201, "zwnj", 8204,
<a name="138"/>                        "zwj", 8205, "lrm", 8206, "rlm", 8207, "ndash", 8211, "mdash", 8212,
<a name="139"/>                        "lsquo", 8216, "rsquo", 8217, "sbquo", 8218, "ldquo", 8220, "rdquo", 8221,
<a name="140"/>                        "bdquo", 8222, "dagger", 8224, "Dagger", 8225, "permil", 8240, "lsaquo", 8249,
<a name="141"/>                        "rsaquo", 8250, "euro", 8364, "fnof", 402, "Alpha", 913, "Beta", 914,
<a name="142"/>                        "Gamma", 915, "Delta", 916, "Epsilon", 917, "Zeta", 918, "Eta", 919,
<a name="143"/>                        "Theta", 920, "Iota", 921, "Kappa", 922, "Lambda", 923, "Mu", 924,
<a name="144"/>                        "Nu", 925, "Xi", 926, "Omicron", 927, "Pi", 928, "Rho", 929,
<a name="145"/>                        "Sigma", 931, "Tau", 932, "Upsilon", 933, "Phi", 934, "Chi", 935,
<a name="146"/>                        "Psi", 936, "Omega", 937, "alpha", 945, "beta", 946, "gamma", 947,
<a name="147"/>                        "delta", 948, "epsilon", 949, "zeta", 950, "eta", 951, "theta", 952,
<a name="148"/>                        "iota", 953, "kappa", 954, "lambda", 955, "mu", 956, "nu", 957,
<a name="149"/>                        "xi", 958, "omicron", 959, "pi", 960, "rho", 961, "sigmaf", 962,
<a name="150"/>                        "sigma", 963, "tau", 964, "upsilon", 965, "phi", 966, "chi", 967,
<a name="151"/>                        "psi", 968, "omega", 969, "thetasym", 977, "upsih", 978, "piv", 982,
<a name="152"/>                        "bull", 8226, "hellip", 8230, "prime", 8242, "Prime", 8243, "oline", 8254,
<a name="153"/>                        "frasl", 8260, "weierp", 8472, "image", 8465, "real", 8476, "trade", 8482,
<a name="154"/>                        "alefsym", 8501, "larr", 8592, "uarr", 8593, "rarr", 8594, "darr", 8595,
<a name="155"/>                        "harr", 8596, "crarr", 8629, "lArr", 8656, "uArr", 8657, "rArr", 8658,
<a name="156"/>                        "dArr", 8659, "hArr", 8660, "forall", 8704, "part", 8706, "exist", 8707,
<a name="157"/>                        "empty", 8709, "nabla", 8711, "isin", 8712, "notin", 8713, "ni", 8715,
<a name="158"/>                        "prod", 8719, "sum", 8721, "minus", 8722, "lowast", 8727, "radic", 8730,
<a name="159"/>                        "prop", 8733, "infin", 8734, "ang", 8736, "and", 8743, "or", 8744,
<a name="160"/>                        "cap", 8745, "cup", 8746, "int", 8747, "there4", 8756, "sim", 8764,
<a name="161"/>                        "cong", 8773, "asymp", 8776, "ne", 8800, "equiv", 8801, "le", 8804,
<a name="162"/>                        "ge", 8805, "sub", 8834, "sup", 8835, "nsub", 8836, "sube", 8838,
<a name="163"/>                        "supe", 8839, "oplus", 8853, "otimes", 8855, "perp", 8869, "sdot", 8901,
<a name="164"/>                        "lceil", 8968, "rceil", 8969, "lfloor", 8970, "rfloor", 8971, "lang", 9001,
<a name="165"/>                        "rang", 9002, "loz", 9674, "spades", 9824, "clubs", 9827, "hearts", 9829,
<a name="166"/>                        "diams", 9830, "nbsp", 160, "iexcl", 161, "cent", 162, "pound", 163,
<a name="167"/>                        "curren", 164, "yen", 165, "brvbar", 166, "sect", 167, "uml", 168,
<a name="168"/>                        "copy", 169, "ordf", 170, "laquo", 171, "not", 172, "shy", 173,
<a name="169"/>                        "reg", 174, "macr", 175, "deg", 176, "plusmn", 177, "sup2", 178,
<a name="170"/>                        "sup3", 179, "acute", 180, "micro", 181, "para", 182, "middot", 183,
<a name="171"/>                        "cedil", 184, "sup1", 185, "ordm", 186, "raquo", 187, "frac14", 188,
<a name="172"/>                        "frac12", 189, "frac34", 190, "iquest", 191, "Agrave", 192, "Aacute", 193,
<a name="173"/>                        "Acirc", 194, "Atilde", 195, "Auml", 196, "Aring", 197, "AElig", 198,
<a name="174"/>                        "Ccedil", 199, "Egrave", 200, "Eacute", 201, "Ecirc", 202, "Euml", 203,
<a name="175"/>                        "Igrave", 204, "Iacute", 205, "Icirc", 206, "Iuml", 207, "ETH", 208,
<a name="176"/>                        "Ntilde", 209, "Ograve", 210, "Oacute", 211, "Ocirc", 212, "Otilde", 213,
<a name="177"/>                        "Ouml", 214, "times", 215, "Oslash", 216, "Ugrave", 217, "Uacute", 218,
<a name="178"/>                        "Ucirc", 219, "Uuml", 220, "Yacute", 221, "THORN", 222, "szlig", 223,
<a name="179"/>                        "agrave", 224, "aacute", 225, "acirc", 226, "atilde", 227, "auml", 228,
<a name="180"/>                        "aring", 229, "aelig", 230, "ccedil", 231, "egrave", 232, "eacute", 233,
<a name="181"/>                        "ecirc", 234, "euml", 235, "igrave", 236, "iacute", 237, "icirc", 238,
<a name="182"/>                        "iuml", 239, "eth", 240, "ntilde", 241, "ograve", 242, "oacute", 243,
<a name="183"/>                        "ocirc", 244, "otilde", 245, "ouml", 246, "divide", 247, "oslash", 248,
<a name="184"/>                        "ugrave", 249, "uacute", 250, "ucirc", 251, "uuml", 252, "yacute", 253,
<a name="185"/>                        "thorn", 254, "yuml", 255)
<a name="186"/>   end
<a name="187"/>
<a name="188"/>   public set_debug_recovery(s)
<a name="189"/>      self.debug_recovery_flag := need_flag(s)
<a name="190"/>      link
<a name="191"/>   end
<a name="192"/>
<a name="193"/>   #
<a name="194"/>   # Parse the string s returning an HtmlDocument object.
<a name="195"/>   #
<a name="196"/>   public parse(s)
<a name="197"/>      local i, node, doc
<a name="198"/>      s := need_text(s)
<a name="199"/>      doc := HtmlDocument()
<a name="200"/>
<a name="201"/>      utf8_flag := Yes{ type(s) == "ucs" }
<a name="202"/>      node_stack := []
<a name="203"/>
<a name="204"/>      s ? {
<a name="205"/>         repeat {
<a name="206"/>            move_to_node()
<a name="207"/>
<a name="208"/>            if pos(0) then {
<a name="209"/>               #
<a name="210"/>               # No opening node found, so put whole in html tags and retry
<a name="211"/>               #
<a name="212"/>               return parse("&lt;HTML&gt;" || s || "&lt;/HTML&gt;")
<a name="213"/>            }
<a name="214"/>
<a name="215"/>            i := &amp;pos
<a name="216"/>            # parse_node() must succeed since move_to_node() didn't
<a name="217"/>            # leave us at pos(0)
<a name="218"/>            node := parse_node() | syserr("parse_node() failed unexpectedly")
<a name="219"/>
<a name="220"/>            if is(node, DocType | Comment) then
<a name="221"/>               doc.add(node)
<a name="222"/>            else if is(node, Tag) then {
<a name="223"/>               if /node.closed &amp; (node.name == "HTML") then {
<a name="224"/>                  #
<a name="225"/>                  # Found the html start point, so parse and return that node.
<a name="226"/>                  #
<a name="227"/>                  doc.add(parse_element(node))
<a name="228"/>                  return doc
<a name="229"/>               } else {
<a name="230"/>                  #
<a name="231"/>                  # Bad structure, so put html tags around it and start again.
<a name="232"/>                  #
<a name="233"/>                  return parse(s[1:i] || "&lt;HTML&gt;" || s[i:0] || "&lt;/HTML&gt;")
<a name="234"/>               }
<a name="235"/>            }
<a name="236"/>         }
<a name="237"/>      }
<a name="238"/>   end
<a name="239"/>
<a name="240"/>   #
<a name="241"/>   # Parse the current input into an `Node`
<a name="242"/>   #
<a name="243"/>   private parse_node()
<a name="244"/>      return if ="&lt;!" then {
<a name="245"/>         if tab(caseless_match("doctype")) then
<a name="246"/>            parse_doctype()
<a name="247"/>         else
<a name="248"/>            parse_comment()
<a name="249"/>      } else
<a name="250"/>         parse_tag()
<a name="251"/>   end
<a name="252"/>
<a name="253"/>   #
<a name="254"/>   # Parse and return an Element, given the starting tag
<a name="255"/>   #
<a name="256"/>   private parse_element(start_tag)
<a name="257"/>      local res, i, node, s
<a name="258"/>
<a name="259"/>      res := HtmlElement()
<a name="260"/>
<a name="261"/>      res.name := start_tag.name
<a name="262"/>      res.attributes := start_tag.attributes
<a name="263"/>
<a name="264"/>      case string(start_tag.name) of {
<a name="265"/>         "PLAINTEXT":
<a name="266"/>            res.add("" ~== tab(0))
<a name="267"/>         "XMP" | "SCRIPT" | "STYLE": {
<a name="268"/>            if /start_tag.empty then
<a name="269"/>               res.add("" ~== move_past_end_tag(start_tag))
<a name="270"/>         }
<a name="271"/>         "TITLE" | "TEXTAREA": {
<a name="272"/>            if /start_tag.empty then
<a name="273"/>               res.add("" ~== do_remove_entities(move_past_end_tag(start_tag)))
<a name="274"/>         }
<a name="275"/>         default: {
<a name="276"/>            unless \start_tag.empty | is_standalone_tag(start_tag.name) then {
<a name="277"/>               push(node_stack, string(start_tag.name))
<a name="278"/>               repeat {
<a name="279"/>                  s := move_to_node()
<a name="280"/>                  res.add("" ~== do_remove_entities(s))
<a name="281"/>                  if pos(0) then
<a name="282"/>                     break
<a name="283"/>
<a name="284"/>                  i := &amp;pos
<a name="285"/>                  # parse_node() must succeed since move_to_node() didn't
<a name="286"/>                  # leave us at pos(0)
<a name="287"/>                  node := parse_node(res) | syserr("parse_node() failed unexpectedly")
<a name="288"/>
<a name="289"/>                  if is(node, Tag) then {
<a name="290"/>                     if /node.closed then {
<a name="291"/>                        if should_close_tag(node) then {
<a name="292"/>                           if \debug_recovery_flag then
<a name="293"/>                              write("Closing on out of sync opening tag ", node.name, " at ", to_string(node_stack), " pos=", i)
<a name="294"/>                           &amp;pos := i
<a name="295"/>                           break
<a name="296"/>                        }
<a name="297"/>                        res.add(parse_element(node))
<a name="298"/>                     } else {
<a name="299"/>                        if node.name == start_tag.name then
<a name="300"/>                           break
<a name="301"/>                        if find_open_tag(node) then {
<a name="302"/>                           if \debug_recovery_flag then
<a name="303"/>                              write("Closing on out of sync closing tag ", node.name, " at ", to_string(node_stack), " pos=", i)
<a name="304"/>                           &amp;pos := i
<a name="305"/>                           break
<a name="306"/>                        }
<a name="307"/>                     }
<a name="308"/>                  } else {
<a name="309"/>                     #
<a name="310"/>                     # It's either a comment, or something else; just add it to the list of children
<a name="311"/>                     #
<a name="312"/>                     res.add(node)
<a name="313"/>                  }            
<a name="314"/>               }
<a name="315"/>               get(node_stack)
<a name="316"/>            }
<a name="317"/>         }
<a name="318"/>      }
<a name="319"/>      return res
<a name="320"/>   end
<a name="321"/>
<a name="322"/>   #
<a name="323"/>   # Succeed if and only if the tag implicitly closes when the other (opening)
<a name="324"/>   # tag is encountered at the same level.
<a name="325"/>   #
<a name="326"/>   private should_close_tag(other)
<a name="327"/>      local n, ti
<a name="328"/>      ti := TAG_INFO[string(other.name)]
<a name="329"/>      if *ti.autoclose = 0 then
<a name="330"/>         fail
<a name="331"/>      every n := !node_stack do {
<a name="332"/>         if member(ti.autoclose, n) then
<a name="333"/>            return
<a name="334"/>         if member(ti.limit, n) then
<a name="335"/>            fail
<a name="336"/>      }
<a name="337"/>   end
<a name="338"/>
<a name="339"/>   #
<a name="340"/>   # Succeed if and only if the given (closing) tag has a matching
<a name="341"/>   # open tag in the node stack.
<a name="342"/>   #
<a name="343"/>   private find_open_tag(other)
<a name="344"/>      local n, ti, on
<a name="345"/>      ti := TAG_INFO[on := string(other.name)]
<a name="346"/>      every n := !node_stack do {
<a name="347"/>         if n == on then
<a name="348"/>            return
<a name="349"/>         if member(ti.limit, n) then
<a name="350"/>            fail
<a name="351"/>      }
<a name="352"/>   end
<a name="353"/>
<a name="354"/>   #
<a name="355"/>   # DOCTYPE
<a name="356"/>   #
<a name="357"/>   # Assume "&lt;!DOCTYPE" already matched.
<a name="358"/>   #
<a name="359"/>   private parse_doctype()
<a name="360"/>      local res
<a name="361"/>
<a name="362"/>      res := DocType()
<a name="363"/>
<a name="364"/>      tab(upto(IDINTRO))
<a name="365"/>      res.name := tab(many(IDCHARS))
<a name="366"/>
<a name="367"/>      tab(many(SPACE))
<a name="368"/>      if ="SYSTEM" then {
<a name="369"/>         res.external_id := ExternalID()
<a name="370"/>         tab(many(SPACE))
<a name="371"/>         res.external_id.system_id := parse_system_literal()
<a name="372"/>      } else if ="PUBLIC" then {
<a name="373"/>         res.external_id := ExternalID()
<a name="374"/>         tab(many(SPACE))
<a name="375"/>         res.external_id.public_id := parse_pubid_literal()
<a name="376"/>         tab(many(SPACE))
<a name="377"/>         res.external_id.system_id := parse_system_literal()
<a name="378"/>      }
<a name="379"/>      tab(upto('&gt;')) | fail
<a name="380"/>      move(1)
<a name="381"/>      return res
<a name="382"/>   end
<a name="383"/>
<a name="384"/>   private parse_system_literal()
<a name="385"/>      local c, res
<a name="386"/>      c := tab(any('\'\"')) | fail
<a name="387"/>      res := tab(upto(c)) | fail
<a name="388"/>      move(1)
<a name="389"/>      return res
<a name="390"/>   end
<a name="391"/>
<a name="392"/>   private parse_pubid_literal()
<a name="393"/>      local c, res, t
<a name="394"/>      if any('\'') then
<a name="395"/>         t := PUBID_CHAR -- '\''
<a name="396"/>      else if any('\"') then
<a name="397"/>         t := PUBID_CHAR
<a name="398"/>      else
<a name="399"/>         fail
<a name="400"/>      c := move(1)
<a name="401"/>      res := tab(many0(t))  # many0() so that res may be an empty string
<a name="402"/>      =c | fail
<a name="403"/>      return res
<a name="404"/>   end
<a name="405"/>
<a name="406"/>   #
<a name="407"/>   # http://dev.w3.org/html5/markup/syntax.html#comments
<a name="408"/>   #
<a name="409"/>   # Assume "&lt;!" already matched.
<a name="410"/>   #
<a name="411"/>   private parse_comment()
<a name="412"/>      local res
<a name="413"/>      res := Comment()
<a name="414"/>      if =("&gt;" | "-&gt;" | "--&gt;" | "---&gt;") then
<a name="415"/>         res.comment := move(0)  # Empty string, same type as &amp;subject
<a name="416"/>      else {
<a name="417"/>         ="--"
<a name="418"/>         res.comment := tab(find("--&gt;") | 0)
<a name="419"/>         move(3)
<a name="420"/>      }
<a name="421"/>      return res
<a name="422"/>   end
<a name="423"/>
<a name="424"/>   #
<a name="425"/>   # Normal tag
<a name="426"/>   #
<a name="427"/>   private parse_tag()
<a name="428"/>      local res, key, c, s, value
<a name="429"/>
<a name="430"/>      res := Tag()
<a name="431"/>      ="&lt;" | fail
<a name="432"/>      if ="/" then {
<a name="433"/>         res.set_closed()
<a name="434"/>         s := (any(IDINTRO) &amp; tab(many(IDCHARS))) | fail
<a name="435"/>         res.set_name(s)
<a name="436"/>         tab(many(SPACE))
<a name="437"/>         ="&gt;" | fail
<a name="438"/>      } else {
<a name="439"/>         s := (any(IDINTRO) &amp; tab(many(IDCHARS))) | fail
<a name="440"/>         res.set_name(s)
<a name="441"/>         repeat {
<a name="442"/>            tab(upto(KEYINTRO ++ '/&gt;')) | fail
<a name="443"/>            if ="&gt;" then
<a name="444"/>               break
<a name="445"/>            if ="/" then {
<a name="446"/>               if ="&gt;" then {
<a name="447"/>                  res.set_empty()
<a name="448"/>                  break
<a name="449"/>               }
<a name="450"/>               # Just discard this / and continue.
<a name="451"/>               next
<a name="452"/>            }
<a name="453"/>            # Should now be at a KEYINTRO, which is a subset of KEYCHARS
<a name="454"/>            key := tab(many(KEYCHARS))
<a name="455"/>            tab(many(SPACE))
<a name="456"/>            if ="=" then {
<a name="457"/>               tab(many(SPACE))
<a name="458"/>               if c := tab(any(DELIM)) then {
<a name="459"/>                  s := tab(upto(c) | 0)
<a name="460"/>                  move(1)
<a name="461"/>               } else
<a name="462"/>                  s := tab(many(VALCHARS)) | next
<a name="463"/>               value := do_remove_entities(s)
<a name="464"/>            } else
<a name="465"/>               # See http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.3.4.2
<a name="466"/>               value := Text.lower(key)
<a name="467"/>
<a name="468"/>            res.set_attribute(key, value)
<a name="469"/>         }
<a name="470"/>      }
<a name="471"/>      return res
<a name="472"/>   end
<a name="473"/>
<a name="474"/>   # Move past the next end tag to match the given start tag,
<a name="475"/>   # regardless of intervening content
<a name="476"/>   #
<a name="477"/>   private move_past_end_tag(start_tag)
<a name="478"/>      local s, i, t
<a name="479"/>      s := ""
<a name="480"/>      repeat {
<a name="481"/>         s ||:= string(tab(upto('&lt;') | 0))
<a name="482"/>         if pos(0) then
<a name="483"/>            break
<a name="484"/>         i := &amp;pos
<a name="485"/>         if t := parse_tag() &amp; \t.closed &amp; start_tag.name == t.name then
<a name="486"/>            break
<a name="487"/>         &amp;pos := i
<a name="488"/>         s ||:= string(move(1))
<a name="489"/>      }
<a name="490"/>      return if \utf8_flag then ucs(s) else s
<a name="491"/>   end
<a name="492"/>
<a name="493"/>   #
<a name="494"/>   # Move to the next node (tag, comment, doctype), or end of file.
<a name="495"/>   #
<a name="496"/>   private move_to_node()
<a name="497"/>      local s, i
<a name="498"/>      s := ""
<a name="499"/>      repeat {
<a name="500"/>         s ||:= string(tab(upto('&lt;') | 0))
<a name="501"/>         if pos(0) then
<a name="502"/>            break
<a name="503"/>         i := &amp;pos
<a name="504"/>         if parse_node() then {
<a name="505"/>            #
<a name="506"/>            # Found a valid node, so tab back and break
<a name="507"/>            #
<a name="508"/>            &amp;pos := i
<a name="509"/>            break
<a name="510"/>         }
<a name="511"/>         #
<a name="512"/>         # Not a valid node, so tab back and continue
<a name="513"/>         #
<a name="514"/>         &amp;pos := i
<a name="515"/>         s ||:= string(move(1))
<a name="516"/>      }
<a name="517"/>      return if \utf8_flag then ucs(s) else s
<a name="518"/>   end
<a name="519"/>
<a name="520"/>   #
<a name="521"/>   # Match an entity character, eg "&amp;#xff;", returning the matched character value.
<a name="522"/>   #
<a name="523"/>   private match_entity()
<a name="524"/>      local i
<a name="525"/>      if ="&amp;" &amp;
<a name="526"/>         (i := if ="#" then {
<a name="527"/>                 if ="x" then
<a name="528"/>                     Format.string_to_int(tab(many('0-9a-fA-F')))
<a name="529"/>                 else
<a name="530"/>                     integer(tab(many(&amp;digits)))
<a name="531"/>              } else
<a name="532"/>                  member(ENTITIES, string(tab(many(&amp;letters))))) &amp;
<a name="533"/>         =";"
<a name="534"/>      then
<a name="535"/>         return if \utf8_flag then
<a name="536"/>                   Text.utf8_seq(i | 63)
<a name="537"/>                else
<a name="538"/>                   char(i | 63)
<a name="539"/>   end
<a name="540"/>
<a name="541"/>   #
<a name="542"/>   # Remove the entity characters from a string.
<a name="543"/>   #
<a name="544"/>   private do_remove_entities(s)
<a name="545"/>      local res
<a name="546"/>      res := ""
<a name="547"/>      s ? {
<a name="548"/>         while res ||:= string(tab(upto('&amp;'))) do res ||:= (match_entity() | string(move(1)))
<a name="549"/>         return res || tab(0)
<a name="550"/>      }
<a name="551"/>   end
<a name="552"/>
<a name="553"/>   #
<a name="554"/>   # Remove the entity characters from a string.
<a name="555"/>   #
<a name="556"/>   public static remove_entities(s)
<a name="557"/>      local p
<a name="558"/>      p := HtmlParser()
<a name="559"/>      p.utf8_flag := Yes{ type(s) == "ucs" }
<a name="560"/>      return p.do_remove_entities(s)
<a name="561"/>   end
<a name="562"/>
<a name="563"/>   #
<a name="564"/>   # Succeed if and only if the tag name is a standalone tag, ie it has no
<a name="565"/>   # matching closing tag.
<a name="566"/>   #
<a name="567"/>   public static is_standalone_tag(name)
<a name="568"/>      succeed member(STANDALONE, string(name))
<a name="569"/>   end
<a name="570"/>end
</pre></body></html>
