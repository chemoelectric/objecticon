<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>dispatcher.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: dispatcher.icn 8602 2020-10-20 20:00:25Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package gui
<a name="10"/>
<a name="11"/>import graphics, io, ipl.pdco
<a name="12"/>
<a name="13"/>#
<a name="14"/># Helper class to wrap an X11 display connection file descriptor.
<a name="15"/>#
<a name="16"/>package class EventStream(DescStream)
<a name="17"/>   public new(fd)
<a name="18"/>      setup(fd, 0)
<a name="19"/>      return
<a name="20"/>   end
<a name="21"/>end
<a name="22"/>
<a name="23"/>#
<a name="24"/>#
<a name="25"/># This class handles Icon events, dispatching them to
<a name="26"/># the appropriate dialog.  It also controls any active Tasks,
<a name="27"/># activating them between events as and when appropriate.
<a name="28"/>#
<a name="29"/>final abstract class Dispatcher()
<a name="30"/>   public static const 
<a name="31"/>      dialogs,
<a name="32"/>      scheduler
<a name="33"/>
<a name="34"/>   private static
<a name="35"/>      poll_list,
<a name="36"/>      poll_task
<a name="37"/>
<a name="38"/>   private static const
<a name="39"/>      BLOCKED_ALLOW,
<a name="40"/>      BLOCKED_QUIET,
<a name="41"/>      REPEATING
<a name="42"/>
<a name="43"/>   private static init()
<a name="44"/>      BLOCKED_ALLOW := Selection.EVENTS ++ set(Window.INVOKE_LATER, Window.FOCUS_IN, Window.FOCUS_OUT,
<a name="45"/>                                               Window.RESIZE, Window.STATE, Window.MOVE)
<a name="46"/>      BLOCKED_QUIET := set(Mouse.RELEASE, Mouse.MOVEMENT) ++ Mouse.CROSSING
<a name="47"/>      REPEATING := Mouse.DRAG_OR_MOVEMENT ++ set(Window.RESIZE, Window.STATE, Window.MOVE)
<a name="48"/>      dialogs := set()
<a name="49"/>      scheduler := Scheduler(Gui.IDLE_SLEEP)
<a name="50"/>      poll_task := new_task{ poller() }
<a name="51"/>      poll_list := []
<a name="52"/>   end
<a name="53"/>   
<a name="54"/>   private static poller()
<a name="55"/>      repeat
<a name="56"/>         poll_task.poll(poll_list)
<a name="57"/>   end
<a name="58"/>
<a name="59"/>   private static setup_poll_task()
<a name="60"/>      if (*poll_list = 0) | (scheduler.poll_timeout = 0) then
<a name="61"/>         poll_task.stop()
<a name="62"/>      else
<a name="63"/>         poll_task.start().notify()
<a name="64"/>   end
<a name="65"/>
<a name="66"/>   private static setup_poll_list()
<a name="67"/>      local fd
<a name="68"/>      poll_list := ipl.pdco.List{ (fd := Unique{ (!dialogs).cbwin.get_fd() },
<a name="69"/>                                   EventStream(fd) | Poll.IN) }
<a name="70"/>      setup_poll_task()
<a name="71"/>   end
<a name="72"/>
<a name="73"/>   #
<a name="74"/>   # Indicate whether the `Dispatcher`'s `Scheduler` should use a poll
<a name="75"/>   # timeout or not. `fl` is a flag value, with `&amp;yes` indicating a
<a name="76"/>   # timeout should be used (the default initial setting).  If a poll
<a name="77"/>   # timeout is not used, then `work()` will never sleep.
<a name="78"/>   #
<a name="79"/>   public static use_poll_timeout(fl)
<a name="80"/>      scheduler.set_poll_timeout(if /fl then 0 else Gui.IDLE_SLEEP)
<a name="81"/>      setup_poll_task()
<a name="82"/>      link
<a name="83"/>   end
<a name="84"/>
<a name="85"/>   #
<a name="86"/>   # Add a dialog
<a name="87"/>   #
<a name="88"/>   public static add_dialog(d)
<a name="89"/>      insert(dialogs, d)
<a name="90"/>      setup_poll_list()
<a name="91"/>      link
<a name="92"/>   end
<a name="93"/>
<a name="94"/>   #
<a name="95"/>   # Delete a dialog
<a name="96"/>   #
<a name="97"/>   public static remove_dialog(d)
<a name="98"/>      delete(dialogs, d)
<a name="99"/>      setup_poll_list()
<a name="100"/>      link
<a name="101"/>   end
<a name="102"/>
<a name="103"/>   #
<a name="104"/>   # Try to do some work, succeeding if something was done, failing if it wasn't.
<a name="105"/>   #
<a name="106"/>   public static work()
<a name="107"/>      return do_event() | do_validate() | do_scheduler()
<a name="108"/>   end
<a name="109"/>
<a name="110"/>   #
<a name="111"/>   # Loop until dialog r is closed processing events and `Task`s.  If r
<a name="112"/>   # is omitted, then loop until there are no open dialogs.
<a name="113"/>   #
<a name="114"/>   public static message_loop(r)
<a name="115"/>      if /r then {
<a name="116"/>         while *dialogs &gt; 0 do
<a name="117"/>            work_or_sleep()
<a name="118"/>      } else {
<a name="119"/>         while \r.win do
<a name="120"/>            work_or_sleep()
<a name="121"/>      }
<a name="122"/>      link
<a name="123"/>   end
<a name="124"/>
<a name="125"/>   #
<a name="126"/>   # This is similar to the normal `message_loop` method, but instead
<a name="127"/>   # of returning only when there are no dialogs open, this method
<a name="128"/>   # will also return when it first finds it has no work to do,
<a name="129"/>   # allowing the caller to undertake some activity before calling it
<a name="130"/>   # again.  When using this method, it is best to configure the
<a name="131"/>   # `Dispatcher`'s scheduler so that it does not sleep in poll, (with
<a name="132"/>   # `use_poll_timeout`(&amp;no)).  This prevents `work` from ever
<a name="133"/>   # sleeping.
<a name="134"/>   #
<a name="135"/>   public static service(r)
<a name="136"/>      if /r then {
<a name="137"/>         while *dialogs &gt; 0 &amp;
<a name="138"/>            work()
<a name="139"/>      } else {
<a name="140"/>         while \r.win &amp;
<a name="141"/>            work()
<a name="142"/>      }
<a name="143"/>      link
<a name="144"/>   end
<a name="145"/>
<a name="146"/>   #
<a name="147"/>   # A further variant of the message loop which never returns.  Even
<a name="148"/>   # when there are no dialogs open, `Task`s continue to be activated.
<a name="149"/>   #
<a name="150"/>   public static message_loop_forever()
<a name="151"/>      repeat
<a name="152"/>         work_or_sleep()
<a name="153"/>   end
<a name="154"/>
<a name="155"/>   #
<a name="156"/>   # Convenient method to call work(), and if no work is done, to
<a name="157"/>   # sleep for the idle period, possibly adjusted downwards to account
<a name="158"/>   # for any sleeping or polling `Task`s.
<a name="159"/>   #
<a name="160"/>   public static work_or_sleep()
<a name="161"/>      work() | delay(scheduler.calc_sleep(Gui.IDLE_SLEEP))
<a name="162"/>      link
<a name="163"/>   end
<a name="164"/>
<a name="165"/>   public static do_event()
<a name="166"/>      local d, bag, e, v
<a name="167"/>      every d := !dialogs do {
<a name="168"/>         if e := d.win.peek() then {
<a name="169"/>            /bag := []
<a name="170"/>            if /d.is_blocked_flag then
<a name="171"/>               put(bag, d)
<a name="172"/>            else {
<a name="173"/>               # Consume all blocked events, or until a BLOCKED_ALLOW
<a name="174"/>               # event is encountered.
<a name="175"/>               repeat {
<a name="176"/>                  if member(BLOCKED_ALLOW, e) then {
<a name="177"/>                     put(bag, d)
<a name="178"/>                     break
<a name="179"/>                  }
<a name="180"/>                  # Discard and maybe beep in the window.
<a name="181"/>                  member(BLOCKED_QUIET, e) | d.win.alert()
<a name="182"/>                  d.win.event()
<a name="183"/>                  e := d.win.peek() | break
<a name="184"/>               }
<a name="185"/>            }
<a name="186"/>         }
<a name="187"/>      }
<a name="188"/>      if d := ?\bag then {
<a name="189"/>         v := d.win.event()
<a name="190"/>         # Discard unwanted repeating events.
<a name="191"/>         if member(REPEATING, v[1]) then {
<a name="192"/>            while d.win.peek() === v[1] do
<a name="193"/>               v := d.win.event()
<a name="194"/>         }
<a name="195"/>         d.process_event(v)
<a name="196"/>         return
<a name="197"/>      }
<a name="198"/>   end
<a name="199"/>
<a name="200"/>   public static do_validate()
<a name="201"/>      local d, bag
<a name="202"/>      every d := !dialogs do {
<a name="203"/>         if d.needs_validate() then {
<a name="204"/>            /bag := []
<a name="205"/>            put(bag, d)
<a name="206"/>         }
<a name="207"/>      }
<a name="208"/>      if d := ?\bag then {
<a name="209"/>         d.validate()
<a name="210"/>         return
<a name="211"/>      }
<a name="212"/>   end
<a name="213"/>
<a name="214"/>   public static do_scheduler()
<a name="215"/>      return scheduler.work()
<a name="216"/>   end
<a name="217"/>
<a name="218"/>   #
<a name="219"/>   # Return a list of unblocked dialogs.
<a name="220"/>   #
<a name="221"/>   public static list_unblocked()
<a name="222"/>      local d, res
<a name="223"/>
<a name="224"/>      res := []
<a name="225"/>      every d := !dialogs do
<a name="226"/>         if /d.is_blocked_flag then
<a name="227"/>            put(res, d)
<a name="228"/>
<a name="229"/>      return res
<a name="230"/>   end
<a name="231"/>
<a name="232"/>   #
<a name="233"/>   # Generate any (unblocked) dialogs which are instances of
<a name="234"/>   # the given class.  If the parameter is omitted, all unblocked
<a name="235"/>   # dialogs are generated.
<a name="236"/>   #
<a name="237"/>   public static find_dialog(cl)
<a name="238"/>      local d
<a name="239"/>      every d := !dialogs do {
<a name="240"/>         if /d.is_blocked_flag &amp; 
<a name="241"/>            (/cl | is(d, cl)) then
<a name="242"/>             suspend d
<a name="243"/>      }
<a name="244"/>   end
<a name="245"/>
<a name="246"/>   #
<a name="247"/>   # Helpful method to create a new `Task` using the `Dispatcher`'s
<a name="248"/>   # `Scheduler`.
<a name="249"/>   #
<a name="250"/>   public static new_task(e, v)
<a name="251"/>      return Task(scheduler, e, v)
<a name="252"/>   end
<a name="253"/>
<a name="254"/>   #
<a name="255"/>   # Return the `Scheduler`'s current task (if any).
<a name="256"/>   #
<a name="257"/>   public static get_curr_task()
<a name="258"/>      return \scheduler.curr_task
<a name="259"/>   end
<a name="260"/>end
</pre></body></html>
