package cairo

import lang, graphics, util, io, ipl.pdco

abstract class PathElement() end

class MoveTo(PathElement)
   public const x, y

   public new(x, y)
      self.x := real(x) | runerr(102, x)
      self.y := real(y) | runerr(102, y)
      return
   end
end

class LineTo(PathElement)
   public const x, y

   public new(x, y)
      self.x := real(x) | runerr(102, x)
      self.y := real(y) | runerr(102, y)
      return
   end
end

class CurveTo(PathElement)
   public const x1, y1, x2, y2, x3, y3

   public new(x1, y1, x2, y2, x3, y3)
      self.x1 := real(x1) | runerr(102, x1)
      self.y1 := real(y1) | runerr(102, y1)
      self.x2 := real(x2) | runerr(102, x2)
      self.y2 := real(y2) | runerr(102, y2)
      self.x3 := real(x3) | runerr(102, x3)
      self.y3 := real(y3) | runerr(102, y3)
      return
   end
end

class ClosePath(PathElement) end

class Matrix()
   public const xx, yx, xy, yy, x0, y0
   public static const I

   private static init()
      I := Matrix(1.0, 0.0, 0.0, 1.0, 0.0, 0.0)
   end

   public static from_translation(tx, ty)
      return Matrix(1.0, 0.0, 0.0, 1.0, tx, ty)
   end

   public static from_rotation(r)
      local c, s
      c := Math.cos(r)
      s := Math.sin(r)
      return Matrix(c, s, -s, c)
   end

   public static from_scale(sx, sy)
      return Matrix(sx, 0.0, 0.0, sy, 0.0, 0.0)
   end

   public multiply_point(x, y)
      return [xx * x + xy * y + x0, yx * x + yy * y + y0]
   end

   public rotate(r)
      return multiply(from_rotation(r), self)
   end

   public translate(tx, ty)  
      return multiply(from_translation(tx, ty), self)
   end

   public scale(sx, sy)
      return multiply(from_scale(sx, sy), self)
   end

   # Return a * b
   public static multiply(a, b)
      return Matrix(a.xx * b.xx + a.yx * b.xy,
                    a.xx * b.yx + a.yx * b.yy,
                    a.xy * b.xx + a.yy * b.xy,
                    a.xy * b.yx + a.yy * b.yy,
                    a.x0 * b.xx + a.y0 * b.xy + b.x0,
                    a.x0 * b.yx + a.y0 * b.yy + b.y0)
   end

   public new(xx, yx, xy, yy, x0, y0)
      /x0 := 0.0
      /y0 := 0.0
      self.xx := real(xx) | runerr(102, xx)
      self.yx := real(yx) | runerr(102, yx)
      self.xy := real(xy) | runerr(102, xy)
      self.yy := real(yy) | runerr(102, yy)
      self.x0 := real(x0) | runerr(102, x0)
      self.y0 := real(y0) | runerr(102, y0)
      return
   end
end

abstract class Pattern(NoCopy)
   protected ptr

   private static init()
      Class.load_library(\Context.LOADED)
   end

   public identity_matrix()
      return set_matrix(Matrix.I)
   end

   private native set_matrix_impl(xx, yx, xy, yy, x0, y0)
   public set_matrix(m)
      return set_matrix_impl(m.xx, m.yx, m.xy, m.yy, m.x0, m.y0)
   end

   private native get_matrix_impl()
   public get_matrix()
      return Matrix!get_matrix_impl()
   end

   public native set_extend(v)
   public native get_extend()

   public native close()

   public static to_pattern(v)
      local t
      return if is(v, Surface) then
         SurfacePattern(v)
      else if is(v, Window) then
         use {
            t := WindowSurface(v),
            SurfacePattern(t)
         }
      else if is(v, Pixels) then
         use {
            t := v.convert(ImageSurface.FORMAT),
            use {
               t := ImageSurface(t),
               SurfacePattern(t)
            }
         }
      else
         use {
            t := Pixels(v),
            to_pattern(t)
         }
   end
end

abstract class Gradient(Pattern)
   private static init()
      Class.load_library(\Context.LOADED)
   end

   private native add_color_stop_rgba(offset, r, g, b, a)

   public add_color_stop(offset, col)
      local c
      c := Window.parse_color(col) | fail
      return add_color_stop_rgba(offset, 
                                 c.red / 65535.0,
                                 c.green / 65535.0,
                                 c.blue / 65535.0,
                                 c.alpha / 65535.0)
   end
end

final class LinearGradient(Gradient)
   private static init()
      Class.load_library(\Context.LOADED)
   end

   private static native new_impl()

   public new(x0, y0, x1, y1)
      \Context.LOADED | return error("Cairo not supported")
      ptr := new_impl(x0, y0, x1, y1)
      return
   end
end

final class RadialGradient(Gradient)
   private static init()
      Class.load_library(\Context.LOADED)
   end

   private static native new_impl()

   public new(cx0, cy0, r0, cx1, cy1, r1)
      \Context.LOADED | return error("Cairo not supported")
      ptr := new_impl(cx0, cy0, r0, cx1, cy1, r1)
      return
   end
end

final class SurfacePattern(Pattern)
   private static init()
      Class.load_library(\Context.LOADED)
   end

   package static create_for_ptr(ptr)
      local i
      i := Class.create_instance()
      i.ptr := ptr
      return i
   end

   private static native new_impl(sur)

   public new(sur)
      \Context.LOADED | return error("Cairo not supported")
      ptr := new_impl(sur)
      return
   end
end

final class SolidPattern(Pattern)
   private static init()
      Class.load_library(\Context.LOADED)
   end

   private static native new_impl(r, g, b, a)

   public new(col)
      local c
      \Context.LOADED | return error("Cairo not supported")
      c := Window.parse_color(col) | fail
      ptr := new_impl(c.red / 65535.0,
                      c.green / 65535.0,
                      c.blue / 65535.0,
                      c.alpha / 65535.0)
      return
   end
end

abstract class Surface(NoCopy)
   protected ptr

   private static init()
      Class.load_library(\Context.LOADED)
   end

   public native set_device_offset(x_offset, y_offset)
   public native set_device_scale(x_scale, y_scale)

   public native close()
end

final class WindowSurface(Surface)
   private static init()
      Class.load_library(\Context.LOADED)
   end

   private static native new_impl()

   public new(win)
      \Context.LOADED | return error("Cairo not supported")
      ptr := new_impl(win)
      return
   end
end

final class ImageSurface(Surface)
   public static const FORMAT

   private static init()
      local t
      Class.load_library(\Context.LOADED)
      use {
         t := Window(),
         FORMAT := t.get_format()
      }
   end

   # Get the width of the block
   #
   public native get_width()

   # Get the height of the block
   #
   public native get_height()

   private static native new_impl(pix)

   public new(pix)
      \Context.LOADED | return error("Cairo not supported")
      pix.get_format() == FORMAT | runerr("Invalid format", pix)
      ptr := new_impl(pix)
      return
   end
end

abstract class PagedSurface(Surface)
   private static init()
      Class.load_library(\Context.LOADED)
   end

   public native copy_page()
   public native show_page()
end

final class SVGSurface(PagedSurface)
   private static init()
      Class.load_library(\Context.LOADED)
   end

   private static native new_impl()

   public new(filename, width, height)
      \Context.LOADED | return error("Cairo not supported")
      ptr := new_impl(filename, width, height)
      return
   end
end

final class PostScriptSurface(PagedSurface)
   private static init()
      Class.load_library(\Context.LOADED)
   end

   private static native new_impl()

   public new(filename, width, height)
      \Context.LOADED | return error("Cairo not supported")
      ptr := new_impl(filename, width, height)
      return
   end
end

final class PDFSurface(PagedSurface)
   private static init()
      Class.load_library(\Context.LOADED)
   end

   private static native new_impl()

   public new(filename, width, height)
      \Context.LOADED | return error("Cairo not supported")
      ptr := new_impl(filename, width, height)
      return
   end
end

final class RecordingSurface(Surface)
   private static init()
      Class.load_library(\Context.LOADED)
   end

   public get_extents()
      return Rectangle!get_extents_impl()
   end

   public ink_extents()
      return Rectangle!ink_extents_impl()
   end

   private native get_extents_impl()
   private native ink_extents_impl()

   private static native new_impl()

   public new(x, y, width, height)
      \Context.LOADED | return error("Cairo not supported")
      ptr := new_impl(x, y, width, height)
      return
   end
end

final class Context(NoCopy)
   private ptr

   public static const LOADED

   private static init()
      local t
      if Class.load_library(t := Files.find_native_lib("objecticoncairolib")) then
         LOADED := t
   end

   public native move_to(x, y)
   public native rel_move_to(x, y)
   public native line_to(x, y)
   public native rel_line_to(x, y)
   public native curve_to(x1, y1, x2, y2, x3, y3)
   public native rel_curve_to(x1, y1, x2, y2, x3, y3)
   public native stroke()
   public native stroke_preserve()
   public native set_line_width(w)
   public native set_line_join(v)
   public native set_line_cap(v)
   public native set_fill_rule(v)
   public native set_dash(offset, l[])
   public native set_font(v)
   public native set_miter_limit(v)
   public native set_tolerance(v)
   public native arc(xc, yc, r, a1, a2)
   public native arc_negative(xc, yc, r, a1, a2)
   public native rectangle(x, y, width, height)
   public native fill()
   public native fill_preserve()
   public native paint()
   public native paint_with_alpha(alpha)
   public native mask(pat)
   public native mask_surface(sur, x, y)
   public native text_path(s)
   public native close_path()
   public native new_path()
   public native new_sub_path()
   public native close()
   public native set_operator(op)
   public native set_antialias(v)

   public native get_line_width()
   public native get_line_join()
   public native get_line_cap()
   public native get_fill_rule()
   public native get_miter_limit()
   public native get_tolerance()
   public native get_antialias()
   public native get_operator()
   public native get_dash_offset()
   public native get_dashes()

   private native get_path_impl(flat)

   private static to_path_elements(t)
      local l
      l := []
      while put(l, case get(t) of {
         0 : MoveTo(get(t), get(t))
         1 : LineTo(get(t), get(t))
         2 : CurveTo(get(t), get(t), get(t), get(t), get(t), get(t))
         3 : ClosePath()
      })
      return l
   end

   private static from_path_elements(l)
      local t, e
      t := []
      every e := !l do
         case classof(e) of {
            MoveTo: every put(t, 0 | e.x | e.y)
            LineTo: every put(t, 1 | e.x | e.y)
            CurveTo: every put(t, 2 | e.x1 | e.y1 | e.x2 | e.y2 | e.x3 | e.y3)
            ClosePath: put(t, 3)
         }
      return t
   end

   public get_path()
      return to_path_elements(get_path_impl())
   end

   public get_flat_path()
      return to_path_elements(get_path_impl(1))
   end

   private native append_path_impl(l)

   public append_path(l)
      return append_path_impl(from_path_elements(l))
   end

   public get_current_point()
      return Point!get_current_point_impl()
   end

   private native get_current_point_impl()

   public native save()
   public native restore()

   public get_stroke_extents()
      return Rectangle!get_stroke_extents_impl()
   end

   public get_fill_extents()
      return Rectangle!get_fill_extents_impl()
   end

   public get_clip_extents()
      return Rectangle!get_clip_extents_impl()
   end

   public get_path_extents()
      return Rectangle!get_path_extents_impl()
   end

   private native get_stroke_extents_impl()
   private native get_clip_extents_impl()
   private native get_fill_extents_impl()
   private native get_path_extents_impl()
   private native user_to_device_impl(x, y)
   private native device_to_user_impl(x, y)

   public user_to_device(x, y)
      return Point!user_to_device_impl(x, y)
   end

   public device_to_user(x, y)
      return Point!device_to_user_impl(x, y)
   end

   public native translate(tx, ty)
   public native scale(sx, sy)
   public native rotate(r)

   public native clip()
   public native clip_preserve()
   public native reset_clip()

   public get_clip_rectangles()
      local l
      l := get_clip_rectangles_impl() | fail
      return List{Rectangle!(!l)}
   end
   private native get_clip_rectangles_impl()

   private native set_source_rgba(r, g, b, a)
   private native set_source_pattern(pat)

   public native in_stroke(x, y)
   public native in_fill(x, y)
   public native in_clip(x, y)

   public native push_group()
   public native push_group_with_content(content)
   public native pop_group_to_source()
   public pop_group()
      return SurfacePattern.create_for_ptr(pop_group_impl())
   end

   private native pop_group_impl()

   public native set_source_extend(v)
   public native get_source_extend()
   private native set_source_matrix_impl(xx, yx, xy, yy, x0, y0)
   private native get_source_matrix_impl()

   public set_source_matrix(m)
      return set_source_matrix_impl(m.xx, m.yx, m.xy, m.yy, m.x0, m.y0)
   end

   public get_source_matrix()
      return Matrix!get_source_matrix_impl()
   end

   public set_source(v)
      local t
      return if is(v, Pattern) then
         set_source_pattern(v)
      else 
         use {
            t := Pattern.to_pattern(v),
            set_source_pattern(t)
         }
   end

   public set_fg(col)
      local c
      c := Window.parse_color(col) | fail
      return set_source_rgba(c.red / 65535.0,
                             c.green / 65535.0,
                             c.blue / 65535.0,
                             c.alpha / 65535.0)
   end

   public identity_matrix()
      return set_matrix(Matrix.I)
   end

   private native set_matrix_impl(xx, yx, xy, yy, x0, y0)
   public set_matrix(m)
      return set_matrix_impl(m.xx, m.yx, m.xy, m.yy, m.x0, m.y0)
   end

   private native get_matrix_impl()
   public get_matrix()
      return Matrix!get_matrix_impl()
   end

   private static native new_impl(sur)

   public new(v)
      local t
      \LOADED | return error("Cairo not supported")
      ptr := if is(v, Window) then
         use {
            t := WindowSurface(v),
            new_impl(t)
         }
      else if is(v, Pixels) then
         use {
            t := ImageSurface(v),
            new_impl(t)
         }
      else
         new_impl(v)
      return
   end
end

final class SVG(NoCopy)
   private ptr

   private static init()
      Class.load_library(\Context.LOADED)
   end

   # Get the width of the document
   #
   public native get_width(id)

   # Get the height of the document
   #
   public native get_height(id)

   public native has_sub()
   public native get_x(id)
   public native get_y(id)
   public native get_title()
   public native get_desc()
   public native get_metadata()

   # Render to a cairo context.
   #
   public native render(context, id)

   public native close()

   private static native new_impl()

   public new(data)
      \Context.LOADED | return error("Cairo not supported")
      ptr := new_impl(data) | fail
      return
   end
end
