#
# $Id$
#

package util

#
# This class represents a caseless table()
#
class ClTable()
   private 
      def,
      t

   #
   # Insert a new entry
   #
   public insert(key, val)
      default.insert(t, map(key), [key, val])
   end

   #
   # Return the value for the given key (as a variable) if it is in
   # the table, or fail if it is not present.
   #
   public member(key)
      return default.member(t, map(key))[2]
   end

   #
   # Delete the entry with the given key
   #
   public delete(key)
      default.delete(t, map(key))
   end

   #
   # Return the value with the given key, or the default value if
   # the key is not present.  Equivalent to {.t[k]} for a table.
   #
   public get(key)
      return .(default.member(t, map(key))[2] | def)
   end

   #
   # Like {get}, but if the key is not present a new entry is added (with
   # the default value).  In any case a variable is returned.
   #
   public add(key)
      local k1, n
      k1 := map(key)
      return default.member(t, k1)[2] | {
         default.insert(t, k1, n := [key, def])
         n[2]
      }
   end

   #
   # Return a sorted list of key-value pairs.
   #
   public sort()
      local l
      l := []
      every put(l, (!default.sort(t))[2])
      return l
   end

   #
   # Generate the keys (cf the builtin key() function.)
   #
   public key()
      suspend .(!t)[1]
   end

   #
   # Generate alternating key/values (cf the builtin keyval() function.)
   #
   public keyval()
      local e
      every e := !t do
         suspend .e[1] | e[2]
   end

   #
   # Generate the values (cf !t for a table).
   #
   public gen()
      suspend (!t)[2]
   end

   #
   # Generate key-value pairs as a sequence of 2-element lists.  NB - for each
   # invocation, the same list is returned every time, with the values replaced.
   #
   public entries()
      local e, l
      l := list(2)
      every e := !t do {
         l[1] := e[1]
         l[2] := e[2]
         suspend l
      }
   end

   #
   # Return the size of the table.
   #
   public size()
      return *t
   end

   #
   # Output object
   #
   private object_output(oo)
      local pairs, e, sep
      pairs := sort()
      if oo.simple{!!pairs | def} then {
         oo.object_start(self) | fail
         if \def then {
            oo.writes("default=") | fail
            oo.traverse(def) | fail
            sep := 1
         }
         every e := !pairs do {
            if \sep then
               oo.writes(";") | fail
            oo.traverse(e[1]) | fail
            oo.writes("->") | fail
            oo.traverse(e[2]) | fail
            sep := 1
         }
         oo.object_end(self) | fail
      } else {
         oo.nl() | fail
         oo.object_start(self) | fail
         oo.iplus()
         if \def then {
            oo.nl() | fail
            oo.writes("default=") | fail
            oo.iplus()
            oo.traverse(def) | fail
            oo.iminus()
         }
         every e := !pairs do {
            oo.nl() | fail
            oo.traverse(e[1]) | fail
            oo.writes("->") | fail
            oo.iplus()
            oo.traverse(e[2]) | fail
            oo.iminus()
         }
         oo.iminus()
         oo.nl() | fail
         oo.object_end(self) | fail
      }
      return
   end

   public new(def, entries[])
      self.def := def
      t := table(def)
      if *entries % 2 ~= 0 then
          runerr(134)
      while *entries > 0 do
         insert(default.get(entries), default.get(entries))
      return
   end
end

