<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>sets.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     sets.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures for set manipulation
<a name="6"/>#
<a name="7"/>#	Author:   Alan Beale
<a name="8"/>#
<a name="9"/>#	Date:     August 7, 1999
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#	Contributor:  Ralph E. Griswold
<a name="18"/>#
<a name="19"/>############################################################################
<a name="20"/>#
<a name="21"/>#       elementset(x)   returns a set that contains the individual elements
<a name="22"/>#                       of x, generated by the ! operator.
<a name="23"/>#
<a name="24"/>#       domain(T)       returns the domain of the function defined by the
<a name="25"/>#                       table T.
<a name="26"/>#
<a name="27"/>#       inverse(T, x)   returns the inverse of the function defined by the
<a name="28"/>#                       table T.  If x is null, it's the functional inverse.
<a name="29"/>#                       If x is an empty list, it's the relational inverse.
<a name="30"/>#                       If x is an empty set, it the relational inverse, but
<a name="31"/>#                       with each table member as a set instead of a list.
<a name="32"/>#
<a name="33"/>#       pairset(T)      converts the table T to an equivalent set of ordered
<a name="34"/>#                       pairs.
<a name="35"/>#
<a name="36"/>#       range(T)        returns the range of the function defined by the
<a name="37"/>#                       table T.
<a name="38"/>#  
<a name="39"/>#       seteq(S1, S2)   tests equivalence of sets S1 and S2.
<a name="40"/>#
<a name="41"/>#       setlt(S1, S2)   tests inclusion of set S1 in S2.
<a name="42"/>#
<a name="43"/>#       simage(S)       string image of set
<a name="44"/>#
<a name="45"/>############################################################################
<a name="46"/>
<a name="47"/>package ipl.sets
<a name="48"/>
<a name="49"/>import ipl.pdco(Set, String)
<a name="50"/>
<a name="51"/># Returns a set that contains the individual elements of `x`,
<a name="52"/># generated by the `!` operator.
<a name="53"/>#
<a name="54"/>procedure elementset(x)			
<a name="55"/>   return Set{ !x }
<a name="56"/>end
<a name="57"/>
<a name="58"/># Converts the table `T` to an equivalent set of ordered pairs.
<a name="59"/>procedure pairset(T)			
<a name="60"/>    return elementset(sort(T))
<a name="61"/>end
<a name="62"/>
<a name="63"/># Returns the domain of the function defined by the table `T`.
<a name="64"/>procedure domain(T)			
<a name="65"/>   return Set{ key(T) }
<a name="66"/>end
<a name="67"/>
<a name="68"/># Returns the range of the function defined by the table `T`.
<a name="69"/>procedure range(T)			
<a name="70"/>   return Set{ !T }
<a name="71"/>end
<a name="72"/>
<a name="73"/># Returns the inverse of the function defined by the table `T`.  If
<a name="74"/># `Default` is null, it's the functional inverse.  If `Default` is an
<a name="75"/># empty list, it's the relational inverse.  If `Default` is an empty
<a name="76"/># set, it the relational inverse, but with each table member as a set
<a name="77"/># instead of a list.
<a name="78"/>#
<a name="79"/>procedure inverse(T, Default)		
<a name="80"/>    local inv, delem, relem
<a name="81"/>
<a name="82"/>    inv := table(Default)
<a name="83"/>    every delem := key(T) do {
<a name="84"/>        if type(Default) == "list" then
<a name="85"/>          if member(inv, relem := T[delem]) then
<a name="86"/>            put(inv[relem], delem)
<a name="87"/>          else inv[relem] := [delem]
<a name="88"/>        else if type(Default) == "set" then
<a name="89"/>          if member(inv, relem := T[delem]) then
<a name="90"/>            insert(inv[relem], delem)
<a name="91"/>          else inv[relem] := set(delem)
<a name="92"/>        else inv[T[delem]] := delem
<a name="93"/>    }
<a name="94"/>    return inv
<a name="95"/>end
<a name="96"/>
<a name="97"/># Tests equivalence of sets `set1` and `set2`.
<a name="98"/>procedure seteq(set1, set2)		
<a name="99"/>   local x
<a name="100"/>
<a name="101"/>   if *set1 ~= *set2 then fail
<a name="102"/>   every x := !set1 do
<a name="103"/>      member(set2, x) | fail
<a name="104"/>   return set2
<a name="105"/>
<a name="106"/>end
<a name="107"/>
<a name="108"/># Tests inclusion of set `set1` in `set2`.
<a name="109"/>procedure setlt(set1, set2)		
<a name="110"/>   local x
<a name="111"/>
<a name="112"/>   if *set1 &gt;= *set2 then fail
<a name="113"/>   every x := !set1 do
<a name="114"/>      member(set2, x) | fail
<a name="115"/>   return set2
<a name="116"/>
<a name="117"/>end
<a name="118"/>
<a name="119"/># Test if `set1` is a subset of `set2`.
<a name="120"/>procedure setle(set1, set2)		
<a name="121"/>   local x
<a name="122"/>
<a name="123"/>   if *set1 &gt; *set2 then fail
<a name="124"/>   every x := !set1 do
<a name="125"/>      member(set2, x) | fail
<a name="126"/>   return set2
<a name="127"/>
<a name="128"/>end
<a name="129"/>
<a name="130"/># String image of set
<a name="131"/>procedure simage(set)			
<a name="132"/>   return "{" || String{ image(!set), "," } || "}"
<a name="133"/>end
</pre></body></html>
