#define FONTHASH_SIZE 64
#define CURSORHASH_SIZE 128

static int inited;
static wfp fonts[FONTHASH_SIZE], default_font;
static struct wcursor *cursors[CURSORHASH_SIZE];
static struct SharedCursor *null_cursor;
static Rectangle max_rect;
static struct Cursor cursor_data[];
static int use_win;
static char old_label[256];

static int read_screeninfo(wsp ws, int *mx, int *my, int *sx, int *sy, int *sw, int *sh);
static int open_winfile(wsp ws, char *s, int mode);
static struct FontInfo *match_font(char *s);
static void load_font_info(void);
static void setup_cursors(void);
static wfp alcfont(wbp w, char **s);
static void mouse_loop(wsp ws);
static Rune *utf8_to_runes(dptr str);
static void cons_loop(wsp ws);
static wfp load_font(char *s);
static void synch_cursor(wsp ws);
static void synch_cursors(struct wcursor *c);
static vlong get_time(void);
static ulong get_timestamp(void);
static int open_screen_win(wsp ws);
static Image *any_other_win(Image *win);
static void close_screen_win(wsp ws);
static void open_pix_win(wsp ws);
static Image *get_draw_img(wcp wc);
static void close_pix_win(wsp ws);
static void resize_pix_win(wbp w);
static void handle_reshape(wsp ws);
static void handle_reshape1(wsp ws);
static void handle_limited(wsp ws);
static void init_window_system(void);
static void clip(wbp w);
static void no_clip(wsp ws, int and_win);
static Rectangle InnerRect(Image *i, int x, int y, int w, int h);
static Rectangle MkRect(int x, int y, int w, int h);
static Point InnerPt(Image *i, int x, int y);
static struct SharedColor *new_sharedcolor(char *name, int rgba);
static struct SharedColor *link_sharedcolor(struct SharedColor *i);
static void unlink_sharedcolor(struct SharedColor *i);
static struct SharedImage *new_sharedimage(struct imgdata *imd);
static struct SharedImage *link_sharedimage(struct SharedImage *x);
static void unlink_sharedimage(struct SharedImage *x);
static struct SharedCursor *new_sharedcursor(struct Cursor *cursor);
static struct SharedCursor *link_sharedcursor(struct SharedCursor *x);
static void unlink_sharedcursor(struct SharedCursor *x);
static struct wcursor *lookup_wcursor(char *name);
static struct wcursor *ensure_wcursor(char *name);
static void synch_pos(wsp ws);
static void synch_size(wsp ws);
static void synch_state(wsp ws);
static void synch_state1(wsp ws);
static void note_time(char *s);
static void copy_pix_to_win(wsp ws);
static int readimageimpl(char *cmd, int fd, struct imgdata *imd);
static Image *imgdata_to_Image(struct imgdata *imd);
static void fill1(wbp w, int x, int y, int width, int height);
static void fill2(wbp w, int op, Image *color, int x, int y, int width, int height);
static void line2(wbp w, int x1, int y1, int x2, int y2);
static int get_thick(wcp wc);
static Point *convert_points(struct point *points0, int npoints);
static Image *getmask(int width, int height);
static void maskimage2(wbp w, Image *mask, int x, int y, int width, int height);
static int needmask(wcp wc, int overlap);
static wbp alcwbinding(void);
static wbp findwbp(wsp ws);
static wcp clonecontext(wcp src);
static void freewindow(wsp ws);
static void freecontext(wcp wc);

static struct imgdataformat imgdataformat_P9ABGR32;
static struct imgdataformat imgdataformat_P9AG16;

#define NormalCanvas 1
#define HiddenCanvas 2
#define IconicCanvas 3
#define PopupCanvas  4

/* Provides info about a font available on the system. */
struct FontInfo {
   char *path;
   char *family;
   int flags;
   double size;
   struct FontInfo *next;
};
static struct FontInfo *font_info;

/* List of windows with win non-null */
static wsp vwstates;

/* List of bindings */
static wbp wbndngs;

static stringint drawops[] = {
   { 0, 12},
   {"atop",           SatopD},
   {"clear",          Clear},
   {"dest",           D},
   {"dest atop",      DatopS},
   {"dest in",        DinS},
   {"dest out",       DoutS},
   {"dest over",      DoverS},
   {"in",             SinD},
   {"out",            SoutD},
   {"over",           SoverD},
   {"source",         S},
   {"xor",            SxorD},
};

static stringint linestyles[] = {
    {0, 3},
    {"enddisc",      Enddisc},
    {"endsquare",    Endsquare},
    {"solid",        Endsquare},
};

static stringint canvastypes[] = {
    {0, 4},
    {"hidden",      HiddenCanvas},
    {"iconic",      IconicCanvas},
    {"normal",      NormalCanvas},
    {"popup",       PopupCanvas},
};

static struct SharedColor *black, *white;
static int window_count;

#if 0
static void dump_all(void)
{
    int i,j,k;
    wsp x;
    wbp y;
    i = 0;
    for (y = wbndngs; y; y = y->next) {
        printf("Binding %p\n",y);
        printf("\tcanvas %p\n",y->window);
        printf("\tcontext %p\n",y->context);
        ++i;
    }
    printf("============\n");
    j = 0;
    for (x = wstates; x; x = x->wnext) {
        printf("Canvas %p\n",x);
        printf("\trefcount=%d\n", x->refcount);
        printf("\tlabel=%s\n", x->windowlabel);
        printf("\tgeometry=%d,%d %dx%d\n", x->x,x->y,x->width,x->height);
        printf("\twin=%d\n", (int)x->win);
        ++j; 
    }
    printf("============\n");
    k = 0;
    for (x = vwstates; x; x = x->vnext) {
        printf("Non-hidden Canvas %p\n",x);
        printf("\trefcount=%d\n", x->refcount);
        printf("\tlabel=%s\n", x->windowlabel);
        printf("\tgeometry=%d,%d %dx%d\n", x->x,x->y,x->width,x->height);
        printf("\twin=%d\n", (int)x->win);
        ++k; 
    }

    printf("Total %d bindings %d canvases (%d non-hidden)\n",i,j,k);
}
#endif

static int open_winfile(wsp ws, char *s, int mode)
{
    char buff[128];
    int fd;
    sprintf(buff, "%s/%s", ws->mount_dir, s);
    fd = open(buff, mode|OCEXEC);
    return fd;
}

static struct SharedColor *new_sharedcolor(char *name, int rgba)
{
    struct SharedColor *res;
    GAlloc(res, SharedColor);
    res->name = salloc(name);
    res->rgba = rgba;
    MemProtect(res->i = allocimage(display, Rect(0, 0, 1, 1), RGBA32, 1, rgba));
    return res;
}

static struct SharedColor *link_sharedcolor(struct SharedColor *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedcolor(struct SharedColor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        free(x->name);
        freeimage(x->i);
        free(x);
    }
}

static struct SharedImage *new_sharedimage(struct imgdata *imd)
{
    struct SharedImage *res;
    GAlloc(res, SharedImage);
    res->i = imgdata_to_Image(imd);
    return res;
}

static struct SharedImage *link_sharedimage(struct SharedImage *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedimage(struct SharedImage *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        freeimage(x->i);
        free(x);
    }
}

static struct SharedCursor *new_sharedcursor(struct Cursor *cursor)
{
    struct SharedCursor *res;
    GAlloc(res, SharedCursor);
    res->cursor = cursor;
    return res;
}

static struct SharedCursor *link_sharedcursor(struct SharedCursor *x)
{
    ++x->refcount;
    return x;
}

static void unlink_sharedcursor(struct SharedCursor *x)
{
    --x->refcount;
    if (x->refcount == 0) {
        free(x->cursor);
        free(x);
    }
}

static struct wcursor *lookup_wcursor(char *name)
{
    struct wcursor *rv;
    int i;
    i = hasher(hashcstr(name), cursors);
    for(rv = cursors[i]; rv; rv = rv->next) {
        if (!strcmp(name, rv->name))
            return rv;
    }
    return 0;
}

static struct wcursor *ensure_wcursor(char *name)
{
    struct wcursor *rv;
    int i;
    i = hasher(hashcstr(name), cursors);
    for(rv = cursors[i]; rv; rv = rv->next) {
        if (!strcmp(name, rv->name))
            return rv;
    }
    rv = rt_zalloc(sizeof(struct wcursor));
    rv->name = salloc(name);
    rv->next = cursors[i];
    cursors[i] = rv;
    return rv;
}

#begdef CheckUnhidden(ws)
do {
   if (!ws->win) {
      LitWhy("Window is hidden");
      return Failed;
   }
} while(0)
#enddef

static void draw_error(Display *d, char *s)
{
    fprintf(stderr, "Draw error on display %p: %s\n", d, s);
}

wbp wopen(char *display)
{
    wbp w;
    wsp ws;
    wcp wc;
    char *wsysstr = 0;

    if (!inited) {
        init_window_system();
        inited = 1;
    }

    /* Get this first so we don't have to fail halfway through the setup */
    if (display)
        wsysstr = salloc(display);
    else {
        wsysstr = getenv("wsys");
        if (!wsysstr) {
            LitWhy("wsys environment variable not set");
            return 0;
        }
    }

    w = alcwbinding();

    GAlloc(ws, _wstate);
    ws->listp = nulldesc;
    ws->windowlabel = defaultwindowlabel;
    add_gc_global(&ws->windowlabel);
    add_gc_global(&ws->listp);
    ws->event_pipe[0] = ws->event_pipe[1] = ws->mouse_fd = ws->cons_fd = ws->consctl_fd =
        ws->screeninfo_fd = ws->cursor_fd = ws->label_fd = ws->mouse_pid = ws->cons_pid =
        ws->wininfo_fd = ws->wsys_fd = ws->wctl_fd = ws->winid = -1;
    ws->cursor = lookup_wcursor("left ptr");
    ws->reqx = ws->reqy = ws->x = ws->y = -INT_MAX;
    ws->minwidth = ws->minheight = 1;
    ws->maxwidth = ws->maxheight = INT_MAX;
    ws->width = ws->height = 1;
    ws->state = HiddenCanvas;
    w->window = ws;
    ws->wsys = wsysstr;
    create_list(64, &ws->listp);

    GAlloc(wc, _wcontext);
    wc->clipx = wc->clipy = 0;
    wc->clipw = wc->cliph = -1;
    wc->fg = link_sharedcolor(black);
    wc->bg = link_sharedcolor(white);
    wc->font = default_font;
    wc->leading = defaultleading;
    wc->drawop = stringint_lookup(drawops, "over");
    wc->linestyle = stringint_lookup(linestyles, "endsquare");
    wc->linewidth = 1;

    w->context = wc;

    open_pix_win(ws);
    /* Fill pixmap with bg color */
    gendrawop(ws->pix, ws->pix->r, w->context->bg->i, ZP, 0, ZP, S);

    return w;
}

static void copy_to(Image *dest, Image *src)
{
    gendrawop(dest, 
              InnerRect(dest, 0, 0, Dx(src->r), Dy(src->r)), 
              src, 
              src->r.min,
              0, ZP, S);
}

static void pix_to_win(wsp ws, int x, int y, int w, int h)
{
    if (ws->win)
        gendrawop(ws->win, 
                  InnerRect(ws->win, x, y, w, h),
                  ws->pix, 
                  Pt(x, y),
                  0, ZP, S);
}

static int adjust(wsp ws, int dim)
{
    if (dim == INT_MAX)
        return dim;
    else
        return dim + ws->border_width;
}

static ulong get_timestamp(void)
{
    return nsec() / 1000000;
}

static void mouse_loop(wsp ws)
{
    char buf[49];
    while (read(ws->mouse_fd, buf, sizeof(buf)) > 0) {
        /* Update timestamp */
        snprintf(&buf[37], 12, "%11lu ", get_timestamp());
        if (write(ws->event_pipe[1], buf, 49) != 49)
            break;
        ++ws->mouse_events;
    }
    _exits(0);
}

static void cons_loop(wsp ws)
{
    Rune r;
    char buf[49], in[10];
    buf[0] = 'k';
    while (read(ws->cons_fd, in, sizeof(in)) > 0) {
        /* Set mouse x,y */
        pread(ws->screeninfo_fd, &buf[1], 24, 0);
        /* Set arg and timestamp */
        chartorune(&r, in);
        snprintf(&buf[25], 24, "%11d %11lu ", (int)r, get_timestamp());
        if (write(ws->event_pipe[1], buf, 49) != 49)
            break;
        ++ws->cons_events;
    }
    _exits(0);
}

/*
 * Synch the x, y variables with rio's values.
 */
static void synch_pos(wsp ws)
{
    int sx, sy, newx, newy;
    if (read_screeninfo(ws, 0,0, &sx, &sy, 0,0) != Succeeded)
        return;
    newx = ws->win->r.min.x - sx;
    newy = ws->win->r.min.y - sy;
    if ((newx != ws->x) || (newy != ws->y)) {
        ws->x = newx;
        ws->y = newy;
        qeventcode(ws, WINDOWMOVED);
    }
}

static void synch_size(wsp ws)
{
    if (Dx(ws->win->r) != ws->width || Dy(ws->win->r) != ws->height) {
        ws->width = Dx(ws->win->r);
        ws->height = Dy(ws->win->r);
        resize_pix_win(findwbp(ws));
        qeventcode(ws, WINDOWRESIZED);
    }
}

static void resize_pix_win(wbp w)
{
    wsp ws = w->window;
    Image *t;
    if (Dx(ws->pix->r) == ws->width && Dy(ws->pix->r) == ws->height)
        return;
    MemProtect(t = allocimage(display, Rect(0, 0, ws->width, ws->height), RGBA32, 1, DNofill));
    gendrawop(t, t->r, w->context->bg->i, ZP, 0, ZP, S);
    no_clip(ws, 0);
    copy_to(t, ws->pix);
    freeimage(ws->pix);
    ws->pix = t;
}

static void handle_limited(wsp ws)
{
    synch_pos(ws);
    synch_size(ws);
    copy_pix_to_win(ws);
}

static void handle_reshape(wsp ws)
{
    char buff[128];
    sprintf(buff, "%s/winname", ws->mount_dir);
    if (gengetwindow(display, buff, &ws->win, &ws->screen, Refnone) < 0)
        syserr("Failed to reconnect to window on a resize");
    handle_reshape1(ws);
}

/*
 * Copy the pix win to the window.
 */
static void copy_pix_to_win(wsp ws)
{
    no_clip(ws, 1);
    copy_to(ws->win, ws->pix);
    flushimage(display, 1);
}

static void handle_reshape1(wsp ws)
{
    synch_state(ws);
    synch_pos(ws);
    synch_size(ws);
    copy_pix_to_win(ws);
}

void pollevent(wbp w)
{
    wsp ws = w->window;
    int n, mx, my, arg;
    char buf[49];
    tended struct descrip d;
    uword time;

    /* Check if pipe open */
    if (!ws->win || ws->event_pipe[0] < 0)
        return;

    while (ws->events_read < ws->mouse_events + ws->cons_events) {
        n = read(ws->event_pipe[0], buf, sizeof(buf));
        if (n <= 0)
            return;

        ++ws->events_read;

        if (n != 49)
            syserr("bad data in event pipe");
        mx = atoi(buf + 1 + 0*12) - ws->win->r.min.x; 
        my = atoi(buf + 1 + 1*12) - ws->win->r.min.y;
        arg = atoi(buf + 1 + 2*12);
        time = atoi(buf + 1 + 3*12);
        switch (buf[0]) {
            case 'k' : {
                if (arg == 10) arg = 13;   /* Hack: convert \n to \r */
                if (arg < 256) {
                    /* Found a char string, so generate string event */
                    StrLen(d) = 1;
                    StrLoc(d) = &allchars[arg & 0xFF];
                } else if (arg < 60000) {
                    d.dword = D_Ucs;
                    BlkLoc(d) = (union block *)make_one_char_ucs_block(arg);
                } else 
                    MakeInt(arg, &d);
                qevent(ws, &d, 
                       mx,
                       my,
                       time, 0);
                break;
            }
            case 'r':
                handle_reshape(ws);
                break;
            case 'l':
                handle_limited(ws);
                break;
            case 'c': {
                qeventcode(ws, WINDOWCLOSED);
                break;
            }
            case 'e': {
                struct descrip d;
                MakeInt(MOUSEENTERED, &d);
                qevent(ws, &d, mx, my, time, 0);
                break;
            }
            case 'x': {
                struct descrip d;
                MakeInt(MOUSEEXITED, &d);
                qevent(ws, &d, mx, my, time, 0);
                break;
            }
            case 'm': {
                qmouseevents(ws, 
                             arg,
                             mx,
                             my,
                             time, 0);
                /* A wheel up or down (8 or 16) just gives one event,
                 * but qmouseevents expects two, as though this were a
                 * button press and release.  So enqueue another event
                 * with the flag turned off.
                 */
                if (arg & 24)
                    qmouseevents(ws, 
                                 arg & ~24,
                                 mx,
                                 my,
                                 time, 0);
                break;
            }
            default:
                syserr("bad event code in event pipe");
        }
    }
}

int grabpointer(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    if (fprint(ws->wctl_fd, "grabpointer") < 0) {
       whyf("Can't grab pointer: %r");
       return Failed;
    }
    return Succeeded;
}

int ungrabpointer(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    if (fprint(ws->wctl_fd, "ungrabpointer") < 0) {
       whyf("Can't ungrab pointer: %r");
       return Failed;
    }
    return Succeeded;
}

int grabkeyboard(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    if (fprint(ws->wctl_fd, "grabkeyboard") < 0) {
       whyf("Can't grab keyboard: %r");
       return Failed;
    }
    return Succeeded;
}

int ungrabkeyboard(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    if (fprint(ws->wctl_fd, "ungrabkeyboard") < 0) {
       whyf("Can't ungrab keyboard: %r");
       return Failed;
    }
    return Succeeded;
}

int walert(wbp w, int volume)
{
    return Succeeded;
}

int copyarea(wbp w1, int x, int y, int w, int h, wbp w2, int x2, int y2)
{
    wsp ws1 = w1->window;
    wsp ws2 = w2->window;
    wcp wc2 = w2->context;
    no_clip(ws1, 0);
    clip(w2);
    gendrawop(ws2->pix,
              MkRect(x2, y2, w, h), 
              ws1->pix,
              Pt(x, y),
              0, ZP,
              wc2->drawop->i);
    pix_to_win(ws2, x2, y2, w, h);
    flushimage(display, 1);
    return Succeeded;
}

/*
 * allocate a window binding structure
 */
static wbp alcwbinding()
{
    wbp w;
    w = rt_zalloc(sizeof(struct _wbinding));
    GLink(w, wbndngs);
    return w;
}

static wbp findwbp(wsp ws)
{
    wbp wb;
    for (wb = wbndngs; wb; wb = wb->next)
        if (wb->window == ws)
            return wb;
    syserr("Couldn't find wbp for wsp");
    return 0;  /* not reached */
}

/*
 * free a window binding.
 */
void freewbinding(wbp w)
{
    freewindow(w->window);
    freecontext(w->context);
    GUnlink(w, wbndngs);
    free(w);
}

wbp clonewindow(wbp w)
{
    wbp w2;
    w2 = alcwbinding();
    w2->window = linkwindow(w->window);
    w2->context = clonecontext(w->context);
    return w2;
}

wbp couplewindows(wbp w1, wbp w2)
{
    wbp w3;
    w3 = alcwbinding();
    w3->window = linkwindow(w1->window);
    w3->context = linkcontext(w2->context);
    return w3;
}

void drawarc(wbp w, double cx, double cy, double rx, double ry, double angle1, double angle2)
{
    int alpha, phi, x, y, width, height, thick;
    wsp ws = w->window;
    wcp wc = w->context;
    thick = get_thick(wc);
    clip(w);
    alpha = -angle1 * 180 / Pi;
    phi = -angle2 * 180 / Pi;
    x = cx - rx - 1 - thick;
    y = cy -ry - 1 - thick;
    width = 2 * rx + 2 * thick + 2;
    height = 2 * ry + 2 * thick + 2;
    arcop(ws->pix, 
          Pt(cx, cy),
          rx, ry,
          thick,
          get_draw_img(wc), 
          Pt(cx, cy),
          alpha, phi,
          wc->drawop->i);
    pix_to_win(ws, x, y, width, height);
    flushimage(display, 1);
}

static Point *convert_points(struct point *points0, int npoints)
{
    Point *points;
    int i;
    points = rt_malloc(npoints * sizeof(Point));
    for (i = 0; i < npoints; ++i) {
        points[i].x = points0[i].x;
        points[i].y = points0[i].y;
    }
    return points;
}

void drawlines(wbp w, struct point *points0, int npoints)
{
    int i, term, x, y, width, height, thick, closed;
    wsp ws = w->window;
    wcp wc = w->context;
    Point *points;
    if (npoints < 2)
        return;
    closed = points0[npoints - 1].x == points0[0].x && points0[npoints - 1].y == points0[0].y;
    thick = get_thick(wc);
    points_extent(points0, npoints, &x, &y, &width, &height);
    x -= thick;
    y -= thick;
    width += 2 * thick;
    height += 2 * thick;

    points = convert_points(points0, npoints);
    if (closed)
        term = Enddisc;
    else
        term = wc->linestyle->i;
    clip(w);
    /* mask with overlap flag set since polyop draws the line joins
     * overlapping the line segments. */
    if (needmask(wc, 1)) {
        Image *mask = getmask(width, height);
        for (i = 0; i < npoints; ++i) {
            points[i].x -= x;
            points[i].y -= y;
        }
        polyop(mask, points, npoints, term, term, thick, white->i, ZP, SoverD);
        maskimage2(w, mask, x, y, width, height);
        freeimage(mask);
    } else {
        polyop(ws->pix, points, npoints, term, term, thick, get_draw_img(wc), ZP, wc->drawop->i);
        pix_to_win(ws, x, y, width, height);
    }
    free(points);
    flushimage(display, 1);
}

static void fill1(wbp w, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    gendrawop(ws->pix, 
              MkRect(x, y, width, height),
              get_draw_img(wc), Pt(x, y), 
              0, ZP, wc->drawop->i);
}

static void fill2(wbp w, int op, Image *color, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    gendrawop(ws->pix, 
              MkRect(x, y, width, height),
              color, Pt(x, y), 
              0, ZP, op);
    pix_to_win(ws, x, y, width, height);
}

static void line2(wbp w, int x1, int y1, int x2, int y2)
{
    wsp ws = w->window;
    wcp wc = w->context;
    int thick;
    if (x2 < x1) {
        int t = x1 ; x1 = x2; x2 = t;
    }
    if (y2 < y1) {
        int t = y1 ; y1 = y2; y2 = t;
    }
    thick = get_thick(wc);
    if (x1 == x2)
        lineop(ws->pix, Pt(x1, y1), Pt(x2, y2 + 1), Endsquare, Endsquare, thick, get_draw_img(wc), ZP, wc->drawop->i);
    else
        lineop(ws->pix, Pt(x1, y1), Pt(x2 + 1, y2), Endsquare, Endsquare, thick, get_draw_img(wc), ZP, wc->drawop->i);
    pix_to_win(ws, x1 - thick, y1 - thick, 1 + x2 - x1 + 2 * thick, 1 + y2 - y1 + 2 * thick);
}

void drawrectangle(wbp w, int x, int y, int width, int height, int thick)
{
    wsp ws = w->window;
    wcp wc = w->context;
    if (width <= 2 * thick || height <= 2 * thick)
        fillrectangle(w, x, y, width, height);
    else {
        clip(w);
        fill1(w,
              x, y,
              width, thick);
        fill1(w,
              x, y +  thick,
              thick, height - 2 * thick);
        fill1(w,
              x + width - thick, y + thick,
              thick, height - 2 * thick);
        fill1(w,
              x, y + height - thick,
              width, thick);
        pix_to_win(ws, x, y, width, height);
        flushimage(display, 1);
    }
}

void fillpolygon(wbp w, struct point *points0, int npoints)
{
    wsp ws = w->window;
    wcp wc = w->context;
    int x, y, width, height, i;
    Point *points;
    if (npoints < 3)
        return;
    points_extent(points0, npoints, &x, &y, &width, &height);
    points = convert_points(points0, npoints);
    clip(w);
    fillpolyop(ws->pix, points, npoints, 0, get_draw_img(wc), points[0], wc->drawop->i);
    pix_to_win(ws, x, y, width, height);
    free(points);
    flushimage(display, 1);
}

static int needmask(wcp wc, int overlap)
{
    /* ops where influence of source color is 0 (clear, dest, dest in, dest out) */
    if (wc->drawop->i == Clear || wc->drawop->i == D || wc->drawop->i == DinS || wc->drawop->i == DoutS)
        return 0;
    if (wc->pattern)
        return 1;
    if (!overlap)
        return 0;
    if ((wc->fg->rgba & 0xff) != 0xff)
        return 1;
    return 0;
}

static Image *getmask(int width, int height)
{
    Image *i;
    MemProtect(i = allocimage(display, Rect(0, 0, width, height), RGBA32, 1, DTransparent));
    return i;
}

static void maskimage2(wbp w, Image *mask, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    gendrawop(ws->pix, 
              MkRect(x, y, width, height),
              get_draw_img(wc),
              Pt(x, y),
              mask,
              ZP, 
              wc->drawop->i);
    pix_to_win(ws, x, y, width, height);
}

void filltrapezoids(wbp w, struct trapezoid *traps, int ntraps)
{
    wsp ws = w->window;
    wcp wc = w->context;
    int x, y, width, height, i;
    trapezoids_extent(traps, ntraps, &x, &y, &width, &height);
    clip(w);
    if (needmask(wc, 1)) {
        Image *mask = getmask(width, height);
        for (i = 0; i < ntraps; ++i) {
            Point p[4];
            p[0] = Pt(traps[i].x1 - x, traps[i].top - y);
            p[1] = Pt(traps[i].x2 - x, traps[i].top - y);
            p[2] = Pt(traps[i].x4 - x, traps[i].bottom - y);
            p[3] = Pt(traps[i].x3 - x, traps[i].bottom - y);
            fillpolyop(mask, p, 4, 0, white->i, ZP, SoverD);
        }
        maskimage2(w, mask, x, y, width, height);
        freeimage(mask);
    } else {
        for (i = 0; i < ntraps; ++i) {
            Point p[4];
            p[0] = Pt(traps[i].x1, traps[i].top);
            p[1] = Pt(traps[i].x2, traps[i].top);
            p[2] = Pt(traps[i].x4, traps[i].bottom);
            p[3] = Pt(traps[i].x3, traps[i].bottom);
            fillpolyop(ws->pix, p, 4, 0, get_draw_img(wc), ZP, wc->drawop->i);
        }
        pix_to_win(ws, x, y, width, height);
    }
    flushimage(display, 1);
}

void filltriangles(wbp w, struct triangle *tris, int ntris)
{
    wsp ws = w->window;
    wcp wc = w->context;
    int x, y, width, height, i;
    triangles_extent(tris, ntris, &x, &y, &width, &height);
    clip(w);
    if (needmask(wc, 1)) {
        Image *mask = getmask(width, height);
        for (i = 0; i < ntris; ++i) {
            Point p[3];
            p[0] = Pt(tris[i].p1.x - x, tris[i].p1.y - y);
            p[1] = Pt(tris[i].p2.x - x, tris[i].p2.y - y);
            p[2] = Pt(tris[i].p3.x - x, tris[i].p3.y - y);
            fillpolyop(mask, p, 3, 0, white->i, ZP, SoverD);
        }
        maskimage2(w, mask, x, y, width, height);
        freeimage(mask);
    } else {
        for (i = 0; i < ntris; ++i) {
            Point p[3];
            p[0] = Pt(tris[i].p1.x, tris[i].p1.y);
            p[1] = Pt(tris[i].p2.x, tris[i].p2.y);
            p[2] = Pt(tris[i].p3.x, tris[i].p3.y);
            fillpolyop(ws->pix, p, 3, 0, get_draw_img(wc), ZP, wc->drawop->i);
        }
        pix_to_win(ws, x, y, width, height);
    }
    flushimage(display, 1);
}

static Rectangle InnerRect(Image *i, int x, int y, int w, int h)
{
    return Rect(i->r.min.x + x, 
                i->r.min.y + y, 
                i->r.min.x + x + w, 
                i->r.min.y + y + h);
}

static Rectangle MkRect(int x, int y, int w, int h)
{
    return Rect(x, y, x + w, y + h); 
}

static Point InnerPt(Image *i, int x, int y)
{
    return Pt(i->r.min.x + x, 
              i->r.min.y + y);
}

static void clip(wbp w)
{
    wsp ws = w->window;
    wcp wc = w->context;
    if (wc->clipw >= 0) {
        replclipr(ws->pix, 0, MkRect(wc->clipx, wc->clipy, wc->clipw, wc->cliph));
        if (ws->win)
            replclipr(ws->win, 0, InnerRect(ws->win, wc->clipx, wc->clipy, wc->clipw, wc->cliph));
    } else
        no_clip(ws, 1);
}

static void no_clip(wsp ws, int and_win)
{
    replclipr(ws->pix, 0, max_rect);
    if (and_win && ws->win)
        replclipr(ws->win, 0, max_rect);
}

void drawstring(wbp w, int x, int y, dptr str)
{
    wsp ws = w->window;
    wcp wc = w->context;
    Point p = Pt(x, y - wc->font->ascent);
    clip(w);
    if (is:string(*str)) {
        stringnop(ws->pix, p,
                  get_draw_img(wc), p,
                  wc->font->font, StrLoc(*str), StrLen(*str), wc->drawop->i);
        pix_to_win(ws, 
                   p.x, 
                   p.y, 
                   stringnwidth(wc->font->font, StrLoc(*str), StrLen(*str)) + wc->font->font->width,   /* Add 1xwidth for italics */
                   wc->font->ascent + wc->font->descent);
    } else {
        Rune *r = utf8_to_runes(str);
        runestringnop(ws->pix, p,
                      get_draw_img(wc), p,
                      wc->font->font, r, UcsBlk(*str).length, wc->drawop->i);
        pix_to_win(ws, 
                   p.x, 
                   p.y, 
                   runestringnwidth(wc->font->font, r, UcsBlk(*str).length) + wc->font->font->width,   /* Add 1xwidth for italics */
                   wc->font->ascent + wc->font->descent);
        free(r);
    }
    flushimage(display, 1);
}

static Rune *utf8_to_runes(dptr str)
{
    Rune *r;
    word i, j, len;
    char *s = StrLoc(UcsBlk(*str).utf8);
    len = UcsBlk(*str).length;
    r = rt_malloc(len * sizeof(Rune));
    for (i = 0; i < len; ++i) {
        j = chartorune(&r[i], s);
        s += j;
    }
    return r;
}

void erasearea(wbp w, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    clip(w);
    fill2(w, S, wc->bg->i, x, y, width, height);
    flushimage(display, 1);
}

static int to_color_value(int r, int g, int b, int a)
{
    r = Mul16(r, a) / 256;
    g = Mul16(g, a) / 256;
    b = Mul16(b, a) / 256;
    a /= 256;
    return (r << 24) | (g << 16) | (b << 8) | a;
}

int setfg(wbp w, char *val)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(val, &r, &g, &b, &a))
        return Failed;
    unlink_sharedcolor(wc->fg);
    wc->fg = new_sharedcolor(val, to_color_value(r, g, b, a));
    return Succeeded;
}

char *getfg(wbp w)
{
    return w->context->fg->name;
}

int setbg(wbp w, char *val)
{
    int r, g, b, a;
    wcp wc = w->context;
    if (!parsecolor(val, &r, &g, &b, &a))
        return Failed;
    unlink_sharedcolor(wc->bg);
    wc->bg = new_sharedcolor(val, to_color_value(r, g, b, a));
    return Succeeded;
}

char *getbg(wbp w)
{
    return w->context->bg->name;
}

int setwindowicon(wbp w, struct imgdata *imd)
{
    return Succeeded;
}

int getwindowicon(wbp w, struct imgdata *imd)
{
    return Failed;
}

#passthru #undef fillarc
#passthru #define fillarc oi_fillarc        

void fillarc(wbp w, double cx, double cy, double rx, double ry, double angle1, double angle2)
{
    int alpha, phi, x, y, width, height;
    wsp ws = w->window;
    wcp wc = w->context;
    clip(w);
    alpha = -angle1 * 180 / Pi;
    phi = -angle2 * 180 / Pi;
    x = cx - rx - 1;
    y = cy -ry - 1;
    width = 2 * rx + 2;
    height = 2 * ry + 2;
    fillarcop(ws->pix,
              Pt(cx, cy),
              rx, ry,
              get_draw_img(wc),
              Pt(cx, cy),
              alpha, phi,
              wc->drawop->i);
    pix_to_win(ws, x, y, width, height);
    flushimage(display, 1);
}

static Image *get_draw_img(wcp wc)
{
    if (wc->pattern)
        return wc->pattern->i;
    else
        return wc->fg->i;
}

void fillrectangle(wbp w, int x, int y, int width, int height)
{
    wsp ws = w->window;
    wcp wc = w->context;
    clip(w);
    fill2(w, wc->drawop->i, get_draw_img(wc), x, y, width, height);
    flushimage(display, 1);
}

static char *convert_spec(char *s)
{
    struct FontInfo *fi;

    if (!strncmp(s, "p9:", 3))
        return s + 3;

    fi = match_font(s);
    if (fi)
        return fi->path;
    else
        return 0;
}

static wfp load_font(char *s)
{
    wfp rv;
    int i;
    Font *f;

    /*
     * Convert to a font path name (without the p9: prefix)
     */
    s = convert_spec(s);
    if (!s)
        return 0;

    /*
     * See if the font is already loaded.
     */
    i = hasher(hashcstr(s), fonts);
    for(rv = fonts[i]; rv; rv = rv->next) {
        if (!strcmp(s, rv->name + 3))
            return rv;
    }

    f = openfont(display, s);
    if (!f)
        return 0;

    rv = rt_zalloc(sizeof(struct _wfont));
    rv->name = rt_malloc(strlen(s) + 3 + 1);
    sprint(rv->name, "p9:%s", s);
    rv->ascent = f->ascent;               /* font dimensions */
    rv->descent = f->height - f->ascent;
    rv->maxwidth = f->width;               /* max width of one char */
    rv->font = f;
    rv->next = fonts[i];
    fonts[i] = rv;
    return rv;
}

int setfont(wbp w, char *s)
{
    wfp f = load_font(s);
    if (!f)
        return Failed;
    w->context->font = f;
    return Succeeded;
}

int lowerwindow (wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    if (fprint(ws->wctl_fd, "bottom") < 0) {
        whyf("Can't lower window: %r");
        return Failed;
    }
    return Succeeded;
}

int setpattern(wbp w, struct imgdata *imd)
{
    wcp wc = w->context;
    if (wc->pattern)
        unlink_sharedimage(wc->pattern);
    if (imd)
        wc->pattern = new_sharedimage(imd);
    else
        wc->pattern = 0;
    return Succeeded;
}

int getpattern(wbp w, struct imgdata *imd)
{
    int len;
    Image *im;
    uchar *data;
    wcp wc = w->context;
    if (!wc->pattern)
        return Failed;
    im = wc->pattern->i;
    imd->width = Dx(im->r);
    imd->height = Dy(im->r);
    len = imd->width * imd->height * 4;
    data = rt_malloc(len);
    unloadimage(im, im->r, data, len);
    imd->format = &imgdataformat_P9ABGR32;
    imd->data = data;
    return Succeeded;
}

void captureimgdata(wbp w, int x, int y, struct imgdata *imd)
{
    Image *im;
    int len;
    uchar *data;
    wsp ws = w->window;
    /* Allocate a temp win to hold the rectangle we want */
    MemProtect(im = allocimage(display, Rect(0, 0, imd->width, imd->height), RGBA32, 1, DNofill));
    len = imd->width * imd->height * 4;
    data = rt_malloc(len);
    /* Copy from pix to the tmp win */
    gendrawop(im, im->r, ws->pix, Pt(x, y), 0, ZP, S);
    /* Get the pixels from the temp win, and then free it */
    unloadimage(im, im->r, data, len);
    freeimage(im);
    imd->format = &imgdataformat_P9ABGR32;
    imd->data = data;
}

static Image *imgdata_to_Image1(struct imgdata *imd)
{
    Image *im;
    int len;
    MemProtect(im = allocimage(display, Rect(0, 0, imd->width, imd->height), RGBA32, 1, DNofill));
    len = imd->width * imd->height * 4;
    loadimage(im, im->r, imd->data, len);
    return im;
}

static Image *imgdata_to_Image(struct imgdata *imd)
{
    struct imgdata *tmp;
    Image *im;
    if (imd->format == &imgdataformat_P9ABGR32)
        return imgdata_to_Image1(imd);
    tmp = initimgdata(imd->width, imd->height, &imgdataformat_P9ABGR32);
    copyimgdata(tmp, imd);
    im = imgdata_to_Image1(tmp);
    unlinkimgdata(tmp);
    return im;
}

void drawimgdata(wbp w, int x, int y, struct imgdata *imd)
{
    wcp wc = w->context;
    wsp ws = w->window;
    Image *im;
    /* Allocate a temp win to represent the imgdata */
    im = imgdata_to_Image(imd);
    /* Copy tmp image back to screen */
    clip(w);
    gendrawop(ws->pix,
              MkRect(x, y, imd->width, imd->height),
              im, ZP, 
              0, ZP, 
              wc->drawop->i);
    pix_to_win(ws, x, y, imd->width, imd->height);
    freeimage(im);
    flushimage(display, 1);
}

struct imgdataformat *getimgdataformat(wbp w)
{
    return &imgdataformat_P9ABGR32;
}

int queryrootpointer(wbp w, int *x, int *y)
{
    int mx, my, sx, sy;
    wsp ws = w->window;
    CheckUnhidden(ws);
    if (read_screeninfo(ws, &mx, &my, &sx, &sy, 0,0) != Succeeded) {
        LitWhy("Failed to read screeninfo file");
        return Failed;
    }
    *x = mx - sx;
    *y = my - sy;
    return Succeeded;
}

int raisewindow(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    if (fprint(ws->wctl_fd, "top") < 0) {
        whyf("Can't raise window: %r");
        return Failed;
    }
    return Succeeded;
}

int focuswindow(wbp w)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    if (fprint(ws->wctl_fd, "current") < 0) {
        whyf("Can't focus window: %r");
        return Failed;
    }
    return Succeeded;
}

int textwidth(wbp w, dptr str)
{
    wcp wc = w->context;
    if (is:string(*str))
        return stringnwidth(wc->font->font, StrLoc(*str), StrLen(*str));
    else {
        int width;
        Rune *r = utf8_to_runes(str);
        width = runestringnwidth(wc->font->font, r, UcsBlk(*str).length);
        free(r);
        return width;
    }
}

void doconfig(wbp w, int status)
{
    wsp ws = w->window;

    /* Move/resize of window if open */
    if (ws->win) {
        if ((status & (C_POS | C_SIZE)) == C_POS) {
            /* Only need a 'move' if doing pos without size; if doing
             * both pos can be done in a 'resize' */
            fprint(ws->wctl_fd, "move -minx %d -miny %d", ws->reqx, ws->reqy);
            status &= ~C_POS;
        }
        if (status & (C_POS | C_SIZE | C_MINSIZE | C_MAXSIZE | C_RESIZE)) {
            char buf[256];
            strcpy(buf, "resize");
            if (status & C_POS)
                sprintf(buf + strlen(buf), " -minx %d -miny %d", ws->reqx, ws->reqy);
            if (status & C_SIZE)
                sprintf(buf + strlen(buf), " -dx %d -dy %d", adjust(ws, ws->width), adjust(ws, ws->height));
            if (status != C_POS) {
                int minw, maxw, minh, maxh;
                if (ws->resizable) {
                    minw = ws->minwidth;
                    minh = ws->minheight;
                    maxw = ws->maxwidth;
                    maxh = ws->maxheight;
                }
                else {
                    minw = maxw = ws->width;
                    minh = maxh = ws->height;
                }
                sprintf(buf + strlen(buf), " -mindx %d -maxdx %d -mindy %d -maxdy %d", 
                        adjust(ws, minw),
                        adjust(ws, maxw),
                        adjust(ws, minh),
                        adjust(ws, maxh));
            }
            write(ws->wctl_fd, buf, strlen(buf));
        }
    }
    if (status & C_SIZE)
        resize_pix_win(w);
}

int ownselection(wbp w, char *selection)
{
    wsp ws = w->window;
    tended struct descrip tmp;

    CheckUnhidden(ws);

    /* Ignore anything other than CLIPBOARD selections. */
    if (strcmp(selection, "CLIPBOARD") == 0) {
        MakeInt(SELECTIONREQUEST, &tmp);
        list_put(&ws->listp, &tmp);
        list_put(&ws->listp, &zerodesc);/* req id */
        LitStr("none", &tmp);           /* property */
        list_put(&ws->listp, &tmp);
        cstr2string(selection, &tmp);   /* selection */
        list_put(&ws->listp, &tmp);
        LitStr("UTF8_STRING", &tmp);    /* type */
        list_put(&ws->listp, &tmp);
        list_put(&ws->listp, &zerodesc); /* time */
    }
    return Succeeded;
}

int requestselection(wbp w, char *selection, char *target)
{
    wsp ws = w->window;
    tended struct descrip tmp;
    int snarf_len = 0;
    char *snarf = 0;

    CheckUnhidden(ws);

    if (strcmp(selection, "CLIPBOARD") == 0 &&
        strcmp(target, "UTF8_STRING") == 0) {
        int fd, n_read;
        char buff[512];
        if ((fd = open_winfile(ws, "snarf", OREAD)) < 0) {
            whyf("Can't open snarf file: %r");
            return Failed;
        }
        while ((n_read = read(fd, buff, sizeof buff)) > 0) {
            snarf = rt_realloc(snarf, snarf_len + n_read);
            memcpy(snarf + snarf_len, buff, n_read);
            snarf_len += n_read;
        }
        close(fd);
    }

    MakeInt(SELECTIONRESPONSE, &tmp);
    list_put(&ws->listp, &tmp);
    cstr2string(selection, &tmp);   /* selection */
    list_put(&ws->listp, &tmp);
    cstr2string(target, &tmp);      /* target */
    list_put(&ws->listp, &tmp);
    if (snarf) {
        bytes2string(snarf, snarf_len, &tmp);
        list_put(&ws->listp, &tmp);
        free(snarf);
    } else
        list_put(&ws->listp, &nulldesc);

    return Succeeded;
}

int sendselectionresponse(wbp w, word requestor, char *property, 
                          char *selection, char *target, word time, dptr data)
{
    wsp ws = w->window;
    int fd;

    CheckUnhidden(ws);

    /* data is &null if the selection doesn't support what we asked for (UTF8_STRING) */
    if (is:null(*data))
        return Succeeded;

    if (!cnv:string(*data, *data))
        ReturnErrVal(103, *data, Error);

    if ((fd = open_winfile(ws, "snarf", OWRITE)) < 0) {
        whyf("Can't open snarf file: %r");
        return Failed;
    }
    /*print("setting snarf to %.*s\n",StrLen(*data),StrLoc(*data));*/
    write(fd, StrLoc(*data), StrLen(*data));
    close(fd);
    return Succeeded;
}

static int open_screen_win(wsp ws)
{
    char buff[256];
    int fd, n, pid;
    int minw, maxw, minh, maxh;

    if (ws->resizable) {
        minw = ws->minwidth;
        minh = ws->minheight;
        maxw = ws->maxwidth;
        maxh = ws->maxheight;
    }
    else {
        minw = maxw = ws->width;
        minh = maxh = ws->height;
    }

    ws->using_win = use_win;
    if (ws->using_win) {
        strcpy(ws->mount_dir, display->windir);

        if ((ws->wctl_fd = open_winfile(ws, "wctl", OWRITE)) < 0) {
            whyf("Can't open wctl file: %r");
            close_screen_win(ws);
            return Failed;
        }

        /* See if the window has a border or not, and set the border width accordingly. */
        buff[0] = 0;
        if ((fd = open_winfile(ws, "winname", OREAD)) >= 0) {
            n = read(fd, buff, sizeof(buff) - 1);
            if (n > 0)
                buff[n] = 0;
            close(fd);
        }
        if (strncmp(buff, "noborder", 8) == 0) {
            ws->border_width = 0;
            ws->state = PopupCanvas;
        } else {
            ws->border_width = 2 * Borderwidth;
            if (ws->state == PopupCanvas)
                ws->state = NormalCanvas;
        }

        /* OIUSEWIN=1 -> set size and pos of enclosing window 
         *          2 -> just set pos of enclosing window 
         *          3 -> just size
         *          4 -> set neither size or pos
         * max/min window sizes are set in any case.
         */
        switch (ws->using_win) {
            case 1: {
                if (ws->reqx != -INT_MAX && ws->reqy != -INT_MAX)
                    fprint(ws->wctl_fd, "resize -minx %d -miny %d -dx %d -dy %d -mindx %d -maxdx %d -mindy %d -maxdy %d", 
                           ws->reqx, ws->reqy,
                           adjust(ws, ws->width), 
                           adjust(ws, ws->height),
                           adjust(ws, minw),
                           adjust(ws, maxw),
                           adjust(ws, minh),
                           adjust(ws, maxh));
                else
                    fprint(ws->wctl_fd, "resize -dx %d -dy %d -mindx %d -maxdx %d -mindy %d -maxdy %d", 
                           adjust(ws, ws->width), 
                           adjust(ws, ws->height),
                           adjust(ws, minw),
                           adjust(ws, maxw),
                           adjust(ws, minh),
                           adjust(ws, maxh));
                break;
            }
            case 2: {
                if (ws->reqx != -INT_MAX && ws->reqy != -INT_MAX)
                    fprint(ws->wctl_fd, "move -minx %d -miny %d", ws->reqx, ws->reqy);
                fprint(ws->wctl_fd, "resize -mindx %d -maxdx %d -mindy %d -maxdy %d", 
                       adjust(ws, minw),
                       adjust(ws, maxw),
                       adjust(ws, minh),
                       adjust(ws, maxh));
                break;
            }
            case 3: {
                fprint(ws->wctl_fd, "resize -dx %d -dy %d -mindx %d -maxdx %d -mindy %d -maxdy %d", 
                       adjust(ws, ws->width), 
                       adjust(ws, ws->height),
                       adjust(ws, minw),
                       adjust(ws, maxw),
                       adjust(ws, minh),
                       adjust(ws, maxh));
                break;
            }
            case 4: {
                fprint(ws->wctl_fd, "resize -mindx %d -maxdx %d -mindy %d -maxdy %d", 
                       adjust(ws, minw),
                       adjust(ws, maxw),
                       adjust(ws, minh),
                       adjust(ws, maxh));
                break;
            }
        }

        if (ws->state == IconicCanvas)
            fprint(ws->wctl_fd, "hide");
        else if (ws->state != PopupCanvas)
            fprint(ws->wctl_fd, "unhide");

        use_win = 0;
    } else {
        ws->wsys_fd = open(ws->wsys, ORDWR|OCEXEC);
        if (ws->wsys_fd < 0) {
            whyf("Can't open $wsys(%s): %r", ws->wsys);
            close_screen_win(ws);
            return Failed;
        }
        sprintf(ws->mount_dir, "/n/oix-win.%d.%d", getpid(), ++window_count);
        ws->border_width = (ws->state == PopupCanvas ? 0 : 2 * Borderwidth);
        /* If either x or y unset, let rio place the window */
        if (ws->reqx == -INT_MAX || ws->reqy == -INT_MAX)
            sprintf(buff, "new -dx %d -dy %d",
                    adjust(ws, ws->width), 
                    adjust(ws, ws->height));
        else
            sprintf(buff, "new -r %d %d %d %d",
                    ws->reqx, ws->reqy,  ws->reqx + adjust(ws, ws->width), 
                    ws->reqy + adjust(ws, ws->height));
        if (ws->state == PopupCanvas)
            strcat(buff, " -noborder -layer 1");
        else if (ws->state == IconicCanvas)
            strcat(buff, " -hide");
        sprintf(buff + strlen(buff), 
                " -mindx %d -maxdx %d -mindy %d -maxdy %d", 
                adjust(ws, minw),
                adjust(ws, maxw),
                adjust(ws, minh),
                adjust(ws, maxh));
        if (ws->transientfor && ws->transientfor->winid >= 0)
            sprintf(buff + strlen(buff), " -transientfor %d", ws->transientfor->winid);

        if (mount(ws->wsys_fd, -1, ws->mount_dir, MREPL, buff) < 0) {
            whyf("Can't mount new window: %r");
            close_screen_win(ws);
            return Failed;
        }
        if ((ws->wctl_fd = open_winfile(ws, "wctl", OWRITE)) < 0) {
            whyf("Can't open wctl file: %r");
            close_screen_win(ws);
            return Failed;
        }
    }

    /* Open mouse before gengetwindow so that we don't miss any
     * reshape events */
    if ((ws->mouse_fd = open_winfile(ws, "mouse", ORDWR)) < 0) {
        whyf("Can't open mouse file: %r");
        close_screen_win(ws);
        return Failed;
    }

    sprintf(buff, "%s/winname", ws->mount_dir);
    if (gengetwindow(display, buff, &ws->win, &ws->screen, Refnone) < 0) {
        whyf("gengetwindow failed: %r");
        close_screen_win(ws);
        return Failed;
    }
    GLink4(ws, vwstates, vnext, vprevious);

    if ((fd = open_winfile(ws, "winid", OREAD)) < 0) {
        whyf("Can't open winid file %r");
        close_screen_win(ws);
        return Failed;
    }
    if (read(fd, buff, 12) != 12) {
        whyf("Can't read winid file %r");
        close(fd);
        close_screen_win(ws);
        return Failed;
    }
    ws->winid = atoi(buff);
    close(fd);

    if ((ws->label_fd = open_winfile(ws, "label", ORDWR)) < 0) {
        whyf("Can't open label file %r");
        close_screen_win(ws);
        return Failed;
    }
    if (ws->using_win)
        /* Save label */
        pread(ws->label_fd, old_label, sizeof(old_label) - 1, 0);
    pwrite(ws->label_fd, 
           StrLoc(UcsBlk(ws->windowlabel).utf8), 
           StrLen(UcsBlk(ws->windowlabel).utf8), 0);

    if (pipe(ws->event_pipe) < 0) {
        whyf("Couldn't init event pipe: %r");
        close_screen_win(ws);
        return Failed;
    }
    ws->mouse_events = ws->cons_events = ws->events_read = 0;

    if ((ws->screeninfo_fd = open_winfile(ws, "screeninfo", OREAD)) < 0) {
        whyf("Can't open screeninfo file: %r");
        close_screen_win(ws);
        return Failed;
    }

    if ((ws->wininfo_fd = open_winfile(ws, "wininfo", OREAD)) < 0) {
        whyf("Can't open wininfo file: %r");
        close_screen_win(ws);
        return Failed;
    }

    if ((ws->cons_fd = open_winfile(ws, "cons", OREAD)) < 0) {
        whyf("Can't open cons file: %r");
        close_screen_win(ws);
        return Failed;
    }

    if ((ws->consctl_fd = open_winfile(ws, "consctl", OWRITE)) < 0) {
        whyf("Can't open consctl file: %r");
        close_screen_win(ws);
        return Failed;
    }
    write(ws->consctl_fd, "rawon", 5);

    if ((ws->cursor_fd = open_winfile(ws, "cursor", OWRITE)) < 0) {
        whyf("Can't open cursor file: %r");
        close_screen_win(ws);
        return Failed;
    }
    synch_cursor(ws);

    switch (pid = rfork(RFPROC|RFMEM)) {
        case 0: {
            mouse_loop(ws);
            break;
        }
        case -1: {
            whyf("rfork failed: %r");
            close_screen_win(ws);
            return Failed;
        }
    }
    ws->mouse_pid = pid;

    switch (pid = rfork(RFPROC|RFMEM)) {
        case 0: {
            cons_loop(ws);
            break;
        }
        case -1: {
            whyf("rfork failed: %r");
            close_screen_win(ws);
            return Failed;
        }
    }
    ws->cons_pid = pid;

    handle_reshape1(ws);
    return Succeeded;
}

static Image *any_other_win(Image *win)
{
    wsp ws;
    for (ws = vwstates; ws; ws = ws->vnext)
        if (ws->win && ws->win != win)
            return ws->win;
    return 0;
}

static void close_screen_win(wsp ws)
{
    if (ws->using_win) {
        /* Reset old label */
        if (ws->label_fd >= 0)
            pwrite(ws->label_fd, old_label, strlen(old_label), 0);
        /* Clear any size limits */
        if (ws->wctl_fd >= 0)
            fprint(ws->wctl_fd, "resize -mindx 1 -maxdx %d -mindy 1 -maxdy %d", INT_MAX, INT_MAX);
    } else
        unmount(0, ws->mount_dir);

    if (ws->mouse_pid >= 0)
        kill_proc(ws->mouse_pid);
    if (ws->cons_pid >= 0)
        kill_proc(ws->cons_pid);
    if (ws->event_pipe[0] >= 0)
        close(ws->event_pipe[0]);
    if (ws->event_pipe[1] >= 0)
        close(ws->event_pipe[1]);
    if (ws->consctl_fd >= 0)
        close(ws->consctl_fd);
    if (ws->cursor_fd >= 0)
        close(ws->cursor_fd);
    if (ws->label_fd >= 0)
        close(ws->label_fd);
    if (ws->screeninfo_fd >= 0)
        close(ws->screeninfo_fd);
    if (ws->wininfo_fd >= 0)
        close(ws->wininfo_fd);
    if (ws->wsys_fd >= 0)
        close(ws->wsys_fd);
    /* 
     * See the source for gengetwindow for the sequence of
     * freeing the bits of the images/screens.
     */
    if (ws->win) {
        /* Avoid reference to freed window remaining in display structure (although it doesn't
         * seem to be used).
         */
        if (ws->win == display->screenimage)
            display->screenimage = any_other_win(ws->win);
        freeimage(ws->win);
        ws->win = 0;
        GUnlink4(ws, vwstates, vnext, vprevious);
    }
    if (ws->screen) {
        freeimage(ws->screen->image);
        freescreen(ws->screen);
        ws->screen = 0;
    }
    /*
     * If ws->using_win, then closing the mouse fd causes riox to
     * issue a refresh to the underlying window, restoring the
     * original contents.
     */
    if (ws->mouse_fd >= 0)
        close(ws->mouse_fd);
    if (ws->cons_fd >= 0)
        close(ws->cons_fd);
    if (ws->wctl_fd >= 0)
        close(ws->wctl_fd);

    ws->using_win = 0;
    ws->mount_dir[0] = 0;
    ws->event_pipe[0] = ws->event_pipe[1] = ws->mouse_fd = ws->cons_fd = ws->consctl_fd =
        ws->screeninfo_fd = ws->cursor_fd = ws->label_fd = ws->mouse_pid = ws->cons_pid =
        ws->wininfo_fd = ws->wsys_fd = ws->wctl_fd = ws->winid = -1;
    ws->x = ws->y = -INT_MAX;
    synch_state(ws);
}

static void open_pix_win(wsp ws)
{
    MemProtect(ws->pix = allocimage(display, Rect(0, 0, ws->width, ws->height), RGBA32, 1, DNofill));
}

static void close_pix_win(wsp ws)
{
    if (ws->pix) {
        freeimage(ws->pix);
        ws->pix = 0;
    }
}

static void freewindow(wsp ws)
{
   ws->refcount--;
   if (ws->refcount == 0) {
       if (ws->win)
           close_screen_win(ws);
       close_pix_win(ws);
       free(ws->wsys);
       del_gc_global(&ws->listp);
       del_gc_global(&ws->windowlabel);
       if (ws->transientfor)
           freewindow(ws->transientfor);
       free(ws);
   }
}

static void freecontext(wcp wc)
{
    wc->refcount--;
    if (wc->refcount == 0) {
        unlink_sharedcolor(wc->fg);
        unlink_sharedcolor(wc->bg);
        if (wc->pattern)
            unlink_sharedimage(wc->pattern);
        free(wc);
    }
}

int setcanvas(wbp w, char *s)
{
    stringint *e;
    wsp ws = w->window;
    e = stringint_lookup(canvastypes, s);
    if (!e)
        return Failed;

    if (e->i == ws->state)
        return Succeeded;

    /*
     * If we're presently hidden, just open the visible window.
     */
    if (!ws->win) {
        if (e->i != HiddenCanvas) {
            ws->state = e->i;
            if (open_screen_win(ws) == Failed)
                return Failed;
        }
        return Succeeded;
    }

    /*
     * More complex cases, with the window already unhidden.
     */
    switch (e->i) {
        case HiddenCanvas: {
            close_screen_win(ws);
            break;
        }

        case IconicCanvas: {
            if (ws->state == PopupCanvas)
                return Failed;
            if (fprint(ws->wctl_fd, "hide") < 0) {
                whyf("Can't make iconic: %r");
                return Failed;
            }
            break;
        }

        case NormalCanvas: {
            if (ws->state == PopupCanvas)
                return Failed;
            if (fprint(ws->wctl_fd, "unhide") < 0) {
                whyf("Can't make normal: %r");
                return Failed;
            }
            break;
        }

        case PopupCanvas:
            return Failed;
    }
    return Succeeded;
}

int setwindowlabel(wbp w, dptr val)
{
    wsp ws = w->window;
    ws->windowlabel = *val;
    if (ws->win)
        pwrite(ws->label_fd, 
               StrLoc(UcsBlk(ws->windowlabel).utf8), 
               StrLen(UcsBlk(ws->windowlabel).utf8), 0);
    return Succeeded;
}

int setlinestyle(wbp w, char *val)
{
    stringint *e;
    wcp wc = w->context;
    e = stringint_lookup(linestyles, val);
    if (!e)
        return Failed;
    wc->linestyle = e;
    return Succeeded;
}

static int get_thick(wcp wc)
{
    return wc->linewidth / 2;
}

int setlinewidth(wbp w, double linewid)
{
    wcp wc = w->context;
    wc->linewidth = linewid;
    return Succeeded;
}

double getlinewidth(wbp w)
{
    return w->context->linewidth;
}

static void synch_cursor(wsp ws)
{
    struct Cursor *c;
    c = ws->cursor->shared_cursor->cursor;
    if (c)
        write(ws->cursor_fd, c, sizeof(struct Cursor));
    else
        write(ws->cursor_fd, "", 0);
}

int setpointer(wbp w, char *val)
{
    struct wcursor *c;
    wsp ws = w->window;
    c = lookup_wcursor(val);
    if (!c)
        return Failed;
    ws->cursor = c;
    if (ws->win)
        synch_cursor(ws);
    return Succeeded;
}

int setdrawop(wbp w, char *val)
{
    wcp wc = w->context;
    stringint *e = stringint_lookup(drawops, val);
    if (!e)
        return Failed;
    wc->drawop = e;
    return Succeeded;
}

int warppointer(wbp w, int x, int y)
{
    wsp ws = w->window;
    CheckUnhidden(ws);
    fprint(ws->mouse_fd, 
           "m%11d %11d %11d %11d ", 
           ws->win->r.min.x + x, 
           ws->win->r.min.y + y, 0, 0);
    return Succeeded;
}

char *getdisplay(wbp w)
{
    return w->window->wsys;
}

char *getlinestyle(wbp w)
{
    return w->context->linestyle->s;
}

static int read_screeninfo(wsp ws, int *mx, int *my, int *sx, int *sy, int *sw, int *sh)
{
    char buff[80];
    int n;
    n = pread(ws->screeninfo_fd, buff, 72, 0);
    if (n != 72)
        return Failed;
    if (mx)
        *mx = atoi(buff);
    if (my)
        *my = atoi(buff + 12);
    if (sx)
        *sx = atoi(buff + 24);
    if (sy)
        *sy = atoi(buff + 36);
    if (sw)
        *sw = atoi(buff + 48);
    if (sh)
        *sh = atoi(buff + 60);
    return Succeeded;
}

int querypointer(wbp w, int *x, int *y)
{
    int mx, my;
    wsp ws = w->window;
    CheckUnhidden(ws);
    if (read_screeninfo(ws, &mx, &my, 0,0,0,0) != Succeeded) {
        LitWhy("Failed to read screeninfo file");
        return Failed;
    }
    *x = mx - ws->win->r.min.x;
    *y = my - ws->win->r.min.y;
    return Succeeded;
}

char *getpointer(wbp w)
{
    return w->window->cursor->name;
}

char *getdrawop(wbp w)
{
    return w->context->drawop->s;
}

int settransientfor(wbp w, wbp other)
{
    wsp ws = w->window;
    if (ws->win) {
        LitWhy("Can't set transient_for on an open window");
        return Failed;
    }
    if (other) {
        if (ws->transientfor)
            freewindow(ws->transientfor);
        ws->transientfor = linkwindow(other->window);
    } else {
        if (ws->transientfor)
            freewindow(ws->transientfor);
        ws->transientfor = 0;
    }
    return Succeeded;
}

char *getcanvas(wbp w)
{
    char *v = stringint_int2str(canvastypes, w->window->state);
    if (!v)
        syserr("Invalid value of state");
    return v;
}

static void synch_state(wsp ws)
{
    int t;

    if (!ws->win) {
        ws->state = HiddenCanvas;
        return;
    }

    if (ws->state == PopupCanvas)
        return;

    t = ws->state;
    synch_state1(ws);
    if (t != ws->state)
        qeventcode(ws, WINDOWSTATE);
}

static void synch_state1(wsp ws)
{
    char buf[256];
    int n;
    if ((n = pread(ws->wininfo_fd, buf, sizeof(buf) - 1, 0)) <= 0)
        return;
    buf[n] = 0;
    ws->state = strstr(buf, "hidden") ? IconicCanvas:NormalCanvas;
}

int getdisplaysize(wbp w, int *width, int *height)
{
    Rectangle r;
    wsp ws = w->window;
    CheckUnhidden(ws);
    if (read_screeninfo(ws, 0,0, &r.min.x, &r.min.y, &r.max.x, &r.max.y) != Succeeded) {
        LitWhy("Failed to read screeninfo file");
        return Failed;
    }
    *width = Dx(r);
    *height = Dy(r);
    return Succeeded;
}

int getdisplaysizemm(wbp w, int *width, int *height)
{
    LitWhy("Display size unknown");
    return Failed;
}

int getdepth(wbp w, int *res)
{
    *res = w->window->pix->depth;
    return Succeeded;
}

static wcp clonecontext(wcp src)
{
    wcp wc;
    GAlloc(wc, _wcontext);
    wc->dx = src->dx;
    wc->dy = src->dy;
    wc->leading = src->leading;
    wc->clipx = src->clipx;
    wc->clipy = src->clipy;
    wc->clipw = src->clipw;
    wc->cliph = src->cliph;
    wc->fg = link_sharedcolor(src->fg);
    wc->bg = link_sharedcolor(src->bg);
    if (src->pattern)
        wc->pattern = link_sharedimage(src->pattern);
    wc->font = src->font;
    wc->linewidth = src->linewidth;
    wc->drawop = src->drawop;
    wc->linestyle = src->linestyle;
    return wc;
}

static int black_pattern_data[] =  {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

static void close_window_system(void)
{
    wsp ws;
    /* Close all screen windows */
    ws = vwstates;
    while (ws) {
        wsp t = ws->vnext;
        close_screen_win(ws);
        ws = t;
    }
    closedisplay(display);
}

static void init_window_system(void)
{
    int win_nameg = 1;

    env_int("OIUSEWIN", &use_win, 0, 4);
    env_int("OIWINNAMEG", &win_nameg, 0, 1);

    load_font_info();
    setup_cursors();

    if (win_nameg) {
        /* Keep mounts private */
        rfork(RFNAMEG);
    }

    if ((display = initdisplay(0, 0, draw_error)) == nil)
        ffatalerr("Couldn't initialize display: %r");

    black = new_sharedcolor("black", 0x000000ff);
    white = new_sharedcolor("white", 0xffffffff);
    max_rect = Rect(-1073741823, -1073741823, 1073741823, 1073741823);
    default_font = load_font(defaultfont);
    if (!default_font)
        ffatalerr("Couldn't load default font");

    memimageinit();

    atexit(close_window_system);
}

static void note_time(char *s)
{
    static vlong prev;
    if (prev) {
        int t = (nsec() - prev) / 1000000;
        fprint(2, "%d: - %s\n", t, s);
    }
    prev = nsec();
}

static int readimageimpl(char *cmd, int fd, struct imgdata *imd)
{
    Memimage *m;
    int pid, pip[2], ndata;
    struct imgdataformat  *format;
    if (pipe(pip) < 0) {
        whyf("Couldn't make pipe: %r");
        return Failed;
    }
    switch (pid = fork()) {
        case -1: {
            whyf("Couldn't fork: %r");
            close(pip[0]);
            close(pip[1]);
            return Failed;
        }
        case 0: {
            int nf;
            dup(fd, 0);
            dup(pip[0], 1);
            if ((nf = open("/dev/null", OWRITE)) >= 0) {
                dup(nf, 2);
                close(nf);
            }
            close(fd);
            close(pip[0]);
            close(pip[1]);
            execl("/bin/rc", "rc", "-c", cmd, 0);
            _exits(0);
        }
    }

    close(pip[0]);
    m = readmemimage(pip[1]);
    close(pip[1]);
    free(waitforpid(pid));

    if (!m) {
        whyf("Failed to readmemimage on file: %r");
        return Failed;
    }
    switch (m->chan) {
        case RGB24: {
            format = &imgdataformat_BGR24;
            break;
        }
        case RGBA32: {
            format = &imgdataformat_P9ABGR32;
            break;
        }
        case GREY8: {
            format = &imgdataformat_G8;
            break;
        }
        case CHAN2(CGrey, 8, CAlpha, 8): {
            format = &imgdataformat_P9AG16;
            break;
        }
        default: {
            char buf[10];
            chantostr(buf,m->chan);
            whyf("Unknown channel format %s from command %s", buf, cmd);
            freememimage(m);
            return Failed;
        }
    }
    imd->width = Dx(m->r);
    imd->height = Dy(m->r);
    imd->format = format;
    ndata = imd->width * imd->height * m->nchan;
    imd->data = rt_malloc(ndata);
    unloadmemimage(m, m->r, imd->data, ndata);
    freememimage(m);
    return Succeeded;
}

int readimagefileimpl(char *filename, struct imgdata *imd)
{
    int fd, r;
    char *cmd;
    struct fileparts *fp = fparse(filename);
    if (strcasecmp(fp->ext, ".png") == 0)
        cmd = "png -9 -3";
    else if (strcasecmp(fp->ext, ".jpg") == 0 || strcasecmp(fp->ext, ".jpeg") == 0)
        cmd = "jpg -9 -3";
    else if (strcasecmp(fp->ext, ".ppm") == 0)
        cmd = "ppm -9 -3";
    else
        return NoCvt;
    if ((fd = open(filename, OREAD)) < 0) {
        whyf("Couldn't open %s: %r", filename);
        return Failed;
    }
    r = readimageimpl(cmd, fd, imd);
    close(fd);
    return r;
}

int readimagedataimpl(dptr data, struct imgdata *imd)
{
    int pid, pip[2], r;
    char *cmd;
    if (is_png(data))
        cmd = "png -9 -3";
    else if (is_jpeg(data))
        cmd = "jpg -9 -3";
    else
        return NoCvt;
    if (pipe(pip) < 0) {
        whyf("Couldn't make pipe: %r");
        return Failed;
    }
    switch (pid = fork()) {
        case -1: {
            whyf("Couldn't fork: %r");
            close(pip[0]);
            close(pip[1]);
            return Failed;
        }
        case 0: {
            close(pip[1]);
            write(pip[0], StrLoc(*data), StrLen(*data));
            close(pip[0]);
            _exits(0);
        }
    }
    close(pip[0]);
    r = readimageimpl(cmd, pip[1], imd);
    close(pip[1]);
    free(waitforpid(pid));
    return r;
}

int writeimagefileimpl(char *filename, struct imgdata *imd)
{
    Memimage *m;
    Waitmsg *w;
    int pip[2], pid, fd, ndata, i, j;
    char *cmd;
    uchar *data, *p;
    struct fileparts *fp = fparse(filename);

    if (strcasecmp(fp->ext, ".png") == 0)
        cmd = "topng";
    else if (strcasecmp(fp->ext, ".gif") == 0)
        cmd = "togif";
    else if (strcasecmp(fp->ext, ".ppm") == 0)
        cmd = "toppm";
    else if (strcasecmp(fp->ext, ".ico") == 0)
        cmd = "toico";
    else
        return NoCvt;

    if ((fd = create(filename, OWRITE, 0777)) < 0) {
        whyf("Couldn't open %s: %r", filename);
        return Failed;
    }
    if (pipe(pip) < 0) {
        whyf("Couldn't make pipe: %r");
        close(fd);
        return Failed;
    }

    /* Transparency only works for png (not gifs it seems) */
    if (!imd->format->alpha_depth || strcmp(cmd, "topng") != 0) {
        ndata = 3 * imd->width * imd->height;
        data = rt_malloc(ndata);
        p = data;
        for (j = 0; j < imd->height; j++) {
            for (i = 0; i < imd->width; i++) {
                int r, g, b, a;
                imd->format->getpixel(imd, i, j, &r, &g, &b, &a);
                *p++ = b / 256;
                *p++ = g / 256;
                *p++ = r / 256;
            }
        }
        MemProtect(m = allocmemimage(Rect(0, 0, imd->width, imd->height), RGB24));
    } else {
        ndata = 4 * imd->width * imd->height;
        data = rt_malloc(ndata);
        p = data;
        for (j = 0; j < imd->height; j++) {
            for (i = 0; i < imd->width; i++) {
                int r, g, b, a;
                imd->format->getpixel(imd, i, j, &r, &g, &b, &a);
                *p++ = Mul16(r, a) / 256;
                *p++ = Mul16(g, a) / 256;
                *p++ = Mul16(b, a) / 256;
                *p++ = a / 256;
            }
        }
        MemProtect(m = allocmemimage(Rect(0, 0, imd->width, imd->height), RGBA32));
    }
    loadmemimage(m, m->r, data, ndata);
    free(data);

    switch (pid = fork()) {
        case -1: {
            whyf("Couldn't fork: %r");
            freememimage(m);
            close(fd);
            close(pip[0]);
            close(pip[1]);
            return Failed;
        }
        case 0: {
            dup(pip[0], 0);
            dup(fd, 1);
            close(fd);
            close(pip[0]);
            close(pip[1]);
            execl("/bin/rc", "rc", "-c", cmd, 0);
            _exits(0);
        }
    }
    close(pip[0]);
    close(fd);
    writememimage(pip[1], m);
    w = waitforpid(pid);
    close(pip[1]);
    freememimage(m);
    if (w && w->msg[0] == 0) {
        free(w);
        return Succeeded;
    } else {
        if (w) {
            whyf("Image writer failed: %s", w->msg);
            free(w);
        } else
            LitWhy("Child process not found");
        remove(filename);
        return Failed;
    }
}

void registerplatformimgdataformats()
{
    registerimgdataformat(&imgdataformat_P9ABGR32);
    registerimgdataformat(&imgdataformat_P9AG16);
}

static int acceptable_font(struct FontInfo *fi, char *family, int flags, double size)
{
    if (strcmp(fi->family, family) != 0)
        return 0;
    if ((fi->flags & flags) != flags)
        return 0;
    return 1;
}

#define PREFER(f) \
do { \
    if ((f1->flags & (f)) && !(f2->flags & (f))) \
        return f1; \
    if (!(f1->flags & (f)) && (f2->flags & (f))) \
        return f2; \
} while(0)

static struct FontInfo *best_font(struct FontInfo *f1, struct FontInfo *f2, int flags, double size)
{
    double n;

    PREFER(FONTFLAG_ROMAN);
    PREFER(FONTFLAG_MEDIUM);
    PREFER(FONTFLAG_NORMAL);

    n = fabs(f1->size - size) - fabs(f2->size - size);
    if (n > 0)
        return f2;
    if (n < 0)
        return f1;

    return f1;
}

static struct FontInfo *match_font(char *s)
{
    int flags;
    double size;
    char family[MAXFONTWORD];
    struct FontInfo *best = 0, *curr;

    if (!parsefont(s, family, &flags, &size))
        return 0;

    for (curr = font_info; curr; curr = curr->next) {
        if (acceptable_font(curr, family, flags, size)) {
            if (!best)
                best = curr;
            else
                best = best_font(best, curr, flags, size);
        }
    }
    /*
    if (best)
        print("matched %s -> %s(family=%s,flags=%d,size=%d)\n",s,best->path,best->family,best->flags,best->size);
    */
    return best;
}

static void load_font_info(void)
{
    int fd, i, flag = 0, line = 1;
    char ch, buff[512], *info = 0;
    struct FontInfo *tail = 0;
    char *fn;

    fn = getenv("OI_FONTINFO");
    if (!fn)
        ffatalerr("OI_FONTINFO environment variable not set");

    if ((fd = open(fn, OREAD)) < 0)
        ffatalerr("Can't open font info file: %r");

    i = 0;
    while (read(fd, &ch, 1) > 0) {
        if (i >= sizeof(buff))
            ffatalerr("Line %d too long in font info file %s", line, fn);

        if (flag) {
            if (ch == '\n') {
                buff[i] = 0;
                /* Ignore blank lines and commented lines */
                if (buff[0] == 0 || buff[0] != '#') {
                    char family[MAXFONTWORD];
                    int flags;
                    double size;
                    struct FontInfo *fi;
                    if (!parsefont(info, family, &flags, &size))
                        ffatalerr("Couldn't parse line %d in font info file %s", line, fn);
                    if (access(buff, R_OK) == 0) {
                        fi = rt_malloc(sizeof(struct FontInfo));
                        fi->path = salloc(buff);
                        fi->family = salloc(family);
                        fi->flags = flags;
                        fi->size = size;
                        fi->next = 0;
                        if (tail) {
                            tail->next = fi;
                            tail = fi;
                        } else
                            font_info = tail = fi;
                    }
                }
                ++line;
                i = 0;
                info = 0;
                flag = 0;
            } else
                buff[i++] = ch;
        } else {
            if (ch == '=') {
                buff[i++] = 0;
                flag = 1;
                info = buff + i;
            } else
                buff[i++] = ch;
        }
    }
    close(fd);
}

static void set_P9ABGR32(struct imgdata *imd, int x, int y, int r, int g, int b, int a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    b = Mul16(b, a);
    g = Mul16(g, a);
    r = Mul16(r, a);
    *s++ = a / 256;
    *s++ = b / 256;
    *s++ = g / 256;
    *s++ = r / 256;
}

static void get_P9ABGR32(struct imgdata *imd, int x, int y, int *r, int *g, int *b, int *a)
{
    int n = imd->width * y + x;
    unsigned char *s = imd->data + 4 * n;
    *a = 257 * (*s++);
    *b = 257 * (*s++);
    *g = 257 * (*s++);
    *r = 257 * (*s++);
    if (*a > 0) {
        *b = Div16(*b, *a);
        *g = Div16(*g, *a);
        *r = Div16(*r, *a);
    }
}

static void set_P9AG16(struct imgdata *imd, int x, int y, int r, int g, int b, int a)
{
    int gr, n = imd->width * y + x;
    unsigned char *s = imd->data + 2 * n;
    gr = Gray(r, g, b);
    gr = Mul16(gr, a);
    *s++ = a / 256;
    *s++ = gr / 256;
}

static void get_P9AG16(struct imgdata *imd, int x, int y, int *r, int *g, int *b, int *a)
{
    int gr, n = imd->width * y + x;
    unsigned char *s = imd->data + 2 * n;
    *a = 257 * (*s++);
    gr = 257 * (*s);
    if (*a > 0)
        *r = *g = *b = Div16(gr, *a);
    else
        *r = *g = *b = gr;
}

static struct imgdataformat imgdataformat_P9ABGR32 =   {set_P9ABGR32,get_P9ABGR32,0,0,getlength_32,8,24,0,"P9ABGR32"};
static struct imgdataformat imgdataformat_P9AG16 =   {set_P9AG16,get_P9AG16,0,0,getlength_16,8,8,0,"P9AG16"};

int definepointer(wbp w, char *name, int x, int y)
{
    struct wcursor *rv;
    rv = ensure_wcursor(name);
    if (rv->shared_cursor) {
        unlink_sharedcursor(rv->shared_cursor);
        rv->shared_cursor = link_sharedcursor(null_cursor);
        synch_cursors(rv);
    } else
        rv->shared_cursor = link_sharedcursor(null_cursor);
    return Succeeded;
}

int copypointer(wbp w, char *dest, char *src)
{
    struct wcursor *sc, *dc;
    sc = lookup_wcursor(src);
    if (!sc)
        return Failed;
    dc = ensure_wcursor(dest);
    if (sc != dc) {
        if (dc->shared_cursor) {
            unlink_sharedcursor(dc->shared_cursor);
            dc->shared_cursor = link_sharedcursor(sc->shared_cursor);
            synch_cursors(dc);
        } else
            dc->shared_cursor = link_sharedcursor(sc->shared_cursor);
    }
    return Succeeded;
}

static void synch_cursors(struct wcursor *c)
{
    wsp x;
    for (x = vwstates; x; x = x->vnext) {
        if (x->cursor == c)
            synch_cursor(x);
    }
}

static void setup_cursor(char *name, struct Cursor *c)
{
    int i;
    struct wcursor *rv;
    struct Cursor *c2;
    i = hasher(hashcstr(name), cursors);
    rv = rt_zalloc(sizeof(struct wcursor));
    rv->name = name;
    if (c) {
        c2 = rt_malloc(sizeof(struct Cursor));
        memcpy(c2, c, sizeof(struct Cursor));
        rv->shared_cursor = new_sharedcursor(c2);
    } else
        rv->shared_cursor = link_sharedcursor(null_cursor);
    rv->next = cursors[i];
    cursors[i] = rv;
}

#begdef LoadCursor(f, s)
    {
        struct Cursor t =
    #include f
            setup_cursor(s, &t);
    }
#enddef

static void setup_cursors()
{
    null_cursor = new_sharedcursor(0);

    /* Plan9 ones */
    LoadCursor("p9cursors/bullseye", "bullseye");
    LoadCursor("p9cursors/crosscursor", "crosscursor");
    LoadCursor("p9cursors/boxcursor", "boxcursor");
    LoadCursor("p9cursors/sightcursor", "sightcursor");
    LoadCursor("p9cursors/whitearrow", "whitearrow");
    LoadCursor("p9cursors/query", "query");

    /* X11 ones */
    LoadCursor("p9cursors/x_cursor", "X cursor");
    LoadCursor("p9cursors/arrow", "arrow");
    setup_cursor("based arrow down", 0);
    setup_cursor("based arrow up", 0);
    setup_cursor("boat", 0);
    setup_cursor("bogosity", 0);
    LoadCursor("p9cursors/bottom_left_corner", "bottom left corner");
    LoadCursor("p9cursors/bottom_right_corner", "bottom right corner");
    LoadCursor("p9cursors/bottom_side", "bottom side");
    LoadCursor("p9cursors/bottom_tee", "bottom tee");
    setup_cursor("box spiral", 0);
    LoadCursor("p9cursors/center_ptr", "center ptr");
    LoadCursor("p9cursors/circle", "circle");
    setup_cursor("clock", 0);
    setup_cursor("coffee mug", 0);
    LoadCursor("p9cursors/cross", "cross");
    LoadCursor("p9cursors/cross_reverse", "cross reverse");
    LoadCursor("p9cursors/crosshair", "crosshair");
    LoadCursor("p9cursors/diamond_cross", "diamond cross");
    LoadCursor("p9cursors/dot", "dot");
    setup_cursor("dotbox", 0);
    setup_cursor("double arrow", 0);
    setup_cursor("draft large", 0);
    setup_cursor("draft small", 0);
    setup_cursor("draped box", 0);
    LoadCursor("p9cursors/exchange", "exchange");
    LoadCursor("p9cursors/fleur", "fleur");
    setup_cursor("gobbler", 0);
    setup_cursor("gumby", 0);
    LoadCursor("p9cursors/hand1", "hand1");
    LoadCursor("p9cursors/hand2", "hand2");
    setup_cursor("heart", 0);
    setup_cursor("icon", 0);
    setup_cursor("iron cross", 0);
    setup_cursor("left ptr", 0);
    LoadCursor("p9cursors/left_side", "left side");
    setup_cursor("left tee", 0);
    setup_cursor("leftbutton", 0);
    setup_cursor("ll angle", 0);
    setup_cursor("lr angle", 0);
    setup_cursor("man", 0);
    setup_cursor("middlebutton", 0);
    setup_cursor("mouse", 0);
    setup_cursor("pencil", 0);
    setup_cursor("pirate", 0);
    setup_cursor("plus", 0);
    setup_cursor("question arrow", 0);
    setup_cursor("right ptr", 0);
    LoadCursor("p9cursors/right_side", "right side");
    setup_cursor("right tee", 0);
    setup_cursor("rightbutton", 0);
    setup_cursor("rtl logo", 0);
    setup_cursor("sailboat", 0);
    setup_cursor("sb down arrow", 0);
    LoadCursor("p9cursors/sb_h_double_arrow", "sb h double arrow");
    setup_cursor("sb left arrow", 0);
    setup_cursor("sb right arrow", 0);
    setup_cursor("sb up arrow", 0);
    LoadCursor("p9cursors/sb_v_double_arrow", "sb v double arrow");
    setup_cursor("shuttle", 0);
    setup_cursor("sizing", 0);
    setup_cursor("spider", 0);
    setup_cursor("spraycan", 0);
    setup_cursor("star", 0);
    setup_cursor("target", 0);
    setup_cursor("tcross", 0);
    setup_cursor("top left arrow", 0);
    LoadCursor("p9cursors/top_left_corner", "top left corner");
    LoadCursor("p9cursors/top_right_corner", "top right corner");
    LoadCursor("p9cursors/top_side", "top side");
    setup_cursor("top tee", 0);
    setup_cursor("trek", 0);
    setup_cursor("ul angle", 0);
    setup_cursor("umbrella", 0);
    setup_cursor("ur angle", 0);
    LoadCursor("p9cursors/watch", "watch");
    LoadCursor("p9cursors/xterm", "xterm");

}
