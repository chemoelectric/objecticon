<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>sizer.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: sizer.icn 8282 2020-05-11 18:28:41Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package gui
<a name="10"/>
<a name="11"/>import util
<a name="12"/>
<a name="13"/>#
<a name="14"/># This class provides a component which can be dragged across the
<a name="15"/># window, allowing panes within the window to be resized.  A Event.SIZER_RELEASE is
<a name="16"/># generated when the `Sizer` has been dragged and released.  The new position
<a name="17"/># may then be obtained and the dialog adjusted accordingly.
<a name="18"/>#
<a name="19"/>class Sizer(Component, HasOrientation)
<a name="20"/>   public 
<a name="21"/>      show_inter_flag,
<a name="22"/>      temp_win,  
<a name="23"/>      temp_orig,
<a name="24"/>      lo,
<a name="25"/>      hi,
<a name="26"/>      gp,
<a name="27"/>      drag_offset,
<a name="28"/>      curr_pos,
<a name="29"/>      start_pos
<a name="30"/>
<a name="31"/>   public static const DEFAULT_SIZE
<a name="32"/>
<a name="33"/>   private static init()
<a name="34"/>      DEFAULT_SIZE := env_scale_odd("OI_SIZER_DEFAULT_SIZE") | scale_odd(7)
<a name="35"/>   end
<a name="36"/>
<a name="37"/>   #
<a name="38"/>   # Set the minimum and maximum values for the `Sizer`.  Whether
<a name="39"/>   # these are x or y values depends on the orientation of the
<a name="40"/>   # `Sizer`.  The range is always reset on each mouse press, so this
<a name="41"/>   # must be set on each `SIZER_PRESS` event.
<a name="42"/>   #
<a name="43"/>   public set_range(lo, hi)
<a name="44"/>      self.lo := /lo | need_integer(lo)
<a name="45"/>      self.hi := /hi | need_integer(hi)
<a name="46"/>      link
<a name="47"/>   end
<a name="48"/>
<a name="49"/>   #
<a name="50"/>   # Return the current position of the `Sizer`.  This may be invoked to determine
<a name="51"/>   # where the `Sizer` has been dragged to after it has generated an event.
<a name="52"/>   #
<a name="53"/>   public get_curr_pos()
<a name="54"/>      return curr_pos
<a name="55"/>   end
<a name="56"/>
<a name="57"/>   #
<a name="58"/>   # Get the size of the move during the current move of the `Sizer`.
<a name="59"/>   #
<a name="60"/>   public get_delta()
<a name="61"/>      return curr_pos - start_pos
<a name="62"/>   end
<a name="63"/>
<a name="64"/>   #
<a name="65"/>   # Set whether to show the intermediate position of the sizer,
<a name="66"/>   # ie whilst it is being dragged.
<a name="67"/>   #
<a name="68"/>   public set_show_inter(s)
<a name="69"/>      self.show_inter_flag := need_flag(s)
<a name="70"/>      link
<a name="71"/>   end
<a name="72"/>
<a name="73"/>   public override display()
<a name="74"/>      local x1, y1
<a name="75"/>      x1 := self.x + (self.w - gp.w) / 2
<a name="76"/>      y1 := self.y + (self.h - gp.h) / 2
<a name="77"/>      gp.draw(self.cbwin, x1, y1)
<a name="78"/>   end
<a name="79"/>
<a name="80"/>   private set_curr_pos(e)
<a name="81"/>      if \self.is_horizontal_flag then
<a name="82"/>         curr_pos := e.y - drag_offset - parent.y
<a name="83"/>      else
<a name="84"/>         curr_pos := e.x - drag_offset - parent.x
<a name="85"/>
<a name="86"/>      curr_pos &lt;:= \lo
<a name="87"/>      curr_pos &gt;:= \hi
<a name="88"/>      return curr_pos
<a name="89"/>   end
<a name="90"/>
<a name="91"/>   public override initially()
<a name="92"/>      if \self.is_horizontal_flag then {
<a name="93"/>         set_pointer("sb v double arrow")
<a name="94"/>         gp.set_cache("gui.HORIZ_GRID")
<a name="95"/>      } else {
<a name="96"/>         set_pointer("sb h double arrow")
<a name="97"/>         gp.set_cache("gui.VERT_GRID")
<a name="98"/>      }
<a name="99"/>      Component.initially()
<a name="100"/>      gp.initially(self)
<a name="101"/>   end
<a name="102"/>
<a name="103"/>   public override finally()
<a name="104"/>      Component.finally()
<a name="105"/>      gp.finally()
<a name="106"/>   end
<a name="107"/>
<a name="108"/>   public override get_default_width()
<a name="109"/>      if /self.is_horizontal_flag then
<a name="110"/>         return DEFAULT_SIZE
<a name="111"/>   end
<a name="112"/>
<a name="113"/>   public override get_default_height()
<a name="114"/>      if \self.is_horizontal_flag then
<a name="115"/>         return DEFAULT_SIZE
<a name="116"/>   end
<a name="117"/>
<a name="118"/>   public handle_lpress(e)
<a name="119"/>      drag_offset := if \self.is_horizontal_flag then
<a name="120"/>         e.y - self.y
<a name="121"/>      else
<a name="122"/>         e.x - self.x
<a name="123"/>      # We reset the range since it may no longer be valid (see notes).
<a name="124"/>      set_range()
<a name="125"/>      start_pos := set_curr_pos(e)
<a name="126"/>      if \self.show_inter_flag then {
<a name="127"/>         self.temp_win := SliderDragComponent().
<a name="128"/>            set_pos(self.x + parent_dialog.win.get_dx(), 
<a name="129"/>                    self.y + parent_dialog.win.get_dy()).
<a name="130"/>            set_z(self.parent_dialog.get_top_z()).
<a name="131"/>            set_size(self.w, self.h)
<a name="132"/>         if \self.is_horizontal_flag then {
<a name="133"/>            temp_orig := self.y + parent_dialog.win.get_dy()
<a name="134"/>            self.temp_win.set_pointer("sb v double arrow")
<a name="135"/>         } else {
<a name="136"/>            temp_orig := self.x + parent_dialog.win.get_dx()
<a name="137"/>            self.temp_win.set_pointer("sb h double arrow")
<a name="138"/>         }
<a name="139"/>         self.parent_dialog.add(self.temp_win)
<a name="140"/>         self.temp_win.resize().invalidate()
<a name="141"/>      }
<a name="142"/>      fire(Event.SIZER_PRESS, e)
<a name="143"/>   end
<a name="144"/>
<a name="145"/>   public handle_ldrag(e)
<a name="146"/>      set_curr_pos(e)
<a name="147"/>      if \self.show_inter_flag then {
<a name="148"/>         if \is_horizontal_flag then {
<a name="149"/>            self.temp_win.y_spec := temp_orig + get_delta()
<a name="150"/>         } else {
<a name="151"/>            self.temp_win.x_spec := temp_orig + get_delta()
<a name="152"/>         }
<a name="153"/>         self.temp_win.invalidate().resize().invalidate()
<a name="154"/>      }
<a name="155"/>      fire(Event.SIZER_DRAG, e)
<a name="156"/>   end
<a name="157"/>
<a name="158"/>   public handle_lrelease(e)
<a name="159"/>      set_curr_pos(e)
<a name="160"/>      if \self.show_inter_flag then {
<a name="161"/>         self.temp_win.invalidate()
<a name="162"/>         self.parent_dialog.remove(self.temp_win)
<a name="163"/>         self.temp_win := &amp;null
<a name="164"/>      }
<a name="165"/>      fire(Event.SIZER_RELEASE, e)
<a name="166"/>   end
<a name="167"/>
<a name="168"/>   public override new()
<a name="169"/>      Component.new()
<a name="170"/>      connect(self.handle_lpress, Event.MOUSE_LEFT_PRESS)
<a name="171"/>      connect(self.handle_ldrag, Event.MOUSE_LEFT_DRAG)
<a name="172"/>      connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE)
<a name="173"/>      gp := ImagePaint()
<a name="174"/>      return
<a name="175"/>   end
<a name="176"/>end
<a name="177"/>
<a name="178"/>
<a name="179"/>class SliderDragComponent(Component)
<a name="180"/>   public override display()
<a name="181"/>      local cw
<a name="182"/>      use {
<a name="183"/>         cw := cbwin.clone(),
<a name="184"/>         cw.set_masked_pattern("gray").fill_rectangle(self.x, self.y, self.w, self.h)
<a name="185"/>      }
<a name="186"/>   end
<a name="187"/>end
</pre></body></html>
