package util

import lang(Class, Prog),
   ipl.lists(ldel1)


#
# Succeed iff the sequence generated by {&features} contains the given
# string.
#
procedure has_feature(x)
   static s
   initial {
      s := set()
      every insert(s, &features)
   }
   return member(s, x)
end

#
# Convenient procedure to set {&why} to the given string and fail.
#
procedure error(s)
   &why := s
end

# This class just provides a simple constructor which initializes the
# instance fields in the order they were defined in the class, from
# the given parameters.  In other words, rather like a record
# constructor.  The fields in the subclass must of course be
# accessible to this class's constructor.
#
# @example
# @  class Abc(SimpleConstructor) public const a, b, c end
# @  ...
# @  x := Abc(1,2,3)  # Sets a,b,c to 1,2,3 respectively
#  
class SimpleConstructor()
   public new(a[])
      every Class.get(self, 1 to Class.get_n_instance_fields(self)) := pop(a)
      return
   end
end

# Invoke co-expression {e}, generating its results, in such a way that
# changes to {vars} made by {e} will not be seen by the caller, and
# vice versa.
#
# @param vars a coexpression generating one or more variables.
#
# @example
# @ # Cleanup some io stuff, without affecting global vars g1 and g2.
# @ save_vars{ io_cleanup(), g1 | g2 }
#
procedure save_vars(e, vars)
   suspend save_state(e, VarState(vars))
end

#
# A common case, having the same effect as `save_vars{..., &why}`.
#
procedure save_why(e)
   suspend save_state(e, WhyState())
end

# This function saves {&why} before evaluating {e}.  If {e} succeeds,
# {&why} is restored, and the result returned; otherwise {&why} is not
# restored and the procedure fails.
#
procedure protect_why(e)
   local t
   t := &why
   return 1(@e, &why := t)
end

#
# Utility to check for a positive integer
#
procedure check_positive_int(n)
   return (0 < integer(n)) | runerr("Positive integer expected", n)
end

# Stores a list of cleanup expressions to be run.  See {use} and {clean}.
#
package global cleanup

#
# This procedure is used to automatically close a {Stream} or other
# resource.  The first expression {e1} produces the resource, the
# second {e2} uses it, and the third expression {e3} then closes it.
# The result of {e2} is returned, if all three expressions succeed,
# otherwise the procedure fails.
#
# {e3} is optional and defaults to calling {close} on the resource.
#
# @example
# @   s := use { f := open("some.txt"),
# @              do_something_with(f) }
procedure use(e1, e2, e3)
   local x, v, f
   x := @e1 | fail
   /e3 := create x.close()
   push(\cleanup, e3)
   /e2 | (v := @e2) | (f := 1)
   ldel1(\cleanup, e3)
   @e3 | (f := 1)
   return /f & v
end

# This procedure can be used in conjunction with {use} to ensure that
# all cleanup expressions are performed.  {e} is evaluated for its
# first result only.  Then any outstanding cleanup expressions are
# performed.  If {e} failed, or any of the cleanup expressions failed,
# then the procedure fails; otherwise the first result of {e} is
# returned.
#
# See also {exception.clean_try}.
#
procedure clean(e)
   local t, v, f
   t := cleanup
   cleanup := []
   (v := @e) | (f := 1)
   do_cleanups() | (f := 1)
   cleanup := t
   return /f & v
end

# Perform any outstanding cleanups in the {cleanup} list.  Fails if any of the
# expressions fail, succeeds otherwise.
#
procedure do_cleanups()
   local f, x
   while x := pop(cleanup) do
      @x | (f := 1)
   return /f
end

# Convert an index position based on a length, to an absolute index,
# using Icon semantics of indices <= 0.  Fails if pos is out of range.
#
procedure cvpos(pos, len)
   pos := integer(pos) | runerr(101, pos)
   len := integer(len) | runerr(101, len)
   if pos < -len | pos > len + 1 then
      fail
   if pos > 0 then
      return pos
   return pos + len + 1
end

# Convert an index position based on a length, to an absolute index,
# using Icon semantics of indices <= 0.  Fails if pos is out of range,
# or points at the end of the range (pos = 0 or equivalent).
#
procedure cvpos_item(pos, len)
   pos := integer(pos) | runerr(101, pos)
   len := integer(len) | runerr(101, len)
   if pos < -len | pos > len | pos = 0 then
      fail
   if pos > 0 then
      return pos
   return pos + len + 1
end

package record Slice(lo, hi)

#
# Normalize an icon slice specification (along the lines of
# s[pos1:pos2]).  Returned is a record with lo, hi elements, giving
# the extent of the slice.  Failure occurs if pos1 or pos2 are out of
# range.
#
procedure cvslice(pos1, pos2, len)
   pos1 := cvpos(pos1, len) | fail
   pos2 := cvpos(pos2, len) | fail
   if pos1 > pos2 then
      pos1 :=: pos2
   return Slice(pos1, pos2)
end

#
# Like cvslice above, but pos1 defaults to 1, pos2 to 0.
#
procedure cvslice_def(pos1, pos2, len)
   /pos1 := 1
   /pos2 := 0
   return cvslice(pos1, pos2, len)
end

# This class can be used by a class which has various capabilities or
# permitted operations, and needs to give clients a simple way of
# seeing what it is capable of, by way of an integer bit flag
# combination.
#
abstract class HasMode()
   #
   # Succeed iff the object's mode has all the flags in {c}
   #
   public can(c)
      return iand(get_mode(), c) = c
   end

   # This method is implemented to return the integer bit flag
   # describing the object's capabilities.
   #
   public abstract get_mode()
end

# This class is used to save and restore some arbitrary global state.
#
abstract class State()
   # Called once to initialize the saved state from the global state,
   # and perhaps to initialize the global state.
   public abstract begin()

   # Called several times to swap the saved state with the global state
   public abstract swap()
end

# A `State` instance which saves several global variables, specified as
# a co-expression generating those variables.
#
class VarState(State)
   private vars, state

   # Return an appropriate initial value for a global named `s`;
   # normally &null, except for certain keyword variables.
   #
   private static init_val(s)
      return case s of {
         "&subject" | "&why" | "&progname": ""
         "&pos": 1
         "&trace" | "&random" | "&dump": 0
         "&maxlevel": 500
         default: &null
      }
   end

   public begin()
      local f
      state := []
      every put(state, !vars)
      f := create init_val(Prog.get_variable_name(!vars))
      every !vars := @f
   end

   public swap()
      if *state = 1 then
         # Simple case
         !vars :=: state[1]
      else {
         # Complex case.  Done in two stages (as opposed to swapping with
         # existing elements of state), so that it works okay with &subject
         # and &pos (swapping to &subject would change &pos).
         every put(state, !vars)
         every !vars := pop(state)
      }
   end

   public new(e)
      vars := e
      return
   end
end

# A `State` which saves &subject and &pos
#
class ScanState(State)
   private ks, kp

   public begin()
      ks := &subject
      kp := &pos
      &subject := ""
   end

   public swap()
      local t
      t := &pos
      &subject :=: ks
      &pos := kp
      kp := t
   end
end

# A `State` to save the global cleanup list used by `clean` and `use`.
#
class CleanupState(State)
   private t

   public begin()
      t := cleanup
      cleanup := &null
   end

   public swap()
      cleanup :=: t
   end
end

# A `State` to save `&why`.
#
class WhyState(State)
   private w

   public begin()
      w := &why
      &why := ""
   end

   public swap()
      &why :=: w
   end
end

# A `State` to save `&trace`.
#
class TraceState(State)
   private t, i

   public begin()
      t := &trace
      &trace := i
   end

   public swap()
      &trace :=: t
   end

   public new(i)
      /i := 0
      self.i := i
      return
   end
end

# A `State` to save `&handler`.  An initial value may be specified.
#
class HandlerState(State)
   private h, i

   public begin()
      h := &handler
      &handler := i
   end

   public swap()
      &handler :=: h
   end

   public new(i)
      self.i := i
      return
   end
end

# A `State` which just brings a list of several other `State`s together.
#
class States(State)
   private l

   public begin()
      every (!l).begin()
   end

   public swap()
      every (!l).swap()
   end

   public new(l[])
      self.l := l
      return
   end
end

# Evaluate the given co-expression `e`, suspending its results, whilst
# using the given `State` instance to save and restore some global
# state.
#
procedure save_state(e, state)
   state.begin()
   suspend 1(|@e, { state.swap() ; &null} ) do
      state.swap()
   state.swap()
end
