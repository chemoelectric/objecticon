<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>slashupto</title></head><body>
<h1>slashupto(c, s, i, j)</h1>
<dl>
<dt>Package :</dt><dd><a href="ipl.scan-package.html" target="listFrame">ipl.scan</a></dd>
<dt>Type :</dt><dd>procedure</dd>
</dl><p/>
###########################################################################
<p/>
Richard L. Goerwitz:
<p/>
Slashupto works just like upto, except that it ignores backslash
escaped characters.  I can't even begin to express how often I've
run into problems applying Icon's string scanning facilities to
to input that uses backslash escaping.  Normally, I tokenize first,
and then work with lists.  With slshupto() I can now postpone or
even eliminate the traditional tokenizing step, and let Icon's
string scanning facilities to more of the work.
<p/>
If you're confused:
<p/>
Typically UNIX utilities (and probably others) use backslashes to
"escape" (i.e. remove the special meaning of) metacharacters.  For
instance, UNIX shells normally accept "*" as a shorthand for "any
series of zero or more characters.  You can make the "*" a literal
"*," with no special meaning, by prepending a backslash.  The rou-
tine slshupto() understands these backslashing conventions.  You
can use it to find the "*" and other special characters because it
will ignore "escaped" characters.
<p/>
<p/>
<code><a href="ipl.scan.slashupto.html" target="displayFrame">slashupto</a></code>:  cset <code>x</code> string <code>x</code> integer <code>x</code> integer -&gt; integers  <br>
<code>(c, s, i, j)</code> -&gt; <code>I</code>s (a generator)
<p/>
where <code>I</code>s are the integer positions in <code>s[i:j]</code> before characters
in <code>c</code> that is not preceded by a backslash escape
<p/>
upto() with escapes
<p/><a href="ipl.scan-scan.icn.html#93" target="displayFrame">Source - scan.icn </a>
<p/>
</body></html>
