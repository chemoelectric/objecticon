#
# $Id$
#

package net

$if _PLAN9
import 
   util, 
   io,
   lang,
   ipl.scan
$elsif _MS_WIN32
import 
   util, 
   io,
   lang,
   ipl.pdco,
   ipl.scan
$else
import 
   util, 
   io,
   lang,
   ssl,
   posix,
   ipl.pdco,
   ipl.scan
$endif

#
# Common base class for a client class which holds a connection to a
# server and communicates using CRLF-terminated lines.
#
abstract class NetClient(Connectable, HasTask)
   public static const 
      CONNECTING_EVENT,
      CONNECTED_EVENT,
      CLOSED_EVENT,
      WRITING_STRING_EVENT,
      WRITING_LINE_EVENT,
      READ_LINE_EVENT,
      READ_STRING_EVENT,
      # The timeout (in ms) for IP addresses noted to avoid; by default one minute.
      AVOID_TIMEOUT,
      # A table of addresses (string) to expiry time.
      avoid

   private static init()
      CONNECTING_EVENT := "Connecting"
      CONNECTED_EVENT := "Connected"
      CLOSED_EVENT := "Closed"
      WRITING_STRING_EVENT := "Writing string"
      WRITING_LINE_EVENT := "Writing line"
      READ_LINE_EVENT := "Read line"
      READ_STRING_EVENT := "Read string"
      AVOID_TIMEOUT := env_int("OI_NETCLIENT_AVOID_TIMEOUT", 0) | 60*1000
      avoid := table()
   end

   private readable
      path,
      server,
      port,
      timeout,
      ssl_flag,
      ssl_verify_flag,
      dont_retry_flag,
      ip_version

   private
      connection,
      ssl_connection,
      sbuff

   # Note an address to avoid for the next `AVOID_TIMEOUT`
   # milliseconds.
   #
   public static avoid_addr(addr)
      insert(avoid, addr, Prog.get_runtime_millis() + AVOID_TIMEOUT)
      return NetClient
   end

   # Given a list of addresses, choose the first which we are not
   # currently avoiding, or the best alternative otherwise.
   #
   public static choose_addr(l)
      local e, t, now, best
      # Purge expired entries from avoid
      now := Prog.get_runtime_millis()
      every e := key(avoid) do {
         if now >= avoid[e] then
            delete(avoid, e)
      }
      every e := !l do {
         # If not avoiding this element, return it.
         t := member(avoid, e) | return e
         # Otherwise note the one with the earliest expiry.
         if /best | t < avoid[best] then
            best := e
      }
      return best
   end

   # Set the ip version option to pass during dns lookup; see
   # `SocketStream.dns_query()`.  By default, this is `&null`.
   #
   public set_ip_version(ver)
      self.ip_version := ver
      return self
   end

   # Set the timeout in ms to use.  If `&null`, then no timeout will
   # be used.
   #
   public set_timeout(timeout)
      self.timeout := timeout
      return self
   end

   private do_poll(for)
      return choose_poll([connection, for], timeout)
   end

$if _PLAN9
   #
   # Open the connection.
   #
   protected open_connection()
      local addr, cs, l
      close_connection()
      fire(CONNECTING_EVENT)
      if \ssl_flag then
         return error_dont_retry("SSL not supported")
      if \path then
         return error_dont_retry("UNIX domain not supported")
      addr := "tcp!" || server || "!" || port
      l := NetStream.cs_query(addr, ip_version, task) | return error("Couldn't translate address: " || &why)
      cs := choose_addr(l)
      connection := NetStream.connect(cs, timeout, task) | {
         avoid_addr(cs)
         return error("Couldn't connect to " || server || " (" || cs || "): " || &why)
      }
      connection := NonBlockStream(connection,, 1048576, 1048576).
         set_write_on_close(NonBlockStream.DISCARD)
      sbuff := ""
      fire(CONNECTED_EVENT, cs)
      return self
   end
$elsif _MS_WIN32
   private dns_query()
      return WinsockStream.dns_query(server, ip_version)
   end

   private ip_to_addr(ip)
      return if upto('.', ip) then 
         "inet:" || ip || ":" || port
      else
         "inet6:[" || ip || "]:" || port
   end

   #
   # Open the connection.
   #
   protected open_connection()
      local r, domain, addr, msg_addr, l

      close_connection()
      fire(CONNECTING_EVENT)
      if \ssl_flag then
         return error_dont_retry("SSL not supported")
      if \path then
         return error_dont_retry("UNIX domain not supported")
      l := dns_query() | return error("Couldn't translate address: " || &why)
      l := List{ ip_to_addr(!l) }
      addr := choose_addr(l)
      domain := if match("inet:", addr) then
         ProtocolFormat.INET
      else
         ProtocolFormat.INET6
      msg_addr := server || " (" || addr || ")"

      connection := WinsockStream(domain)
      connection.set_blocking_mode(&no) | {
         save_why{ close_connection() }
         return error("Couldn't put socket in non-blocking mode: " || &why)
      }

      connection.connect(addr) | {
         if errno() = WSAError.EWOULDBLOCK then {
            r := do_poll(Poll.OUT) | {
               save_why{ close_connection() }
               avoid_addr(addr)
               return error("Couldn't connect to " || msg_addr || ": " || &why)
            }
            if /r then {
               close_connection()
               avoid_addr(addr)
               return error("Couldn't connect to " || msg_addr || ": timeout")
            }
            DescStream.poll_out_test(r[1]) | {
               close_connection()
               avoid_addr(addr)
               return error("Couldn't connect to " || msg_addr || ": socket error")
            }
         } else {
            save_why{ close_connection() }
            avoid_addr(addr)
            return error("Couldn't connect to " || msg_addr || ": " || &why)
         }
      }
      sbuff := ""
      fire(CONNECTED_EVENT, addr)
      return self
   end
$else
   private dns_query_impl()
      return SocketStream.dns_query(server, ip_version)
   end

   private dns_bg_query(p)
      local r
      if r := dns_query_impl() then
         p.send(r)
      else
         p.send(&why)
   end

   private dns_query()
      local p, v
      if /task then
         return dns_query_impl()
      p := Process{dns_bg_query(p)}.set_task(task)
      p.start() | fail
      if v := p.poll() then {
         p.close()
         return if type(v) == "list" then
            v
         else
            error(v)
      } else
         # poll() failed, meaning we were interrupted.  We don't want
         # to call close(), which would hang whilst p exited, so we
         # call stop() which kills it first.
         p.stop()
   end

   private ip_to_addr(ip)
      return if upto('.', ip) then 
         "inet:" || ip || ":" || port
      else
         "inet6:[" || ip || "]:" || port
   end

   #
   # Open the connection.
   #
   protected open_connection()
      local r, domain, addr, msg_addr, l

      close_connection()
      fire(CONNECTING_EVENT)

      if \server then {
         l := dns_query() | return error("Couldn't translate address: " || &why)
         l := List{ ip_to_addr(!l) }
         addr := choose_addr(l)
         domain := if match("inet:", addr) then
            ProtocolFormat.INET
         else
            ProtocolFormat.INET6
         msg_addr := server || " (" || addr || ")"
      } else if \path then {
         domain := ProtocolFormat.UNIX
         msg_addr := addr := "unix:" || path
      } else
         runerr("Neither server/port nor path set")

      connection := SocketStream(domain)
      connection.flag(FileOpt.NONBLOCK) | {
         save_why{ close_connection() }
         return error("Couldn't put socket in non-blocking mode: " || &why)
      }

      connection.connect(addr) | {
         if errno() = Errno.EINPROGRESS then {
            r := do_poll(Poll.OUT) | {
               save_why{ close_connection() }
               avoid_addr(addr)
               return error("Couldn't connect to " || msg_addr || ": " || &why)
            }
            if /r then {
               close_connection()
               avoid_addr(addr)
               return error("Couldn't connect to " || msg_addr || ": timeout")
            }
            DescStream.poll_out_test(r[1]) | {
               close_connection()
               avoid_addr(addr)
               return error("Couldn't connect to " || msg_addr || ": socket error")
            }
         } else {
            save_why{ close_connection() }
            avoid_addr(addr)
            return error("Couldn't connect to " || msg_addr || ": " || &why)
         }
      }
      if \ssl_flag then {
         ssl_available() | return error_dont_retry(&why)
         ssl_connection := SslStream(connection, server) | {
            save_why{ close_connection() }
            return error("Couldn't create SslStream: " || &why)
         }
         until ssl_connection.connect() do {
            ssl_maybe_poll() | {
               save_why{ close_connection() }
               return error("Couldn't perform SSL connection: " || &why)
            }
         }
         if \ssl_verify_flag then {
            ssl_connection.verify() | {
               save_why{ close_connection() }
               return error_dont_retry("Couldn't verify SSL connection: " || &why)
            }
         }
      }

      sbuff := ""
      fire(CONNECTED_EVENT, addr)
      return self
   end
$endif

   # After an error to an ssl function, check if it is because the
   # ssl layer needs to read/write from the underlying connection.
   # If so, poll the connection and return (so the ssl call can be
   # retried); otherwise fail.
   private ssl_maybe_poll()
      local err, r
      # Extract the ssl error no.
      &why ? {
         if tab(past("error:")) then
            err := integer(tab(many(&digits)))
      }
      case err of {
         2 : {  # SSL_ERROR_WANT_READ
            r := do_poll(Poll.IN) | return error("Receive poll failed: " || &why)
            if /r then return error("Receive failed (timeout)")
            DescStream.poll_in_test(r[1]) | return error("Receive failed (socket error)")
            return
         }
         3 : {  # SSL_ERROR_WANT_WRITE 
            r := do_poll(Poll.OUT) | return error("Send poll failed: " || &why)
            if /r then return error("Send failed (timeout)")
            DescStream.poll_out_test(r[1]) | return error("Send failed (socket error)")
            return
         }
      }
   end

   #
   # Close the connection
   #
   protected close_connection()
      local f
      if \ssl_connection then {
         ssl_connection.close() | (f := &why)
         connection.close() | (f := &why)
         ssl_connection := connection := &null
         fire(CLOSED_EVENT)
      } else if \connection then {
         connection.close() | (f := &why)
         connection := &null
         fire(CLOSED_EVENT)
      }
      return if /f then self else error(f)
   end

   #
   # Close this client and any associated connection.
   #
   public close()
      return close_connection()
   end

   #
   # Set the path to use (implies using PF_UNIX socket domain)
   #
   public set_path(s)
      path := s
      return self
   end

   #
   # Set the server to use (implies using PF_INET socket domain)
   #
   public set_server(s)
      server := s
      return self
   end

   #
   # Set the port
   #
   public set_port(n)
      port := n
      return self
   end

   #
   # Low-level write on the connection. 
   #
   private send(s)
      local i, r
      s := need_string(s)
      if \ssl_connection then {
         while *s > 0 do {
            if i := ssl_connection.out(s) then
               s := s[i+1 : 0]
            else
               ssl_maybe_poll() | return error("Send SSL out() failed: " || &why)
         }
      } else {
         while *s > 0 do {
            r := do_poll(Poll.OUT) | return error("Send poll failed: " || &why)
            if /r then return error("Send failed (timeout)")
            DescStream.poll_out_test(r[1]) | return error("Send failed (socket error)")
            i := connection.out(s) | return error("Send out() failed: " || &why)
            s := s[i+1 : 0]
         }
      }
      return self
   end

   #
   # Low-level read on the connection. 
   #
   private recv(len)
      local r, s
      if \ssl_connection then {
         repeat {
            if s := ssl_connection.in(len) then
               return s
            ssl_maybe_poll() | return error("Receive SSL in() failed: " || &why)
         }
      } else {
         r := do_poll(Poll.IN) | return error("Receive poll failed: " || &why)
         if /r then return error("Receive failed (timeout)")
         DescStream.poll_in_test(r[1]) | return error("Receive failed (socket error)")
         return connection.in(len) | error("Receive in() failed: " || &why)
      }
   end

   #
   # Write the given string to the connection.
   #
   protected write_str(s)
      fire(WRITING_STRING_EVENT, s)
      return send(s)
   end

   #
   # Write a single line to the connection, appending CRLF to the output stream.
   # 
   protected write_line(s)
      /s := ""
      fire(WRITING_LINE_EVENT, s)
      return send(s || "\r\n") 
   end

   #
   # Write several lines in one go, but firing separate events for each line.
   #
   protected write_lines(l)
      local s
      s := ""
      every s ||:= (!l) || "\r\n"
      every fire(WRITING_LINE_EVENT, !l)
      return send(s)
   end

   #
   # Read a single line from the connection, and return it.  Returns `&null` on eof.
   #
   protected read_line()
      local line, s

      repeat {
         #
         # Look for a line and if found return it.
         #
         sbuff ? {
            if line := tab(find("\r\n")) then {
               move(2)
               sbuff := tab(0)
               fire(READ_LINE_EVENT, line)
               return line
            }
         }
         s := recv(1048576) | fail
         if /s then {
            if *sbuff = 0 then
               return
            line := sbuff
            sbuff := ""
            fire(READ_LINE_EVENT, line)
            return line
         }
         sbuff ||:= s
      }
   end

   #
   # This method is the same as `read_line`, except that on end of
   # file it fails, setting `&why`, rather than returning `&null`.
   #
   protected expect_line()
      local s
      s := read_line() | fail
      return \s | error("Unexpected eof")
   end

   #
   # Read up to len bytes on the connection, returning `&null` on eof.
   #
   protected read_str(len)
      local t
      #
      # Use the line buffer if it has anything in it.
      #
      if *sbuff > 0 then {
         sbuff ? {
            t := move(len) | tab(0)
            sbuff := tab(0)
         }
      } else {
         t := recv(len) | fail
         if /t then
            return
      }
      fire(READ_STRING_EVENT, t)
      return t
   end

   # This method is the same as `read_str`, except that on end of file
   # it fails, setting `&why`, rather than returning `&null`.
   #
   protected expect_str(len)
      local s
      s := read_str(len) | fail
      return \s | error("Unexpected eof")
   end

   #
   # Succeed iff the connection is currently open.
   #
   protected is_connected()
      if \self.connection then
         return
   end

   #
   # A flag value.  When set, indicate that the connection should be wrapped in
   # an SslStream.
   #
   public set_ssl(s)
      self.ssl_flag := need_flag(s)
      return self
   end

   #
   # A flag value.  When set, indicate that the remote host's identity should be
   # verified.  By default, this flag is on.
   #
   public set_ssl_verify(s)
      self.ssl_verify_flag := need_flag(s)
      return self
   end

   #
   # Set the `dont_retry_flag`, indicating an error has occurred that
   # couldn't be overcome by retrying.  Then `&why` is set to `s`.
   #
   protected error_dont_retry(s)
      dont_retry_flag := &yes
      &why := s
   end

   #
   # Clear the `dont_retry_flag`.
   #
   protected reset_dont_retry()
      dont_retry_flag := &null
      return self
   end

   public new()
      Connectable.new()
      sbuff := ""
      ssl_verify_flag := &yes
      return
   end
end
