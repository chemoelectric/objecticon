<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>webscraper.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: webscraper.icn 7464 2019-02-16 10:58:37Z rparlett $
<a name="3"/>#
<a name="4"/>
<a name="5"/>package ipl.webscraper
<a name="6"/>
<a name="7"/>import xml, util, ipl.scan, io, ipl.pdco, lang
<a name="8"/>
<a name="9"/>package record AnchorString(str, path)
<a name="10"/>package record AnchorTag(name, attrs, path)
<a name="11"/>
<a name="12"/>package record AnchorStringCmd(str)
<a name="13"/>package record AnchorTagCmd(name, attrs)
<a name="14"/>package record UpCmd(n)
<a name="15"/>package record RootCmd()
<a name="16"/>package record TagCmd(n, name)
<a name="17"/>package record StringCmd(n)
<a name="18"/>
<a name="19"/>#
<a name="20"/># A class to help with web scraping.  In particular, it provides a way
<a name="21"/># to help lookup particular elements (tags) in a web page, which has a
<a name="22"/># known element structure.  Having found a desired element, then the
<a name="23"/># client program can extract the desired data.
<a name="24"/>#
<a name="25"/># The class works by taking a sample web page which has the same
<a name="26"/># structure as the web pages we will subsequently be scraping data
<a name="27"/># from.  This sample page is called the template, and is like an
<a name="28"/># ordinary webpage, but contains special directives which mark the
<a name="29"/># particular points in the document we wish to locate in the pages we
<a name="30"/># will be scraping data from.
<a name="31"/>#
<a name="32"/># There are two types of special directives.  The first is the "scrape
<a name="33"/># id".  This can either point to a tag, in which case it takes the
<a name="34"/># form of an attribute :-
<a name="35"/># ~
<a name="36"/>#    &lt;table scrapeid="spellingtable"&gt;
<a name="37"/># ~
<a name="38"/># or it can be placed at the start of text content :-
<a name="39"/># ~
<a name="40"/>#    &lt;a href="/news/special_reports" class="navigation-wide-list__link"&gt;
<a name="41"/>#        &lt;span&gt;$scrapeid=title$Special Reports&lt;/span&gt;
<a name="42"/>#    &lt;/a&gt;
<a name="43"/># ~
<a name="44"/>#
<a name="45"/># The second type of directive is an "anchor".  The idea is that some
<a name="46"/># unique, non-changing text content is chosen, near to a scrape id
<a name="47"/># location.  This is then marked as an "anchor", and the scrape id is
<a name="48"/># made to refer to the anchor.  The scrape id will then be searched
<a name="49"/># for by first searching for the anchor text, and then by following
<a name="50"/># the relative path to the scrape location.  This relative path will
<a name="51"/># hopefully be less prone to change than the path from the scrape to
<a name="52"/># the root element, which must be used if there is no anchor for the
<a name="53"/># scrape.
<a name="54"/>#
<a name="55"/># An example of an anchor and scrape used together is :-
<a name="56"/># ~
<a name="57"/>#    &lt;table scrapeid="pp:pastparticiple" border="0"&gt;
<a name="58"/>#       &lt;tr&gt;&lt;td align="center"&gt;$anchorid=pp$Past participle&lt;/td&gt;&lt;/tr&gt;
<a name="59"/>#       &lt;tr&gt;&lt;td class="colVerbDef"&gt;gemacht&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
<a name="60"/>#    &lt;/table&gt;
<a name="61"/># ~
<a name="62"/>#
<a name="63"/># Here the anchor id is "pp", and the anchor text is "Past
<a name="64"/># participle".  The scrapeid is "pastparticiple", and the link to the
<a name="65"/># anchor is indicated by prefixing this with "pp:".  Now, so long as
<a name="66"/># this relative structure doesn't change, and future documents still
<a name="67"/># contain the "Past participle" text in the same place, the scrape
<a name="68"/># will still successfully retrieve the desired element.
<a name="69"/>#
<a name="70"/># An anchor can also refer to an element, rather than text :-
<a name="71"/># ~
<a name="72"/>#   &lt;div anchorid="a2" class="definition-block def-text"&gt;
<a name="73"/># ~
<a name="74"/># Now a reference to this anchor will cause a search for the first
<a name="75"/># element with the same tag name and attributes in the target
<a name="76"/># document.
<a name="77"/>#
<a name="78"/># A `WebScraper' instance is created by passing the text data
<a name="79"/># containing the template document.  This can either be loaded from a
<a name="80"/># file, or included using a `$load` directive, if it is not too
<a name="81"/># unwieldy.
<a name="82"/>#
<a name="83"/># Once created, subject web pages can be searched using the `lookup`
<a name="84"/># method.  This takes a parsed document and a scrape id and returns
<a name="85"/># the element in the document which corresponds to the scrape id in
<a name="86"/># the template.
<a name="87"/>#
<a name="88"/>class WebScraper()
<a name="89"/>   private
<a name="90"/>      paths,
<a name="91"/>      debug_flag
<a name="92"/>
<a name="93"/>   #
<a name="94"/>   # Generate the lookup scrape ids this webscraper can search for
<a name="95"/>   #
<a name="96"/>   public get_ids()
<a name="97"/>      suspend key(paths)
<a name="98"/>   end
<a name="99"/>
<a name="100"/>   #
<a name="101"/>   # Turn on debugging info
<a name="102"/>   #
<a name="103"/>   public set_debug(s)
<a name="104"/>      self.debug_flag := need_flag(s)
<a name="105"/>      link
<a name="106"/>   end
<a name="107"/>
<a name="108"/>   #
<a name="109"/>   # Create a new instance using the given template.
<a name="110"/>   # :Parameters :
<a name="111"/>   # :  `data` - the template, either string or ucs.
<a name="112"/>   #
<a name="113"/>   public new(data)
<a name="114"/>      local d, n, s, i, anchors, ak, sk
<a name="115"/>
<a name="116"/>      d := HtmlParser().parse(data)
<a name="117"/>
<a name="118"/>      ak := same_string_type(u"ANCHORID", data)
<a name="119"/>      sk := same_string_type(u"SCRAPEID", data)
<a name="120"/>
<a name="121"/>      anchors := create_anchors(d, ak, sk) | fail
<a name="122"/>
<a name="123"/>      paths := table()
<a name="124"/>
<a name="125"/>      every n := Seq{d.traverse_nodes_preorder()} do {
<a name="126"/>         if is(n, Element) &amp; s := n.get_attribute(sk) then {
<a name="127"/>            do_insert(s, n, anchors) | fail
<a name="128"/>         }
<a name="129"/>         i := 0
<a name="130"/>         every s := text(!n.children) do {
<a name="131"/>            i +:= 1
<a name="132"/>            s ? if tab(caseless_match("$scrapeid=")) then {
<a name="133"/>               s := tab(upto('$')) | return error("Unclosed scrapeid")
<a name="134"/>               do_insert(s, n, anchors, i) | fail
<a name="135"/>            }
<a name="136"/>         }
<a name="137"/>      }
<a name="138"/>
<a name="139"/>      return
<a name="140"/>   end
<a name="141"/>
<a name="142"/>   private do_insert(s, n, anchors, si)
<a name="143"/>      local a, anchor, id
<a name="144"/>      s ? {
<a name="145"/>         if a := tab(upto(':')) then {
<a name="146"/>            move(1)
<a name="147"/>            anchor := member(anchors, a) | return error("Unknown anchor: " || a)
<a name="148"/>         }
<a name="149"/>         id := tab(0)
<a name="150"/>      }
<a name="151"/>      insert(paths, id, create_path(n, anchor, si))
<a name="152"/>
<a name="153"/>      link
<a name="154"/>   end
<a name="155"/>
<a name="156"/>   private static create_anchors(d, ak, sk)
<a name="157"/>      local n, s, id, str, res, t
<a name="158"/>
<a name="159"/>      res := table()
<a name="160"/>      every n := Seq{d.traverse_nodes_preorder()} do {
<a name="161"/>         if is(n, Element) &amp; id := n.get_attribute(ak) then {
<a name="162"/>            t := copy(n.attributes)
<a name="163"/>            # Delete any special template attributes
<a name="164"/>            every delete(t, ak | sk)
<a name="165"/>            insert(res, id, AnchorTag(n.name, t, path_to_root(n)))
<a name="166"/>         }
<a name="167"/>         every s := text(!n.children) do {
<a name="168"/>            s ? if tab(caseless_match("$anchorid=")) then {
<a name="169"/>               id := tab(upto('$')) | return error("Unclosed anchor id")
<a name="170"/>               move(1)
<a name="171"/>               str := tab(0)
<a name="172"/>               insert(res, id, AnchorString(str, path_to_root(n)))
<a name="173"/>            }
<a name="174"/>         }
<a name="175"/>      }
<a name="176"/>
<a name="177"/>      return res
<a name="178"/>   end
<a name="179"/>
<a name="180"/>   private static create_path(n, anchor, si)
<a name="181"/>      local p1, p2, res, el
<a name="182"/>
<a name="183"/>      res := []
<a name="184"/>      p1 := path_to_root(n)
<a name="185"/>
<a name="186"/>      if \anchor then {
<a name="187"/>         p2 := copy(anchor.path)
<a name="188"/>         while p1[1] === p2[1] do {
<a name="189"/>            pop(p1)
<a name="190"/>            pop(p2)
<a name="191"/>         }
<a name="192"/>
<a name="193"/>         if is(anchor, AnchorString) then
<a name="194"/>            put(res, AnchorStringCmd(anchor.str))
<a name="195"/>         else
<a name="196"/>            put(res, AnchorTagCmd(anchor.name, anchor.attrs))
<a name="197"/>
<a name="198"/>         put(res, UpCmd(0 &lt; *p2))
<a name="199"/>      } else {
<a name="200"/>         put(res, RootCmd())
<a name="201"/>         pop(p1)
<a name="202"/>      }
<a name="203"/>
<a name="204"/>      every el := !p1 do
<a name="205"/>         put(res, TagCmd(get_tag_index(el), el.name))
<a name="206"/>
<a name="207"/>      if \si then
<a name="208"/>         put(res, StringCmd(si))
<a name="209"/>
<a name="210"/>      return res
<a name="211"/>   end
<a name="212"/>
<a name="213"/>   private static get_tag_index(n)
<a name="214"/>      local i, e
<a name="215"/>      i := 0
<a name="216"/>      every e := !n.parent.children do {
<a name="217"/>         if not(text(e)) &amp; is(e, Element) &amp; e.name == n.name then
<a name="218"/>            i +:= 1
<a name="219"/>         if e === n then
<a name="220"/>            return i
<a name="221"/>      }
<a name="222"/>      syserr("Couldn't find child in parent!")
<a name="223"/>   end
<a name="224"/>
<a name="225"/>   private static path_to_root(n)
<a name="226"/>      local l
<a name="227"/>      l := []
<a name="228"/>      repeat {
<a name="229"/>         push(l, n)
<a name="230"/>         n := n.parent 
<a name="231"/>         is(n, Element) | return l
<a name="232"/>      }
<a name="233"/>   end
<a name="234"/>
<a name="235"/>   private find_anchor_tag(d, name, attrs)
<a name="236"/>      local n
<a name="237"/>      every n := d.get_root_element().search_tree(name) do {
<a name="238"/>         if equals(attrs, n.attributes) then
<a name="239"/>            return n
<a name="240"/>      }
<a name="241"/>   end
<a name="242"/>
<a name="243"/>   #
<a name="244"/>   # Lookup the given scrape id in the given `HtmlDocument`.  Either
<a name="245"/>   # an `HTMLElement` or text is returned, depending on whether the
<a name="246"/>   # scrape directive was a tag attribute, or part of a text content
<a name="247"/>   # in the template.
<a name="248"/>   #
<a name="249"/>   # :Parameters :
<a name="250"/>   # :  `d` - An `HtmlDocument`.
<a name="251"/>   # :  `id` - The particular scrape id, corresponding to one of the
<a name="252"/>   #           ids in the template.
<a name="253"/>   public lookup(d, id)
<a name="254"/>      local l, n, e
<a name="255"/>
<a name="256"/>      # The string type of the template and subject must match for AnchorTagCmd to work
<a name="257"/>      # properly (equals on two attribute tables).
<a name="258"/>      type(d.get_root_element().name) == type(key(paths)\1) | runerr("WebScraper string type mismatch between template and subject")
<a name="259"/>
<a name="260"/>      l := member(paths, id) | return error("Unknown id:" || id)
<a name="261"/>
<a name="262"/>      every e := !l do {
<a name="263"/>         if \debug_flag then
<a name="264"/>            ewrite("Command: ", to_string(e))
<a name="265"/>
<a name="266"/>         case classof(e) of {
<a name="267"/>            RootCmd : {
<a name="268"/>               n := d.get_root_element()
<a name="269"/>            }
<a name="270"/>            AnchorStringCmd : {
<a name="271"/>               n := d.find_string(e.str) | return error("While looking up " || 
<a name="272"/>                                                        id || ": Couldn't find anchor string: " || e.str)
<a name="273"/>            }
<a name="274"/>            AnchorTagCmd : {
<a name="275"/>               n := find_anchor_tag(d, e.name, e.attrs) | return error("While looking up " || 
<a name="276"/>                                                                       id || ": Couldn't find anchor tag: " || e.name || " and " || *e.attrs || " attrs")
<a name="277"/>            }
<a name="278"/>            UpCmd : {
<a name="279"/>               every 1 to e.n do {
<a name="280"/>                  n := n.parent
<a name="281"/>                  is(n, Element) | return error("While looking up " || 
<a name="282"/>                                                id || ":  Couldn't go up " || e.n || " levels")
<a name="283"/>               }
<a name="284"/>            }
<a name="285"/>            TagCmd : {
<a name="286"/>               n := n.get_nth_element(e.n, e.name) | return error("While looking up " || 
<a name="287"/>                                                                  id || ": Tag " || e.name || " not found, n=" || e.n || ".")
<a name="288"/>            }
<a name="289"/>            StringCmd : {
<a name="290"/>               n := n.get_nth_string(e.n) | return error("While looking up " || 
<a name="291"/>                                                         id || ": String at " || e.n || " not found.")
<a name="292"/>            }
<a name="293"/>            default : syserr("Unknown command")
<a name="294"/>         }
<a name="295"/>
<a name="296"/>         if \debug_flag then {
<a name="297"/>            if is(n, Element) then
<a name="298"/>               ewrite("OK: Now at ", n.name, " ", to_string(n.attributes))
<a name="299"/>            else
<a name="300"/>               ewrite("OK: Now at ", image(n))
<a name="301"/>         }
<a name="302"/>      }
<a name="303"/>      return n
<a name="304"/>   end
<a name="305"/>
<a name="306"/>   #
<a name="307"/>   # Return an instance with template in the given file.
<a name="308"/>   # :Parameters :
<a name="309"/>   # :  `fn` - the filename.
<a name="310"/>   #
<a name="311"/>   public static from_file(fn)
<a name="312"/>      return WebScraper(Files.file_to_string(fn))
<a name="313"/>   end
<a name="314"/> 
<a name="315"/>   # Return an instance with template in the given file, which is
<a name="316"/>   # first converted to a ucs string.
<a name="317"/>   # :Parameters :
<a name="318"/>   # :  `fn` - the filename.
<a name="319"/>   #
<a name="320"/>   public static from_ucs_file(fn)
<a name="321"/>      local s
<a name="322"/>      s := Files.file_to_string(fn) | fail
<a name="323"/>      s := ucs(s) | return error("File not UTF-8")
<a name="324"/>      return WebScraper(s)
<a name="325"/>   end
<a name="326"/>end
<a name="327"/>
</pre></body></html>
