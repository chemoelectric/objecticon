package ipl.termdialog

import
   gui, io, graphics, util

class TermTextField(TextField)
   public keeps(e)
      return member(Key.CURSOR, e.code)
   end
end

class TermEditableTextList(EditableTextList)
   private on_word_wrap(ev, src)
      set_wrap_mode(if src.is_checked() then "width" else "off")
   end

   public create_context_menu(e)
      local m
      m := TextContextMenu(self)
      m.add(MenuSeparator()).
         add(CheckBoxMenuItem().
             set_label("Word wrap").
             set_is_checked(Flag{ wrap_mode === "width" }).
             connect(on_word_wrap, Event.ACTION)).
         add(TextMenuItem().
               set_label("Clear").
               connect(create set_contents([u""]), Event.ACTION)).
         add(TextMenuItem().
             set_label("Quit").
             set_label_right("^Q").
             connect(create parent_dialog.dispose(), Event.ACTION))
      return m.tidy()
   end

end

class TermDialog(Dialog, LineBasedOutputStream)
   private
      input,
      log_limit,
      history_limit,
      history,
      history_start_no,
      hpos,
      hmod,
      text
   private readable
      line

   public close()
      return self
   end

   protected write_line_impl(s)
      text.log([ucs(s)], log_limit)
      return
   end

   public set_log_limit(n)
      self.log_limit := n
      return self
   end

   public set_history_limit(n)
      self.history_limit := n
      limit_history()
      return self
   end

   public set_history(l)
      self.history := l
      self.history_start_no := 1
      limit_history()
      return self
   end

   public get_history()
      return .history
   end

   public get_history_item(n)
      return .history[0 < n - history_start_no + 1]
   end

   public get_history_start_no()
      return .history_start_no
   end

   private move_hist(n)
      local subj
      subj := input.get_contents()
      (subj == ucs(history[hpos])) | (hmod[hpos] := subj)
      hpos +:= n
      subj := \hmod[hpos] | ucs(history[hpos]) | u"?? bad utf8 in history"
      input.set_contents(subj)
   end

   private limit_history()
      while *history > \history_limit do {
         pop(history)
         history_start_no +:= 1
      }
   end

   public component_setup()
      reset_term()
   end

   public end_dialog()
   end

   public init_dialog()
   end

   public get_term_width()
      return (text.predict_view_width(text.w, 1) - 2 * Gui.TEXT_INSET) / text.cbwin.text_width("m")
   end

   public new()
      Dialog.new()
      LineBasedOutputStream.new()
      history := []
      history_start_no := 1
      log_limit := 600
      self.setup()
      return
   end

   private reset_term()
      hpos := *history + 1
      hmod := table()
      input.set_contents(u"")
   end

   private on_input(ev)
      line := input.get_contents()
      if *line > 0 then {
         put(history, line)
         limit_history()
      }
      reset_term()
      fire(Event.ACTION, ev)
   end
   
   private handle_key_up(e)
      if hpos > 1 then move_hist(-1)
   end

   private handle_key_down(e)
      if hpos <= *history then move_hist(1)
   end

   private handle_history_recall(ev)
      input.assign_contents(get_history_item(integer(input.get_contents())), ev)
   end

   private on_input_key(ev)
      case ev.code of {
         Key.UP : handle_key_up(ev)
         Key.DOWN : handle_key_down(ev)
         "\^p": handle_history_recall(ev)
      }
   end

   private on_close_button(ev)
      dispose()
   end

   private on_icon_event(ev)
      if ev.code === "\^q" then 
         dispose()
   end

   private setup()
      local layout_1
      self.set_resize(&yes)
      self.set_size(scale(735), scale(510))
      text := TermEditableTextList().
         set_size(scale(465), scale(256)).
         set_font("fixed").
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("y_fill", &yes).
         set_constraint("y_weight", 1.0).
         set_contents([u""]).
         set_is_editable(&no)
      self.add(text)
      input := TermTextField().
         set_size(scale(458)).
         clear_constraints().
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         connect(self.on_input, Event.ACTION).
         connect(self.on_input_key, Event.KEY_PRESS).
         set_contents(u"")
      self.add(input)
      self.connect(self.on_close_button, Event.WINDOW_CLOSE_BUTTON)
      self.connect(self.on_icon_event, Event.ICON)
      layout_1 := GridLayout().
         set_extra("cells")
      self.set_layout(layout_1)
      self.set_focus(input.find_focus())
   end
end

### Ivib-v2 layout: layouts/$.layout
