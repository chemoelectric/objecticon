package plan9

import io, lang, util, exception

record RAttach(tag, qid)
record RAuth(tag, aqid)
record RClunk(tag)
record RCreate(tag, qid, iounit)
record RError(tag, ename)
record RFlush(tag)
record ROpen(tag, qid, iounit)
record RRead(tag, data)
record RRemove(tag)
record RStat(tag, stat)
record RVersion(tag, msize, version)
record RWalk(tag, wqid)
record RWrite(tag, count)
record RWstat(tag)
record TAttach(tag, fid, afid, uname, aname)
record TAuth(tag, afid, uname, aname)
record TClunk(tag, fid)
record TCreate(tag, fid, name, perm, mode)
record TFlush(tag, oldtag)
record TOpen(tag, fid, mode)
record TRead(tag, fid, offset, count)
record TRemove(tag, fid)
record TStat(tag, fid)
record TVersion(tag, msize, version)
record TWalk(tag, fid, newfid, wname)
record TWrite(tag, fid, offset, data)
record TWstat(tag, fid, stat)

record Tinvalid()

record Info(mode, atime, mtime, length, name, uid, gid, muid)
record Qid(type, version, path)

class File9P()
   private readable
      parent,
      name,
      perm,
      qversion,
      qpath,
      atime,
      mtime,
      uid,
      gid,
      muid,
      fixed

   private static 
      qpath_seq, user
      
   private static init()
      qpath_seq := 0
      user := Files.file_to_string("/env/user") | "none"
   end

   public defer get_length()
   public defer set_length(len)

   public modified(uid)
      self.qversion +:= 1
      self.muid := uid
      self.mtime := Time.get_system_seconds()
      return self
   end

   public open(mode)
   end

   public close()
   end

   public path_unreferenced()
   end

   public get_parent()
      return .\self.parent
   end

   public get_info()
      return Info(perm, atime, mtime, get_length(), name, uid, gid, muid)
   end

   public set_info(x)
      if \fixed & (\x.mode | \x.mtime | \x.gid) then throw("permission denied")
      set_perm(\x.mode)
      set_mtime(\x.mtime)
      set_name(\x.name)
      set_length(\x.length)
      set_gid(\x.gid)
      return self
   end

   package set_parent(x)
      self.parent := x
      return self
   end

   public set_name(x)
      if \parent & (\self.name ~== x) then
         parent.rename_child(self, x)
      self.name := x
      return self
   end

   public set_fixed_perm(x)
      return set_perm(x, &yes)
   end

   public set_perm(x, y)
      iand(perm, Mode9.DMDIR) = iand(x, Mode9.DMDIR) | runerr("Cannot change directory bit")
      self.perm := x
      self.fixed := y
      return self
   end

   public set_qversion(x)
      self.qversion := x
      return self
   end

   public set_mtime(x)
      self.mtime := x
      return self
   end

   public set_atime(x)
      self.atime := x
      return self
   end

   public set_uid(x)
      self.uid := x
      return self
   end

   public set_gid(x)
      self.gid := x
      return self
   end

   public set_muid(x)
      self.muid := x
      return self
   end

   public get_qid()
      return Qid(ishift(perm, -24), qversion, qpath)
   end

   public new()
      self.qversion := 0
      self.qpath := (qpath_seq +:= 1)
      self.mtime := self.atime := Time.get_system_seconds()
      self.uid := self.gid := self.muid := user
      self.perm := if is(self,Dir9P) then ior(8r777, Mode9.DMDIR) else 8r666
      return
   end
end

class Dir9P(File9P)
   public defer add_child(x)
   public defer delete_child(x)
   public defer get_child(x)
   package defer rename_child(x, s)
   public defer gen_children()
   public defer create_child(name, uid, perm)
   public defer is_empty()
end

class Dir9PImpl(Dir9P)
   private
      ent

   public add_child(x)
      \x.name | runerr("Child name not set")
      (/ent[x.name] := x) | runerr("Can't add child named " || x.name || " - already exists")
      x.set_parent(self)
      return self
   end

   public delete_child(x)
      delete(ent, x.name)
      x.set_parent()
      return self
   end

   public get_child(x)
      return .\ent[x]
   end

   public gen_children()
      suspend .!ent
   end

   public is_empty()
      return *ent = 0
   end

   package rename_child(x, s)
      /ent[s] | runerr("Can't change name to " || s || " - already exists")
      delete(ent, x.name)
      ent[s] := x
      return self
   end

   protected new_dir_child(name, uid, perm)
      return Dir9PImpl("name=",name, 
                       "uid=",uid,
                       "muid=",uid,
                       "gid=",self.gid,
                       "perm=",iand(perm, ior(icom(8r777), iand(self.perm, 8r777))))
   end

   protected new_regular_child(name, uid, perm)
      return Regular9PImpl("name=",name, 
                           "uid=",uid,
                           "muid=",uid,
                           "gid=",self.gid,
                           "perm=",iand(perm, ior(icom(8r666), iand(self.perm, 8r666))))
   end

   public create_child(name, uid, perm)
      local n
      n := if iand(perm, Mode9.DMDIR) = 0 then
         new_regular_child(name, uid, perm)
      else
         new_dir_child(name, uid, perm)
      add_child(n)
      return n
   end

   public get_length()
      return 0
   end

   public set_length(len)
      return self
   end

   public new()
      cast(self,Dir9P).new()
      ent := table()
      return
   end
end

class Regular9P(File9P)
   public defer write(s, pos)
   public defer read(pos, count)
   public defer set_length(len)
end

class Regular9PImpl(Regular9P)
   private readable
      data

   public open(mode)
      if iand(self.perm, Mode9.DMAPPEND) = 0 &
         iand(mode, FileOpt9.OTRUNC) ~= 0 then
         data := ""
      return self
   end

   public set_length(len)
      if len > *data then
         data ||:= repl("\0", len - *data)
      else
         data := data[1+:len]
      return self
   end

   public write(s, pos)
      if iand(self.perm, Mode9.DMAPPEND) = 0 then {
         if pos > *data then
            data ||:= repl("\0", pos - *data - 1) || s
         else
            data[pos:min(pos + *s, *data + 1)] := s
      } else
         data ||:= s
      return self
   end

   public read(pos, count)
      if pos > *data then
         return ""
      else
         return data[pos:min(pos + count, *data + 1)]
   end

   public get_length()
      return *data
   end

   public set_data(s)
      data := s
      return self
   end

   public new()
      cast(self,Regular9P).new()
      data := ""
      return
   end
end

class Comms9P()
   public static const
      Tversion,
      Tauth,
      Tattach,
      Tflush,
      Twalk,
      Topen,
      Tcreate,
      Tread,
      Twrite,
      Tclunk,
      Tremove,
      Tstat,
      Twstat,
      Rversion,
      Rauth,
      Rattach,
      Rerror,
      Rflush,
      Rwalk,
      Ropen,
      Rcreate,
      Rread,
      Rwrite,
      Rclunk,
      Rremove,
      Rstat,
      Rwstat,
      AEXEC,
      AWRITE,
      AREAD,
      MAX_32,
      MAX_64

   private static init()
      Tversion :=     100
      Rversion :=     101
      Tauth :=        102
      Rauth :=        103
      Tattach :=      104
      Rattach :=      105
      Rerror :=       107
      Tflush :=       108
      Rflush :=       109
      Twalk :=        110
      Rwalk :=        111
      Topen :=        112
      Ropen :=        113
      Tcreate :=      114
      Rcreate :=      115
      Tread :=        116
      Rread :=        117
      Twrite :=       118
      Rwrite :=       119
      Tclunk :=       120
      Rclunk :=       121
      Tremove :=      122
      Rremove :=      123
      Tstat :=        124
      Rstat :=        125
      Twstat :=       126
      Rwstat :=       127

      AEXEC :=        1
      AWRITE :=       2
      AREAD :=        4

      MAX_32 :=       16rffffffff
      MAX_64 :=       16rffffffffffffffff
   end

   public static int_to_bytes(n, w)
      local s
      s := ""
      every 1 to w do {
         s ||:= char(iand(n, 255))
         n := ishift(n, -8)
      }
      return s
   end

   public static bytes_to_int(s)
      local n, ch
      n := 0
      every ch := back(s) do
         n := ishift(n, 8) + ord(ch)
      return n
   end

   public static encode_qid(q)
      return int_to_bytes(q.type, 1) || 
         int_to_bytes(q.version, 4) || 
         int_to_bytes(q.path,8)
   end

   public static encode_stat(qid, info)
      local s
      s := "\0\0\0\0\0\0" || 
         encode_qid(qid) || 
         int_to_bytes(info.mode, 4) ||
         int_to_bytes(info.atime, 4) || 
         int_to_bytes(info.mtime, 4) || 
         int_to_bytes(info.length, 8) ||
         int_to_bytes(*info.name, 2) || info.name ||
         int_to_bytes(*info.uid, 2) || info.uid ||
         int_to_bytes(*info.gid, 2) || info.gid ||
         int_to_bytes(*info.muid, 2) || info.muid
      return int_to_bytes(*s, 2) || s
   end

   public static decode_wstat(s)
      local i, t
      i := Info()
      s ? {
         move(21) | fail          # tab past qid
         t := get_int4() | fail
         if t ~= MAX_32 then i.mode := t
         t := get_int4() | fail
         if t ~= MAX_32 then i.atime := t
         t := get_int4() | fail
         if t ~= MAX_32 then i.mtime := t
         t := get_int8() | fail
         if t ~= MAX_64 then i.length := t
         t := get_data_len2() | fail
         if *t > 0 then i.name := t
         t := get_data_len2() | fail
         if *t > 0 then i.uid := t
         t := get_data_len2() | fail
         if *t > 0 then i.gid := t
         t := get_data_len2() | fail
         if *t > 0 then i.muid := t
      }
      return i
   end

   public static encode_int4(n)
      return int_to_bytes(n, 4)
   end

   public static encode_int2(n)
      return int_to_bytes(n, 2)
   end

   public static encode_data_len2(s)
      return encode_int2(*s) || s
   end

   public static encode_data_len4(s)
      return encode_int4(*s) || s
   end

   public static get_int8()
      return bytes_to_int(move(8))
   end

   public static get_int4()
      return bytes_to_int(move(4))
   end

   public static get_int2()
      return bytes_to_int(move(2))
   end

   public static get_int1()
      return ord(move(1))
   end

   public static get_data_len2()
      return move(get_int2())
   end

   public static get_data_len4()
      return move(get_int4())
   end

   public static get(f)
      local s, size, body
      s := f.reads(4) | fail
      size := (s ? get_int4()) - 4 | return Tinvalid()
      body := f.reads(size) | fail
      return decode_body(body) | Tinvalid()
   end

   public static decode_body(body)
      local type, f1, f2, f3, f4, tag, n
      body ? {
         type := ord(move(1)) | fail
         tag := get_int2() | fail
         case type of {
            Tversion: {
               f1 := get_int4() | fail
               f2 := get_data_len2() | fail
               pos(0) | fail
               return TVersion(tag, f1, f2)
            }
            Tauth: {
               f1 := get_int4() | fail    # afid
               f2 := get_data_len2() | fail    # uname
               f3 := get_data_len2() | fail    # aname
               pos(0) | fail
               return TAuth(tag, f1, f2, f3)
            }
               
            Tattach: {
               f1 := get_int4() | fail    # fid
               f2 := get_int4() | fail    # afid
               f3 := get_data_len2() | fail    # uname
               f4 := get_data_len2() | fail    # aname
               pos(0) | fail
               return TAttach(tag, f1, f2, f3, f4)
            }

            Tflush: {
               f1 := get_int2() | fail     # oldtag
               pos(0) | fail
               return TFlush(tag, f1)
            }

            Twalk: {
               f1 := get_int4() | fail    # fid
               f2 := get_int4() | fail    # newfid
               n := get_int2() | fail     # nwname
               f3 := []
               every 1 to n do
                  put(f3, get_data_len2()) | fail
               pos(0) | fail
               return TWalk(tag, f1, f2, f3)
            }

            Topen: {
               f1 := get_int4() | fail    # fid
               f2 := get_int1() | fail    # mode
               pos(0) | fail
               return TOpen(tag, f1, f2)
            }

            Tcreate: {
               f1 := get_int4() | fail    # fid
               f2 := get_data_len2() | fail    # name
               f3 := get_int4() | fail    # perm
               f4 := get_int1() | fail    # mode
               pos(0) | fail
               return TCreate(tag, f1, f2, f3, f4)
            }

            Tread: {
               f1 := get_int4() | fail    # fid
               f2 := get_int8() | fail    # offset
               f3 := get_int4() | fail    # count
               pos(0) | fail
               return TRead(tag, f1, f2, f3)
            }

            Twrite: {
               f1 := get_int4() | fail    # fid
               f2 := get_int8() | fail    # offset
               f3 := get_data_len4() | fail    # data
               pos(0) | fail
               return TWrite(tag, f1, f2, f3)
            }

            Tclunk: {
               f1 := get_int4() | fail    # fid
               pos(0) | fail
               return TClunk(tag, f1)
            }
            Tremove: {
               f1 := get_int4() | fail    # fid
               pos(0) | fail
               return TRemove(tag, f1)
            }

            Tstat: {
               f1 := get_int4() | fail    # fid
               pos(0) | fail
               return TStat(tag, f1)
            }

            Twstat: {
               f1 := get_int4() | fail         # fid
               f2 := get_data_len2() | fail    # stat
               pos(0) | fail
               return TWstat(tag, f1, f2)
            }

            default: fail
         }
      }
   end

   public static encode(x)
      local s
      case classof(x) of {
         RVersion: {
            return encode_int4(13 + *x.version) ||
               char(Rversion) ||
               encode_int2(x.tag) ||
               encode_int4(x.msize) ||
               encode_data_len2(x.version)
         }

         RAttach: {
            return encode_int4(20) ||
               char(Rattach) ||
               encode_int2(x.tag) ||
               x.qid
         }

         RAuth: {
            return encode_int4(20) ||
               char(Rauth) ||
               encode_int2(x.tag) ||
               x.aqid
         }

         RClunk: {
            return encode_int4(7) ||
               char(Rclunk) ||
               encode_int2(x.tag)
         }

         RFlush: {
            return encode_int4(7) ||
               char(Rflush) ||
               encode_int2(x.tag)
         }

         RRemove: {
            return encode_int4(7) ||
               char(Rremove) ||
               encode_int2(x.tag)
         }

         RWstat: {
            return encode_int4(7) ||
               char(Rwstat) ||
               encode_int2(x.tag)
         }

         RError: {
            return encode_int4(9 + *x.ename) ||
               char(Rerror) ||
               encode_int2(x.tag) ||
               encode_data_len2(x.ename)
         }

         RWalk: {
            s := encode_int4(9 + 13 * *x.wqid) ||
               char(Rwalk) ||
               encode_int2(x.tag) ||
               encode_int2(*x.wqid)
            every s ||:= !x.wqid
            return s
         }

         RCreate: {
            return encode_int4(24) ||
               char(Rcreate) ||
               encode_int2(x.tag) ||
               x.qid ||
               encode_int4(x.iounit)
         }

         ROpen: {
            return encode_int4(24) ||
               char(Ropen) ||
               encode_int2(x.tag) ||
               x.qid ||
               encode_int4(x.iounit)
         }

         RWrite: {
            return encode_int4(11) ||
               char(Rwrite) ||
               encode_int2(x.tag) ||
               encode_int4(x.count)
         }

         RRead: {
            return encode_int4(11 + *x.data) ||
               char(Rread) ||
               encode_int2(x.tag) ||
               encode_data_len4(x.data)
         }

         RStat: {
            return encode_int4(9 + *x.stat) ||
               char(Rstat) ||
               encode_int2(x.tag) || 
               encode_data_len2(x.stat)
         }

         default:
            runerr("Bad type to encode")
      }
   end
end

class Data9P()
   public defer get_root(aname)
   public defer get_parent(p)
   public defer get_child(p, name)
   public defer gen_children(p)
   public defer delete_child(p1, p2)
   public defer create_child(p, name, uid, perm)
   public defer is_empty(p)
   public defer modified(p, uid)
   public defer open(p, mode)
   public defer write(p, s, pos)
   public defer read(p, pos, count)
   public defer close(p)
   public defer get_info(p)
   public defer set_info(p, x)
   public defer get_qid(p)
   public defer path_unreferenced(p)
end

class TreeData9P(Data9P)
   private
      root

   public get_root(aname)
      return root
   end

   public get_parent(p)
      return p.get_parent()
   end

   public get_child(p, name)
      return p.get_child(name)
   end

   public gen_children(p)
      suspend p.gen_children()
   end

   public delete_child(p1, p2)
      return p1.delete_child(p2)
   end

   public create_child(p, name, uid, perm)
      return p.create_child(name, uid, perm)
   end

   public is_empty(p)
      return p.is_empty()
   end
   
   public modified(p, uid)
      return p.modified(uid)
   end

   public open(p, mode)
      p.open(mode)
   end

   public write(p, s, pos)
      p.write(s, pos)
   end

   public read(p, pos, count)
      return p.read(pos, count)
   end

   public close(p)
      p.close()
   end

   public get_info(p)
      return p.get_info()
   end

   public set_info(p, x)
      p.set_info(x)
      return self
   end

   public get_qid(p)
      return p.get_qid()
   end

   public path_unreferenced(p)
      p.path_unreferenced()
   end

   public new(root)
      self.root := root
      return
   end
end

record Fid(path, uid, omode, dir)

class Session9P()
   private
      fids,        # table mapping fid numbers to Fid() records
      data, 
      paths,       # table mapping paths to sets of fid numbers representing those paths.  So
                   # for each fid number n, n is an element of paths[fids[n].path].
      verbose

   private new_fid(n, path, uid, mode)
      fids[n] := Fid(path, uid, mode)
      (/paths[path] := set(n)) | insert(paths[path], n)
   end

   private del_fid(n)
      local x
      x := fids[n]
      delete(fids, n)
      delete(paths[x.path], n)
      if *paths[x.path] = 0 then
         delete(paths, x.path)
   end

   private is_path_open(path)
      return \fids[!paths[path]].omode
   end

   private lookup(n)
      return \fids[n] | throw("no such fid:" || n)
   end

   private check_referenced(path)
      member(paths, path) | data.path_unreferenced(path)
   end

   private path_string(path)
      local s, t, n
      s := ""
      t := path
      repeat {
         n := data.get_info(t).name
         if n == "/" then
            s := "/" || s
         else if *s = 0 then
            s := n
         else
            s := n || "/" || s
         t := data.get_parent(t) | break
      }
      return s
   end

   public dump()
      local e
      write("Fids(",*fids,")")
      every e := !sort(fids) do
         write(e[1], " -> Fid(", path_string(e[2].path), ", ", e[2].uid, ", ", if \e[2].omode then "open" else "closed", ")")
      write("Paths(",*paths,")")
      every e := !sort(paths) do {
         writes(path_string(e[1]), " -> ")
         every writes(!e[2], " ")
         write()
      }
   end

   private has_perm(info, uid, p)
      local m
      # see uid.c
      m := iand(info.mode, 7)
      if iand(p, m) = p then
         return
      if uid == info.uid then {
         m := ior(m, iand(ishift(info.mode, -6), 7))
         if iand(p, m) = p then
            return
      }
      if uid == info.gid then {
         m := ior(m, iand(ishift(info.mode, -3), 7))
         if iand(p, m) = p then
            return
      }
   end

   public respond(x)
      return try{respond_impl(x)} | RError(x.tag, &why)
   end

   private respond_impl(x)
      local o, qids, e, s, i, p, info
      case classof(x) of {
         TVersion:
            return RVersion(65535, 8216, "9P2000")
         TAttach: {
            p := data.get_root(x.aname)
            new_fid(x.fid, p, x.uname)
            return RAttach(x.tag, Comms9P.encode_qid(data.get_qid(p)))
         }
         TClunk: {
            o := lookup(x.fid)
            del_fid(x.fid)
            if \o.omode then {
               data.close(o.path)
               if iand(o.omode, FileOpt9.ORCLOSE) ~= 0 then {
                  p := data.get_parent(o.path)
                  data.delete_child(p, o.path)
                  data.modified(p, o.uid)
               }
            }
            check_referenced(o.path)
            return RClunk(x.tag)
         }
         TRemove: {
            o := lookup(x.fid)
            del_fid(x.fid)
            info := data.get_info(o.path)
            if iand(info.mode, Mode9.DMDIR) ~= 0 & not data.is_empty(o.path) then
               throw("directory not empty")
            p := data.get_parent(o.path)
            has_perm(data.get_info(p), o.uid, Comms9P.AWRITE) | throw("permission denied")
            if \o.omode then
               data.close(o.path)
            data.delete_child(p, o.path)
            data.modified(p, o.uid)
            check_referenced(o.path)
            return RRemove(x.tag)
         }
         TCreate: {
            o := lookup(x.fid)
            /o.omode | throw("fid already open")
            info := data.get_info(o.path)
            iand(info.mode, Mode9.DMDIR) ~= 0 | throw("attempt to create in a regular file")
            has_perm(info, o.uid, Comms9P.AWRITE) | throw("permission denied")
            if data.get_child(o.path, x.name) then
               throw("create with name which already exists")
            p := data.create_child(o.path, x.name, o.uid, x.perm)
            data.open(p, x.mode)
            data.modified(o.path, o.uid)
            del_fid(x.fid)
            check_referenced(o.path)
            new_fid(x.fid, p, o.uid, x.mode)
            return RCreate(x.tag, Comms9P.encode_qid(data.get_qid(p)), 0)
         }
         TOpen: {
            o := lookup(x.fid)
            /o.omode | throw("fid already open")
            info := data.get_info(o.path)
            if iand(info.mode, Mode9.DMEXCL) ~= 0 & is_path_open(o.path) > 0 then
               throw("exclusive use file already open")
            if iand(info.mode, Mode9.DMDIR) ~= 0 &
               iand(x.mode, icom(FileOpt9.ORCLOSE)) ~= FileOpt9.OREAD then
                  throw("invalid mode for opening a directory")
            i := case iand(x.mode, 3) of {
               FileOpt9.OREAD : Comms9P.AREAD
               FileOpt9.OWRITE : Comms9P.AWRITE
               FileOpt9.ORDWR : ior(Comms9P.AREAD, Comms9P.AWRITE)
               FileOpt9.OEXEC : Comms9P.AEXEC
               default: throw("strange permissions value")
            }
            if iand(x.mode, FileOpt9.OTRUNC) ~= 0 then
               i := ior(i, Comms9P.AWRITE)
            has_perm(info, o.uid, i) | throw("permission denied")
            if iand(x.mode, FileOpt9.ORCLOSE) ~= 0 then {
               p := data.get_parent(o.path)
               has_perm(data.get_info(p), o.uid, Comms9P.AWRITE) | throw("permission denied")
            }
            data.open(o.path, x.mode)
            o.omode := x.mode
            return ROpen(x.tag, Comms9P.encode_qid(data.get_qid(o.path)), 0)
         }
         TWalk: {
            o := lookup(x.fid)
            if is_path_open(o.path) then
               throw("cannot clone open fid")
            p := o.path
            qids := []
            every e := !x.wname do {
               if e == ".." then
                  p := data.get_parent(p)   # Note parent of root is root
               else 
                  p := data.get_child(p, e) | break
               put(qids, Comms9P.encode_qid(data.get_qid(p)))
            }
            if *qids = *x.wname then {
               #fids[x.newfid] := Fid(p, o.uid)
               new_fid(x.newfid, p, o.uid)
               return RWalk(x.tag, qids)
            } 
            if *qids = 0 then
               throw("file does not exist")
            return RWalk(x.tag, qids)
         }
         TWrite: {
            o := lookup(x.fid)
            (iand(\o.omode, 3) = (FileOpt9.OWRITE | FileOpt9.ORDWR)) |
               throw("write on file not open for writing")
            info := data.get_info(o.path)
            if iand(info.mode, Mode9.DMDIR) ~= 0 then
               throw("attempt to write to directory")
            data.write(o.path, x.data, x.offset + 1)
            data.modified(o.path, o.uid)
            return RWrite(x.tag, *x.data)
         }
         TRead: {
            o := lookup(x.fid)
            (iand(\o.omode, 3) = (FileOpt9.OREAD | FileOpt9.OEXEC | FileOpt9.ORDWR)) |
               throw("read on file not open for reading")
            info := data.get_info(o.path)
            if iand(info.mode, Mode9.DMDIR) ~= 0 then {
               if x.offset = 0 then {
                  o.dir := []
                  every e := data.gen_children(o.path) do
                     put(o.dir, Comms9P.encode_stat(data.get_qid(e), data.get_info(e)))
               }
               s := ""
               while *s + *o.dir[1] <= x.count do
                  s ||:= get(o.dir)
            } else
               s := data.read(o.path, x.offset + 1, x.count)
            return RRead(x.tag, s)
         }
         TStat: {
            o := lookup(x.fid)
            return RStat(x.tag, Comms9P.encode_stat(data.get_qid(o.path), data.get_info(o.path)))
         }
         TWstat: {
            o := lookup(x.fid)
            i := Comms9P.decode_wstat(x.stat)  | throw("invalid wstat data")
            info := data.get_info(o.path)
            if \i.name then {
               p := data.get_parent(o.path)
               has_perm(data.get_info(p), o.uid, Comms9P.AWRITE) | throw("permission denied")
               if data.get_child(p, i.name) then
                  throw("name already exists")
            }
            if \i.length then {
               has_perm(info, o.uid, Comms9P.AWRITE) | throw("permission denied")
               if i.length ~= 0 & iand(info.mode, Mode9.DMDIR) ~= 0 then
                  throw("cannot set length of directory to non-zero value")
            }
            if \i.mtime | \i.mode | \i.gid then {
               ((info.uid | info.gid) == o.uid) | throw("permission denied")
               if \i.mode & iand(i.mode, Mode9.DMDIR) ~= iand(info.mode, Mode9.DMDIR) then
                  throw("directory bit cannot be changed")
            }
            if \i.atime | \i.uid | \i.muid then
               throw("invalid value set in wstat")

            data.set_info(o.path, i)
            if \i.name then
               data.modified(p, o.uid)
            if \i.length then
               data.modified(o.path, o.uid)

            return RWstat(x.tag)
         }
         TFlush:
            return RFlush(x.tag)
         TAuth:
            throw("authorization not required")
         default:
            throw("unknown message type")
      }
   end

   public io(f)
      local x, y
      while x := Comms9P.get(f) do {
         if \verbose then write("GOT:", to_string(x))
         if is(x, Tinvalid) then
            next
         y := respond(x)
         if \verbose then write("SEND:",to_string(y))
         f.writes(Comms9P.encode(y)) | fail
      }
   end

   public poll(f, i)
      local x, y
      while f.length() > 0 do {
         x := Comms9P.get(f) | fail
         if \verbose then write("GOT:", to_string(x))
         if is(x, Tinvalid) then
            next
         y := respond(x)
         if \verbose then write("SEND:",to_string(y))
         f.writes(Comms9P.encode(y)) | fail
         delay(\i)
      }
   end

   public set_data(d)
      data := d
      return self
   end

   public set_verbose(x)
      self.verbose := x
      return self
   end

   public new()
      self.fids := table()
      self.paths := table()
      return
   end
end
