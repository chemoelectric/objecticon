############################################################################
#
#	File:     options.icn
#
#	Subject:  Procedure to get command-line options
#
#	Authors:  Robert J. Alexander and Gregg M. Townsend
#
#	Date:     May 5, 2000
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#	options(arg, optstring,errproc) removes command options from the
#	argument list of an Icon main procedure, returning a table of
#	option values.
#
############################################################################
#  
#     options(arg,optstring,errproc) -- Get command line options.
#
#     This procedure separates and interprets command options included in 
#  the main program argument list.  Option names and values are removed
#  from the argument list and returned in a table.
#
#     On the command line, options are introduced by a "-" character.  An
#  option name is either a single printable character, as in "-n" or "-?",
#  or a string of letters, numbers, and underscores, as in "-geometry".
#  Valueless single-character options may appear in combination, for
#  example as "-qtv".
#
#     Some options require values.  Generally, the option name is one
#  argument and the value appears as the next argument, for example
#  "-F file.txt".   However, with a single-character argument name
#  (as in that example), the value may be concatenated: "-Ffile.txt"
#  is accepted as equivalent.
#  
#     Options may be freely interspersed with non-option arguments.
#  An argument of "-" is treated as a non-option.  The special argument
#  "--" terminates option processing.  Non-option arguments are returned
#  in the original argument list for interpretation by the caller.
#
#     An argument of the form @filename (a "@" immediately followed
#  by a file name) causes options() to replace that argument with
#  arguments retrieved from the file "filename".  Each line of the file
#  is taken as a separate argument, exactly as it appears in the file.
#  Arguments beginning with - are processed as options, and those
#  starting with @ are processed as nested argument files.  An argument
#  of "--" causes all remaining arguments IN THAT FILE ONLY to be
#  treated as non-options (including @filename arguments).
#
#     The parameters of options(arg,optstring,errproc) are:
#  
#       arg         the argument list as passed to the main procedure.
#
#       optstring   a string specifying the allowable options.  This is
#		    a concatenation, with optional spaces between, of
#		    one or more option specs of the form
#			-name%
#		    where
#			-	introduces the option
#			name	is either a string of alphanumerics
#				(any of a-z, A-Z, 0-9, and _)
#				or any single printable character
#			%	is one of the following flag characters:
#				!	No value is required or allowed
#			 	:	A string value is required
#				+	An integer value is required
#				.	A real value is required
#
#		    The leading "-" may be omitted for a single-character
#		    option.  The "!" flag may be omitted except when
#		    needed to terminate a multi-character name.
#		    Thus, the following optstrings are equivalent:
#			"-n+ -t -v -q -F: -geometry: -silent"
#			"n+tvqF:-geometry:-silent"
#			"-silent!n+tvqF:-geometry:"
#
#	errproc	    a procedure which will be called if an error is
#		    is detected in the command line options.  The
#		    procedure is called with one argument:  a string
#		    describing the error that occurred.  After errproc()
#		    is called, options() immediately returns the outcome
#		    of errproc(), without processing further arguments.
#		    Already processed arguments will have been removed
#		    from "arg".  If "errproc" is omitted, stop() is
#		    called if an error is detected.
#  
#     A table is returned containing the options that were specified.
#  The keys are the specified option names.  The assigned values are the
#  data values following the options converted to the specified type.
#  A value of 1 is stored for options that accept no values.
#  The table's default value is &null.
#
#     Upon return, the option arguments are removed from arg, leaving
#  only the non-option arguments.
#  
############################################################################

package ipl.options

import
   io, lang, util, ipl.scan

record OptFormat(names, help)

class Opt()
   public const
      names, convert, multi, help, def, err

   public format()
      local f, ns, h, ph
      ns := ""
      every f := !names do
         ns ||:= "-" || f || ", "
      ns[-2:0] := ""
      h := \help | ""
      if \convert then {
         h ? {
            if ph := tab(upto('#')) then
               h := (move(1), tab(0))
            else
               ph := map(Proc.get_name(convert), &lcase, &ucase)
         }
         ns ||:= " " || ph
      }
      return OptFormat(ns, h)
   end

   public new(s, convert, help, multi, def, err)
      names := if type(s) == "list" then
         s
      else
         [s]
      self.convert := convert
      self.multi := check_flag(multi)
      self.help := help
      self.def := def
      /err := Proc.get_name(\convert)
      self.err := err
      return
   end
end

procedure options_help(opts)
   local o, t
   every o := !opts do {
      t := o.format()
      help_line(t.names, t.help)
   }
end

procedure help_line(ns, h)
   static cols
   local i
   initial
      cols := LineEditorStream.get_console_width() | 80
   if /h then {
      repeat {
         if i := backto(' ', ns, 1, cols - 5) then {
            write(ns[1:i])
            ns := ns[i:0]
         } else {
            write(ns)
            break
         }
      }
   } else {
      if *ns > 18 then
         writes(ns, "\n", repl(" ", 20))
      else
         writes(left(ns, 20))
      repeat {
         if i := backto(' ', h, 1, cols - 25) then {
            writes(h[1:i], "\n", repl(" ", 20))
            h := h[i:0]
         } else {
            write(h)
            break
         }
      }
   }
end

procedure options(arg, opts, usage, errproc)
   local f, fList, fileArg, fn, ignore, optname, opttable, p, x, 
      option, k, v, opt, opttype, convert
   #
   #  Initialize.
   #
   /errproc := stop
   option := table()
   fList := []
   opttable := table()

   if opts := text(opts) then {
      #
      #  Scan the option specification string.
      #
      opts ? {
         opts := []
         while optname := move(1) do {
            if optname == " " then next
            if optname == "-" then
               optname := tab(many(&letters ++ &digits ++ '_')) | move(1) | break
            opttype := tab(any('!:+.')) | "!"
            convert := case string(opttype) of {
               ":": string
               "+": integer
               ".": real
               default: &null
            }
            put(opts, Opt(optname, convert,, Yes{tab(any('*'))}))
         }
      }
   }

   every opt := !opts do
      every insert(opttable, string(!opt.names), opt)

   #
   #  Iterate over program invocation argument words.
   #
   while x := get(arg) do {
      if /x then ignore := &null     # if end of args from file, stop ignoring
      else if x == ("-help" | "--help") & not member(opttable, "help") then {
         /usage := "Usage: " || FilePath(&progname).get(-1) || " [OPTIONS...]"
         if usage := text(usage) then {
            write(usage)
            options_help(opts)
            exit(0)
         } else {
            usage(opts)
            fail
         }
      } else x ? {
         if ="-" & not pos(0) & /ignore then {
            if ="-" then {
               if pos(0) then
                  ignore := &yes   # ignore following args if --
               else {
                  optname := tab(upto('=') | 0)
                  if opt := member(opttable, string(optname)) then {
                     if /opt.convert then
                        v := &yes
                     else if pos(0) & (*arg = 0 | /arg[1] | any('-', arg[1])) & \opt.def then
                        v := opt.def
                     else {
                        if ="=" then
                           p := tab(0)
                        else
                           p := get(arg) | return errproc("No parameter following --" || optname)
                        v := opt.convert(p) | return errproc("--" || optname || " needs " || 
                                                             opt.err  || " parameter")
                     }
                     k := opt.names[1]
                     if /opt.multi then
                        option[k] := v
                     else {
                        /option[k] := []
                        put(option[k], v)
                     }
                  } else return errproc("Unrecognized option: --" || optname)
               }
            } else {
               tab(0) ? until pos(0) do {
                  if opt := member(opttable, string(optname := ((pos(1),tab(0)) | move(1)))) then {
                     if /opt.convert then
                        v := &yes
                     else if pos(0) & (*arg = 0 | /arg[1] | any('-', arg[1])) & \opt.def then
                        v := opt.def
                     else {
                        p := "" ~== tab(0) | get(arg) |
                           return errproc("No parameter following -" || optname)
                        v := opt.convert(p) | return errproc("-" || optname || " needs " || 
                                                             opt.err || " parameter")
                     }
                     k := opt.names[1]
                     if /opt.multi then
                        option[k] := v
                     else {
                        /option[k] := []
                        put(option[k], v)
                     }
                  } else return errproc("Unrecognized option: -" || optname)
               }
            }
         }
         #
         #  If the argument begins with the character "@", fetch option
         #  words from lines of a text file.
         #
         else if ="@" & not pos(0) & /ignore then {
            f := open(fn := tab(0)) |
               return errproc("Can't open " || fn || ": " || &why)
            fileArg := []
            while put(fileArg,read(f))
            f.close()
            push(arg)   # push null to signal end of args from file
            while push(arg,pull(fileArg))
         }
         else put(fList,x)
      }
   }
   while push(arg,pull(fList))
   return option
end
