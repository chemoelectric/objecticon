package util

import lang(Class)

#
# Succeed iff the sequence generated by {&features} contains the given
# string.
#
procedure has_feature(x)
   static s
   initial {
      s := set()
      every insert(s, &features)
   }
   return member(s, x)
end

#
# Convenient procedure to set {&why} to the given string and fail.
#
procedure error(s)
   &why := s
end

# This class just provides a simple constructor which initializes the
# instance fields in the order they were defined in the class, from
# the given parameters.  In other words, rather like a record
# constructor.  The fields in the subclass must of course be
# accessible to this class's constructor.
#
# @example
# @  class Abc(SimpleConstructor) public const a, b, c end
# @  ...
# @  x := Abc(1,2,3)  # Sets a,b,c to 1,2,3 respectively
#  
class SimpleConstructor()
   public new(a[])
      every Class.get(self, 1 to Class.get_n_instance_fields(self)) := pop(a)
      return
   end
end

# Helper function for {save_vars}.
#
procedure swap_vars(e, l)
   if *l = 1 then
      # Simple case
      !e :=: l[1]
   else {
      # Complex case.  Done in two stages (as opposed to swapping with
      # existing elements of l), so that it works okay with &subject
      # and &pos (swapping to &subject would change &pos).
      every put(l, !e)
      every !e := pop(l)
   }
   return
end

# Invoke co-expression {e}, generating its results, in such a way that
# changes to {vars} made by {e} will not be seen by the caller, and
# vice versa.
#
# @param vars a coexpression generating one or more variables.
#
# @example
# @ # Cleanup some io stuff, without affecting {&why}
# @ save_vars{ io_cleanup(), &why }
#
procedure save_vars(e, vars)
   local t
   t := []
   every put(t, !vars)
   suspend 1(|@e, swap_vars(vars, t)) do
      swap_vars(vars, t)
   every !vars := pop(t)
end

#
# A common case, having the same effect as `save_vars{..., &why}`.
#
procedure save_why(e)
   local t
   t := &why
   suspend 1(|@e, &why :=: t) do
      &why :=: t
   &why := t
end

# This function saves {&why} before evaluating {e}.  If {e} succeeds,
# {&why} is restored, and the result returned; otherwise {&why} is not
# restored and the procedure fails.
#
procedure protect_why(e)
   local t
   t := &why
   return 1(@e, &why := t)
end

#
# Utility to check for a positive integer
#
procedure check_positive_int(n)
   return (0 < integer(n)) | runerr("Positive integer expected", n)
end

