#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

import util, lang

#
# Component representing the slider area
# @p
class SliderArea(Component)
   public 
      inner_x, 
      inner_y,
      inner_w,
      inner_h, 
      slider_x,
      slider_y,
      slider_w,
      slider_h

   public display()
      Gui.style.draw_sunken_rectangle(self.cbwin, 
                                  self.inner_x, self.inner_y, 
                                  self.inner_w, self.inner_h,
                                  Gui.BORDER_WIDTH)
      self.cbwin.erase_area(self.slider_x, self.slider_y, self.slider_w, self.slider_h)
      Gui.style.draw_raised_rectangle(self.cbwin, 
                                  self.slider_x, self.slider_y, 
                                  self.slider_w, self.slider_h,
                                  Gui.BORDER_WIDTH)
   end
end


#
# This component is a slider between two set values, with optional tick marks
# and labels.
#
# @example
# @ s := Slider()
# @ s.set_pos("85%", "25%")      
# @ s.set_size(, "40%") # Width defaults for a vertical slider
# @ s.set_range(0,5)
# @ s.set_value(2)
# @ s.set_ticks(1)
# @ s.set_labels(1)
# @ s.set_snaps(1)
# @ self.add(s)
#
class Slider(Component)
   public 
      value,                   
      old_value,
      slider_down,
      slider_down_offset,
      slider_area,
      slider_pos,
      slider_area_pos,
      slider_area_size,
      is_horizontal_flag,                                
      discrete_vals,
      ticks,
      labels,
      snaps,
      ticks_pos,
      labels_pos,
      is_paging,
      increment_size,
      wheel_factor,
      hi,                                
      lo,
      repeat_ticker,
      repeat_delay


   # These values refer to a horizontal slider, the logic is backwards for a vertical one.
   public static SLIDER_W, SLIDER_H, SLIDER_INNER_H, SLIDER_TICK_H

   private static init()
      SLIDER_W := 31
      SLIDER_H := 19
      SLIDER_INNER_H := 4
      SLIDER_TICK_H := 10
   end

   #
   # Configure the orientation (default is vertical).
   #
   public set_is_horizontal(s)
      self.is_horizontal_flag := check_flag(s)
      return self
   end

   #
   # Configure so that on release after a drag, the value will snap to 
   # the nearest multiple of n.
   #
   public set_snaps(n)
      self.snaps := n
      return self
   end

   #
   # Draw ticks at the given interval
   #
   public set_ticks(n)
      self.ticks := n
      return self
   end

   #
   # Draw labels at the given interval
   #
   public set_labels(n)
      self.labels := n
      return self
   end

   #
   # Set the increment_size to increment on a click in the slider area; default is 1.
   # @param x   The increment_size
   #
   public set_increment_size(x)
      self.increment_size := x
      self.invalidate()
      return self
   end

   #
   # Get the increment_size
   #
   public get_increment_size()
      return self.increment_size
   end

   #
   # Set the wheel factor, being the number of increments to
   # move on a wheel press; by default it is set to 1.
   #
   public set_wheel_factor(n)
      self.wheel_factor := n
      return self
   end

   #
   # Get the wheel_factor
   #
   public get_wheel_factor()
      return self.wheel_factor
   end

   #
   # Set the current value
   #
   public set_value(x)
      if is_live() then {
         self.move_value(x)
         self.set_pos_from_value()
      } else 
         self.value := x
      return self
   end

   public move_value(x)
      self.value := x
      self.value <:= self.lo
      self.value >:= self.hi
   end

   #
   # Get the value.
   # @return The value
   #
   public get_value()
      return self.value
   end

   public set_pos_from_value()
      if self.hi ~= self.lo then
         self.move_slider_pos(self.slider_area_pos + integer(((self.get_value() - self.lo) * 
                                                              self.slider_area_size / (self.hi - self.lo))))
      else
         self.move_slider_pos(self.slider_area_pos)
   end

   public set_value_from_pos()
      if self.slider_area_size ~= 0 then {
         # For discrete vals, an adjustment is made so that, for example
         # the ranges where the cursor set the position might be
         # 0     1     2     3
         # 0001111112222223333
         # Without this adjustment 0 would only be in the leftmost position, which for
         # small ranges is unattractive.  For non-discrete ranges this behaviour is
         # not appropriate.
         if \self.discrete_vals then
            self.move_value(self.lo + ((self.slider_area_size / 2) + (self.hi - self.lo) * 
                                       (self.slider_pos - self.slider_area_pos)) / self.slider_area_size)
         else
            self.move_value(self.lo + ((self.hi - self.lo) * (self.slider_pos - self.slider_area_pos)) / self.slider_area_size)
      } else
         self.move_value(self.lo)
   end

   public move_slider_pos(x)
      x <:= self.slider_area_pos
      x >:= self.slider_area_pos + self.slider_area_size
      (self.slider_pos ~=== x) | fail
      self.slider_pos := x
      if /self.is_horizontal_flag then
         self.slider_area.slider_y := self.slider_pos - SLIDER_W / 2
      else
         self.slider_area.slider_x := self.slider_pos - SLIDER_W / 2
      self.slider_area.invalidate()
   end

   #
   # Set the range of the slider.  The values may
   # be integer or real.
   #
   # @param lo  The lower bound
   # @param hi  The upper bound
   #
   public set_range(lo, hi)
      self.lo := lo
      self.hi := hi
      if type(self.hi) == type(self.lo) == "integer" then
         self.discrete_vals := 1
      else
         self.discrete_vals := &null
      self.reconfigure()
      return self
   end

   public handle_lpress(e)
      start_handle(e)
      if (self.slider_area.slider_x <= e.x < self.slider_area.slider_x + self.slider_area.slider_w) & 
         (self.slider_area.slider_y  <= e.y < self.slider_area.slider_y + self.slider_area.slider_h) then {
         #
         # Click on slider; set flag and save offset between top of slider and pointer position
         #
         self.slider_down := 1
         if /self.is_horizontal_flag then
            self.slider_down_offset := e.y - self.slider_pos
         else
            self.slider_down_offset := e.x - self.slider_pos
      } else if (/self.is_horizontal_flag & (self.slider_area.y  <= e.y < self.slider_area.slider_y)) | 
         (self.slider_area.x  <= e.x < self.slider_area.slider_x) then {
         self.move_value(self.get_value() - self.increment_size)
         self.set_pos_from_value()
         start_paging(-1)
      } else  if (/self.is_horizontal_flag & 
                  (self.slider_area.slider_y + self.slider_area.slider_h <= e.y < self.slider_area.y + self.slider_area.h)) | 
         (self.slider_area.slider_x + self.slider_area.slider_w  <= e.x < self.slider_area.x + self.slider_area.w) then {
         self.move_value(self.get_value() + self.increment_size)
         self.set_pos_from_value()
         start_paging(1)
      }
      end_handle(e)
   end

   public handle_lrelease(e)
      start_handle(e)
      if \self.slider_down then {
         #
         # Released; clear flag
         #
         self.slider_down := &null
         if \self.snaps then {
            self.value +:= self.snaps / 2
            self.set_value(self.value - (self.value % snaps))
         }
      } 
      stop_paging()
      end_handle(e)
   end

   public repeat_tick()
      repeat {
         if Prog.get_runtime_millis() > self.repeat_delay then {
            start_handle()
            self.move_value(self.get_value()  + self.is_paging * self.increment_size)
            self.set_pos_from_value()
            end_handle()
         }
         repeat_ticker.sleep(Gui.REPEAT_RATE)
      }
   end

   public start_paging(n)
      self.is_paging := n
      self.repeat_delay := Prog.get_runtime_millis() + Gui.REPEAT_DELAY
      repeat_ticker.start()
   end

   public stop_paging()
      self.is_paging := &null
      repeat_ticker.stop()
   end

   public handle_ldrag(e)
      \self.slider_down | fail

      start_handle(e)
      #
      # Slider dragged; compute new position
      #
      if /self.is_horizontal_flag then
         self.move_slider_pos(e.y - self.slider_down_offset)
      else
         self.move_slider_pos(e.x - self.slider_down_offset)
      self.set_value_from_pos()
      end_handle(e)
   end

   public handle_wheel_up(e)
      start_handle(e)
      self.move_value(self.get_value() - self.wheel_factor * self.increment_size)
      self.set_pos_from_value()
      end_handle(e)
   end

   public handle_wheel_down(e)
      start_handle(e)
      self.move_value(self.get_value() + self.wheel_factor * self.increment_size)
      self.set_pos_from_value()
      end_handle(e)
   end

   public start_handle(ev)
      old_value := value
   end

   public end_handle(ev)
      if old_value ~=== value then
         fire(Event.VALUE_CHANGED, ev)
   end

   public reconfigure()
      # Don't do anything if we haven't called resized yet.
      is_live() | fail
      self.move_value(self.value)
      self.set_pos_from_value()
      self.invalidate()
   end

   public get_default_width()
      local w
      if /self.is_horizontal_flag then {
         w := SLIDER_H + border.get_total_width()
         if \self.labels then
            w +:= self.cbwin.text_width(self.hi) + Gui.X_INSET
         if \self.ticks then
            w +:= SLIDER_TICK_H + Gui.X_INSET
         return w
      }
   end

   public get_default_height()
      local h
      if \self.is_horizontal_flag then {
         h := SLIDER_H + border.get_total_height()
         if \self.labels then
            h +:= self.cbwin.get_font_height() + Gui.Y_INSET
         if \self.ticks then
            h +:= SLIDER_TICK_H + Gui.Y_INSET
         return h
      }
   end

   public layout()
      self.labels_pos := self.ticks_pos := &null
      if /self.is_horizontal_flag then {
         if \self.labels then
            labels_pos := self.x + border.get_l_inset() + SLIDER_H + Gui.X_INSET
         if \self.ticks then {
            ticks_pos := self.x + border.get_l_inset() + SLIDER_H + Gui.X_INSET
            \labels_pos +:= SLIDER_TICK_H + Gui.X_INSET
         }
         slider_area.x := self.x + border.get_l_inset()
         slider_area.y := self.y + border.get_t_inset()
         slider_area.w := SLIDER_H
         slider_area.h := self.h - border.get_total_height()
         slider_area.inner_x := slider_area.x + slider_area.w / 2 - SLIDER_INNER_H  / 2
         slider_area.inner_y := slider_area.y + SLIDER_W / 2
         slider_area.inner_w := SLIDER_INNER_H
         slider_area.inner_h := slider_area.h - SLIDER_W
         slider_area.slider_x := slider_area.x
         slider_area.slider_h := SLIDER_W
         slider_area.slider_w := SLIDER_H
         slider_area_pos := slider_area.inner_y
         slider_area_size := slider_area.inner_h
      } else {
         if \self.labels then
            labels_pos := self.y + border.get_t_inset() + SLIDER_H + 
                              Gui.Y_INSET + self.cbwin.get_font_height() / 2
         if \self.ticks then {
            ticks_pos := self.y + border.get_t_inset() + SLIDER_H + Gui.Y_INSET
            \labels_pos +:= SLIDER_TICK_H + Gui.Y_INSET
         }
         slider_area.x := self.x + border.get_l_inset()
         slider_area.y := self.y + border.get_t_inset()
         slider_area.w := self.w - border.get_total_width()
         slider_area.h := SLIDER_H
         slider_area.inner_x := slider_area.x + SLIDER_W  / 2
         slider_area.inner_y := slider_area.y + slider_area.h / 2 - SLIDER_INNER_H  / 2
         slider_area.inner_h := SLIDER_INNER_H
         slider_area.inner_w := slider_area.w - SLIDER_W
         slider_area.slider_y := slider_area.y
         slider_area.slider_w := SLIDER_W
         slider_area.slider_h := SLIDER_H
         slider_area_pos := slider_area.inner_x
         slider_area_size := slider_area.inner_w
      }

      reconfigure()
   end

   public shift(dx, dy)
      cast(self,Component).shift(dx, dy)
      if /self.is_horizontal_flag then {
         (\labels_pos) +:= dx
         (\ticks_pos) +:= dx
         slider_area_pos +:= dy
         slider_pos +:= dy
      } else {
         (\labels_pos) +:= dy
         (\ticks_pos) +:= dy
         slider_area_pos +:= dx
         slider_pos +:= dx
      }
      slider_area.inner_x +:= dx
      slider_area.inner_y +:= dy
      slider_area.slider_x +:= dx
      slider_area.slider_y +:= dy
   end

   public draw_ticks()
      local i, xp, yp
      if /self.is_horizontal_flag then {
         i := self.lo
         while i <= self.hi do {
            yp := self.slider_area_pos + integer(((i - self.lo) * (self.slider_area_size) / (self.hi - self.lo)))
            self.cbwin.fill_rectangle(ticks_pos, yp, SLIDER_TICK_H, 1)
            i +:= ticks
         }
      } else {
         i := self.lo
         while i <= self.hi do {
            xp := self.slider_area_pos + integer(((i - self.lo) * (self.slider_area_size) / (self.hi - self.lo)))
            self.cbwin.fill_rectangle(xp, ticks_pos, 1, SLIDER_TICK_H)
            i +:= ticks
         }
      }
   end

   public draw_labels()
      local i, xp, yp, fh
      fh := self.cbwin.get_font_height()
      if /self.is_horizontal_flag then {
         i := self.lo
         while i <= self.hi do {
            yp := self.slider_area_pos + integer(((i - self.lo) * (self.slider_area_size) / (self.hi - self.lo)))
            draw_string_ex(self.cbwin, labels_pos, yp - fh / 2, i)
            i +:= labels
         }
      } else {
         i := self.lo
         while i <= self.hi do {
            xp := self.slider_area_pos + integer(((i - self.lo) * (self.slider_area_size) / (self.hi - self.lo)))
            draw_string_ex(self.cbwin, xp - self.cbwin.text_width(i) / 2, labels_pos - fh / 2, i)
            i +:= labels
         }
      }
   end

   public initially()
      \self.value | runerr("value not set")
      if /(self.lo | self.hi) then
         runerr("range not set")
      cast(self,Component).initially()
   end

   public display()
      border.draw_rect(self.cbwin, self)

      if \self.labels then
         draw_labels()

      if \self.ticks then
         draw_ticks()

      self.display_children()
   end

   public finally()
      repeat_ticker.stop()
      cast(self,Component).finally()
   end

   public new()
      cast(self,Component).new()
      repeat_ticker := Dispatcher.new_task{repeat_tick()}
      self.slider_area := SliderArea()
      self.increment_size := 1
      self.wheel_factor := 1
      self.set_border(NullBorder())
      add(self.slider_area)
      self.slider_area.
         connect(self.handle_lpress, Event.MOUSE_LEFT_PRESS).
         connect(self.handle_ldrag, Event.MOUSE_LEFT_DRAG).
         connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE)
      connect(self.handle_wheel_up, Event.MOUSE_WHEEL_UP)
      connect(self.handle_wheel_down, Event.MOUSE_WHEEL_DOWN)
      return
   end
end
