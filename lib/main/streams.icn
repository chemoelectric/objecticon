package io

import util(error, to_flag, SetFields)

class Stream()
   public defer in(n)

   public defer out(s)

   public defer seek(offset)

   public defer tell()

   public defer get_mode()

   public defer close()

   public defer eof()

   public read()
      local s, c
      s := ""
      repeat {
         if c := in(1) then {
            if c == "\n" then {
               if s[-1] == "\r" then
                  s[-1] := ""
               return s
            } else
               s ||:= c
         } else {
            if eof() & (*s > 0) then
               return s
            else
               fail
         }
      }
   end

   public reads(n)
      local s, t
      s := ""
      while n > 0 do {
         if t := in(n) then {
            s ||:= t
            n -:= *t
         } else {
            if eof() & (*s > 0) then
               return s
            else
               fail
         }
      }
      return s
   end

   public writes(a[])
      local e, n
      every e := !a do {
         while *e > 0 do {
            n := out(e) | fail
            e := e[n + 1:0]
         }
      }
      return
   end

   public write(a[])
      local e, n
      every e := !a | "\n" do {
         while *e > 0 do {
            n := out(e) | fail
            e := e[n + 1:0]
         }
      }
      return
   end
end

class StringStream(Stream)
   private 
      f_eof,
      str,
      pos

   public in(n)
      local t, e
      f_eof := &null
      if pos > *str then {
         f_eof := 1
         return error("End of file")
      }
      e := min(pos + n, *str + 1)
      t := str[pos:e]
      pos := e
      return t
   end

   public out(s)
      local e
      if pos > *str then {
         str ||:= repl("\0", pos - *str - 1) || s
         pos := *str + 1
      } else {
         e := min(pos + *s, *str + 1)
         str[pos:e] := s
         pos +:= *s
      }
      return *s
   end

   public seek(offset)
      return if offset > 0 then
         pos := offset
      else if -offset <= *str then
         pos := *str + 1 + offset
      else
         error("Seek out of range")
   end

   public tell()
      return pos
   end

   public close()
   end

   public get_mode()
      return "rws"
   end

   public eof()
      return \.f_eof
   end

   public get_str()
      return .str
   end

   public new(str)
      /str := ""
      self.str := str
      self.pos := 1
      return
   end
end

class BufferStream(Stream, SetFields)
   private
      other,
      rpos,
      wbuff,
      wbuff_len,
      rbuff,
      flush_on_nl_flag,
      buff_size

   public set_other(other)
      self.other := other
   end

   public set_flush_on_nl(s)
      self.flush_on_nl_flag := to_flag(s)
   end

   public set_buff_size(n)
      self.buff_size := n
   end

   public read()
      local t
      flush() | fail
      repeat {
         rbuff ? {
            if t := tab(upto('\n')) then {
               t ||:= move(1)
               rbuff := tab(0)
               \rpos +:= *t
               break
            }
         }
         if *rbuff = 0 & upto('s', other.get_mode()) then
            rpos := other.tell() | fail
         rbuff ||:= other.in(buff_size) | {
            other.eof() | fail
            t := rbuff
            rbuff := ""
            rpos := &null
            break
         }
      }
      if *t = 0 then
         fail
      if t[-1] == "\n" then {
         t[-1] := ""
         if t[-1] == "\r" then
            t[-1] := ""
      }
      return t
   end

   public in(n)
      local t
      flush() | fail
      if *rbuff > 0 then {
         rbuff ? {
            t := move(n) | tab(0)
            rbuff := tab(0)
            \rpos +:= *t
         }
      } else if n < buff_size then {
         if upto('s', other.get_mode()) then
            rpos := other.tell() | fail
         rbuff := other.in(buff_size) | fail
         rbuff ? {
            t := move(n) | tab(0)
            rbuff := tab(0)
            \rpos +:= *t
         }
      } else
         t := other.in(n) | fail
      return t
   end

   public out(s)
      unbuff() | fail
      put(wbuff, s)
      wbuff_len +:= *s
      if wbuff_len > buff_size | (\flush_on_nl_flag & upto('\n', s)) then
         flush() | fail
      return *s
   end

   public flush()
      local n, s
      if *wbuff = 0 then
         return
      s := ""
      every s ||:= !wbuff
      wbuff := []
      wbuff_len := 0
      while *s > 0 do {
         n := other.out(s) | fail
         s := s[n + 1:0]
      }
      return
   end

   public unbuff()
      if *rbuff > 0 & \rpos & upto('s', other.get_mode()) then {
         other.seek(rpos) | fail
         rbuff := ""
         rpos := &null
      }
      return
   end

   public synch()
      unbuff() | fail
      flush() | fail
      return
   end

   public close()
      flush() | fail
      return other.close()
   end

   public seek(offset)
      synch() | fail
      return other.seek(offset)
   end

   public tell()
      synch() | fail
      return other.tell()
   end

   public get_mode()
      return other.get_mode()
   end

   public eof()
      return other.eof()
   end

   public set_one(f)
      case f.attr of {
         "other" : set_other(f.object_val(Stream))
         "buff_size" : set_buff_size(f.int_val())
         "flush_on_nl" : set_flush_on_nl(f.flag_val())
         default: fail
      }
      return
   end

   public new(a[])
      self.rbuff := ""
      self.wbuff := []
      self.wbuff_len := 0
      self.buff_size := 1024
      set_fields(a)
      return
   end
end

class DescStream(Stream)
   protected 
      fd,
      mode,
      f_eof

   public get_fd()
      return .fd
   end

   public get_mode()
      return .mode
   end

   public eof()
      return \.f_eof
   end

   private static get_fds(l)
      local r, e
      if /l then
         return
      r := []
      every e := !l do {
         if is(e, DescStream) then
            put(r, e.get_fd())
         else
            return error("Not supported for a stream of type " || classof(e))
      }
      return r
   end

   private static filter_fds(l, il)
      local t, i, e
      if /l then
         return
      t := []
      while put(t, get(l))
      every i := !il do {
         while e := get(t) do {
            if e.get_fd() = i then {
               put(l, e)
               break
            }
         }
      }
   end

   public static select(rl, wl, el, timeout)
      local tr, tw, te, rc
      tr := get_fds(rl) | fail
      tw := get_fds(wl) | fail
      te := get_fds(el) | fail
      rc := select_impl(tr, tw, te, timeout) | fail
      filter_fds(rl, tr)
      filter_fds(wl, tw)
      filter_fds(el, te)
      return rc
   end

   public static poll(a[])
      local l, e
      l := []
      every e := !a do {
         if type(e) == "object" then {
            if is(e, DescStream) then
               put(l, e.get_fd())
            else
               return error("Not supported for a stream of type " || classof(e))
         } else
            put(l, e)
      }
      return poll_impl!l
   end

   public defer flag(on, off)

   private static defer select_impl(rl, wl, el, timeout)
   private static defer poll_impl(a[])

   protected new(fd, mode)
      self.fd := fd
      self.mode := mode
      return
   end
end

procedure open(name, mode)
   local i
   i := case mode of {
      &null | "r" : FileOpt.RDONLY
      "w" : ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT)
      "b"|"rw"|"r+" : FileOpt.RDWR
      "crw"|"w+" : ior(FileOpt.RDWR, FileOpt.TRUNC, FileOpt.CREAT)
      "a" : ior(FileOpt.WRONLY, FileOpt.APPEND, FileOpt.CREAT)
      "a+" : ior(FileOpt.RDWR, FileOpt.APPEND, FileOpt.CREAT)
      default: return error("Invalid mode flag: " || mode)
   }
   return BufferStream("other=",FileStream.open(name, i))
end

procedure popen(cmd, mode)
end

procedure ewrite(a[])
   return write!(FileStream.stderr ||| a)
end

procedure ewrites(a[])
   return writes!(FileStream.stderr ||| a)
end

procedure write(a[])
   local e, f, r, n
   r := a[-1]
   if type(a[1]) == "object" then
      f := pop(a)
   else
      f := FileStream.b_stdout
   every e := \!a | "\n" do {
      if type(e) == "object" then {
         f.out("\n")
         f := e
      } else {
         e := string(e) | runerr(103, e)
         while *e > 0 do {
            n := f.out(e) | fail
            e := e[n + 1:0]
         }
      }
   }
   return r
end

procedure writes(a[])
   local e, f, r, n
   r := a[-1]
   if type(a[1]) == "object" then
      f := pop(a)
   else
      f := FileStream.b_stdout
   every e := \!a do {
      if type(e) == "object" then {
         if f === FileStream.b_stdout then
            f.flush() | fail
         f := e
      } else {
         e := string(e) | runerr(103, e)
         while *e > 0 do {
            n := f.out(e) | fail
            e := e[n + 1:0]
         }
      }
   }
   if f === FileStream.b_stdout then
      f.flush() | fail
   return r
end

procedure stop(a[])
   every FileStream.stderr.out(string(!a) | "\n")
   exit(1)
end

procedure read(f)
   /f := FileStream.b_stdin
   return f.read()
end

procedure reads(f, n)
   /f := FileStream.b_stdin
   /n := 1
   return f.reads(n)
end

procedure close(f)
   f.close() | fail
   return f
end

class FileStream(DescStream)
   public static const
      stdin, 
      stdout,
      stderr,
      b_stdin, 
      b_stdout,
      b_stderr

   public static open(name, flags, perm)
      local mode
      if iand(flags, FileOpt.WRONLY) ~= 0 then
         mode := "w"
      else if iand(flags, FileOpt.RDWR) ~= 0 then
         mode := "rw"
      else
         mode := "r"
      mode ||:= "s"
      return FileStream(open_impl(name, flags, perm), mode)
   end

   private static defer open_impl(path, flags, perm)

   private static init()
      stdin := FileStream(0)
      stdout := FileStream(1)
      stderr := FileStream(2)
      b_stdin := BufferStream("other=",stdin, "flush_on_nl=t")
      b_stdout := BufferStream("other=",stdout, "flush_on_nl=t")
      b_stderr := BufferStream("other=",stderr, "flush_on_nl=t")
   end

   public defer in(n)

   public defer out(s)

   public defer seek(offset)

   public defer tell()

   public defer truncate(len)

   public stat()
      return Stat!stat_impl()
   end

   private defer stat_impl()

   public defer close()
end

class SocketStream(DescStream)
   public static socket(domain, typ)
      return SocketStream(socket_impl(domain, typ), "rw")
   end

   public static socketpair(typ)
      local t
      t := socketpair_impl(typ) | fail
      return [SocketStream(t[1], "rw"), SocketStream(t[2], "rw")]
   end

   public defer in(n)

   public defer connect(addr)

   public defer bind(addr)

   public defer listen(backlog)

   public accept()
      return SocketStream(accept_impl(), "rw")
   end

   private defer accept_impl()

   public defer out(s)

   public defer close()

   private static defer socketpair_impl(typ)

   private static defer socket_impl(domain, typ)
end

class DirStream(Stream)
   private 
      dd,
      line,
      f_eof

   public static open(dir)
      return DirStream(open_impl(dir))
   end

   public read()
      local t
      f_eof := &null
      if (*\line > 0) then {
         t := line[1:-1]
         line := ""
         return t
      }
      if t := read_impl(dd) then
         return t
   end

   public in(n)
      local t
      f_eof := &null
      if (*\line > 0) | (line := read_impl(dd) || "\n") then {
         line ? {
            t := move(n) | tab(0)
            line := tab(0)
         }
         return t
      }
   end

   private defer read_impl(dd)

   public defer close()

   public eof()
      return \.f_eof
   end

   public get_mode()
      return "r"
   end

   private static defer open_impl(path)

   private new(dd)
      self.dd := dd
      return
   end
end

class ProgStream(FileStream)
   private
      pid

   public static open(cmd, flags)
      local l, mode
      if iand(flags, FileOpt.WRONLY) ~= 0 then
         mode := "w"
      else
         mode := "r"
      l := open_impl(cmd, flags) | fail
      return ProgStream(l[1], l[2], mode)
   end

   public defer close()

   private static defer open_impl(cmd, flags)

   private new(fd, pid, mode)
      cast(self,FileStream).new(fd, mode)
      self.pid := pid
      return
   end
end
