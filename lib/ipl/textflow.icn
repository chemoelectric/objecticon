package ipl.browser

import 
   gui,
   util,
   graphics,
   ipl.strings

abstract class HasAscent()
   public abstract get_ascent(dw, dh)
end

abstract class HasMaxWidth()
   public abstract get_max_width()
end

abstract class TextFlowCmd()
   public const attr
   package blob_width

   public new(attr)
      self.attr := attr
      return
   end
end

class ComponentCmd(TextFlowCmd)
   public const c, align

   public new(c, attr, align)
      self.c := c
      self.attr := attr
      self.align := align
      return
   end
end

class TextCmd(TextFlowCmd)
   public const s

   public new(s, attr)
      self.s := s
      self.attr := attr
      return
   end
end

class WbrCmd(TextFlowCmd)
end

class NamedAnchorCmd(TextFlowCmd)
   public const
      name

   public new(name, attr)
      self.name := name
      self.attr := attr
      return
   end
end

class NewRowCmd(TextFlowCmd) end
class ParaCmd(TextFlowCmd) end
class SupStartCmd(TextFlowCmd) end
class SupEndCmd(TextFlowCmd) end
class SubStartCmd(TextFlowCmd) end
class SubEndCmd(TextFlowCmd) end

class BreakCmd(TextFlowCmd)
   public const clear

   public new(clear, attr)
      self.clear := clear
      self.attr := attr
      return
   end
end

class TextOut(Rect)
   public const s, attr, ascent, descent

   public new(attr, s, ascent, descent, w, h)
      self.attr := attr
      self.s := s
      self.ascent := ascent
      self.descent := descent
      self.w := w
      self.h := h
      return
   end
end

class CompOut(Rect)
   public const c, align, attr, pw, maxw
   public ascent, descent

   public set_height_from_width()
      h := c.get_preferred_height(w)
      h <:= integer(c.get_constraint("fix_h"))
      return self
   end

   public new(attr, c, align, pw, maxw)
      self.attr := attr
      self.c := c
      self.align := align
      self.pw := pw
      self.maxw := maxw
      return
   end
end

class TextSelection()
   public const textout, textflow, i, j, w_off, w_sub

   public get_bounds()
      return Rect(textflow.x + textflow.border.get_l_inset() + textout.x + w_off,
                  textflow.y + textflow.border.get_t_inset() + textflow.y_off + textout.y,
                  w_sub,
                  textout.h)
   end

   public new(textout, textflow, i, j, w_off, w_sub)
      self.textout := textout
      self.textflow := textflow
      self.i := i
      self.j := j
      self.w_off := w_off
      self.w_sub := w_sub
      return
   end
end

class OutputRow(Rect)
   public const l

   public new()
      l := []
      return
   end
end

class TextFlow(Component, HasLastHighlight)
   public const
      input

   package
      ascent_adj

   private readable
      v_align,
      y_off

   private
      left_comps,
      right_comps,
      output_comps,
      output_rows,
      computed_output_rows,
      row,
      row_x,
      row_y,
      row_bottom,
      row_width,
      row_ascent,
      first_row_ascent,
      row_descent,
      baseline_off,
      row_abs_middle_height,
      row_abs_top_height,
      row_abs_bottom_height,
      max_word_w,
      max_ll,
      calculating,
      calculated,
      need_spc,
      right_margin,
      compute_w,
      deferred,
      at_new_para,
      def_width,
      max_width,
      held,               # URL held during mouse press
      over,               # URL the mouse is over; also written to the browser's msg area
      highlight,          # URL highlighted with alink colour.
      last_highlight,
      dominant_width,
      computed_named_anchors,
      named_anchors,
      browser,
      blob_start,
      row_blob

   public static const 
      WHITESPACE,
      PREFERRED_WIDTH,
      MAX_WIDTH

   private static init()
      WHITESPACE := ' \t\r\n\v\f'
      PREFERRED_WIDTH := 1
      MAX_WIDTH := 2
   end

   private compute(width)
      local c
      # We must compute in calculating mode before computing with a particular width, in order to set the row blobs.
      if \width & /calculated then
         compute()
      /width := 16r7fffffff
      if width === compute_w then 
         return
      compute_w := width
      calculating := if width = 16r7fffffff then 1 else &null
      output_comps := []
      output_rows := []
      left_comps := []
      right_comps := []
      named_anchors := table()
      row := []
      deferred := []
      at_new_para := 1
      row_width := row_y := row_bottom := row_x := max_word_w := max_ll :=
         baseline_off := row_abs_middle_height := row_abs_top_height :=
         row_abs_bottom_height := row_ascent := row_descent := row_blob := 0
      right_margin := compute_w
      need_spc := first_row_ascent := blob_start := &null
      compute1()
      while *(row | deferred) > 0 do
         new_row()
      if \calculating then {
         # Ensure that we have cleared any left/right images, so that
         # we calculate max_ll correctly (which we only need if
         # calculating).
         until have_max() do 
            new_row()

         # Calculate default (=minimum) and max widths.
         def_width := 0
         every c := !input do
            def_width <:= \c.blob_width
         every c := !output_comps do
            def_width <:= c.pw
         def_width <:= max_word_w
         def_width +:= border.get_total_width()
         max_width := max_ll + border.get_total_width()

         calculated := 1
      }
   end

   public set_v_align(v)
      self.v_align := v
      return self
   end

   public reset_layout()
      max_width := def_width := output_rows := output_comps := left_comps :=
         calculated := named_anchors := right_comps := compute_w := &null
      every (!input).blob_width := &null
   end

   public set_dominant_width(x)
      self.dominant_width := x
      return self
   end

   public get_default_width()
      if dominant_width === MAX_WIDTH then
         return get_max_width()
      if /calculated then
         compute()
      return def_width
   end

   public get_max_width()
      if dominant_width === PREFERRED_WIDTH then
         return get_preferred_width()
      if /calculated then
         compute()
      return max_width
   end

   public get_default_height(dw)
      local mh, co
      dw -:= border.get_total_width()
      compute(dw)
      mh := row_bottom
      every co := !left_comps | !right_comps do
        mh <:= co.y + co.h
      return mh + border.get_total_height()
   end

   public get_ascent(dw)
      return get_first_row_ascent(dw) + border.t_inset
   end

   public get_first_row_ascent(dw)
      dw -:= border.get_total_width()
      compute(dw)
      return \first_row_ascent | 0
   end

   private compute1()
      local cmd, font, W
      W := cbwin.clone()
      every cmd := !input do {
         if font ~=== cmd.attr.font then {
            W.close()
            W := attr_clone(font := cmd.attr.font)
         } 
         case classof(cmd) of {
            ComponentCmd: 
               compute_component(W, cmd)
            NewRowCmd: {
               # Avoid 1-pixel gap, which would be added if *row=0
               if *row > 0 then
                  new_row()
            }
            ParaCmd: {
               if /at_new_para then {
                  new_row(W.get_font_height() / 2)
                  at_new_para := 1
               }
            }

            SupStartCmd: baseline_off +:= W.get_font_ascent() / 2
            SupEndCmd: baseline_off -:= W.get_font_ascent() / 2
            SubStartCmd: baseline_off -:= W.get_font_ascent() / 3
            SubEndCmd: baseline_off +:= W.get_font_ascent() / 3

            BreakCmd: {
               if *row > 0 then
                  new_row()
               else
                  new_row(W.get_font_height())
               case \cmd.clear of {
                  Align.L: 
                     until row_x = 0 do new_row()
                  Align.R:
                     until right_margin = compute_w do new_row()
                  "all":
                     until have_max() do new_row()
               }
            }
            NamedAnchorCmd: {
               if /calculating then
                  insert(named_anchors, string(cmd.name), row_y)
            }
            WbrCmd: {
               if /cmd.attr.nowrap & /cmd.attr.pre then
                  blob_start := &null
            }
            TextCmd: {
               if /cmd.attr.pre then {
                  if /cmd.attr.nowrap then
                     compute_txt(W, cmd)
                  else
                     compute_nowrap_txt(W, cmd)
               } else
                  compute_pre_txt(W, cmd)
            }
         }
      }
      W.close()
   end

   public lookup_named_anchor(name)
      local yp
      if yp := member(computed_named_anchors, string(name)) then
         return yp + y + border.get_t_inset() + y_off
   end

   private attr_clone(font, fg)
      local W
      W := cbwin.clone()
      W.set_font(font)
      W.set_fg(\fg)
      return W
   end

   private rows_in_range(ry, rh)
      local i, j, m, or
      # Shortcut for very common case
      if *computed_output_rows = 1 then {
         or := computed_output_rows[1]
         return if or.y + or.h > ry  &  or.y < ry + rh then or
      }
      i := 1
      j := *computed_output_rows
      while i <= j do {
         m := (i + j) / 2
         or := computed_output_rows[m]
         if or.y + or.h <= ry then
            i := m + 1
         else if or.y >= ry + rh then
            j := m - 1
         else
            break
      }
      if i > j then
         fail

      # Now row m is in the sought range; but rows before may be too,
      # so tab back as far as needed.
      while or := computed_output_rows[m - 1] &
         or.y + or.h > ry  &  or.y < ry + rh do
         m -:= 1

      # Now suspend all the rows in range from row m forwards.
      while or := computed_output_rows[m] &
         or.y + or.h > ry  &  or.y < ry + rh do
      {
         suspend or
         m +:= 1
      }
   end

   public display()
      local o, W, font, fg, x1, y1, r, t, ts, or, want_fg
      border.draw(self.cbwin, x, y, w, h)
      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      W := cbwin.clone()
      r := get_cbwin_clip()
      every or := rows_in_range(r.y - y1, r.h) do {
         every o := !or.l do {
            if is(o, TextOut) then {
               t := Rect(x1 + o.x, y1 + o.y, o.w, o.h)
               if r.intersect(t) then {
                  want_fg := if o.attr.url === \highlight then
                     browser.page_alink_color
                  else
                     o.attr.fg
                  if font ~=== o.attr.font | fg ~=== want_fg then {
                     W.close()
                     W := attr_clone(font := o.attr.font, fg := want_fg)
                  } 
                  if \o.attr.mark then
                     text_bg(W, "yellow", x1 + o.x, y1 + o.y, o.w, o.h)
                  draw_string_ex(W, x1 + o.x, y1 + o.y, o.s)

                  every ts := browser.is_searched(o) do {
                     text_bg(W, 
                             if ts === browser.highlighted_searched then "red 33%" else "purple 33%",
                             x1 + o.x + ts.w_off,
                             y1 + o.y, 
                             ts.w_sub,
                             o.h)
                  }


                  if ts := browser.is_banded(o) then
                     # NB - the rectangle used should be the same as that returned by ts.get_bounds()
                     Gui.style.fill_selection_rectangle(cbwin, 
                                                        x1 + o.x + ts.w_off,
                                                        y1 + o.y, 
                                                        ts.w_sub,
                                                        o.h)
                  if \o.attr.underline then
                     text_line(W,
                               o.s, 
                               x1 + o.x, 
                               y1 + o.y + W.get_font_ascent() + 1)
                  else if \o.attr.underdash | (o.attr.url === \last_highlight) then
                     text_dash(W,
                               o.s, 
                               x1 + o.x, 
                               y1 + o.y + W.get_font_ascent() + 1)
                  if \o.attr.strike then
                     text_line(W,
                               o.s, 
                               x1 + o.x,
                               y1 + o.y + (2 * W.get_font_ascent()) / 3)
               }
            }
         }
      }
      W.close()
      cast(self,Component).display()
   end

   private static text_bg(W, c, x, y, w, h)
      local W2
      use {
         W2 := W.clone().set_fg(c),
         W2.fill_rectangle(x, y, w, h)
      }
   end

   private static text_dash(W, s, x, y)
      local W2
      use {
         W2 := W.clone().set_masked_pattern("gray"),
         text_line(W2, s, x, y)
      }
   end

   private static text_line(W, s, x, y)
      local t, w1
      s ? repeat {
         if t := tab(many(WHITESPACE)) then
            x +:= W.text_width(t)
         if pos(0) then
            break
         t := tab(upto(WHITESPACE) | 0)
         w1 := W.text_width(t)
         W.draw_rectangle(x, y, w1, 1)
         x +:= w1
      }
   end

   public calculate_banded(br, bs)
      local d, i, u, j, or, o, W, font, x1, y1, t, first, last, first_r, last_r, l, ts
      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      l := []
      every or := rows_in_range(br.y - y1, br.h) do {
         every o := !or.l do {
            t := Rect(x1 + o.x, y1 + o.y, o.w, o.h)
            if t := br.intersect(t) then {
               if /first := o then
                  first_r := t
               last := o
               last_r := t
            }
            if \first then
               put(l, o)
         }
      }
      if /first then
         fail
      until l[-1] === last do
         pull(l)

      W := cbwin.clone()
      every o := !l do {
         case classof(o) of {
            TextOut: {
               if font ~=== o.attr.font then {
                  W.close()
                  W := attr_clone(font := o.attr.font)
               } 
               i := 1
               if o === first then {
                  d := first_r.x - x1 - o.x
                  u := 0
                  while i <= *o.s & ((.u + (u := W.text_width(o.s[1+:i]))) / 2) < d do
                     i +:= 1
               }
               if o === last then {
                  d := last_r.x - x1 - o.x + last_r.w
                  j := i
                  u := W.text_width(o.s[1:i])
                  while j <= *o.s & ((.u + (u := W.text_width(o.s[1+:j]))) / 2) < d do
                     j +:= 1
               } else
                  j := *o.s + 1

               if i < j then {
                  ts := TextSelection(o, self, 
                                      i, j, 
                                      W.text_width(o.s[1:i]), W.text_width(o.s[i:j]))
                  insert(bs, o, ts)
               }
            }
            CompOut: {
               # An image; add the Img to the banded map.  (It may be
               # inserted again by Browser.calculate_banded() if the
               # image actually intersects the band).
               insert(bs, o.c, o.c)
            }
         }
      }
      W.close()
   end

   public search(s, searched)
      local or, o, W, font, ts, i
      W := cbwin.clone()
      every or := !computed_output_rows do {
         every o := !or.l do {
            if is(o, TextOut) then {
               every i := find(s, o.s) do {
                  if font ~=== o.attr.font then {
                     W.close()
                     W := attr_clone(font := o.attr.font)
                  } 
                  ts := TextSelection(o, self, 
                                      i, i + *s, 
                                      W.text_width(o.s[1:i]), W.text_width(o.s[i+:*s]))
                  put(member(searched, o), ts) | insert(searched, o, [ts])
               }
            }
         }
      }
      W.close()
   end

   public get_selected_text(br)
      local o, x1, y1, t, or, s, sr
      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      s := u""
      every or := rows_in_range(br.y - y1, br.h) do {
         sr := u""
         every o := !or.l do {
            case classof(o) of {
               TextOut: {
                  if t := browser.is_banded(o) then
                     sr ||:= o.s[t.i:t.j]
               }
               CompOut: {
                  if browser.is_banded(o.c) then
                     sr ||:= \o.c.alt
               }
            }
         }
         if *sr > 0 then {
            if *s > 0 then
               s ||:= u"\n"
            s ||:= sr
         }
      }
      if *s > 0 then
         return s
   end

   private invalidate_url(u)
      local o, or, x1, y1, r
      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      r := get_clip_rect()
      every or := rows_in_range(r.y - y1, r.h) do {
         every o := !or.l do {
            if is(o, TextOut) & (u === \o.attr.url) then
               invalidate(Rect(x1 + o.x, y1 + o.y, o.w, o.h))
         }
      }
   end

   public calculate_link_text(t)
      local o, or, u, u2, or2
      every or := !computed_output_rows do {
         every o := !or.l do {
            if is(o, TextOut) & (u := \o.attr.url) then {
               if u === u2 & or ~=== or2 then
                  t[u] ||:= u" "
               t[u] ||:= o.s
               u2 := u
               or2 := or
            }
         }
      }
   end

   public layout()
      local co, c, x1, y1
      compute(self.w - border.get_total_width())
      y_off := case v_align of {
         "baseline": ascent_adj
         Align.T: 0
         Align.C: (h - get_default_height(w)) / 2
         Align.B: h - get_default_height(w)
         default: runerr("invalid v_align", v_align)
      }

      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      every co := !output_comps do {
         c := co.c
         c.x := co.x + x1
         c.y := co.y + y1
         c.w := co.w
         c.h := co.h
         c.layout()
      }
      computed_output_rows := output_rows
      computed_named_anchors := named_anchors 
   end

   private new_row(gap)
      local x1, r, g, need, or, row_height
      if *row > 0 then {
         x1 := row_x

         # Expand space for comps relative to absolute top
         row_descent <:= row_abs_top_height - row_ascent

         # and to absolute bottom
         row_ascent <:= row_abs_bottom_height - row_descent

         # finally absolute middle
         need := row_abs_middle_height - (row_ascent + row_descent)
         if need > 0 then {
            row_ascent +:= need / 2
            row_descent +:= need / 2 + need % 2
         }

         row_height := row_ascent + row_descent

         if /calculating then {
            put(output_rows, or := OutputRow())
            or.x := row_x
            or.y := row_y
            or.h := row_height
            or.w := row_width
         }

         row_bottom := row_y + row_height

         /first_row_ascent := row_ascent      
         while r := get(row) do {
            if /calculating & x1 = row_x then {
               case r.attr.align of {
                  Align.C:
                     x1 +:= (right_margin - row_width - row_x) / 2
                  Align.R:
                     x1 +:= right_margin - row_width - row_x
               }
            }
            case classof(r) of {
               CompOut: {
                  r.x := x1
                  r.y := case r.align of {
                     Align.C: row_y + row_ascent - r.h / 2
                     Align.B: row_y + row_ascent - r.ascent
                     Align.T: row_y
                     "absbottom": row_y + row_height - r.h
                     "absmiddle": row_y + (row_height - r.h) / 2
                     default: runerr("invalid alignment", r.align)
                  }
                  x1 +:= r.w
                  # Save images in the row for banded selection.
                  if is(r.c, Img) then
                     put((\or).l, r)
               }
               TextOut: {
                  r.x := x1
                  r.y := row_y + row_ascent - r.ascent
                  x1 +:= r.w
                  put((\or).l, r)
               }
               default: syserr("Invalid type in row")
            }
         }
         /gap := 0
         row_y +:= row_height + gap
      } else {
         /gap := 1
         row_y +:= gap
      }

      if \calculating then
         max_ll <:= compute_w - (right_margin - row_width - row_x)

      row_blob := row_width := row_abs_middle_height := row_abs_top_height := row_abs_bottom_height := row_ascent := row_descent := 0

      row_x := 0
      every g := !left_comps do
         if g.y <= row_y < g.y + g.h then
            row_x <:= g.x + g.w

      right_margin := compute_w
      every g := !right_comps do
         if g.y <= row_y < g.y + g.h then
            right_margin >:= g.x

      while do_deferred(deferred[1]) do
         pop(deferred)
   end

   # A special version of fits_in_row, used for determining if a
   # left/right aligned component will fit in the row.  The problem
   # arises in a case like :-
   #
   #    FIRST<img src="j3.jpeg" align="right"/>SECOND
   #
   # FIRST and SECOND form a blob, but row_width only includes
   # FIRST after it has been output.  Therefore fits_in_row may
   # wrongly indicate that the img would fit in the row, rather than
   # be deferred.  The solution is to set row_blob to the end of the
   # blob when FIRST is output, and use row_blob to see if the img
   # would fit.
   #
   private fits_in_row_lr(w)
      return have_max() | (row_x + w + max(row_blob, row_width) <= right_margin)
   end

   private fits_in_row(w)
      return have_max() | (row_x + w + row_width <= right_margin)
   end

   private do_deferred(co)
      # Note fits_in_row can be used since row_blob = 0.
      case co.align of {
         Align.L: {
            if fits_in_row(co.maxw) then {
               left_comp_out(co)
               return
            }
         }
         Align.R: {
            if fits_in_row(co.maxw) then {
               right_comp_out(co)
               return
            }
         }
      }
   end

   private left_comp_out(co)
      co.x := row_x
      co.y := row_y
      # Since we only do left/right_comp_out if co.maxw
      # fits_in_row_lr, we only need to reduce its width from maxw if
      # it fit because of have_max, and the available width is less
      # than maxw.
      co.w := min(co.maxw, compute_w)
      co.set_height_from_width()
      row_x +:= co.w
      put(left_comps, co)
   end

   private right_comp_out(co)
      co.w := min(co.maxw, compute_w)
      co.x := right_margin - co.w
      co.y := row_y
      co.set_height_from_width()
      right_margin -:= co.w
      put(right_comps, co)
   end

   package is_top_level()
      return self === browser.view.inner
   end

   private compute_component(W, cmd)
      local co, prefw, maxw, i
      prefw := cmd.c.get_preferred_width()
      maxw := if is(cmd.c, HasMaxWidth) then cmd.c.get_max_width() else prefw

      # Apply constraints
      if i := cmd.c.get_constraint("fix_w") then
         prefw := maxw := max(i, prefw)
      else if i := integer(cmd.c.get_constraint("pct_w")) then {
         case classof(cmd.c) of {
            Line: {
               if /calculating then
                  prefw := maxw := max(((right_margin - row_x - row_width) * i) / 100, prefw)
            }
            Img: {
               # For Img, specified widths refer to image width, excluding any border.
               if /calculating then
                  prefw := maxw := max((compute_w * i) / 100 + cmd.c.border.get_total_width(), prefw)
               else {
                  # Since prefw/maxw is set to 1 + the border width
                  # (see Img), we set it to the actual image size +
                  # the border, so the max width is calculated on that
                  # basis.
                  if not is_top_level() then
                     maxw := (\cmd.c.win).get_width() + cmd.c.border.get_total_width()
               }
            }
            Tbl: {
               if /calculating then
                  prefw := maxw := max((compute_w * i) / 100, prefw)
            }
            default: syserr("Invalid type with pct_w")
         }
      }
      co := CompOut(cmd.attr, cmd.c, cmd.align, prefw, maxw)
      put(output_comps, co)
      case cmd.align of {
         Align.L: {
            # If already have deferred, then defer this too, otherwise they will be out of order. 
            if *deferred = 0 & fits_in_row_lr(co.maxw) then
               left_comp_out(co)
            else
               put(deferred, co)
         }
         Align.R: {
            if *deferred = 0 & fits_in_row_lr(co.maxw) then 
               right_comp_out(co)
            else
               put(deferred, co)
         }
         Align.B: {
            comp_out(cmd, co)
            row_ascent <:= co.ascent
            row_descent <:= co.descent
         }
         Align.T: {
            comp_out(cmd, co)
            row_abs_top_height <:= co.h
         }
         Align.C: {
            comp_out(cmd, co)
            row_ascent <:= co.h / 2
            row_descent <:= co.h / 2 + co.h % 2
         }
         "absbottom": {
            comp_out(cmd, co)
            row_abs_bottom_height <:= co.h
         }
         "absmiddle": {
            comp_out(cmd, co)
            row_abs_middle_height <:= co.h
         }
         default: runerr("invalid alignment", cmd.align)
      }
   end

   private comp_out(cmd, co)
      local c, tw, rb
      c := co.c
      if \co.attr.pre | *row = 0 then
         need_spc := &null
      if \co.attr.nowrap | \co.attr.pre then {
         if \calculating then {
            # In nowrap/pre mode we always either start a new blob, or
            # add to the existing one.
            if (*row = 0) | /blob_start then {
               blob_start := cmd
               cmd.blob_width := co.maxw
            } else
               blob_start.blob_width +:= co.maxw + get_pad()
         } else {
            if tw := \cmd.blob_width then {
               until fits_in_row(tw + get_pad()) do {
                  new_row()
                  need_spc := &null
               }
               rb := row_width + tw + get_pad()
            }
         }
      } else {
         if \calculating then {
            # Outside of nowrap/pre mode; a component always cancels a
            # blob (so a break may occur to the left or right of an
            # image).
            blob_start := &null
         } else {
            tw := co.maxw
            until fits_in_row(tw + get_pad()) do {
               new_row()
               need_spc := &null
            }
         }
      }

      if \need_spc then {
         put(row, need_spc)
         row_width +:= need_spc.w
         row_ascent <:= need_spc.ascent
         row_descent <:= need_spc.descent
      }
      co.w := min(co.maxw, right_margin - row_x - row_width)
      co.set_height_from_width()
      co.ascent := (if is(co.c, HasAscent) then co.c.get_ascent(co.w, co.h) else co.h) + baseline_off
      co.descent := co.h - co.ascent
      put(row,  co)
      row_width +:= co.w
      row_blob := \rb
      need_spc := at_new_para := &null
   end

   private txt_out(W, attr, s, rb)
      local xo
      if \need_spc then {
         put(row, need_spc)
         row_width +:= need_spc.w
         row_ascent <:= need_spc.ascent
         row_descent <:= need_spc.descent
      }
      xo := TextOut(attr, s, 
                    W.get_font_ascent() + baseline_off, 
                    W.get_font_descent() - baseline_off, 
                    W.text_width(s), W.get_font_height())
      put(row,  xo)
      row_width +:= xo.w
      row_ascent <:= xo.ascent
      row_descent <:= xo.descent
      row_blob := \rb
      at_new_para := &null
   end

   private have_max()
      return *row = 0 & row_x = 0 & right_margin = compute_w
   end

   private make_pad(W, attr)
      return TextOut(attr, u" ",
                     W.get_font_ascent() + baseline_off, 
                     W.get_font_descent() - baseline_off, 
                     W.text_width(" "), W.get_font_height())
   end

   private get_pad()
      return (\need_spc).w | 0
   end

   private compute_txt(W, cmd)
      local ds, ds2, tw, attr, wd, l, i, rb
      attr := cmd.attr

      l := []
      every put(l, words(cmd.s, WHITESPACE))

      if *row = 0 | *l = 0 then
         need_spc := &null
      else if any(WHITESPACE, cmd.s) then 
         /need_spc := make_pad(W, attr)

      if \calculating then {
         # If we are at the start of a row, or start with whitespace,
         # then we cancel any existing blob; otherwise the first word
         # must be added to any existing blob.
         if (*row = 0) | any(WHITESPACE, cmd.s) then
            blob_start := &null
         else if \blob_start then
            # We might have need_spc here if we've just left a nobr
            # section, for example :- "<nobr>Some text </nobr>after"
            blob_start.blob_width +:= W.text_width(l[1]) + get_pad()

         # If the input ends with whitespace, then we have no blob
         # since that can give a break.  Otherwise, the last word may
         # start a new blob.  If we have >1 words, then it must since
         # that implies a space in the input.
         if any(WHITESPACE, cmd.s[-1]) then
            blob_start := &null
         else if (*l > 1) | /blob_start then {
            blob_start := cmd
            cmd.blob_width := W.text_width(l[-1])
         }
         every max_word_w <:= W.text_width(!l)
      }

      ds := u""
      i := 1
      while wd := l[i] do {
         if *ds = 0 then
            ds2 := wd
         else
            ds2 := ds || u" " || wd
         if \calculating then {
            ds := ds2
            i +:= 1
         } else {
            tw := W.text_width(ds2) + get_pad()
            #
            # The width of the last word is given by the blob width, if any.  For example, if we have
            # <u>Fred Smith</u><i>Hello</i>
            # and wd = Smith, then blob_width = len(Smith) + len(hello), tw = len(Fred Smith), and we
            # will adjust tw to = len(Fred Smith) - len(Smith) + bw = len(Fred Smith) + len(hello).
            # Thus, this corresponds to the sum of the strings we will output.
            #
            if (i = *l) & \cmd.blob_width then {
               tw -:= W.text_width(wd) - cmd.blob_width
               rb := row_width + tw
            }
            if row_x + row_width + tw > right_margin then {
               if *ds = 0 then {
                  if have_max() then {
                     txt_out(W, attr, wd)
                     i +:= 1
                  }
               } else {
                  txt_out(W, attr, ds)
                  ds := u""
               }
               new_row()
               need_spc := &null
            } else {
               ds := ds2
               i +:= 1
            }
         }
      }
      if *ds > 0 then
         txt_out(W, attr, ds, rb)

      need_spc := if any(WHITESPACE, cmd.s[-1]) then
         make_pad(W, attr)
      else
         &null
   end

    private compute_nowrap_txt(W, cmd)
      local ds, wd, tw, attr, rb
      attr := cmd.attr

      # Calculate ds being the catenation without leading space
      ds := u""
      every wd := words(cmd.s, WHITESPACE) do {
         if *ds = 0 then
            ds := wd
         else
            ds ||:= u" " || wd
      }

      if *row = 0 | *ds = 0 then
         need_spc := &null
      else if any(WHITESPACE, cmd.s) then 
         /need_spc := make_pad(W, attr)

      if \calculating then {
         # If we are starting a new blob, then the width is ds, since
         # potentially we can break to a new row.  If adding to a
         # blob, then add any pad space, since we can't break and must
         # show the space.
         if (*row = 0) | /blob_start then {
            blob_start := cmd
            cmd.blob_width := W.text_width(ds)
         } else
            blob_start.blob_width +:= W.text_width(ds) + get_pad()
      } else {
         if tw := \cmd.blob_width then {
            # The blob width gives us the width excluding any leading
            # space, so unless at start of row we must ensure we have
            # the space too.
            until fits_in_row(tw + get_pad()) do {
               new_row()
               need_spc := &null
            }
            rb := row_width + tw + get_pad()
         }
      }

      if *ds > 0 then
         txt_out(W, attr, ds, rb)

      need_spc := if any(WHITESPACE, cmd.s[-1]) then
         make_pad(W, attr)
      else
         &null
   end

   private compute_pre_txt(W, cmd)
      local s, l, i, tw, rb
      l := []
      every s := detab(separate_lines(cmd.s)) do {
         # Xft can't measure/display very long strings, so just truncate them.
         s[1000:0] := u""
         put(l, s)
      }
      need_spc := &null

      if \calculating then {
         # This follows similar logic to compute_txt above.  First,
         # cancel the current blob if we are starting a new line;
         # otherwise add the first line to any current blob.
         if *row = 0 then
            blob_start := &null
         else
            (\blob_start).blob_width +:= W.text_width(l[1])

         # Now see if we start a new blob.  If we end with a nl, then
         # no, since that starts a new row.  Otherwise start a new
         # blob, unless we have just one line and an existing blob (to
         # which the single line will have just been added).
         if cmd.s[-1] == u"\n" then
            blob_start := &null
         else if (*l > 1) | /blob_start then {
            blob_start := cmd
            cmd.blob_width := W.text_width(l[-1])
         }
         every max_word_w <:= W.text_width(!l)
      }
      every i := 1 to *l do {
         s := l[i]
         if /calculating then {
            if (i = *l) & tw := \cmd.blob_width then {
               until fits_in_row(tw) do
                  new_row()
               rb := row_width + tw 
            } else {
               tw := W.text_width(s)
               until fits_in_row(tw) do
                  new_row()
            }
         }

         txt_out(W, cmd.attr, s, rb)
         # Every element of l except the last ends in a new line
         # (recall that "abc\ndef\n" -> l=["abc","def",""])
         if i < *l then
            new_row()
      }
   end

   private which_text_out(e)
      local or, o, x1, y1
      in_region(e) | fail
      x1 := x + border.get_l_inset()
      y1 := y + border.get_t_inset() + y_off
      every or := rows_in_range(e.y - y1, 1) do {
         every o := !or.l do {
            if is(o, TextOut) & o.inside(e.x - x1, e.y - y1) then
               return o
         }
      }
   end

   private handle_lrelease(e)
      \held | fail
      if \over then {
         set_highlight()
         self.browser.link_left_clicked(over)
      }
      held := &null
   end

   private handle_mrelease(e)
      \held | fail
      if \over then {
         set_highlight()
         self.browser.link_middle_clicked(over)
      }
      held := &null
   end

   private handle_lpress(e)
      local c, t
      *parent_dialog.held = 1 | fail
      if \over then {
         set_highlight(over)
         held := over
      } else if t := which_text_out(e) then {
         if c := \ ( \ (t.attr.form_label)).comp & not c.is_shaded() then {
            parent_dialog.set_focus(c.gen_focusable(e))
            if is(c, Toggle) then
               c.on_action(e)
         }
      }
   end

   private handle_mpress(e)
      *parent_dialog.held = 1 | fail
      if \over then {
         set_highlight(over)
         held := over
      }
   end

   package wants_rpress(e)
      # Also check highlight since we may have just opened a menu,
      # clearing over and setting highlight.
      return \over | \highlight
   end

   package wants_lpress(e)
      return \over
   end

   private handle_rpress(e)
      local pm, pm_menu
      *parent_dialog.held = 1 | fail
      if pm_menu := browser.create_link_menu(\over) then {
         set_highlight(over)
         set_over()
         pm := PopupMenu()
         pm.connect(on_popup_closed, Event.POPUP_CLOSED)
         pm.popup(parent_dialog, pm_menu, e.x, e.y)
      }
   end

   private on_popup_closed()
      set_highlight()
   end

   private handle_in_chain(e)
      local u, t, a, f
      *parent_dialog.held = 0 | fail
      if e.code === (Key.SHIFT_L | Key.SHIFT_R) then {
         if /e.release then
            f := 1
      } else f := \e.shift
      t := which_text_out(e)
      a := (\t).attr.title
      set_tooltip(a)
      if /f & (u := \ (\t).attr.url) then {
         set_over(u)
         set_pointer("hand1")
      } else {
         set_over()
         set_pointer()
      }
   end

   private handle_lmdrag(e)
      \held | fail
      if \which_text_out(e).attr.url === held then {
         set_over(held)
         set_highlight(held)
      } else {
         set_over()
         set_highlight()
      }
   end

   private handle_exit(e)
      *parent_dialog.held = 0 | fail
      set_over()
   end

   private set_over(u)
      if u ~=== over then {
         over := u
         if /over then
            browser.clear_msg(self)
         else
            browser.msg(over.str(),, self)
      }
      return self
   end

   public get_last_highlight_index()
      local or, o, n, u
      n := 0
      every or := !computed_output_rows do {
         every o := !or.l do {
            if u := \o.attr.url then {
               n +:= 1
               if last_highlight === u then
                  return n
            }
         }
      }
   end

   public set_last_highlight_index(n)
      local or, o, u
      every or := !computed_output_rows do {
         every o := !or.l do {
            if u := \o.attr.url then {
               n -:= 1
               if n = 0 then {
                  last_highlight := u
                  return self
               }
            }
         }
      }
   end

   public set_last_highlight(u)
      if u ~=== last_highlight then {
         invalidate_url(\last_highlight)
         last_highlight := u
         invalidate_url(\last_highlight)
      }
      return self
   end

   private set_highlight(u)
      if u ~=== highlight then {
         browser.set_last_highlight(self, \u)
         invalidate_url(\highlight)
         highlight := u
         invalidate_url(\highlight)
      }
      return self
   end

   public new(browser)
      cast(self,Component).new()
      self.browser := browser
      set_border(NullBorder())
      input := []
      ascent_adj := 0
      v_align := Align.T
      set_constraint("x_fill", &yes)
      set_constraint("y_fill", &yes)
      set_tooltip_follows_mouse(&yes)
      connect(self.handle_lmdrag, Event.MOUSE_LEFT_DRAG)
      connect(self.handle_lmdrag, Event.MOUSE_MIDDLE_DRAG)
      connect(self.handle_mpress, Event.MOUSE_MIDDLE_PRESS)
      connect(self.handle_lpress, Event.MOUSE_LEFT_PRESS)
      connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE)
      connect(self.handle_exit, Event.MOUSE_EXIT)
      connect(self.handle_rpress, Event.MOUSE_RIGHT_PRESS)
      connect(self.handle_mrelease, Event.MOUSE_MIDDLE_RELEASE)
      connect(self.handle_in_chain, Event.IN_POINT_CHAIN)
      return
    end
end
