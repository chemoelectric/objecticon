<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>options.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     options.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedure to get command-line options
<a name="6"/>#
<a name="7"/>#	Authors:  Robert J. Alexander and Gregg M. Townsend
<a name="8"/>#
<a name="9"/>#	Date:     May 5, 2000
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#	options(arg, optstring,usage,errproc) removes command options
<a name="18"/>#	from the argument list of an Icon main procedure, returning a
<a name="19"/>#	table of option values.
<a name="20"/>#
<a name="21"/>############################################################################
<a name="22"/>
<a name="23"/>package ipl.options
<a name="24"/>
<a name="25"/>import
<a name="26"/>   io, lang, util, ipl.scan, ipl.lists, ipl.pdco, ipl.tables(inserts),
<a name="27"/>   ipl.functional, ipl.printf
<a name="28"/>
<a name="29"/>#
<a name="30"/># The result of the `Opt.format` method.
<a name="31"/>#
<a name="32"/>package record OptFormat(names, help)
<a name="33"/>
<a name="34"/>#
<a name="35"/># This class encapsulates a single option.
<a name="36"/>#
<a name="37"/>class Opt()
<a name="38"/>   public const
<a name="39"/>      # A list of the names of this option.
<a name="40"/>      names,
<a name="41"/>      # The conversion procedure; this should be one of the built-in
<a name="42"/>      # conversion functions (`integer`, `string`, etc), `util.flag`,
<a name="43"/>      # or another procedure which converts the string parameter, and
<a name="44"/>      # sets `&amp;why` on failure.  If this field is null, then the
<a name="45"/>      # option takes no value.
<a name="46"/>      convert,
<a name="47"/>      # The descriptive help string produced when "-?" is used.  This
<a name="48"/>      # may be split into two parts, separated by a `#` character; the
<a name="49"/>      # part to the left is the string used to describe the option
<a name="50"/>      # parameter in the help output.  For example :-
<a name="51"/>      # ~
<a name="52"/>      #    Opt("f", string, "FILE#Load values from FILE")
<a name="53"/>      # ~
<a name="54"/>      # Would produce a help string :-
<a name="55"/>      # ~
<a name="56"/>      #    -f FILE             Load values from FILE
<a name="57"/>      # ~
<a name="58"/>      help,
<a name="59"/>      # A flag value; if set then multiple uses of the option are
<a name="60"/>      # allowed.  The resulting entry in the options table will then
<a name="61"/>      # be a list.
<a name="62"/>      multiple_flag,
<a name="63"/>      # An optional error string produced on an invalid flag value.
<a name="64"/>      # If set, it overrides any value of `&amp;why` set by the convert
<a name="65"/>      # procedure.
<a name="66"/>      param_err
<a name="67"/>
<a name="68"/>   #
<a name="69"/>   # A utility function to help format an option string.
<a name="70"/>   #
<a name="71"/>   public format()
<a name="72"/>      local ns, h, ph
<a name="73"/>      ns := String{ "-" || !names, ", " }
<a name="74"/>      h := \help | ""
<a name="75"/>      if \convert then {
<a name="76"/>         h ? {
<a name="77"/>            if ph := tab(upto('#')) then
<a name="78"/>               h := (move(1), tab(0))
<a name="79"/>            else
<a name="80"/>               ph := case convert of {
<a name="81"/>                  real|integer|numeric|ucs|text|string|cset :
<a name="82"/>                     Text.upper(Proc.get_name(convert))
<a name="83"/>                  flag: "FLAG"
<a name="84"/>                  default: "VALUE"
<a name="85"/>               }
<a name="86"/>         }
<a name="87"/>         ns ||:= " " || ph
<a name="88"/>      }
<a name="89"/>      return OptFormat(ns, h)
<a name="90"/>   end
<a name="91"/>
<a name="92"/>   package build_param_err()
<a name="93"/>      return \param_err | case convert of {
<a name="94"/>         real|integer|numeric|ucs|text|string|cset :
<a name="95"/>            capitalize_cnv(convert) || " expected"
<a name="96"/>         flag:
<a name="97"/>            "Flag expected"
<a name="98"/>         default:
<a name="99"/>            &amp;why
<a name="100"/>      }
<a name="101"/>   end
<a name="102"/>
<a name="103"/>   #
<a name="104"/>   # Create a new Opt instance.
<a name="105"/>   # :Parameters :
<a name="106"/>   # :  `s` - the name of the option; may be a list of several synonymous names 
<a name="107"/>   # :  `convert` - the conversion function to apply; see `Opt.convert`
<a name="108"/>   # :  `help` - a descriptive help string; see `Opt.help`
<a name="109"/>   # :  `multiple` - a flag value, set if multiple uses of the option are 
<a name="110"/>   #          allowed
<a name="111"/>   # :  `param_err` - a string describing the type of parameter (for error output)
<a name="112"/>   #
<a name="113"/>   public new(s, convert, help, multiple, param_err)
<a name="114"/>      names := if type(s) == "list" then
<a name="115"/>         s
<a name="116"/>      else
<a name="117"/>         [s]
<a name="118"/>      self.convert := convert
<a name="119"/>      self.help := help
<a name="120"/>      self.multiple_flag := need_flag(multiple)
<a name="121"/>      self.param_err := param_err
<a name="122"/>      return
<a name="123"/>   end
<a name="124"/>end
<a name="125"/>
<a name="126"/>#
<a name="127"/># Output help for a list of `Opt`s.  This procedure may be useful if a
<a name="128"/># custom "usage" procedure is provided to `options`.
<a name="129"/>#
<a name="130"/># :Parameters :
<a name="131"/># :  `opts` - a list of `Opt`s
<a name="132"/>#
<a name="133"/>procedure options_help(opts)
<a name="134"/>   local o, t
<a name="135"/>   if *opts &gt; 0 then {
<a name="136"/>      write("Options :-")
<a name="137"/>      every o := !opts do {
<a name="138"/>         if is(o, Opt) then {
<a name="139"/>            t := o.format()
<a name="140"/>            help_line!t
<a name="141"/>         } else
<a name="142"/>            help_line(o)
<a name="143"/>      }
<a name="144"/>   }
<a name="145"/>end
<a name="146"/>
<a name="147"/>#
<a name="148"/># Output a formatted two column help line; this is also useful if a
<a name="149"/># custom "usage" procedure is provided.
<a name="150"/>#
<a name="151"/># :Parameters :
<a name="152"/># :  `ns` - the left hand (option) column
<a name="153"/># :  `h` - the descriptive help string.
<a name="154"/>#
<a name="155"/>procedure help_line(ns, h)
<a name="156"/>   static cols
<a name="157"/>   local i
<a name="158"/>   initial
<a name="159"/>      cols := LineEditorStream.get_console_width() | 80
<a name="160"/>   if /h then {
<a name="161"/>      repeat {
<a name="162"/>         if i := backto(' ', ns, 1, cols - 5) then {
<a name="163"/>            write(ns[1:i - 1])
<a name="164"/>            ns := ns[i:0]
<a name="165"/>         } else {
<a name="166"/>            write(ns)
<a name="167"/>            break
<a name="168"/>         }
<a name="169"/>      }
<a name="170"/>   } else {
<a name="171"/>      if *ns &gt; 18 then {
<a name="172"/>         write(ns)
<a name="173"/>         writes(repl(" ", 20))
<a name="174"/>      } else
<a name="175"/>         writes(left(ns, 20))
<a name="176"/>      repeat {
<a name="177"/>         if i := backto(' ', h, 1, cols - 25) then {
<a name="178"/>            write(h[1:i - 1])
<a name="179"/>            writes(repl(" ", 20))
<a name="180"/>            h := h[i:0]
<a name="181"/>         } else {
<a name="182"/>            write(h)
<a name="183"/>            break
<a name="184"/>         }
<a name="185"/>      }
<a name="186"/>   }
<a name="187"/>end
<a name="188"/>
<a name="189"/>#
<a name="190"/># This is just a wrapper around stop(), which prints out the given
<a name="191"/># message and a helpful line about the "-?" option.
<a name="192"/>#
<a name="193"/>procedure help_stop(a[])
<a name="194"/>   push(a, Files.get_program_name() || ": ")
<a name="195"/>   put(a, "\NUse the -? option for more information")
<a name="196"/>   stop!a
<a name="197"/>end
<a name="198"/>
<a name="199"/>#
<a name="200"/>#     This procedure separates and interprets command options included in 
<a name="201"/>#  the main program argument list.  Option names and values are removed
<a name="202"/>#  from the argument list and returned in a table.
<a name="203"/>#
<a name="204"/>#     On the command line, options are introduced by a `-` character.
<a name="205"/>#  An option name is either a single printable character, as in `-n`
<a name="206"/>#  or `-?`, or a string of letters, numbers, and underscores, as in
<a name="207"/>#  `-geometry`.  Single-character options which don't take a parameter
<a name="208"/>#  may appear in combination, for example as `-qtv`.  If an option
<a name="209"/>#  string is ambiguous, in that it may either be interpreted as a
<a name="210"/>#  single multi-character option, or as several single-character
<a name="211"/>#  options, then the former always has precedence.
<a name="212"/>#
<a name="213"/>#     Some options require values.  Generally, the option name is one
<a name="214"/>#  argument and the value appears as the next argument, for example
<a name="215"/>#  `-F file.txt`.  However, with a single-character argument name (as
<a name="216"/>#  in that example), the value may be concatenated: `-Ffile.txt` is
<a name="217"/>#  accepted as equivalent.
<a name="218"/>#
<a name="219"/>#     Options may be specified using an alternative format, starting
<a name="220"/>#  with `--`.  In this case, no combination of single character
<a name="221"/>#  options is recognised, and a parameter may follow an `=` sign, eg
<a name="222"/>#  `--width=100`.
<a name="223"/>#  
<a name="224"/>#     Options may be freely interspersed with non-option arguments.
<a name="225"/>#  An argument of `-` is treated as a non-option.  The special argument
<a name="226"/>#  `--` terminates option processing.  Non-option arguments are returned
<a name="227"/>#  in the original argument list for interpretation by the caller.
<a name="228"/>#
<a name="229"/>#     Two special options exist.  The first is "?" (alias "help"),
<a name="230"/>#  described below with the `usage` parameter.  The second is "clear",
<a name="231"/>#  which takes a string argument.  Its effect is to remove that key
<a name="232"/>#  from the results table.  If the key is "all", then the results
<a name="233"/>#  table is cleared entirely.  This can be useful if an unwanted
<a name="234"/>#  option defined in a shell alias needs to be deleted.  Thus
<a name="235"/>#  ~
<a name="236"/>#       prog -a -b -clear a -c
<a name="237"/>#  ~
<a name="238"/>#  is equivalent to
<a name="239"/>#  ~
<a name="240"/>#       prog -b -c
<a name="241"/>#  ~
<a name="242"/>#  (assuming a, b and c are valid no-argument options).
<a name="243"/>#
<a name="244"/>#     An argument of the form `@filename` (a `@` immediately followed
<a name="245"/>#  by a file name) causes options() to replace that argument with
<a name="246"/>#  arguments retrieved from the file `filename`.  Each line of the file
<a name="247"/>#  is taken as a separate argument, exactly as it appears in the file.
<a name="248"/>#  Arguments beginning with - are processed as options, and those
<a name="249"/>#  starting with `@` are processed as nested argument files.  An argument
<a name="250"/>#  of `--` causes all remaining arguments IN THAT FILE ONLY to be
<a name="251"/>#  treated as non-options (including `@filename` arguments).
<a name="252"/>#
<a name="253"/>#   :The parameters of `options` are:
<a name="254"/>#  
<a name="255"/>#   :   `arg` -     the argument list as passed to the main procedure.
<a name="256"/>#
<a name="257"/>#   :   `optstring` - a string specifying the allowable options.  This is
<a name="258"/>#                   a concatenation, with optional spaces between, of
<a name="259"/>#                   one or more option specs of the form `-name%`, where
<a name="260"/>#                    *   `-`     introduces the option
<a name="261"/>#                    *   `name`  is either a string of alphanumerics
<a name="262"/>#                               (any of `a-z`, `A-Z`, `0-9`, and `_`)
<a name="263"/>#                               or any single printable character
<a name="264"/>#                    *   `%`     is one of the following flag characters:  
<a name="265"/>#                               `!`       No value is required or allowed  
<a name="266"/>#                               `:`       A string value is required  
<a name="267"/>#                               `+`       An integer value is required  
<a name="268"/>#                               `.`       A real value is required
<a name="269"/>#
<a name="270"/>#                   If the string is followed by a `*` character, then
<a name="271"/>#                   the option may be specified multiple times.
<a name="272"/>#
<a name="273"/>#                   The leading `-` may be omitted for a single-character
<a name="274"/>#                   option.  The `!` flag may be omitted except when
<a name="275"/>#                   needed to terminate a multi-character name.
<a name="276"/>#                   Thus, the following optstrings are equivalent:
<a name="277"/>#                   ~~~
<a name="278"/>#                       -n+ -t -v -q -F: -geometry: -silent
<a name="279"/>#                       n+tvqF:-geometry:-silent
<a name="280"/>#                       -silent!n+tvqF:-geometry:
<a name="281"/>#                   ~~~
<a name="282"/>#
<a name="283"/>#   :   `usage`  -  a procedure which will be called, with the list of
<a name="284"/>#                   `Opt` objects (see below), if the special `-help`
<a name="285"/>#                   or `-?` option is given; by default the options
<a name="286"/>#                   are listed and `exit(0)` called.  A string may be
<a name="287"/>#                   given, which is printed before the options.
<a name="288"/>#
<a name="289"/>#   :   `errproc` - a procedure which will be called if an error is
<a name="290"/>#                   is detected in the command line options.  The
<a name="291"/>#                   procedure is called with one argument:  a string
<a name="292"/>#                   describing the error that occurred.  After `errproc()`
<a name="293"/>#                   is called, `options()` immediately returns the outcome
<a name="294"/>#                   of `errproc()`, without processing further arguments.
<a name="295"/>#                   Already processed arguments will have been removed
<a name="296"/>#                   from `arg`.  If `errproc` is omitted, stop() is
<a name="297"/>#                   called if an error is detected.
<a name="298"/>#
<a name="299"/>#   :   `ignoreproc` - a procedure invoked for every argument, if it
<a name="300"/>#                   succeeds then the argument is added to the argument
<a name="301"/>#                   result list without option processing.
<a name="302"/>#  `
<a name="303"/>#     Instead of an option string, a list of `Opt` objects may be given
<a name="304"/>#  instead.  This allows a descriptive help string to be given for
<a name="305"/>#  each option.
<a name="306"/>#
<a name="307"/>#     Using an `Opt` also allows other conversion procedures to be
<a name="308"/>#  specified.  For example, an integer option might be specified as:
<a name="309"/>#  ~~~
<a name="310"/>#         Opt("t", integer, "Timeout in seconds")
<a name="311"/>#  ~~~
<a name="312"/>#  This would allow `-t 3`, `--t=4`, etc.
<a name="313"/>#
<a name="314"/>#     The list of `Opt`s may also contain strings; these are interspersed
<a name="315"/>#  with the formatted option output when help is produced with the `-help`
<a name="316"/>#  option (or by calling `options_help()`).
<a name="317"/>#
<a name="318"/>#     A table is returned containing the options that were specified.
<a name="319"/>#  The keys are the specified option names.  The assigned values are the
<a name="320"/>#  data values following the options converted to the specified type.  For
<a name="321"/>#  an option allowing multiple usages, a the assigned value is a list.
<a name="322"/>#  A value of `&amp;yes` is stored for options that accept no values.
<a name="323"/>#  The table's default value is `&amp;null`.
<a name="324"/>#
<a name="325"/>#     Upon return, the option arguments are removed from arg, leaving
<a name="326"/>#  only the non-option arguments.
<a name="327"/>#
<a name="328"/>procedure options(arg, opts, usage, errproc, ignoreproc)
<a name="329"/>   local fList, fileArg, fn, ignore, optname, opttable, x,
<a name="330"/>      option, v, p, opt, opttype, convert
<a name="331"/>   #
<a name="332"/>   #  Initialize.
<a name="333"/>   #
<a name="334"/>   /errproc := help_stop
<a name="335"/>   option := table()
<a name="336"/>   fList := []
<a name="337"/>   opttable := table()
<a name="338"/>
<a name="339"/>   if opts := text(opts) then {
<a name="340"/>      #
<a name="341"/>      #  Scan the option specification string.
<a name="342"/>      #
<a name="343"/>      opts ? {
<a name="344"/>         opts := []
<a name="345"/>         while optname := move(1) do {
<a name="346"/>            if optname == " " then next
<a name="347"/>            if optname == "-" then
<a name="348"/>               optname := tab(many(&amp;letters ++ &amp;digits ++ '_')) | move(1) | break
<a name="349"/>            opttype := tab(any('!:+.')) | "!"
<a name="350"/>            convert := case string(opttype) of {
<a name="351"/>               ":": string
<a name="352"/>               "+": integer
<a name="353"/>               ".": real
<a name="354"/>               default: &amp;null
<a name="355"/>            }
<a name="356"/>            put(opts, Opt(optname, convert,, Yes{tab(any('*'))}))
<a name="357"/>         }
<a name="358"/>      }
<a name="359"/>   }
<a name="360"/>
<a name="361"/>   every opt := !opts | Opt("clear", lpartial(clear_opt, opttable)) | Opt(["help", "?"]) do {
<a name="362"/>      if is(opt, Opt) then {
<a name="363"/>         every optname := string(!opt.names) do {
<a name="364"/>            if member(opttable, optname) then
<a name="365"/>               runerr("Duplicate option", optname)
<a name="366"/>            insert(opttable, optname, opt)
<a name="367"/>         }
<a name="368"/>      }
<a name="369"/>   }
<a name="370"/>
<a name="371"/>   #
<a name="372"/>   #  Iterate over program invocation argument words.
<a name="373"/>   #
<a name="374"/>   while x := get(arg) do {
<a name="375"/>      if /x then ignore := &amp;null     # if end of args from file, stop ignoring
<a name="376"/>      else if \ignore | (\ignoreproc)(x, option) then
<a name="377"/>         put(fList,x)
<a name="378"/>      else x ? {
<a name="379"/>         if ="-" &amp; not pos(0) then {
<a name="380"/>            if ="-" then {
<a name="381"/>               if pos(0) then
<a name="382"/>                  ignore := &amp;yes   # ignore following args if --
<a name="383"/>               else {
<a name="384"/>                  optname := tab(upto('=') | 0)
<a name="385"/>                  opt := member(opttable, string(optname)) |
<a name="386"/>                     return errproc("Unrecognized option: --" || optname)
<a name="387"/>
<a name="388"/>                  if /opt.convert then {
<a name="389"/>                     pos(0) | return errproc("--" || optname || " doesn't accept a parameter")
<a name="390"/>                     v := &amp;yes
<a name="391"/>                  } else {
<a name="392"/>                     p := if ="=" then
<a name="393"/>                        tab(0)
<a name="394"/>                     else if \arg[1] then
<a name="395"/>                        get(arg)
<a name="396"/>                     else
<a name="397"/>                        return errproc("No parameter following --" || optname)
<a name="398"/>                     v := opt.convert(p) | return errproc("--" || optname || ": " || opt.build_param_err())
<a name="399"/>                  }
<a name="400"/>                  add_option(option, opt, v)
<a name="401"/>               }
<a name="402"/>            } else {
<a name="403"/>               tab(0) ? until pos(0) do {
<a name="404"/>                  opt := member(opttable, string(optname := ((pos(1),tab(0)) | move(1)))) | 
<a name="405"/>                     return errproc("Unrecognized option: -" || optname)
<a name="406"/>
<a name="407"/>                  if /opt.convert then
<a name="408"/>                     v := &amp;yes
<a name="409"/>                  else {
<a name="410"/>                     pos(*optname + 1) | return errproc("An option taking a parameter cannot be combined: -" || optname)
<a name="411"/>
<a name="412"/>                     p := unless pos(0) then
<a name="413"/>                        tab(0)
<a name="414"/>                     else if \arg[1] then
<a name="415"/>                        get(arg)
<a name="416"/>                     else
<a name="417"/>                        return errproc("No parameter following -" || optname)
<a name="418"/>                     v := opt.convert(p) | return errproc("-" || optname || ": " || opt.build_param_err())
<a name="419"/>                  }
<a name="420"/>                  add_option(option, opt, v)
<a name="421"/>               }
<a name="422"/>            }
<a name="423"/>         }
<a name="424"/>         #
<a name="425"/>         #  If the argument begins with the character "@", fetch option
<a name="426"/>         #  words from lines of a text file.
<a name="427"/>         #
<a name="428"/>         else if ="@" &amp; not pos(0) then {
<a name="429"/>            fn := tab(0)
<a name="430"/>            fileArg := file2list(fn) |
<a name="431"/>               return errproc("Can't open " || fn || ": " || &amp;why)
<a name="432"/>            # push null to signal end of args from file, followed by each line.
<a name="433"/>            every push(arg, &amp;null | back(fileArg))
<a name="434"/>         }
<a name="435"/>         else put(fList,x)
<a name="436"/>      }
<a name="437"/>   }
<a name="438"/>   every push(arg, back(fList))
<a name="439"/>
<a name="440"/>   if member(option, "help") then {
<a name="441"/>      /usage := "Usage: " || Files.get_program_name() || " [OPTIONS...]"
<a name="442"/>      if type(usage) == "list" then
<a name="443"/>         usage := cat_lines(usage)
<a name="444"/>      if usage := text(usage) then {
<a name="445"/>         write(usage)
<a name="446"/>         options_help(opts)
<a name="447"/>         exit(0)
<a name="448"/>      } else {
<a name="449"/>         usage(opts)
<a name="450"/>         fail
<a name="451"/>      }
<a name="452"/>   }
<a name="453"/>
<a name="454"/>   return option
<a name="455"/>end
<a name="456"/>
<a name="457"/>#
<a name="458"/># Add value v from Opt opt into the result table option.
<a name="459"/>#
<a name="460"/>package procedure add_option(option, opt, v)
<a name="461"/>   local k
<a name="462"/>   k := opt.names[1]
<a name="463"/>   if k == "clear" then {
<a name="464"/>      # v is either null ("all") or the Opt to remove.
<a name="465"/>      if /v then
<a name="466"/>         clear(option)
<a name="467"/>      else
<a name="468"/>         delete(option, v.names[1])
<a name="469"/>   } else if /opt.multiple_flag then
<a name="470"/>      insert(option, k, v)
<a name="471"/>   else
<a name="472"/>      inserts(option, k, v)
<a name="473"/>end
<a name="474"/>
<a name="475"/>#
<a name="476"/># Return the given builtin converter function's name, with its first
<a name="477"/># letter capitalized (eg integer-&gt;"Integer").
<a name="478"/>#
<a name="479"/>package procedure capitalize_cnv(f)
<a name="480"/>   local s
<a name="481"/>   s := Proc.get_name(f)
<a name="482"/>   s[1] := Text.upper(s[1])
<a name="483"/>   return s
<a name="484"/>end
<a name="485"/>
<a name="486"/>package procedure range_impl(cnv, min, max, x)
<a name="487"/>   x := cnv(x) | return error(capitalize_cnv(cnv) || " expected")
<a name="488"/>   if x &lt; \min | x &gt; \max then
<a name="489"/>      return error(capitalize_cnv(cnv) || " value out of valid range " || range_string(min, max))
<a name="490"/>   return x
<a name="491"/>end
<a name="492"/>
<a name="493"/>#
<a name="494"/># Converter function for an integer which must lie within the given
<a name="495"/># min-max range.
<a name="496"/>#
<a name="497"/>procedure integer_range(min, max)
<a name="498"/>   return lpartial(range_impl, integer, min, max)
<a name="499"/>end
<a name="500"/>
<a name="501"/>#
<a name="502"/># Converter function for a real which must lie within the given
<a name="503"/># min-max range.
<a name="504"/>#
<a name="505"/>procedure real_range(min, max)
<a name="506"/>   return lpartial(range_impl, real, min, max)
<a name="507"/>end
<a name="508"/>
<a name="509"/>#
<a name="510"/># Converter function for a numeric which must lie within the given
<a name="511"/># min-max range.
<a name="512"/>#
<a name="513"/>procedure numeric_range(min, max)
<a name="514"/>   return lpartial(range_impl, numeric, min, max)
<a name="515"/>end
<a name="516"/>
<a name="517"/>package procedure text_with_impl(cnv, q, i, s)
<a name="518"/>   local j
<a name="519"/>   i := need_integer(\i) | 1
<a name="520"/>   s := cnv(s) | return error(capitalize_cnv(cnv) || " expected")
<a name="521"/>   return if (j := if type(q) == "cset" then upto(q, s) else find(q, s)) then {
<a name="522"/>      if j &gt;= i then
<a name="523"/>         s
<a name="524"/>      else
<a name="525"/>         whyf("%i in invalid position", q)
<a name="526"/>   } else
<a name="527"/>      whyf("%s containing %i expected", capitalize_cnv(cnv), q)
<a name="528"/>end
<a name="529"/>
<a name="530"/>#
<a name="531"/># Converter function for a string option which must contain a char in
<a name="532"/># `q` (if q is a cset), or the substring `q`, otherwise.  `i` is an
<a name="533"/># optional integer giving a minimum index for `q`.
<a name="534"/>#
<a name="535"/>procedure string_with(q, i)
<a name="536"/>   return lpartial(text_with_impl, string, q, i)
<a name="537"/>end
<a name="538"/>
<a name="539"/>#
<a name="540"/># Same as `string_with`, but returns a ucs.
<a name="541"/>#
<a name="542"/>procedure ucs_with(q, i)
<a name="543"/>   return lpartial(text_with_impl, ucs, q, i)
<a name="544"/>end
<a name="545"/>
<a name="546"/>#
<a name="547"/># Converter function for the builtin "clear" option.
<a name="548"/>#
<a name="549"/>package procedure clear_opt(opttable, v)
<a name="550"/>   return if v == "all" then
<a name="551"/>      &amp;null
<a name="552"/>   else
<a name="553"/>      member(opttable, string(v)) | error("Unrecognized option name: " || v)
<a name="554"/>end
<a name="555"/>
<a name="556"/>package class IgnoreAfterImpl(New)
<a name="557"/>   private const f
<a name="558"/>   private fl
<a name="559"/>
<a name="560"/>   public call(x, t)
<a name="561"/>      if /fl &amp; f(x, t) then
<a name="562"/>         fl := &amp;yes
<a name="563"/>      succeed \fl
<a name="564"/>   end
<a name="565"/>end
<a name="566"/>
<a name="567"/>#
<a name="568"/># A helpful procedure to use as an ignoreproc to `option`.  The
<a name="569"/># given function `f` is used to test each argument; when it succeeds
<a name="570"/># then option processing ceases, and all further arguments are treated
<a name="571"/># as-is.
<a name="572"/>#
<a name="573"/>procedure ignore_after(f)
<a name="574"/>   return IgnoreAfterImpl(need_callable(f)).call
<a name="575"/>end
<a name="576"/>
<a name="577"/>#
<a name="578"/># Used with ignore_after to ignore options after first non-flag argument
<a name="579"/>#
<a name="580"/>procedure non_flag(x)
<a name="581"/>   succeed any(~'\-@', x)
<a name="582"/>end
</pre></body></html>
