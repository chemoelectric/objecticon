#
# Retrieve http pages.
#

import util, http, net, lang, ipl.options, io, xdg

global total, ok, err, failed, hc, opts, skipped, out

class Monitor()
   private last_progress, prev_len

   private writes(a[])
      local t
      t := 0
      every t +:= *!a
      push(a, repl("\b \b", \prev_len))
      FileStream.stderr.writes!a
      prev_len := t
   end

   private write(a[])
      push(a, repl("\b \b", \prev_len))
      FileStream.stderr.write!a
      prev_len := &null
   end

   public progress()
      local len, read, now
      len := hc.get_length()
      read := hc.get_read()
      # Check to avoid printing huge number of progress messages very quickly.
      now := Prog.get_runtime_millis()
      if now - \last_progress < 250 then
         return
      last_progress := now
      if \len then
         writes(Format.numeric_to_string(read, 0, ','), " bytes of ", Format.numeric_to_string(len, 0, ','), " (", (read * 100) / len, "%)")
      else
         writes(Format.numeric_to_string(read, 0, ','), " bytes read")
   end

   public complete()
      writes()
   end

   public writing_line(ev)
      write("Sent: ", ev)
   end

   public read_line(ev)
      write("Got : ", ev)
   end

   public read_string(ev)
      write("Got : data - 0x", Format.int_to_string(*ev, 16), " bytes")
   end

   public writing_string(ev)
      write("Sent: data - 0x", Format.int_to_string(*ev, 16), " bytes")
   end

   public failed(ev)
      write("Failed: ", &why)
   end

   public retrying(ev)
      write("Retrying: ", &why)
   end

   public connecting(ev, src, type)
      write("Connecting to " || src.server || ":" || src.port)
   end

   public other(ev, src, type)
      write(type)
   end

   public got_headers()
      local fname

      if \opts["head"|"c"] then
         fail

      if fname := hc.get_response().get_filename() & *fname > 0 then {
         get_out(fname)
         if check_skip() then
            hc.abort()
      }
   end
end

class HttpRequestHelperImpl(HttpRequestHelper)
   public get_authentication(httpc, dom, realm)
      local u, p
      \opts["a"] ? {
         u := tab(upto(':')) | stop("Bad -a option")
         move(1)
         p := tab(0)
         # Only succeed once, otherwise httpclient will loop forever retrying
         delete(opts, "a")
         return Authentication(u, p)
      }
   end

   public modify_redirect(httpc, hreq, hresp)
   end
end

procedure usage(opts)
   write("Usage: geturl [OPTIONS] [URL]...")
   write("Retrieve URL(s)")
   options_help(opts)
   write("URL may contain range expansions eg {1-2+8-11}")
   exit(0)
end

procedure main(args)
   local l, f, t, cookies

   opts := options(args, [Opt("over",, "Overwrite any existing files"),
                          Opt("i",string, "INPUT FILE#Input file for a POST request"),
                          Opt("form",string, "K=V#Post an HTTP form with entry K=V; multiple uses allowed",&yes),
                          Opt("type",string, "TYPE#Content type for a POST request"),
                          Opt("o",string,"OUTPUT FILE/DIR#Output file or directory"),
                          Opt("k",string, "FILE#Load cookies from file"),
                          Opt("q",, "Quiet mode"),
                          Opt("t",integer,"TIMEOUT#Specify timeout (in seconds) to use"),
                          Opt("r",integer, "RETRIES#Specify number of retries to use"),
                          Opt("p",string,"Prepend string to all output files"),
                          Opt("d",string, "Append string to all output files"),
                          Opt("a",string, "USER:PASS#Specify authorization"),
                          Opt("f",string, "FILE#Read URLs from file"),
                          Opt("e",string, "URL#Set referer header"),
                          Opt("l",, "Show HTTP headers and data flow"),
                          Opt("n",string, "FILE#Append to the given partial file"),
                          Opt("head",, "Do an HTTP HEAD"),
                          Opt("nsslv",, "Don't verify SSL certificates"),
                          Opt("npro",, "Don't output progress information"),
                          Opt("c",, "Output to stdout (implies -q)"),
                          Opt("put",,"With -i, do a PUT instead of a POST"),
                          Opt("skip",, "Skip over any existing files"),
                          Opt("agent",string, "Set user agent field"),
                          Opt("while",, "Set the retry-while-data flag"),
                          Opt("close",, "Use Connection: Close"),
                          Opt("x",string,"HEADER:VALUE#Set extra HTTP header; multiple uses allowed",&yes),
                          Opt("nz",, "Don't use gzip compression"),
                          Opt("v1",, "Use HTTP 1.0")],
                          usage)

   total := ok := skipped := 0
   err := []
   failed := []

   hc := HttpClient()
   hc.set_timeout(\opts["t"] * 1000)
   hc.set_retries(\opts["r"])
   hc.set_user_agent(\opts["agent"])
   if \opts["nsslv"] then
      hc.set_ssl_verify(&no)

   if \opts["c"] then
      opts["q"] := &yes

   if \opts["head"] then 
      opts["l"] := &yes

   if \opts["nz"] then
      hc.set_gzip(&no)

   if \opts["close"] then
      hc.set_keep_alive(&no)

   if \opts["v1"] then
      hc.set_http_version("1.0")

   if \opts["while"] then
      hc.set_retry_while_data(&yes)

   cookies := \opts["k"] | FilePath(BaseDir.ensure_data_home()).child("oicookies").str() | stop("Couldn't access data dir: ", &why)
   t := decode_from_file(cookies) | table()
   hc.set_cookies(t)

   l := Monitor()
   if /opts["q"] then {
      hc.connect(l.failed, HttpClient.FAILED_EVENT)
      hc.connect(l.retrying, HttpClient.RETRYING_EVENT)
      if \opts["l"] then {
         hc.connect(l.read_line, NetClient.READ_LINE_EVENT)
         hc.connect(l.read_string, NetClient.READ_STRING_EVENT)
         hc.connect(l.writing_line, NetClient.WRITING_LINE_EVENT)
         hc.connect(l.writing_string, NetClient.WRITING_STRING_EVENT)
         hc.connect(l.connecting, NetClient.CONNECTING_EVENT)
         hc.connect(l.other, NetClient.CONNECTED_EVENT)
         hc.connect(l.other, NetClient.CLOSED_EVENT)
      } else if /opts["npro"] then {
         hc.connect(l.progress, HttpClient.PROGRESS_EVENT)
         hc.connect(l.complete, HttpClient.COMPLETE_EVENT)
      }
   }

   hc.connect(l.got_headers, "Headers")

   if \opts["f"] then {
      f := open(opts["f"]) | stop("Couldn't open ", opts["f"], ": ", &why)
      every process_one(expand_arg(|read(f)))
      close(f)
   } else if *args = 0 then
      every process_one(expand_arg(|read()))
   else
      every process_one(expand_arg(!args))

   hc.close()

   if /opts["q"] then {
      ewrite("Summary: Total ", total, ", Okay ", ok, ", Skipped ", skipped, 
            ", HTTP error ", *err, ", Failed ", *failed)
      if *err > 0 then
         every ewrite("HTTP errors on:" | pp_url(!err))
      if *failed > 0 then
         every ewrite("Failed on:" | pp_url(!failed))
   }

   # Save cookies
   t := cookies || ".bak"
   encode_to_file(t, Cookie.expire_cookies(hc.get_cookies())) | 
      stop("Couldn't encode to temp cookie file ", t, ": ", &why)
$ifdef _MS_WIN32
   Files.remove(cookies)
$endif
   # Use rename not move to ensure it's atomic
   Files.rename(t, cookies) | stop("Couldn't rename cookie file ", t, ": ", &why)

   if *err = *failed = 0 then
      exit(0)
   else
      exit(1)
end

procedure pp_out()
   local s
   return if Files.is_flowterm_tty(FileStream.stderr) & 
      s := FilePath(out).canonical().ucs() then
      Files.begin_link(s) || out || Files.end_link()
   else
      out
end

procedure pp_url(url)
   return if Files.is_flowterm_tty(FileStream.stderr) then       
      Files.begin_link(url) || url.str() || Files.end_link()
   else
      url.str()
end

procedure process_one(a)
   local hr, url, start_t, res, end_t, kbps, s, msg, tmp_file, output_stream, 
      input_stream, content_type, t, k, v, p, f

   total +:= 1

   url := URL(a) | stop("Invalid url: " || a)
   url.scheme == ("http"|"https") | stop("Unknown url scheme: " || url.scheme)

   if /opts["head"] & /opts["c"] then {
      get_out(url.get_path_last())
      if check_skip() then
         fail
      if /opts["q"] then
         ewrite("Saving URL ", pp_url(url))
   }

   hr := HttpRequest().
      set_url(url).
      set_helper(HttpRequestHelperImpl())

   if \opts["head"] then 
      hr.set_method("HEAD")

   hr.set_referer(\opts["e"])

   every s := !\opts["x"] do {
      s ? {
         if k := tab(upto(':')) then {
            move(1)
            tab(many(' \t'))
            v := tab(0)
            hr.add_header(k, v)
         }
      }
   }

   if \opts["n"] then {
      p := Files.stat(opts["n"]) | stop("Couldn't stat ", opts["n"], ": ", &why)
      hr.set_range(p.size)
   }

   if \opts["i"] & \opts["form"] then
      stop("Can't have -i and -form options together")

   if \opts["i"] then {
      /opts["head"] | stop("Can't have -head and -i options together")
      input_stream := FileStream(opts["i"], FileOpt.RDONLY) | stop("Couldn't open ", opts["i"], ": ", &why)
      hr.set_input_stream(input_stream)
      if \opts["put"] then
         hr.set_method("PUT")
      else
         hr.set_method("POST")
      content_type := \opts["type"] | "application/x-www-form-urlencoded"
      hr.set_content_type(content_type)
   }

   if \opts["form"] then {
      /opts["head"] | stop("Can't have -head and -form options together")
      t := table()
      every s := !opts["form"] do {
         s ? {
            if k := tab(upto('=')) then {
               move(1)
               v := tab(0)
               t[k] := v
            }
         }
      }
      hr.set_html_form_data(t)
   }

   if /opts["head"] then {
      tmp_file := Files.make_temp_filename("http_geturl.", ".bin") | stop("Couldn't create temp file: ", &why)
      output_stream := BufferStream(FileStream(tmp_file, 
                                               ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT))).
                         set_buff_size(8192) | stop("Couldn't open ", tmp_file, ": ", &why)
      hr.set_output_stream(output_stream)
   }

   start_t := Prog.get_runtime_millis()
   if res := hc.retrieve(hr) then {
      if /opts["head"] then {
         if \input_stream then
            input_stream.close() | stop("Couldn't close input_stream: ", &why)
         output_stream.close() | stop("Couldn't close output_stream: ", &why)
         if \opts["c"] then {
            use {
               f := FileStream(tmp_file),
               f.copy_to(FileStream.stdout)
            } | {
               save_why{Files.remove(tmp_file)}
               stop("Couldn't copy ", tmp_file, " to stdout: ", &why)
            }
            Files.remove(tmp_file)
         } else {
            end_t := Prog.get_runtime_millis()
            kbps := Format.numeric_to_string((hc.get_read() / 1024.0) / ((end_t - start_t) / 1000.0), 1, ',')
            msg := Format.numeric_to_string(hc.get_read(), 0, ',') || " bytes OK (" || kbps  || " kB/s)"

            if out == Files.NULL_FILE then {
               Files.remove(tmp_file)
               msg ||:= " -> " || out
            } else if \opts["n"] then {
               Files.append(tmp_file, out) | {
                  save_why{Files.remove(tmp_file)}
                  stop("Unable to append ", tmp_file, " to ", out, ": ", &why)
               }
               Files.remove(tmp_file)
               msg ||:= " ->> " || pp_out()
            } else if \opts["over"] then {
               Files.move(tmp_file, out) | {
                  save_why{every Files.remove(tmp_file | out)}
                  stop("Unable to move ", tmp_file, " to ", out, ": ", &why)
               }
               msg ||:= " -> " || pp_out()
            } else if Files.equal_files(tmp_file, out) then {
               msg ||:= " : Existing file " || pp_out() || " is identical."
               Files.remove(tmp_file)
            } else {
               out := Files.ensure_unique_filename(out)
               Files.move(tmp_file, out)  | {
                  save_why{every Files.remove(tmp_file | out)}
                  stop("Unable to move ", tmp_file, " to ", out, ": ", &why)
               }
               msg ||:= " -> " || pp_out()
            }

            if /opts["q"] then
               ewrite(msg)
         }
      }
      ok +:= 1
   } else {
      if /opts["head"] then {
         if \input_stream then
            input_stream.close() | stop("Couldn't close input_stream: ", &why)
         output_stream.close() | stop("Couldn't close output_stream: ", &why)
         Files.remove(tmp_file)
      }
      if /hc.abort_flag then {
         if s := hc.get_http_error() then {
            put(err, url)
            if /opts["q"] then
               ewrite("HTTP Error: ", s, " - no data output")
         } else {
            put(failed, url)
         }
      }
   }
end


procedure get_out(fname)
   if \opts["n"] then {
      out := opts["n"]
      fail
   }

   if *fname = 0 then
      fname := "geturl.out"

   # Ensure illegal path chars (/ and NULL) are removed from fname
   fname := map(fname, "/\0", "--")

   fname := \opts["p"] || fname
   fname := fname || \opts["d"]

   if out := \opts["o"] then {
      if Files.is_directory(out) then
         out := FilePath(out).child(fname).str()
   } else
      out := fname
end


procedure check_skip()
   /opts["n"] | fail
   /opts["over"] | fail
   \opts["skip"] | fail
   Files.access(out) | fail
   if /opts["q"] then
      ewrite("Skipping existing file ", pp_out())
   skipped +:= 1
   return
end


procedure expand_arg(s)
   local s1, s2, s3
   s ? {
      s1 := tab(upto('{')) | return s
      move(1)
      s2 := tab(upto('}')) | fail
      move(1)
      s3 := tab(0)
      suspend s1 || expand_braces(s2) || expand_arg(s3)
   }
end

procedure expand_braces(s)
   local l, s1, s2, s3
   s ? repeat {
      s1 := tab(upto('-+') | 0)
      if any('-') then {
         move(1)
         s2 := tab(upto(':+') | 0)
         if any(':') then {
            move(1)
            s3 := tab(upto('+') | 0)
         } else
            s3 := 1
         if any('0', s1 | s2) then {
            l := *s1
            l <:= *s2
            suspend right(integer(s1) to integer(s2) by integer(s3), l, "0")
         } else
            suspend string(integer(s1) to integer(s2) by integer(s3))
      } else
         suspend s1
      move(1) | break
   }
end
