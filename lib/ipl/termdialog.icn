package ipl.termdialog

import
   gui, io, graphics


class TermTextField(TextField)
   public keeps(e)
      return member(Key.CURSOR, e.code)
   end
end

class TermDialog(Dialog, LineBasedOutputStream)
   private
      input,
      log_limit,
      history_limit,
      history,
      history_start_no,
      hpos,
      hmod,
      text
   private readable
      line

   protected write_line_impl(s)
      text.log([ucs(s)], log_limit)
      return
   end

   public set_log_limit(n)
      self.log_limit := n
      return self
   end

   public set_history_limit(n)
      self.history_limit := n
      limit_history()
      return self
   end

   public set_history(l)
      self.history := l
      self.history_start_no := 1
      limit_history()
      return self
   end

   public get_history()
      return .history
   end

   public get_history_item(n)
      return .history[0 < n - history_start_no + 1]
   end

   public get_history_start_no()
      return .history_start_no
   end

   private move_hist(n)
      local subj
      subj := input.get_contents()
      (subj == ucs(history[hpos])) | (hmod[hpos] := subj)
      hpos +:= n
      subj := \hmod[hpos] | ucs(history[hpos]) | u"?? bad utf8 in history"
      input.set_contents(subj)
   end

   private limit_history()
      while *history > \history_limit do {
         pop(history)
         history_start_no +:= 1
      }
   end

   public component_setup()
      self.setup()
      reset()
   end

   public end_dialog()
   end

   public init_dialog()
   end

   public get_term_width()
      return text.w / text.cbwin.text_width("m")
   end

   public new()
      cast(self,Dialog).new()
      cast(self,LineBasedOutputStream).new()
      history := []
      history_start_no := 1
      log_limit := 600
      return
   end

   private reset()
      hpos := *history + 1
      hmod := table()
      input.set_contents(u"")
   end

   private on_input(ev)
      line := input.get_contents()
      if *line > 0 then {
         put(history, line)
         limit_history()
      }
      reset()
      fire(Event.ACTION, ev)
   end
   
   private handle_key_up(e)
      if hpos > 1 then move_hist(-1)
   end

   private handle_key_down(e)
      if hpos <= *history then move_hist(1)
   end

   private on_input_key(ev)
      case ev.code of {
         Key.UP : handle_key_up(ev)
         Key.DOWN : handle_key_down(ev)
      }
   end

   private setup()
      local layout_1
      self.set_resize(&yes)
      text := EditableTextList().
         set_size("465", "256").
         set_font("fixed").
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("y_fill", &yes).
         set_constraint("y_weight", 1.0).
         set_contents([u""]).
         set_is_editable(&no)
      self.add(text)
      input := TermTextField().
         set_size("458").
         clear_constraints().
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         connect(self.on_input, Event.ACTION).
         connect(self.on_input_key, Event.KEY_PRESS).
         set_contents(u"")
      self.add(input)
      layout_1 := GridLayout().
         set_extra("cells")
      self.set_layout(layout_1)
      self.set_focus(input.find_focus())
   end
end

### Ivib-v2 layout ##
#CCanvas|I18SSuperClass Name|SDialog|SImport Name|Sgui|SButton Groups|L
#0SCheckbox Groups|L0SGen Indent|I3SGen Main|NSGen Component Setup|I1SG
#en Init Dialog|I1SGen Constructor|I1SDialog Struct|CCDialog|I1SWAttrib
#s|T1NSresize|I1SName|STermDialog|SIs Component|NSWidth|NSHeight|NSChil
#dren|L2CCanvasEditableTextList|I30SParent Canvas|X1SName|Stext|SClass 
#Name|SEditableTextList|SImport Name|Sgui|SClass Variable|I1SX Fix|NSY 
#Fix|NSW Fix|NSH Fix|NSX Spec|NSY Spec|NSW Spec|S465|SH Spec|S256|SX Al
#ign|Sl|SY Align|St|SZ|I0STab ord|I0SIs shaded|NSWAttribs|T1NSfont|Sfix
#ed|SConstraints|T5NSx_weight|B1.0|Sx_fill|I1Sy_weight|B1.0|Sy_fill|I1S
#eol|I1STooltip|NSAccel|NSLayout delegate|NSBorder opts|NSEvent Handler
#s|L0SClass Variable|I1SParent Component|X1SContents|L1U|SIs editable f
#lag|NSMove on rpress flag|I1CCanvasTextField|I31SParent Canvas|X1SName
#|Sinput|SClass Name|STermTextField|SImport Name|Sgui|SClass Variable|I
#1SX Fix|NSY Fix|NSW Fix|NSH Fix|I1SX Spec|NSY Spec|NSW Spec|S458|SH Sp
#ec|NSX Align|Sl|SY Align|St|SZ|I0STab ord|I0SIs shaded|NSWAttribs|T0NS
#Constraints|T3NSx_align|Sl|Sx_weight|B1.0|Sx_fill|I1STooltip|NSAccel|N
#SLayout delegate|NSBorder opts|NSEvent Handlers|L2L2SEvent.ACTION|Son_
#input|L2SEvent.KEY_PRESS|Son_input_key|SClass Variable|I1SParent Compo
#nent|X1SContents|U|SFilter String|U|SIs editable flag|I1SMove on rpres
#s flag|I1SInitial Focus|X12SEvent Handlers|L0SLayout delegate|CCanvasG
#ridLayout|I8SDII val|NSDOI val|NSExtra|Scells|SName|Slayout_1|SClass N
#ame|SGridLayout|SImport Name|Sgui|SClass Variable|NSParent|X1
