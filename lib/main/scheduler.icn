package io

import lang, util, ipl.printf, ipl.pdco

# This stream wraps another stream (normally a `SocketStream`).  The
# `in` and `out` methods are invoked from the co-expression of the
# owning `Task`.  Those methods activate the `Task`'s `Scheduler`'s
# co-expression.  The stream's co-expression is re-activated only when
# the `Scheduler` determines the stream is ready for i/o.
#
class TaskStream(Stream, HasTask, HasCloseUnderlying)
   private readable
      timeout
   private const
      other

   public override in(n)
      local r
      r := task.poll([other, Poll.IN], timeout) | fail
      return if /r then 
         error(if /task.notify_flag then "Timeout" else "Notified")
      else if DescStream.poll_in_test(r[1]) then
         other.in(n)
      else {
         other.improve_why()
         whyf("Error on poll(): %w")
      }
   end

   public override out(s)
      local r
      r := task.poll([other, Poll.OUT], timeout) | fail
      return if /r then
         error(if /task.notify_flag then "Timeout" else "Notified")
      else if DescStream.poll_out_test(r[1]) then
         other.out(s)
      else {
         other.improve_why()
         whyf("Error on poll(): %w")
      }
   end

   public override close()
      if \close_underlying_flag then
         other.close() | fail
      link
   end

   public override get_mode()
      return other.get_mode()
   end

   public override seek(offset)
      return other.seek(offset)
   end

   public override tell()
      return other.tell()
   end

   public override truncate(len)
      return other.truncate(len)
   end

   # Set the timeout in ms to use.  If `&null`, then no timeout will
   # be used.
   #
   public set_timeout(timeout)
      self.timeout := /timeout | need_integer(timeout, 0)
      link
   end

   public new(other, task, timeout)
      self.other := need_Stream(other)
      self.close_underlying_flag := &yes
      self.task := need_instance(task, Task)
      set_timeout(timeout)
      return
   end
end

class Task()
   public const
      scheduler
   private readable
      time_from,
      time_until,
      poll_req
   private const
      xstate
   package
      coex,
      state,
      old_state
   package readable
      poll_err,
      poll_res,
      interrupt_why,
      notify_flag

   # If a task is currently sleeping or polling, then this alters the
   # time it will sleep for, behaving as though the original call to
   # `sleep` or `poll` had given `n` as its time parameter.
   #
   # :Parameters :
   # :  `n` - The time to wait for.  If `&null`, wait forever.
   #
   public change_time(n)
      \coex | runerr("change_time() called on a currently active task")
      n := need_integer(\n, 0)
      if is_sleeping() | is_polling() then
         time_until := (time_from + \n) | &null
      link
   end

   # This is like `change_time()`, but the time is set to `n`
   # milliseconds from now, rather than from the time of the original
   # call.
   #
   # :Parameters :
   # :  `n` - The time to wait for.  If `&null`, wait forever.
   #
   public change_time_from_now(n)
      \coex | runerr("change_time_from_now() called on a currently active task")
      n := need_integer(\n, 0)
      if is_sleeping() | is_polling() then
         time_until := (Prog.get_runtime_millis() + \n) | &null
      link
   end

   # Succeed iff the task is currently active.
   #
   public is_active()
      succeed /coex
   end

   # Succeed iff the task is the current task.  Note that a task may
   # be active, but not the current task, since a task may itself
   # invoke `Scheduler.work` in order to activate another task, in a
   # nested fashion.  This may happen for example when a task shows a
   # modal dialog, and hence calls `Scheduler.work` via the dispatcher
   # event loop.
   #
   public is_current()
      succeed self === scheduler.curr_task
   end

   # Succeed iff the task is currently sleeping
   public is_sleeping()
      succeed state === scheduler.sleeping
   end

   # Succeed iff the task is currently polling
   public is_polling()
      succeed state === scheduler.polling
   end

   # Succeed iff the task is currently in the ready state
   public is_ready()
      succeed state === scheduler.ready
   end

   # Succeed iff the task is dormant, meaning it is not active, and is
   # not sleeping, polling or ready, meaning it won't be scheduled by
   # the scheduler, at least until `start` is called on it.
   public is_dormant()
      succeed \coex & /state
   end

   # Suspend this task, which must be the currently scheduled task, in
   # order to carry out a `DescStream.poll`.  The parameters and
   # result are in the same form as for `DescStream.poll`.  The
   # difference between this and `DescStream.poll` is that the
   # scheduler will suspend this task whilst the poll is taking place,
   # whereas `DescStream.poll` will block.  If `timeout` is zero, then
   # there is no advantage in using this method, and `DescStream.poll`
   # is preferable.
   #
   # If the task is interrupted whilst polling this method fails with
   # `&why` set to the value of `interrupt_why`, which will be
   # non-null.
   #
   # If the task is notified whilst polling, this method returns
   # `&null`, ie it behaves as though a timeout occurred.  The
   # `notify_flag` is also set.
   #
   # :Parameters :
   # :  `l` - A list of alternating `DescStream`, flag (from `Poll`)
   #          pairs.
   # :  `timeout` - The optional timeout
   #
   public poll(l, timeout)
      is_current() | runerr("poll() called on task which is not current")
      need_list(l)
      if *l % 2 ~= 0 then
         runerr(177, l)
      timeout := need_integer(\timeout, 0)
      coex := &current
      time_from := Prog.get_runtime_millis()
      time_until := (time_from + \timeout) | &null
      poll_req := l
      poll_err := poll_res := notify_flag := interrupt_why := &null
      scheduler.now_poll(self)
      return if \interrupt_why then
         error(interrupt_why)
      else if \poll_err then
         error(poll_err)
      else
         .self.poll_res
   end

   # Suspend this task, which must be the currently scheduled task,
   # for `n` milliseconds; `&null` means indefinitely.
   #
   # This task is woken and the method returns after one of three
   # things happens :-
   #
   # 1. After `n` milliseconds passes; the method succeeds.
   # 2. After it is notified; the method succeeds and the
   #    `notify_flag` is set.
   # 3. After it is interrupted; the method fails with `&why`
   #    set to the value of `interrupt_why`, which will be
   #    non-null.
   #
   # :Parameters :
   # :  `n` - The time to wait for.  If `&null`, wait forever (or until
   #          interrupted or notified).
   # :Returns :
   # :  `self` when the task awakes; fails on interrupt
   #
   public sleep(n)
      is_current() | runerr("sleep() called on task which is not current")
      n := need_integer(\n, 0)
      coex := &current
      time_from := Prog.get_runtime_millis()
      time_until := (time_from + \n) | &null
      notify_flag := interrupt_why := &null
      scheduler.now_sleep(self)
      return if \interrupt_why then error(interrupt_why) else self
   end

   # Interrupt the task, which may not be currently active.  If the
   # task is currently sleeping or polling, then it is placed back in
   # the ready state.  This causes the original `poll` or `sleep` call
   # to fail, setting `&why` to the value given in the optional
   # parameter `why` (the default `&why` is "Interrupted").
   #
   public interrupt(why)
      \coex | runerr("interrupt() called on a currently active task")
      why := need_text(\why)
      scheduler.interrupt(self, why)
      link
   end

   # If the task is sleeping or polling, then place it immediately
   # back into the ready state.  The task must not be currently
   # active.
   #
   public notify()
      \coex | runerr("notify() called on a currently active task")
      scheduler.notify(self)
      link
   end

   # Suspend this task, which must be the currently scheduled task,
   # placing it immediately into the ready state in the scheduler.
   #
   public yield()
      is_current() | runerr("yield() called on task which is not current")
      self.coex := &current
      scheduler.now_yield(self)
      link
   end

   # Suspend this task, which must be the currently scheduled task,
   # but do not resume it.  Control reverts to the scheduler.  The
   # task may be subsequently restarted with `start`.  Note that to
   # end a task, it is not simply sufficient to fall off the end of
   # the task's co-expression, `revert` must be used.
   #
   public revert()
      is_current() | runerr("revert() called on task which is not current")
      self.coex := &current
      scheduler.now_revert()
      link
   end

   # Start the task, which may not be currently active.  If the task
   # was previously stopped in a particular state (eg sleeping), then
   # it continues from that same state.
   #
   public start()
      \coex | runerr("start() called on a currently active task")
      scheduler.start(self)
      link
   end

   # Stop the task, which may not be currently active.  This prevents
   # the scheduler from activating it.  Its present state is
   # remembered, and it may be started again in that state using
   # `start`.
   #
   public stop()
      \coex | runerr("stop() called on a currently active task")
      scheduler.stop(self)
      link
   end

   # This method swaps the values of external state previously saved,
   # by invoking the `swap()` on the xstate member (if set).
   #
   package xstate_swap()
      (\xstate).swap()
   end

   #
   # Create a new `Task`.
   #
   # :Parameters :
   # :  `scheduler` - The `Scheduler` to use to activate the task.
   # :  `coex` - The co-expression body of the task.
   # :  `xstate` - An optional instance of `State` which is used
   #        to save and restore external state when switching to and
   #        from this Task.
   #
   public new(scheduler, coex, xstate)
      self.scheduler := need_instance(scheduler, Scheduler)
      self.coex := need_coexpression(coex)
      self.xstate := need_instance(\xstate, State)
      return
   end
end

class Scheduler()
   private readable 
      poll_timeout,
      coex,
      curr_task
   package const
      ready,
      sleeping,
      polling
   
   public new(n)
      set_poll_timeout(n)
      ready := set()
      sleeping := set()
      polling := set()
      return
   end

   public set_poll_timeout(n)
      poll_timeout := need_integer(\n, 0) | 0
      link
   end

   package start(t)
      if /t.state then {
         t.state := \t.old_state | ready
         t.old_state := &null
         insert(t.state, t)
      }
   end

   package stop(t)
      if \t.state then {
         t.old_state := t.state
         delete(t.state, t)
         t.state := &null
      }
   end

   private set_state(t, x)
      delete(\t.state, t)
      t.state := x
      insert(t.state, t)
   end

   package interrupt(t, why)
      if t.state === (sleeping | polling) then {
         t.interrupt_why := \why | "Interrupted"
         set_state(t, ready)
      }
   end

   package notify(t)
      if t.state === (sleeping | polling) then {
         t.notify_flag := &yes
         set_state(t, ready)
      }
   end

   package now_sleep(t)
      \coex | syserr("now_sleep() with null coex")
      set_state(t, sleeping)
      coact(, coex)
   end

   package now_poll(t)
      \coex | syserr("now_poll() with null coex")
      set_state(t, polling)
      coact(, coex)
   end

   package now_yield(t)
      \coex | syserr("now_yield() with null coex")
      set_state(t, ready)
      coact(, coex)
   end

   package now_revert()
      \coex | syserr("now_revert() with null coex")
      coact(, coex)
   end

   #
   # Test whether there are any tasks in the internal lists.
   #
   public empty()
      succeed not(*(ready | sleeping | polling) > 0)
   end

   private run(t)
      local sc, st, te
      delete(t.state, t)
      t.state := &null
      sc := coex
      st := curr_task
      coex := &current
      curr_task := t
      te := t.coex
      t.coex := &null
      # Don't specify an activator unless we have to (ie if this is a
      # new co-expression).
      t.xstate_swap()
      if Coexpression.get_activator(te) then
         coact(, te)
      else
         @te
      t.xstate_swap()
      \t.coex | runerr("Incorrect reversion to scheduler, task co-expression not set", t)
      coex === &current | syserr("Scheduler co-expression not &current")
      coex := sc
      curr_task := st
   end

   #
   # Perhaps do some work; succeed if some was done, fail if not.
   #
   public work()
      local t, r, curr_time, poll_l, x
      repeat {
         if t := ?ready then {
            run(t)
            return
         }

         if *sleeping > 0 then {
            curr_time := Prog.get_runtime_millis()
            every t := !sleeping do {
               if curr_time >= \t.time_until then
                  set_state(t, ready)
            }
            if *ready > 0 then
               next
         }

         if *polling > 0 then {
            poll_l := List{ !(!polling).poll_req }
            curr_time := Prog.get_runtime_millis() + poll_timeout
            if r := DescStream.poll(poll_l, poll_timeout) then {
               if /r then {
                  # Process timeout for each task.
                  every t := !polling do {
                     if curr_time >= \t.time_until then
                        set_state(t, ready)
                  }
               } else {
                  every t := !polling do {
                     # Extract relevant part of result
                     x := []
                     every 1 to *t.poll_req / 2 do
                        put(x, pop(r))
                     # If all zeros, it's the same as a timeout.
                     if !x ~= 0 then {
                        set_state(t, ready)
                        t.poll_res := x
                     } else if curr_time >= \t.time_until then
                        set_state(t, ready)
                  }
               }
            } else {
               # poll error; forward error to each Task
               every t := !polling do {
                  set_state(t, ready)
                  t.poll_err := &why
               }
            }
            # If we have a poll_timeout, the poll counts as work; otherwise it does not
            if poll_timeout > 0 then
               return
            if *ready > 0 then
               next
         }

         fail
      }
   end

   #
   # Convenient method to call work(), and if no work is done, to
   # sleep for the poll timeout period.
   #
   public work_or_sleep()
      work() | delay(poll_timeout)
   end
end
