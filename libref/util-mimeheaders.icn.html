<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>mimeheaders.icn</title></head><body><pre>
<a name="1"/>package util
<a name="2"/>
<a name="3"/>import io(write), lang(Text), datastruct, ipl.pdco(String)
<a name="4"/>
<a name="5"/>#
<a name="6"/># Base class for an object which has headers (Message, and HTTP response
<a name="7"/># and request objects).
<a name="8"/>#
<a name="9"/>abstract class MimeHeaders()
<a name="10"/>   public const
<a name="11"/>      headers
<a name="12"/>
<a name="13"/>   #
<a name="14"/>   # Show the header table (useful debug)
<a name="15"/>   #
<a name="16"/>   public show_headers()
<a name="17"/>      local h
<a name="18"/>      every h := gen_header_entries() do {
<a name="19"/>         every write(h.key, ": ", !h.val)
<a name="20"/>      }
<a name="21"/>   end
<a name="22"/>
<a name="23"/>   #
<a name="24"/>   # Generate the header keys in sorted order.
<a name="25"/>   #
<a name="26"/>   public gen_header_keys()
<a name="27"/>      suspend headers.key()
<a name="28"/>   end
<a name="29"/>
<a name="30"/>   #
<a name="31"/>   # Generate a list of sorted key-entrylist header pairs.
<a name="32"/>   #
<a name="33"/>   public gen_header_entries()
<a name="34"/>      suspend headers.entries()
<a name="35"/>   end
<a name="36"/>
<a name="37"/>   #
<a name="38"/>   # A convenience function to get the first header matching the given key, or fail
<a name="39"/>   #
<a name="40"/>   public get_first_header(key)
<a name="41"/>      return get_headers(key)[1]
<a name="42"/>   end
<a name="43"/>
<a name="44"/>   #
<a name="45"/>   # Get all the headers for the key, or fail if the key has no headers
<a name="46"/>   # :Returns :
<a name="47"/>   # :  a list of all the headers for the key.  This will always be
<a name="48"/>   #         a non-empty list.
<a name="49"/>   # :Fails :
<a name="50"/>   # :  if no headers for the key have been defined
<a name="51"/>   #
<a name="52"/>   public get_headers(key)
<a name="53"/>      return headers.member(need_string(key))
<a name="54"/>   end
<a name="55"/>
<a name="56"/>   #
<a name="57"/>   # Generate all the headers for the key, or fail if the key has no headers
<a name="58"/>   # :Generates :
<a name="59"/>   # :  all the headers for the key
<a name="60"/>   # :Fails :
<a name="61"/>   # :  if no headers for the key have been defined
<a name="62"/>   #
<a name="63"/>   public gen_headers(key)
<a name="64"/>      suspend !get_headers(key)
<a name="65"/>   end
<a name="66"/>
<a name="67"/>   #
<a name="68"/>   # Get all the headers matching the given key as a string separated
<a name="69"/>   # by the given delimeter, which defaults to ","
<a name="70"/>   # :Fails :
<a name="71"/>   # :  if there is no header with the given key
<a name="72"/>   #
<a name="73"/>   public get_catenated_headers(key, delim)
<a name="74"/>      local l
<a name="75"/>
<a name="76"/>      l := get_headers(key) | fail
<a name="77"/>
<a name="78"/>      /delim := ","
<a name="79"/>
<a name="80"/>      return String{ !l, delim }
<a name="81"/>   end
<a name="82"/>
<a name="83"/>   #
<a name="84"/>   # Add a header with the given key, after any existing ones with the same key
<a name="85"/>   #
<a name="86"/>   public add_header(key, val)
<a name="87"/>      key := need_string(key)
<a name="88"/>      val := need_string(val)
<a name="89"/>      put(headers.member(key), val) | headers.insert(key, [val])
<a name="90"/>      link
<a name="91"/>   end
<a name="92"/>
<a name="93"/>   #
<a name="94"/>   # Set a header with the given key; any existing headers with the same key
<a name="95"/>   # are removed.
<a name="96"/>   #
<a name="97"/>   public set_header(key, val)
<a name="98"/>      headers.insert(need_string(key), [need_string(val)])
<a name="99"/>      link
<a name="100"/>   end
<a name="101"/>
<a name="102"/>   #
<a name="103"/>   # Unset the header(s) for the given key
<a name="104"/>   #
<a name="105"/>   public unset_header(key)
<a name="106"/>      headers.delete(need_string(key))
<a name="107"/>      link
<a name="108"/>   end
<a name="109"/>
<a name="110"/>   #
<a name="111"/>   # Succeed iff there is a header with the given key.
<a name="112"/>   #
<a name="113"/>   public has_header(key)
<a name="114"/>      succeed headers.member(need_string(key))
<a name="115"/>   end
<a name="116"/>
<a name="117"/>   public new()
<a name="118"/>      headers := SortTable(, Text.caseless_compare)
<a name="119"/>      return
<a name="120"/>   end
<a name="121"/>end
</pre></body></html>
