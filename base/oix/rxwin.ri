/*
 * File: rxwin.ri - X11 system-specific graphics interface code.
 */

#ifdef Graphics

#define RootState IconicState+1
#define CONVERT_ANGLE(ang) (-(ang) * 180 / Pi * 64)

/*
 * Global variables specific to X
 */
wdp wdsplys;

/*
 * function prototypes
 */
static wcp alc_context(wbp w);
static wsp alc_winstate(void);
static int handle_misc(wdp display);
static int handle_config(wbp w, XConfigureEvent *event);
static int handle_exposures(wbp w, XExposeEvent *event);
static void handle_mouse(wbp w, XButtonEvent *event);
static void handle_keypress(wbp w, XKeyEvent *event);
static XImage *getximage(wbp w, int x, int y,
                         int width, int height, int init);
static void makeIcon(wbp w, int x, int y);
static int wmap(wbp w, wbp parent);
static Pixmap loadimage(wbp w, char *filename, unsigned int *height, 
                        unsigned int *width, int atorigin, int *status);
static int convert_KeySym_to_code_point(KeySym k);
#ifdef HAVE_LIBXFT
int xft_stringwidth(wbp w, char *s, int n);
static char *convert_spec(char *s);
#else
static wfp findfont(wbp w, char *fam, int size, int flags);
static int okfont(char *spec, int size, int flags);
static int fontcmp(char *font1, char *font2, int size, int flags);
static int fieldcmp(char *font1, char *font2, char *value, int field);
static char *xlfd_field(char *s, int i);
static int xlfd_size(char *s, int n);
#endif
static wfp loadfont(wdp wd, char *s);
static int resetfg (wbp w);
static int setfgrgb(wbp w, int r, int g, int b);
static int setbgrgb(wbp w, int r, int g, int b);
static XColor xcolor(wbp w, LinearColor clr);
static LinearColor lcolor(wbp w, XColor color);
static int remap(wbp w, int x, int y);
static wdp alc_display (char *s);
static void free_display   (wdp wd);
static wfp alc_font(wbp w, char *s);
static wfp tryfont(wbp w, char *s);
static wclrp alc_rgb(wbp w, char *s, unsigned int r,
                     unsigned int g, unsigned int b,
                     int is_iconcolor);
static int alc_centry(wdp wd);
static void copy_colors(wbp w1, wbp w2);
static void free_xcolor(wbp w, unsigned long c);
static void free_xcolors(wbp w, int extent);
static int go_virtual(wbp w);
static int resizePixmap(wbp w, int width, int height);
static void setclip(wbp w);
static void unsetclip(wbp w);


#define DEFAULTFONTNAME "fixed"

static stringint drawops[] = {
   { 0, 16},
   {"and",		GXand},
   {"andInverted",	GXandInverted},
   {"andReverse",	GXandReverse},
   {"clear",		GXclear},
   {"copy",		GXcopy},
   {"copyInverted",	GXcopyInverted},
   {"equiv",		GXequiv},
   {"invert",		GXinvert},
   {"nand",		GXnand},
   {"noop",		GXnoop},
   {"nor",		GXnor},
   {"or",		GXor},
   {"orInverted",	GXorInverted},
   {"orReverse",	GXorReverse},
   {"set",		GXset},
   {"xor",		GXxor},
};

#define NUMCURSORSYMS	78

static stringint cursorsyms[] = {
  { 0, NUMCURSORSYMS},
  {"X cursor",		XC_X_cursor},
  {"arrow",		XC_arrow},
  {"based arrow down",	XC_based_arrow_down},
  {"based arrow up",	XC_based_arrow_up},
  {"boat",		XC_boat},
  {"bogosity",		XC_bogosity},
  {"bottom left corner",XC_bottom_left_corner},
  {"bottom right corner",XC_bottom_right_corner},
  {"bottom side",	XC_bottom_side},
  {"bottom tee",	XC_bottom_tee},
  {"box spiral",	XC_box_spiral},
  {"center ptr",	XC_center_ptr},
  {"circle",		XC_circle},
  {"clock",		XC_clock},
  {"coffee mug",	XC_coffee_mug},
  {"cross",		XC_cross},
  {"cross reverse",	XC_cross_reverse},
  {"crosshair",		XC_crosshair},
  {"diamond cross",	XC_diamond_cross},
  {"dot",		XC_dot},
  {"dotbox",		XC_dotbox},
  {"double arrow",	XC_double_arrow},
  {"draft large",	XC_draft_large},
  {"draft small",	XC_draft_small},
  {"draped box",	XC_draped_box},
  {"exchange",		XC_exchange},
  {"fleur",		XC_fleur},
  {"gobbler",		XC_gobbler},
  {"gumby",		XC_gumby},
  {"hand1",		XC_hand1},
  {"hand2",		XC_hand2},
  {"heart",		XC_heart},
  {"icon",		XC_icon},
  {"iron cross",	XC_iron_cross},
  {"left ptr",		XC_left_ptr},
  {"left side",		XC_left_side},
  {"left tee",		XC_left_tee},
  {"leftbutton",	XC_leftbutton},
  {"ll angle",		XC_ll_angle},
  {"lr angle",		XC_lr_angle},
  {"man",		XC_man},
  {"middlebutton",	XC_middlebutton},
  {"mouse",		XC_mouse},
  {"pencil",		XC_pencil},
  {"pirate",		XC_pirate},
  {"plus",		XC_plus},
  {"question arrow",	XC_question_arrow},
  {"right ptr",		XC_right_ptr},
  {"right side",	XC_right_side},
  {"right tee",		XC_right_tee},
  {"rightbutton",	XC_rightbutton},
  {"rtl logo",		XC_rtl_logo},
  {"sailboat",		XC_sailboat},
  {"sb down arrow",	XC_sb_down_arrow},
  {"sb h double arrow",	XC_sb_h_double_arrow},
  {"sb left arrow",	XC_sb_left_arrow},
  {"sb right arrow",	XC_sb_right_arrow},
  {"sb up arrow",	XC_sb_up_arrow},
  {"sb v double arrow",	XC_sb_v_double_arrow},
  {"shuttle",		XC_shuttle},
  {"sizing",		XC_sizing},
  {"spider",		XC_spider},
  {"spraycan",		XC_spraycan},
  {"star",		XC_star},
  {"target",		XC_target},
  {"tcross",		XC_tcross},
  {"top left arrow",	XC_top_left_arrow},
  {"top left corner",	XC_top_left_corner},
  {"top right corner",	XC_top_right_corner},
  {"top side",		XC_top_side},
  {"top tee",		XC_top_tee},
  {"trek",		XC_trek},
  {"ul angle",		XC_ul_angle},
  {"umbrella",		XC_umbrella},
  {"ur angle",		XC_ur_angle},
  {"watch",		XC_watch},
  {"xterm",		XC_xterm},
  {"num glyphs",	XC_num_glyphs},
};


static int selection_debug = 0;

static char *atom_fmt(wsp ws,Atom a) {
    static int n = 0;
    static char buff[8][96];
    char *s, *r;
    r = buff[n];
    if (a == None)
        return "None(0)";

    s = XGetAtomName(ws->display->display, a);
    if (s) {
        sprintf(r, "%.64s(%ld)", s, (long)a);
        XFree(s);
    } else {
        sprintf(r, "?unknown atom(%ld)", (long)a);
    }

    n = (n + 1) % 8;
    return r;
}

/*
 * Get the string name of the given Atom into dest.  The string is
 * allocated in the string region.
 */
void get_atom_descriptor(wsp ws, Atom a, dptr dest)
{
    char *s = XGetAtomName(ws->display->display, a);
    cstr2string(s, dest);
    XFree(s);
}

Atom ConvertTarget(Display* display, Atom desired_target)
{
    /* Check for common cases. */
    if ( (desired_target == XInternAtom(display, "TIMESTAMP", False))    ||
         (desired_target == XInternAtom(display, "LIST_LENGTH", False) ) ||
         (desired_target == XInternAtom(display, "LENGTH", False) ) ) {
        return XA_INTEGER;
    }

    if ( desired_target == XInternAtom(display, "CHARACTER_POSITION", False) ) {
        return XInternAtom(display, "SPAN", False);
    }

    if ( desired_target == XInternAtom(display, "TARGETS", False) ) {
        return XA_ATOM;
    }

    if ( desired_target == XInternAtom(display, "CLIENT_WINDOW", False) ) {
        return XA_WINDOW;
    }

    if (( desired_target == XInternAtom(display, "HOST_NAME", False) ) ||
        ( desired_target == XInternAtom(display, "HOSTNAME", False) ) ||
        ( desired_target == XInternAtom(display, "NAME", False) ) ||
        ( desired_target == XInternAtom(display, "OWNER_OS", False) ) ||
        ( desired_target == XInternAtom(display, "USER", False) ) ) {
        return XA_STRING;
    }
    /* Otherwise, no need to convert target. */
    return desired_target;
}

char* PropertyToString(Display* display, Atom target, int number_items,
                       void* data)
{
    Atom            new_target;
    Atom            timestamp, span;
    unsigned long*  long_array;
    int*            int_array;
    char*           string0 = NULL;
    int             i, length;
    char            temp[100];
    char*           atom_name;

    /* Convert our atoms. */
    timestamp = XInternAtom(display, "TIMESTAMP", False);
    span      = XInternAtom(display, "SPAN", False);

    /* Convert target, if necessary. */
    new_target = ConvertTarget(display, target);

    if (new_target == XA_ATOM) {

        long_array = (unsigned long*) data;

        length = number_items * 30;
        MemProtect(string0 = malloc( length + 1 ));
        string0[0] = '\0';

        /* Convert to atom names. */
        for (i = 0; i < number_items; i++) {
            atom_name = XGetAtomName(display, long_array[i] );

            if (atom_name != NULL) {

                /* Check that space is available. */
                length -= strlen(atom_name);
 
                if (length > 1) {
                    strcat(string0, atom_name);
                    strcat(string0, "\n");
                }
                XFree(atom_name);
            }
        }
    }
    else if (new_target == XA_STRING) {
        MemProtect(string0 = malloc(number_items + 1));
        strcpy(string0, (char *)data);
    }
    else if ((new_target == XA_INTEGER) ||
             (new_target == span) ||
             (new_target == timestamp) ) {

        int_array = (int*) data;

        length = number_items * 20;
        MemProtect(string0 = malloc( length + 1 ));
        string0[0] = '\0';

        for (i = 0; i < number_items; i++) {
            sprintf(temp, "%d ", int_array[i]);

            /* Check that space is available. */
            length -= strlen(temp);
            if (length > 0) {
                strcat(string0, temp);
            }
        }
    }
    else if (new_target == XA_WINDOW) {

        long_array = (unsigned long*) data;

        length = number_items * 12;
        MemProtect(string0 = malloc( length + 1 ));
        string0[0] = '\0';

        for (i = 0; i < number_items; i++) {
            sprintf(temp, "0x%8.8lu ", long_array[i]);
            strcat(string0, temp);
        }

    }
    else {
        /* Add extra cases as necessary... */
    }

    return string0;

}

/*
 * Function to append data to an X property.
 */

static int     ErrorFlag = False;
static int     LastError = None;

#define BUFSIZE     1024

#define NUMBER_ERRORS   18

char*  ErrorCodes[ NUMBER_ERRORS ] = {
    "Success",           /* 0  */
    "BadRequest",        /* 1  */
    "BadValue",          /* 2  */
    "BadWindow",         /* 3  */
    "BadPixmap",         /* 4  */
    "BadAtom",           /* 5  */
    "BadCursor",         /* 6  */
    "BadFont",           /* 7  */
    "BadMatch",          /* 8  */
    "BadDrawable",       /* 9  */
    "BadAccess",         /* 10 */
    "BadAlloc",          /* 11 */
    "BadColor",          /* 12 */
    "BadGC",             /* 13 */
    "BadIDChoice",       /* 14 */
    "BadName",           /* 15 */
    "BadLength",         /* 16 */
    "BadImplementation"  /* 17 */
};


static void ErrorHandler(Display* display, XErrorEvent* error_event)
{   
    char string0[BUFSIZE + 1];

    ErrorFlag = True;
    LastError = (int) error_event->error_code;

    /* Find out the error message and print it. */
    XGetErrorText(display, error_event->error_code, string0, BUFSIZE);

    fprintf(stderr, "X Error on display %s.i\nResource %ld:  ",
            DisplayString( display ), error_event->resourceid );

    if ((error_event->error_code > 0 ) && 
        (error_event->error_code < NUMBER_ERRORS ) ) {

        fprintf( stderr, "%s (%s).\n", string0,
                 ErrorCodes[ error_event->error_code ] );
    }
    else {
        fprintf( stderr, "%s.\n", string0 );
    }

    fprintf(stderr, "Op code %d.%d, Error code %d\n", error_event->request_code,
            error_event->minor_code, error_event->error_code );
}


void ResetErrorFlag()
{  
    ErrorFlag = False;
    LastError = None;
}

void SetErrorHandler()
{   
    (void) XSetErrorHandler((XErrorHandler) ErrorHandler);
}

/*
 * handle_misc processes pending events on display.
 * if w is non-null, block until a returnable event arrives.
 * returns 1 on success, 0 on failure.
 */
static int handle_misc(wdp wd)
{
    XEvent event;
    Window evwin;
    static int presscount = 0;
    wbp wb;
    wsp ws = 0;

    while (XPending(wd->display)) {

        XNextEvent(wd->display, &event);
        evwin = event.xexpose.window;  /* go ahead, criticize all you like */

/* could avoid doing this search every event by handling 1 window at a time */
        for (wb = wbndngs; wb; wb=wb->next) {
            ws = wb->window;
            if (ws->display == wd) {
                if (ws->win == evwin) break;
                if (ws->iconwin == evwin) break;
                if (ws->pix == evwin) break;
                if (ws->initialPix == evwin) break;
	    }
        }
        if (!wb) continue;
        if (evwin == ws->iconwin) {
            switch (event.type) {
                case Expose:
                    if (ws->iconpix)
                        XCopyArea(wd->display, ws->iconpix, ws->iconwin,
                                  wd->icongc, 0, 0, ws->iconw, ws->iconh, 3, 3);
                    else
                        XDrawString(wd->display, evwin, wd->icongc, 4,
                                    ws->display->fonts->ascent + 2,
                                    ws->iconlabel, strlen(ws->iconlabel));
                    if (ws->iconic == IconicState)
                        SETEXPOSED(wb);
                    break;
                case KeyRelease: {
                    if (ws->inputmask & KeyReleaseMask) {
                        handle_keypress(wb, (XKeyEvent *)&event);
                    }
                    break;
                }
                case KeyPress:
                    handle_keypress(wb, (XKeyEvent *)&event);
                    break;
                case ButtonPress:
                    if (ws->iconic == IconicState)
                        XMapWindow(ws->display->display, ws->win);
                    ws->iconic = NormalState;        /* set the current state */
                    break;
                case ConfigureNotify:
                    ws->iconx = ((XConfigureEvent *)&event)->x;
                    ws->icony = ((XConfigureEvent *)&event)->y;
                    break;
	    }
        }
        else {
            switch (event.type) {
                case SelectionRequest: {
                    tended struct descrip tmp;
                    if (selection_debug)
                        printf("SelectionRequest event:\n\towner=%lx requestor=%lx "
                               "property=%s target=%s selection=%s\n",
                               (long)event.xselectionrequest.owner,
                               (long)event.xselectionrequest.requestor,
                               atom_fmt(ws, event.xselectionrequest.property),
                               atom_fmt(ws, event.xselectionrequest.target),
                               atom_fmt(ws, event.xselectionrequest.selection)
                            );

                    MakeInt(SELECTIONREQUEST, &tmp);
                    list_put(&ws->listp, &tmp);
                    MakeInt((word)event.xselectionrequest.requestor, &tmp);
                    list_put(&ws->listp, &tmp);
                    get_atom_descriptor(ws, event.xselectionrequest.property, &tmp);
                    list_put(&ws->listp, &tmp);
                    get_atom_descriptor(ws, event.xselectionrequest.target, &tmp);
                    list_put(&ws->listp, &tmp);
                    get_atom_descriptor(ws, event.xselectionrequest.selection, &tmp);
                    list_put(&ws->listp, &tmp);
                    MakeInt(event.xselectionrequest.time, &tmp);
                    list_put(&ws->listp, &tmp);
                    break;
                }

                case SelectionClear: {
                    tended struct descrip tmp;
                    if (selection_debug)
                        printf("SelectionClear event win=%lx selection=%s\n",
                               (long)event.xselectionclear.window,
                               atom_fmt(ws, event.xselectionclear.selection));
                    MakeInt(SELECTIONCLEAR, &tmp);
                    list_put(&ws->listp, &tmp);
                    get_atom_descriptor(ws, event.xselectionclear.selection, &tmp);
                    list_put(&ws->listp, &tmp);
                    break;
                }

                case SelectionNotify: {
                    Atom actual_type, property;
                    int actual_format;
                    unsigned long bytes_after, nitems;
                    unsigned char *prop;
                    word bytes_read;
                    tended struct descrip tmp;
                    int status;
                    char *conv_str;

                    if (selection_debug)
                        printf("SelectionNotify: requestor=%lx selection=%s target=%s property=%s\n",
                               (long)event.xselection.requestor,
                               atom_fmt(ws, event.xselection.selection),
                               atom_fmt(ws, event.xselection.target),
                               atom_fmt(ws, event.xselection.property));

                    MakeInt(SELECTIONRESPONSE, &tmp);
                    list_put(&ws->listp, &tmp);
                    get_atom_descriptor(ws, event.xselection.selection, &tmp);
                    list_put(&ws->listp, &tmp);
                    get_atom_descriptor(ws, event.xselection.target, &tmp);
                    list_put(&ws->listp, &tmp);

                    if (event.xselection.property == None) {
                        if (selection_debug)
                            printf("XGetWindowProperty xselection.property == None\n");
                        list_put(&ws->listp, &nulldesc);
                        break;
                    }

                    property = XInternAtom(ws->display->display, "_OBJECTICON_PROP", False);

                    status = XGetWindowProperty(ws->display->display,
                                                ws->win,
                                                property,
                                                0,
                                                8192,   /* Means we won't get back > 32kb of stuff */
                                                True,
                                                AnyPropertyType,
                                                &actual_type,
                                                &actual_format,
                                                &nitems,
                                                &bytes_after,
                                                &prop);

                    if (status != Success) {
                        if (selection_debug)
                            printf("XGetWindowProperty failed\n");
                        list_put(&ws->listp, &nulldesc);
                        break;
                    }

                    if (actual_type == None) {
                        if (selection_debug)
                            printf("XGetWindowProperty returned actual_type == None\n");
                        list_put(&ws->listp, &nulldesc);
                        break;
                    }

                    /* Shouldn't ever happen */
                    if (!prop) {
                        if (selection_debug)
                            printf("XGetWindowProperty set prop to null\n");
                        list_put(&ws->listp, &nulldesc);
                        break;
                    }

                    bytes_read = nitems * (actual_format/8);
                    if (selection_debug)
                        printf("Got %lu items x %d bits -> %ld bytes\n",nitems, actual_format, (long)bytes_read);

                    conv_str = PropertyToString(ws->display->display,
                                                actual_type,
                                                nitems,
                                                prop);
                    if (conv_str) {
                        /* Make an Icon string out of the data */
                        cstr2string(conv_str, &tmp);
                        free(conv_str);
                    } else {
                        /* Make an Icon string out of the data */
                        bytes2string((char *)prop, bytes_read, &tmp);
                    }
                    list_put(&ws->listp, &tmp);

                    XFree(prop);
                    
                    break;
                }

                case KeyRelease: {
                    if (ws->inputmask & KeyReleaseMask) {
                        handle_keypress(wb, (XKeyEvent *)&event);
                    }
                    break;
                }
                case KeyPress:
                    handle_keypress(wb, (XKeyEvent *)&event);
                    break;
                case ButtonPress:
                    presscount++;
                    handle_mouse(wb, (XButtonEvent *)&event);
                    break;
                case ButtonRelease:
                    if (--presscount < 0) presscount = 0;
                    handle_mouse(wb, (XButtonEvent *)&event);
                    break;
                case MotionNotify:
                    if (presscount || wb->window->inputmask)
                        handle_mouse(wb, (XButtonEvent *)&event);
                    break;
                case NoExpose:
                    break;
                case Expose:
                    if (!handle_exposures(wb, (XExposeEvent *)&event))
                        return 1;
                    continue;
                case UnmapNotify:
                    wb->window->iconic = IconicState;
                    continue;
                case MapNotify:
                    if ((ws->width != DisplayWidth(wd->display, wd->screen)) ||
                        (ws->height != DisplayHeight(wd->display, wd->screen)))
                        ws->iconic = NormalState;
                    else
                        ws->iconic = MaximizedState;
                    continue;
                case ConfigureNotify:
                    if (!handle_config(wb, (XConfigureEvent *)&event)) {
                        return 0;
                    }
                    break;
                case ClientMessage: {
                    /*
                     * only client message we handle at present are destroy requests
                     */
                    if (event.xclient.data.l[0] == XInternAtom(ws->display->display, 
                                                               "WM_DELETE_WINDOW", False)) {
                        struct descrip d;
                        MakeInt(WINDOWCLOSED, &d);
                        qevent(wb->window, &d, 0, 0, 0, 0, 0);
                        return 1;
                    }
                    continue;
                }
                case DestroyNotify:
                    if (!ISZOMBIE(wb))
                        fatalerr(141, NULL);
                    /*
                     * first of all, we are done with this window
                     */
                    ws->win = (Window) NULL;

                    /*
                     * if there are no more references, we are done with the pixmap
                     *  too.  Free it and the colors allocated for this canvas.
                     */
                    if (ws->refcount == 0) {
                        if (wb->window->pix) {
                            Display *d = ws->display->display;
                            XSync(d, False);
                            if (ws->pix)
                                XFreePixmap(d, ws->pix);
                            ws->pix = (Pixmap) NULL;
                        }
#ifdef HAVE_LIBXFT
                        if (ws->pixDraw) {
                            XftDrawDestroy(ws->pixDraw);
                            ws->pixDraw = NULL;
                        }
#endif
                        if (ws->initialPix != (Pixmap) NULL) {
                            Display *d = ws->display->display;
                            XSync(d, False);
                            XFreePixmap(d, ws->initialPix);
                            ws->initialPix = (Pixmap) NULL;
                        }
                        free_xcolors(wb, 2); /* free regular colors */
                        free_xcolors(wb, 1); /* free icon colors */
                    }
                    break;
                default:
                    continue;
            }
        }
    }
    return 1;
}

/*
 * poll for available events on all opened displays.
 * this is where the interpreter calls into the X interface.
 */
void pollevent()
{
    wdp wd;
    for (wd = wdsplys; wd; wd = wd->next) {
        if (wd->program == curpstate)
            handle_misc(wd);
    }
}

/*
 * wclose - close a window.  If is a real on-screen window,
 * wait for a DestroyNotify event from the server before returning.
 */
void wclose(wbp w)
{
    STDLOCALS(w);

    XSync(stddpy, False);

    pollevent();

    /*
     * Force window to close (turn into a pixmap)
     */
    if (ws->win && ws->refcount > 1) {
        SETZOMBIE(w);
#ifdef HAVE_LIBXFT
        if (ws->winDraw) {
            XftDrawDestroy(ws->winDraw);
            ws->winDraw = NULL;
        }
#endif
        XDestroyWindow(stddpy,stdwin);
        XFlush(stddpy);
        while (ws->win)
            pollevent();
    }
    /*
     * Entire canvas terminates
     */
    else {
        free_xcolors(w, 2);
        free_xcolors(w, 1);
    }
}
/*
 * flush a window
 */
void wflush(wbp w)
{
    STDLOCALS(w);
    XFlush(stddpy);
}
/*
 * flush all windows
 */
void wflushall()
{
    wdp wd;
    for (wd = wdsplys; wd != NULL; wd = wd->next) {
        XFlush(wd->display);
    }
}
/*
 * sync all the servers
 */
void wsync(wbp w)
{
    wdp wd;
    if (w == NULL) {
        for (wd = wdsplys; wd != NULL; wd = wd->next) {
            XSync(wd->display, False);
        }
    }
    else
        XSync(w->window->display->display, False);
}

/*
 * open a window
 */
wbp wcreate(char *display)
{
    wbp w;
    wsp ws;
    w = alc_wbinding();
    w->window = alc_winstate();
    if ((w->window->display = alc_display(display)) == NULL) {
        LitWhy("Couldn't initialize display structure");
        free_binding(w);
        return 0;
    }
    ws = w->window;
    ws->vis = DefaultVisual(ws->display->display, ws->display->screen); 
    create_list(0, &ws->listp);

    /*
     * some attributes of the display and window are used in the context
     */
	
    w->context = alc_context(w);

    ws->height = 200;
    ws->width  = 200;
    ws->windowlabel = salloc(DEFAULT_WINDOW_LABEL);

    return w;
}

int wopen(wbp w, wbp parent)
{
    wsp ws = w->window;

    if (wmap(w, parent) != Succeeded) {
        LitWhy("Failed to map window");
        return Failed;
    }
	
    if (ws->win) {
        Atom WMDeleteWindow = XInternAtom(ws->display->display, "WM_DELETE_WINDOW", False);
        XSetWMProtocols(ws->display->display, ws->win, &WMDeleteWindow, 1);
    }

    return Succeeded;
}

/*
 * make an icon for a window
 */
static void makeIcon(wbp w, int x, int y)  /* x,y = current mouse position */
{
    int status;
    STDLOCALS(w);
   
    /* if a pixmap image has been specified, load it */
    if (ws->initicon.width) {
        ws->iconpix = XCreatePixmap(stddpy, DefaultRootWindow(stddpy),
                                    ws->iconw, ws->iconh,
                                    DefaultDepth(stddpy,wd->screen));
    }
    else if (ws->iconimage && strcmp(ws->iconimage, "")) {
        ws->iconpix = loadimage(w, ws->iconimage, &(ws->iconh), &(ws->iconw),
                                0, &status);
        ws->iconh += 6;
        ws->iconw += 6;
    }
    else {    /* determine the size of the icon window */
        ws->iconh = wd->fonts->ascent +
            wd->fonts->descent + 5;
        if (ws->iconlabel == NULL) ws->iconlabel = "";
#ifdef HAVE_LIBXFT
        ws->iconw = textwidth(w, ws->iconlabel,
                                  strlen(ws->iconlabel)) + 6;
#else
        ws->iconw = XTextWidth(wd->fonts->fsp, ws->iconlabel,
                               strlen(ws->iconlabel)) + 6;
#endif
    }

    /* if icon position hint exists, get it */
    if (ws->wmhintflags & IconPositionHint) {
        x = ws->iconx;
        y = ws->icony;
    }

    /* create the icon window */
    ws->iconwin = XCreateSimpleWindow(stddpy, DefaultRootWindow(stddpy), x, y,
                                      ws->iconw, ws->iconh, 2,
                                      wd->colors[wc->fg].c,
                                      wd->colors[wc->bg].c);

    /* select events for the icon window */
    XSelectInput(stddpy, ws->iconwin,
                 ExposureMask | KeyPressMask | ButtonPressMask |
                 StructureNotifyMask);

}


/*
 * Create a canvas.
 *  If a window, cause the window to actually become visible on the screen.
 *  returns Succeeded, Failed, or Error
 */
static int wmap(wbp w, wbp parent)
{
    XWindowAttributes attrs;
    XGCValues gcv;
    unsigned long gcmask =
        GCFont | GCForeground | GCBackground | GCFillStyle | GCCapStyle;
    struct imgdata *imd;
    int i;
    int new_pixmap = 0;
    struct descrip progname;
    char *p, *s, sbuf[256];
    XWMHints wmhints;
    XClassHint clhints;
    STDLOCALS(w);

    /*
     *  Create a pixmap for this canvas if there isn't one already.
     */
    if (ws->pix == (Pixmap) NULL) {
        if (ws->initialPix) {
            ws->pix = ws->initialPix;
            ws->initialPix = (Pixmap) NULL;
            ws->pixwidth = ws->width;
            ws->pixheight = ws->height;
        }
        else {
            ws->pix = XCreatePixmap(stddpy, DefaultRootWindow(stddpy),
                                    ws->width, ws->height,
                                    DefaultDepth(stddpy,wd->screen));
            ws->pixwidth = ws->width;
            ws->pixheight = ws->height;
            new_pixmap = 1;
        }
        stdpix = ws->pix;
    }


    /*
     * create the X window (or use the DefaultRootWindow if requested)
     */
    if (ws->iconic != HiddenState) {
        XSetWindowAttributes attr;
        attr.background_pixmap = None;
        attr.background_pixel = wd->colors[wc->bg].c;
        attr.border_pixel = wd->colors[wc->fg].c;
        attr.event_mask = StructureNotifyMask | ExposureMask;
 
        ws->win = ((ws->iconic == RootState) ? DefaultRootWindow(stddpy) :
                   XCreateSimpleWindow(stddpy, DefaultRootWindow(stddpy),
                                       ws->posx < 0 ? 0 : ws->posx,
                                       ws->posy < 0 ? 0 : ws->posy, ws->width,
                                       ws->height, 1,
                                       wd->colors[wc->fg].c,
                                       wd->colors[wc->bg].c));

        if (ws->win == (Window) NULL)
            return Failed;

        /* If the window has a parent, set the WM_TRANSIENT_FOR hint. */
        if (parent && parent->window->win)
            XSetTransientForHint(stddpy, ws->win, parent->window->win);

        /* Turn off background; this prevents X filling the background on an expose
           and hence prevents unsightly flicker on a resize. */
        if (ws->win)
            XSetWindowBackgroundPixmap(stddpy, ws->win, None);

        stdwin = ws->win;
        XClearWindow(stddpy, stdwin);
    }

    /*
     * before creating the graphics context, construct a description
     * of any non-default initial graphics context values.
     */
    gcv.foreground = wd->colors[wc->fg].c ^ (ISXORREVERSE(w) ? wd->colors[wc->bg].c : 0);
    gcv.background = wd->colors[wc->bg].c;
#ifdef HAVE_LIBXFT
    gcv.font       = wd->xfont->fid;
#else
    gcv.font       = wc->font->fsp->fid;
#endif
    if (wc->fillstyle)
        gcv.fill_style = wc->fillstyle;
    else
        gcv.fill_style = wc->fillstyle = FillSolid;
    if (wc->linestyle || wc->linewidth) {
        gcmask |= (GCLineWidth | GCLineStyle);
        gcv.line_width = wc->linewidth;
        gcv.line_style = wc->linestyle;
        if (wc->linewidth > 1) {
            gcv.dashes = 3 * wc->linewidth;
            gcmask |= GCDashList;
        }
    }
    else
        wc->linestyle = LineSolid;
    gcv.cap_style = CapProjecting;

    /*
     * Create a graphics context (or change an existing one to conform
     * with initial values).
     */
    if (stdgc == NULL) {
        wc->gc = XCreateGC(stddpy, stdpix, gcmask, &gcv);
        stdgc = wc->gc;
        if (stdgc == NULL) return Failed;
    }
    else
        XChangeGC(stddpy, stdgc, gcmask, &gcv);


    if (wc->clipw >= 0)
        setclip(w);

    if (new_pixmap) {
        XSetForeground(stddpy, stdgc, wd->colors[wc->bg].c);
        XFillRectangle(stddpy, ws->pix, stdgc, 0, 0, ws->width, ws->height);
        XSetForeground(stddpy, stdgc,
                       wd->colors[wc->fg].c ^(ISXORREVERSE(w)?wd->colors[wc->bg].c:0));
    }

    imd = &ws->initimage;
    if (imd->width) {
        drawstrimage(w, 0, 0, imd->width, imd->height, imd->paltbl,
                     imd->data, imd->width * imd->height);
        free(imd->paltbl);
        free(imd->data);
        imd->width = 0;
    }

    if (wc->patternname != NULL) {
        if (setpattern(w, wc->patternname) != Succeeded)
            return Failed;
    }

    /*
     *  if we are opening a pixmap, we are done at this point.
     */
    if (stdwin == (Window) NULL) return Succeeded;

    if (ws->iconic != RootState) {
        XSizeHints size_hints;
        size_hints.flags = PSize | PMinSize | PMaxSize;
        size_hints.width = ws->width;
        size_hints.height= ws->height;
        if (ws->posx == -(INT_MAX)) 
            ws->posx = 0;
        else
            size_hints.flags |= USPosition;
        if (ws->posy == -(INT_MAX)) 
            ws->posy = 0;
        else 
            size_hints.flags |= USPosition;
        size_hints.x = ws->posx;
        size_hints.y = ws->posy;
        if (ISRESIZABLE(w)) {
            size_hints.min_width = ws->minwidth;
            size_hints.min_height = ws->minheight;
            size_hints.max_width = ws->maxwidth;
            size_hints.max_height = ws->maxheight;
        }
        else {
            size_hints.min_width = size_hints.max_width = ws->width;
            size_hints.min_height = size_hints.max_height = ws->height;
        }
        if (ws->iconlabel == NULL) {
            ws->iconlabel = salloc(ws->windowlabel);
        }
        XSetStandardProperties(stddpy, stdwin, ws->windowlabel, ws->iconlabel,
                               0,0,0, &size_hints);
        XSelectInput(stddpy, stdwin, XMasks(ws->inputmask));
    }

    wmhints.input = True;
    wmhints.flags = InputHint;
    if (ws->iconic != RootState) {
        if (ws->iconimage != NULL) {
            makeIcon(w, ws->posx < 0 ? 0 : ws->posx, ws->posy < 0 ? 0 : ws->posy);
            wmhints.icon_window = ws->iconwin;
            ws->wmhintflags |= IconWindowHint;
        }
        wmhints.flags |= (ws->wmhintflags | StateHint);
        wmhints.initial_state = ws->iconic;
        wmhints.icon_x = ws->iconx;
        wmhints.icon_y = ws->icony;
    }
    XSetWMHints(stddpy, stdwin, &wmhints);

    /*
     * Set the class hints that name the program (for reference by the
     * window manager) following conventions given in O'Reilly.
     */
    cnv:string(kywd_prog, progname);
    if (! (s = getenv("RESOURCE_NAME"))) {
        p = StrLoc(progname);
        s = p + StrLen(progname);
        while (s > p && s[-1] != '/')
            s--;				/* find tail of prog_name */
        clhints.res_name = sbuf;
        clhints.res_class = "IconProg";
        for (i=0; s < p+StrLen(progname); ) clhints.res_name[i++] = *s++;
        clhints.res_name[i] = '\0';
        XSetClassHint(stddpy, stdwin, &clhints);
    }

    if (wd->cmap != DefaultColormap(stddpy,wd->screen)) { /* ? */
        XSetWindowColormap(stddpy, stdwin, wd->cmap);
    }
    XSync(stddpy, False);

    if (ws->iconic != RootState) {
        CLREXPOSED(w);
        XMapWindow(stddpy, stdwin);
    }

    XGetWindowAttributes(stddpy, stdwin, &attrs);
    ws->width = attrs.width;
    ws->height = attrs.height;
    if (!resizePixmap(w, ws->width, ws->height)) return Failed;

    if (stdwin) {
        i = ws->theCursor;
        if (!(wd->cursors[i]))
            wd->cursors[i] = XCreateFontCursor(stddpy, 2 * i);
        XDefineCursor(stddpy, stdwin, wd->cursors[i]);
    }

    /*
     * busy loop for an expose event, unless of course we are starting out
     *  in an iconic state
     */
    CLRZOMBIE(w);

    XSetFunction(stddpy, stdgc, wc->drawop);
    XSync(stddpy, False);

    return Succeeded;
}

int doconfig(wbp w, int status)
{
    wsp ws = w->window;
    wcp wc = w->context;
    wdp wd = ws->display;
    XTextProperty textprop;

    if (status & C_CLIP) {
        if (wc->clipw >= 0)
            setclip(w);
        else
            unsetclip(w);
    }

    if (status & (C_POS | C_SIZE | C_MINSIZE | C_MAXSIZE | C_RESIZE)) {
        if (!resizePixmap(w, ws->width, ws->height))
            return Failed;

        if (!ws->win)
            return Succeeded;

        if (status != C_POS) {
            XSizeHints size_hints;
            long t;

            /* Not just a move */

            XGetWMNormalHints(wd->display, ws->win, &size_hints, &t);
            if (ISRESIZABLE(w)) {
                size_hints.min_width = ws->minwidth;
                size_hints.min_height = ws->minheight;
                size_hints.max_width = ws->maxwidth;
                size_hints.max_height = ws->maxheight;
            }
            else {
                size_hints.min_width = size_hints.max_width = ws->width;
                size_hints.min_height = size_hints.max_height = ws->height;
            }
            XSetWMNormalHints(wd->display, ws->win, &size_hints);
        }

        switch (status & (C_POS|C_SIZE)) {
            case C_POS: {
                XMoveWindow(wd->display, ws->win, ws->posx, ws->posy);
                break;
            }
            case C_SIZE: {
                XResizeWindow(wd->display, ws->win, ws->width, ws->height);
                break;
            }
            case C_POS|C_SIZE: {
                XMoveResizeWindow(wd->display, ws->win, ws->posx, ws->posy, ws->width, ws->height);
                break;
            }
        }
        if (status & C_IMAGE) {
            struct imgdata *imd = &ws->initimage;
            if (imd->width) {
                drawstrimage(w, 0, 0, imd->width, imd->height, imd->paltbl,
                             imd->data, imd->width * imd->height);
                free(imd->paltbl);
                free(imd->data);
                imd->width = 0;
            }
        }

        /* XSync is not enough because the window manager gets involved here. */
        XFlush(wd->display);			      /* force out request */
        XGetWMName(wd->display, ws->win, &textprop);    /* force WM round trip */
        XSync(wd->display, False);		      /* NOW sync */
    }
        
    return Succeeded;
}

/*
 * Note that the three strings are pointers into the string space;
 * data is a safe pointer into a frame.
 */
int sendselectionresponse(wbp w, word requestor, char *property, char *target, char *selection, word time, dptr data)
{
    Atom property_atom, target_atom, selection_atom, XA_TARGETS, target_list[32];
    XEvent theevent;
    struct lgstate state;
    tended struct b_lelem *le;
    tended char *cstr_target;
    int target_cnt = 1;
    STDLOCALS(w);

    if (selection_debug)
        printf("sendselectionresponse:\n\trequestor=%lx "
               "property=%s target=%s selection=%s time=%ld\n",
               (long)requestor, property, target, selection, (long)time);

    property_atom = XInternAtom(ws->display->display, property, False);
    target_atom = XInternAtom(ws->display->display, target, False);
    selection_atom = XInternAtom(ws->display->display, selection, False);
    XA_TARGETS = XInternAtom(ws->display->display, "TARGETS", False);

    if (target_atom == XA_TARGETS) {
        if (!is:list(*data))
            ReturnErrVal(108, *data, Error);
        target_list[0] = XA_TARGETS;
        for (le = lgfirst(&ListBlk(*data), &state); le;
             le = lgnext(&ListBlk(*data), &state, le)) {
            if (!cnv:C_string(le->lslots[state.result], cstr_target))
                ReturnErrVal(148, le->lslots[state.result], Error);
            target_list[target_cnt++] = XInternAtom(ws->display->display, cstr_target, False);
            if (selection_debug)
                printf("\tAdding target:%s\n", cstr_target);
        }
        XChangeProperty(ws->display->display,
                        requestor,
                        property_atom,
                        target_atom,
                        32,
                        PropModeReplace,
                        (unsigned char *)target_list,
                        target_cnt);
        theevent.xselection.property = property_atom;
    } else if (is:null(*data)) {
        /* Can't handle this target type */
        if (selection_debug)
            printf("\tSetting property to None\n");
        theevent.xselection.property = None;
    } else {
        if (!cnv:string(*data, *data))
            ReturnErrVal(103, le->lslots[state.result], Error);
        if (selection_debug)
            printf("\tSetting property to %d bytes of data\n", (int)StrLen(*data));
        XChangeProperty(ws->display->display,
                        requestor,
                        property_atom,
                        target_atom,
                        8,
                        PropModeReplace,
                        (unsigned char *)StrLoc(*data),
                        StrLen(*data));
        theevent.xselection.property = property_atom;
    }

    theevent.type = SelectionNotify;
    theevent.xselection.serial = 0; /*event.xselectionrequest.serial;*/
    theevent.xselection.send_event = True;
    theevent.xselection.requestor = requestor;
    theevent.xselection.selection = selection_atom;
    theevent.xselection.target = target_atom;
    theevent.xselection.time = time;

    XSendEvent(ws->display->display,
               requestor,
               False, NoEventMask, &theevent);

    return Succeeded;
}

int ownselection(wbp w, char *selname)
{
    Atom selection;
    Window curr;
    {
    STDLOCALS(w);

    selection = XInternAtom(ws->display->display, selname, False);

    curr = XGetSelectionOwner(ws->display->display, selection);
    /* Check for no change in selection */
    if (curr == ws->win)
        return Succeeded;

    if (selection_debug)
        printf("Owner of selection %s set from %lx -> %lx\n", 
               atom_fmt(ws, selection),
               (long)curr,
               (long)ws->win);

    /*
     * X doesn't send a SelectionClear event to us when the selection
     * changes between our own windows, so if the current owner is one
     * our windows, send it a "clear" message.
     */
    if (curr) {
        wsp x;
        for (x = wstates; x; x = x->next) {
            if (x->win == curr) {
                tended struct descrip tmp;
                if (selection_debug)
                    printf("Enqueueing artificial SELECTIONCLEAR to current owner %lx\n",(long)curr);
                MakeInt(SELECTIONCLEAR, &tmp);
                list_put(&x->listp, &tmp);
                get_atom_descriptor(x, selection, &tmp);
                list_put(&x->listp, &tmp);
                break;
            }
        }
    }

    XSetSelectionOwner(ws->display->display, 
                       selection,
                       ws->win,
                       CurrentTime);

    return Succeeded;
    }
}

int requestselection(wbp w, char *selname, char *targetname)
{
    Atom selection, property, target;
    STDLOCALS(w);

    selection = XInternAtom(ws->display->display, selname, False);
    property = XInternAtom(ws->display->display, "_OBJECTICON_PROP", False);
    target = XInternAtom(ws->display->display, targetname, False);
    if (selection_debug)
        printf("getselectioncontent: calling XConvertSelection selection=%s target=%s property=%s requestor=%lx\n",
               atom_fmt(ws, selection),
               atom_fmt(ws, target),
               atom_fmt(ws, property),
               (long)ws->win);

    XConvertSelection(ws->display->display,
                      selection, 
                      target, 
                      property, 
                      ws->win,
                      CurrentTime);

    return Succeeded;
}

int warppointer(wbp w, int x, int y)
{
    wsp ws = w->window;
    XWarpPointer(ws->display->display, None, ws->win, 0,0,0,0, x, y);
    return Succeeded;
}

/*
 * #@#@ This is a bug
 */
int seticonlabel(wbp w, char *val)
{
    STDLOCALS(w);
    if (ws->iconlabel != NULL) free(ws->iconlabel);
    ws->iconlabel = salloc(val);
   
    if (stddpy && stdwin) {
        XSetIconName(stddpy, stdwin, w->window->iconlabel);
        if (ws->iconic == IconicState && !ws->iconpix && ws->iconwin) {
            XClearWindow(stddpy, ws->iconwin);
            XDrawString(stddpy, ws->iconwin, wd->icongc, 4,
                        wd->fonts->ascent + 2,
                        ws->iconlabel, strlen(ws->iconlabel));
        }
    }
    return Succeeded;
}

/*
 * setwindowlabel
 */
int setwindowlabel(wbp w, char *s)
{
    wsp ws = w->window;
    if (ws->windowlabel != NULL) free(ws->windowlabel);
    ws->windowlabel = salloc(s);

    if (ws->display && ws->display->display && ws->win)
        XStoreName(ws->display->display, ws->win,
                   *ws->windowlabel ? ws->windowlabel : " ");    /* empty string fails */
    return Succeeded;
}



/*
 * setpointer() - define a mouse pointer shape
 */
int setpointer(wbp w, char *val)
{
    int i = stringint_str2int(cursorsyms,val) >> 1;
    STDLOCALS(w);
    if (i < 0 || i >= NUMCURSORSYMS) return Failed;

    ws->theCursor = i;
    if (!(wd->cursors[i]))
        wd->cursors[i] = XCreateFontCursor(stddpy, 2 * i);
    if (stdwin)
        XDefineCursor(stddpy, stdwin, wd->cursors[i]);
    return Succeeded;
}

/*
 * setdrawop() - set the drawing operation
 */
int setdrawop(wbp w, char *val)
{
    int i;
    STDLOCALS(w);
    XSync(stddpy, False);
    if (!strcmp(val,"reverse")) {
        if (!ISXORREVERSE(w)) {
            SETXORREVERSE(w);
            wc->drawop = GXxor;
            if (stdgc)
                XSetForeground(stddpy, stdgc,
                               wd->colors[wc->fg].c ^ wd->colors[wc->bg].c);
        }
    }
    else {
        if (ISXORREVERSE(w)) {
            CLRXORREVERSE(w);
            if (stdgc)
                XSetForeground(stddpy, stdgc, wd->colors[wc->fg].c);
        }
        if ((i = stringint_str2int(drawops,val)) < 0)
            return Error;
        wc->drawop = i;
    }
    if (stdgc) XSetFunction(stddpy, stdgc, wc->drawop);
    return Succeeded;
}

/*
 * rebind() - bind w's context to that of w2.
 */
int rebind(wbp w, wbp w2)
{
    if (w->window->display != w2->context->display) return Failed;
    w->context = w2->context;
    return Succeeded;
}


static void setclip(wbp w)
{
    wcp wc = w->context;
    XRectangle rec;
    if (wc->gc) {
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XSetClipRectangles(wc->display->display, wc->gc, 0, 0, &rec, 1,Unsorted);
    }
}

static void unsetclip(wbp w)
{
    wcp wc = w->context;
    if (wc->gc) {
        XSetClipMask(wc->display->display, wc->gc, None);
    }
}

void getcanvas(wbp w, char *s)
{
    if (w->window->win == (Window) NULL) sprintf(s, "hidden");
    else
        switch (w->window->iconic) {
            case RootState:
                sprintf(s, "root");
                break;
            case NormalState:
                sprintf(s, "normal");
                break;
            case IconicState:
                sprintf(s, "iconic");
                break;
            case MaximizedState:
                sprintf(s, "maximal");
                break;
            case HiddenState:
                sprintf(s, "hidden");
                break;
            default:
                sprintf(s, "???");
        }
}


int setinputmask(wbp w, char *val)
{
    wsp ws = w->window;
    if (strchr(val,'k')) {
        ws->inputmask |= KeyReleaseMask;
    }
    else {
        ws->inputmask &= ~KeyReleaseMask;
    }
    if (strchr(val,'m')) {
        ws->inputmask |= PointerMotionMask;
    }
    else {
        ws->inputmask &= ~PointerMotionMask;
    }

    if (ws->win)
        XSelectInput(ws->display->display, ws->win, XMasks(ws->inputmask));
    return Succeeded;
}

/*
 *  Set the canvas type, either during open (pixmap is null, set a flag)
 *   or change an existing canvas to a different type.
 */
int setcanvas(wbp w, char *s)
{
    STDLOCALS(w);

    if (!strcmp(s, "iconic")) {
        if (ws->pix == (Pixmap) NULL) {
            ws->wmhintflags |= StateHint;
            ws->iconic = IconicState;
        }
        else {
            if (ws->iconic != IconicState) {
                if (ws->win == (Window) NULL) {
                    wmap(w, 0);
                }
                XIconifyWindow(ws->display->display, ws->win, ws->display->screen);
                XSync(stddpy, False);
                while (ws->iconic != IconicState)
                    if (handle_misc(wd) < 1) {
                        return Failed;
                    }
	    }
        }
    }

    else if (!strcmp(s, "normal")) {
        if (ws->pix == (Pixmap) NULL) {
            ws->iconic = NormalState;
        }
        else {
            if (ws->win == (Window) NULL) {
                ws->iconic = NormalState;
                ws->initialPix = ws->pix;
                ws->pix = (Window) NULL;
                wmap(w, 0);
	    }
            else if (ws->iconic == IconicState) {
                XMapWindow(stddpy, stdwin);
                XSync(stddpy, False);
                while (ws->iconic == IconicState)
                    pollevent();
	    }
            else if (ws->iconic == MaximizedState) {
                ws->posx = ws->normalx;
                ws->posy = ws->normaly;
                ws->width = ws->normalw;
                ws->height = ws->normalh;
                doconfig(w, C_POS | C_SIZE);
                ws->iconic = NormalState;
	    }
        }
    }
    else if (!strcmp(s, "maximal")) {
        if (ws->iconic != MaximizedState) {
            int expect_config= (ws->width != DisplayWidth(stddpy, wd->screen)) ||
                (ws->height != DisplayHeight(stddpy, wd->screen));
            ws->normalx = ws->posx;
            ws->normaly = ws->posy;
            ws->normalw = ws->width;
            ws->normalh = ws->height;
            ws->width = DisplayWidth(stddpy, wd->screen);
            ws->height= DisplayHeight(stddpy, wd->screen);
            if (ws->pix != (Pixmap) NULL) {
                if (ws->win == (Window) NULL) {
                    ws->iconic = MaximizedState;
                    ws->initialPix = ws->pix;
                    ws->pix = (Window) NULL;
                    wmap(w, 0);
                }
                else if (ws->iconic == IconicState) {
                    XMapWindow(stddpy, stdwin);
                    XSync(stddpy, False);
                    while (ws->iconic == IconicState)
                        pollevent();
                }
                else if (expect_config) {
                    ws->posx = ws->posy = 0;
                    doconfig(w, C_POS | C_SIZE);
                    pollevent();
                    ws->posx = -ws->posx;
                    ws->posy = -ws->posy;
                    doconfig(w, C_POS);
                }
	    }
            ws->iconic = MaximizedState;
        }
    }
    else if (!strcmp(s, "hidden")) {
        if (ws->pix == (Pixmap)NULL) {
            ws->iconic = HiddenState;
        }
        else {
            if (ws->win != (Window) NULL) {
                if (ws->iconic == MaximizedState) {
                    ws->posx = ws->normalx;
                    ws->posy = ws->normaly;
                    ws->width = ws->normalw;
                    ws->height = ws->normalh;
                    ws->iconic = NormalState;
                }
                if (ws->iconic != IconicState) {
                    SETZOMBIE(w);
#ifdef HAVE_LIBXFT
                    if (ws->winDraw) {
                        XftDrawDestroy(ws->winDraw);
                        ws->winDraw = NULL;
                    }
#endif
                    XDestroyWindow(stddpy, stdwin);
                    XFlush(stddpy);
                    while (ws->win)
                        pollevent();
                }
	    }
        }
    }
    else return Error;
    XSync(ws->display->display, False);
    return Succeeded;
}

int seticonicstate(wbp w, char *s)
{
    STDLOCALS(w);

    if (!strcmp(s, "icon")) {
        if (ws->pix == (Pixmap) NULL) {
            ws->wmhintflags |= StateHint;
            ws->iconic = IconicState;
        }
        else {
            if (ws->iconic != IconicState) {
                XIconifyWindow(ws->display->display, ws->win, ws->display->screen);
	    }
        }
    }
    else if (!strcmp(s, "window")) {
        if (ws->win != (Window) NULL) {
            if (ws->iconic == IconicState) {
                XMapWindow(stddpy, stdwin);
	    }
        }
    }
    else if (!strcmp(s, "root")) {
        if (ws->win == (Window) NULL)
            ws->iconic = RootState;
        else return Failed;
    }
    else return Error;
    XSync(ws->display->display, False);
    return Succeeded;
}

int seticonpos(wbp w, char *s)
{
    char *s2;
    wsp ws = w->window;

    ws->wmhintflags |= IconPositionHint;
    s2 = s;
    ws->iconx = atol(s2);
    while (isspace((unsigned char)*s2)) s2++;
    while (isdigit((unsigned char)*s2)) s2++;
    if (*s2++ != ',') return Error;
    ws->icony = atol(s2);

    if (ws->win) {
        if (ws->iconwin == (Window) NULL)
            makeIcon(w, ws->iconx, ws->icony);
        if (remap(w, ws->iconx, ws->icony) == -1) return Error;
    }
    return Succeeded;
}

int geticonpos(wbp w, char *s)
{
    wsp ws = w->window;
    sprintf(s,"%d,%d", ws->iconx, ws->icony);
    return Succeeded;
}


/*
 * Set the context's fill style by name.
 */
int setfillstyle(wbp w, char *s)
{
    STDLOCALS(w);

    if (!strcmp(s, "solid")) {
        wc->fillstyle = FillSolid;
    }
    else if (!strcmp(s, "masked")
             || !strcmp(s, "stippled") || !strcmp(s, "patterned")) {
        wc->fillstyle = FillStippled;
    }
    else if (!strcmp(s, "textured")
             || !strcmp(s, "opaquestippled") || !strcmp(s, "opaquepatterned")) {
        wc->fillstyle = FillOpaqueStippled;
    }
    else return Error;
    if (stdpix) {
        XSetFillStyle(stddpy, stdgc, wc->fillstyle);
    }
    return Succeeded;
}

/*
 * Set the context's line style by name.
 */
int setlinestyle(wbp w, char *s)
{
    STDLOCALS(w);

    if (!strcmp(s, "solid")) {
        wc->linestyle = LineSolid;
    }
    else if (!strcmp(s, "onoff") || !strcmp(s, "dashed")) {
        wc->linestyle = LineOnOffDash;
    }
    else if (!strcmp(s, "doubledash") || !strcmp(s, "striped")) {
        wc->linestyle = LineDoubleDash;
    }
    else return Error;
    if (stdpix) {
        XSetLineAttributes(stddpy, stdgc,
                           wc->linewidth, wc->linestyle, CapProjecting, JoinMiter);
    }
    return Succeeded;
}

/*
 * Set the context's line width
 */
int setlinewidth(wbp w, int linewid)
{
    unsigned long gcmask;
    XGCValues gcv;
    STDLOCALS(w);

    if (linewid < 0) return Error;
    wc->linewidth = linewid;
    if (stdpix) {
        gcv.line_width = linewid;
        gcv.line_style = wc->linestyle;
        if (linewid > 1)
            gcv.dashes = 3 * wc->linewidth;
        else
            gcv.dashes = 4;
        gcmask = GCLineWidth | GCLineStyle | GCDashList;
        XChangeGC(stddpy, stdgc, gcmask, &gcv);
    }
    return Succeeded;
}

int getlinewidth(wbp w)
{
    return w->context->linewidth;
}

/*
 * Reset the context's foreground color to whatever it is supposed to be.
 */
static int resetfg(wbp w)
{
    wcp wc = w->context;
    wdp wd = wc->display;
    if (wc->gc != NULL)
        XSetForeground(wc->display->display, wc->gc,
                       wd->colors[wc->fg].c ^ (ISXORREVERSE(w) ? wd->colors[wc->bg].c : 0));
    return Succeeded;
}

/*
 * Set the context's foreground color by name.
 */
int setfg(wbp w, char *s)
{
    wclrp cp;
    long r, g, b, a;
    wcp wc = w->context;
    wdp wd = w->window->display;
    /*
     * convert color to an r,g,b triple
     */
    if (parsecolor(w, s, &r, &g, &b, &a) != Succeeded)
        return Error;
    Protect(cp = alc_rgb(w, s, r, g, b, 0), return Failed);
    wc->fg = (cp - wd->colors);
    return resetfg(w);
}

static int setfgrgb(wbp w, int r, int g, int b)
{
    char sbuf1[32];
    sprintf(sbuf1, "%d,%d,%d", r, g, b);
    return setfg(w, sbuf1);
}

/*
 * Set the context's foreground color by color cell.
 */
int isetfg(wbp w, int fg)
{
    int i, r, g, b;
    STDLOCALS(w);

    if (fg >= 0) {
        b = fg & 255;
        fg >>= 8;
        g = fg & 255;
        fg >>= 8;
        r = fg & 255;
        return setfgrgb(w, r * 257, g * 257, b * 257);
    }
    for (i = 2; i < DMAXCOLORS; i++)
        if (wd->colors[i].type == MUTABLE && wd->colors[i].c == -fg - 1)
            break;
    if (i == DMAXCOLORS) return Failed;
    wc->fg = i;
    return resetfg(w);
}

/*
 * Set the window context's background color by name.
 */
int setbg(wbp w, char *s)
{
    wclrp cp;
    long r, g, b, a;
    wcp wc = w->context;
    wdp wd = w->window->display;
    GC stdgc = wc->gc;
    Display *stddpy = wd->display;
    /*
     * convert color to an r,g,b triple
     */
    if (parsecolor(w, s, &r, &g, &b, &a) != Succeeded)
        return Error;
    Protect(cp = alc_rgb(w, s, r, g, b, 0), return Failed);
    wc->bg = (cp - wd->colors);
    if (stdgc != NULL)
        XSetBackground(stddpy, stdgc, cp->c);
    return ISXORREVERSE(w) ? resetfg(w) : Succeeded;
}

static int setbgrgb(wbp w, int r, int g, int b)
{
    char sbuf1[32];
    sprintf(sbuf1, "%d,%d,%d", r, g, b);
    return setbg(w, sbuf1);
}

/*
 * Set the context's background color by color cell.
 */
int isetbg(wbp w, int bg)
{
    int i, r, g, b;
    STDLOCALS(w);

    if (bg >= 0) {
        b = bg & 255;
        bg >>= 8;
        g = bg & 255;
        bg >>= 8;
        r = bg & 255;
        return setbgrgb(w, r * 257, g * 257, b * 257);
    }
    for (i = 2; i < DMAXCOLORS; i++)
        if (wd->colors[i].type == MUTABLE && wd->colors[i].c == -bg - 1)
            break;
    if (i == DMAXCOLORS) return Failed;
    wc->bg = i;
    if (stdgc != NULL)
        XSetBackground(stddpy, stdgc, wd->colors[wc->bg].c);
    return ISXORREVERSE(w) ? resetfg(w) : Succeeded;
}

/*
 * Set the gamma correction value.
 */
int setgamma(wbp w, double gamma)
{
    wcp wc = w->context;
    wdp wd = w->window->display;
    wc->gamma = gamma;
    setfg(w, wd->colors[wc->fg].name);	/* reinterpret current Fg/Bg spec */
    setbg(w, wd->colors[wc->bg].name);
    return Succeeded;
}

/*
 * Set the display by name.  Really should cache answers as per fonts below;
 * for now just open a new display each time.  Note that this can only be
 * called before a window is instantiated...
 */
int setdisplay(wbp w, char *s)
{
    wdp d;
    /* can't change display for mapped window! */
    if (w->window->pix != (Pixmap) NULL)
        return Failed;

    Protect(d = alc_display(s), return 0);
    w->window->display = d;
    w->context->fg = 0;
    w->context->bg = 1;
    w->context->font = d->fonts;
    return Succeeded;
}

int setleading(wbp w, int i)
{
    w->context->leading = i;
    return Succeeded;
}

int setimage(wbp w, char *val)
{
    wsp ws = w->window;
    int status;
    ws->initialPix = loadimage(w, val, &(ws->height), &(ws->width),
                               0, &status);
    if (ws->initialPix == (Pixmap) NULL) return Failed;
    return Succeeded;
}

void togglefgbg(wbp w)
{
    int tmp;
    STDLOCALS(w);
    tmp = wc->fg;
    wc->fg = wc->bg;
    wc->bg = tmp;
    if (stdpix) {
        XSetForeground(stddpy, stdgc,
                       wd->colors[wc->fg].c ^ (ISXORREVERSE(w)?wd->colors[wc->bg].c:0));
        XSetBackground(stddpy, stdgc, wd->colors[wc->bg].c);
    }
}

void getdisplay(wbp w, char *answer)
{
    char *tmp;
    wdp wd = w->window->display;
    if (!strcmp(wd->name, "")) {
        if ((tmp = getenv("DISPLAY")) != NULL)
            sprintf(answer, "%s", tmp);
        else
            *answer = '\0';
    }
    else sprintf(answer, "%s", wd->name);
}

int geticonimage(wbp w, char *answer)
{
    if (!w->window->iconimage)
        return Failed;
    strcpy(answer, w->window->iconimage);
    return Succeeded;
}

int geticonlabel(wbp w, char *answer)
{
    if (!w->window->iconlabel)
        return Failed;
    strcpy(answer, w->window->iconlabel);
    return Succeeded;
}

int getwindowlabel(wbp w, char *answer)
{
    if (!w->window->windowlabel)
        return Failed;
    strcpy(answer, w->window->windowlabel);
    return Succeeded;
}

int getdisplaysize(wbp w, int *width, int *height)
{
    *width = DisplayWidth(w->window->display->display, w->window->display->screen);
    *height = DisplayHeight(w->window->display->display, w->window->display->screen);
    return Succeeded;
}

int getdepth(wbp w, int *res)
{
    *res = DefaultDepth(w->window->display->display, w->window->display->screen);
    return Succeeded;
}

int getvisual(wbp w, char *answer)
{
    wdp wd = w->window->display;
    Visual * v = DefaultVisual(wd->display,wd->screen);
    sprintf(answer, "%d,%d,%d", v->class, v->bits_per_rgb, v->map_entries );
    return Succeeded;
}
/*
 * getpos() - update the window state's notion of its current position
 */
int getpos(wbp w)
{
    Window garbage1, garbage2;
    int root_x, root_y, win_x, win_y;
    unsigned int key_buttons;
    STDLOCALS(w);
    if (!stdwin) return Failed;
    /*
     * This call is made because it is guaranteed to generate
     * a synchronous request of the server, not just ask Xlib
     * what the window position was last it knew.
     */
    if (XQueryPointer(stddpy, stdwin, &garbage1, &garbage2,
                      &root_x, &root_y, &win_x, &win_y, &key_buttons) ==
        False) {
        return Failed;
    }
    ws->posx = root_x - win_x;
    ws->posy = root_y - win_y;
    return Succeeded;
}

void getfg(wbp w, char *answer)
{
    sprintf(answer, "%s", w->window->display->colors[w->context->fg].name);
}

void getbg(wbp w, char *answer)
{
    sprintf(answer, "%s", w->window->display->colors[w->context->bg].name);
}

void getlinestyle(wbp w, char *answer)
{
    wcp wc = w->context;
    sprintf(answer,"%s",
            (wc->linestyle==LineSolid)?"solid":
            ((wc->linestyle==LineOnOffDash)?"dashed":"striped"));
}

void getpointername(wbp w, char *answer)
{
    strcpy(answer, stringint_int2str(cursorsyms, 2 * w->window->theCursor));
}

void getdrawop(wbp w, char *answer)
{
    char *s;
    if (ISXORREVERSE(w)) s = "reverse";
    else s = stringint_int2str(drawops, w->context->drawop);
    if (s) sprintf(answer, "%s", s);
    else strcpy(answer, "copy");
}

void geticonic(wbp w, char *answer)
{
    switch (w->window->iconic) {
        case RootState:
            sprintf(answer, "root");
            break;
        case NormalState:
            sprintf(answer, "window");
            break;
        case IconicState:
            sprintf(answer, "icon");
            break;
        default:
            sprintf(answer, "???");
    }
}

/*
 * Set the window's font by name.
 */
int setfont(wbp w, char *s)
{
    wfp tmp;
    STDLOCALS(w);

    /* could free up previously allocated font here */

    Protect(tmp = alc_font(w,s), return Failed);
    wc->font = tmp;

#ifndef HAVE_LIBXFT
    if (stdgc != NULL)
        XSetFont(stddpy, stdgc, wc->font->fsp->fid);
#endif

    return Succeeded;
}

/*
 * callback procedures
 */

static int handle_exposures(wbp w, XExposeEvent *event)
{
    int returnval;
    STDLOCALS(w);
    returnval = ISEXPOSED(w);
    SETEXPOSED(w);
    if (stdwin && !ISZOMBIE(w)) {
/* if its a 3D window, do we skip this part ?? */
        if (wc->drawop != GXcopy)
            XSetFunction(stddpy, stdgc, GXcopy);
        if (wc->clipw >= 0)
            unsetclip(w);
        XCopyArea(stddpy, stdpix, stdwin, stdgc, event->x,event->y,
                  event->width,event->height, event->x,event->y);
        if (wc->clipw >= 0)
            setclip(w);
        if (wc->drawop != GXcopy)
            XSetFunction(stddpy,stdgc,wc->drawop);
/* end of " if its a 3D window " */


    }
    return returnval;
}

/*
 * resizePixmap(w,width,height) -- ensure w's backing pixmap is at least
 * width x height pixels.
 *
 * Resizes the backing pixmap, if needed.  Called when X resize events
 * arrive, as well as when programs make explicit resize requests.
 *
 * Returns 0 on failure.
 */
static int resizePixmap(wbp w, int width, int height)
{
    Pixmap p;
    STDLOCALS(w);
    if (ws->pix == (Pixmap) NULL) return 1;
    if ((width > ws->pixwidth) || (height > ws->pixheight)) {
        int x = ws->pixwidth, y = ws->pixheight;

        ws->pixheight = Max(ws->pixheight, height);
        ws->pixwidth  = Max(ws->pixwidth, width);
        p = XCreatePixmap(stddpy, DefaultRootWindow(stddpy), ws->pixwidth,
                          ws->pixheight, DefaultDepth(stddpy,wd->screen));
        if (p == (Pixmap) NULL)
            return 0;

        /*
         * This staggering amount of redudancy manages to make sure the new
         * pixmap gets initialized including areas not in the old pixmap.
         * The window is redrawn.
         */
        XSetForeground(stddpy, stdgc, wd->colors[wc->bg].c);
        if (wc->drawop != GXcopy)
            XSetFunction(stddpy, stdgc, GXcopy);
        if (wc->fillstyle != FillSolid)
            XSetFillStyle(stddpy, stdgc, FillSolid);
        if (wc->clipw >= 0)
            unsetclip(w);
	   
        if (width > x) {
            XFillRectangle(stddpy, p, stdgc, x, 0, width-x, ws->pixheight);
            if (stdwin != (Window) NULL)
                XFillRectangle(stddpy,stdwin,stdgc, x, 0, width-x, ws->pixheight);
        }
        if (height > y) {
            XFillRectangle(stddpy, p, stdgc, 0, y, x, height - y);
            if (stdwin != (Window) NULL)
                XFillRectangle(stddpy, stdwin, stdgc, 0, y, x, height - y);
        }
        XSetForeground(stddpy, stdgc,
                       wd->colors[wc->fg].c ^ (ISXORREVERSE(w)?wd->colors[wc->bg].c:0));
        XCopyArea(stddpy, stdpix, p, stdgc, 0, 0, x, y, 0, 0);
        if (wc->drawop != GXcopy)
            XSetFunction(stddpy,stdgc,wc->drawop);
        if (wc->fillstyle != FillSolid)
            XSetFillStyle(stddpy, stdgc, wc->fillstyle);
        if (wc->clipw >= 0)
            setclip(w);

        XFreePixmap(stddpy, stdpix);	/* free old pixmap */
        ws->pix = p;
#ifdef HAVE_LIBXFT
        if (ws->pixDraw) {
            XftDrawDestroy(ws->pixDraw);
            ws->pixDraw = NULL;
        }
#endif
    }
    return 1;
}

/*
 * Resize operations are made as painless as possible, but the
 * user program is informed anyhow.  The integer coordinates are
 * the new size of the window, in pixels.
 */
static int handle_config(wbp w, XConfigureEvent *event)
{
    struct descrip d;
    STDLOCALS(w);

    /*
     * Update X-Icon's information about the window's configuration
     */

    ws->posx = event->x;
    ws->posy = event->y;

    /*
     * If this was not a resize, drop it
     */
    if ((event->width == ws->width) && (event->height == ws->height))
        return 1;

    ws->width = event->width;
    ws->height = event->height;

    if (! resizePixmap(w, event->width, event->height)) return 0;


    /*
     * The initial configure event generates no Icon-level "events"
     */
    if (!ISEXPOSED(w))
        return 1;

    MakeInt(RESIZED, &d);
    qevent(w->window, &d, 0, 0, 0, 0, 0);
    return 1;
}

/*
 * Queue up characters for keypress events.
 */
static void handle_keypress(wbp w, XKeyEvent *event)
{
    int i,j;
    char s[10];
    tended struct descrip d;
    KeySym k;

    /* First try to convert the event to a simple char string, and a KeySym */
    i = XLookupString(event, s, sizeof(s), &k, NULL);
    if (i > 0) {
        /* Found a char string, so generate string event(s) */
        StrLen(d) = 1;
        for (j = 0; j < i; j++) {
            StrLoc(d) = &allchars[s[j] & 0xFF];
            qevent(w->window, &d, event->x, event->y,
                   (uword)event->time, event->state,
                   (event->type == KeyRelease) );
        }
        return;
    }

    /* Second try is to convert to a unicode char; if found generate a 1-char
     * ucs/string */
    i = convert_KeySym_to_code_point(k);
    if (i > 0) {
        if (i < 256) {
            StrLen(d) = 1;
            StrLoc(d) = &allchars[i];
        } else {
            d.dword = D_Ucs;
            BlkLoc(d) = (union block *)make_one_char_ucs_block(i);
        }
        qevent(w->window, &d, event->x, event->y,
               (uword)event->time, event->state,
               (event->type == KeyRelease) );
        return;
    }

    /* Neither of those worked, so it must be a non-character key (cursor key, etc).
     * So just generate the numerical value of the KeySym as an integer.
     */
    MakeInt(k, &d);
    qevent(w->window, &d, event->x, event->y,
           (uword)event->time, event->state,
           (event->type == KeyRelease) );
}

#include "rxkeysyms.ri"

#define swap(a,b) { tmp = a; a = b; b = tmp; }
/*
 * Handle button presses and drag events.  In the case of drags, we should
 * really be looking at an XMotionEvent instead of an XButtonEvent, but
 * the structures are identical up to the button field (which we do not
 * examine for drag events).  Mouse coordinates are queued up after the event.
 */
static void handle_mouse(wbp w, XButtonEvent *event)
{
    static unsigned int buttonorder[3] =
        { Button1Mask, Button2Mask, Button3Mask };
    unsigned int tmp;
    int eventcode = 0;
    struct descrip d;

    if (event->type == MotionNotify) {
        if (event->state & buttonorder[0]) {
            if (buttonorder[0] == Button1Mask)
                eventcode = MOUSELEFTDRAG;
            else if (buttonorder[0] == Button2Mask)
                eventcode = MOUSEMIDDRAG;
            else
                eventcode = MOUSERIGHTDRAG;
        }
        else if (event->state & buttonorder[1]) {
            if (buttonorder[1] == Button1Mask)
                eventcode = MOUSELEFTDRAG;
            else if (buttonorder[1] == Button2Mask)
                eventcode = MOUSEMIDDRAG;
            else
                eventcode = MOUSERIGHTDRAG;
        }
        else if (event->state & buttonorder[2]) {
            if (buttonorder[2] == Button1Mask)
                eventcode = MOUSELEFTDRAG;
            else if (buttonorder[2] == Button2Mask)
                eventcode = MOUSEMIDDRAG;
            else
                eventcode = MOUSERIGHTDRAG;
        }
        else {
            eventcode = MOUSEMOVED;
        }
    }
    else switch (event->button) {
        case Button1: {
            eventcode = MOUSELEFT;
            if (buttonorder[2] == Button1Mask)
                swap(buttonorder[1],buttonorder[2]);
            if (buttonorder[1] == Button1Mask)
                swap(buttonorder[0],buttonorder[1]);
            break;
        }
        case Button2: {
            eventcode = MOUSEMID;
            if (buttonorder[2] == Button2Mask)
                swap(buttonorder[1],buttonorder[2]);
            if (buttonorder[1] == Button2Mask)
                swap(buttonorder[0],buttonorder[1]);
            break;
        }
        case Button3: {
            eventcode = MOUSERIGHT;
            if (buttonorder[2] == Button3Mask)
                swap(buttonorder[1],buttonorder[2]);
            if (buttonorder[1] == Button3Mask)
                swap(buttonorder[0],buttonorder[1]);
            break;
        }
        case Button4: {
            eventcode = MOUSE4;
            break;
        }
        case Button5: {
            eventcode = MOUSE5;
            break;
        }
    }
    if (event->type == ButtonRelease) {
        eventcode -= (MOUSELEFT - MOUSELEFTUP);
        swap(buttonorder[0],buttonorder[1]);
        swap(buttonorder[1],buttonorder[2]);
    }

    /*
     * Don't generate events for these codes.  Rather, MOUSE4UP and
     * MOUSE5UP are used to generate the &wheelup and &wheeldown
     * events respectively.
     */
    if (eventcode == MOUSE4 || eventcode == MOUSE5)
        return;

    MakeInt(eventcode,&d);

    qevent(w->window, &d, event->x, event->y, (uword)event->time, event->state, 0);
}


void drawarc(wbp w, int x, int y, int width, int height, double angle1, double angle2)
{
    XArc arc;
    STDLOCALS(w); 
    arc.x = x;
    arc.y = y;
    arc.width = width;
    arc.height = height;
    arc.angle1 = CONVERT_ANGLE(angle1);
    arc.angle2 = CONVERT_ANGLE(angle2);
    RENDER2(XDrawArcs,&arc,1);
}

void drawlines(wbp w, XPoint *points, int npoints)
{
    STDLOCALS(w); 
    RENDER3(XDrawLines,points,npoints,CoordModeOrigin);
}

void drawpoint(wbp w, int x, int y)
{
    XPoint p;
    STDLOCALS(w);
    p.x = x;
    p.y = y;
    RENDER3(XDrawPoints,&p,1,CoordModeOrigin);
}

void drawrectangle(wbp w, int x, int y, int width, int height)
{
   STDLOCALS(w);
   RENDER4(XDrawRectangle,x,y,width-1,height-1);
}

void fillarc(wbp w, int x, int y, int width, int height, double angle1, double angle2)
{ 
    XArc arc;
    STDLOCALS(w); 
    arc.x = x;
    arc.y = y;
    arc.width = width;
    arc.height = height;
    arc.angle1 = CONVERT_ANGLE(angle1);
    arc.angle2 = CONVERT_ANGLE(angle2);
    RENDER2(XFillArcs, &arc, 1);
}

void fillpolygon(wbp w, XPoint *points, int npoints)
{
    STDLOCALS(w); 
    RENDER4(XFillPolygon, points, npoints, Complex, CoordModeOrigin);
}

/*
 * fill a rectangle
 */
void fillrectangle(wbp w, int x, int y, int width, int height)
{
    XRectangle rec;
    STDLOCALS(w);
    rec.x = x;
    rec.y = y;
    rec.width = width;
    rec.height = height;
    /*
     * Free colors if drawop=copy, fillstyle~=masked, no clipping,
     * and a single rectangle that fills the whole window.
     */
    if (!rec.x && !rec.y && rec.width >= ws->width &&
        rec.height >= ws->height &&
        wc->drawop == GXcopy && wc->fillstyle != FillStippled && wc->clipw < 0) {
        rec.width = ws->pixwidth;	/* fill hidden part */
        rec.height = ws->pixheight;
        free_xcolors(w, 0);			/* free old colors */
    }
    RENDER2(XFillRectangles, &rec, 1);
}

/*
 * erase an area
 */
void erasearea(wbp w, int x, int y, int width, int height)
{
    STDLOCALS(w);

    /*
     * if width >= window width or height >= window height, clear any
     * offscreen portion as well in order to allow the freeing of colors.
     */
    if (x + width  >= (int)ws->width)  width  = ws->pixwidth - x;
    if (y + height >= (int)ws->height) height = ws->pixheight - y;

    /*
     * fill the rectangle with the background color
     */
    XSetForeground(stddpy, stdgc, wd->colors[wc->bg].c);
    if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, GXcopy);
    if (wc->fillstyle != FillSolid) XSetFillStyle(stddpy, stdgc, FillSolid);

    RENDER4(XFillRectangle, x, y, width, height);
    XSetForeground(stddpy, stdgc,
                   wd->colors[wc->fg].c ^ (ISXORREVERSE(w)?wd->colors[wc->bg].c:0));
    if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, wc->drawop);
    if (wc->fillstyle != FillSolid) XSetFillStyle(stddpy, stdgc, wc->fillstyle);

    /*
     * if the entire window is cleared, free up colors
     */
    if (!x && !y && width >= ws->pixwidth && height >= ws->pixheight &&
        wc->clipw < 0) {
        free_xcolors(w, 0);
    }
}

/*
 * copy an area
 */
int copyarea(wbp w, wbp w2, int x, int y, int width, int height, int x2, int y2)
{
    int lpad, rpad, tpad, bpad;
    Pixmap src;
    wsp ws1 = w->window, ws2 = w2->window;
    wclrp cp, cp2 = NULL;
    STDLOCALS(w2);

    if (w->window->display->display != w2->window->display->display) {
        wdp wd1 = ws1->display;
        unsigned long c = 0;
        int i, j;
        Display *d1 = wd1->display;
        XColor clr;
        XImage *xim;

        /*
         * Copying is between windows on two different displays.
         */
        if (x<0 || y<0 || x+width > ws1->pixwidth || y+height > ws1->pixheight)
            return Failed;		/*#%#%# BOGUS, NEEDS FIXING */
        xim = XGetImage(d1, ws1->pix, x, y, width, height,
                        (1<<DefaultDepth(d1,wd1->screen))-1,XYPixmap);
        XSetFunction(stddpy, stdgc, GXcopy);
        for (i=0; i < width; i++) {
            for (j=0; j < height; j++) {
                clr.pixel = XGetPixel(xim, i, j);
                if (cp2 != NULL && c == clr.pixel) {
                    XSetForeground(stddpy, stdgc, cp2->c);
                    RENDER2(XDrawPoint, i + x2, j + y2);
                    continue;
                }
                c = clr.pixel;
                cp2 = NULL;
                for ( cp = wd1->colors; cp < wd->colors + wd->numColors; cp++) {
                    if (cp->c == c) {
                        if (cp->name[0]=='\0') {
                            XQueryColor(d1, wd1->cmap, &clr);
                            cp->r = clr.red;
                            cp->g = clr.green;
                            cp->b = clr.blue;
                            sprintf(cp->name,"%d,%d,%d",cp->r,cp->g,cp->b);
                        }
                        cp2 = alc_rgb(w2, cp->name, cp->r, cp->g, cp->b, 0);
                        if (cp2 == NULL) return Failed;
                        break;
                    }
                }
                if (cp2 == NULL) {
                    XQueryColor(d1, wd1->cmap, &clr);
                    cp2 = alc_rgb(w2, "unknown", clr.red, clr.green, clr.blue, 0);
                }
                if (cp2 == NULL) return Failed;
                XSetForeground(stddpy, stdgc, cp2->c);
                RENDER2(XDrawPoint, i + x2, j + y2);
	    }
        }
        XSetForeground(stddpy, stdgc,
                       wd->colors[wc->fg].c ^ (ISXORREVERSE(w2) ? wd->colors[wc->bg].c : 0));
        XSetFunction(stddpy, stdgc, wc->drawop);
        XSync(stddpy,False);
        XDestroyImage(xim);
    }
    else {
        /*
         * Copying is between windows on one display, perhaps the same window.
         */
        src = ws1->pix;
        if (src != stdpix) {
            /* copying between different windows; handle color bookkeeping */
            if (!x2 && !y2 &&
                ((width  >= ws2->pixwidth)  || !width) &&
                ((height >= ws2->pixheight) || !height) && w2->context->clipw < 0){
                free_xcolors(w2, 0);
            }
            copy_colors(w, w2);
        }
        XSetForeground(stddpy, stdgc, wd->colors[wc->bg].c);
        XSetFunction(stddpy, stdgc, GXcopy);

        if (x+width<0 || y+height<0 || x>=ws1->pixwidth || y>=ws1->pixheight) {
            /* source is entirely offscreen */
            RENDER4(XFillRectangle, x2, y2, width, height);
        }
        else {
            /*
             * Check for source partially offscreen, but copy first and
             * fill later in case the source and destination overlap.
             */
            lpad = rpad = tpad = bpad = 0;
            if (x < 0) {			/* source extends past left edge */
                lpad = -x;
                width -= lpad;
                x2 += lpad;
                x = 0;
            }
            if (x + width > ws1->pixwidth) {  /* source extends past right edge */
                rpad = x + width - ws1->pixwidth;
                width -= rpad;
            }
            if (y < 0) {			/* source extends above top edge */
                tpad = -y;
                height -= tpad;
                y2 += tpad;
                y = 0;
            }
            if (y + height > ws1->pixheight) {  /* source extends below bottom */
                bpad = y + height - ws1->pixheight;
                height -= bpad;
            }
            /*
             * Copy the area.
             */
            if (stdwin)
                XCopyArea(stddpy, src, stdwin, stdgc, x, y, width, height, x2, y2);
            XCopyArea(stddpy, src, stdpix, stdgc, x, y, width, height, x2, y2);
            /*
             * Fill any edges not provided by source.
             */
            if (lpad > 0)
                RENDER4(XFillRectangle, x2-lpad, y2-tpad, lpad, tpad+height+bpad);
            if (rpad > 0)
                RENDER4(XFillRectangle, x2+width, y2-tpad, rpad, tpad+height+bpad);
            if (tpad > 0)
                RENDER4(XFillRectangle, x2, y2-tpad, width, tpad);
            if (bpad > 0)
                RENDER4(XFillRectangle, x2, y2+height, width, bpad);
        }

        XSetForeground(stddpy,stdgc,
                       wd->colors[wc->fg].c^(ISXORREVERSE(w2) ? wd->colors[wc->bg].c :0));
        XSetFunction(stddpy, stdgc, wc->drawop);
    }
    return Succeeded;
}


wbp sprite;
int tics;
int lastx,lasty;
int animwidth, animheight;

void animHelper(wbp w, XPoint p[], int n)
{
    int i=0;
    STDLOCALS(w);

    for ( ; i < n; i++) {
        int j;

        /*
         * redraw that portion of the previous image that isn't overlapped
         * by the new image being drawn
         */
        if (lastx >= 0) {
            int dx = p[i].x - lastx, dy = p[i].y - lasty;
            if (dx > 0) XCopyArea(stddpy,stdpix,stdwin,stdgc, lastx, lasty,
                                  dx, animheight, lastx, lasty);
            else if (dx < 0)
                XCopyArea(stddpy,stdpix,stdwin,stdgc, lastx+animwidth+dx, lasty,
                          -dx, animheight, lastx+animwidth+dx, lasty);

            if (dy > 0) XCopyArea(stddpy, stdpix, stdwin, stdgc, lastx, lasty,
                                  animwidth, dy, lastx, lasty);
            else if (dy < 0)
                XCopyArea(stddpy,stdpix,stdwin,stdgc, lastx, lasty+animheight+dy,
                          animwidth, -dy, lastx, lasty+animheight+dy);
        }

        XCopyArea(stddpy, sprite->window->pix, stdwin, stdgc,
                  0, 0, animwidth, animheight, p[i].x, p[i].y);
        XFlush(stddpy);
        for (j = 0; j < tics; j++);
/*     
 * erase the whole box approach:
 *      XCopyArea(stddpy, stdpix, stdwin, stdgc,
 *                0, 0, animwidth, animheight, p[i].x, p[i].y);
 */
        lastx = p[i].x;
        lasty = p[i].y;
    }
}


int getdefault(wbp w, char *prog, char *opt, char *answer)
{
    char *p;
    STDLOCALS(w);

   
    if ((p = XGetDefault(stddpy,prog,opt)) == NULL)
        return Failed;
    strcpy(answer, p);
    return Succeeded;
}


/*
 * Allocate a mutable color
 */
int mutablecolor(wbp w, dptr argv, int ac, int *retval)
{
    XColor colorcell;
    LinearColor clr;
    unsigned long plane_masks[1], pixels[1];
    char *colorname;
    tended char  *str;
    int i;
    long alpha;
    {
        STDLOCALS(w);

        /*
         * X11 Bug Warning:  some old versions of the X server, but not X11R5,
         * will crash sometime after a failed call to XNewColor.  This happens
         * only if a virtual colormap has been allocated and completely filled
         * and then XNewColor is called to allocate a new, unshared entry.  The
         * request fails, as it should, but when the program eventually exits
         * the X server crashes.  This has been seen on OpenWindows 3.0,
         * Irix 4.0.1, and HP-UX 7.0.
         */

        if (!XAllocColorCells(stddpy,wd->cmap,False,plane_masks,0,pixels,1)) {
            /*
             * try again with a virtual colormap
             */
            if (!go_virtual(w) ||
                !XAllocColorCells(stddpy,wd->cmap,False,plane_masks,0,pixels,1))
                return Failed;                         /* cannot allocate an entry */
        }

        /*
         * allocate a slot in wdisplay->colors and wstate->theColors arrays
         */
        i = alc_centry(wd);
        if (i == 0)
            return Failed;
        wd->colors[i].type = MUTABLE;
        wd->colors[i].c = pixels[0];


        /* save color index as "name", followed by a null string for value */
        colorname = wd->colors[i].name;
        sprintf(colorname, "%ld", -pixels[0] - 1);	/* index is name */
        colorname = colorname + strlen(colorname) + 1;
        *colorname = '\0';				/* value unknown */

        if (ws->numColors < WMAXCOLORS) {
            if (ws->theColors == NULL) {
                MemProtect(ws->theColors = calloc(WMAXCOLORS, sizeof(short)));
            }
            ws->theColors[ws->numColors++] = i;
        }

        if (ac > 0) {                     /* set the color */
            if (ac != 1) return Error;
            /*
             * old-style check for C integer
             */
            else if (argv[0].dword == D_Integer) {/* check for color cell */
                if (IntVal(argv[0]) >= 0)
                    return Failed;        /* must be negative */
                colorcell.pixel = -IntVal(argv[0]) - 1;
                XQueryColor(stddpy, wd->cmap, &colorcell);
                clr = lcolor(w, colorcell);
                sprintf(colorname, "%ld,%ld,%ld", clr.red, clr.green, clr.blue);
            }
            else {
                if (!cnv:C_string(argv[0],str)) {
                    ReturnErrVal(103,argv[0], Error);
                }
                if (parsecolor(w, str, &clr.red, &clr.green, &clr.blue, &alpha) != Succeeded) {
                    free_xcolor(w, pixels[0]);
                    return Failed;                   /* invalid color specification */
                }
                strcpy(colorname, str);
                colorcell = xcolor(w, clr);
            }
            colorcell.pixel = pixels[0];
            XStoreColor(stddpy, wd->cmap, &colorcell);
        }

        *retval = (-pixels[0] - 1);
        return Succeeded;
    }
}

char *getmutablename(wbp w, int mute_index)
{
    wdp dp;
    Display *d;
    int i;
    char *colorname;

    dp = w->window->display;
    d = dp->display;

    for (i = 2; i < DMAXCOLORS; i++)
        if (dp->colors[i].type == MUTABLE && dp->colors[i].c == - mute_index - 1)
	    break;
    if (i == DMAXCOLORS)
        return NULL;
    colorname = dp->colors[i].name;			/* color name field */
    colorname = colorname + strlen(colorname) + 1;	/* set value follows */
    return colorname;
}

int setmutable(wbp w, int i, char *s)
{
    LinearColor clr;
    long alpha;
    XColor colorcell;
    wdp dp = w->window->display;

    if (parsecolor(w, s, &clr.red, &clr.green, &clr.blue, &alpha) != Succeeded)
        return Failed;                        /* invalid color specification */
    colorcell = xcolor(w, clr);
    colorcell.pixel = -i - 1;
    XStoreColor(dp->display, dp->cmap, &colorcell);
    return Succeeded;
}

void free_mutable(wbp w, int mute_index)
{
    wdp dp;
    Display *d;
    int i;

    dp = w->window->display;
    d = dp->display;

    for (i = 2; i < DMAXCOLORS; i++)
        if (dp->colors[i].type == MUTABLE && dp->colors[i].c == - mute_index - 1)
            break;
    if (i != DMAXCOLORS)
        free_xcolor(w, dp->colors[i].c); 
}


void free_color(wbp w, char *s)
{
    wdp dp;
    Display *d;
    long i, alpha;
    LinearColor clr;
    XColor color;

    if (parsecolor(w, s, &clr.red, &clr.green, &clr.blue, &alpha) != Succeeded)
        return;
    dp = w->window->display;
    d = dp->display;
    color = xcolor(w, clr);

    for (i = 2; i < DMAXCOLORS; i++)
        if (dp->colors[i].r == color.red && dp->colors[i].g == color.green
            && dp->colors[i].b == color.blue && dp->colors[i].type != MUTABLE)
            break;
    if (i != DMAXCOLORS)
        free_xcolor(w, dp->colors[i].c);
}

/*
 * Draw a bilevel image
 */
void drawblimage(wbp w, int x, int y, int width, int height, int ch, unsigned char *s, word len)
{
    unsigned int m, msk1, c, ix, iy;
    long fg, bg;
    XImage *im;
    STDLOCALS(w);

    /*
     * Get an XImage structure and free the old color set if possible.
     */
    MemProtect(im = getximage(w, x, y, width, height, ch == TCH1));

    /*
     * Read the image string and set the pixel values.  Note that
     * the hex digits in sequence fill the rows *right to left*.
     */
    m = width % 4;
    if (m == 0)
        msk1 = 8;
    else
        msk1 = 1 << (m - 1);		/* mask for first byte of row */

    fg = wd->colors[wc->fg].c;
    bg = wd->colors[wc->bg].c;
    ix = width;
    iy = 0;
    m = msk1;
    while (len--) {
        if (isxdigit((unsigned char)(c = *s++))) {		/* if hexadecimal character */
            if (!isdigit((unsigned char)c))		/* fix bottom 4 bits if necessary */
                c += 9;
            while (m > 0) {		/* set (usually) 4 pixel values */
                --ix;
                if (c & m)
                    XPutPixel(im, ix, iy, fg);
                else if (ch != TCH1)	/* if zeroes aren't transparent */
                    XPutPixel(im, ix, iy, bg);
                m >>= 1;
            }
            if (ix == 0) {			/* if end of row */
                ix = width;
                iy++;
                m = msk1;
            }
            else
                m = 8;
        }
    }
    if (ix > 0)				/* pad final row if incomplete */
        while (ix < width)
            XPutPixel(im, ix++, iy, bg);

    /*
     * Put it on the screen.
     */
    if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, GXcopy);
    RENDER7(XPutImage, im, 0, 0, x, y, width, height);
    XDestroyImage(im);
    if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, wc->drawop);
}

/*
 * Draw a character-per-pixel image
 */
void drawstrimage(wbp w, int x, int y, int width, int height, 
             struct palentry *e, unsigned char *s, int len)
{
    int c, v, ret = 0, trans = 0;
    unsigned int r, g, b, ix, iy;
    XImage *im;
    wclrp cp;
    int ciarray[256];
    char tmp[32];
    STDLOCALS(w);

    if (e) {
        /*
         * Get an XImage structure and free the old color set if possible.
         */
        for (c = 0; c < 256; c++)
            trans |= e[c].used && e[c].transpt;
    }
    MemProtect(im = getximage(w, x, y, width, height, trans));

    if (e) {
        /*
         * Allocate the colors we need.  Use black or white if unsuccessful.
         */
        ret = 0;
        for (c = 0; c < 256; c++)
            if (e[c].used && e[c].valid) {
                r = e[c].clr.red;
                g = e[c].clr.green;
                b = e[c].clr.blue;
                sprintf(tmp, "%d,%d,%d", r, g, b);
                cp = alc_rgb(w, tmp, r, g, b, 0);
                if (cp == NULL) {
                    ret++;
                    if ((0.299 * r + 0.587 * g + 0.114 * b) > 32767)
                        cp = alc_rgb(w, "white", 65535, 65535, 65535, 0);
                    else
                        cp = alc_rgb(w, "black", 0, 0, 0, 0);
                }
                ciarray[c] = cp-wd->colors;
            }

        /*
         * Read the image string and set the pixel values.
         */
        ix = iy = 0;
        while (len--) {
            c = *s++;
            v = e[c].valid;
            if (v)				/* put char if valid */
                XPutPixel(im, ix, iy, wd->colors[ciarray[c]].c);
            if (v || e[c].transpt) { 		/* advance if valid or transparent */
                if (++ix >= width) {
                    ix = 0;			/* reset for new row */
                    iy++;
                }
            }
        }
        if (ix > 0) {			/* pad final row if incomplete */
            while (ix < width)
                XPutPixel(im, ix++, iy, wd->colors[wc->bg].c);
        }
    }
    else {
        iy = 0;
        while (iy < height) {
            ix = 0;
            while (ix < width) {
                int b = *s++ * 257;
                int g = *s++ * 257;
                int r = *s++ * 257;
                wclrp cp = alc_rgb(w,"anon", r, g, b, 0);
                XPutPixel(im, ix++, iy, cp->c);
	    }
            iy++;
        }
    }
    /*
     * Put it on the screen.
     */
    if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, GXcopy);
    XPutImage(stddpy, ws->pix, stdgc, im, 0, 0, x, y, width, height);
    if (ws->win)
        XCopyArea(stddpy, ws->pix, ws->win, stdgc, x, y, width, height, x, y);
    XDestroyImage(im);
    if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, wc->drawop);
}

/*
 * getimstr(w, x, y, width, height, paltbl, data) -- get image as a string.
 *
 * Stores the specified subimage in data, one pixel per byte, and sets
 * entries in paltbl corresponding to the pixel values that were used.
 */

/*
 * Compare two unsigned long values for qsort or bsearch.
 */
static int ulcmp(unsigned long *p1, unsigned long *p2)
{
    unsigned long u1 = *p1;
    unsigned long u2 = *p2;

    if (u1 < u2)
        return -1;
    else
        return (u1 > u2);
}


/*
 * The getimstr() code assumes that a maximum of 256 colors can be onscreen
 * at one time.  If DMAXCOLORS maximum is raised, code must be added for the
 * depth>8 case to reduce the local copy of the image to no more than the
 * 256-color maximum allowed in a GIF file.  This reduction operation is
 * nontrivial; look up "color quantization" in computer graphics literature.
 */
#passthru #if (DMAXCOLORS > 256)
#passthru   Deliberate Syntax error
#passthru #endif				/* DMAXCOLORS */

int getimstr(wbp w, int x, int y, int width, int height,
             struct palentry paltbl[DMAXCOLORS], unsigned char *data)
{
    XImage *im;
    XColor colorcell;
    wclrp cp;
    unsigned long px, clist[DMAXCOLORS], *lp;
    int i, ncolors;
    STDLOCALS(w);

    /*
     * Get an XImage structure containing window pixel values.
     */
    im = getximage(w, x, y, width, height, 1);
    if (!im)
        return 0;
   
    if (im->depth <= 8) {

        /*
         * We can use the pixel values directly as color indices.
         * Put them in the data string, noting which colors are used.
         */
        for (i = 0; i < DMAXCOLORS; i++)
            clist[i] = i;
        for (y = 0; y < height; y++)
            for (x = 0; x < width; x++) {
                *data++ = px = XGetPixel(im, x, y) & 0xFF;
                paltbl[px].used = 1;
            }
    }

    else {

        /*
         * Make a sorted list of the pixel values of the colors that are in
         * use.  Search this list for every pixel and store the resulting
         * list index as the color index.
         */
        lp = clist;
        for (cp = wd->colors; cp < wd->colors + wd->numColors; cp++)
            *lp++ = cp->c;
        ncolors = lp - clist;
        qsort((char *)clist, ncolors, sizeof(*clist), (QSortFncCast)ulcmp);

        for (y = 0; y < height; y++)
            for (x = 0; x < width; x++) {
                px = XGetPixel(im, x, y);
                lp = (unsigned long *)bsearch((char *)&px, (char *)clist,
                                              ncolors, sizeof(*clist), (BSearchFncCast)ulcmp);
                if (lp)
                    i = lp - clist;
                else
                    i = 0;			/* use black if not found */
                *data++ = i;
                paltbl[i].used = 1;
            }
    }

    /*
     * Query the real color values from X; Icon's data structures
     * may show several entries for any particular pixel value.
     */
    for (i = 0; i < DMAXCOLORS; i++)
        if (paltbl[i].used) {
            colorcell.pixel = clist[i];
            colorcell.flags = DoRed | DoGreen | DoBlue;
            XQueryColor(stddpy, wd->cmap, &colorcell);
            paltbl[i].clr = lcolor(w, colorcell);
            paltbl[i].valid = 1;
        }

    XDestroyImage(im);
    return 1;
}

/*
 * Create an XImage structure corresponding to subimage (x, y, w, h).
 * If init is nonzero, initialize it with current contents.
 * If init is zero and (x,y,w,h) fills the window, free existing color set.
 */
static XImage *getximage(wbp w, int x, int y, int width, int height, int init)
{
    int tx, ty;
    XImage *im;
    STDLOCALS(w);

    im = XCreateImage(stddpy, DefaultVisual(stddpy, wd->screen),
                      DefaultDepth(stddpy, wd->screen), ZPixmap, 0, NULL, width, height, 32, 0);
    if (im == NULL)
        return NULL;
    im->data = malloc((im->bytes_per_line * height));
    if (im->data == NULL) {
        XDestroyImage(im);
        return NULL;
    }

    if (!init) {
        if (x <= 0 && y <= 0 && x + width >= ws->pixwidth &&
            y + height >= ws->pixheight && wc->clipw < 0) {
            free_xcolors(w, 0);
        }
        return im;
    }

    tx = ty = 0;
    if (x < 0)  { tx -= x; width += x; x = 0; }
    if (y < 0)  { ty -= y; height += y; y = 0; }
    if (x + width > ws->width)  { width = ws->width - x; }
    if (y + height > ws->height) { height = ws->height - y; }
    if (width > 0 && height > 0)
        XGetSubImage(stddpy, stdpix, x, y, width, height, AllPlanes, ZPixmap,
                     im, tx, ty);
    return im;
}

int readimage(wbp w, int x, int y, char *filename)
{
    Pixmap p;
    unsigned int width, height;
    int status;
    STDLOCALS(w);
    if (!x && !y)
        p = loadimage(w, filename, &height, &width, 1, &status);
    else
        p = loadimage(w, filename, &height, &width, 0, &status);
    if (p == (Pixmap) NULL) return Failed;

    if (wc->drawop != GXcopy)
        XSetFunction(stddpy, stdgc, GXcopy);
    if (stdwin)
        XCopyArea(stddpy, p, stdwin, stdgc, 0, 0, width, height, x, y);
    XCopyArea(stddpy, p, stdpix, stdgc, 0, 0, width, height, x, y);
    if (wc->drawop != GXcopy)
        XSetFunction(stddpy,stdgc,wc->drawop);

    /*
     * Make sure previous ops on p are complete, then free it.
     */
    XSync(stddpy, False);
    XFreePixmap(stddpy, p);
    return Succeeded;
}


/*
 * Initialize client for producing pixels from a window
 */
int getpixelinit(wbp w, struct imgmem *imem)
{
    STDLOCALS(w);

    if (imem->width <= 0 || imem->height <= 0) {
        imem->im = NULL;
        return Succeeded;
    }
    imem->im = XGetImage(stddpy, stdpix,
                         imem->x, imem->y, imem->width, imem->height,
                         (1 << DefaultDepth(stddpy, wd->screen))-1, XYPixmap);
   
    if (imem->im == NULL) return Failed;
    return Succeeded;
}

static wclrp lastcp;

int getpixelterm(wbp w, struct imgmem *imem)
{
    if (imem->im != NULL)
        XDestroyImage(imem->im);
    lastcp = NULL;
    return Succeeded;
}

/*
 * Return pixel (x,y) from a window in long value (rv)
 */
int getpixel(wbp w, int x, int y, word *rv, char *s, struct imgmem *imem)
{
    XColor colorcell;
    LinearColor clr;
    wclrp cp;
    unsigned long c;
    wcp wc = w->context;
    wdp wd = w->window->display;
    Display *stddpy = wd->display; 

    if (x < imem->x || x >= imem->x + imem->width ||
        y < imem->y || y >= imem->y + imem->height)
        c = colorcell.pixel = wd->colors[wc->bg].c;
    else
        c = colorcell.pixel = XGetPixel(imem->im, x - imem->x, y - imem->y);
    *rv = 0xff000000;

    if (lastcp && (lastcp->c == c)) { cp = lastcp; goto foundc; }
    else
        for (cp = wd->colors ; cp < wd->colors + wd->numColors; cp++) {
            if (cp->c == c) {
                lastcp = cp;
              foundc:
                if (cp->type == MUTABLE)
                    *rv = -c - 1;
                else {
                    *rv = 1;
                    colorcell.red = cp->r;
                    colorcell.green = cp->g;
                    colorcell.blue = cp->b;
                    clr = lcolor(w, colorcell);
                    sprintf(s, "%ld,%ld,%ld", clr.red, clr.green, clr.blue);
                }
                break;
            }
        }
    if (*rv == 0xff000000) {
        XQueryColor(stddpy, wd->cmap, &colorcell);
        *rv = 1;
        clr = lcolor(w, colorcell);
        sprintf(s, "%ld,%ld,%ld", clr.red, clr.green, clr.blue);
    }
    return Succeeded;
}


int querypointer(wbp w, int *x, int *y)
{
    Display *theDisplay;
    Window theWindow;
    Window garbage1, garbage2;
    int root_x, root_y;
    unsigned int key_buttons;

    theDisplay = w->window->display->display;
    theWindow  = w->window->win;
    if (!theWindow)
        return Failed;

    XQueryPointer(theDisplay, theWindow, &garbage1, &garbage2,
                  &root_x, &root_y, x, y, &key_buttons);
    return Succeeded;
}

int queryrootpointer(wbp w, int *x, int *y)
{
    Display *theDisplay;
    Window theWindow;
    Window garbage1, garbage2;
    int win_x, win_y;
    unsigned int key_buttons;

    theDisplay = w->window->display->display;
    theWindow  = DefaultRootWindow(theDisplay);
    if (!theWindow)
        return Failed;
    XQueryPointer(theDisplay, theWindow, &garbage1, &garbage2,
                  x, y, &win_x, &win_y, &key_buttons);
    return Succeeded;
}


int patbits[] = {
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFE,0xFF,0xEF,0xFF,0xFE,0xFF,0xEF,0xFF,
    0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,
    0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,
    0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,
    0x01,0x00,0x10,0x00,0x01,0x00,0x10,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
    0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,
    0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,
    0x10,0x10,0x10,0xFF,0x10,0x10,0x10,0x10,
    0x82,0x44,0x28,0x10,0x28,0x44,0x82,0x01,

    0x0F,0x0F,0x0F,0x0F,0xF0,0xF0,0xF0,0xF0,
    0x1B,0x18,0x81,0xB1,0x36,0x06,0x60,0x63,
    0x02,0x02,0x05,0xF8,0x20,0x20,0x50,0x8F,
    0x03,0x84,0x48,0x30,0x03,0x84,0x48,0x30,
};

/*
 * pattern symbols
 */
static stringint siPatternSyms[] = {
    {0,		16},
    { "black",	 0},
    { "checkers",	 12},
    { "darkgray",	 2},
    { "diagonal",	 8},
    { "grains",	 13},
    { "gray",	 3},
    { "grid",	 10},
    { "horizontal",9},
    { "lightgray", 4},
    { "scales",	 14},
    { "trellis",	 11},
    { "vertical",	 7},
    { "verydark",	 1},
    { "verylight", 5},
    { "waves",	 15},
    { "white",	 6},
};

/*
 * setpattern
 */
int setpattern(wbp w, char *name)
{
    int width, nbits;
    int i;
    int symbol;
    word v, bits[MAXXOBJS];
    Pixmap p;
    char data[MAXXOBJS];
    char *t, *buf = data;
    STDLOCALS(w);

    t = salloc(name);
    if (wc->patternname != NULL)
        free(wc->patternname);
    wc->patternname = t;
   
    /*
     * If the pattern starts with a number it is a width , bits encoding
     */
    if (isdigit((unsigned char)name[0])) {
        nbits = MAXXOBJS;
        switch (parsepattern(name, &width, &nbits, bits)) {
            case Failed:
                return Failed;
            case Error:
                ReturnErrNum(145, Error);
        }
        if (!stdgc) return Succeeded;
        return setpatternbits(w, width, bits, nbits);
    }

    /*
     * Otherwise, it is a named pattern.  Find the symbol id.
     */
    if ((symbol = stringint_str2int(siPatternSyms, wc->patternname)) >= 0) {
        if (!stdgc) return Succeeded;
        for(i = 0; i < 8; i++) {
            v = patbits[symbol * 8 + i];
            *buf++ = v;
        }
        p = XCreateBitmapFromData(stddpy, stdpix, data, 8, 8);
        XSetStipple(stddpy, stdgc, p);
        XSync(stddpy, False);
        XFreePixmap(stddpy, p);
        return Succeeded;
    }
    return Failed;
}

int setpatternbits(wbp w, int width, word *bits, int nbits)
{
    word v;
    int i, j;
    Pixmap p;
    char data[MAXXOBJS];
    char *buf = data;
    STDLOCALS(w);

    for(i = 0; i < nbits; i++) {
        v = bits[i];
        for(j=0; j<width; j+=8) {
            *buf++ = v;
            v >>= 8;
        }
    }

    p = XCreateBitmapFromData(stddpy, stdpix, data, width, nbits);
    XSetStipple(stddpy, stdgc, p);
    XSync(stddpy, False);
    XFreePixmap(stddpy, p);
    return Succeeded;
}



/*
 * remap a window ... this time with an iconwin
 */
static int remap(wbp w, int x, int y)
{
    XSizeHints size_hints;
    XWMHints   *wmhints;
    STDLOCALS(w);

    XGetSizeHints(stddpy, stdwin, &size_hints, XA_WM_NORMAL_HINTS);
    wmhints = XGetWMHints(stddpy, stdwin);
    if (ws->iconwin)
        XDestroyWindow(stddpy, ws->iconwin);
#ifdef HAVE_LIBXFT
    if (ws->winDraw) {
        XftDrawDestroy(ws->winDraw);
        ws->winDraw = NULL;
    }
#endif
    if (stdwin)
        XDestroyWindow(stddpy, stdwin);
    ws->win = XCreateSimpleWindow(stddpy, DefaultRootWindow(stddpy),
                                  ws->posx, ws->posy, ws->width,
                                  ws->height, 4,
                                  wd->colors[wc->fg].c, wd->colors[wc->bg].c);
    XSetStandardProperties(stddpy, ws->win, ws->windowlabel,
                           ws->iconlabel, 0, 0, 0, &size_hints);
    XSelectInput(stddpy, ws->win, XMasks(ws->inputmask));

    ws->iconwin = XCreateSimpleWindow(stddpy, DefaultRootWindow(stddpy),
                                      ws->iconx, ws->icony, ws->iconw,
                                      ws->iconh, 2,
                                      wd->colors[wc->fg].c,
                                      wd->colors[wc->bg].c);
    XSelectInput(stddpy, ws->iconwin,
                 ExposureMask | KeyPressMask | ButtonPressMask);

    wmhints->flags |= IconPositionHint;
    wmhints->icon_x = x;
    wmhints->icon_y = y;
    wmhints->initial_state = ws->iconic;
    wmhints->icon_window = ws->iconwin;
    wmhints->flags |= IconWindowHint;
    XSetWMHints(stddpy, ws->win, wmhints);
    CLREXPOSED(w);
    XMapWindow(stddpy, ws->win);
    if (ws->iconic == NormalState) {
        while (!ISEXPOSED(w))
            pollevent();
    }
    ws->iconx = x;
    ws->icony = y;
    XSync(stddpy, False);
    XFree((char *)wmhints);
    return 1;
}


int seticonimage(wbp w, dptr dp)
{
    int status;
    Pixmap pix;
    tended char *tmp;
    {
        STDLOCALS(w);
        /* get the pixmap file named by x */
        if (is:string(*dp)) {
            unsigned int height, width;
            if (!cnv:C_string(*dp,tmp))
                ReturnErrVal(103, *dp, Error);

            if ((ws->iconimage != NULL) && strcmp(ws->iconimage, ""))
                free(ws->iconimage);
            ws->iconimage = salloc(tmp);

            if (ws->iconwin == (Window) NULL) makeIcon(w,0,0);
            else {
                pix = loadimage(w, ws->iconimage, &height, &width, 0, &status);
                if (pix == (Pixmap) NULL)
                    return Failed;
                XCopyArea(stddpy, pix, ws->iconwin, wd->icongc,
                          0, 0, width, height, 0, 0);
                if (ws->iconpix) {
                    XSync(stddpy, False);
                    XFreePixmap(stddpy, ws->iconpix);
                }
                ws->iconpix = pix;
                ws->iconw = width;
                ws->iconh = height;
                if (remap(w,ws->iconx,ws->icony) == -1)
                    ReturnErrNum(144, Error);
            }
        }
        else
            return Failed;
        return Succeeded;
    }
}


/*
 * dumpimage -- write an image to a disk file in an X format.
 *
 * Accepts only .xpm and .xbm file names, returning NoCvt for anything else.
 */

int dumpimage(wbp w, char *filename, unsigned int x, unsigned int y, 
              unsigned int width, unsigned int height)
{
    int status, slen;
    STDLOCALS(w);

    /*
     * Check for bilevel XBM (X BitMap) format.
     */
    slen = strlen(filename);
    if ((slen > 4) &&
        (!strcmp(".xbm", filename + slen - 4) ||
         !strcmp(".XBM", filename + slen - 4))) {
        /*
         * Write a bitmap from a "color" window (presumed to have only BW in it).
         * BlackPixel ^ WhitePixel will have a 1 in the first bit in which
         * they are different, so this bit is the plane we want to copy.
         */

        if (DefaultDepth(stddpy,wd->screen) != 1) {
            unsigned long bw =
                BlackPixel(stddpy,wd->screen) ^ WhitePixel(stddpy,wd->screen);
            Pixmap p1 = XCreatePixmap(stddpy, DefaultRootWindow(stddpy),
                                      width, height, 1);
            XGCValues xgc;
            GC thinGC;
            int i;
            /*
             * pick out the bitplane on which Black and White differ
             */
            for(i=0;!((1<<i) & bw);i++);
            bw &= (1<<i);
            /*
             * Construct a 1-bit-deep GC for use in copying the plane.
             */
            xgc.foreground = BlackPixel(stddpy,wd->screen);
            xgc.background = WhitePixel(stddpy,wd->screen);
            thinGC = XCreateGC(stddpy,p1,GCForeground|GCBackground,&xgc);

            if (i>DefaultDepth(stddpy,wd->screen)) return Failed;
            XCopyPlane(stddpy,stdpix,p1,thinGC,x,y,width,height,0,0,bw);
            status= XWriteBitmapFile(stddpy, filename, p1, width, height, -1, -1);

            XSync(stddpy, False);
            XFreePixmap(stddpy, p1);
            XFreeGC(stddpy,thinGC);
            if (status != BitmapSuccess) return Failed;
        }
        else {
            if(x || y) {
                Pixmap p1 = XCreatePixmap(stddpy, DefaultRootWindow(stddpy), width,
                                          height, DefaultDepth(stddpy,wd->screen));

                XCopyArea(stddpy, stdpix, p1, stdgc, x, y, width, height, 0, 0);
                XSync(stddpy, False);

                status = XWriteBitmapFile(stddpy, filename, p1, width, height, -1, -1);

                XSync(stddpy, False);
                XFreePixmap(stddpy, p1);

                if (status != BitmapSuccess) return Failed;

            }
            else if (XWriteBitmapFile(stddpy, filename, stdpix,
                                      width, height, -1, -1) != BitmapSuccess)
                return Failed;

        }
        return Succeeded;
    }
    /*
     * Check for XPM (color X PixMap) format.
     */
    else if (((slen > 4) &&
              (!strcmp(".xpm", filename + slen - 4) ||
               !strcmp(".XPM", filename + slen - 4))) ||
             ((slen > 6) && !strcmp(".xpm.Z", filename + slen - 6))) {
#ifdef HAVE_LIBXPM
        /*
         * Could optimize by calling XpmWriteFileFromPixmap directly on the
         * stdpix...
         */
        Pixmap p1 = XCreatePixmap(stddpy, DefaultRootWindow(stddpy), width,
                                  height, DefaultDepth(stddpy,wd->screen));

        XCopyArea(stddpy, stdpix, p1, stdgc, x, y, width, height, 0, 0);
        XSync(stddpy, False);

        status = XpmWriteFileFromPixmap(stddpy, filename, p1,
                                        (Pixmap) NULL, NULL);
        XSync(stddpy, False);
        XFreePixmap(stddpy, p1);

        if (status == XpmSuccess)
            return Succeeded;
#endif					/* HAVE_LIBXPM */
        return Failed;
    }
    else
        return NoCvt;		/* not an X format -- write GIF instead */
}

/*
 * Load an image, in any format we can figure out.
 */
static Pixmap loadimage(wbp w, char *filename, unsigned int *height, 
                        unsigned int *width, int atorigin, int *status)
{
    Pixmap p1, p2 = (Pixmap) NULL;
    int xhot, yhot;
    XGCValues gcv;
    unsigned long gcmask = GCFont | GCForeground | GCBackground;
    int isxbm;
    STDLOCALS(w);

    if (!strcmp(".xbm", filename + strlen(filename) - 4))
        isxbm = 1;
    else if (!strcmp(".xpm", filename + strlen(filename) - 4) ||
             !strcmp(".xpm.Z", filename + strlen(filename) - 6))
        isxbm = 0;
    else {
        /*
         * Not sure what kind of file this is, make a guess
         * For example, the format might be on the first line of the file,
         * so open it up and read some.
         */
        FILE *ftemp = fopen(filename,"r");
        char s[6];
        int  i;

        if (!ftemp) {
            return (Pixmap) NULL;
        }
        if ((long)fread(s,1,6,ftemp) < (long)6) {
            fclose(ftemp);
            return (Pixmap) NULL;
        }
        fclose(ftemp);
        /* check s for XPM string */
        isxbm = 1;         /* default to xbm */
        for (i = 0; i <= 3; i++)
            if (!strncmp(&s[i], "XPM", 3))
                isxbm = 0;
    }

    if (isxbm) {    /* isxbm = 1 => .xbm file */
        if (XReadBitmapFile(stddpy, DefaultRootWindow(stddpy), filename,
                            width, height, &p1, &xhot, &yhot) != BitmapSuccess)
            return (Pixmap) NULL;
        else *status = 0;
        p2 = XCreatePixmap(stddpy, DefaultRootWindow(stddpy), *width, *height,
                           DefaultDepth(stddpy,DefaultScreen(stddpy)));
    }
    else {				/* isxbm == 0 => .xpm file */
#ifdef HAVE_LIBXPM
        int i, j;
        XpmAttributes a;
        XColor color;
        LinearColor clr;
        Pixmap dummy;
        a.npixels = 0;
        a.colormap = wd->cmap;
        a.valuemask = XpmReturnPixels | XpmColormap;
      
        *status = XpmReadFileToPixmap(stddpy, DefaultRootWindow(stddpy),
                                      filename, &p2, &dummy, &a);

        if (*status == XpmColorFailed && go_virtual(w)) {
            /* try again with a virtual colormap */
            a.npixels = 0;
            a.colormap = wd->cmap;
            a.valuemask = XpmReturnPixels | XpmColormap;
            *status = XpmReadFileToPixmap(stddpy, DefaultRootWindow(stddpy),
                                          filename, &p2, &dummy, &a);
        }

        if (*status != XpmSuccess) {
            if (*status == XpmColorFailed)
                *status = 1;
            else
                return (Pixmap) NULL;
        }
        else *status = 0;
        *height = a.height;
        *width = a.width;

        /*
         * if the loaded image is to cover an entire window, free up colors
         * currently in use by the window
         */
        if (atorigin && *width >= ws->pixwidth && *height >= ws->pixheight
            && wc->clipw < 0) {
            free_xcolors(w, 0);
        }

        /*
         * OK, now register all the allocated colors with the display
         * and window in which we are residing.
         */
        for (i = 0; i < a.npixels; i++) {
            for (j = 2; j < DMAXCOLORS; j++)
                if (wd->colors[j].refcount == 0) break;
            if (j == DMAXCOLORS) {
                return (Pixmap) NULL;
	    }
            if (j == wd->numColors) wd->numColors++;
            else if (j > wd->numColors) {
                wd->numColors = j+1;
	    }
            wd->colors[j].refcount = 1;
            /*
             * Store their allocated pixel (r,g,b) values.
             */
            color.pixel = wd->colors[j].c = a.pixels[i];
            XQueryColor(stddpy, wd->cmap, &color);
            wd->colors[j].r = color.red;
            wd->colors[j].g = color.green;
            wd->colors[j].b = color.blue;
            clr = lcolor(w, color);
            sprintf(wd->colors[j].name,"%ld,%ld,%ld",clr.red,clr.green,clr.blue);
            if (ws->numColors == WMAXCOLORS)
                ;
            else {
                if (ws->theColors == NULL) {
                    MemProtect(ws->theColors = calloc(WMAXCOLORS, sizeof(short)));
                }
                ws->theColors[ws->numColors++] = j;
	    }
        }
#else					/* HAVE_LIBXPM */
        return (Pixmap) NULL;
#endif					/* HAVE_LIBXPM */
    }

    if (p2 == (Pixmap) NULL) {
        return (Pixmap) NULL;
    }

    if (stdgc == NULL) {
        gcv.foreground = wd->colors[wc->fg].c;
        gcv.background = wd->colors[wc->bg].c;
#ifdef HAVE_LIBXFT
        gcv.font       = wd->xfont->fid;
#else
        gcv.font       = wc->font->fsp->fid;
#endif
        wc->gc = XCreateGC(stddpy, p2, gcmask, &gcv);
        stdgc = wc->gc;
    }

    if (isxbm) {
        XCopyPlane(stddpy, p1, p2, stdgc, 0, 0, *width, *height, 0, 0, 1);
        XSync(stddpy, False);
        XFreePixmap(stddpy, p1);
    }
    return p2;
}

/*
 * Interpret a platform-specific color name s.
 * Under X, we can do this only if there is a window.
 */
int nativecolor(wbp w, char *s, long *r, long *g, long *b)
{
    XColor colorcell;
    LinearColor clr;
    wsp ws;
    wdp wd;

    if (!w)				/* if no window, give up */
        return 0;
    ws = w->window;
    wd = ws->display;
    if (!XParseColor(wd->display, wd->cmap, s, &colorcell))
        return 0;				/* if unknown to X */
    clr = lcolor(w, colorcell);
    *r = clr.red;
    *g = clr.green;
    *b = clr.blue;
    return 1;
}

/*
 * Convert an X color into an Icon linear color.
 */
static LinearColor lcolor(wbp w, XColor colorcell)
{
    LinearColor l;
    double gamma = w->context->gamma;

    l.red   = 65535 * pow((int)colorcell.red   / 65535.0, gamma);
    l.green = 65535 * pow((int)colorcell.green / 65535.0, gamma);
    l.blue  = 65535 * pow((int)colorcell.blue  / 65535.0, gamma);
    return l;
}

/*
 * Convert an Icon linear color into an X colorcell.
 */
static XColor xcolor(wbp w, LinearColor c)
{
    XColor x;
    double invgamma = 1.0 / w->context->gamma;

    x.red   = 65535 * pow(c.red   / 65535.0, invgamma);
    x.green = 65535 * pow(c.green / 65535.0, invgamma);
    x.blue  = 65535 * pow(c.blue  / 65535.0, invgamma);
    x.flags = DoRed | DoGreen | DoBlue;
    x.pixel = 0;
    x.pad = 0;

    return x;
}


int raisewindow(wbp w)
{
    XEvent event;
    XWindowAttributes attr;

    wsp ws = w->window;
    if (ws->win) {
        XMapRaised(ws->display->display, ws->win);

        /* Wait for the window to become viewable before giving
           it the focus. */
        for (;;) {
            XGetWindowAttributes(ws->display->display, ws->win, &attr);
            if (attr.map_state == IsViewable)
                break;
            /* Not viewable yet, so wait for a MapNotify event. */
            XWindowEvent(ws->display->display, 
                         ws->win,
                         StructureNotifyMask, 
                         &event);
        }

        /* Now it is viewable, so give it the focus. */
        XSetInputFocus(ws->display->display, ws->win, RevertToParent, CurrentTime);
    }
    return Succeeded;
}

int lowerwindow(wbp w)
{
    if (w->window->win)
        XLowerWindow(w->window->display->display, w->window->win);
    return Succeeded;
}

int walert(wbp w, int volume)
{
    STDLOCALS(w);
    XBell(stddpy, volume);    
    XFlush(stddpy);
    return Succeeded;
}

#ifdef HAVE_LIBXFT
int textwidth(wbp w, char *s, int n)
{
    XGlyphInfo	extents; 

    XftTextExtents8 (w->window->display->display,
                     w->context->font->fsp,
                     (FcChar8 *)s,
                     n,
                     &extents);
    return extents.xOff;
}

int utf8width(wbp w, char *s, int n)
{
    XGlyphInfo	extents; 

    XftTextExtentsUtf8 (w->window->display->display,
                        w->context->font->fsp,
                        (FcChar8 *)s,
                        n,
                        &extents);
    return extents.xOff;
}


void drawstring(wbp w, int x, int y, char *str, int slen)
{
    XftColor color;
    Region r;
    XRectangle rec;
    struct wcolor *cc;
    STDLOCALS(w);

    if (ws->win && !ws->winDraw)
        ws->winDraw = XftDrawCreate(ws->display->display,
                                    ws->win,
                                    ws->vis,
                                    ws->display->cmap);

    if (!ws->pixDraw)
        ws->pixDraw = XftDrawCreate(ws->display->display,
                                    ws->pix,
                                    ws->vis,
                                    ws->display->cmap);
    /* Don't think xft can do XOR drawing, so just swap bg/fg instead */
    if (ISXORREVERSE(w))
        cc = &wd->colors[wc->bg];
    else
        cc = &wd->colors[wc->fg];
    color.pixel = cc->c;
    color.color.red = cc->r;
    color.color.green = cc->g;
    color.color.blue = cc->b;
    color.color.alpha = 0xffff;

    if (wc->clipw >= 0 && wc->cliph >=0) {
        r = XCreateRegion();
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XUnionRectWithRegion(&rec, r, r);
        if (ws->winDraw) 
            XftDrawSetClip(w->window->winDraw, r);
        if (ws->pixDraw) 
            XftDrawSetClip(w->window->pixDraw, r);
        XDestroyRegion(r);
    } else {
        if (ws->winDraw) 
            XftDrawSetClip(w->window->winDraw, 0);
        if (ws->pixDraw) 
            XftDrawSetClip(w->window->pixDraw, 0);
    }

    if (ws->winDraw)
        XftDrawString8 (ws->winDraw,
                        &color,
                        wc->font->fsp,
                        x,
                        y,
                        (FcChar8 *)str,
                        slen);

    if (ws->pixDraw)
        XftDrawString8 (ws->pixDraw,
                        &color,
                        wc->font->fsp,
                        x,
                        y,
                        (FcChar8 *)str,
                        slen);
}

void drawutf8(wbp w, int x, int y, char *str, int slen)
{
    XftColor color;
    Region r;
    XRectangle rec;
    struct wcolor *cc;
    STDLOCALS(w);

    if (ws->win && !ws->winDraw)
        ws->winDraw = XftDrawCreate(ws->display->display,
                                    ws->win,
                                    ws->vis,
                                    ws->display->cmap);

    if (!ws->pixDraw)
        ws->pixDraw = XftDrawCreate(ws->display->display,
                                    ws->pix,
                                    ws->vis,
                                    ws->display->cmap);
    /* Don't think xft can do XOR drawing, so just swap bg/fg instead */
    if (ISXORREVERSE(w))
        cc = &wd->colors[wc->bg];
    else
        cc = &wd->colors[wc->fg];
    color.pixel = cc->c;
    color.color.red = cc->r;
    color.color.green = cc->g;
    color.color.blue = cc->b;
    color.color.alpha = 0xffff;

    if (wc->clipw >= 0 && wc->cliph >=0) {
        r = XCreateRegion();
        rec.x = wc->clipx;
        rec.y = wc->clipy;
        rec.width = wc->clipw;
        rec.height = wc->cliph;
        XUnionRectWithRegion(&rec, r, r);
        if (ws->winDraw) 
            XftDrawSetClip(w->window->winDraw, r);
        if (ws->pixDraw) 
            XftDrawSetClip(w->window->pixDraw, r);
        XDestroyRegion(r);
    } else {
        if (ws->winDraw) 
            XftDrawSetClip(w->window->winDraw, 0);
        if (ws->pixDraw) 
            XftDrawSetClip(w->window->pixDraw, 0);
    }

    if (ws->winDraw)
        XftDrawStringUtf8 (ws->winDraw,
                           &color,
                           wc->font->fsp,
                           x,
                           y,
                           (FcChar8 *)str,
                           slen);

    if (ws->pixDraw)
        XftDrawStringUtf8 (ws->pixDraw,
                           &color,
                           wc->font->fsp,
                           x,
                           y,
                           (FcChar8 *)str,
                           slen);
}
#else
int textwidth(wbp w, char *s, int n)
{
    return XTextWidth(w->context->font->fsp, s, n);
}

int utf8width(wbp w, char *s, int n)
{
    return textwidth(w, s, n);
}

void drawstring(wbp w, int x, int y, char *s, int slen)
{ 
    STDLOCALS(w); 
    RENDER4(XDrawString, x, y, s, slen); 
}
void drawutf8(wbp w, int x, int y, char *s, int slen)
{
    STDLOCALS(w); 
    RENDER4(XDrawString, x, y, s, slen);
}
#endif            /* HAVE_LIBXFT */

/*
 * Allocate a color given linear r, g, b. Colors are shared on a
 * per-display basis, but they are often freed on a per-window basis,
 * so they are remembered in two structures.
 */
static wclrp alc_rgb(wbp w, char *s, unsigned int r, unsigned int g,
              unsigned int b, int is_iconcolor)
{
    LinearColor lc;
    XColor color;
    int i;
    int *numColors;
    int *sizColors;
    short **theColors;
    STDLOCALS(w);

    /*
     * handle black and white specially (no allocation)
     */
    if ((r == 0) && (g == 0) && (b == 0))
        return &(wd->colors[0]);
    if ((r == 65535) && (g == 65535) && (b == 65535))
        return &(wd->colors[1]);

    if (is_iconcolor) {
        if (ws->iconColors == NULL) {
            MemProtect(ws->iconColors = calloc(WMAXCOLORS, sizeof(short)));
            ws->siziColors = WMAXCOLORS;
        }
        numColors = &(ws->numiColors);
        sizColors = &(ws->siziColors);
        theColors = &(ws->iconColors);
    }
    else {
        if (ws->theColors == NULL) {
            MemProtect(ws->theColors = calloc(WMAXCOLORS*2, sizeof(short)));
            ws->sizColors = WMAXCOLORS*2;
        }
        numColors = &(ws->numColors);
        sizColors = &(ws->sizColors);
        theColors = &(ws->theColors);
    }

    /*
     * Change into server-dependent R G B
     */
    lc.red = r;
    lc.green = g;
    lc.blue = b;
    color = xcolor(w, lc);
    r = color.red;
    g = color.green;
    b = color.blue;

    /*
     * Search for the color in w's display
     */
    for (i = 2; i < wd->numColors; i++) {
        if (wd->colors[i].refcount>0 &&
            wd->colors[i].type == SHARED &&
            color.red == wd->colors[i].r &&
            color.green == wd->colors[i].g &&
            color.blue == wd->colors[i].b)
            break;
    }

    if (i >= wd->numColors) {
        int j;
        /*
         * color not found, must allocate
         * first verify there is room in window color table.
         */
        if (*numColors >= *sizColors-1) {
            if (*numColors >= 2 << DefaultDepth(wd->display, wd->screen))
                return NULL;
            MemProtect((*theColors) = realloc(*theColors, *sizColors * 2 * sizeof(short)));
            *sizColors *= 2;
            /*
             * reallocated color table to *sizColors
             */
        }

        if (!XAllocColor(stddpy, wd->cmap, &color)) {
            /* try again with a virtual colormap (but not for an icon) */
            if (is_iconcolor || !go_virtual(w) ||
                !XAllocColor(stddpy, wd->cmap, &color))
                return NULL;
        }
        j = alc_centry(wd);
        if (j == 0)
            return NULL;
        strcpy(wd->colors[j].name, s);
        /*
         * Store server color as requested in color table.
         */
        wd->colors[j].r = r;
        wd->colors[j].g = g;
        wd->colors[j].b = b;
        wd->colors[j].c = color.pixel;
        wd->colors[j].type = SHARED;
        (*theColors)[(*numColors)++] = j;
        return &(wd->colors[j]);
    }
    else {
        /* color is found, alias it and put it in the window color table */
        int k;
        for(k=0; k < *numColors; k++){
            if ((*theColors)[k] == i) {
                /* already there, no further action needed */
                return &(wd->colors[i]);
            }
        }
        wd->colors[i].refcount++;
        (*theColors)[(*numColors)++] = i;
        return &(wd->colors[i]);
    }
}

/*
 * allocate a color entry, return index (or 0 if table is full)
 */
static int alc_centry(wdp wd)
{
    int i, j;

    for (j = 2; j < wd->sizColors; j++)
        if (wd->colors[j].refcount == 0)
            break;
    if (j >= wd->sizColors-1) {
        if (j >= 2 << DefaultDepth(wd->display, wd->screen)) return 0;
        MemProtect(wd->colors = realloc(wd->colors,
                                        wd->sizColors * 2 * sizeof (struct wcolor)));
        for(i=wd->sizColors;i<wd->sizColors*2;i++) wd->colors[i].refcount=0;
        wd->sizColors *= 2;
        /*
         * reallocated color table to wd->sizColors
         */
    }
    if (j == wd->numColors)
        wd->numColors++;
    else if (j > wd->numColors)
        return 0;		/* internal confusion */

    wd->colors[j].refcount = 1;
    return j;
}

/*
 * copy color entries to reflect pixel transmission via CopyArea()
 * (assumes w1 and w2 are on the same display)
 */
static void copy_colors(wbp w1, wbp w2)
{
    wsp ws1 = w1->window, ws2 = w2 -> window;
    wdp wd = ws1->display;
    int i1, i2, j;

    for (i1 = 0; i1 < ws1->numColors; i1++) {
        j = ws1->theColors[i1];
        if (wd->colors[j].refcount > 0 && wd->colors[j].type != MUTABLE) {
            for (i2 = 0; i2 < ws2->numColors; i2++) {
                if (j == ws2->theColors[i2])
                    break;
	    }
            if (i2 >= ws2->numColors) {
                /* need to add this color */
                wd->colors[j].refcount++;
                if (ws2->numColors < WMAXCOLORS) {
                    if (ws2->theColors == NULL)
                        MemProtect(ws2->theColors = calloc(WMAXCOLORS, sizeof(short)));
                    ws2->sizColors = WMAXCOLORS;
                    ws2->theColors[ws2->numColors++] = j;
                }
                /* else cannot record it -- table full */
	    }
        }
    }
}

/*
 * free a single color allocated by a given window
 */
static void free_xcolor(wbp w, unsigned long c)
{
    int i;
    STDLOCALS(w);

    for (i = 0; i < ws->numColors; i++) {
        if (wd->colors[ws->theColors[i]].c == c) break;
    }
    if (i >= ws->numColors) {
        /* "free_xcolor couldn't find the color in the window\n" */
    }
    else {
        if (--(wd->colors[ws->theColors[i]].refcount) == 0) {
            XFreeColors(stddpy, wd->cmap, &c, 1, 0);
            ws->numColors--;
            if (ws->numColors != i)
                ws->theColors[i] = ws->theColors[ws->numColors];
        }
    }
}

/*
 * free the colors allocated by a given window.  extent indicates how much
 * to free.  extent == 0 implies window colors except black, white,
 * fg, bg, wbg, and mutable colors.  extent == 1 implies free icon colors.
 * extent == 2 implies free window AND fg/bg/wbg (window is closed)
 */
static void free_xcolors(wbp w, int extent)
{
    int i;
    unsigned long *toFree;
    int freed = 0;
    int *numColors;
    int numSaved;
    short *theColors;
    STDLOCALS(w);

    numColors = (extent==1 ? &(ws->numiColors) : &(ws->numColors));
    theColors = (extent==1 ? ws->iconColors : ws->theColors);

    MemProtect(toFree = malloc(*numColors * sizeof(unsigned long)));
    numSaved = 0;
    for (i = *numColors-1; i >= 0; i--) {
        int j = theColors[i];


        if (j < 2)		/* black & white are permanent residents */
            continue;
        /*
         * don't free fg, bg, or mutable color
         */
        if (((extent==0) && (j == w->context->fg)) ||
            ((extent==0) && (j == w->context->bg)) ||
            (wd->colors[j].type == MUTABLE)) {
            theColors[numSaved++] = j;
            continue;
        }

#ifndef NoFreeColorFix
        /*
         * don't free ANY context's fg or bg
         */
        {
            wcp wc; int numhits = 0;
            for(wc=wcntxts; wc; wc=wc->next) {
                if ((wc->fg == j) || (wc->bg == j)) {
                    if (numhits == 0)
                        theColors[numSaved++] = j;
                    numhits++;
                }
            }
            if (numhits) {
                if (numhits > wd->colors[j].refcount)
                    wd->colors[j].refcount = numhits;
                continue;
            }
        }
#endif					/* NoFreeColorFix */

        if (--(wd->colors[j].refcount) == 0) {
            toFree[freed++] = wd->colors[j].c;
        }
    }
    if (freed>0)
        XFreeColors(stddpy, wd->cmap, toFree, freed,0);
    *numColors = numSaved;
    free(toFree);
}

/*
 * Allocate a virtual colormap with all colors used by the client copied from
 * the default colormap to new colormap, and set all windows to use this new
 * colormap.  Returns 0 on failure.
 */
static int go_virtual(wbp w)
{
    wsp win;
    STDLOCALS(w);

    if (wd->cmap != DefaultColormap(stddpy,wd->screen))
        return 0;    /* already using a virtual colormap */

    wd->cmap = XCopyColormapAndFree(stddpy,wd->cmap);

    /* set the colormap for all the windows to the new colormap */

    for (win = wstates; win; win = win->next)
        if ((win->display->display == stddpy) & (win->win != (Window)NULL))
            XSetWindowColormap(stddpy, win->win, wd->cmap);

    return 1;
}

/*
 * allocate a display on machine s
 */
static wdp alc_display(char *s)
{
    double g;
    wdp wd;
    XColor color;

    if (s == NULL) s = getenv("DISPLAY");
    if (s == NULL) s = "";
    for(wd = wdsplys; wd; wd = wd->next)
        if (wd->program == curpstate && !strcmp(wd->name,s)) {
            wd->refcount++;
            return wd;
        }

    GRFX_ALLOC(wd, _wdisplay);

    strcpy(wd->name,s);
    wd->program = curpstate;
    wd->display = XOpenDisplay((*s=='\0') ? NULL : s);

    if (wd->display == NULL) {
        wd->refcount = 0;
        free(wd);
        return NULL;
    }

    wd->screen = DefaultScreen(wd->display);
    wd->cmap = DefaultColormap(wd->display, wd->screen);

    /*
     * Color slots 0 and 1 are permanently reserved for black and white
     * respectively.  Allocate them explicitly so that they're preserved
     * if we later switch to a virtual colormap.
     */
    wd->sizColors = DMAXCOLORS;
    MemProtect(wd->colors = calloc(DMAXCOLORS, sizeof (struct wcolor)));
    strcpy(wd->colors[0].name,"black");
    wd->colors[0].refcount = 1;
    wd->colors[0].type = SHARED;
    wd->colors[0].r = wd->colors[0].g = wd->colors[0].b = 0;
    color.red = color.green = color.blue = 0;
    if (XAllocColor(wd->display, wd->cmap, &color))
        wd->colors[0].c = color.pixel;
    else
        wd->colors[0].c = BlackPixel(wd->display,wd->screen);

    strcpy(wd->colors[1].name,"white");
    wd->colors[1].refcount = 1;
    wd->colors[1].type = SHARED;
    wd->colors[1].r = wd->colors[1].g = wd->colors[1].b = 65535;
    color.red = color.green = color.blue = 65535;
    if (XAllocColor(wd->display, wd->cmap, &color))
        wd->colors[1].c = color.pixel;
    else
        wd->colors[1].c = WhitePixel(wd->display,wd->screen);
    wd->numColors = 2;

    /*
     * Set the default gamma correction value for windows that are
     * opened on this display.  Start with configuration default,
     * but if we can get an interpretation of "RGBi:.5/.5/.5",
     * calculate a gamma value from that instead.
     */
    wd->gamma = GammaCorrection;
    if (XParseColor(wd->display, wd->cmap, "RGBi:.5/.5/.5", &color)) {
        g = .299 * color.red + .587 * color.green + .114 * color.blue;
        g /= 65535;
        if (g >= 0.1 && g <= 0.9)		/* sanity check */
            wd->gamma = log(0.5) / log(g);
    }

    /*
     * Initialize fonts and other things.
     */
    wd->numFonts = 1;
#ifdef HAVE_LIBXFT
    wd->fonts = loadfont(wd, convert_spec(DEFAULTFONTNAME));
#else
    wd->fonts = loadfont(wd, DEFAULTFONTNAME);
#endif
    if (wd->fonts == NULL) {
        free(wd);
        return NULL;
    }
    wd->fonts->refcount = 1;
    wd->fonts->next = wd->fonts->previous = NULL;
#ifdef HAVE_LIBXFT
    wd->xfont = XLoadQueryFont(wd->display, "fixed");
#endif
    {
        XGCValues gcv;
        Display *stddpy = wd->display;
#ifdef HAVE_LIBXFT
        gcv.font = wd->xfont->fid;
#else
        gcv.font = wd->fonts->fsp->fid;
#endif
        gcv.foreground = wd->colors[0].c;
        gcv.background = wd->colors[1].c;
        gcv.fill_style = FillSolid;
        gcv.cap_style = CapProjecting;
        wd->icongc = XCreateGC(stddpy, DefaultRootWindow(stddpy),
                               GCFont | GCForeground | GCBackground | GCFillStyle | GCCapStyle, &gcv);
        if (wd->icongc == NULL) {
            free(wd);
            return NULL;
        }
    }
    GRFX_LINK(wd, wdsplys);
    return wd;
}


#ifdef HAVE_LIBXFT

/*
 * Convert a given font spec, which may or may not be in icon font spec format,
 * into fontconfig (used by Xft) style format.  The result is never null.
 * 
 * To avoid ambiguity, a spec can start with "fc:" to indicate it's in fontconfig
 * format; otherwise parsefont is called to decide the format.
 */
static char *convert_spec(char *s)
{
    static char res[256];
    int flags, size;
    char family[MAXFONTWORD+1];
    XftPattern *p;

    if (!strncmp(s, "fc:", 3))
        return s + 3;

    if (!parsefont(s, family, &flags, &size))
        return s;

    p = XftPatternCreate();

    /*
     * Check first for special "standard" family names.
     */
    if (!strcmp(family, "fixed")) {
        XftPatternAddString(p, XFT_FAMILY, "Object Icon fixed");
        XftPatternAddString(p, XFT_FAMILY, "mono");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "mono")) {
        XftPatternAddString(p, XFT_FAMILY, "Object Icon mono");
        XftPatternAddString(p, XFT_FAMILY, "mono");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "typewriter")) {
        XftPatternAddString(p, XFT_FAMILY, "Object Icon typewriter");
        XftPatternAddString(p, XFT_FAMILY, "courier");
        flags |= FONTFLAG_MONO;
    }
    else if (!strcmp(family, "sans")) {
        XftPatternAddString(p, XFT_FAMILY, "Object Icon sans");
        XftPatternAddString(p, XFT_FAMILY, "helvetica");
        flags |= FONTFLAG_PROPORTIONAL;
    }
    else if (!strcmp(family, "serif")) {
        XftPatternAddString(p, XFT_FAMILY, "Object Icon serif");
        XftPatternAddString(p, XFT_FAMILY, "times");
        flags |= FONTFLAG_PROPORTIONAL;
    }
    else
        XftPatternAddString(p, XFT_FAMILY, family);

    if (size > 0)
        XftPatternAddDouble(p, XFT_SIZE, (double)size);

    if (flags & FONTFLAG_MEDIUM)
        XftPatternAddInteger(p, XFT_WEIGHT, XFT_WEIGHT_MEDIUM);
    else if ((flags & FONTFLAG_DEMI) && (flags & FONTFLAG_BOLD))
        XftPatternAddInteger(p, XFT_WEIGHT, XFT_WEIGHT_DEMIBOLD);
    else if (flags & FONTFLAG_BOLD)
        XftPatternAddInteger(p, XFT_WEIGHT, XFT_WEIGHT_BOLD);
    else if (flags & FONTFLAG_LIGHT)
        XftPatternAddInteger(p, XFT_WEIGHT, XFT_WEIGHT_LIGHT);

    if (flags & FONTFLAG_ITALIC)
        XftPatternAddInteger(p, XFT_SLANT, XFT_SLANT_ITALIC);
    else if (flags & FONTFLAG_OBLIQUE)
        XftPatternAddInteger(p, XFT_SLANT, XFT_SLANT_OBLIQUE);
    else if (flags & FONTFLAG_ROMAN)
        XftPatternAddInteger(p, XFT_SLANT, XFT_SLANT_ROMAN);

    if (flags & FONTFLAG_PROPORTIONAL)
        XftPatternAddInteger(p, XFT_SPACING, XFT_PROPORTIONAL);
    if (flags & FONTFLAG_MONO)
        XftPatternAddInteger(p, XFT_SPACING, XFT_MONO);

    XftNameUnparse(p, res, sizeof(res) - 1);
    XftPatternDestroy(p);

    return res;
}

/*
 * allocate font s in the display attached to w
 */
static wfp alc_font(wbp w, char *s)
{
    return tryfont(w,convert_spec(s));
}


#else /* HAVE_LIBXFT */

/*
 * allocate font s in the display attached to w
 */
wfp alc_font(wbp w, char *s)
{
    int flags, size;
    wfp rv = NULL;
    char family[MAXFONTWORD+1];
    char *stdfam;

    if (strcmp(s, "fixed") != 0 && parsefont(s, family, &flags, &size)) {
        /*
         * This is a legal Icon font spec (and it's not an unadorned "fixed").
         * Check first for special "standard" family names.
         */
        if (!strcmp(family, "mono")) {
            stdfam = "lucidatypewriter";
            flags |= FONTFLAG_MONO + FONTFLAG_SANS;
        }
        else if (!strcmp(family, "typewriter")) {
            stdfam = "courier";
            flags |= FONTFLAG_MONO + FONTFLAG_SERIF;
        }
        else if (!strcmp(family, "sans")) {
            stdfam = "helvetica";
            flags |= FONTFLAG_PROPORTIONAL + FONTFLAG_SANS;
        }
        else if (!strcmp(family, "serif")) {
            stdfam = "times";
            flags |= FONTFLAG_PROPORTIONAL + FONTFLAG_SERIF;
        }
        else stdfam = NULL;

        if (stdfam) {
            /*
             * Standard name: first try preferred family, then generalize.
             */
            rv = findfont(w, stdfam, size, flags);
            if (!rv)
                rv = findfont(w, "*", size, flags);
        }
        else {
            /*
             * Any other name: must match as specified.
             */
            rv = findfont(w, family, size, flags);
        }
        if (rv != NULL)
            return rv;
    }

    /*
     * Not found as an Icon name; may be an X font name.
     */
    return tryfont(w, s);
}

/*
 * return pointer to field i inside XLFD (X Logical Font Description) s.
 */
static char *xlfd_field(char *s, int i)
{
    int j = 0;
    while (j < i) {
        if (*s == '\0') return "";	/* if no such field */
        if (*s++ == '-') j++;
    }
    return s;
}

/*
 * return size of font, treating a scalable font as having size n
 */
static int xlfd_size(char *s, int n)
{
    char *f;
    int z;

    f = xlfd_field(s, XLFD_Size);
    if (!*f)
        return 0;
    z = atoi(f);
    if (z != 0)
        return z;
    else
        return n;
}

/*
 * Find the best font matching a set of specifications.
 */
static wfp findfont(wbp w, char *family, int size, int flags)
{
    char fontspec[MAXFONTWORD+100];
    char *p, *weight, *slant, *width, *spacing, **fontlist;
    int n, champ, challenger, bestsize;

    /*
     * Construct a font specification that enforces any stated requirements
     * of size, weight, slant, set width, or proportionality.
     */
    if (size > 0)
        bestsize = size;
    else
        bestsize = DEFAULTFONTSIZE;

    if (flags & FONTFLAG_MEDIUM)
        weight = "medium";
    else if ((flags & FONTFLAG_DEMI) && (flags & FONTFLAG_BOLD))
        weight = "demibold";
    else if (flags & FONTFLAG_BOLD)
        weight = "bold";
    else if (flags & FONTFLAG_DEMI)
        weight = "demi";
    else if (flags & FONTFLAG_LIGHT)
        weight = "light";
    else
        weight = "*";

    if (flags & FONTFLAG_ITALIC)
        slant = "i";
    else if (flags & FONTFLAG_OBLIQUE)
        slant = "o";
    else if (flags & FONTFLAG_ROMAN)
        slant = "r";
    else
        slant = "*";

    if (flags & FONTFLAG_NARROW)
        width = "narrow";
    else if (flags & FONTFLAG_CONDENSED)
        width = "condensed";
    else if (flags & FONTFLAG_NORMAL)
        width = "normal";
    else if (flags & FONTFLAG_WIDE)
        width = "wide";
    else if (flags & FONTFLAG_EXTENDED)
        width = "extended";
    else
        width = "*";

    if (flags & FONTFLAG_PROPORTIONAL)
        spacing = "p";
    else
        spacing = "*";			/* can't specify {m or c} to X */

    sprintf(fontspec, "-*-%s-%s-%s-%s-*-*-*-*-*-%s-*-*-*",
            family, weight, slant, width, spacing);

    /*
     * Get a list of matching fonts from the X server and find the best one.
     */
    fontlist = XListFonts(w->window->display->display, fontspec, 2500, &n);
    champ = 0;
    while (champ < n && !okfont(fontlist[champ], size, flags))
        champ++;
    if (champ >= n) {
        XFreeFontNames(fontlist);
        return NULL;			/* nothing acceptable */
    }
    for (challenger = champ + 1; challenger < n; challenger++) 
        if (okfont(fontlist[challenger], size, flags)
            && fontcmp(fontlist[challenger], fontlist[champ], bestsize, flags) < 0)
            champ = challenger;

    /*
     * Set the scaling field, if needed, and load the font.
     */
    p = xlfd_field(fontlist[champ], XLFD_Size);
    if (p[0] == '0' && p[1] == '-')
        sprintf(fontspec, "%.*s%d%s", (int)(p - fontlist[champ]),
                fontlist[champ], bestsize, p + 1);
    else
        strcpy(fontspec, fontlist[champ]);
    XFreeFontNames(fontlist);
    return tryfont(w, fontspec);
}

/*
 * check for minimum acceptability of a font
 * (things that couldn't be filtered by the XLFD pattern):
 * -- size wrong (there's a bug in OpenWindows 3.3 else X could do it)
 * -- not monospaced (can't set pattern to match m or c but not p)
 */
static int okfont(char *spec, int size, int flags)
{
    if (size > 0 && xlfd_size(spec, size) != size)
        return 0;			/* can't match explicit size request */
    if ((flags & FONTFLAG_MONO) && xlfd_field(spec, XLFD_Spacing)[0] == 'p')
        return 0;			/* requested mono, but this isn't */
    return 1;
}

/*
 * rank two fonts based on whether XLFD field n matches a preferred value.
 * returns <0 if font1 is better, >0 if font2 is better, else 0.
 */
static int fieldcmp(char *font1, char *font2, char *value, int field)
{
    int len, r1, r2;

    len = strlen(value);
    r1 = (strncmp(xlfd_field(font1, field), value, len) == 0);
    r2 = (strncmp(xlfd_field(font2, field), value, len) == 0);
    return r2 - r1;			/* -1, 0, or 1 */
}

/*
 * rank two fonts.
 * returns <0 if font1 is better, >0 if font2 is better, else 0.
 *
 * Note that explicit requests for size, slant, weight, and width caused
 * earlier filtering in findfont(), so all those flags aren't checked
 * again here; normal values are just favored in case nothing was specified.
 */
static int fontcmp(char *font1, char *font2, int size, int flags)
{
    int n;

/* return if exactly one of the fonts matches value s in field n */
#define PREFER(s,n)                                                     \
    do { int r = fieldcmp(font1, font2, s, n); if (r != 0) return r; } while (0)

/* return if exactly one of the fonts does NOT match value s in field n */
#define SPURN(s,n)                                                      \
    do { int r = fieldcmp(font1, font2, s, n); if (r != 0) return -r; } while (0)

    /*
     * Prefer the font that is closest to the desired size.
     */
    n = abs(size - xlfd_size(font1, size)) - abs(size - xlfd_size(font2, size));
    if (n != 0)
        return n;

    /*
     * try to check serifs (though not always indicated in X font description)
     */
    if (flags & FONTFLAG_SANS) {
        PREFER("sans", XLFD_AddStyle);
        SPURN("serif", XLFD_AddStyle);
    }
    else if (flags & FONTFLAG_SERIF) {
        PREFER("serif", XLFD_AddStyle);
        SPURN("sans", XLFD_AddStyle);
    }

    /*
     * prefer normal values for other fields.  These only have an effect
     * for fields that were wildcarded when requesting the font list.
     */
    PREFER("r", XLFD_Slant);		/* prefer roman slant */
    PREFER("medium", XLFD_Weight);	/* prefer medium weight */
    SPURN("demi", XLFD_Weight);		/* prefer non-demi if no medium */
    PREFER("normal", XLFD_SetWidth);	/* prefer normal width */
    PREFER("iso8859", XLFD_CharSet);	/* prefer font of ASCII chars */
    SPURN("0", XLFD_PointSize);		/* prefer tuned font to scaled */
    PREFER("adobe", XLFD_Foundry);	/* these look better than others */

    /* no significant difference */
    return 0;
}


#endif /* HAVE_LIBXFT */


/*
 * load a font and return a font structure.
 */

static wfp tryfont(wbp w, char *s)
{
    wdp wd = w->window->display;
    wfp rv;
    /*
     * see if the font is already loaded on this display
     */
    for(rv = wd->fonts; rv != NULL; rv = rv->next) {
        if (!strcmp(s,rv->name)) break;
    }
    if (rv != NULL) {
        rv->refcount++;
        return rv;
    }
    /*
     * load a new font
     */
    rv = loadfont(wd, s);
    if (rv == NULL) {
        return NULL;
    }

    w->context->leading = rv->height;

    /*
     * link the font into this displays fontlist (but not at the head!)
     */
    rv->next = wd->fonts->next;
    rv->previous = wd->fonts;
    if (wd->fonts->next) wd->fonts->next->previous = rv;
    wd->fonts->next = rv;
    return rv;
}

static wfp loadfont(wdp wd, char *s)
{
    wfp rv;
    GRFX_ALLOC(rv, _wfont);
    rv->name = salloc(s);
#ifdef HAVE_LIBXFT
    rv->fsp = XftFontOpenName(wd->display, wd->screen, rv->name);
#else
    rv->fsp = XLoadQueryFont(wd->display, rv->name);
#endif
    if (rv->fsp == NULL){
        free(rv->name);
        free(rv);
        return NULL;
    }

#ifdef HAVE_LIBXFT
    {
        XGlyphInfo	extents; 
        char s[256];
        int i;

        /*
         * Xft seems to sometimes give too-small values in its font
         * ascent/descent fields; therefore calculate the GlyphInfo
         * for a sample string comprising the first 256 chars and take
         * the maximum ascent/descent of the sample and the font's
         * reported values.
         */
        for (i = 0; i < 256; ++i) s[i] = (char)i;
        XftTextExtents8 (wd->display,
                         rv->fsp,
                         (FcChar8 *)s,
                         256,
                         &extents);
        rv->ascent = Max(rv->fsp->ascent, extents.y);
        rv->descent = Max(rv->fsp->descent, extents.height - extents.y);
        rv->maxwidth = rv->fsp->max_advance_width;
    }
#else
    rv->ascent = rv->fsp->ascent;
    rv->descent = rv->fsp->descent;
    rv->maxwidth = rv->fsp->max_bounds.width;
#endif
    rv->height = rv->ascent + rv->descent;
    return rv;
}


/*
 * allocate a context.  Can't be called until w has a display and window.
 */
static wcp alc_context(wbp w)
{
    wcp wc;
    wdp wd = w->window->display;

    GRFX_ALLOC(wc, _wcontext);
    wc->serial = ++context_serial;
    wc->display = wd;
    wd->refcount++;
    wd->colors[0].refcount++;
    wc->fg = 0;
    wd->colors[1].refcount++;
    wc->bg = 1;
    wc->font = wd->fonts;
    wc->leading = wd->fonts->height;
    wc->drawop = GXcopy;
    wc->gamma = wd->gamma;
    wc->clipx = wc->clipy = 0;
    wc->clipw = wc->cliph = -1;
    wc->linewidth = 1;

    GRFX_LINK(wc, wcntxts);
    return wc;
}

/*
 * allocate a context, cloning attributes from an existing context
 */
wcp clonecontext(wbp w)
{
    wcp wc, rv;
    wdp wd;
    XGCValues gcv;
    XRectangle rec;
    unsigned long gcmask = GCFont | GCForeground | GCBackground |
        GCFillStyle | GCCapStyle | GCLineWidth | GCLineStyle;

    wc = w->context;
    wd = w->context->display;
    rv = alc_context(w);

    rv->dx = wc->dx;
    rv->dy = wc->dy;
    rv->clipx = wc->clipx;
    rv->clipy = wc->clipy;
    rv->clipw = wc->clipw;
    rv->cliph = wc->cliph;
    rv->fg = wc->fg;
    wd->colors[rv->fg].refcount++;
    rv->bg = wc->bg;
    wd->colors[rv->bg].refcount++;
    rv->font = wc->font;
    rv->font->refcount++;
    rv->fillstyle = wc->fillstyle;
    rv->linestyle = wc->linestyle;
    rv->linewidth = wc->linewidth;
    rv->drawop = wc->drawop;
    rv->gamma = wc->gamma;
    rv->bits = wc->bits;

    if (ISXORREVERSE(w))
        gcv.foreground = wd->colors[rv->fg].c ^ wd->colors[rv->bg].c;
    else
        gcv.foreground = wd->colors[rv->fg].c;
    gcv.background = wd->colors[rv->bg].c;
#ifdef HAVE_LIBXFT
    gcv.font       = wd->xfont->fid;
#else
    gcv.font       = rv->font->fsp->fid;
#endif
    gcv.line_style = rv->linestyle;
    gcv.line_width = rv->linewidth;
    if (rv->linewidth > 1) {
        gcv.dashes = 3 * rv->linewidth;
        gcmask |= GCDashList;
    }
    gcv.fill_style = rv->fillstyle;
    gcv.cap_style  = CapProjecting;
    MemProtect(rv->gc = XCreateGC(w->window->display->display,w->window->pix,gcmask,&gcv));
    if (rv->clipw >= 0) {
        rec.x = rv->clipx;
        rec.y = rv->clipy;
        rec.width = rv->clipw;
        rec.height = rv->cliph;
        XSetClipRectangles(rv->display->display, rv->gc, 0, 0, &rec, 1,Unsorted);
    }
    return rv;
}

/*
 * allocate a window state structure
 */
static wsp alc_winstate()
{
    wsp ws;
    GRFX_ALLOC(ws, _wstate);
    ws->serial = ++canvas_serial;
    ws->bits = 1024;				/* echo ON; others OFF */
    ws->listp = nulldesc;
    ws->theCursor = stringint_str2int(cursorsyms, "left ptr") >> 1;
    ws->inputmask =
        ExposureMask | KeyPressMask |
        ButtonPressMask | ButtonReleaseMask | ButtonMotionMask |
        StructureNotifyMask;
    ws->iconic = NormalState;
    ws->posx = ws->posy = -(INT_MAX);
    ws->minwidth = ws->minheight = 0;
    ws->maxwidth = ws->maxheight = INT_MAX;
#ifdef HAVE_LIBXFT
    ws->pixDraw = ws->winDraw = NULL;
#endif

    GRFX_LINK(ws, wstates);
    return ws;
}

/*
 * free a window state
 */
void free_window(wsp ws)
{
    ws->refcount--;
    if(ws->refcount == 0) {
        struct imgdata *imd;

        ws->bits |= 1;			/* SETZOMBIE */
#ifdef HAVE_LIBXFT
        if (ws->winDraw) {
            XftDrawDestroy(ws->winDraw);
            ws->winDraw = NULL;
        }
        if (ws->pixDraw) {
            XftDrawDestroy(ws->pixDraw);
            ws->pixDraw = NULL;
        }
#endif
        if (ws->win != (Window) NULL) {
            XDestroyWindow(ws->display->display, ws->win);
            XFlush(ws->display->display);
            while (ws->win != (Window) NULL)
                pollevent();
        }
        else {
            /*
             * There was no XDestroyWindow, so it is necessary
             * to free the Pixmap here, as it won't be freed via
             * a DestroyNotify event.
             */
            if (ws->pix != (Pixmap) NULL) {
                Display *d = ws->display->display;
                XFreePixmap(d, ws->pix);
                ws->pix = (Pixmap) NULL;
            }
        }
        /*
         * free any malloc'ed space within this window state, before freeing it in GRFX_UNLINK
         */
        if (ws->theColors) { free(ws->theColors); ws->iconColors = NULL; }
        if (ws->iconColors) { free(ws->iconColors); ws->iconColors = NULL; }

        imd = &ws->initimage;
        if (imd->width) {
            free(imd->paltbl);
            free(imd->data);
            imd->width = 0;
        }

        imd = &ws->initicon;
        if (imd->width) {
            free(imd->paltbl);
            free(imd->data);
            imd->width = 0;
        }

        GRFX_UNLINK(ws, wstates);
    }
}

/*
 * free a window context
 */
void free_context(wcp wc)
{
    wc->refcount--;
    if(wc->refcount == 0) {
        if (wc->gc != NULL)
            XFreeGC(wc->display->display, wc->gc);
        /* free color references to fg and bg? */
        free_display(wc->display);
        GRFX_UNLINK(wc, wcntxts);
    }
}

/*
 * free a display
 */
static void free_display(wdp wd)
{
    wd->refcount--;
    if(wd->refcount == 0) {
        if (wd->cmap != DefaultColormap(wd->display, wd->screen))
            XFreeColormap(wd->display, wd->cmap);
        XCloseDisplay(wd->display);
        if (wd->previous) wd->previous->next = wd->next;
        else wdsplys = wd->next;
        if (wd->next) wd->next->previous = wd->previous;
        free(wd);
    }
}

#endif            /* Graphics */
