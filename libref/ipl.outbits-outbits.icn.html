<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>outbits.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     outbits.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedure to write variable-length characters
<a name="6"/>#
<a name="7"/>#	Author:   Richard L. Goerwitz
<a name="8"/>#
<a name="9"/>#	Date:     November 3, 1991
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#	Version:  1.5
<a name="18"/>#
<a name="19"/>############################################################################
<a name="20"/>#
<a name="21"/>#  In any number of instances (e.g. when outputting variable-length
<a name="22"/>#  characters or fixed-length encoded strings), the programmer must
<a name="23"/>#  fit variable and/or non-byte-sized blocks into standard 8-bit
<a name="24"/>#  bytes.  Outbits() performs this task.
<a name="25"/>#
<a name="26"/>#  Pass to outbits(i, len) an integer i, and a length parameter (len),
<a name="27"/>#  and outbits will suspend byte-sized chunks of i converted to
<a name="28"/>#  characters (most significant bits first) until there is not enough
<a name="29"/>#  left of i to fill up an 8-bit character.  The remaining portion is
<a name="30"/>#  stored in a buffer until outbits() is called again, at which point
<a name="31"/>#  the buffer is combined with the new i and then output in the same
<a name="32"/>#  manner as before.  The buffer is flushed by calling outbits() with
<a name="33"/>#  a null i argument.  Note that len gives the number of bits there
<a name="34"/>#  are in i (or at least the number of bits you want preserved; those
<a name="35"/>#  that are discarded are the most significant ones). 
<a name="36"/>#
<a name="37"/>#  A trivial example of how outbits() might be used:
<a name="38"/>#
<a name="39"/>#      outtext := open("some.file.name","w")
<a name="40"/>#      l := [1,2,3,4]
<a name="41"/>#      every writes(outtext, outbits(!l,3))
<a name="42"/>#      writes(outtext, outbits(&amp;null,3))           # flush buffer
<a name="43"/>#
<a name="44"/>#  List l may be reconstructed with inbits() (see inbits.icn):
<a name="45"/>#
<a name="46"/>#      intext := open("some.file.name")
<a name="47"/>#      l := []
<a name="48"/>#      while put(l, inbits(intext, 3))
<a name="49"/>#
<a name="50"/>#  Note that outbits() is a generator, while inbits() is not.
<a name="51"/>#
<a name="52"/>############################################################################
<a name="53"/>#
<a name="54"/>#  See also: inbits.icn
<a name="55"/>#
<a name="56"/>############################################################################
<a name="57"/>
<a name="58"/>package ipl.outbits
<a name="59"/>
<a name="60"/>procedure outbits(i, len)
<a name="61"/>
<a name="62"/>    local old_part, new_part, window, old_byte_mask
<a name="63"/>    static old_i, old_len, byte_length, byte_mask
<a name="64"/>    initial {
<a name="65"/>	old_i := old_len := 0
<a name="66"/>	byte_length := 8
<a name="67"/>	byte_mask := (2^byte_length)-1
<a name="68"/>    }
<a name="69"/>
<a name="70"/>    old_byte_mask := (0 &lt; 2^old_len - 1) | 0
<a name="71"/>    window := byte_length - old_len
<a name="72"/>    old_part := ishift(iand(old_i, old_byte_mask), window)
<a name="73"/>
<a name="74"/>    # If we have a no-arg invocation, then flush buffer (old_i).
<a name="75"/>    if /i then {
<a name="76"/>	if old_len &gt; 0 then {
<a name="77"/>	    old_i := old_len := 0
<a name="78"/>	    return char(old_part)
<a name="79"/>	} else {
<a name="80"/>	    old_i := old_len := 0
<a name="81"/>	    fail
<a name="82"/>	}
<a name="83"/>    } else {
<a name="84"/>	new_part := ishift(i, window-len)
<a name="85"/>	unless len -:= (len &gt;= window) then {
<a name="86"/>	    old_len +:= len
<a name="87"/>	    old_i := ior(ishift(old_part, len-window), i)
<a name="88"/>	    fail
<a name="89"/>	}
<a name="90"/>#	For debugging purposes.
<a name="91"/>#	write("old_byte_mask = ", old_byte_mask)
<a name="92"/>#	write("window = ", image(window))
<a name="93"/>#	write("old_part = ", image(old_part))
<a name="94"/>#	write("new_part = ", image(new_part))
<a name="95"/>#	write("outputting ", image(ior(old_part, new_part)))
<a name="96"/>	suspend char(ior(old_part, new_part))
<a name="97"/>    }
<a name="98"/>
<a name="99"/>    until len &lt; byte_length do {
<a name="100"/>	suspend char(iand(ishift(i, byte_length-len), byte_mask))
<a name="101"/>	len -:= byte_length
<a name="102"/>    }
<a name="103"/>
<a name="104"/>    old_len := len
<a name="105"/>    old_i := i
<a name="106"/>    fail
<a name="107"/>
<a name="108"/>end
</pre></body></html>
