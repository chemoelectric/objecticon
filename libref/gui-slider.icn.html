<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>slider.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: slider.icn 9113 2021-05-21 16:34:21Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package gui
<a name="10"/>
<a name="11"/>import lang, graphics, util, ipl.pdco(MaxNN)
<a name="12"/>
<a name="13"/>#
<a name="14"/># Component representing the slider area
<a name="15"/>#
<a name="16"/>class SliderArea(Component)
<a name="17"/>   public 
<a name="18"/>      inner_x, 
<a name="19"/>      inner_y,
<a name="20"/>      inner_w,
<a name="21"/>      inner_h, 
<a name="22"/>      slider_x,
<a name="23"/>      slider_y,
<a name="24"/>      slider_w,
<a name="25"/>      slider_h
<a name="26"/>
<a name="27"/>   public override display()
<a name="28"/>      Gui.style.draw_sunken_rectangle(self.cbwin, 
<a name="29"/>                                  self.inner_x, self.inner_y, 
<a name="30"/>                                  self.inner_w, self.inner_h,
<a name="31"/>                                  Gui.BORDER_WIDTH)
<a name="32"/>      self.cbwin.erase_area(self.slider_x, self.slider_y, self.slider_w, self.slider_h)
<a name="33"/>      Gui.style.draw_raised_rectangle(self.cbwin, 
<a name="34"/>                                  self.slider_x, self.slider_y, 
<a name="35"/>                                  self.slider_w, self.slider_h,
<a name="36"/>                                  Gui.BORDER_WIDTH)
<a name="37"/>   end
<a name="38"/>end
<a name="39"/>
<a name="40"/>
<a name="41"/>#
<a name="42"/># This component is a slider between two set values, with optional tick marks
<a name="43"/># and labels.
<a name="44"/>#
<a name="45"/># Example :-
<a name="46"/># ~
<a name="47"/>#   s := Slider()
<a name="48"/>#   s.set_pos("85%", "25%")      
<a name="49"/>#   s.set_size(, "40%") # Width defaults for a vertical slider
<a name="50"/>#   s.set_range(0,5)
<a name="51"/>#   s.set_value(2)
<a name="52"/>#   s.set_ticks(1)
<a name="53"/>#   s.set_labels(1)
<a name="54"/>#   s.set_snaps(1)
<a name="55"/>#   self.add(s)
<a name="56"/># ~
<a name="57"/>class Slider(Component, HasOrientation, HasUseWheel)
<a name="58"/>   public 
<a name="59"/>      value,                   
<a name="60"/>      old_value,
<a name="61"/>      slider_down,
<a name="62"/>      slider_down_offset,
<a name="63"/>      slider_area,
<a name="64"/>      slider_pos,
<a name="65"/>      slider_area_pos,
<a name="66"/>      slider_area_size,
<a name="67"/>      old_slider_area_pos,
<a name="68"/>      old_slider_area_size,
<a name="69"/>      discrete_vals,
<a name="70"/>      ticks,
<a name="71"/>      labels,
<a name="72"/>      snaps,
<a name="73"/>      ticks_pos,
<a name="74"/>      labels_pos,
<a name="75"/>      is_paging,
<a name="76"/>      increment_size,
<a name="77"/>      wheel_factor,
<a name="78"/>      hi,                                
<a name="79"/>      lo,
<a name="80"/>      repeat_ticker,
<a name="81"/>      repeat_delay
<a name="82"/>
<a name="83"/>
<a name="84"/>   # These values refer to a horizontal slider, the logic is backwards for a vertical one.
<a name="85"/>   public static const
<a name="86"/>      AREA_W, AREA_H, INNER_H, TICK_H, DEFAULT_WHEEL_FACTOR
<a name="87"/>
<a name="88"/>   private static init()
<a name="89"/>      AREA_W := env_scale("OI_SLIDER_AREA_W") | scale(31)
<a name="90"/>      AREA_H := env_scale("OI_SLIDER_AREA_H") | scale(19)
<a name="91"/>      INNER_H := env_scale("OI_SLIDER_INNER_H") | scale(4)
<a name="92"/>      TICK_H := env_scale("OI_SLIDER_TICK_H") | scale(10)
<a name="93"/>      DEFAULT_WHEEL_FACTOR := env_int("OI_SLIDER_DEFAULT_WHEEL_FACTOR", 1) | 1
<a name="94"/>   end
<a name="95"/>
<a name="96"/>   #
<a name="97"/>   # Configure so that on release after a drag, the value will snap to 
<a name="98"/>   # the nearest multiple of n.
<a name="99"/>   #
<a name="100"/>   public set_snaps(n)
<a name="101"/>      self.snaps := /n | need_numeric(n)
<a name="102"/>      link
<a name="103"/>   end
<a name="104"/>
<a name="105"/>   #
<a name="106"/>   # Draw ticks at the given interval
<a name="107"/>   #
<a name="108"/>   public set_ticks(n)
<a name="109"/>      self.ticks := /n | need_numeric(n)
<a name="110"/>      link
<a name="111"/>   end
<a name="112"/>
<a name="113"/>   #
<a name="114"/>   # Draw labels at the given interval
<a name="115"/>   #
<a name="116"/>   public set_labels(n)
<a name="117"/>      self.labels := /n | need_numeric(n)
<a name="118"/>      link
<a name="119"/>   end
<a name="120"/>
<a name="121"/>   #
<a name="122"/>   # Set the increment_size to increment on a click in the slider area; default is 1.
<a name="123"/>   # :Parameters :
<a name="124"/>   # :  `x` - The increment_size
<a name="125"/>   #
<a name="126"/>   public set_increment_size(x)
<a name="127"/>      self.increment_size := need_numeric(x)
<a name="128"/>      self.invalidate()
<a name="129"/>      link
<a name="130"/>   end
<a name="131"/>
<a name="132"/>   #
<a name="133"/>   # Get the increment_size
<a name="134"/>   #
<a name="135"/>   public get_increment_size()
<a name="136"/>      return self.increment_size
<a name="137"/>   end
<a name="138"/>
<a name="139"/>   #
<a name="140"/>   # Set the wheel factor, being the number of increments to
<a name="141"/>   # move on a wheel press; by default it is `DEFAULT_WHEEL_FACTOR`
<a name="142"/>   #
<a name="143"/>   public set_wheel_factor(n)
<a name="144"/>      self.wheel_factor := need_integer(n, 1)
<a name="145"/>      link
<a name="146"/>   end
<a name="147"/>
<a name="148"/>   #
<a name="149"/>   # Get the wheel_factor
<a name="150"/>   #
<a name="151"/>   public get_wheel_factor()
<a name="152"/>      return self.wheel_factor
<a name="153"/>   end
<a name="154"/>
<a name="155"/>   #
<a name="156"/>   # Set the current value
<a name="157"/>   #
<a name="158"/>   public set_value(x)
<a name="159"/>      x := need_numeric(x)
<a name="160"/>      if value ~=== x then {
<a name="161"/>         if is_live() then {
<a name="162"/>            move_value(x)
<a name="163"/>            set_pos_from_value()
<a name="164"/>         } else 
<a name="165"/>            self.value := x
<a name="166"/>      }
<a name="167"/>      link
<a name="168"/>   end
<a name="169"/>
<a name="170"/>   private move_value(x)
<a name="171"/>      self.value := restrict(x, self.lo, self.hi)
<a name="172"/>   end
<a name="173"/>
<a name="174"/>   #
<a name="175"/>   # Get the value.
<a name="176"/>   # :Returns :
<a name="177"/>   # :  The value
<a name="178"/>   #
<a name="179"/>   public get_value()
<a name="180"/>      return self.value
<a name="181"/>   end
<a name="182"/>
<a name="183"/>   private set_pos_from_value()
<a name="184"/>      if self.hi ~= self.lo then
<a name="185"/>         move_slider_pos(self.slider_area_pos + integer(((self.value - self.lo) * 
<a name="186"/>                                                         self.slider_area_size / (self.hi - self.lo))))
<a name="187"/>      else
<a name="188"/>         move_slider_pos(self.slider_area_pos)
<a name="189"/>   end
<a name="190"/>
<a name="191"/>   private set_value_from_pos()
<a name="192"/>      if self.slider_area_size ~= 0 then {
<a name="193"/>         # For discrete vals, an adjustment is made so that, for example
<a name="194"/>         # the ranges where the cursor set the position might be
<a name="195"/>         # 0     1     2     3
<a name="196"/>         # 0001111112222223333
<a name="197"/>         # Without this adjustment 0 would only be in the leftmost position, which for
<a name="198"/>         # small ranges is unattractive.  For non-discrete ranges this behaviour is
<a name="199"/>         # not appropriate.
<a name="200"/>         if \self.discrete_vals then
<a name="201"/>            move_value(self.lo + ((self.slider_area_size / 2) + (self.hi - self.lo) * 
<a name="202"/>                                  (self.slider_pos - self.slider_area_pos)) / self.slider_area_size)
<a name="203"/>         else
<a name="204"/>            move_value(self.lo + ((self.hi - self.lo) * (self.slider_pos - self.slider_area_pos)) / self.slider_area_size)
<a name="205"/>      } else
<a name="206"/>         move_value(self.lo)
<a name="207"/>   end
<a name="208"/>
<a name="209"/>   private move_slider_pos(x)
<a name="210"/>      x &lt;:= self.slider_area_pos
<a name="211"/>      x &gt;:= self.slider_area_pos + self.slider_area_size
<a name="212"/>      if self.slider_pos ~===:= x then {
<a name="213"/>         if /self.is_horizontal_flag then
<a name="214"/>            self.slider_area.slider_y := self.slider_pos - AREA_W / 2
<a name="215"/>         else
<a name="216"/>            self.slider_area.slider_x := self.slider_pos - AREA_W / 2
<a name="217"/>         self.slider_area.invalidate()
<a name="218"/>      }
<a name="219"/>   end
<a name="220"/>
<a name="221"/>   #
<a name="222"/>   # Set the range of the slider.  The values may
<a name="223"/>   # be integer or real.
<a name="224"/>   #
<a name="225"/>   # :Parameters :
<a name="226"/>   # :  `lo` - The lower bound
<a name="227"/>   # :  `hi` - The upper bound
<a name="228"/>   #
<a name="229"/>   public set_range(lo, hi)
<a name="230"/>      lo := need_numeric(lo)
<a name="231"/>      hi := need_numeric(hi)
<a name="232"/>      if self.lo ~=== lo | self.hi ~=== hi then {
<a name="233"/>         if lo &gt;= hi then
<a name="234"/>            runerr("Invalid range")
<a name="235"/>         self.lo := lo
<a name="236"/>         self.hi := hi
<a name="237"/>         discrete_vals := Yes{ type(self.hi) == type(self.lo) == "integer" }
<a name="238"/>         reconfigure()
<a name="239"/>      }
<a name="240"/>      link
<a name="241"/>   end
<a name="242"/>
<a name="243"/>   public handle_press(e)
<a name="244"/>      local k
<a name="245"/>      start_handle(e)
<a name="246"/>      if (self.slider_area.slider_x &lt;= e.x &lt; self.slider_area.slider_x + self.slider_area.slider_w) &amp; 
<a name="247"/>         (self.slider_area.slider_y  &lt;= e.y &lt; self.slider_area.slider_y + self.slider_area.slider_h) then {
<a name="248"/>         #
<a name="249"/>         # Click on slider; set flag and save offset between top of slider and pointer position
<a name="250"/>         #
<a name="251"/>         self.slider_down := &amp;yes
<a name="252"/>         if /self.is_horizontal_flag then
<a name="253"/>            self.slider_down_offset := e.y - self.slider_pos
<a name="254"/>         else
<a name="255"/>            self.slider_down_offset := e.x - self.slider_pos
<a name="256"/>      } else if (if /is_horizontal_flag then slider_area.y  &lt;= e.y &lt; slider_area.slider_y
<a name="257"/>                 else slider_area.x &lt;= e.x &lt; slider_area.slider_x) then {
<a name="258"/>         if \e.shift | e.code === Mouse.MIDDLE_PRESS  then {
<a name="259"/>            self.slider_down := &amp;yes
<a name="260"/>            slider_down_offset := 0
<a name="261"/>            move_slider_pos(if /self.is_horizontal_flag then e.y else e.x)
<a name="262"/>            set_value_from_pos()
<a name="263"/>         } else {
<a name="264"/>            k := if e.code === Mouse.RIGHT_PRESS then 1 else -1
<a name="265"/>            move_value(small_jump(k))
<a name="266"/>            set_pos_from_value()
<a name="267"/>            start_paging(k)
<a name="268"/>         }
<a name="269"/>      } else if (if /is_horizontal_flag then slider_area.slider_y + slider_area.slider_h &lt;= e.y &lt; slider_area.y + slider_area.h
<a name="270"/>                 else slider_area.slider_x + slider_area.slider_w &lt;= e.x &lt; slider_area.x + slider_area.w) then {
<a name="271"/>         if \e.shift | e.code === Mouse.MIDDLE_PRESS then {
<a name="272"/>            self.slider_down := &amp;yes
<a name="273"/>            slider_down_offset := 0
<a name="274"/>            move_slider_pos(if /self.is_horizontal_flag then e.y else e.x)
<a name="275"/>            set_value_from_pos()
<a name="276"/>         } else {
<a name="277"/>            k := if e.code === Mouse.RIGHT_PRESS then -1 else 1
<a name="278"/>            move_value(small_jump(k))
<a name="279"/>            set_pos_from_value()
<a name="280"/>            start_paging(k)
<a name="281"/>         }
<a name="282"/>      }
<a name="283"/>      end_handle(e)
<a name="284"/>   end
<a name="285"/>
<a name="286"/>   public small_jump(n)
<a name="287"/>      return value + n * increment_size
<a name="288"/>   end
<a name="289"/>
<a name="290"/>   public handle_release(e)
<a name="291"/>      local n
<a name="292"/>      start_handle(e)
<a name="293"/>      if \self.slider_down then {
<a name="294"/>         #
<a name="295"/>         # Released; clear flag
<a name="296"/>         #
<a name="297"/>         self.slider_down := &amp;no
<a name="298"/>         if \self.snaps then {
<a name="299"/>            n := value + snaps / 2
<a name="300"/>            move_value(n - (n % snaps))
<a name="301"/>            set_pos_from_value()
<a name="302"/>         }
<a name="303"/>      } 
<a name="304"/>      stop_paging()
<a name="305"/>      end_handle(e)
<a name="306"/>   end
<a name="307"/>
<a name="308"/>   public handle_interrupted()
<a name="309"/>      if slider_area.is_held(Mouse.LEFT_PRESS) then
<a name="310"/>         handle_release()
<a name="311"/>   end
<a name="312"/>
<a name="313"/>   public handle_key_home(e)
<a name="314"/>      start_handle(e)
<a name="315"/>      move_value(self.lo)
<a name="316"/>      set_pos_from_value()
<a name="317"/>      end_handle(e)
<a name="318"/>   end
<a name="319"/>
<a name="320"/>   public handle_key_end(e)
<a name="321"/>      start_handle(e)
<a name="322"/>      move_value(self.hi)
<a name="323"/>      set_pos_from_value()
<a name="324"/>      end_handle(e)
<a name="325"/>   end
<a name="326"/>
<a name="327"/>   public handle_key_right(e)
<a name="328"/>      start_handle(e)
<a name="329"/>      move_value(small_jump(1))
<a name="330"/>      set_pos_from_value()
<a name="331"/>      end_handle(e)
<a name="332"/>   end
<a name="333"/>
<a name="334"/>   public handle_key_left(e)
<a name="335"/>      start_handle(e)
<a name="336"/>      move_value(small_jump(-1))
<a name="337"/>      set_pos_from_value()
<a name="338"/>      end_handle(e)
<a name="339"/>   end
<a name="340"/>
<a name="341"/>   public handle_key(e)
<a name="342"/>      case e.code of {
<a name="343"/>         Key.HOME : handle_key_home(e)
<a name="344"/>         Key.END : handle_key_end(e)
<a name="345"/>         Key.RIGHT | Key.DOWN : handle_key_right(e)
<a name="346"/>         Key.LEFT | Key.UP : handle_key_left(e)
<a name="347"/>      }
<a name="348"/>   end
<a name="349"/>
<a name="350"/>   private repeat_tick()
<a name="351"/>      repeat {
<a name="352"/>         if Prog.get_runtime_millis() &gt; self.repeat_delay then {
<a name="353"/>            start_handle()
<a name="354"/>            move_value(small_jump(is_paging))
<a name="355"/>            set_pos_from_value()
<a name="356"/>            end_handle()
<a name="357"/>         }
<a name="358"/>         repeat_ticker.sleep(Gui.REPEAT_RATE)
<a name="359"/>      }
<a name="360"/>   end
<a name="361"/>
<a name="362"/>   public start_paging(n)
<a name="363"/>      self.is_paging := n
<a name="364"/>      self.repeat_delay := Prog.get_runtime_millis() + Gui.REPEAT_DELAY
<a name="365"/>      repeat_ticker.start()
<a name="366"/>   end
<a name="367"/>
<a name="368"/>   public stop_paging()
<a name="369"/>      self.is_paging := &amp;null
<a name="370"/>      repeat_ticker.stop()
<a name="371"/>   end
<a name="372"/>
<a name="373"/>   public handle_drag(e)
<a name="374"/>      \self.slider_down | fail
<a name="375"/>
<a name="376"/>      start_handle(e)
<a name="377"/>      #
<a name="378"/>      # Slider dragged; compute new position
<a name="379"/>      #
<a name="380"/>      if /self.is_horizontal_flag then
<a name="381"/>         move_slider_pos(e.y - self.slider_down_offset)
<a name="382"/>      else
<a name="383"/>         move_slider_pos(e.x - self.slider_down_offset)
<a name="384"/>      set_value_from_pos()
<a name="385"/>      end_handle(e)
<a name="386"/>   end
<a name="387"/>
<a name="388"/>   public override handle_wheel_up(e)
<a name="389"/>      /self.slider_down | fail
<a name="390"/>      start_handle(e)
<a name="391"/>      move_value(small_jump(-wheel_factor))
<a name="392"/>      set_pos_from_value()
<a name="393"/>      end_handle(e)
<a name="394"/>   end
<a name="395"/>
<a name="396"/>   public override handle_wheel_down(e)
<a name="397"/>      /self.slider_down | fail
<a name="398"/>      start_handle(e)
<a name="399"/>      move_value(small_jump(wheel_factor))
<a name="400"/>      set_pos_from_value()
<a name="401"/>      end_handle(e)
<a name="402"/>   end
<a name="403"/>
<a name="404"/>   public start_handle(ev)
<a name="405"/>      old_value := value
<a name="406"/>   end
<a name="407"/>
<a name="408"/>   public end_handle(ev)
<a name="409"/>      if old_value ~=== value then
<a name="410"/>         fire(Event.VALUE_CHANGED, ev)
<a name="411"/>   end
<a name="412"/>
<a name="413"/>   private reconfigure()
<a name="414"/>      # Don't do anything if we haven't been positioned yet.
<a name="415"/>      is_live() | fail
<a name="416"/>      # Ensure value in lo..hi range.
<a name="417"/>      move_value(self.value)
<a name="418"/>      set_pos_from_value()
<a name="419"/>      invalidate()
<a name="420"/>   end
<a name="421"/>
<a name="422"/>   public override get_default_width()
<a name="423"/>      local w
<a name="424"/>      if /self.is_horizontal_flag then {
<a name="425"/>         w := AREA_H + border.get_total_width()
<a name="426"/>         if \self.labels then
<a name="427"/>            w +:= MaxNN{ cbwin.text_width(hi | lo) } + Gui.X_INSET
<a name="428"/>         if \self.ticks then
<a name="429"/>            w +:= TICK_H + Gui.X_INSET
<a name="430"/>         return w
<a name="431"/>      }
<a name="432"/>   end
<a name="433"/>
<a name="434"/>   public override get_default_height()
<a name="435"/>      local h
<a name="436"/>      if \self.is_horizontal_flag then {
<a name="437"/>         h := AREA_H + border.get_total_height()
<a name="438"/>         if \self.labels then
<a name="439"/>            h +:= self.cbwin.get_font_height() + Gui.Y_INSET
<a name="440"/>         if \self.ticks then
<a name="441"/>            h +:= TICK_H + Gui.Y_INSET
<a name="442"/>         return h
<a name="443"/>      }
<a name="444"/>   end
<a name="445"/>
<a name="446"/>   public override layout()
<a name="447"/>      self.labels_pos := self.ticks_pos := &amp;null
<a name="448"/>      if /self.is_horizontal_flag then {
<a name="449"/>         if \self.labels then
<a name="450"/>            labels_pos := self.x + border.get_l_inset() + AREA_H + Gui.X_INSET
<a name="451"/>         if \self.ticks then {
<a name="452"/>            ticks_pos := self.x + border.get_l_inset() + AREA_H + Gui.X_INSET
<a name="453"/>            \labels_pos +:= TICK_H + Gui.X_INSET
<a name="454"/>         }
<a name="455"/>         slider_area.x := self.x + border.get_l_inset()
<a name="456"/>         slider_area.y := self.y + border.get_t_inset()
<a name="457"/>         slider_area.w := AREA_H
<a name="458"/>         slider_area.h := self.h - border.get_total_height()
<a name="459"/>         slider_area.inner_x := slider_area.x + slider_area.w / 2 - INNER_H  / 2
<a name="460"/>         slider_area.inner_y := slider_area.y + AREA_W / 2
<a name="461"/>         slider_area.inner_w := INNER_H
<a name="462"/>         slider_area.inner_h := slider_area.h - AREA_W
<a name="463"/>         slider_area.slider_x := slider_area.x
<a name="464"/>         slider_area.slider_h := AREA_W
<a name="465"/>         slider_area.slider_w := AREA_H
<a name="466"/>         slider_area_pos := slider_area.inner_y
<a name="467"/>         slider_area_size := slider_area.inner_h
<a name="468"/>      } else {
<a name="469"/>         if \self.labels then
<a name="470"/>            labels_pos := self.y + border.get_t_inset() + AREA_H + 
<a name="471"/>                              Gui.Y_INSET + self.cbwin.get_font_height() / 2
<a name="472"/>         if \self.ticks then {
<a name="473"/>            ticks_pos := self.y + border.get_t_inset() + AREA_H + Gui.Y_INSET
<a name="474"/>            \labels_pos +:= TICK_H + Gui.Y_INSET
<a name="475"/>         }
<a name="476"/>         slider_area.x := self.x + border.get_l_inset()
<a name="477"/>         slider_area.y := self.y + border.get_t_inset()
<a name="478"/>         slider_area.w := self.w - border.get_total_width()
<a name="479"/>         slider_area.h := AREA_H
<a name="480"/>         slider_area.inner_x := slider_area.x + AREA_W  / 2
<a name="481"/>         slider_area.inner_y := slider_area.y + slider_area.h / 2 - INNER_H  / 2
<a name="482"/>         slider_area.inner_h := INNER_H
<a name="483"/>         slider_area.inner_w := slider_area.w - AREA_W
<a name="484"/>         slider_area.slider_y := slider_area.y
<a name="485"/>         slider_area.slider_w := AREA_W
<a name="486"/>         slider_area.slider_h := AREA_H
<a name="487"/>         slider_area_pos := slider_area.inner_x
<a name="488"/>         slider_area_size := slider_area.inner_w
<a name="489"/>      }
<a name="490"/>
<a name="491"/>      # This test avoids a cosmetic problem whereby the slider would
<a name="492"/>      # move slightly as its position is recalculated from the value.
<a name="493"/>      # There is no need for this calculation unless the slider area
<a name="494"/>      # has changed size/pos.
<a name="495"/>      #
<a name="496"/>      if old_slider_area_pos ~=== slider_area_pos |
<a name="497"/>         old_slider_area_size ~=== slider_area_size then
<a name="498"/>      {
<a name="499"/>         set_pos_from_value()
<a name="500"/>         old_slider_area_pos := slider_area_pos
<a name="501"/>         old_slider_area_size := slider_area_size
<a name="502"/>      }
<a name="503"/>   end
<a name="504"/>
<a name="505"/>   public override shift(dx, dy)
<a name="506"/>      Component.shift(dx, dy)
<a name="507"/>      if /self.is_horizontal_flag then {
<a name="508"/>         (\labels_pos) +:= dx
<a name="509"/>         (\ticks_pos) +:= dx
<a name="510"/>         slider_area_pos +:= dy
<a name="511"/>         old_slider_area_pos +:= dy
<a name="512"/>         slider_pos +:= dy
<a name="513"/>      } else {
<a name="514"/>         (\labels_pos) +:= dy
<a name="515"/>         (\ticks_pos) +:= dy
<a name="516"/>         slider_area_pos +:= dx
<a name="517"/>         old_slider_area_pos +:= dx
<a name="518"/>         slider_pos +:= dx
<a name="519"/>      }
<a name="520"/>      slider_area.inner_x +:= dx
<a name="521"/>      slider_area.inner_y +:= dy
<a name="522"/>      slider_area.slider_x +:= dx
<a name="523"/>      slider_area.slider_y +:= dy
<a name="524"/>   end
<a name="525"/>
<a name="526"/>   public draw_ticks()
<a name="527"/>      local i, xp, yp
<a name="528"/>      if /self.is_horizontal_flag then {
<a name="529"/>         i := self.lo
<a name="530"/>         while i &lt;= self.hi do {
<a name="531"/>            yp := self.slider_area_pos + integer(((i - self.lo) * (self.slider_area_size) / (self.hi - self.lo)))
<a name="532"/>            self.cbwin.fill_rectangle(ticks_pos, yp, TICK_H, 1)
<a name="533"/>            i +:= ticks
<a name="534"/>         }
<a name="535"/>      } else {
<a name="536"/>         i := self.lo
<a name="537"/>         while i &lt;= self.hi do {
<a name="538"/>            xp := self.slider_area_pos + integer(((i - self.lo) * (self.slider_area_size) / (self.hi - self.lo)))
<a name="539"/>            self.cbwin.fill_rectangle(xp, ticks_pos, 1, TICK_H)
<a name="540"/>            i +:= ticks
<a name="541"/>         }
<a name="542"/>      }
<a name="543"/>   end
<a name="544"/>
<a name="545"/>   public draw_labels()
<a name="546"/>      local i, xp, yp, fh
<a name="547"/>      fh := self.cbwin.get_font_height()
<a name="548"/>      if /self.is_horizontal_flag then {
<a name="549"/>         i := self.lo
<a name="550"/>         while i &lt;= self.hi do {
<a name="551"/>            yp := self.slider_area_pos + integer(((i - self.lo) * (self.slider_area_size) / (self.hi - self.lo)))
<a name="552"/>            cbwin.draw_string(labels_pos, yp - fh / 2 + cbwin.get_font_ascent(), i)
<a name="553"/>            i +:= labels
<a name="554"/>         }
<a name="555"/>      } else {
<a name="556"/>         i := self.lo
<a name="557"/>         while i &lt;= self.hi do {
<a name="558"/>            xp := self.slider_area_pos + integer(((i - self.lo) * (self.slider_area_size) / (self.hi - self.lo)))
<a name="559"/>            cbwin.draw_string(xp - self.cbwin.text_width(i) / 2, labels_pos - fh / 2 + cbwin.get_font_ascent(), i)
<a name="560"/>            i +:= labels
<a name="561"/>         }
<a name="562"/>      }
<a name="563"/>   end
<a name="564"/>
<a name="565"/>   public override initially()
<a name="566"/>      \self.value | runerr("Value not set")
<a name="567"/>      if /(self.lo | self.hi) then
<a name="568"/>         runerr("Range not set")
<a name="569"/>      # Ensure value in lo..hi range.
<a name="570"/>      move_value(self.value)
<a name="571"/>      Component.initially()
<a name="572"/>   end
<a name="573"/>
<a name="574"/>   public override display()
<a name="575"/>      border.draw_rect(self.cbwin, self)
<a name="576"/>
<a name="577"/>      if \self.labels then
<a name="578"/>         draw_labels()
<a name="579"/>
<a name="580"/>      if \self.ticks then
<a name="581"/>         draw_ticks()
<a name="582"/>
<a name="583"/>      display_children()
<a name="584"/>
<a name="585"/>      if should_draw_focus() then
<a name="586"/>         border.draw_focus_rect(self.cbwin, self)
<a name="587"/>   end
<a name="588"/>
<a name="589"/>   public override finally()
<a name="590"/>      repeat_ticker.stop()
<a name="591"/>      old_slider_area_pos := old_slider_area_size := &amp;null
<a name="592"/>      Component.finally()
<a name="593"/>   end
<a name="594"/>
<a name="595"/>   public override keeps(e)
<a name="596"/>      succeed member(if /self.is_horizontal_flag then Key.CURSOR_V else Key.CURSOR_H, e.code)
<a name="597"/>   end
<a name="598"/>
<a name="599"/>   public override new()
<a name="600"/>      Component.new()
<a name="601"/>      repeat_ticker := Dispatcher.new_task{repeat_tick()}
<a name="602"/>      slider_area := SliderArea()
<a name="603"/>      accepts_focus_flag := &amp;yes
<a name="604"/>      increment_size := 1
<a name="605"/>      wheel_factor := DEFAULT_WHEEL_FACTOR
<a name="606"/>      set_use_wheel(&amp;yes)
<a name="607"/>      set_border(NullBorder())
<a name="608"/>      add(slider_area)
<a name="609"/>      slider_area.
<a name="610"/>         connect(handle_press, Event.MOUSE_LEFT_PRESS).
<a name="611"/>         connect(handle_drag, Event.MOUSE_LEFT_DRAG).
<a name="612"/>         connect(handle_release, Event.MOUSE_LEFT_RELEASE).
<a name="613"/>         connect(handle_press, Event.MOUSE_RIGHT_PRESS).
<a name="614"/>         connect(handle_drag, Event.MOUSE_RIGHT_DRAG).
<a name="615"/>         connect(handle_release, Event.MOUSE_RIGHT_RELEASE).
<a name="616"/>         connect(handle_press, Event.MOUSE_MIDDLE_PRESS).
<a name="617"/>         connect(handle_drag, Event.MOUSE_MIDDLE_DRAG).
<a name="618"/>         connect(handle_release, Event.MOUSE_MIDDLE_RELEASE)
<a name="619"/>      connect(handle_key, Event.KEY_PRESS)
<a name="620"/>      connect(handle_interrupted, Event.INTERRUPTED)
<a name="621"/>      return
<a name="622"/>   end
<a name="623"/>end
</pre></body></html>
