#
# Support procedures for ieval.
#

package ipl.ieval

import io, lang, ipl.colmize, parser, util, ipl.pdco, ipl.sort

procedure show_env(env)
   local e
   every e := !sort(env) do
      write(left(e[1], 16), to_string(e[2]))
end

procedure list_syms(imports)
   local s, e
   s := set()
   every e := lang.Prog.get_global_names() do
      if e ? ((not upto('.')) | (=!imports & ="." & (not upto('.')))) then
         insert(s, e)
   every write(colmize(isort(s, map), LineEditorStream.get_console_size()[1]))
end

procedure flags_string(f)
   local s
   s := ""
   if iand(f, lang.Class.Method) ~= 0 then
      s ||:= "Method "
   if iand(f, lang.Class.Private) ~= 0 then
      s ||:= "Private "
   if iand(f, lang.Class.Public) ~= 0 then
      s ||:= "Public "
   if iand(f, lang.Class.Protected) ~= 0 then
      s ||:= "Protected "
   if iand(f, lang.Class.Package) ~= 0 then
      s ||:= "Package "
   if iand(f, lang.Class.Static) ~= 0 then
      s ||:= "Static "
   if iand(f, lang.Class.Const) ~= 0 then
      s ||:= "Const "
   if iand(f, lang.Class.Readable) ~= 0 then
      s ||:= "Readable "
   if iand(f, lang.Class.Defer) ~= 0 then
      s ||:= "Defer "
   if iand(f, lang.Class.Final) ~= 0 then
      s ||:= "Final "
   if iand(f, lang.Class.Special) ~= 0 then
      s ||:= "Special "
   s[-1] := ""
   return s
end

procedure supers_string(c)
   local s
   s := ""
   every s ||:= lang.Class.get_name(lang.Class.get_supers(c)) || ", "
   s[-2:0] := ""
   return s
end

procedure implements_string(c)
   local s
   s := ""
   every s ||:= lang.Class.get_name(lang.Class.get_implemented_classes(c)) || ", "
   s[-2:0] := ""
   return s
end

procedure fields_string(c)
   local s
   s := ""
   every s ||:= Constructor.get_field_names(c) || ", "
   s[-2:0] := ""
   return s
end

procedure locn_string(l)
   return "at line " || l.line || " in " || l.file
end

procedure kind_string(f)
   return case f of {
      Proc.Procedure: "Procedure"
      Proc.Function: "Function"
      Proc.Keyword: "Keyword"
      Proc.Operator: "Operator"
      Proc.Internal: "Internal"
   }
end

procedure var_string(f)
   return case f of {
      Proc.Argument: "Argument"
      Proc.Dynamic: "Dynamic"
      Proc.Static: "Static"
   }
end

procedure args_string(f)
   local s
   s := Proc.get_n_arguments(f)
   if Proc.has_varargs(f) then
      s ||:= "[]"
   return s
end

procedure print_table(t)
   local w, widths, col, row
   widths := []
   every col := 1 to *t[1] do {
      w := 0
      every w <:= *(!t)[col]
      put(widths, w)
   }
   every row := !t do {
      every col := 1 to *t[1] do
         every writes(left(row[col], 4 + widths[col]))
      write()
   }
end

procedure dir(c)
   local f, t
   case type(c) of {
      "cast"|"class": {
         write(if iand(lang.Class.get_class_flags(c), lang.Class.Final) ~= 0 then "final class " else "class ",
               lang.Class.get_name(c), "(", supers_string(c), ")")
         write("   ", locn_string(lang.Class.get_location(c))) 
         write("   implements ", implements_string(c))
         t := []
         every f := !isort(ipl.pdco.List{lang.Class.get_field_names(c)}, map) do
            put(t, [f, 
                    lang.Class.get_name(lang.Class.get_field_defining_class(c, f)), 
                    flags_string(lang.Class.get_field_flags(c, f))])
         print_table(t)
      }
      "procedure"|"methp": {
         write(kind_string(Proc.get_kind(c)), " ", Proc.get_name(c), "(", args_string(c), ")")
         write("   ", locn_string(Proc.get_location(c))) 
         write("   method of ", lang.Class.get_name(Proc.get_defining_class(c)))
         t := []
         every f := Proc.get_local_names(c) do
            put(t, [f,
                    var_string(Proc.get_local_kind(c, f))])
         print_table(t)
      }
      "constructor": {
         write("constructor ",
               Constructor.get_name(c), "(", fields_string(c), ")")
         write("   ", locn_string(Constructor.get_location(c))) 
      }

      default: {
         to_stdout(c, 3)
         write()
      }
   }

end

procedure main_impl(imports, files, opts)
   local env, s, t, eval, prompt, f, in, quiet_flag, par, n, tr_flag, tv, last_runerr, ee

   par := Parser()
   env := table()
   ee := DefaultEvaluatorEnv(env)
   if \opts["w"] then
      ee.set_write_globals(&yes)
   eval := Evaluator().
      set_env(ee).
      set_imports(imports)

   env["env"] := create show_env(env)
   env["tt"] := create tr_flag := toggle_flag(tr_flag)
   env["tb"] := create Coexpression.traceback(\\last_runerr, &yes)
   env["q"] := create quiet_flag := toggle_flag(quiet_flag)
   env["ls"] := create list_syms(imports)
   env["dir"] := dir

   every f := !files do {
      s := Files.file_to_string(f) | stop("Couldn't load ", f, ": ", &why)
      n := par.parse_expression(s) | stop("Couldn't parse ", f,  ": ", &why)
      eval.set_node(n) | stop("Couldn't parse ", f,  ": ", &why) 
      eval.eval()
   }

   s := ""
   prompt := "> "
   in := LineEditorStream()
   repeat {
      in.set_prompt(prompt)
      t := in.read_line() | stop("Failed to read file: ", &why)
      if /t then break
      s ||:= t
      if s[-1] == "\\" then {
         prompt := ">> "
         next
      }
      if n := par.parse_expression(s, "UTF-8") then {
         if \\tr_flag then {
            to_stdout(n, 3)
            write()
            tv := -1
         } else
            tv := 0
         if eval.set_node(n) then {
            if \\quiet_flag then
               save_var{{ &trace := tv ; Safe{eval.eval()}}, &trace}
            else
               every to_stdout(save_var{{ &trace := tv ; Safe{eval.eval()}}, &trace}, 3) do 
                  write()
            if &errortext then {
               if &errornumber then
                  write("Runtime error ", &errornumber, ": ", &errortext)
               else
                  write("Runtime error: ", &errortext)
               write("offending value: ", image(&errorvalue))
               last_runerr := &errorcoexpr
               errorclear()
            }
         } else
            write("Couldn't parse: ", &why)
      } else
         write("Couldn't parse: ", &why)
      prompt := "> "
      s := ""
   }
   write("Ciao")
end
