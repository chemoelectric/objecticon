import 
   gui,
   io,
   posix,
   graphics,
   net,
   lang,
   util,
   xdg,
   ipl.options,
   ipl.sort,
   ipl.pdco,
   ipl.wildcard,
   ipl.lists,
   ipl.functional,
   ipl.filegui,
   ipl.childwait,
   ipl.vt,
   ipl.columnize,
   ipl.strings,
   ipl.browser

global opts, glob_cmds

$ifdef _PNG
$load HOURGLASS "rpp.HOURGLASS_24.png"
$load KEYBOARD "rpp.KEYBOARD_24.png"
$load HELP "rpp.HELP_64.png"
$load ABOUT "rpp.ABOUT_64.png"
$else
$load HOURGLASS "rpp.HOURGLASS_24.gif"
$load KEYBOARD "rpp.KEYBOARD_24.gif"
$load HELP "rpp.HELP_64.gif"
$load ABOUT "rpp.ABOUT_64.gif"
$endif
$load EXIT "rpp.EXIT_24.gif"
$load FLOWTERM_LOGO "rpp.FLOWTERM_LOGO.png"

abstract class Runner()
   public abstract get_command()
end

class ImmediateRunner(Runner)
   public const
      cmd

   public get_command()
      return cmd
   end

   public new(cmd)
      self.cmd := cmd
      return
   end
end

abstract class ExternalRunner(Runner)
   public abstract get_working_dir()
end

class LaunchRunner(ExternalRunner)
   public const
      cmd,
      wd

   public get_working_dir()
      return \wd
   end

   public get_command()
      return cmd
   end

   public new(cmd, wd)
      self.cmd := cmd
      self.wd := wd
      return
   end
end

class DesktopRunner(ExternalRunner)
   public const
      # The DesktopEntry giving the command and other parameters.
      desktop_entry,
      # The string to substitute to create a command to run
      subst,
      # The url itself (a URL object).
      url

   public get_working_dir()
      return \desktop_entry.path
   end

   public get_command()
      local line
      if url.scheme == u"file" then
         line := integer(url.extract_cgi_parameters()["line"][1])
      return desktop_entry.subst_file(Format.shell_escape(subst), line)
   end

   public new(desktop_entry, url, subst)
      self.desktop_entry := desktop_entry
      self.url := url
      self.subst := subst
      return
   end
end

class TerminalMenu(DynamicMenu)
   public populate()
      move_all(parent_component.parent_dialog.tabs.which_one.create_context_menu())
   end
end

class ColumnsMenu(DynamicMenu)
   public populate()
      move_all(parent_component.parent_dialog.tabs.which_one.create_columns_context_menu())
   end
end

class FlowTermDialog(Dialog)
   private readable
      favourite_dirs,
      tabs,
      file_dialog

   public
      last_log_file

   private on_quit(ev)
      dispose()
   end

   public do_tab_cmd(l)
      local s, t, cmd
      # l is a list of strings (not ucs).
      t := tabs.which_one
      while s := get(l) do {
         s ? if =":" then {
            cmd := tab(0)
            \t | return error("Command before tab directory: " || cmd)
            t.do_tab_cmd(cmd) | fail
         } else {
            done_tab_cmds(t)
            t := Terminal(if *s > 0 then s else &null,, tabs.which_one)
         }
      }
      done_tab_cmds(t)
      return self
   end

   private done_tab_cmds(t)
      local a
      # Add t if it's not already added in the TabSet
      if /(\t).parent then {
         a := if \t.adjacent_flag then tabs.which_one
         add_tab(t, a)
         if \t.select_flag | /tabs.which_one then
            tabs.set_which_one(t)
      }
   end

   private add_tab(t, adjacent)
      local i
      t.set_is_hidden(&yes)
      i := tabs.get_index(\adjacent) + 1
      tabs.add(t, i)
      if is_live() then
         tabs.do_layout().invalidate()
      return t
   end

   public new_tab(sel, dir, other, adjacent)
      local t
      t := add_tab(Terminal(dir, other, tabs.which_one), adjacent)
      if \sel then
         tabs.set_which_one(t)
      return t
   end

   private on_new_tab(ev)
      new_tab(&yes)
   end

   private on_xdg_refresh(ev)
      Xdg.refresh()
      tabs.which_one.info_msg("XDG database reloaded")
   end

   private on_html_click(url)
      tabs.which_one.open_link(url)
   end

   private show_html(src)
      local d
      d := HTMLMessageDialog().
         set_label("FlowTerm")
      d.browser.
         set_accepts_focus(&no).
         set_border(NullBorder()).
         set_page(src).
         set_size(scale(550), scale(350)).
         connect(on_html_click, SimpleBrowser.LINK_LEFT_CLICKED)
      d.show_modal(self)
   end

   private on_about(ev)
      show_html("<html><h1><img src=img:rpp.ABOUT_64 width=64 height=64 align=absmiddle/>&nbsp;About FlowTerm</h1>_
<h2>Author</h2>Robert Parlett_
<h2>Contact</h2><a href=mailto:r.parlett@gmail.com</a>r.parlett@gmail.com</a>_
<h2>Version</h2>" || &version ||
"</html>")
   end

   private on_help(ev)
      show_html("<html><h1><img src=img:rpp.HELP_64 width=64 height=64 align=absmiddle/>&nbsp;FlowTerm Help</h1>_
FlowTerm is a terminal emulator which uses web-like hyperlinks, as well as some elements of a file explorer._
<p>_
It requires an additional set of programs, <i>FlowTerm extras</i>, in order to be fully functional._
<p>_
Simple command line option help can be obtained by running :-_
<pre>    flowterm -help</pre>_
<p>_
Full documentation can be found at <a href=\"http://objecticon.sourceforge.net/FlowTerm.html\">this page</a>._
<p>_
The FlowTerm extras can be downloaded <a href=\"https://sourceforge.net/projects/objecticon/files/misc/flowterm-extras.tar.gz/download\">here</a>._
</html>")
   end

   private on_favourite_dirs(ev)
      local d
      d := FavouriteDirectoriesDialog()
      d.show_modal(self)
      \d.okay | fail
      every (!tabs.children).refresh_favourite_dirs()
   end

   public component_setup()
      local i, t
      t := \tabs.which_one | tabs.children[1]
      if i := \opts["width"] then {
         i > 0 | stop("Invalid -width: integer > 0 expected")
         t.output.
            set_width().
            set_vt_width(i)
      } else
         set_width(scale(1200))

      if i := \opts["height"] then {
         i > 0 | stop("Invalid -height: integer > 0 expected")
         t.output.
            set_height().
            set_vt_height(i)
      } else
         set_height(scale(850))
   end

   private on_tabs_rpress(e)
      local t, m, pm
      t := tabs.which_tab(e) | fail
      m := Menu().
         add(TextMenuItem().
             set_label("New").
             connect(create new_tab(&yes,,, t), Event.ACTION)).
         add(TextMenuItem().
             set_label("Close").
             connect(create t.close_tab(), Event.ACTION)).
         add(TextMenuItem().
             set_label("Clone").
             connect(create t.clone_tab(), Event.ACTION))
      pm := PopupMenu().
         connect(create tabs.set_which_highlight(), Event.POPUP_CLOSED)
      tabs.set_which_highlight(t)
      pm.popup(self, m, e.x, e.y)
   end

   private on_tabs_changed(e)
      tabs.which_one.tab_active()
   end

   public new()
      local quit_menu_item, menu_bar, file_menu, terminal_menu, columns_menu, 
         new_tab_item, favourite_dirs_item, xdg_refresh_item,
         help_menu, about_item, help_item
      Dialog.new()
      set_resize(&yes)
      file_dialog := FileDialog().set_remember_size(&yes)
      new_tab_item := TextMenuItem().
         connect(on_new_tab, Event.ACTION).
         set_label("New Tab")
      favourite_dirs_item := TextMenuItem().
         connect(on_favourite_dirs, Event.ACTION).
         set_label("Favourite dirs...")
      xdg_refresh_item := TextMenuItem().
         connect(on_xdg_refresh, Event.ACTION).
         set_label("Refresh XDG")
      quit_menu_item := TextMenuItem().
         connect(on_quit, Event.ACTION).
         set_label("Quit")
      file_menu := Menu().
         set_label("File").
         add(new_tab_item).
         add(favourite_dirs_item).
         add(xdg_refresh_item).
         add(quit_menu_item)
      terminal_menu := TerminalMenu().
         set_label("Terminal")
      columns_menu := ColumnsMenu().
         set_label("List")
      help_item := TextMenuItem().
         connect(on_help, Event.ACTION).
         set_label("Help...")
      about_item := TextMenuItem().
         connect(on_about, Event.ACTION).
         set_label("About...")
      help_menu := Menu().
         set_label("Help").
         add(help_item).
         add(about_item)
      menu_bar := MenuBar().
         set_size(scale(100)).
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("l_inset", 0).
         set_constraint("r_inset", 0).
         set_constraint("t_inset", 0).
         set_constraint("b_inset", 0).
         set_constraint("x_fill", &yes).
         add(file_menu).
         add(columns_menu).
         add(terminal_menu).
         add(help_menu)
      self.add(menu_bar)
      tabs := TabSet().
         clear_constraints().
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("y_fill", &yes).
         set_constraint("y_weight", 1.0).
         set_constraint("l_inset", 0).
         set_constraint("r_inset", 0).
         set_constraint("t_inset", 0).
         set_constraint("b_inset", 0).
         set_remember_focus(&yes).
         set_draggable_tabs(&yes).
         set_accepts_focus(&no).
         connect(on_tabs_rpress, Event.MOUSE_RIGHT_PRESS).
         connect(on_tabs_changed, Event.SELECTION_CHANGED)
      self.add(tabs)
      self.connect(self.on_quit, Event.WINDOW_CLOSE_BUTTON)
      self.set_layout(GridLayout().set_extra("cells"))
      set_label(\opts["t"] | "FlowTerm")
      return
   end
end

class Columns(LineBasedScrollArea)
   private readable
      data,
      item_border,
      item_paint,
      gutter,
      held,
      over,
      highlight,
      cursor

   private
      quieten,
      data_w,
      col_w,
      n_rows,
      prev_columnize_dw

   public static 
      FOCUS_DASHED_WIDTH

   private static init()
      FOCUS_DASHED_WIDTH := env_scale("OI_FLOWTERM_FOCUS_DASHED_WIDTH") | Gui.DASHED_WIDTH
   end

   public initially()
      \self.item_paint | runerr("ItemPaint not set")
      LineBasedScrollArea.initially()
      self.item_paint.initially(self)
      self.item_border.initially(self)
   end

   public finally()
      LineBasedScrollArea.finally()
      self.item_paint.finally()
      self.item_border.finally()
   end

   #
   # Set a border to draw along with each item.
   #
   public set_item_border(b)
      if is_initialized() then {
         (\self.item_border).finally()
         self.item_border := b
         self.item_border.initially(self)
      } else
         self.item_border := b
      return self
   end

   public set_item_paint(r)
      if is_initialized() then {
         (\self.item_paint).finally()
         self.item_paint := r
         self.item_paint.initially(self)
      } else
         self.item_paint := r
      return self
   end

   public draw_line(xp, yp, lh, i)
      local e, j, r, s, k, W
      every j := 1 to *col_w do {
         k := i + (j - 1) * n_rows
         e := data[k] | break
         s := item_paint.get_size(view.cbwin, e)
         r := Rect(xp, yp, s.w + item_border.get_total_width(), lh)
         if k === highlight then  {
            use {
               W := view.cbwin.clone(),
               {
                  W.set_fg("red")
                  item_paint.draw_rect(W, e, item_border.float(r, s))
                  item_border.draw_rect(W, r)
               }
            }
         } else {
            item_paint.draw_rect(view.cbwin, e, item_border.float(r, s))
            item_border.draw_rect(view.cbwin, r)
         }
         if k === cursor then {
            if has_focus() & is_unshaded() then
               item_border.draw_focus_rect(view.cbwin, r, FOCUS_DASHED_WIDTH)
            else
               item_border.draw_dashed_rect(view.cbwin, r)
         }
         if k === over then 
            Gui.style.fill_over_rectangle(view.cbwin, r.x, r.y, r.w, r.h)
         xp +:= col_w[j] + gutter
      }
   end

   public calculate_subject_width()
      do_columnize(predict_view_width(w, vsb))
      return col_w[1]
   end

   private invalidate_columnize()
      data_w := prev_columnize_dw := &null
      return self
   end

   public focus_changed(e) 
      if is_live() then
         invalidate_line(get_row_for_index(\cursor))
   end

   public layout()
      invalidate_subject_width()
      invalidate_line_count()
      ScrollArea.layout()
   end

   public set_internal_fields()
      local had_vsb
      had_vsb := self.vsb
      ScrollArea.set_internal_fields()
      if had_vsb ~=== self.vsb then {
         invalidate_subject_width()
         invalidate_line_count()
         ScrollArea.set_internal_fields()
      }
   end

   public get_default_subject_height(dw)
      do_columnize(dw)
      return n_rows * get_line_height()
   end

   private do_columnize(dw)
      local cr, tb
      if \prev_columnize_dw &
         (dw = prev_columnize_dw |
          (*col_w = 1 & dw < prev_columnize_dw)) then
         return
      prev_columnize_dw := dw
      if /data_w then {
         tb := item_border.get_total_width( )
         data_w := ipl.pdco.List{ item_paint.get_width(view.cbwin, (!data)) + tb }
      }
      cr := columnize(data_w, dw, gutter)
      n_rows := cr.rows
      col_w := cr.width
   end

   public calculate_line_height()
      return item_paint.get_constant_height(view.cbwin) + item_border.get_total_height() | runerr("Need a constant height")
   end

   public calculate_line_count()
      do_columnize(predict_view_width(w, vsb))
      return n_rows
   end

   public get_element_under_pointer(e)
      local i, j, d, s, r, xp, yp, fs, k
      i := get_line_under_pointer(e) | fail
      xp := get_subject_x()
      yp := get_subject_y() + get_line_height() * (i - 1)
      every j := 1 to *col_w do {
         if xp <= e.x < xp + col_w[j] then {
            k := i + (j - 1) * n_rows
            d := data[k] | fail
            s := item_paint.get_size(view.cbwin, d)
            r := Rect(xp, yp, col_w[j], get_line_height())
            fs := item_border.float(r, s)
            if fs.inside(e.x, e.y) then
               return k
            else
               fail
         }
         xp +:= col_w[j] + gutter
      }
   end

   public quieten_cursor()
      (/quieten & parent_dialog.get_held_count() = 0) | fail
      set_over()
      # No need to synch_pointer since we call this method out of the
      # vt's keyboard handler.
      view.set_pointer()
      quieten := 1
   end

   public unquieten_cursor()
      quieten := &null
   end

   private handle_move(ev)
      unquieten_cursor()
   end

   private handle_in_chain(e)
      local k, f
      (/quieten & parent_dialog.get_held_count() = 0) | fail
      if e.code === (Key.SHIFT_L | Key.SHIFT_R) then {
         if /e.release then
            f := 1
      } else f := \e.shift
      if /f & (k := get_element_under_pointer(e)) then {
         set_over(k)
         view.set_pointer("hand1")
      } else {
         set_over()
         view.set_pointer()
      }
   end

   private handle_exit(e)
      parent_dialog.get_held_count() = 0 | fail
      set_over()
   end

   public set_over(n)
      if n ~=== over then {
         invalidate_line(get_row_for_index(\over))
         over := n
         invalidate_line(get_row_for_index(\over))
         fire("over-changed")
      }
      return self
   end

   public handle_lmdrag(e)
      if \held = get_element_under_pointer(e) then {
         set_highlight(held)
         set_over(held)
      } else {
         set_highlight()
         set_over()
      }
   end

   public handle_lrelease(e)
      \held | fail
      if \over then {
         set_highlight()
         fire("lclicked", e)
      }
      held := &null
   end

   public handle_mrelease(e)
      \held | fail
      if \over then {
         set_highlight()
         fire("mclicked", e)
      }
      held := &null
   end

   public get_row_for_index(n)
      return (n - 1) % \n_rows + 1
   end

   public get_col_for_index(n)
      return (n - 1) / \n_rows + 1
   end

   public set_cursor(n)
      if cursor ~=== n then {
         invalidate_line(get_row_for_index(\cursor))
         cursor := n
         constrain_cursor()
         invalidate_line(get_row_for_index(\cursor))
      }
      return self
   end

   public set_highlight(n)
      if highlight ~=== n then {
         set_cursor(\n)
         invalidate_line(get_row_for_index(\highlight))
         highlight := n
         ensure_line_visible(get_row_for_index(\highlight)) 
         invalidate_line(get_row_for_index(\highlight))
      }
      return self
   end

   public get_highlight()
      return .\highlight
   end

   public get_held()
      return .\held
   end

   public get_over()
      return .\over
   end

   public object_get_cursor()
      return data[.\cursor]
   end

   public object_set_cursor(o)
      return set_cursor(keyof(data, o))
   end
   
   public get_cursor()
      return .\cursor
   end

   public handle_lpress(e)
      parent_dialog.get_held_count() = 1 | fail
      if \over then {
         if /e.ctrl then {
            set_highlight(over)
            held := over
         } else {
            set_cursor(over)
            ensure_line_visible(get_row_for_index(over)) 
         }
      } 
   end

   public handle_mpress(e)
      parent_dialog.get_held_count() = 1 | fail
      if \over then {
         set_highlight(over)
         held := over
      } 
   end

   public handle_key_page_up(e)
      local t
      t := get_page_movement(cursor, -1)
      t <:= n_rows * (get_col_for_index(cursor) - 1) + 1
      return t
   end

   public handle_key_page_down(e)
      local t
      t := get_page_movement(cursor, 1)
      t >:= n_rows * get_col_for_index(cursor)
      return t
   end

   public handle_key_up(e)
      return cursor - 1
   end

   public handle_key_down(e)
      return cursor + 1
   end

   public handle_key_left(e)
      local t
      (cursor > 1) | fail
      t := cursor - n_rows
      if t < 1 then {
         t +:= *col_w * n_rows - 1
         if t > *data then
            t -:= n_rows
      }
      return t
   end

   public handle_key_right(e)
      local t
      t := cursor + n_rows
      if t > *data then {
         t := (t - 1) % n_rows + 2
         t <= n_rows | fail
      }
      return t
   end

   public handle_key_home(e)
      return 1
   end

   public handle_key_end(e)
      return *data
   end

   public handle_return(e)
      local t
      \cursor | fail
      ensure_line_visible(get_row_for_index(cursor))
      set_highlight(cursor)
      t := Dispatcher.new_task{{
         t.sleep(50)
         set_highlight()
         fire("lclicked", e)
         t.revert()
      }}
      t.start()
   end

   private handle_key_move(f)
      \cursor | fail
      set_cursor(f())
      ensure_line_visible(get_row_for_index(cursor))
   end

   public handle_key(e)
      case e.code of {
         Key.HOME : handle_key_move(handle_key_home)
         Key.END : handle_key_move(handle_key_end)
         Key.PGUP : handle_key_move(handle_key_page_up)
         Key.PGDN : handle_key_move(handle_key_page_down)
         Key.UP : handle_key_move(handle_key_up)
         Key.DOWN : handle_key_move(handle_key_down)
         Key.LEFT : handle_key_move(handle_key_left)
         Key.RIGHT : handle_key_move(handle_key_right)
         "\r" | "\l": handle_return(e)
      }
   end

   public constrain_cursor()
      if *data = 0 then
         cursor := &null
      else {
         /cursor := 1
         cursor <:= 1
         cursor >:= *data
      }
   end

   public set_held(d)
      self.held := d
      return self
   end

   public data_changed()
      # over, held and highlight are cleared, since we store these as
      # indices (which may change) rather than the underlying objects.
      # cursor is left, however, and so the underlying object may
      # change.
      set_over()
      set_held()
      set_highlight()
      invalidate_columnize()
      invalidate_subject_width()
      invalidate_line_count()
      compute_and_invalidate()
      constrain_cursor()
      return self
   end

   public set_data(l)
      self.data := l
      data_changed()
      return self
   end

   public set_gutter(n)
      self.gutter := n
      return self
   end

   public keeps(e)
      return member(Key.CURSOR, e.code)
   end

   public new()
      LineBasedScrollArea.new()
      data := []
      gutter := scale(8)
      item_paint := TextItemPaint()
      item_border := NullBorder().set_x_align(Align.L)
      view.connect(handle_lpress, Event.MOUSE_LEFT_PRESS)
      view.connect(handle_mpress, Event.MOUSE_MIDDLE_PRESS)
      view.connect(handle_lmdrag, Event.MOUSE_LEFT_DRAG)
      view.connect(handle_lrelease, Event.MOUSE_LEFT_RELEASE)
      view.connect(handle_lmdrag, Event.MOUSE_MIDDLE_DRAG)
      view.connect(handle_mrelease, Event.MOUSE_MIDDLE_RELEASE)
      view.connect(handle_in_chain, Event.IN_POINT_CHAIN)
      every view.connect(handle_exit, Event.MOUSE_EXIT | Event.INTERRUPTED)
      view.connect(handle_move, Event.MOUSE_MOVEMENT)
      connect(handle_key, Event.KEY_PRESS)
      return
   end
end

procedure mk_file_URL(s)
   return URL(u"file://" || URL.percent_encode(s, URL.UNRESERVED ++ '/'))
end

class DirList(ButtonOnlyList)
   public create_button()
      local b
      b := IconButton().set_paint(ImagePaint().set_cache("gui.FAVOURITES_24"))
      theme_toolbar_button(b, "emblem-favorite")
      return b
   end

   private cursor_to_url()
      return mk_file_URL(popup.object_get_cursor())
   end

   private on_rpress(e)
      local m, pm
      m := parent.parent.create_link_menu(cursor_to_url()) | fail
      every Seq{m.traverse_postorder()}.connect(close_popup, Event.ACTION, 1)
      pm := PopupMenu().
         connect(create popup.clear_selections(), Event.POPUP_CLOSED)
      pm.popup(popup, m, e.x, e.y)
      popup.set_selections([popup.get_cursor()])
   end

   private on_mrelease(ev)
      popup.get_cursor() = popup.get_line_under_pointer(ev) | fail
      parent.parent.insert_link(cursor_to_url(), ev)
      close_popup()
   end

   public create_popup()
      local l
      l := ItemPaintList().
         set_item_paint(StringDirItemPaint()).
         set_item_border(EmptyBorder().
                            set_insets(Gui.TEXT_INSET, Gui.TEXT_INSET, 0, 0).
                            set_x_align(Align.L))
      l.view.
         connect(on_rpress, Event.MOUSE_RIGHT_PRESS).
         connect(on_mrelease, Event.MOUSE_MIDDLE_RELEASE)
      return l
   end
end

# Store objects rather than just strings in the history list to avoid
# confusion when the dir changes whilst the history list is open.
# With just strings we wouldn't be able to match up the selected
# string with a position in the (possibly changed) history.

record HistoryEntry(dir)

class HistoryEntryItemPaint(StringDirItemPaint)
   public get_string(data)
      return data.dir
   end
end

class HistoryList(ButtonOnlyList)
   public create_button()
      local b
      b := IconButton().set_paint(ImagePaint().set_cache("rpp.HOURGLASS_24"))
      theme_toolbar_button(b, "view-history")
      return b
   end

   private cursor_to_url()
      return mk_file_URL(popup.object_get_cursor().dir)
   end

   private on_rpress(e)
      local m, pm
      m := parent.parent.create_link_menu(cursor_to_url()) | fail
      every Seq{m.traverse_postorder()}.connect(close_popup, Event.ACTION, 1)
      pm := PopupMenu().
         connect(create popup.clear_selections(), Event.POPUP_CLOSED)
      pm.popup(popup, m, e.x, e.y)
      popup.set_selections([popup.get_cursor()])
   end

   private on_mrelease(ev)
      popup.get_cursor() = popup.get_line_under_pointer(ev) | fail
      parent.parent.insert_link(cursor_to_url(), ev)
      close_popup()
   end

   public create_popup()
      local t, l
      t := parent.parent
      set_selection_list(copy(t.history))
      set_selection(t.history_pos)
      l := ItemPaintList().
         set_item_paint(HistoryEntryItemPaint()).
         set_item_border(EmptyBorder().
                            set_insets(Gui.TEXT_INSET, Gui.TEXT_INSET, 0, 0).
                            set_x_align(Align.L))
      l.view.
         connect(on_rpress, Event.MOUSE_RIGHT_PRESS).
         connect(on_mrelease, Event.MOUSE_MIDDLE_RELEASE)
      return l
   end
end

class FileTrailListEx(FileTrailList)
   private cursor_to_url()
      return mk_file_URL(p.child(popup.object_get_cursor().name).ucs())
   end

   private on_rpress(e)
      local m, pm
      m := parent.parent.parent.create_link_menu(cursor_to_url()) | fail
      every Seq{m.traverse_postorder()}.connect(close_popup, Event.ACTION, 1)
      pm := PopupMenu().
         connect(create popup.clear_selections(), Event.POPUP_CLOSED)
      pm.popup(popup, m, e.x, e.y)
      popup.set_selections([popup.get_cursor()])
   end

   private on_mrelease(ev)
      popup.get_cursor() = popup.get_line_under_pointer(ev) | fail
      parent.parent.parent.insert_link(cursor_to_url(), ev)
      close_popup()
   end

   public create_popup()
      local l
      l := FileTrailList.create_popup()
      l.view.
         connect(on_rpress, Event.MOUSE_RIGHT_PRESS).
         connect(on_mrelease, Event.MOUSE_MIDDLE_RELEASE)
      return l
   end
end

class FileTrailButtonEx(FileTrailButton)
   private button_to_url()
      return mk_file_URL(p.ucs())
   end

   private on_rpress(e)
      local m, pm
      m := parent.parent.parent.create_link_menu(button_to_url()) | fail
      pm := PopupMenu().
         connect(create set_border_whilst_entered(&yes), Event.POPUP_CLOSED)
      set_border_whilst_entered(&no)
      pm.popup(self, m, e.x, e.y)
   end

   private on_mrelease(ev)
      parent.parent.parent.insert_link(button_to_url(), ev)
   end

   public new(p, tt)
      FileTrailButton.new(p, tt)
      connect(on_rpress, Event.MOUSE_RIGHT_PRESS)
      connect(on_mrelease, Event.MOUSE_MIDDLE_RELEASE)
      return
   end   
end

class FileTrailEx(FileTrail)
   public create_trail_list(p, child)
      return FileTrailListEx(p, child)
   end

   public create_trail_button(p, tt)
      return FileTrailButtonEx(p, tt)
   end
end

class Terminal(TabItem, VtUI)
   public static const
      MAX_HISTORY_SIZE,
      SHOW_NAME_ONLY,
      SHOW_DATE,
      SHOW_SIZE

   private
      prev_button,
      next_button,
      date_button,
      name_button,
      size_button,
      favourites_list,
      message_label,
      search_panel,
      search_field,
      search_label, 
      search_close_button,
      search_next_button,
      search_prev_button, 
      history_list,
      trail,
      best_focus,         # Either columns or output (the vt)
      log_file,
      log

   private readable
      ascending,
      sorter,
      annotate_opt,
      filter,
      refresh_button,
      up_button,
      home_button,
      close_button,
      focus_columns_button,
      output,
      columns,
      split,
      columns_pos_table,
      history,
      history_pos,
      io_task,
      check_cwd_time_task,
      pid, 
      tty,
      input,
      cwd,
      cwd_mtime,
      cwd_list,
      show_hidden_menu_item,
      mix_entries_menu_item,
      sort_dirs_menu_item,
      revert_tab,
      adjacent_flag,
      shell,
      auto_close_flag,
      select_flag,
      title

   private static init()
      MAX_HISTORY_SIZE := 100
      SHOW_NAME_ONLY := 1
      SHOW_DATE := 2
      SHOW_SIZE := 3
   end

   public set_select(f)
      self.select_flag := check_flag(f)
      return self
   end

   public set_adjacent(f)
      self.adjacent_flag := check_flag(f)
      return self
   end

   public set_auto_close(f)
      self.auto_close_flag := check_flag(f)
      return self
   end

   public set_shell(s)
      self.shell := s
      return self
   end

   public get_label_width()
      return scale(100)
   end

   public link_left_clicked(url)
      open_link(url)
   end

   public vt_size_changed(cols, rows)
      if \opts["v"] then
         write("Vt size changed to: ", cols, ",", rows)
      tty.set_size(cols, rows)
   end

   public set_title(s)
      self.title := s
      update_title()
      return self
   end

   public set_list_width(n)
      columns.set_width(n)
      if is_live() then {
         split.first.set_width().reset_layout()
         split.do_layout().invalidate()
      }
      return self
   end

   public set_list_height(n)
      columns.set_height(n)
      if is_live() then {
         split.first.set_height().reset_layout()
         split.do_layout().invalidate()
      }
      return self
   end

   public do_tab_cmd(s)
      local param
      s := ucs(s) | return error("Not a ucs string")
      s ? if s := tab(upto('=')) then
         param := (move(1), tab(0))
      case string(s) of {
         "sh" : set_shell(param)
         "run" : {
            \param | return error("expected parameter to run")
            run_prog(param)
         }
         "font" : {
            \param | return error("expected parameter to font")
            output.set_vt_font(param) | return error("invalid parameter to font: " || &why)
         }
         "fg": output.set_normal_fg(param) | return error("invalid parameter to fg: " || &why)
         "bg": output.set_normal_bg(param) | return error("invalid parameter to bg: " || &why)
         "rev-fg": output.set_reverse_fg(param) | return error("invalid parameter to rev-fg: " || &why)
         "rev-bg": output.set_reverse_bg(param) | return error("invalid parameter to rev-bg: " || &why)
         "hist": {
            param := (0 <= integer(param)) | return error("integer >= 0 expected to hist")
            output.set_history_size(param)
         }
         "list-width": {
            param := (0 < integer(param)) | return error("integer > 0 expected to list-width")
            set_list_width(scale(param))
         }
         "list-height": {
            param := (0 < integer(param)) | return error("integer > 0 expected to list-height")
            set_list_height(scale(param))
         }
         "auto-close" : set_auto_close(&yes)
         "title" : set_title(param)
         "max-list" : on_max_list()
         "max-term" : on_max_terminal()
         "restore" : on_restore()
         "adjacent" : set_adjacent(&yes)
         "list-focus" : {
            focus_columns_button.toggle_is_checked().invalidate()
            on_focus_columns_button()
         }
         "reorient" | "re-orient" : on_reorient()
         "sort-name" : on_name_button()
         "sort-date" : on_date_button()
         "sort-size" : on_size_button()
         "show-name-only" : on_show_name_only()
         "show-date" : on_show_date()
         "show-size" : on_show_size()
         "mix-entries" : {
            mix_entries_menu_item.toggle_is_checked()
            on_mix_entries_menu_item()
         }
         "show-hidden" : {
            show_hidden_menu_item.toggle_is_checked()
            on_show_hidden_menu_item()
         }
         "sort-dirs" : {
            sort_dirs_menu_item.toggle_is_checked()
            on_sort_dirs_menu_item()
         }
         "select" : set_select(&yes)
         default: return error("Invalid command: " || s)
      }
      return self
   end

   private on_max_terminal()
      split.hide_first()
   end

   private on_max_list()
      split.hide_second()
   end

   private on_restore()
      split.hide_neither()
   end

   private on_reorient(e)
      split.reorient()
   end

   public link_middle_clicked(url, ev)
      insert_link(url, ev)
   end

   public quieten_cursor()
      columns.quieten_cursor()
   end

   public send_tty(s)
      s := string(s) | runerr(103, s)
      put(input, s)
      # We may be in the io_task already since some writes to the vt
      # cause it to output something (eg device attr string).  So in
      # that case we must not interrupt.  Otherwise, the io_task
      # must be sleeping in poll().  Interrupt it so it goes round
      # its loop again, and polls for both input and output.
      /io_task | (Dispatcher.get_curr_task() === io_task) | io_task.interrupt()
      return self
   end

   public msg(s, n)
      message_label.set(s, n)
   end

   private static env_put(env, key, val)
      local i
      key ||:= "="
      every i := 1 to *env do {
         if match(key, env[i]) then {
            env[i] := key || val
            return
         }
      }
      put(env, key || val)
   end

   private setup_shell()
      local env, sh, xd, fp, s, sh2, t
      env := []
      every put(env, System.environ())
      env_put(env, "FLOWTERM", "1")
      env_put(env, "TERM", "xterm")
      sh := \shell | System.getpw(System.getuid()).shell
      if /sh | *sh = 0 then
         sh := "/bin/sh"
      if /opts["nx"] then {
         s := \opts["x"] | Files.get_home() || "/flowterm-extras"
         fp := FilePath(s).child("bin").canonical()
         xd := fp.str()
         if Files.access(xd) then {
            env_put(env, "PATH", xd || ":" || System.getenv("PATH"))
            t := FilePath(sh).get(-1)
            if t == ("bash" | "zsh") then {
               sh2 := fp.child(t).str()
               if Files.access(sh2) then
                  sh := sh2
               else
                  info_msg("Unable to access extras " || t || " shell '" || sh2 || "'")
            }
         } else
            info_msg("Unable to access extras bin directory '" || xd || "'")
      }
      tty := PttyStream() | fail
$ifdef _DARWIN
      # Darwin doesn't seem to allow NONBLOCK flag on a tty
      (pid := System.fork()) | {
         tty.close()
         fail
      }
$else
      (tty.flag(FileOpt.NONBLOCK) &
       pid := System.fork()) | {
         tty.close()
         fail
      }
$endif
      if pid > 0 then {
         # Parent
         return
      } else {
         # Child
         System.setsid() | stop(&why)
         tty.close()
         tty := tty.open_slave() | stop(&why)
         tty.dup2(FileStream.stdout) | stop(&why)
         tty.dup2(FileStream.stdin) | stop(&why)
         tty.dup2(FileStream.stderr) | stop(&why)
         Files.chdir(cwd)
         System.exec(sh, [], env) | stop(&why)
         syserr("Not reached")
      }
   end

   private static on_shell_exit(r)
      if \opts["v"] then
         write("Shell process exited: ", to_string(r))
   end

   public get_pats()
      local pat, pats
      pats := []
      filter.get_contents() ? {
         repeat {
            pat := tab(upto(';') | 0)
            put(pats, Wildcard(pat))
            move(1) | break
         }
      }
      return pats
   end

   public tab_active()
      check_cwd_change()
   end

   private check_cwd_change()
      set_cwd(cwd ~== ucs(System.getcwd(pid)))
   end

   private update_grey()
      prev_button.set_is_shaded(No{ history_pos < *history })
      next_button.set_is_shaded(No{ history_pos > 1 })
   end

   private send_vt(s)
      output.input(s)
   end

   private check_cwd_time()
      local t
      repeat {
         if t := get_ns_mtime(cwd) then {
            if t ~= cwd_mtime then
               refresh_cwd()
         }
         check_cwd_time_task.sleep(500)
      }
   end

   private service_tty()
      local x, s, n, i, some_in
      repeat {
         # The some_in flag ensures we don't send anything to the tty
         # until we've seen some input (a prompt).  This is since
         # readline will misinterpret what's in the buffer before it
         # starts up, muddling up \n with \r, because readline clears the
         # ICRNL bit in the termios c_iflag structure (see rltty.c).
         i := if *input > 0 & \some_in then Poll.IN + Poll.OUT else Poll.IN
         x := io_task.poll([tty, i]) | {
            if /io_task.interrupt_flag then {
               err_msg("IO problem polling tty: " || &why)
               break
            } else {
               # We were interrupted, meaning that some input has gone into the
               # buffer; so go round again.
               next
            }
         }
         if DescStream.poll_out_test(x[1]) then {
            s := get(input) | syserr("Poll out, but input buffer empty")
            n := tty.out(s) | {
               err_msg("IO problem on tty: " || &why)
               break
            }
            if n < *s then
               push(input, s[n + 1:0])
            if \opts["v"] then
               write("Out: ", image(s))
         } else if DescStream.poll_in_test(x[1]) then {
            s := tty.in(1048576) | {
               err_msg("IO problem on tty: " || &why)
               break
            }
            if /s then {
               err_msg("EOF on tty")
               break
            }
            if \opts["v"] then
               write("In: ", image(s))
            (\log).writes1(s)
            send_vt(s)
            check_cwd_change()
            some_in := &yes
         } else {
            err_msg("IO problem on tty, neither poll in or out ready")
            break
         }
      }
      if \auto_close_flag then
         # invoke later since we can't call finally() from within the io_task
         parent_dialog.invoke_later{close_tab()}
      io_task.revert()
   end

   public static launch_prog(runner)
      local pid, nul, cmd
      if \opts["v"] then write("Launch runner: ", to_string(runner, 3, 1))
      pid := System.fork() | fail
      if pid > 0 then {
         # Parent
         ChildWait.add_pid(pid, on_prog_exit)
         return
      }
      # Set the working directory for the child process
      Files.chdir(runner.get_working_dir() | Files.get_home())
      # Get the command to run.
      cmd := runner.get_command()
      System.setpgid()
      if nul := FileStream("/dev/null", FileOpt.RDWR) then {
         every nul.dup2(FileStream.stdin | FileStream.stdout | FileStream.stderr)
         nul.close()
      }
      System.exec("/bin/sh", ["-c", "exec " || cmd]) | stop(&why)
      syserr("Not reached")
   end

   private static on_prog_exit(r)
      if \opts["v"] then
         write("Child application exited: ",to_string(r))
   end

   public open_link(url)
      local r
      case string(url.scheme) of {
         "text": send_tty(ucs(url.get_decoded_path()))
         "tab": {
            parent_dialog.do_tab_cmd(ipl.pdco.List{ URL.percent_decode(separate(url.get_path(), ';')) }) |
               info_msg(&why)
         }
         default: {
            if r := get_runners(url) then {
               if is(r, ExternalRunner) then
                  launch_prog(r)
               else
                  run_prog(r.get_command())
            } else
               info_msg(&why)
         }
      }
   end

   public insert_link(url, ev)
      local s, es
      if url.scheme == u"file" then {
         if s := ucs(url.get_decoded_path()) then {
            es := if /ev.ctrl & is_local_host(url) & cwd ~== u"/" then {
               if cwd == s then
                  u"./"
               else if match(cwd || u"/", s) then
                  u"./" || s[*cwd + 2:0]
               else
                  s
            } else
               s
            es := Format.shell_escape(es)
            if is_local_host(url) & Files.is_directory(s) then {
               if es[-1] ~== u"/" then
                  es ||:= u"/"
            }
            send_tty(es || u" ")
         }
      } else
         send_tty(url.ucs() || u" ")
   end

   public err_msg(s)
      send_vt("\n\e[31m(Message from terminal:) " || s || "\e[m")
      info_msg(s)
   end

   public info_msg(s)
      msg(s, 3000)
   end

   private static get_possible_desktop_entries(s)
      suspend Unique{Xdg.gen_desktop_entries(Xdg.alternative_mime_types(Xdg.get_mime_type_for_file(FilePath(s).get(-1))))}
   end

   private static get_possible_scheme_handler_desktop_entries(url)
      suspend Xdg.gen_desktop_entries("x-scheme-handler/" || string(url.scheme))
   end

   private static is_local_host(url)
      return url.host == ("localhost" | &host)
   end

   private get_runners(url)
      local s, cd, de, fl
      case string(url.scheme) of {
         "file" : {
            is_local_host(url) | return error(u"Can't run a file on another host (" || url.host || u")")
            s := ucs(url.get_decoded_path()) | return error(u"URL decoded path not utf8")
            if Files.is_directory(s) then
               return ImmediateRunner(u"cd " || Format.shell_escape(s))
            # Get a DesktopEntry based on the content-type if available, or the filename.
            every de := get_possible_desktop_entries(s) do {
               fl := 1
               suspend DesktopRunner(de, url, s)
            }
            return if /fl then error(u"No matching desktop entry for this URL")
         }
         "run" : {
            s := ucs(url.get_decoded_path()) | return error(u"URL decoded path not utf8")
            return ImmediateRunner(s)
         }
         "launch" : {
            s := ucs(url.get_decoded_path()) | return error(u"URL decoded path not utf8")
            if cd := member(url.extract_cgi_parameters(), "wd")[1] then
               cd := ucs(cd) | return error(u"CD decoded path not utf8")
            return LaunchRunner(s, cd)
         }
         default : {
            every de := get_possible_scheme_handler_desktop_entries(url) do {
               fl := 1
               suspend DesktopRunner(de, url, url.ucs())
            }
            return if /fl then error(u"No desktop entry for url scheme " || url.scheme)
         }
      }
   end

   private on_columns_lclick()
      local item
      item := columns.data[columns.get_cursor()] | fail
      open_link(item_to_url(item))
   end

   private item_to_url(item)
      return mk_file_URL(FilePath(cwd).child(item.name).ucs())
   end

   private on_columns_mclick(ev)
      local item
      item := columns.data[columns.get_cursor()]
      insert_link(item_to_url(item), ev)
   end

   private on_columns_over_changed(ev)
      local s, url
      if /columns.over then
         msg()
      else {
         s := FilePath(cwd).child(columns.data[columns.over].name).ucs() | fail
         url := mk_file_URL(s)
         msg(url.ucs())
      }
   end

   private copy_text(s)
      parent_dialog.own_selection(Selection.CLIPBOARD, 
                                  StaticTextSelectionOwner(s))
   end

   private copy_url(url)
      parent_dialog.own_selection(Selection.CLIPBOARD,
                                  URLSelectionOwner([url]))
   end 

   private rename(s)
      local d
      d := RenameDialog(s)
      d.show_modal(parent_dialog)
      s := \d.result | fail
      info_msg("Renamed OK")
      if cwd == FilePath(s).parent().ucs() then
         refresh_cwd()
      else
         check_cwd_change()
   end

   private on_copy_cwd(e)
      copy_text(cwd)
   end

   private open_in_new_tab(dir)
      parent_dialog.new_tab(, dir,, self)
   end

   private on_start_log()
      local d, s, dl, fl
      d := parent_dialog.file_dialog
      dl := [cwd]
      fl := [u"log"]
      if \parent_dialog.last_log_file then {
         push(dl, parent_dialog.last_log_file.parent().ucs())
         push(fl, parent_dialog.last_log_file.get(-1))
      }
      if \log_file then {
         push(dl, log_file.parent().ucs())
         push(fl, log_file.get(-1))
      }
      d.set_directories(dl).
         set_files(fl).
         set_existing_file_mode(FileDialog.WARN).
         show_modal(parent_dialog)
      parent_dialog.last_log_file := log_file := d.get_result_path() | fail
      s := log_file.ucs()
      if log := open(s, "w") then
         info_msg(u"Logging to file " || s)
      else
         info_msg(u"Failed to open " || s || u": " || ucs(&why))
   end

   private close_log()
      \log | fail
      log.close()
      log := &null
   end

   private on_end_log()
      close_log()
      info_msg(u"Closed log file " || log_file.ucs())
   end

   public create_context_menu()
      local m
      m := Menu()
      if output.get_current_text_selection() then {
         m.add(TextMenuItem().
               set_label("Copy text").
               connect(output.handle_copy, Event.ACTION))
      }
      m.add(TextMenuItem().
            set_label("Paste").
            connect(output.handle_paste, Event.ACTION))
      m.add(TextMenuItem().
            set_label("Paste escaped").
            connect(output.handle_paste_escaped, Event.ACTION))
      m.add(TextMenuItem().
            set_label("Select all").
            connect(output.handle_select_all, Event.ACTION))
      m.add(TextMenuItem().
            set_label("Copy cwd").
            connect(on_copy_cwd, Event.ACTION))
      m.add(MenuSeparator())
      m.add(TextMenuItem().
            set_label("Reorient").
            connect(on_reorient, Event.ACTION))
      if /split.first.is_hidden_flag then
         m.add(TextMenuItem().
               set_label("Maximize").
               connect(on_max_terminal, Event.ACTION))
      if \split.sizer.is_hidden_flag then
         m.add(TextMenuItem().
               set_label("Restore").
               connect(on_restore, Event.ACTION))
      if not search_panel.is_live() then
         m.add(TextMenuItem().
               set_label("Search").
               connect(open_search_panel, Event.ACTION))
      if /log then
         m.add(TextMenuItem().
               set_label("Log...").
               connect(on_start_log, Event.ACTION))
      else
         m.add(TextMenuItem().
               set_label("End log").
               connect(on_end_log, Event.ACTION))

      return m
   end

   private create_open_with_menu(url)
      local m, m1, r, de
      m := Menu().set_label("Open with")
      every r := get_runners(url) do {
         if is(r, DesktopRunner) then {
            de := r.desktop_entry
            m1 := TextMenuItem().
               set_label(de.name).
               connect(cocopy{launch_prog(r)}, Event.ACTION)
            m1.set_paint_left(ImagePaint().set_cache(Xdg.find_icon_and_cache(\de.icon, Gui.MENU_ICON_SIZE, &yes)))
            m.add(m1)
         }
      }
      if *m.children > 0 then
         return m
   end

   public create_link_menu(url)
      local m, r, udp
      m := Menu()
      if udp := ucs(url.get_decoded_path()) &
         url.scheme == (u"file" | u"text" | u"run") then 
      {
         m.add(TextMenuItem().
               set_label("Copy").
               connect(create copy_text(udp), Event.ACTION))
      }
      m.add(TextMenuItem().
            set_label("Copy URL").
            connect(create copy_url(url), Event.ACTION))
      if r := get_runners(url) then
         m.add(TextMenuItem().
            set_label("Insert command").
            connect(create send_tty(r.get_command()), Event.ACTION))
      if url.scheme == u"file" then {
         if is_local_host(url) & \udp then {
            if Files.is_directory(udp) then {
               m.add(TextMenuItem().
                     set_label("Open in new tab").
                     connect(create open_in_new_tab(udp), Event.ACTION))
            } else
               m.add(create_open_with_menu(url))

            m.add(TextMenuItem().
                  set_label("Rename").
                  connect(create rename(udp), Event.ACTION))
         }
      } else
         m.add(create_open_with_menu(url))
      return m
   end

  private on_columns_rpress(e)
      local i, m, pm, item, url
      pm := PopupMenu()
      if item := columns.data[i := columns.get_over()] then {
         url := item_to_url(item) | fail
         columns.set_highlight(i).set_over()
         m := create_link_menu(url)
         pm.connect(on_popup_closed, Event.POPUP_CLOSED)
      } else
         m := create_columns_context_menu()
      pm.popup(parent_dialog, m, e.x, e.y)
   end

   public get_tab_tooltip()
      if tab_w - label_border.get_total_width() < cbwin.text_width(paint.str) then
         return paint.str
   end

   private on_show_name_only(e)
      annotate_opt := SHOW_NAME_ONLY
      annotate_cwd_list()
      columns.data_changed()
   end

   private on_show_date(e)
      annotate_opt := SHOW_DATE
      annotate_cwd_list()
      columns.data_changed()
   end

   private on_show_size(e)
      annotate_opt := SHOW_SIZE
      annotate_cwd_list()
      columns.data_changed()
   end

   private on_mix_entries_menu_item(e)
      annotate_cwd_list()
      resort_cwd()
   end

   private on_sort_dirs_menu_item(e)
      annotate_cwd_list()
      resort_cwd()
   end

   private on_show_hidden_menu_item(e)
      resort_cwd(&yes)
   end

   public create_columns_context_menu()
      local m
      m := Menu()
      if annotate_opt ~= SHOW_NAME_ONLY then
         m.add(TextMenuItem().
            set_label("Name only").
            connect(on_show_name_only , Event.ACTION))
      if annotate_opt ~= SHOW_DATE then
         m.add(TextMenuItem().
            set_label("Show date").
            connect(on_show_date, Event.ACTION))
      if annotate_opt ~= SHOW_SIZE then
         m.add(TextMenuItem().
            set_label("Show size").
            connect(on_show_size, Event.ACTION))
      m.add(MenuSeparator())
      m.add(show_hidden_menu_item)
      if mix_entries_menu_item.is_unchecked() then
         m.add(sort_dirs_menu_item)
      m.add(mix_entries_menu_item)
      m.add(MenuSeparator())
      m.add(TextMenuItem().
            set_label("Reorient").
            connect(on_reorient, Event.ACTION))
      if /split.second.is_hidden_flag then
         m.add(TextMenuItem().
               set_label("Maximize").
               connect(on_max_list, Event.ACTION))
      if \split.sizer.is_hidden_flag then
         m.add(TextMenuItem().
               set_label("Restore").
               connect(on_restore, Event.ACTION))
      return m
   end

   private on_popup_closed()
      columns.set_highlight()
   end

   private run_prog(s)
      send_tty(s || u"\r")
   end

   public goto_dir(d)
      d := ucs(d) | fail
      run_prog(u"cd " || Format.shell_escape(d))
   end

   private synch_paints()
      local cp, np, sp, dp, sz
      sz := Gui.TOOLBAR_ICON_SIZE
      cp := CompoundPaint().set_top(ImagePaint().set_cache(if /ascending then "gui.TINY_ARROW_DOWN" else "gui.TINY_ARROW_UP"))
      np := ImagePaint().set_cache(ImageCache.get_scaled_svg_key_alt("gui.FONT_SVG", "gui.FONT_24", sz, sz))
      sp := ImagePaint().set_cache(ImageCache.get_scaled_svg_key_alt("gui.FILESIZE_SVG", "gui.FILESIZE_24", sz, sz))
      dp := ImagePaint().set_cache(ImageCache.get_scaled_svg_key_alt("gui.CLOCK_SVG", "gui.CLOCK_24", sz, sz))
      case sorter of {
         Files.name_cmp: {
            name_button.set_paint(cp.set_bottom(np))
            date_button.set_paint(dp)
            size_button.set_paint(sp)
         }
         Files.size_cmp: {
            name_button.set_paint(np)
            date_button.set_paint(dp)
            size_button.set_paint(cp.set_bottom(sp))
         }
         Files.date_cmp: {
            name_button.set_paint(np)
            date_button.set_paint(cp.set_bottom(dp))
            size_button.set_paint(sp)
         }
      }
      resort_cwd()
   end

   private on_date_button(ev)
      if sorter === Files.date_cmp then
         ascending := toggle_flag(ascending)
      else
         sorter := Files.date_cmp
      synch_paints()
   end

   private on_name_button(ev)
      if sorter === Files.name_cmp then
         ascending := toggle_flag(ascending)
      else
         sorter := Files.name_cmp
      synch_paints()
   end

   private on_size_button(ev)
      if sorter === Files.size_cmp then
         ascending := toggle_flag(ascending)
      else
         sorter := Files.size_cmp
      synch_paints()
   end

   private static get_ns_mtime(f)
      local st
      st := Files.stat(f) | fail
      return st.mtime * 1000000000 + st.mtime_ns
   end

   private load_cwd_list()
      cwd_mtime := get_ns_mtime(cwd) | 0
      (cwd_list := Files.ucs_list(cwd, AnnotatedListEntryWithIcon)) | {
         info_msg("Failed to read cwd: " || &why)
         cwd_list := []
      }
   end

   private annotate_cwd_list()
      local e, fl, now
      # flag indicates whether to annotate dirs with size/date
      if mix_entries_menu_item.is_checked() | sort_dirs_menu_item.is_checked() then
         fl := &yes
      now := Time.get_system_seconds()
      every e := !cwd_list do {
         if /fl & e.stat.mode_str[1] == "d" then
            e.annotate_name()
         else case annotate_opt of {
            SHOW_NAME_ONLY : e.annotate_name()
            SHOW_DATE : e.annotate_date(now)
            SHOW_SIZE : e.annotate_size()
            default : syserr("Bad annotate_opt")
         }
      }
   end

   private sort_cwd_list()
      local dirs, files, e, s, pats
      pats := get_pats()
      dirs := []
      files := []
      every e := !cwd_list do {
         s := e.name
         if (/pats | (!pats).match(s) = *s + 1)\1 &
            (show_hidden_menu_item.is_checked() | not(Files.is_hidden(s))) then {
            if e.stat.mode_str[1] == "d" then
               Files.is_relative_dir(s) | put(dirs, e)
            else
               put(files, e)
         }
      }
      if mix_entries_menu_item.is_checked() then
         while put(files, get(dirs))
      else {
         if sort_dirs_menu_item.is_checked() then
            qsort(dirs, if /ascending then sorter else flip(sorter))
         else
            qsort(dirs, Files.name_cmp)
      }
      qsort(files, if /ascending then sorter else flip(sorter))
      columns.set_data(dirs ||| files)
   end

   private resort_cwd(track_cursor)
      local i, ino, info, vis, high, held, over
      \cwd | fail
      if is_live() then {
         if \track_cursor & i := columns.get_row_for_index(columns.get_cursor()) then {
            # Set vis to &yes if the last highlight is currently visible; also get the ino of
            # the last highlight.
            info := columns.get_line_info()
            if info.first_whole <= i <= info.last_whole then
               vis := &yes
            ino := columns.object_get_cursor().stat.ino
            if columns.get_cursor() === columns.get_highlight() then
               high := &yes
            if columns.get_cursor() === columns.get_held() then
               held := &yes
            if columns.get_cursor() === columns.get_over() then
               over := &yes
         }
         sort_cwd_list()
         # Search for the old ino in the new data.  If found, set the highlight and if the old
         # cursor was visible, ensure the new one is too.
         if \track_cursor & i := Positions{(!columns.data).stat.ino, \ino} then {
            columns.set_cursor(i)
            if \vis then
               columns.ensure_line_visible(columns.get_row_for_index(i))
            if \high then
               columns.set_highlight(i)
            if \held then
               columns.set_held(i)
            if \over then
               columns.set_over(i)
         } else
            columns.set_cursor()
         # Since the pointer may be over the files list, update the pointer.
         parent_dialog.resynch_pointer()
      } else
         sort_cwd_list()
   end

   private update_filter_list()
      local e, l, ex
      ex := table(0)
      every e := !cwd_list do {
         (e.stat.mode_str[1] == "d") |
            Files.is_hidden(e.name) |
            (ex[Files.get_extension(e.name)] +:= 1)
      }
      l := [u"*"]
      every e := back(sort(ex, 2)) do
         put(l, u"*." || e[1])
      filter.set_selection_only().synch_set_selection_list(l)
   end

   private refresh_cwd()
      load_cwd_list()
      annotate_cwd_list()
      resort_cwd(&yes)
      update_filter_list()
   end

   private update_title()
      set_paint(AbbreviatedTextPaint(\title | FilePath(cwd).get(-1)))
   end

   private set_cwd(s)
      local lh, t, i
      s := ucs(s) | fail
      if \cwd then {
         lh := columns.data[columns.get_cursor()].name
         insert(columns_pos_table, 
                FilePath(cwd).canonical().str(), 
                FileDialogPos(lh, columns.get_area_y()))
      }
      cwd := s
      trail.set_path(cwd)
      load_cwd_list()
      annotate_cwd_list()
      # Reset filter to "*"
      filter.set_selection(1)
      sort_cwd_list()
      synch_favourites_list()
      update_filter_list()

      if is_live() then {
         if t := member(columns_pos_table, FilePath(cwd).canonical().str()) then {
            i := Positions{(!columns.data).name, \t.cursor_name}
            columns.set_area_y(t.area_y).set_area_x(0).set_cursor(i)
         } else
            columns.set_area_y(0).set_area_x(0).set_cursor()
         parent_dialog.resynch_pointer()
      }

      (cwd === history[history_pos].dir) | {
         every 1 to history_pos - 1 do
            pop(history)
         push(history, default.HistoryEntry(cwd))
         history_pos := 1
         while *history > MAX_HISTORY_SIZE do
            pull(history)
         update_grey()
      }
      update_title()
      return self
   end

   public get_favourites_directories()
      local t
      t := []
      every put(t,
                Files.getcwd() | 
                FavouriteDirectoriesDialog.gen_directories())
      return lunique(FileDialog.ucs_list(t))
   end

   public refresh_favourite_dirs()
      favourites_list.set_selection_list(get_favourites_directories())
      synch_favourites_list()
   end

   private synch_favourites_list()
      favourites_list.object_set_selection(cwd) | favourites_list.set_selection()
   end

   private on_trail(ev)
      goto_dir(ev)
   end

   private on_columns_move(ev)
      output.unquieten_cursor()
   end

   public new(dir, other, revert_tab)
      local start_dir, c, e
      TabItem.new()
      self.revert_tab := revert_tab
      setup()
      setup_search_panel()
      label_border.set_x_align(Align.L)
      columns.
         set_item_paint(AnnotatedIconFilesItemPaint()).
         set_item_border(EmptyBorder().
                             set_insets(Gui.TEXT_INSET, Gui.TEXT_INSET, 0, 0).
                             set_x_align(Align.L)).
         connect(on_columns_lclick, "lclicked").
         connect(on_columns_mclick, "mclicked").
         connect(on_columns_over_changed, "over-changed")
      columns.view.
         connect(on_columns_rpress, Event.MOUSE_RIGHT_PRESS).
         connect(on_columns_move, Event.MOUSE_MOVEMENT)
      trail.
         set_height().
         set_constraint("l_inset", scale(10)).
         connect(on_trail, FileTrail.DIR_CHANGED_EVENT)
      output.
         set_ui(self)
      if \opts["v"] then
         output.set_verbose(&yes)

      favourites_list.set_size().set_selection_list(get_favourites_directories())
      sort_dirs_menu_item := CheckBoxMenuItem().
         set_label("Sort dirs").
         connect(on_sort_dirs_menu_item, Event.ACTION)
      mix_entries_menu_item := CheckBoxMenuItem().
         set_label("Mix files & dirs").
         connect(on_mix_entries_menu_item, Event.ACTION)
      show_hidden_menu_item := CheckBoxMenuItem().
         set_label("Show hidden files").
         connect(on_show_hidden_menu_item, Event.ACTION)

      filter.set_selection_list([u"*"])
      history_list.set_size().set_selection_list([])
      input := []
      theme_toolbar_button(close_button, "window-close")
      theme_toolbar_button(prev_button, "go-previous")
      theme_toolbar_button(next_button, "go-next")
      theme_toolbar_button(up_button, "go-up")
      theme_toolbar_button(home_button, "go-home")
      theme_toolbar_button(refresh_button, "view-refresh")
      theme_toolbar_button(focus_columns_button, "key-enter")

      if \other then {
         if other.focus_columns_button.is_checked() then {
            focus_columns_button.set_is_checked(&yes)
            columns.set_accepts_focus(&yes)
         }
         split.first.set_size(other.split.first.w_spec, other.split.first.h_spec)
         split.second.set_size(other.split.second.w_spec, other.split.second.h_spec)
         columns.set_size(other.columns.w_spec, other.columns.h_spec)
         if \other.split.sizer.is_horizontal_flag then
            split.reorient()
         if \other.split.first.is_hidden_flag then
            on_max_terminal()
         else if \other.split.second.is_hidden_flag then
            on_max_list()
         sorter := other.sorter
         ascending := other.ascending
         annotate_opt := other.annotate_opt
         c := if \other.is_hidden_flag then other.remembered_focus else other.parent_dialog.get_focus()
         set_remembered_focus(if c === other.columns then columns else output)
         log_file := other.log_file
         output.
            set_normal_fg(other.output.normal_fg).
            set_normal_bg(other.output.normal_bg).
            set_reverse_fg(other.output.reverse_fg).
            set_reverse_bg(other.output.reverse_bg).
            set_font(other.output.font_family || "," || other.output.font_size).
            set_history_size(other.output.history_size) | syserr("Clone output setting failed: " || &why)
         set_shell(other.shell)
         sort_dirs_menu_item.set_is_checked(other.sort_dirs_menu_item.get_status())
         mix_entries_menu_item.set_is_checked(other.mix_entries_menu_item.get_status())
         show_hidden_menu_item.set_is_checked(other.show_hidden_menu_item.get_status())
         history := clone(other.history)
         history_pos := other.history_pos
         columns_pos_table := clone(other.columns_pos_table)
         set_cwd(other.cwd)
      } else {
         sorter := Files.name_cmp
         annotate_opt := SHOW_NAME_ONLY
         set_remembered_focus(output)
         history := []
         history_pos := 0
         columns_pos_table := table()
         if \dir then
            start_dir := Files.realpath(\dir) | info_msg("Invalid tab start directory: " || &why)
         /start_dir := ucs(Files.getcwd()) | u"/"
         set_cwd(start_dir)
         # Apply global default tab options.
         every e := !glob_cmds do
            do_tab_cmd(e) | stop(&why)
      }
      synch_paints()
      update_grey()
      return
   end

   public initially()
      TabItem.initially()
      setup_shell() | stop(&why)
      io_task := Dispatcher.new_task{service_tty()}
      io_task.start()
      check_cwd_time_task := Dispatcher.new_task{check_cwd_time()}
      check_cwd_time_task.start()
   end

   public finally()
      TabItem.finally()
      check_cwd_time_task.stop()
      io_task.stop()
      System.kill(pid, Signal.SIGHUP)
      tty.close()
      close_log()
      ChildWait.add_pid(pid, on_shell_exit)
      check_cwd_time_task := io_task := tty := pid := &null
   end

   private on_favourites_list(ev)
      goto_dir(favourites_list.object_get_selection())
   end

   private on_history_list(ev)
      local he
      he := history_list.object_get_selection()
      history_pos := keyof(history, he) | fail
      update_grey()
      goto_dir(he.dir)
   end

   private on_home_button(ev)
      goto_dir(Files.get_home())
   end

   private on_refresh_button(ev)
      refresh_cwd()
   end

   private on_up_button(ev)
      local t
      t := FilePath(cwd).canonical()
      if t.size() > 1 then
         goto_dir(t.parent().str())
   end

   private on_close_button(ev)
      close_tab()
   end

   public clone_tab()
      parent_dialog.new_tab(&yes,, self, self)
   end

   public close_tab()
      local t, i
      if *parent.children = 1 then
         parent_dialog.dispose()
      else {
         if parent.which_one === self then {
            # We're closing the currently selected tab, so choose a new
            # one to be the current tab.
            (i := parent.get_index(\revert_tab)) | {
               i := parent.get_index(self)
               if i > 1 then
                  i -:= 1
               else
                  i +:= 1
            }
            t := parent.children[i] | syserr("Couldn't find other tab")
            parent.set_which_one(t)
         }
         parent.
            remove(self).
            do_layout().
            invalidate()
      }
   end

   private on_filter_action(ev)
      resort_cwd(&yes)
      parent_dialog.set_focus(best_focus)
   end

   private on_filter_content_changed(ev)
      if filter.was_applied(ev) then
         on_filter_action()
   end

   private on_prev_button(ev)
      local he
      (history_pos < *history) | fail
      he := history[history_pos +:= 1]
      update_grey()
      goto_dir(he.dir)
   end

   private on_next_button(ev)
      local he
      (history_pos > 1) | fail
      he := history[history_pos -:= 1]
      update_grey()
      goto_dir(he.dir)
   end

   private on_focus_columns_button(ev)
      local f, c
      f := focus_columns_button.get_status()
      columns.set_accepts_focus(f)
      c := if /f then output else columns
      if is_live() then
         parent_dialog.set_focus(c)
      else
         set_remembered_focus(c)
   end

   private on_columns_focus(ev)
      best_focus := columns
   end

   private on_vt_focus(ev)
      best_focus := output
   end

   private open_search_panel()
      split.second.
         add(search_panel, 0).
         reset_layout().
         do_layout().
         invalidate()
      parent_dialog.set_focus(search_field)
   end

   private close_search_panel()
      split.second.
         remove(search_panel).
         reset_layout().
         do_layout().
         invalidate()
      parent_dialog.set_focus(output)
   end

   public search_msg(s)
      /s := ""
      search_label.set_label(s)
   end

   private on_search_field()
      output.do_search(search_field.get_contents())
   end

   private on_search_next()
      output.do_search_next()
   end

   private on_search_prev()
      output.do_search_prev()
   end

   private setup_search_panel()
      search_panel := Component().
         set_constraint("eol", &yes).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_layout(GridLayout().set_doi(0).set_dii(2).set_extra("cells"))
      search_close_button := IconButton().
         set_tooltip(TextPaint("Close")).
         connect(close_search_panel, Event.ACTION).
         set_no_click_focus(&yes).
         set_paint(ImagePaint().set_cache("gui.CLOSE_24"))
      search_panel.add(search_close_button)
      search_field := TextField().
         set_width(scale(150)).
         set_contents(u"").
         connect(on_search_field, Event.CONTENT_CHANGED).
         connect(on_search_field, Event.ACTION)
      search_panel.add(search_field)
      search_prev_button := IconButton().
         set_tooltip(TextPaint("Prev")).
         connect(self.on_search_prev, Event.ACTION).
         set_no_click_focus(&yes).
         set_paint(ImagePaint().set_cache("gui.PREV_24"))
      search_panel.add(search_prev_button)
      search_next_button := IconButton().
         set_tooltip(TextPaint("Next")).
         connect(self.on_search_next, Event.ACTION).
         set_no_click_focus(&yes).
         set_paint(ImagePaint().set_cache("gui.NEXT_24"))
      search_panel.add(search_next_button)
      search_label := Label().
         set_label("").
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("l_inset", 5).
         set_width(scale(75))
      search_panel.add(search_label)
   end

   private setup()
      local paint_2, paint_14, paint_27, paint_32, paint_45, paint_7, layout_4, paint_11, paint_37, paint_42, panel_4, paint_29, split_content_3, split_content_4, paint_9, layout_6, paint_13, paint_31, paint_6, layout_3, paint_10, paint_23, paint_41, paint, paint_3, paint_28, paint_8, border_1, layout_5, paint_12, paint_30, paint_40
      paint_10 := ImagePaint().
         set_cache("rpp.EXIT_24")
      paint_9 := TextPaint("Close")
      close_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_9).
         set_accel("c").
         connect(self.on_close_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_10)
      paint_8 := ImagePaint().
         set_cache("gui.HOME_24")
      paint := TextPaint("Home")
      home_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint).
         connect(self.on_home_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_8)
      paint_3 := ImagePaint().
         set_cache("gui.UP_24")
      paint_2 := TextPaint("Up")
      up_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_2).
         connect(self.on_up_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_3)
      paint_7 := ImagePaint().
         set_cache("gui.REFRESH_24")
      paint_6 := TextPaint("Refresh")
      refresh_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_6).
         connect(self.on_refresh_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_7)
      paint_12 := ImagePaint().
         set_cache("gui.PREV_24")
      paint_11 := TextPaint("Prev")
      prev_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_11).
         connect(self.on_prev_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_12)
      paint_14 := ImagePaint().
         set_cache("gui.NEXT_24")
      paint_13 := TextPaint("Next")
      next_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_13).
         connect(self.on_next_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_14)
      paint_41 := TextPaint("History")
      history_list := HistoryList().
         set_size(scale(37), scale(30)).
         clear_constraints().
         set_tooltip(paint_41).
         connect(self.on_history_list, Event.SELECTION_CHANGED)
      paint_45 := ImagePaint().
         set_cache("rpp.KEYBOARD_24")
      paint_42 := TextPaint("Columns focus")
      focus_columns_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_42).
         connect(self.on_focus_columns_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&yes).
         set_paint(paint_45)
      paint_23 := TextPaint("Filter")
      filter := EditList().
         set_size(scale(150)).
         set_align(Align.L, Align.B).
         clear_constraints().
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_tooltip(paint_23).
         connect(self.on_filter_action, Event.ACTION).
         connect(self.on_filter_content_changed, Event.CONTENT_CHANGED).
         set_selection_list([""])
      paint_28 := ImagePaint().
         set_cache("gui.FONT_24")
      paint_27 := TextPaint("Sort by name")
      name_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_27).
         connect(self.on_name_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_28)
      paint_30 := ImagePaint().
         set_cache("gui.CLOCK_24")
      paint_29 := TextPaint("Sort by date")
      date_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_29).
         connect(self.on_date_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_30)
      paint_32 := ImagePaint().
         set_cache("gui.FILESIZE_24")
      paint_31 := TextPaint("Sort by size")
      size_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_31).
         connect(self.on_size_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_32)
      paint_37 := TextPaint("Favourite directories")
      favourites_list := DirList().
         set_size(scale(37), scale(30)).
         clear_constraints().
         set_tooltip(paint_37).
         connect(self.on_favourites_list, Event.SELECTION_CHANGED)
      trail := FileTrailEx().
         set_size(scale(200), scale(20)).
         clear_constraints().
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0)
      layout_6 := GridLayout().
         set_doi(scale(0)).
         set_dii(scale(2)).
         set_extra("cells")
      panel_4 := Panel().
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_layout(layout_6).
         add(close_button).
         add(home_button).
         add(up_button).
         add(refresh_button).
         add(prev_button).
         add(next_button).
         add(history_list).
         add(focus_columns_button).
         add(filter).
         add(name_button).
         add(date_button).
         add(size_button).
         add(favourites_list).
         add(trail)
      self.add(panel_4)
      columns := Columns().
         set_size(scale(300), scale(300)).
         clear_constraints().
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("y_fill", &yes).
         set_constraint("y_weight", 1.0).
         connect(self.on_columns_focus, Event.GOT_FOCUS)
      layout_5 := GridLayout().
         set_doi(scale(0)).
         set_extra("cells")
      split_content_3 := Component().
         clear_constraints().
         set_layout(layout_5).
         add(columns)
      output := Vt().
         set_size(scale(100), scale(100)).
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("y_fill", &yes).
         set_constraint("y_weight", 1.0).
         connect(self.on_vt_focus, Event.GOT_FOCUS)
      layout_4 := GridLayout().
         set_doi(scale(0)).
         set_extra("cells")
      split_content_4 := Component().
         clear_constraints().
         set_layout(layout_4).
         add(output)
      split := Split().
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("y_fill", &yes).
         set_constraint("y_weight", 1.0).
         set_left(split_content_3).
         set_right(split_content_4)
      self.add(split)
      paint_40 := TextPaint("")
      border_1 := CompoundBorder().
         set_outer(SunkenBorder()).
         set_inner(EmptyBorder().
            set_l_inset(scale(3))).
         set_x_align(Align.L)
      message_label := MessageLabel().
         set_fg("red").
         clear_constraints().
         set_constraint("b_inset", scale(0)).
         set_constraint("l_inset", scale(0)).
         set_constraint("r_inset", scale(0)).
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_border(border_1).
         set_paint(paint_40)
      self.add(message_label)
      layout_3 := GridLayout().
         set_extra("cells")
      self.set_layout(layout_3)
   end
end

procedure usage(opts)
   local u
   ewrite("Usage: flowterm [OPTIONS] [ALL TAB OPTS] [DIRS/PER TAB OPTS]")
   options_help(opts)
   ewrite()
   help_line("Tab options begin with a ':', as follows.  If a parameter is omitted, then it is 'null', which is a valid setting for some keys.")
   ewrite()
   help_line(":max-list", "Maximize the space for the list, so the terminal is not visible.")
   help_line(":max-term", "Maximize the space for the terminal, so the files list is not visible.")
   help_line(":restore", "Return to normal split between file list and terminal.")
   help_line(":list-focus", "Allow keyboard focus in the file list.")
   help_line(":reorient, :re-orient", "Toggle the orientation of the file list/terminal split.")
   help_line(":sort-name", "Sort the file list by name, or if the file list is already sorted by name, toggle the sort order.")
   help_line(":sort-date", "As `sort-name`, but sort by date.")
   help_line(":sort-size", "As `sort-name`, but sort by size.")
   help_line(":show-name-only", "Show only the name in the file list.")
   help_line(":show-date", "Show name and date in the file list.")
   help_line(":show-size", "Show name and size in the file list.")
   help_line(":mix-entries", "Toggle whether or not to mix directories and files together in the list.")
   help_line(":show-hidden", "Toggle whether or not to show hidden files and directories in the list.")
   help_line(":sort-dirs", "Toggle whether or not to sort the directory portion of the list in the same way as the files (by default, the directories are always sorted by name).")
   help_line(":select", "Make this tab the selected tab.")
   help_line(":adjacent", "Add this tab adjacent to the current tab, rather than at the end of all the tabs.")
   help_line(":sh=STRING", "Specify the shell to run.  The default is null, meaning use the user's default shell.")
   help_line(":run=STRING", "Run the given string in the shell.")
   help_line(":font=FONT", "Set the font, which should be fixed width.  The default is the font 'fixed'.")
   help_line(":fg=COLOUR", "Specify the foreground colour.  The default is null, meaning use the dialog's foreground colour.")
   help_line(":bg=COLOUR", "Specify the background colour.  The default is null, meaning use the dialog's foreground colour.")
   help_line(":rev-fg=COLOUR", "Specify the reverse-mode foreground colour.  The default is null, meaning use the background colour.")
   help_line(":rev-bg=COLOUR", "Specify the reverse-mode background colour.  The default is null, meaning use the foreground colour.")
   help_line(":hist=INTEGER", "Specify the history size.  The default is 500.")
   help_line(":list-width=INTEGER", "The width of the list component in pixels. The default is 300 scaled pixels.")
   help_line(":list-height=INTEGER", "The height of the list component in pixels. The default is 300 scaled pixels.")
   help_line(":auto-close", "Automatically close the tab if the forked shell process ends.")
   help_line(":title=STRING" , "Set the title of the tab.  The default is null, meaning show the shell's current directory.")
   u := URL("http://objecticon.sourceforge.net/FlowTerm.html")
   ewrites("\nFor more details, visit ")
   if Files.is_flowterm_tty(FileStream.stderr) then
      ewrite(Files.begin_link(u), u.str(), Files.end_link())
   else
      ewrite(u.str())
end

procedure main(a)
   local d, t
   opts := options(a, [Opt("x",string,"The location of the 'flowterm-extras' directory; by default 'flowterm-extras' in your home directory.  This directory's 'bin' subdirectory is added to the front of the PATH variable"),
                       Opt("nx",,"Don't add any flowterm extras directory to the PATH.  The -x option is ignored"),
                       Opt("v",,"Verbose output"),
                       Opt("width",integer,"CHARS#The preferred width of the terminal, in characters.  This only applies to the first visible terminal tab."),
                       Opt("height",integer,"LINES#The preferred height of the terminal, in lines.  This only applies to the first visible terminal tab."),
                       Opt("t",string,"The window title, by default \"FlowTerm\"")],
                       usage)
   ImageCache.
      name_image("rpp.HELP_64", HELP).
      name_image("rpp.ABOUT_64", ABOUT).
      name_image("rpp.HOURGLASS_24", HOURGLASS).
      name_image("rpp.KEYBOARD_24", KEYBOARD).
      name_image("rpp.EXIT_24", EXIT)
   insert(Dialog.ROOT_WATTRIBS, "icon", Pixels(FLOWTERM_LOGO))
   glob_cmds := []
   while a[1,1] == ":" do
      put(glob_cmds, pop(a)[2:0])
   if *a = 0 then
      put(a, "")
   d := FlowTermDialog()
   d.do_tab_cmd(a) | stop(&why)
   t := \d.tabs.which_one | d.tabs.children[1]
   d.set_focus(t.remembered_focus)
   d.show_modal()
   if \opts["v"] then write("Exiting")
end

### Ivib-v2 layout: layouts/$.layout
