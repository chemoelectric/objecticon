$encoding UTF-8

package ipl.vt

import gui, io, lang, util, graphics(Window,Key,Selection,Mouse,Canvas), 
   net, ipl.lists, ipl.pdco, ipl.strings, ipl.graphics

# Current attributes.  Treated as immutable (except the font field), to alter a copy() is taken first.
package record Attr(fg, bg, underline, inverse, invisible, crossed, bold, italic, url, font)

package record SavedCursor(cx, cy, attr, charsets, curr_charset)

package record SavedBuffer(cx, cy, attr, charsets, curr_charset, 
                           top_margin, bottom_margin, tab_stops,
                           reverse_mode, origin_mode, wraparound_mode,
                           col_mode, allow_80_132_mode, insert_mode,
                           hide_cursor_mode, application_keypad_mode,
                           application_cursor_mode,
                           rows, cols, contents, history_size)

package record PopupElement(label, str)

package record Locn(x, y)

package class PopupElementItemPaint(ItemPaint)
   public get_width(W, data)
      return W.text_width(data.label)
   end

   public get_constant_height(W)
      return W.get_line_height()
   end

   public get_size(W, data)
      return Size(W.text_width(data.label), W.get_line_height())
   end

   public draw(W, data, x, y)
      W.draw_string(x, y + W.get_line_ascent(), data.label)
   end
end

package class KeyEntry()
   public const 
      bits,       # The bits which must be set in the mask set
      mask,       # The mask, ie the bits to be considered
      val,        # The code to send, or function to call
      data        # An arbitrary piece of user data

   public matches(i)
      if iand(mask, i) = bits then
         return
   end

   public new(bits, mask, val, data)
      self.bits := bits
      self.mask := mask
      self.val := val
      self.data := data
      return
   end
end

# Class for storing key code strings.
package class KeyTable()
   private const t

   public add1(code, bits, mask, val)
      return add(code, bits, mask, val) | syserr(&why)
   end

   public gen_codes()
      suspend key(t)
   end

   public gen_entries(code)
      local l
      if l := member(t, code) then
         suspend .!l
   end

   public add(code, bits, mask, val, data)
      local l, e
      iand(bits, mask) = bits | return error("invalid bits/mask combination")
      if l := member(t, code) then {
         # Given two entries, e and f, assume i matches both e and f.  Clearly i must
         # be be|bf|z for some other bits z.  Since both match
         # be = i&me and bf=i&mf. So
         # be & i & mf = bf & i & me.  Subsitute i:
         # be & mf & (be|bf|z) = bf & me & (be|bf|z)
         # be&mf | be&mf&bf | be&mf&z = be&bf&me | bf&me | bf&me&z.  Since me&z=mf&z=0 :
         # be&mf | be&mf&bf = be&bf&me | bf&me.  ie
         # be&mf(1|bf) = bf&me(1|be), ie
         # be&mf = bf&me
         every e := !l do {
            if iand(e.bits, mask) = iand(bits, e.mask) then
               return error("inconsistent key entry")
         }
      } else
         insert(t, code, l := [])
      put(l, KeyEntry(bits, mask, val, data))
      return self
   end

   # Remove a specific bits/mask entry for code or, with just one
   # parameter, all the entries for code.
   #
   public remove(code, bits, mask)
      local l, e
      l := member(t, code) | fail
      if /bits then
         delete(t, code)
      else {
         every e := !l do {
            if e.bits = bits & e.mask = mask then {
               ldel1(l, e)
               if *l = 0 then
                  delete(t, code)
               break
            }
         }
      }
      return self
   end

   public lookup(code, i)
      local e
      every e := !member(t, code) do {
         if e.matches(i) then
            return e
      }
   end

   public new()
      t := table()
      return
   end
end

# Part of a line
package class Segment()
   public const
      s,      # The string for this segment
      attr    # The attributes

   public new(s, attr)
      self.s := s
      self.attr := attr
      return
   end
end

# Represents one line
package class Row()
   public const
      l,     # List of Segments
      bg,    # Bg colour for right part of row not covered by segments (null -> current bg).
      join   # Line is notionally joined with next one (used to reflow).

   public new(l, bg, join)
      /l := []
      self.l := l
      self.bg := bg
      self.join := join
      return
   end
end

#
# This interface provides external required functionality for the terminal.
abstract class VtUI()
   public abstract link_left_clicked(url)
   public abstract link_middle_clicked(url)
   public abstract create_link_menu(url)
   public abstract create_context_menu()
   public abstract quieten_cursor()
   public abstract send_tty(s)
   public abstract vt_size_changed(cols, rows)
   public abstract msg(s, n)
   public abstract search_msg(s)
end

package class VtPrimarySelectionOwner(TextSelectionOwner)
   private parent

   protected get_text()
      return \parent.primary
   end

   public lost_ownership()
      parent.on_lost_primary_ownership()
   end

   public new(parent)
      self.parent := parent
      return
   end
end

package class Charset()
   public const id, src, dest

   public new(id, src, dest)
      self.id := id
      self.src := src
      self.dest := dest
      return
   end
end

package class VtView(DrawScrollAreaView)
   public initially()
      parent.synch_view_colours()
      DrawScrollAreaView.initially()
   end
end

#
# A VT emulator.
#
class Vt(LineBasedScrollArea, MenuMode)
   private
      primary_selection_owner,
      ui,                         # The VtUI instance providing external functionality.
      contents,                   # List of Rows
      tab_stops,                  # Set of column numbers.
      custom_keys,                # KeyTable for custom key settings.
      cursor_ticker,
      cursor_on,
      going_up,                   # Selection scrolling direction
      scroll_ticker,
      scroll_ticker_interval,
      highlight,                  # Link clicked on (shown red).
      last_highlight,             # Link last clicked, shown with a dotted rectangle
      held,                       # Link held by mouse down
      over,                       # Link mouse is over
      no_drag,                    # Don't allow drag to set the cursor
      got,                        # Raw input, a string.
      part_ch,                    # Partial utf-8 char, a string.
      buff,                       # Input buffer, a ucs string.
      input_handler_coex,
      attr,
      saved_cursor,               # A SavedCursor instance for implementing decset 1048
      saved_buffer,               # A SavedBuffer instance for implementing decset 1049
      popup,
      quieten                     # A flag to stop distracting in_chain cursor updates

   private readable
      verbose_flag,
      cursor_x,                   # The selection cursor/mark
      cursor_y,
      mark_x,
      mark_y,
      char_w,                     # Character width dimensions of the font in use.
      rows,                       # Size of the emulated screen
      cols,
      cx,                         # The cursor position (in screen co-ordinates)
      cy,
      top_margin,                 # Optional margins
      bottom_margin,
      origin_mode,                # Various mode flags
      reverse_mode,
      insert_mode,
      wraparound_mode,
      col_mode,
      allow_80_132_mode,
      application_keypad_mode,
      application_cursor_mode,
      hide_cursor_mode,
      text_selection,             # Current text selection, or null
      font_family,                # Font details
      font_size,
      primary,                    # Primary selection string, or null
      history_size,               # Size of history scroll lines; 0 -> no vsb
      vt_width,                   # Default width in chars, used by get_default_width()
      vt_height,                  # Default height in chars, used by get_default_height()
      reverse_fg,                 # Colours of reverse mode, or null implying true reverse.
      reverse_bg,
      normal_fg,                  # Colours of non-reverse mode, or null implying use cbwin colours.
      normal_bg,
      charsets,                   # List of 4 Charsets G0..G4
      curr_charset,               # Current charset 1=G0 etc.  
      search_term,                # Current string being searched for.
      search_increment_flag       # Should next search forward/backward be incremental? (ie from mark).

   private static const
      EMPTY_ATTR,
      KEY_TABLE,
      C, S, M, M4, M5, K, U, CSM,
      CHARSET

   public static const
      DEFAULT_HISTORY_SIZE,
      DEFAULT_VT_WIDTH,
      DEFAULT_VT_HEIGHT,
      DEFAULT_FONT,
      OSC_CHAR

   private static init()
      EMPTY_ATTR := Attr()
      C := 1
      S := 2
      M := 4
      M4 := 8
      M5 := 16
      K := 32
      U := 64
      CSM := C + S + M + M4 + M5
      KEY_TABLE := KeyTable()
      setup_key_table()
      CHARSET := table()
      setup_charsets()
      OSC_CHAR := '\x08-\x0D\x20-\x7E'
      DEFAULT_HISTORY_SIZE := env_int("OI_VT_DEFAULT_HISTORY_SIZE", 0) | 500
      DEFAULT_VT_WIDTH := env_int("OI_VT_DEFAULT_VT_WIDTH", 20) | 80
      DEFAULT_VT_HEIGHT := env_int("OI_VT_DEFAULT_VT_HEIGHT", 5) | 25
      DEFAULT_FONT := env_font("OI_VT_DEFAULT_FONT") | "fixed"
   end

   private static setup_charsets()
      insert(CHARSET, "0", Charset("DEC Special Character and Line Drawing",
                                   u"`abcdefghijklmnopqrstuvwxyz{|}~",
                                   u"◆▒␉␌␍␊°±␤␋┘┐┌└┼─├┤┴┬│≤≥π≠£·"))
      insert(CHARSET, "A", Charset("United Kingdom", u"#", u"£"))
      insert(CHARSET, "B", Charset("United States", u"", u""))
   end

   public static string_to_key_mask(s)
      local i, c
      i := 0
      every c := !s do {
         i := ior(i, case map(string(c)) of {
            "0" : 0
            "c" : C
            "s" : S
            "m" : M
            "4" : M4
            "5" : M5
            "k" : K
            "u" : U
            "*" : CSM
            default: fail
         })
      }
      return i
   end

   private static setup_key_table()
      add_cursor_key(Key.UP, "A")
      add_cursor_key(Key.DOWN, "B")
      add_cursor_key(Key.RIGHT, "C")
      add_cursor_key(Key.LEFT, "D")
      add_cursor_key(Key.HOME, "H")
      add_cursor_key(Key.END, "F")

      KEY_TABLE.add1("\b", 0, M, "\d")
      KEY_TABLE.add1("\b", M, M, "\e\d")
      KEY_TABLE.add1("\d", 0, 0, "\e[3~")

      add_std_key(Key.PGUP, "\e[5~")
      add_std_key(Key.PGDN, "\e[6~")
      add_std_key(Key.INSERT, "\e[2~")

      add_std_key(Key.F1, "\eOP")
      add_std_key(Key.F2, "\eOQ")
      add_std_key(Key.F3, "\eOR")
      add_std_key(Key.F4, "\eOS")
      add_std_key(Key.F5, "\e[15~")
      add_std_key(Key.F6, "\e[17~")
      add_std_key(Key.F7, "\e[18~")
      add_std_key(Key.F8, "\e[19~")
      add_std_key(Key.F9, "\e[20~")
      add_std_key(Key.F10, "\e[21~")
      add_std_key(Key.F11, "\e[23~")
      add_std_key(Key.F12, "\e[24~")
   end

   private static add_std_key(k, s)
      local l, r
      KEY_TABLE.add1(k, 0, CSM, s)
      if any(&digits, s[3]) then {
         l := s[1:4]
         r := s[4:0]
      } else {
         l := s[1:3] || "1"
         r := s[3:0]
      }
      KEY_TABLE.add1(k, S, CSM, l || ";2" || r)
      KEY_TABLE.add1(k, M, CSM, l || ";3" || r)
      KEY_TABLE.add1(k, C, CSM, l || ";5" || r)
      KEY_TABLE.add1(k, S+M, CSM, l || ";4" || r)
      KEY_TABLE.add1(k, C+M, CSM, l || ";7" || r)
      KEY_TABLE.add1(k, C+S, CSM, l || ";6" || r)
      KEY_TABLE.add1(k, CSM, CSM, l || ";8" || r)
   end

   private static add_cursor_key(k, c)
      KEY_TABLE.add1(k, 0, CSM+U, "\e[" || c)
      KEY_TABLE.add1(k, U, CSM+U, "\eO" || c)
      KEY_TABLE.add1(k, S, CSM, "\e[1;2" || c)
      KEY_TABLE.add1(k, M, CSM, "\e[1;3" || c)
      KEY_TABLE.add1(k, C, CSM, "\e[1;5" || c)
      KEY_TABLE.add1(k, S+M, CSM, "\e[1;4" || c)
      KEY_TABLE.add1(k, C+M, CSM, "\e[1;7" || c)
      KEY_TABLE.add1(k, C+S, CSM, "\e[1;6" || c)
      KEY_TABLE.add1(k, CSM, CSM, "\e[1;8" || c)
   end

   package on_lost_primary_ownership()
      primary := &null
      invalidate_region()
      clear_mark()
   end

   public create_view()
      return VtView()
   end

   public layout()
      check_changed_size()
      LineBasedScrollArea.layout()
   end

   # Set the width of the vt in characters.  The default is 80. Only
   # used if the size of the component is not set in pixels.
   #
   public set_vt_width(n)
      n := (0 < integer(n)) | runerr(101, n)
      self.vt_width := n
      return self
   end

   # Set the height of the vt in lines.  The default is 25.  Only used
   # if the size of the component is not set in pixels.
   #
   public set_vt_height(n)
      n := (0 < integer(n)) | runerr(101, n)
      self.vt_height := n
      return self
   end

   public get_default_width()
      return predict_total_width(integer(vt_width * char_w) + 2 * Gui.TEXT_INSET, Yes{ history_size > 0 })
   end

   public get_default_height()
      return predict_total_height(vt_height * get_line_height())
   end

   private check_changed_size()
      local old_cols, old_rows
      old_cols := \cols | 0
      old_rows := \rows | 0
      calc_size()
      if old_cols ~= cols | old_rows ~= rows then {
         ui.vt_size_changed(cols, rows)
         normalize_after_size_changed(old_cols, old_rows)
         trim_history()
         reset_margins()
         reset_tab_stops()
         invalidate_line_count()
         compute_and_invalidate()
      }
   end

   # This generates the rows so that multi-row lines (with join set)
   # are merged together and generated as one row.
   private unflowed()
      local r, m
      every r := !contents do {
         if /r.join then {
            if /m then
               suspend r
            else {
               put_all_segments(m, r.l)
               suspend Row(m, r.bg)
               m := &null
            }
         } else {
            /m := []
            put_all_segments(m, r.l)
         }
      }
      # The last line's continuation line is missing (perhaps it was
      # deleted).
      if \ (\r).join then
         return Row(m, r.bg)
   end

   # Given an x, y position in the current contents, this returns the
   # corresponding position in "unflowed" coordinates (ie, consistent
   # with the rows generated by unflowed() above).
   private unflow_loc(x, y)
      local r, i, j, l
      i := j := 1
      l := 0
      every r := !contents do {
         if i = y then {
            # If this is line is part of a larger line, and x is
            # beyond its end, then it makes sense to limit x to the
            # end of the line; otherwise the returned result would
            # notionally refer to a position some way into the next
            # line.  In any case, this shouldn't occur under normal
            # circumstances.
            /r.join | i = *contents | (x >:= line_len(r.l) + 1)
            return Locn(l + x, j)
         }
         if /r.join then {
            j +:= 1
            l := 0
         } else
            l +:= line_len(r.l)
         i +:= 1
      }
   end

   # Given an x, y position based on "unflowed" coordinates, returns
   # a new position based on the current (flowed) contents.
   private reflow_loc(x, y)
      local r, i, j, l
      i := j := 1
      l := 0
      every r := !contents do {
         if j = y & (/r.join | i = *contents | x <= l + line_len(r.l)) then
            return Locn(x - l, i)
         if /r.join then {
            j +:= 1
            l := 0
         } else
            l +:= line_len(r.l)
         i +:= 1
      }
   end

   private reflow(old_rows)
      local t, r, cursor, mark, cxy, p
      # Get cursor, mark and cx/cy in "normalized" unflowed coordinates.
      cursor := unflow_loc(cursor_x, \cursor_y)
      mark := unflow_loc(mark_x, \mark_y)
      cxy := unflow_loc(cx, *contents - old_rows + cy)
      # Now reflow the contents based on the new column width.
      t := []
      every r := unflowed() do {
         while line_len(r.l) > cols do {
            put(t, Row(split_upto(r, cols), r.bg, &yes))
            r := Row(split_from(r, cols), r.bg)
         }
         put(t, r)
      }
      contents := t

      # Ensure the reflowed contents is consistent with old_rows; pad
      # with blank lines so that it covers the screen.
      while *contents < old_rows do
         put(contents, Row(, attr.bg))

      # Finally, reset the cursor, mark and cx/cy, from their
      # normalized values to coordinates based on the new contents.
      if \cursor & p := reflow_loc(cursor.x, cursor.y) then {
         cursor_x := p.x
         cursor_y := p.y
      }
      if \mark & p := reflow_loc(mark.x, mark.y) then {
         mark_x := p.x
         mark_y := p.y
      }
      if \cxy & p := reflow_loc(cxy.x, cxy.y) then {
         cx := p.x
         cy := p.y - *contents + old_rows
         cy <:= 1
         cy >:= old_rows
      } 
   end

   private calc_size()
      local hsz
      # See notes for explanation.
      hsz := history_size
      hsz <:= (\saved_buffer).history_size
      cols := integer((predict_view_width(w, Yes{ hsz > 0 }) - 2 * Gui.TEXT_INSET) / char_w)
      cols >:= \col_mode
      cols <:= 16
      rows := predict_view_height(h) / get_line_height()
      rows <:= 1
   end

   private normalize_after_size_changed(old_cols, old_rows)
      # Firstly, reflow the content if the columns have changed.
      if old_cols ~= cols then
         reflow(old_rows)

      cx >:= cols + 1
      # The objective is to leave the value of cy_to_index() unchanged as we adjust *contents, rows and cy.
      # Say the old is i1 = *c1 - rows1 + cy1; the new is i2 = *c2 - rows2 + cy2
      if rows < old_rows then {
         if cy <= rows then {
            # We leave cy unchanged so for i1 = i2, *c1 - *c2 = rows1 - rows2
            # So we pull (old_rows - rows) rows from the end.
            every 1 to old_rows - rows do
               content_delete(*contents)
         } else {
            # Since cy is now out of range, we must set it.  So cy2 = rows2.  So i2 = *c2, and for i1 = i2,
            # *c1 - *c2 = rows1 - cy1 (ie the old distance to the end of the screen).
            # So we pull (old_rows - cy) rows from the end.
            every 1 to old_rows - cy do
               content_delete(*contents)
            cy := rows
         }
      } else {
         # rows >= old_rows, so we leave cy2 = cy1.  for i1 = i2, *c2 - *c1 = rows2 - rows1.  So we
         # add (rows - old_rows) new rows to the end.
         every 1 to rows - old_rows do
            put(contents, Row(, attr.bg))
      }
   end

   private reset_margins()
      top_margin := 1
      bottom_margin := rows
   end

   public initially()
      local s, l
      s := get_wattrib(WAttrib.FONT)
      l := check_font(s) | runerr(&why, self)
      font_family := l[1]
      font_size := l[2]
      char_w := l[3]
      LineBasedScrollArea.initially()
      cursor_ticker.start()
   end

   private static calc_font_width(W, s)
      local m, m2
      W.set_font(s) | fail
      m := W.text_width("m")
      (m = W.text_width("i")) | return error("font is not monospace")
      m2 := W.text_width(repl("m", 1000))
      return if m2 = m * 1000 then m else m2 / 1000.0
   end

   private check_font(s)
      local fam, size, width, W, t
      s ? {
         fam := tab(upto(',') | 0)
         (*fam > 0) | return error("font not in required format")
         if ="," then {
            t := tab(0)
            size := real(t) | return error("font not in required format")
            if any('+\-', t) then
               size +:= Window.get_default_font_size()
            size <:= 3.0
            size >:= 40.0
         } else
            size := Window.get_default_font_size()
      }
      s := fam || "," || size
      width := use {
         W := Window(),
         calc_font_width(W, s)
      } | fail
      return [fam, size, width]
   end

   # A wrapper around `set_font()`, which validates `s` as a valid
   # font and resets the component if necessary.
   #
   public set_vt_font(s)
      local seg, l
      s := string(s) | runerr(103, s)
      l := check_font(s) | fail
      set_font(s)
      if is_live() & not(l[1] == font_family & l[2] = font_size) then {
         invalidate_line_height()
         reset()
         # Update the font entry in all Attr records
         synch_font()
         every seg := !((!contents).l) do
            synch_font(seg.attr)
         synch_font((\saved_cursor).attr)
         if \saved_buffer then {
            synch_font(saved_buffer.attr)
            every seg := !((!saved_buffer.contents).l) do
               synch_font(seg.attr)
         }
      }
      return self
   end

   public finally()
      close_popup()
      scroll_ticker.stop()
      cursor_ticker.stop()
      LineBasedScrollArea.finally()
   end

   #
   # Provide input to the terminal
   #
   public input(s)
      got := string(s) | runerr(103, s)
      @input_handler_coex
      return self
   end

   private static is_partial_utf8(s)
      return *s < (5 > Text.get_utf8_seq_len(s[1]))
   end

   private wait_for_buff()
      local i
      while *buff = 0 do {
         # Note that *got will not be 0 here on the first time
         # through, since we are activated for the first time by
         # input().
         while *got = 0 do
            coact()
         # Add any partial utf-8 char saved from last time
         got := part_ch || got
         part_ch := ""
         # Try the simple, usual case first
         buff := ucs(got) | {
            # Find the last utf-8 char in got; may be part of a char
            i := *got
            while i > 1 & 127 < ord(got[i]) < 192 do
               i -:= 1
            # Now got[i:0] gives us the last utf-8 char or part of it.
            # Split got into got and part_ch, depending on whether the
            # last utf-8 sequence is partial or not.
            if is_partial_utf8(got[i:0]) then {
               part_ch := got[i:0]
               got := got[1:i]
            }
            # Assign to buff
            Text.liberal_ucs(got)
         }
         got := ""
       }
   end

   private get_chs(cs)
      local c
      wait_for_buff()
      buff ? {
         c := tab(many(cs)) | move(1)
         buff := tab(0)
      }
      return c
   end

   private get_ch()
      local c
      wait_for_buff()
      buff ? {
         c := move(1)
         buff := tab(0)
      }
      return c
   end

   private peek_ch()
      wait_for_buff()
      return buff[1]
   end

   private input_handler()
      local c
      repeat {
         c := get_chs(Gui.PRINTABLE_1)
         case string(c) of {
            "\r" : do_cr()
            "\n" : do_nl()
            "\e" : do_esc()
            "\b" : do_backspace()
            "\t" : do_tab()
            "\^g" : {}
            "\^o" : do_set_charset(1)
            "\^n" : do_set_charset(2)
            default: do_default_str(apply_charset(c, curr_charset))
         }
         parent_dialog.resynch_pointer()
      }
   end

   private do_set_charset(n)
      curr_charset := n
   end

   private apply_charset(s, n)
      local cs
      cs := charsets[n]
      return map(s, cs.src, cs.dest)
   end

   private do_tab()
      local i
      # If in pos cols+1 (or cols), do nothing.  In particular tab doesn't reset cx=cols+1 to cols.
      if cx >= cols then
         fail
      i := cx
      repeat {
         i +:= 1
         if (i >= cols) | member(tab_stops, i) then
            break
      }
      move_cursor(i)
   end

   private do_backspace()
      cx >:= cols
      move_cursor(cx - 1)
   end

   private read_params()
      local l, c, t
      l := []
      repeat {
         c := peek_ch()
         if any(&digits, c) then {
            t := get_chs(&digits)
            while any(&digits, peek_ch()) do
               t ||:= get_chs(&digits)
            put(l, integer(t))
         } else if c == u"\"" then {
            get_ch()  # opening "
            t := u""
            repeat {
               # This check is to avoid getting stuck in the loop.  ^C
               # will certainly be followed by a newline, or the user
               # will press newline to get the prompt, or the prompt
               # itself will produce a newline.
               if any('\r\n', peek_ch()) then
                  break
               c := get_chs(~'\r\n\"')
               if c == u"\"" then
                  break
               t ||:= c
            }
            put(l, t)
         } else if c == u";" then
            # Empty param
            put(l)
         if peek_ch() ~== u";" then
            break
         get_ch()  # skip ;
      }
      return l
   end

   private do_csi()
      local cmd, param
      cmd := if any('>?!', peek_ch()) then get_ch() else u""
      param := read_params()
      cmd ||:= get_ch()
      # See ecma 5.4
      while any(' !"#$%&\'()*+,\-./', cmd[-1]) do
         cmd ||:= get_ch()
      case string(cmd) of {
         "m" : every do_set_attr(int_params(param, 0))
         "!L" : do_set_link(param)
         "!P" : do_popup(param)
         "A" : do_cursor_up(int_param(param, 1, 1))
         "B" : do_cursor_down(int_param(param, 1, 1))
         "C" : do_cursor_right(int_param(param, 1, 1))
         "D" : do_cursor_left(int_param(param, 1, 1))
         "P" : do_delete_chars(int_param(param, 1, 1))
         "J" : do_erase_in_display(int_param(param, 1, 0))
         "K" : do_erase_in_line(int_param(param, 1, 0))
         "X" : do_erase_characters(int_param(param, 1, 1))
         "G" : do_move_cursor_x(int_param(param, 1, 1))
         "H" : do_move_cursor(int_param(param, 1, 1), int_param(param, 2, 1))
         "r" : do_set_margins(int_param(param, 1, 1), int_param(param, 2, rows))
         "c" : do_send_primary_device_attrs(int_param(param, 1, 0))
         ">c" : do_send_secondary_device_attrs(int_param(param, 1, 0))
         "@" : do_insert_blanks(int_param(param, 1, 1))
         "S" : do_scroll_up(int_param(param, 1, 1))
         "L" : do_insert_lines(int_param(param, 1, 1))
         "M" : do_delete_lines(int_param(param, 1, 1))
         "d" : do_vertical_pos_absolute(int_param(param, 1, 1))
         "e" : do_vertical_pos_relative(int_param(param, 1, 1))
         "f" : do_vertical_and_horizontal_pos(int_param(param, 1, 1), int_param(param, 2, 1))
         "h" : do_set_mode(int_param(param, 1))
         "l" : do_reset_mode(int_param(param, 1))
         "n" : do_device_status_report(int_param(param, 1))
         "?h" : do_dec_set(int_param(param, 1))
         "?l" : do_dec_reset(int_param(param, 1))
         "!p" : do_soft_reset()
         "g" : do_tab_clear(int_param(param, 1, 0))
         default : if \verbose_flag then write("csi not implemented: cmd=", image(cmd), "  params=", to_string(param))
      }
   end

   private do_device_status_report(n)
      local t
      case n of {
         5 : send("\e[0n")
         6 : { 
            # cy is relative to top_margin, for consistency with xterm (see vttest option 6,3).
            # cx may be in cols+1; xterm reports cols (but konsole reports cols+1).  Do as per xterm.
            t := if \origin_mode then cy - top_margin + 1 else cy
            send("\e[" || t || ";" || min(cx, cols) || "R")
         }
      }
   end

   private do_set_mode(n)
      case n of {
         4 : insert_mode := &yes
      }
   end

   private do_reset_mode(n)
      case n of {
         4 : insert_mode := &no
      }
   end

   private do_tab_clear(n)
      case n of {
         0 : delete(tab_stops, cx)
         3 : clear(tab_stops)
      }
   end

   private do_soft_reset()
      reset_term()
   end

   private do_full_reset()
      do_restore_cursor()
      do_use_normal_buffer()
      reset_term()
      do_erase_all()
      move_cursor(1, 1)
   end

   private do_dec_set(n)
      case n of {
         1 : do_application_cursor_keys_mode(&yes)
         3 : set_col_mode(132)
         5 : do_reverse_video(&yes)
         6 : origin_mode := &yes
         7 : wraparound_mode := &yes
         25 : do_hide_cursor(&no)
         40 : allow_80_132_mode := &yes
         1047 | 1049 : do_use_alternate_buffer()
         1048 : do_save_cursor()
      }
   end

   private do_dec_reset(n)
      case n of {
         1 : do_application_cursor_keys_mode(&no)
         3 : set_col_mode(80)
         5 : do_reverse_video(&no)
         6 : origin_mode := &no
         7 : wraparound_mode := &no
         25 : do_hide_cursor(&yes)
         40 : allow_80_132_mode := &no
         1047 | 1049 : do_use_normal_buffer()
         1048 : do_restore_cursor()
      }
   end

   private do_use_alternate_buffer()
      saved_buffer := SavedBuffer(cx, cy, attr, charsets, curr_charset, 
                                  top_margin, bottom_margin, tab_stops,
                                  reverse_mode, origin_mode, wraparound_mode,
                                  col_mode, allow_80_132_mode, insert_mode,
                                  hide_cursor_mode, application_keypad_mode,
                                  application_cursor_mode,
                                  rows, cols, contents, history_size)
      history_size := 0
      contents := []
      every 1 to rows do put(contents, Row())
      origin_mode := &no
      wraparound_mode := &yes
      cx := cy := 1
      col_mode := &no
      allow_80_132_mode := &no
      insert_mode := &no
      hide_cursor_mode := &no
      reset_charsets()
      attr := EMPTY_ATTR
      check_changed_size()
      clear_mark()
      reset_tab_stops()
      reset_margins()
      invalidate_line_count()
      compute_and_invalidate()
   end

   private do_use_normal_buffer()
      local old_cols, old_rows
      \saved_buffer | fail
      contents := saved_buffer.contents
      history_size := saved_buffer.history_size
      col_mode := saved_buffer.col_mode
      old_cols := cols
      old_rows := rows
      calc_size()
      if old_cols ~= cols | old_rows ~= rows then
         ui.vt_size_changed(cols, rows)
      if saved_buffer.cols ~= cols | saved_buffer.rows ~= rows then {
         # Normalize needs cy to be set for its calculations, then limits it (and cx).
         cx := saved_buffer.cx
         cy := saved_buffer.cy
         normalize_after_size_changed(saved_buffer.cols, saved_buffer.rows)      
         trim_history()
         reset_tab_stops()
         reset_margins()
      } else {
         top_margin := saved_buffer.top_margin
         bottom_margin := saved_buffer.bottom_margin
         tab_stops := saved_buffer.tab_stops
         move_cursor(saved_buffer.cx, saved_buffer.cy)
      }
      attr := saved_buffer.attr
      charsets := saved_buffer.charsets
      curr_charset := saved_buffer.curr_charset
      do_reverse_video(saved_buffer.reverse_mode)
      origin_mode := saved_buffer.origin_mode
      wraparound_mode := saved_buffer.wraparound_mode
      allow_80_132_mode := saved_buffer.allow_80_132_mode
      insert_mode := saved_buffer.insert_mode
      hide_cursor_mode := saved_buffer.hide_cursor_mode
      application_keypad_mode := saved_buffer.application_keypad_mode
      application_cursor_mode := saved_buffer.application_cursor_mode
      saved_buffer := &null
      clear_mark()
      invalidate_line_count()
      compute_and_invalidate()
   end

   private do_reverse_video(f)
      if reverse_mode ~===:= f then
         view.reset()
   end

   private set_col_mode(n)
      \allow_80_132_mode | fail
      col_mode := n
      do_erase_all()
      move_cursor(1, 1)
      check_changed_size()
   end

   private do_vertical_pos_absolute(n)
      move_cursor(, n)
   end

   private do_vertical_pos_relative(n)
      move_cursor(, cy + n)
   end

   private do_vertical_and_horizontal_pos(m, n)
      move_cursor(n, m)
   end

   private do_insert_lines(n)
      scroll_down(cy, n)
   end

   private do_scroll_up(n)
      scroll_up(bottom_margin, n)
   end

   private do_delete_lines(n)
      delete_lines(cy, n)
   end

   private do_insert_blanks(n)
      do_insert(repl(u" ", n))
   end

   private reset_tab_stops()
      tab_stops := Set{1 to cols by 8}
   end

   private reset_charsets()
      charsets := []
      every 1 to 4 do put(charsets, CHARSET["B"])
      curr_charset := 1
   end

   private reset_term()
      origin_mode := &no
      wraparound_mode := &yes
      cx := cy := 1
      col_mode := &no
      allow_80_132_mode := &no
      reverse_mode := &no
      insert_mode := &no
      application_keypad_mode := &no
      application_cursor_mode := &no
      hide_cursor_mode := &no
      reset_charsets()
      attr := EMPTY_ATTR
      if is_live() then {
         # Size may have changed since col_mode changed
         check_changed_size()
         clear_mark()
         # The next two need rows/cols to be set, so can only be done
         # if live.
         reset_tab_stops()
         reset_margins()
         # Since reverse_mode may have changed.
         view.reset()
      }
   end

   #
   # If set, some debug output is produced.
   #
   public set_verbose(f)
      self.verbose_flag := check_flag(f)
      return self
   end

   # Set the fg colour to use in reverse mode.
   #
   public set_reverse_fg(c)
      /c | Window.parse_color(c) | return error("invalid color")
      if reverse_fg ~===:= c then {
         if is_live() then
            view.reset()
      }
      return self
   end

   #
   # Set the bg colour to use in reverse mode.
   #
   public set_reverse_bg(c)
      /c | Window.parse_color(c) | return error("invalid color")
      if reverse_bg ~===:= c then {
         if is_live() then
            view.reset()
      }
      return self
   end

   # Set the fg colour to use in normal (non-reverse) mode.
   #
   public set_normal_fg(c)
      /c | Window.parse_color(c) | return error("invalid color")
      if normal_fg ~===:= c then {
         if is_live() then
            view.reset()
      }
      return self
   end

   #
   # Set the bg colour to use in non-reverse mode.
   #
   public set_normal_bg(c)
      /c | Window.parse_color(c) | return error("invalid color")
      if normal_bg ~===:= c then {
         if is_live() then
            view.reset()
      }
      return self
   end

   #
   # Set the history size; 0 implies no scrollbar.
   #
   public set_history_size(n)
      n := (0 <= integer(n)) | runerr(101, n)
      if history_size ~=:= n then {
         trim_history()
         invalidate_line_count()
         if is_live() then {
            check_changed_size()
            compute_and_invalidate()
         }
      }
      return self
   end

   #
   # A helper procedure to clear the history and screen content, and
   # move the cursor to (1, 1).
   #
   public clear()
      local n
      \rows | fail
      n := *contents - rows
      if n > 0 then {
         every 1 to n do
            content_delete(1)
         invalidate_line_count()
         compute_and_invalidate()
      }
      do_erase_all()
      do_move_cursor(1, 1)
      return self
   end

   #
   # Return the history size, but ignoring the value used by the
   # alternate buffer, if we are in that mode.
   #
   public get_actual_history_size()
      return .(\saved_buffer).history_size | .history_size
   end

   private do_send_primary_device_attrs(n)
      case n of {
         0 : send("\e[?1;2;75c")
      }
   end

   private do_send_secondary_device_attrs(n)
      case n of {
         0 : send("\e[>0;115;0c")
      }
   end

   private do_erase_in_display(n)
      case n of {
         0 : do_erase_below()
         1 : do_erase_above()
         2 : do_erase_all()
      }
   end

   private do_erase_in_line(n)
      case n of {
         0 : do_erase_right()
         1 : do_erase_left()
         2 : do_erase_line()
      }
   end

   private do_erase_characters(n)
      local i, r, m
      r := contents[i := cy_to_index()]
      cx >:= cols
      n >:= cols - cx + 1
      m := split_upto(r, cx - 1, &yes)
      put_segment(m, repl(u" ", n), attr)
      content_edit(i, split_from(r, cx + n - 1, m), r.bg, r.join)
      invalidate_line(i)
   end

   private do_erase_below()
      local i
      do_erase_right()
      i := cy_to_index()
      every content_edit(i + 1 to *contents,, attr.bg)
      invalidate_lines(i + 1, *contents)
   end

   private do_erase_above()
      local i, j
      do_erase_left()
      i := row_to_index(1)
      j := cy_to_index()
      every content_edit(i to j - 1,, attr.bg)
      invalidate_lines(i, j - 1)
   end

   private do_erase_all()
      every content_edit(row_to_index(1) to *contents,, attr.bg)
      view.invalidate()
   end

   # Change line i in the contents; the caller is responsible for invalidating the line i.
   private content_edit(i, l, bg, join)
      contents[i] := Row(l, bg, join)
      if \mark_y & region_contains(i) then {
         invalidate_region()
         clear_mark()
      }
   end

   private do_move_cursor(r, c)
      if \origin_mode then {
         r +:= top_margin - 1
         r >:= bottom_margin
      }
      move_cursor(c, r)
   end

   private do_move_cursor_x(c)
      move_cursor(c)
   end

   private do_set_margins(top, bottom)
      bottom <:= 1
      bottom >:= rows
      top <:= 1
      top >:= bottom
      top_margin := top
      bottom_margin := bottom
      if /origin_mode then
         move_cursor(1, 1)
      else
         move_cursor(1, top)
   end

   private static int_param(param, n, def)
      return (0 < integer(param[n])) | \def
   end

   private static int_params(param, def)
      local i
      if *param = 0 then
         return def
      every i := !param do
         suspend ((0 < integer(i)) | \def)\1
   end

   private static put_all_segments(l, others)
      if equals(l[-1].attr, others[1].attr) then {
         l[-1] := Segment(l[-1].s || others[1].s, others[1].attr)
         every put(l, others[2 to *others])
      } else
         every put(l, !others)
      return l
   end

   private static put_segment(l, s, attr)
      if equals(attr, l[-1].attr) then
         l[-1] := Segment(l[-1].s || s, attr)
      else
         put(l, Segment(s, attr))
   end

   private static split_upto(r, j, pad)
      local k, t, m, l
      l := r.l
      m := []
      k := 1
      while j >= *l[k].s do {
         put(m, l[k])
         j -:= *l[k].s
         k +:= 1
      }
      if j > 0 then {
         if t := l[k] then
            # We know j < *t.s from the above while loop
            put_segment(m, t.s[1:j+1], t.attr)
         else if \pad then
            put_segment(m, repl(u" ", j), Attr(, r.bg))
      }
      return m
   end

   private static split_from(r, j, m)
      local k, t, l
      l := r.l
      k := 1
      while j >= *l[k].s do {
         j -:= *l[k].s
         k +:= 1
      }
      /m := []
      if j > 0 & t := l[k] then {
         put_segment(m, t.s[j+1:0], t.attr)
         k +:= 1
      }
      while put(m, l[k]) do k +:= 1
      return m
   end

   private do_delete_chars(n)
      local i, r, m
      r := contents[i := cy_to_index()]
      cx >:= cols
      m := split_upto(r, cx - 1)
      content_edit(i, split_from(r, cx + n - 1, m), r.bg, r.join)
      invalidate_line(i)
   end

   private do_erase_right()
      local i, r
      r := contents[i := cy_to_index()]
      cx >:= cols
      content_edit(i, split_upto(r, cx - 1, &yes), attr.bg)
      invalidate_line(i)
   end

   private do_erase_left()
      local i, r, m
      r := contents[i := cy_to_index()]
      cx >:= cols
      m := [Segment(repl(u" ", cx), Attr(, attr.bg))]
      content_edit(i, split_from(r, cx, m), r.bg, r.join)
      invalidate_line(i)
   end

   private do_erase_line()
      local i, r
      r := contents[i := cy_to_index()]
      cx >:= cols
      content_edit(i,, attr.bg)
      invalidate_line(i)
   end

   private move_cursor(x, y)
      if \y then {
         invalidate_cursor()
         y <:= 1
         y >:= rows
         cy := y
      }
      if \x then {
         x <:= 1
         cx := x
      }
      cx >:= cols
      reset_blink()
      invalidate_cursor()
   end

   private do_cursor_up(n)
      local lim, y1
      lim := if cy < top_margin then 1 else top_margin
      y1 := cy - n
      y1 <:= lim
      move_cursor(, y1)
   end

   private do_cursor_down(n)
      local lim, y1
      lim := if cy > bottom_margin then rows else bottom_margin
      y1 := cy + n
      y1 >:= lim
      move_cursor(, y1)
   end

   private do_cursor_right(n)
      move_cursor(cx + n)
   end

   private do_cursor_left(n)
      cx >:= cols
      move_cursor(cx - n)
   end

   private static decode_list(l)
      local s, t
      t := []
      every s := !l do
         put(t, ucs(URL.percent_decode(s))) | fail
      return t
   end

   private do_popup(l)
      local t, e
      # Validate params; must be ucs encoded list, even number, and no empty ones.
      l := decode_list(l) | fail
      if (*l % 2 ~= 0) | /!l then
         fail
      t := []
      e := create !l
      while put(t, PopupElement(@e, @e))
      open_popup(t)
   end

   private do_set_link(l)
      attr := copy(attr)
      attr.url := URL(l[1]) | &null
   end

   # This is called (from view's initially) just after cbwin has been
   # initialized, and just before view.cbwin is to be initialized.
   package synch_view_colours()
      if /reverse_mode then {
         view.clear_wattribs()
         view.set_fg(\normal_fg)
         view.set_bg(\normal_bg)
      } else {
         view.set_fg(\reverse_fg | \normal_bg | cbwin.get_bg())
         view.set_bg(\reverse_bg | \normal_fg | cbwin.get_fg())
      }
   end

   private synch_font(a)
      local s
      /a := attr
      if \ (a.bold | a.italic) then {
         s := font_family
         if \a.bold then
            s ||:= ",bold"
         if \a.italic then
            s ||:= ",italic"
         s ||:= "," || font_size
      }
      a.font := s
   end

   # ESC[{n}m
   private do_set_attr(n)
      if n = 0 then
         # Keep just the url setting.
         attr := Attr(,,,,,,,, attr.url)
      else {
         attr := copy(attr)
         case n of {
            1 : {
               attr.bold := &yes
               synch_font()
            }
            3 : {
               attr.italic := &yes
               synch_font()
            }
            4 : attr.underline := &yes
            7 : attr.inverse := &yes
            8 : attr.invisible := &yes
            9 : attr.crossed := &yes
            22 : {
               attr.bold := &no
               synch_font()
            }
            23 : {
               attr.italic := &no
               synch_font()
            }
            24 : attr.underline := &no
            27 : attr.inverse := &no
            28 : attr.invisible := &no
            29 : attr.crossed := &no
            30: attr.fg := "black"
            31: attr.fg := "dark red"
            32: attr.fg := "dark green"
            33: attr.fg := "dark yellow"
            34: attr.fg := "blue"
            35: attr.fg := "purple"
            36: attr.fg := "dark cyan"
            37: attr.fg := "pale gray"
            39: attr.fg := &null

            40: attr.bg := "black"
            41: attr.bg := "dark red"
            42: attr.bg := "dark green"
            43: attr.bg := "dark yellow"
            44: attr.bg := "blue"
            45: attr.bg := "purple"
            46: attr.bg := "dark cyan"
            47: attr.bg := "pale gray"
            49: attr.bg := &null
         }
      }
   end

   private do_esc()
      local c
      c := get_ch()
      case string(c) of {
         "D" : do_index()
         "M" : do_reverse_index()
         "E" : do_next_line()
         "H" : do_tab_set()
         "#" : do_esc_hash()
         "[" : do_csi()
         "7" : do_save_cursor()
         "8" : do_restore_cursor()
         ">" : do_application_keypad_mode(&no)
         "=" : do_application_keypad_mode(&yes)
         "(" : do_designate_charset(1)
         ")" : do_designate_charset(2)
         "*" : do_designate_charset(3)
         "+" : do_designate_charset(4)
         "n" : do_set_charset(3)
         "o" : do_set_charset(4)
         "N" : do_single_shift(3)
         "O" : do_single_shift(4)
         "c" : do_full_reset()
         "^" : do_privacy_message()
         "_" : do_apc()
         "P" : do_dcs()
         "]" : do_osc()
         "X" : do_sos()
         default : if \verbose_flag then write("Unknown ESC char: ", c)
      }
   end

   # Read a string according to ecma 8.3.27, 8.3.89 and others.  The
   # stuck loop check is non-standard.
   private read_string1()
      local t, c
      t := u""
      repeat {
         # Avoid stuck loop; see comment in read_params() above.
         if any('\r\n', peek_ch()) then
            break
         c := get_chs(OSC_CHAR -- '\r\n\e')
         if c == u"\e" then {
            # ESC-\ terminates, as does ESC on its own.
            if peek_ch() == u"\\" then
               get_ch()
            break
         }
         if any(OSC_CHAR, c) then
            t ||:= c
         else
            break
      }
      return t
   end

   # Read a string according to ecma 8.3.128.  The stuck loop check is
   # non-standard.
   private read_string2()
      local t, c
      t := u""
      repeat {
         # Avoid stuck loop; see comment in read_params() above.
         if any('\r\n', peek_ch()) then
            break
         c := get_chs(~'\r\n\e')
         if c == u"\e" then {
            # Only ESC-\ terminates.
            if peek_ch() == u"\\" then {
               get_ch()
               break
            }
         }
         t ||:= c
      }
      return t
   end

   private do_privacy_message()
      read_string1()
   end

   private do_apc()
      read_string1()
   end

   private do_dcs()
      read_string1()
   end

   private do_osc()
      read_string1()
   end

   private do_sos()
      read_string2()
   end

   private do_application_keypad_mode(f)
      application_keypad_mode := f
   end

   private do_application_cursor_keys_mode(f)
      application_cursor_mode := f
   end

   private do_hide_cursor(f)
      if hide_cursor_mode ~===:= f then
         invalidate_cursor()
   end

   private do_single_shift(n)
      local c
      c := get_ch()
      do_default_str(apply_charset(c, n))
   end

   private do_designate_charset(n)
      local c
      c := get_ch()
      charsets[n] := member(CHARSET, string(c) | "B")
   end

   private do_save_cursor()
      saved_cursor := SavedCursor(cx, cy, attr, copy(charsets), curr_charset)
   end

   private do_restore_cursor()
      \saved_cursor | fail
      attr := saved_cursor.attr
      curr_charset := saved_cursor.curr_charset
      charsets := saved_cursor.charsets
      move_cursor(saved_cursor.cx, saved_cursor.cy)
      saved_cursor := &null
   end

   private do_tab_set()
      insert(tab_stops, cx)
   end

   private do_esc_hash()
      local c
      c := get_ch()
      case string(c) of {
         "8" : do_decaln()
         default : if \verbose_flag then write("Unkown ESC# char: ", c)
      }
   end

   private do_decaln()
      local s
      s := Segment(repl(u"E", cols), EMPTY_ATTR)
      every content_edit(row_to_index(1) to *contents, [s])
      view.invalidate()
   end

   private scroll_down(r, n)
      local i, j
      if r < 1 | r > bottom_margin then
         fail
      /n := 1
      i := row_to_index(r)
      j := row_to_index(bottom_margin)
      every 1 to n do {
         content_delete(j)
         content_insert(i)
      }
      view.invalidate()
   end

   # Trim the history list so that it is within range; caller must
   # invalidate line count.
   private trim_history()
      local n
      \rows | fail
      n := *contents - (rows + history_size)
      (n > 0) | fail
      every 1 to n do
         content_delete(1)
      # Adjust the vsb so that if we are above the bottom then the
      # line we're looking at stays the same.
      if not at_bottom() then
         vsb.set_value(vsb.value - n * line_height)
   end

   private scroll_up(r, n)
      local i, j, t
      if r < 1 | r > bottom_margin then
         fail
      /n := 1
      t := if r < top_margin then 1 else top_margin
      i := row_to_index(r)
      if t = 1 & history_size > 0 then {
         every 1 to n do
            content_insert(i + 1)
         trim_history()
         invalidate_line_count()
         compute_and_invalidate()
      } else {
         j := row_to_index(t)
         every 1 to n do {
            content_delete(j)
            content_insert(i)
         }
         view.invalidate()
      }
   end

   # Delete a line from the content; the caller must invalidate the view
   private content_delete(i)
      delete(contents, i)
      if \mark_y then {
         if region_contains(i) then
            clear_mark()
         else if cursor_y > i then {
            cursor_y -:= 1
            mark_y -:= 1
         }
      }
   end

   # Add a line to the content; the caller must invalidate the view
   private content_insert(i)
      insert(contents, i, Row(, attr.bg))
      if \mark_y then {
         if region_contains(i) then
            clear_mark()
         else if cursor_y > i then {
            cursor_y +:= 1
            mark_y +:= 1
         }
      }
   end

   private region_contains(i)
      return contained(i, i, cursor_y, mark_y)
   end

   private delete_lines(r, n)
      local i, j
      if r < 1 | r > bottom_margin then
         fail
      /n := 1
      if n > bottom_margin - r + 1 then
         fail
      i := row_to_index(r)
      j := row_to_index(bottom_margin)
      every 1 to n do {
         content_delete(i)
         content_insert(j)
      }
      view.invalidate()
   end

   private do_index()
      if cy = bottom_margin then {
         cx >:= cols
         scroll_up(cy)
      } else
         move_cursor(, cy + 1)
   end

   private do_reverse_index()
      if cy = top_margin then {
         cx >:= cols
         scroll_down(cy)
      } else
         move_cursor(, cy - 1)
   end

   private do_next_line()
      if cy = bottom_margin then {
         scroll_up(cy)
         move_cursor(1)
      } else
         move_cursor(1, cy + 1)
   end

   private cy_to_index()
      return *contents - rows + cy
   end

   private row_to_index(r)
      return *contents - rows + r
   end

   private do_cr()
      move_cursor(1)
   end

   private do_nl()
      if cy = bottom_margin then
         scroll_up(cy)
      else
         move_cursor(, cy + 1)
   end

   private do_crnl()
      do_cr()
      do_nl()
   end

   private do_insert_or_put(s)
      if /insert_mode then
         do_put(s)
      else
         do_insert(s)
   end

   private do_put(s)
      local i, r, m
      if *s = 0 then
         fail
      i := cy_to_index()
      r := contents[i]
      m := split_upto(r, cx - 1, &yes)
      put_segment(m, s, attr)
      split_from(r, cx + *s - 1, m)
      content_edit(i, m, r.bg, r.join)
      invalidate_line(i)
   end

   private truncate(l, lim)
      local n, t
      n := line_len(l)
      while n > lim do {
         t := l[-1]
         if *t.s <= n - lim then {
            n -:= *t.s
            pull(l)
         } else {
            l[-1] := Segment(t.s[1:lim - n], t.attr)
            break
         }
      }
   end

   private do_insert(s)
      local i, r, m
      if *s = 0 then
         fail
      i := cy_to_index()
      r := contents[i]
      m := split_upto(r, cx - 1, &yes)
      put_segment(m, s, attr)
      split_from(r, cx - 1, m)
      truncate(m, cols)
      content_edit(i, m, r.bg, r.join)
      invalidate_line(i)
   end

   private do_default_str(s)
      local s1, i, r
      if /wraparound_mode then {
         if *s > cols - cx then {
            s := s[1+:cols - cx] || s[-1]
            do_insert_or_put(s)
            cx := cols
         } else {
            do_insert_or_put(s)
            cx +:= *s
         }
      } else {
         while *s > 0 do {
            if cx > cols then {
               r := contents[i := cy_to_index()]
               contents[i] := Row(r.l, r.bg, &yes)
               do_crnl()
            }
            s ? {
               s1 := tab(cols - cx + 2 | 0)
               if *s1 = 0 then syserr("cx out of range")
               s := tab(0)
            }
            do_insert_or_put(s1)
            # Since *s1 <= cols - cx + 1, this leaves cx <= cols + 1
            cx +:= *s1
         }
      }
      reset_blink()
   end

   public keeps(e)
      return
   end

   public set_internal_fields()
      local bf
      bf := if at_bottom() then &yes
      LineBasedScrollArea.set_internal_fields()
      if \bf then goto_bottom()
   end

   public calculate_line_count()
      return *contents
   end

   public calculate_line_height()
      return view.cbwin.get_line_height()
   end

   public calculate_subject_width()
      return 0
   end

   public defer draw_line()

   public draw()
      local n, ss, row, seg, x1, W, W2, fg, bg, w1, want_fg, want_bg, want_font,
         default_bg, default_fg, default_font, a, r, font, y1, cr, info, xp, yp, i,
         cursor_i, leading

      cr := view.get_cbwin_clip()
      info := get_line_info(cr) | fail
      yp := cr.y - info.offset
      xp := get_subject_x() + Gui.TEXT_INSET

      use { 
         W := view.cbwin.clone(), 
         {
            bg := default_bg := W.get_bg()
            fg := default_fg := W.get_fg()
            font := default_font := get_wattrib(WAttrib.FONT)
            leading := W.get_absolute_leading()
            if /hide_cursor_mode then
               cursor_i := cy_to_index()

            #
            # Write the lines
            #
            every i := info.first to info.last do {
               # Don't draw partial lines at the top, since this looks poor
               # when running full-screen editing style apps (eg emacs)
               if yp >= view.y then {
                  row := contents[i]

                  x1 := xp
                  y1 := yp + leading
                  every seg := !row.l do {
                     a := seg.attr
                     ss := seg.s
                     want_fg := if \a.url === highlight then Style.FOCUS_COLOR else (\a.fg | default_fg)
                     want_bg := \a.bg | default_bg
                     if \a.inverse then
                        want_fg :=: want_bg
                     want_font := \a.font | default_font

                     W.set_fg(fg ~===:= want_fg)
                     W.set_bg(bg ~===:= want_bg)
                     W.set_font(font ~===:= want_font)

                     w1 := char_w * *ss
                     if want_bg ~=== default_bg then
                        W.erase_area(x1, yp, w1, line_height)

                     if /a.invisible then
                        W.draw_string(x1, y1 + W.get_font_ascent(), ss)

                     if \a.underline then
                        W.fill_rectangle(x1, y1 + W.get_font_ascent() + Gui.UNIT, w1, Gui.FINE_WIDTH)
                     else if \a.url ~=== last_highlight then
                        use { 
                           W2 := W.clone(),
                           W2.set_fg(EditRGBA(want_fg,,,, 16000)).      # 25% alpha of the current fg.
                                fill_rectangle(x1, y1 + W.get_font_ascent() + Gui.UNIT, w1, Gui.FINE_WIDTH)
                        }

                     if \a.crossed then
                        W.fill_rectangle(x1, y1 + (2 * W.get_font_ascent()) / 3, w1, Gui.FINE_WIDTH)

                     if \a.url === last_highlight then
                        Gui.style.draw_dashed_rectangle(W, x1, yp, w1, line_height, Gui.FINE_WIDTH)
                     if \a.url === over then
                        Gui.style.fill_over_rectangle(W, x1, yp, w1, line_height)

                     x1 +:= w1
                  }

                  if \row.bg ~=== default_bg then {
                     w1 := xp + cols * char_w - x1
                     W.set_bg(bg ~===:= row.bg)
                     W.erase_area(x1, yp, w1, line_height)
                  }

                  if \mark_y & 
                     ((mark_y <= i <= cursor_y) | (mark_y >= i >= cursor_y)) &
                     n := line_len(row.l) &
                     (r := if (mark_y < i < cursor_y) | (mark_y > i > cursor_y) then
                      Range(1, 1 + (0 < n))
                     else if i = mark_y = cursor_y then
                     range1(1, n + 1, cursor_x, mark_x)
                     else if i = mark_y then {
                        if mark_y < cursor_y then
                           range1(1, n + 1, mark_x, n + 1)
                        else
                           range1(1, n + 1, 1, mark_x)
                     } else if i = cursor_y then {
                        if mark_y > cursor_y then
                           range1(1, n + 1, cursor_x, n + 1)
                        else
                           range1(1, n + 1, 1, cursor_x)
                     })
                  then
                     Gui.style.fill_selection_rectangle(W, xp + (r.lo - 1) * char_w, yp,  
                                                        (r.hi - r.lo) * char_w, line_height)

                  if i = \cursor_i then {
                     if has_focus() & is_unshaded() then {
                        if cursor_on ~= 2 then
                           Gui.style.draw_text_cursor(W,
                                                      xp + (cx - 1) * char_w,
                                                      y1, 
                                                      view.cbwin.get_font_height())
                     } else 
                        Gui.style.draw_shadow_text_cursor(W,
                                                          xp + (cx - 1) * char_w,
                                                          y1, 
                                                          view.cbwin.get_font_height())
                  }
               }
               yp +:= line_height
            }
         }
      }
   end

   #
   # Set cursor from the given event
   #
   private set_cursor_from_pos(e)
      cursor_y := get_nearest_line_to_pointer(e)
      # Adding char_w/2 notionally places the dividing points in the
      # middle of chars; this is better for selection of regions with
      # the "xterm" mouse cursor.
      cursor_x := col_for_x(e.x + integer(char_w / 2))
      cursor_x >:= cols + 1
   end

   private reset_blink()
      cursor_on := -1
   end

   private clear_mark()
      reset_search()
      text_selection := mark_x := mark_y := &null
      return self
   end

   private static line_len(l)
      local n
      n := 0
      every n +:= *(!l).s
      return n
   end

   private contents_str(i)
      return line_str(contents[i].l)
   end

   private static line_str(l)
      local s
      s := u""
      every s ||:= (!l).s
      return s
   end

   private handle_ldrag(e)
      if \held then
         handle_mdrag(e)
      else if /no_drag then {
         if cursor_y > 1 & e.y < self.view.y then {
            going_up := &yes
            check_scroll_ticker(self.view.y - e.y)
         } else if cursor_y < *contents & e.y >= self.view.y + self.view.h then {
            going_up := &no
            check_scroll_ticker(e.y - (self.view.y + self.view.h))
         } else {
            invalidate_region()
            scroll_ticker.stop()
            if e.y < self.view.y then
               # cursor_y = 1
               cursor_x := 1
            else if e.y >= self.view.y + self.view.h then
               # cursor_y = *contents
               cursor_x := *contents_str(cursor_y) + 1
            else
               set_cursor_from_pos(e)
            invalidate_region()
         }
      }
   end

   private check_scroll_ticker(d)
      scroll_ticker_interval := Gui.style.distance2ticker_rate(d)
      scroll_ticker.change_time(scroll_ticker_interval)
      # Start it (if it isn't already running)
      scroll_ticker.start()
   end

   private scroll_tick()
      local i
      repeat {
         if \going_up then {
            if cursor_y > 1 & i := get_line_info() then {
               invalidate_region()
               cursor_y := i.first_whole - 1
               cursor_y <:= 1
               cursor_x := 1
               ensure_line_visible(cursor_y)
               invalidate_region()
            }
         } else {
            if cursor_y < *contents & i := get_line_info() then {
               invalidate_region()
               cursor_y := i.last_whole + 1
               cursor_y >:= *contents
               cursor_x := *contents_str(cursor_y) + 1
               ensure_line_visible(cursor_y)
               invalidate_region()
            }
         }
         scroll_ticker.sleep(scroll_ticker_interval)
      }
   end

   private cursor_tick()
      local t
      repeat {
         if /hide_cursor_mode & self.has_focus() & self.is_unshaded() & self.is_unhidden() then {
            t := cursor_on
            cursor_on := if dont_blink(self) then
               0
            else
               (cursor_on + 1) % 3

            if (t | cursor_on) = 2 then
               invalidate_cursor()
         }
         cursor_ticker.sleep(Gui.CURSOR_BLINK)
      }
   end

   private send_tr_nl(s)
      send(replace(s, u"\n", u"\r"))
   end

   private send(s)
      ui.send_tty(s)
   end

   public handle_paste(e)
      goto_bottom()
      parent_dialog.request_selection(Selection.CLIPBOARD, 
                                      [Selection.UTF8_STRING_TARGET, Selection.STRING_TARGET], 
                                      handle_paste_response, 
                                      e)
   end

   private handle_paste_response(target_type, data, e)
      send_tr_nl(text_convert(selection_convert(target_type, data), "ucs"))
   end

   public handle_paste_escaped(e)
      goto_bottom()
      parent_dialog.request_selection(Selection.CLIPBOARD, 
                                      [Selection.UTF8_STRING_TARGET, Selection.STRING_TARGET], 
                                      handle_paste_escaped_response, 
                                      e)
   end

   private handle_paste_escaped_response(target_type, data, e)
      send(Format.shell_escape(text_convert(selection_convert(target_type, data), "ucs")))
   end

   public handle_pgup(e)
      goto_first(get_line_info().first_whole - max(rows - 3, 1))
   end

   public handle_pgdn(e)
      goto_last(get_line_info().last_whole + max(rows - 3, 1))
   end

   public handle_copy(e)
      local s
      if s := \text_selection then
         parent_dialog.own_selection(Selection.CLIPBOARD, StaticTextSelectionOwner(s))
   end

   # Put a string as though typed by the user.
   public put_user_string(s)
      send(s)
      if is_live() then {
         quieten_cursor_and_clear_msg()
         goto_bottom()
      }
      return self
   end

   private handle_default_key(e)
      local ch
      ch := e.code
      if type(ch) == ("string" | "ucs") then {
         ch := text_convert(ch, "ucs") | fail
         if \e.meta then
            ch := u"\e" || ch
         put_user_string(ch)
      }
   end

   private handle_table_key(e)
      local i, ke
      i := 0
      if \e.shift then i +:= S
      if \e.ctrl then i +:= C
      if \e.meta then i +:= M
      if \e.meta4 then i +:= M4
      if \e.meta5 then i +:= M5
      if \application_keypad_mode then i +:= K
      if \application_cursor_mode then i +:= U
      if ke := custom_keys.lookup(e.code, i) then {
         ke.val(ke.data, e)
         return
      }
      if ke := KEY_TABLE.lookup(e.code, i) then {
         put_user_string(ke.val)
         return
      }
   end

   private handle_popup_key(e, src, ty)
      \popup | fail
      if member(Key.NAVIGATE ++ set("\r"), e.code) then {
         popup.fire(ty, e)
         return
      } else if e.code === "\e" then {
         close_all()
         return
      } else if type(e.code) == ("string" | "ucs") then {
         # A char has been pressed; close popup, fail, and so "fall
         # through" to the other key handlers
         close_all()
      }
   end

   private handle_key(e, src, ty)
      handle_popup_key(e, src, ty) | handle_table_key(e) | handle_default_key(e)
   end

   public gen_custom_key_codes()
      suspend custom_keys.gen_codes()
   end

   public gen_custom_key_entries(code)
      suspend custom_keys.gen_entries(code)
   end

   public add_custom_key(code, bits, mask, func, data)
      return custom_keys.add(code, bits, mask, func, data) & self
   end

   public remove_custom_key(code, bits, mask)
      return custom_keys.remove(code, bits, mask) & self
   end

   public reset_custom_keys()
      custom_keys := KeyTable()
      return self
   end

   private invalidate_link(l)
      local info, i, r
      info := get_line_info() | fail
      every i := info.first to info.last do {
         r := contents[i]
         if (!r.l).attr.url === l then
            invalidate_line(i, info)
      }
   end

   private set_last_highlight(l)
      if l ~=== last_highlight then {
         invalidate_link(\last_highlight)
         last_highlight := l
         invalidate_link(\last_highlight)
      }
      return self
   end

   private set_highlight(l)
      if l ~=== highlight then {
         set_last_highlight(\l)
         invalidate_link(\highlight)
         highlight := l
         invalidate_link(\highlight)
      }
      return self
   end

   private col_for_x(x)
      x := x - (view.x + Gui.TEXT_INSET)
      x <:= 0
      return 1 + integer(x / char_w)
   end

   private get_segment_for_pos(ev)
      local r, c, seg
      r := contents[get_line_under_pointer(ev)] | fail
      c := col_for_x(ev.x)
      every seg := !r.l do {
         if c <= *seg.s then
            return seg
         c -:= *seg.s
      }
   end

   private set_over(u)
      if u ~=== over then {
         invalidate_link(\over)
         over := u
         invalidate_link(\over)
         if /over then {
            ui.msg()
            view.set_pointer("xterm")
         } else {
            ui.msg(u.ucs())
            view.set_pointer("hand1")
         }
      }
   end

   private handle_mpress_response(target_type, data, e)
      send_tr_nl(text_convert(selection_convert(target_type, data), "ucs"))
   end

   private handle_mpress(e)
      parent_dialog.get_held_count() = 1 | fail
      if \over then {
         set_highlight(over)
         held := over
      } else {
         goto_bottom()
         parent_dialog.request_selection(Selection.PRIMARY, 
                                         [Selection.UTF8_STRING_TARGET, Selection.STRING_TARGET], 
                                         handle_mpress_response, 
                                         e)
      }
   end

   #
   # Return the currently selected text, or fail if none is selected.
   #
   public get_current_text_selection()
      return \.text_selection
   end

   private static ts_add(r, s, fl)
      if /fl then
         put(r, s)
      else
         r[-1] ||:= s
   end

   private calculate_text_selection()
      local r, s, t, a, fl
      text_selection := &null
      \mark_y | fail
      if mark_y < cursor_y then {
         a := contents[mark_y]
         s := line_str(a.l)
         fl := a.join
         r := [if t := range(1, *s + 1, mark_x, *s + 1) then s[t.lo:t.hi] else u""]
         every a := contents[mark_y + 1 to cursor_y - 1] do {
            ts_add(r, line_str(a.l), fl)
            fl := a.join
         }
         a := contents[cursor_y]
         s := line_str(a.l)
         ts_add(r, if t := range(1, *s + 1, 1, cursor_x) then s[t.lo:t.hi] else u"", fl)
      } else if mark_y > cursor_y then {
         a := contents[cursor_y]
         s := line_str(a.l)
         fl := a.join
         r := [if t := range(1, *s + 1, cursor_x, *s + 1) then s[t.lo:t.hi] else u""]
         every a := contents[cursor_y + 1 to mark_y - 1] do {
            ts_add(r, line_str(a.l), fl)
            fl := a.join
         }
         a := contents[mark_y]
         s := line_str(a.l)
         ts_add(r, if t := range(1, *s + 1, 1, mark_x) then s[t.lo:t.hi] else u"", fl)
      } else {
         # mark_y = cursor_y
         s := contents_str(mark_y)
         t := range1(1, *s + 1, cursor_x, mark_x) | fail
         r := [ s[t.lo:t.hi] ]
      }
      text_selection := cat_lines(r)
   end

   private handle_lrelease(e)
      if \held then {
         if \over then {
            set_highlight()
            ui.link_left_clicked(over)
         }
         held := &null
      } else {
         no_drag := &null
         scroll_ticker.stop()
         own_primary()
      }
   end

   private own_primary()
      calculate_text_selection()
      if primary := \text_selection then
         parent_dialog.own_selection(Selection.PRIMARY, primary_selection_owner)
   end

   public handle_select_all(e)
      mark_x := mark_y := 1
      cursor_y := *contents
      cursor_x := *contents_str(cursor_y) + 1
      reset_search()
      own_primary()
      view.invalidate()
   end

   private handle_mdrag(e)
      local seg
      \held | fail
      if (seg := get_segment_for_pos(e)) & (seg.attr.url === held) then {
         set_over(held)
         set_highlight(held)
      } else {
         set_over()
         set_highlight()
      }
   end

   private handle_mrelease(e)
      \held | fail
      if \over then {
         set_highlight()
         ui.link_middle_clicked(over, e)
      }
      held := &null
   end

   private invalidate_region()
      invalidate_lines(\cursor_y, \mark_y)
   end

   private invalidate_cursor()
      invalidate_line(cy_to_index())
   end

   public focus_changed(e) 
      if is_live() then
         invalidate_cursor()
   end

   private handle_double_click()
      local s, l, r, m, t
      l := unflow_loc(cursor_x, cursor_y) | fail
      r := Index{unflowed(), l.y} | fail
      s := line_str(r.l)
      t := l.x
      while any(~'\t ', s, t) do
         t +:= 1
      if m := reflow_loc(t, l.y) then {
         cursor_x := m.x
         cursor_y := m.y
      }
      t := l.x
      while any(~'\t ', s, t - 1) do
         t -:= 1
      if m := reflow_loc(t, l.y) then {
         mark_x := m.x
         mark_y := m.y
      }
      no_drag := &yes
   end

   private handle_triple_click()
      local s, l, r, m
      l := unflow_loc(cursor_x, cursor_y) | fail
      r := Index{unflowed(), l.y} | fail
      s := line_str(r.l)
      if m := reflow_loc(*s + 1, l.y) then {
         cursor_x := m.x
         cursor_y := m.y
      }
      if m := reflow_loc(1, l.y) then {
         mark_x := m.x
         mark_y := m.y
      }
      no_drag := &yes
   end

   private handle_lpress1(e)
      invalidate_region()
      reset_search()
      if \e.shift then {
         /self.mark_y := self.cursor_y
         /self.mark_x := self.cursor_x
         set_cursor_from_pos(e)
      } else {
         set_cursor_from_pos(e)
         case (parent_dialog.get_click_count() - 1) % 3 of {
            0 : {
               self.mark_y := self.cursor_y
               self.mark_x := self.cursor_x
            }
            1 : handle_double_click()
            2 : handle_triple_click()
         }
      }
      invalidate_region()
   end

   private handle_lpress(e)
      parent_dialog.get_held_count() = 1 | fail
      if \over then {
         set_highlight(over)
         held := over
      } else {
         handle_lpress1(e)
      }
   end

   private handle_rpress(e)
      local m, pm
      parent_dialog.get_held_count() = 1 | fail
      if /over then {
         if m := ui.create_context_menu() then {
            pm := PopupMenu()
            pm.popup(self, m, e.x, e.y)
         }
      } else {
         if m := ui.create_link_menu(over) then {
            set_highlight(over)
            set_over()
            pm := PopupMenu()
            pm.connect(on_popup_closed, Event.POPUP_CLOSED)
            pm.popup(self, m, e.x, e.y)
         }
      }
   end

   private on_popup_closed()
      set_highlight()
   end

   private quieten_cursor_and_clear_msg()
      quieten_cursor()
      # This is done in order to clear any info message which may
      # still persist even after quieten cursor state has begun.
      if parent_dialog.get_held_count() = 0 then
         ui.msg()
   end

   private quieten_cursor()
      (/quieten & parent_dialog.get_held_count() = 0) | fail
      set_over()
      # No need to synch_pointer since we call this method out of the
      # keyboard handler.
      quieten := &yes
      ui.quieten_cursor()
   end

   public unquieten_cursor()
      quieten := &null
   end

   private handle_move(ev)
      unquieten_cursor()
   end

   private handle_in_chain(ev)
      local seg, f
      (/quieten & parent_dialog.get_held_count() = 0) | fail
      if ev.code === (Key.CONTROL_L | Key.CONTROL_R) then {
         if /ev.release then
            f := &yes
      } else f := \ev.ctrl
      if /f & (seg := get_segment_for_pos(ev)) & \seg.attr.url then
         set_over(seg.attr.url)
      else
         set_over()
   end

   private handle_exit(e)
      parent_dialog.get_held_count() = 0 | fail
      set_over()
   end

   private handle_interrupted(e)
      set_highlight()
      set_over()
      held := &null
      if view.is_held(Mouse.LEFT_PRESS) then
         handle_lrelease()
   end

   #
   # Set the VtUI to use.
   #
   public set_ui(ui)
      self.ui := ui
      return self
   end

   public should_close(e)
      if (member(Mouse.PRESS, e.code) & 
                not(popup.in_region(e))) then 
         return
   end

   public gen_popup_components()
      return popup
   end

   public get_nesting_component()
   end

   public allow_nested(c)
   end

   public close_all()
      close_popup()
   end

   private close_popup()
      \self.popup | fail
      self.parent_dialog.set_focus(self)
      if popup.parent_dialog === parent_dialog then {
         self.popup.invalidate()
         self.parent_dialog.remove(popup)
      } else {
         self.parent_dialog.remove_popup(self.popup.parent_dialog)
         self.popup.parent_dialog.dispose()
      }
      self.popup := &null
      self.parent_dialog.exit_menu_mode(self)
   end

   private on_popup_selection()
      local pe
      pe := popup.object_get_selections()[1]
      close_popup()
      send_tr_nl(pe.str)
   end

   private open_popup(l)
      local spc_below, spc_right, d, dim, win,
         rs, max_h, max_w, info, px, py

      close_popup()
      (*l > 0) | fail
      px := view.x + Gui.TEXT_INSET + integer((cx - 1) * char_w) + Gui.TEXT_INSET
      info := get_line_info() | fail
      py := view.y - info.offset + (cy_to_index() - info.first) * line_height
      # Ensure cursor is entirely within view
      (view.y <= py & py + line_height - 1 < view.y + view.h) | fail
      # Get perfect alignment between the cursor line and the first line in the popup.
      py -:= Gui.BORDER_WIDTH

      win := parent_dialog.win
      dim := win.get_display_size()
      # Screen rectangle, in adjusted co-ordinates
      rs := Rect(-win.get_x() - win.get_dx(), -win.get_y() - win.get_dy(), dim.width, dim.height)

      # Check popup position is in the visible part of the screen.
      parent_dialog.intersect(rs).inside(px, py) | fail

      # Space available for popup limited by screen size
      spc_below := rs.y + rs.h - py
      spc_right := rs.x + rs.w - px

      max_h := dim[2]
      max_w := spc_right

      self.popup := ItemPaintList().
         set_item_paint(PopupElementItemPaint()).
         set_item_border(EmptyBorder().
                             set_insets(Gui.TEXT_INSET, Gui.TEXT_INSET, 0, 0).
                             set_x_align(Align.L)).
         set_wattrib_ancestor(view).
         connect(on_popup_selection, Event.SELECTION_CHANGED).
         set_select_mode(Select.ONE).
         set_accepts_focus(&no).
         set_draggable_cursor(&yes).
         set_motion_cursor(&yes).
         set_always_show_focus_cursor(&yes).
         set_selection_on_key_moves(&no).
         set_contents(l).
         set_z(self.parent_dialog.get_top_z())

      self.parent_dialog.add(popup)
      self.popup.set_ideal_size(scale(25), max_w,
                                scale(5), max_h)

      if popup.h_spec > spc_below then
         py -:= popup.h_spec - spc_below

      popup.
         set_pos(win.get_dx() + px,
                 win.get_dy() + py).
         resize()

      self.parent_dialog.enter_menu_mode(self)

      if Gui.allow_internal_popups() & parent_dialog.contains(popup) then {
         popup.invalidate()
      } else {
         # Remove popup from dialog and add to popup window.
         self.parent_dialog.remove(popup)
         d := PureDialog().
            set_canvas(Canvas.POPUP).
            set_width(popup.w_spec).
            set_height(popup.h_spec).
            set_dx(-popup.x).
            set_dy(-popup.y).
            set_x(win.get_x() + win.get_dx() + popup.x).
            set_y(win.get_y() + win.get_dy() + popup.y).
            copy_wattrib(WAttrib.DISPLAY, parent_dialog).
            add(popup)

         popup.set_pos(0, 0)
         parent_dialog.add_popup(d)
         d.show()
      }
   end

   public do_search(s)
      reset_search()
      if *s = 0 then {
         search_term := &null
         invalidate_region()
         clear_mark()
         ui.search_msg("No results")
      } else {
         search_term := map(s)
         do_search_prev()
      }
      return self
   end

   public do_search_prev()
      local i, j, num, curr, prev, last, matching, r
      \search_term | fail
      if \search_increment_flag then
         curr := unflow_loc(mark_x, \mark_y)
      num := 0
      i := 1
      every r := unflowed() do {
         every j := find(search_term, map(line_str(r.l))) do {
            num +:= 1
            last := Locn(j, i)
            if \curr & ((i < curr.y) | (i = curr.y & j < curr.x)) then {
               prev := last
               matching := num
            }
         }
         i +:= 1
      }
      if /prev := \last then
         matching := num
      done_search(prev, matching, num)
      return self
   end

   public do_search_next()
      local i, j, num, curr, first, matching, nxt, r, p
      \search_term | fail
      if \search_increment_flag then
         curr := unflow_loc(mark_x, \mark_y)
      num := 0
      i := 1
      every r := unflowed() do {
         every j := find(search_term, map(line_str(r.l))) do {
            num +:= 1
            p := Locn(j, i)
            /first := p
            if /nxt & \curr & ((i > curr.y) | (i = curr.y & j > curr.x)) then {
               nxt := p
               matching := num
            }
         }
         i +:= 1
      }
      if /nxt := \first then
         matching := 1
      done_search(nxt, matching, num)
      return self
   end

   private done_search(pos, matching, num)
      local at_c, at_m
      if \pos &
         at_m := reflow_loc(pos.x, pos.y) &
         at_c := reflow_loc(pos.x + *search_term, pos.y) then
      {
         invalidate_region()
         cursor_x := at_c.x
         cursor_y := at_c.y
         mark_x := at_m.x
         mark_y := at_m.y
         # Ensure the search selection is visible with context of at
         # least 3 lines above/below.
         ensure_region_visible(get_area_line_rect(cursor_y).
                                  union(get_area_line_rect(mark_y)).
                                  pad(0, 3 * line_height))
         own_primary()
         search_increment_flag := &yes
         invalidate_region()
         ui.search_msg(matching || "/" || num)
      } else if num > 0 then
         # This should only happen if we got some matches, but
         # couldn't reflow the selected one.
         ui.search_msg(num || " matches")
      else
         ui.search_msg("No results")
   end

   private reset_search()
      ui.search_msg()
      search_increment_flag := &no
   end

   public new()
      LineBasedScrollArea.new()
      reset_custom_keys()
      scroll_ticker := Dispatcher.new_task{scroll_tick()}
      cursor_ticker := Dispatcher.new_task{cursor_tick()}
      cursor_on := -1
      primary_selection_owner := VtPrimarySelectionOwner(self)
      contents := []
      buff := u""
      part_ch := got := ""
      set_accepts_focus(&yes)
      view.
         set_pointer("xterm").
         connect(handle_in_chain, Event.IN_POINT_CHAIN).
         connect(handle_move, Event.MOUSE_MOVEMENT).
         connect(handle_mdrag, Event.MOUSE_MIDDLE_DRAG).
         connect(handle_mrelease, Event.MOUSE_MIDDLE_RELEASE).
         connect(handle_exit, Event.MOUSE_EXIT).
         connect(handle_lpress, Event.MOUSE_LEFT_PRESS).
         connect(handle_rpress, Event.MOUSE_RIGHT_PRESS).
         connect(handle_mpress, Event.MOUSE_MIDDLE_PRESS).
         connect(handle_ldrag, Event.MOUSE_LEFT_DRAG).
         connect(handle_lrelease, Event.MOUSE_LEFT_RELEASE)
      connect(handle_key, Event.KEY_PRESS)
      connect(handle_interrupted, Event.INTERRUPTED)
      input_handler_coex := create input_handler()
      history_size := DEFAULT_HISTORY_SIZE
      set_font(DEFAULT_FONT)
      vt_width := DEFAULT_VT_WIDTH
      vt_height := DEFAULT_VT_HEIGHT
      reset_term()
      return
   end
end
