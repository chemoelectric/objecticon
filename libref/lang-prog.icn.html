<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>prog.icn</title></head><body><pre>
<a name="1"/>package lang
<a name="2"/>
<a name="3"/>import ipl.pdco
<a name="4"/>
<a name="5"/># In the methods below, the term "program" refers to the main
<a name="6"/># co-expression of either the root program, or a program loaded via
<a name="7"/># `Prog.load` below.   The parameters named `P` are always programs
<a name="8"/># and default to the currently executing program if omitted.
<a name="9"/>#
<a name="10"/>final abstract class Prog()
<a name="11"/>   public static const 
<a name="12"/>      # Integer flag for a pre-defined constant global, which will be
<a name="13"/>      # either a class, record or procedure.
<a name="14"/>      Const,
<a name="15"/>      # Integer flag for a global with package visibility
<a name="16"/>      Package,
<a name="17"/>      # Integer flag for a global with readable visibility
<a name="18"/>      Readable,
<a name="19"/>      # Integer flag for a global procedure which is a builtin function.
<a name="20"/>      Builtin
<a name="21"/>
<a name="22"/>   private static init()
<a name="23"/>      Const := 1
<a name="24"/>      Package := 2
<a name="25"/>      Readable := 4
<a name="26"/>      Builtin := 8
<a name="27"/>   end
<a name="28"/>
<a name="29"/>   # Load and return a program from file `s`.
<a name="30"/>   #
<a name="31"/>   # :Parameters :
<a name="32"/>   # :  `s` - the file name of the program.
<a name="33"/>   # :  `arglist` - an optional list of arguments to pass to the
<a name="34"/>   #                program's `main` procedure; they need not be
<a name="35"/>   #                strings.
<a name="36"/>   # :  `blocksize` - the optional size of the program's block region.
<a name="37"/>   #                If omitted, then the top-level program's block region
<a name="38"/>   #                size is used; if zero then the program shares its
<a name="39"/>   #                loader's block region.
<a name="40"/>   # :  `stringsize` - the size of the string region, with similar
<a name="41"/>   #                defaults to `blocksize`.
<a name="42"/>   #
<a name="43"/>   public static native load(s, arglist, blocksize, stringsize)
<a name="44"/>
<a name="45"/>   #
<a name="46"/>   # Generate the number of globals in program P
<a name="47"/>   #
<a name="48"/>   public static native get_n_globals(P)
<a name="49"/>
<a name="50"/>   #
<a name="51"/>   # Return the name of the given global.
<a name="52"/>   # :Parameters :
<a name="53"/>   # :  `q` - either a global name or number
<a name="54"/>   #
<a name="55"/>   public static native get_global_name(q, P)
<a name="56"/>
<a name="57"/>   #
<a name="58"/>   # Return the index number of the given global.
<a name="59"/>   # :Parameters :
<a name="60"/>   # :  `q` - either a global name or number
<a name="61"/>   #
<a name="62"/>   public static native get_global_index(q, P)
<a name="63"/>
<a name="64"/>   #
<a name="65"/>   # Return an integer flag value giving info about the global.
<a name="66"/>   # :Parameters :
<a name="67"/>   # :  `q` - either a global name or number
<a name="68"/>   #
<a name="69"/>   public static native get_global_flags(q, P)
<a name="70"/>
<a name="71"/>   #
<a name="72"/>   # Get the global named `s` in program P
<a name="73"/>   # :Parameters :
<a name="74"/>   # :  `q` - either a global name or number
<a name="75"/>   #
<a name="76"/>   public static get_global(q, P)
<a name="77"/>      local i
<a name="78"/>      i := get_global_index(q, P) | fail
<a name="79"/>      return case get_global_flags(i, P) of {
<a name="80"/>         Package+Readable : .get_global_impl(i, P)
<a name="81"/>         0 | Const | Const+Builtin : get_global_impl(i, P)
<a name="82"/>      }
<a name="83"/>   end
<a name="84"/>
<a name="85"/>   #
<a name="86"/>   # Get the global in program P, restricting results to named (constant) globals.
<a name="87"/>   # :Parameters :
<a name="88"/>   # :  `q` - either a global name or number
<a name="89"/>   #
<a name="90"/>   public static get_named_global(q, P)
<a name="91"/>      local i
<a name="92"/>      if i := get_global_index(q, P) &amp;
<a name="93"/>         get_global_flags(i, P) = (Const | Const+Builtin) then
<a name="94"/>         return get_global_impl(i, P)
<a name="95"/>   end
<a name="96"/>
<a name="97"/>   private static native get_global_impl(q, P)
<a name="98"/>
<a name="99"/>   #
<a name="100"/>   # Generate the global names in program P
<a name="101"/>   #
<a name="102"/>   public static get_global_names(P)
<a name="103"/>      suspend get_global_name(1 to get_n_globals(P), P)
<a name="104"/>   end
<a name="105"/>
<a name="106"/>   #
<a name="107"/>   # Generate the builtin functions.
<a name="108"/>   #
<a name="109"/>   public static native get_functions()
<a name="110"/>
<a name="111"/>   #
<a name="112"/>   # Generate the builtin operators.
<a name="113"/>   #
<a name="114"/>   public static native get_operators()
<a name="115"/>
<a name="116"/>   #
<a name="117"/>   # Generate the builtin keywords (as invocable functions).
<a name="118"/>   #
<a name="119"/>   public static native get_keywords()
<a name="120"/>
<a name="121"/>   #
<a name="122"/>   # Get the builtin function named `s`, or fail if it doesn't exist.
<a name="123"/>   #
<a name="124"/>   public static native get_function(s)
<a name="125"/>
<a name="126"/>   #
<a name="127"/>   # Get the builtin operator named `s`, with arity `n`, or fail if
<a name="128"/>   # it doesn't exist.
<a name="129"/>   #
<a name="130"/>   public static native get_operator(s, n)
<a name="131"/>
<a name="132"/>   #
<a name="133"/>   # Get the builtin keyword named `s` (as an invocable function), or fail
<a name="134"/>   # if it doesn't exist.
<a name="135"/>   #
<a name="136"/>   public static native get_keyword(s)
<a name="137"/>
<a name="138"/>   #
<a name="139"/>   # Get the location of global `s` in program P, if that data is
<a name="140"/>   # available.
<a name="141"/>   # :Parameters :
<a name="142"/>   # :  `q` - either a global name or number
<a name="143"/>   # :Returns :
<a name="144"/>   # :  a `Location` instance
<a name="145"/>   #
<a name="146"/>   public static get_global_location(q, P)
<a name="147"/>      return Location!get_global_location_impl(q, P)
<a name="148"/>   end
<a name="149"/>
<a name="150"/>   private static native get_global_location_impl(q, P)
<a name="151"/>
<a name="152"/>   #
<a name="153"/>   # Return the value of the keyword `s` in program P.
<a name="154"/>   #
<a name="155"/>   public static native eval_keyword(s, P)
<a name="156"/>
<a name="157"/>   #
<a name="158"/>   # Find the variable with name s in program P and return a variable
<a name="159"/>   # descriptor which points to its value.  Fails if `s` cannot be
<a name="160"/>   # resolved to a variable.
<a name="161"/>   #
<a name="162"/>   public static native get_variable(s, P)
<a name="163"/>
<a name="164"/>   #
<a name="165"/>   # Get the given program's event mask
<a name="166"/>   #
<a name="167"/>   public static native get_event_mask(P)
<a name="168"/>
<a name="169"/>   #
<a name="170"/>   # Set the given program's event mask
<a name="171"/>   #
<a name="172"/>   public static native set_event_mask(cs, P)
<a name="173"/>
<a name="174"/>   #
<a name="175"/>   # Set the given program's timer interval, for use with the E_Timer
<a name="176"/>   # event.
<a name="177"/>   #
<a name="178"/>   public static native set_timer_interval(i, P)
<a name="179"/>
<a name="180"/>   #
<a name="181"/>   # Get the timer interval for program P.
<a name="182"/>   #
<a name="183"/>   public static native get_timer_interval(P)
<a name="184"/>
<a name="185"/>   #
<a name="186"/>   # Get the next event from program P.
<a name="187"/>   #
<a name="188"/>   public static get_event(P)
<a name="189"/>      static res
<a name="190"/>      initial
<a name="191"/>         res := ProgEvent()
<a name="192"/>      if get_event_impl(P, res) then
<a name="193"/>         return .res
<a name="194"/>   end
<a name="195"/>
<a name="196"/>   private static native get_event_impl(P, res)
<a name="197"/>
<a name="198"/>   #
<a name="199"/>   # Get the number of milliseconds since the startup time of the given
<a name="200"/>   # program.
<a name="201"/>   #
<a name="202"/>   public static native get_runtime_millis(P)
<a name="203"/>
<a name="204"/>   #
<a name="205"/>   # Get the startup time (load time) of the given program, as the
<a name="206"/>   # number of microseconds since the Unix base epoch (1 Jan 1970).
<a name="207"/>   #
<a name="208"/>   public static native get_startup_micros(P)
<a name="209"/>
<a name="210"/>   #
<a name="211"/>   # Return info about the collections in the given program.
<a name="212"/>   # :Returns :
<a name="213"/>   # :  a `CollectionInfo` object
<a name="214"/>   #
<a name="215"/>   public static get_collection_info(P)
<a name="216"/>      return CollectionInfo!get_collection_info_impl(P)
<a name="217"/>   end
<a name="218"/>
<a name="219"/>   private static native get_collection_info_impl(P)
<a name="220"/>
<a name="221"/>   #
<a name="222"/>   # Return the number of collections of any type triggered by any
<a name="223"/>   # program.
<a name="224"/>   #
<a name="225"/>   public static native get_global_collection_count()
<a name="226"/>
<a name="227"/>   #
<a name="228"/>   # Return info about the allocations in the given program.
<a name="229"/>   # :Returns :
<a name="230"/>   # :  a `AllocationInfo` object
<a name="231"/>   #
<a name="232"/>   public static get_allocation_info(P)
<a name="233"/>      return AllocationInfo!get_allocation_info_impl(P)
<a name="234"/>   end
<a name="235"/>
<a name="236"/>   private static native get_allocation_info_impl(P)
<a name="237"/>
<a name="238"/>   #
<a name="239"/>   # Return info about the memory regions in the given program.
<a name="240"/>   # :Returns :
<a name="241"/>   # :  a `RegionInfo` object
<a name="242"/>   #
<a name="243"/>   public static get_region_info(P)
<a name="244"/>      local t, l, m
<a name="245"/>      t := get_region_info_impl(P)
<a name="246"/>      l := []
<a name="247"/>      while put(l, Region(pop(t[1]), pop(t[1]), pop(t[1]), pop(t[1])))
<a name="248"/>      m := []
<a name="249"/>      while put(m, Region(pop(t[2]), pop(t[2]), pop(t[2]), pop(t[2])))
<a name="250"/>      return RegionInfo(l, m)
<a name="251"/>   end
<a name="252"/>
<a name="253"/>   private static native get_region_info_impl(P)
<a name="254"/>
<a name="255"/>   #
<a name="256"/>   # Return the amount of stack (stack frames and local variables)
<a name="257"/>   # currently allocated by the given program.
<a name="258"/>   #
<a name="259"/>   # :Returns :
<a name="260"/>   # :  an integer
<a name="261"/>   #
<a name="262"/>   public static native get_stack_used(P)
<a name="263"/>end
<a name="264"/>
<a name="265"/>#
<a name="266"/># This class contains some useful methods for manipulating co-expressions.
<a name="267"/>#
<a name="268"/>final abstract class Coexpression()
<a name="269"/>   #
<a name="270"/>   # Return the given co-expression's activator (ie the value of
<a name="271"/>   # `&amp;source` when it was last active); fails if the co-expression has
<a name="272"/>   # never been activated.
<a name="273"/>   #
<a name="274"/>   # :Parameters :
<a name="275"/>   # :  `ce` - the co-expression, by default &amp;current
<a name="276"/>   #
<a name="277"/>   public static native get_activator(ce)
<a name="278"/>
<a name="279"/>   #
<a name="280"/>   # Return the program holding the current execution point
<a name="281"/>   # of the given co-expression.
<a name="282"/>   #
<a name="283"/>   # :Parameters :
<a name="284"/>   # :  `ce` - the co-expression, by default &amp;current
<a name="285"/>   #
<a name="286"/>   public static native get_program(ce)
<a name="287"/>
<a name="288"/>   #
<a name="289"/>   # Succeed iff this co-expression is the main co-expression of a
<a name="290"/>   # program.
<a name="291"/>   #
<a name="292"/>   # :Parameters :
<a name="293"/>   # :  `ce` - the co-expression, by default &amp;current
<a name="294"/>   #
<a name="295"/>   public static native is_main(ce)
<a name="296"/>
<a name="297"/>   #
<a name="298"/>   # Return the current procedure depth level of the given
<a name="299"/>   # co-expression (ie the value of &amp;level for that co-expression).
<a name="300"/>   #
<a name="301"/>   # :Parameters :
<a name="302"/>   # :  `ce` - the co-expression, by default &amp;current
<a name="303"/>   #
<a name="304"/>   public static native get_level(ce)
<a name="305"/>
<a name="306"/>   #
<a name="307"/>   # Output (to stderr) a traceback in the same format as that produced by
<a name="308"/>   # a runtime error.
<a name="309"/>   #
<a name="310"/>   # :Parameters :
<a name="311"/>   # :  `ce` - the co-expression, by default &amp;current
<a name="312"/>   # :  `act_chain` - if non-null, show the traceback for the activator chain, otherwise
<a name="313"/>   #            just show the traceback for this co-expression.
<a name="314"/>   #
<a name="315"/>   public static native traceback(ce, act_chain)
<a name="316"/>
<a name="317"/>   #
<a name="318"/>   # Output (to stderr) a dump of the stack of the given co-expression,
<a name="319"/>   # showing the internal format of the stack.
<a name="320"/>   #
<a name="321"/>   public static native print_stack(ce)
<a name="322"/>
<a name="323"/>   #
<a name="324"/>   # Return a list containing information about the stack of frames in the given
<a name="325"/>   # co-expression.  Each element is a `FrameInfo` instance.
<a name="326"/>   #
<a name="327"/>   # :Parameters :
<a name="328"/>   # :  `ce` - the co-expression, by default &amp;current
<a name="329"/>   # :  `lim` - the maximum number of frames to put in the list, by default 
<a name="330"/>   #              all frames
<a name="331"/>   #
<a name="332"/>   public static get_stack_info(ce, lim)
<a name="333"/>      local l
<a name="334"/>      every put(l := [], FrameInfo!get_stack_info_impl(ce, lim))
<a name="335"/>      return l
<a name="336"/>   end
<a name="337"/>
<a name="338"/>   #
<a name="339"/>   # This is like `get_stack_info`, but just returns what would be the
<a name="340"/>   # first element of the list, which represents the current procedure
<a name="341"/>   # frame of the given co-expression.
<a name="342"/>   #
<a name="343"/>   # :Parameters :
<a name="344"/>   # :  `ce` - the co-expression, by default &amp;current
<a name="345"/>   #
<a name="346"/>   public static get_current_frame_info(ce)
<a name="347"/>      return FrameInfo!get_stack_info_impl(ce, 1)
<a name="348"/>   end
<a name="349"/>
<a name="350"/>   private static native get_stack_info_impl()
<a name="351"/>end
<a name="352"/>
<a name="353"/>#
<a name="354"/># Contains some information about a frame in a stack.
<a name="355"/>#
<a name="356"/>final class FrameInfo()
<a name="357"/>   public const
<a name="358"/>      # The name of the procedure
<a name="359"/>      proc, 
<a name="360"/>      # The args the procedure was called with, as image strings
<a name="361"/>      args,
<a name="362"/>      # The name of the file of the current execution point
<a name="363"/>      file,
<a name="364"/>      # The line number of the current execution point
<a name="365"/>      line
<a name="366"/>
<a name="367"/>   package new(proc, args, file, line)
<a name="368"/>      self.proc := proc
<a name="369"/>      self.args := args
<a name="370"/>      self.file := file
<a name="371"/>      self.line := line
<a name="372"/>      return
<a name="373"/>   end
<a name="374"/>end
<a name="375"/>
<a name="376"/>#
<a name="377"/># This class contains information about the garbage collections
<a name="378"/># carried out by a program.
<a name="379"/>#
<a name="380"/>final class CollectionInfo()
<a name="381"/>   public const
<a name="382"/>      # The number of collections requested by the `collect()` function.
<a name="383"/>      user_requests, 
<a name="384"/>      # The number of collections requested during stack allocations.
<a name="385"/>      stack_requests, 
<a name="386"/>      # The number of collections requested during string allocations.
<a name="387"/>      string_requests, 
<a name="388"/>      # The number of collections requested during block allocations.
<a name="389"/>      block_requests
<a name="390"/>
<a name="391"/>   #
<a name="392"/>   # Return the total of all four types.
<a name="393"/>   #
<a name="394"/>   public get_total()
<a name="395"/>      return user_requests + stack_requests + string_requests + block_requests
<a name="396"/>   end
<a name="397"/>
<a name="398"/>   package new(user_requests, stack_requests, string_requests, block_requests)
<a name="399"/>      self.user_requests := user_requests
<a name="400"/>      self.stack_requests := stack_requests
<a name="401"/>      self.string_requests := string_requests
<a name="402"/>      self.block_requests := block_requests
<a name="403"/>      return
<a name="404"/>   end
<a name="405"/>end
<a name="406"/>
<a name="407"/>#
<a name="408"/># This class returns the total amounts allocated by a program in each
<a name="409"/># of its regions.
<a name="410"/>#
<a name="411"/>final class AllocationInfo()
<a name="412"/>   public const
<a name="413"/>      # The total allocated in the string region.
<a name="414"/>      string_total,
<a name="415"/>      # The total allocated in the block region.
<a name="416"/>      block_total
<a name="417"/>
<a name="418"/>   #
<a name="419"/>   # The total in all regions.
<a name="420"/>   #
<a name="421"/>   public get_total()
<a name="422"/>      return string_total + block_total
<a name="423"/>   end
<a name="424"/>
<a name="425"/>   package new(string_total, block_total)
<a name="426"/>      self.string_total := string_total
<a name="427"/>      self.block_total := block_total
<a name="428"/>      return
<a name="429"/>   end
<a name="430"/>end
<a name="431"/>
<a name="432"/>#
<a name="433"/># This class contains information about a program's memory allocation
<a name="434"/># regions.
<a name="435"/>#
<a name="436"/>final class RegionInfo()
<a name="437"/>   public const
<a name="438"/>      # A list of `Region` instances, one for each string region
<a name="439"/>      # allocated.
<a name="440"/>      string_regions, 
<a name="441"/>      # A list of `Region` instances, one for each block region
<a name="442"/>      # allocated.
<a name="443"/>      block_regions
<a name="444"/>
<a name="445"/>   # Return a `Region` instance representing the sum of all the string
<a name="446"/>   # regions.
<a name="447"/>   #
<a name="448"/>   public get_string_total()
<a name="449"/>      return Region.sum_list(string_regions)
<a name="450"/>   end
<a name="451"/>
<a name="452"/>   # Return a `Region` instance representing the sum of all the block
<a name="453"/>   # regions.
<a name="454"/>   #
<a name="455"/>   public get_block_total()
<a name="456"/>      return Region.sum_list(block_regions)
<a name="457"/>   end
<a name="458"/>
<a name="459"/>   package new(string_regions,
<a name="460"/>               block_regions)
<a name="461"/>      self.string_regions := string_regions
<a name="462"/>      self.block_regions := block_regions
<a name="463"/>      return
<a name="464"/>   end
<a name="465"/>end
<a name="466"/>
<a name="467"/>#
<a name="468"/># This class contains info about an allocated memory region.
<a name="469"/>#
<a name="470"/>final class Region()
<a name="471"/>   public const 
<a name="472"/>      # The amount used
<a name="473"/>      used,
<a name="474"/>      # The size of the space
<a name="475"/>      size,
<a name="476"/>      # The number of times compacted
<a name="477"/>      compacted,
<a name="478"/>      # Flag indicating whether this region is current
<a name="479"/>      current
<a name="480"/>
<a name="481"/>   #
<a name="482"/>   # Add up the elements in a list of `Region`s.
<a name="483"/>   #
<a name="484"/>   public static sum_list(l)
<a name="485"/>      return Region(Sum{ (!l).used }, Sum{ (!l).size })
<a name="486"/>   end
<a name="487"/>
<a name="488"/>   #
<a name="489"/>   # Return the amount free.
<a name="490"/>   #
<a name="491"/>   public get_free()
<a name="492"/>      return size - used
<a name="493"/>   end
<a name="494"/>
<a name="495"/>   package new(used, size, compacted, current)
<a name="496"/>      self.used := used
<a name="497"/>      self.size := size
<a name="498"/>      self.compacted := compacted
<a name="499"/>      self.current := current
<a name="500"/>      return
<a name="501"/>   end
<a name="502"/>end
<a name="503"/>
<a name="504"/>#
<a name="505"/># An event from a program's event queue.
<a name="506"/>#
<a name="507"/>class ProgEvent()
<a name="508"/>   private readable
<a name="509"/>      code, value
<a name="510"/>end
</pre></body></html>
