############################################################################
#
#       File:     printf.icn
#
#       Subject:  Procedures for printf-style formatting
#
#       Author:   William H. Mitchell
#
#       Date:     July 20, 2005
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#       Contributors:   Cheyenne Wills, Phillip Lee Thomas, Michael Glass
#
############################################################################

package ipl.printf

import
   io(stop, ewrites, writes),
   util(Format, need_integer, need_text, need_real, need_list),
   lang(to_string)

# Returns a `printf` format as a string result.
procedure sprintf(format, args[])
   return doprnt(format, args)
end

# Outputs a `printf` format to the given file.
procedure fprintf(file, format, args[])
   return writes(file, doprnt(format, args))
end

# Outputs a `printf` format to stderr.
procedure eprintf(format, args[])
   return ewrites(doprnt(format, args))
end

# Set `&why` from a `printf` format, and fail.
procedure whyf(format, args[])
   &why := doprnt(format, args)
end

# Call `stop()` with the result of a `printf` format.
procedure stopf(format, args[])
   stop(doprnt(format, args))
end

#
# This is like `sprintf`, but the second argument is a list of the
# arguments used by the format string.  Thus
#
# ~
#    sprintf("%d %d", 100, 200)
# ~
# and
# ~
#    lprintf("%d %d", [100, 200])
# ~
#
# are equivalent.
#
procedure lprintf(format, args)
   return doprnt(format, need_list(args))
end

#
# Outputs a C-style `printf` format to stdout.
#
# The specifier format is
# ~
#     %[index$]<flags><width>.<precision><char>
# ~
#  <flags> can be :-
#  *   0 - pad fields with zeroes instead of spaces; this may
#          not give sensible results with some numerical formats,
#          eg signed numbers or left adjusted numbers.
#  *   ' - for formats d, r, e, use commas to separate thousands
#  *   - - left adjust fields instead of right adjust
#  *   S - for formats r, e, replace trailing fractional zeroes
#          with spaces
#  *   Z - for formats r, e, means drop trailing fractional
#          zeroes altogether
#  *   + - for numeric formats, add a leading + to positive
#          numbers
#
# The optional "index$" specifier indicates the argument index to which
# this specifier applies, rather than the next argument in sequence.
#
# The optional width specifies the field width.  It may be "*", in
# which case an argument is consumed to give the width, or
# "*<index>$", indicating which argument to use.
#
# The optional precision (which may also be a "*") means :-
# *  for string formats (s, i, t) the maximum string length;
# *  for integer formats (d, x, X, o, b), the minimum number of
#    digits; leading zeroes are added if needed.
# *  for real formats (r, e), the number of digits in the
#    fractional part.
#
# The formats are :-
# *   %d  decimal number
# *   %s  string
# *   %x  hex lower case
# *   %X  hex upper case
# *   %o  octal
# *   %b  binary
# *   %i  image() result
# *   %t  to_string() result
# *   %r  real decimal
# *   %e  real in exponential format
# *   %E  real in exponential format, with a capital E in
#         the result
# *   %w  the value of &why
#
procedure printf(format, args[])
   return writes(doprnt(format, args))
end

# Get a positional param of the form <int>$, or fail.
package procedure optpos()
   return 1(integer(tab(many(&digits ++ '\-'))), ="$")
end

# A helper class to process the arguments
package class Args()
   private a, e

   public get(i)
      return if /i then @e else a[i]
   end

   public intparam()
      local a, i
      return if ="*" then {
         # Optional *N$ form
         i := optpos()
         a := get(i)
         need_integer(a)
      } else
         integer(tab(many(&digits)))
   end

   public new(x)
      a := x
      e := create !a
      return
   end
end

package procedure one(args)  
   local v, a, just, width, conv, prec, pad, flag, apos
   move(1)     # Move over %
   # Get the optional positional specifier, eg "3$"
   apos := optpos()
   flag := cset(tab(many('0\'\-+SZ'))) | ''
   # Convert flags to those used by Format.numeric_to_string
   if any(flag, "'") then flag ++:= ','
   if any(flag, "S") then flag ++:= 's'
   if any(flag, "Z") then flag ++:= 'z'
   just := if any(flag, "-") then left else right
   if any(flag, "0") then pad := "0"
   width := args.intparam()
   if ="." then prec := args.intparam()
   conv := move(1) | ""

   if any('dsxXobitreE', conv) then {
      # Formats that take an argument.
      a := args.get(apos)
      case string(conv) of {
         "d": v := decimal(a, prec, flag)
         "s": v := str(a, prec)
         "x": v := map(intstr(a, prec, flag))
         "X": v := intstr(a, prec, flag)
         "o": v := intstr(a, prec, flag, 8)
         "b": v := intstr(a, prec, flag, 2)
         "i": v := str(image(a), prec)
         "t": v := str(to_string(a), prec)
         "r": v := fixnum(a, prec, flag)
         "e": v := eformatstr(a, prec, flag ++ 'e')
         "E": v := eformatstr(a, prec, flag ++ 'E')
      }
   } else {
      # Formats that don't take an argument.
      case string(conv) of {
         "w": v := str(&why, prec)
         default: v := str(conv, prec)
      }
   }
   if \width & *v < width then
      v := just(v, width, pad)
   return v
end

package procedure doprnt(format, args)
   local out
   out := ""
   args := Args(args)
   format ? repeat {
      out ||:= tab(upto('%') | 0)
      if pos(0) then
         break
      out ||:= one(args)
   }
   return out
end

package procedure str(x, prec)
   x := need_text(x)
   return x[1:(\prec+1)|0]
end

package procedure intstr(x, prec, flag, base)
   local v
   x := need_integer(x)
   v := Format.int_to_string(x, base, prec)
   if any(flag, "+") & x >= 0 then
      v := "+" || v
   return v
end

package procedure fixnum(x, prec, flag)
   /prec := 6
   x := need_real(x)
   return Format.numeric_to_string(x, prec, flag)
end

package procedure decimal(x, prec, flag)
   x := need_integer(x)
   # Limitation: if we have a precision (padded to min prec digits),
   # then we can't have commas.
   return if \prec then
      intstr(x, prec, flag, 10)
   else
      Format.numeric_to_string(x, 0, flag)
end

# e-format:  [-]m.ddddddE(+|-)xxx
#
package procedure eformatstr(x, prec, flag)
   /prec := 6
   x := need_real(x)
   return Format.numeric_to_string(x, prec, flag)
end
