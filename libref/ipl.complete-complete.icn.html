<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>complete.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     complete.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedure to complete partial input string
<a name="6"/>#
<a name="7"/>#	Author:   Richard L. Goerwitz
<a name="8"/>#
<a name="9"/>#	Date:     August 14, 1996
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#	Version:  1.7
<a name="18"/>#
<a name="19"/>############################################################################
<a name="20"/>#
<a name="21"/>#	complete(s,st)	completes a s relative to a set or list of strings, st.
<a name="22"/>#			Put differently, complete() lets you supply a
<a name="23"/>#			partial string, s, and get back those strings in st
<a name="24"/>#			that s is either equal to or a	substring of.
<a name="25"/>#
<a name="26"/>############################################################################
<a name="27"/>#
<a name="28"/>#  Lots of command interfaces allow completion of partial input.
<a name="29"/>#  Complete() simply represents my personal sentiments about how this
<a name="30"/>#  might best be done in Icon.  If you strip away the profuse comments
<a name="31"/>#  below, you end up with only about thirty lines of actual source
<a name="32"/>#  code.
<a name="33"/>#
<a name="34"/>#  I have arranged things so that only that portion of an automaton
<a name="35"/>#  which is needed to complete a given string is actually created and
<a name="36"/>#  stored.  Storing automata for later use naturally makes complete()
<a name="37"/>#  eat up more memory.  The performance gains can make it worth the
<a name="38"/>#  trouble, though.  If, for some reason, there comes a time when it
<a name="39"/>#  is advisable to reclaim the space occupied by complete's static
<a name="40"/>#  structures, you can just call it without arguments.  This
<a name="41"/>#  "resets" complete() and forces an immediate garbage collection.
<a name="42"/>#  
<a name="43"/># Example code:
<a name="44"/>#
<a name="45"/>#      commands := ["run","stop","quit","save","load","continue"]
<a name="46"/>#      while line := read() do {
<a name="47"/>#          cmds := list()
<a name="48"/>#          every put(cmds, complete(line, commands))
<a name="49"/>#          case *cmds of {
<a name="50"/>#              0 : input_error(line)
<a name="51"/>#              1 : do_command(cmds[1])
<a name="52"/>#              default : display_possible_completions(cmds)
<a name="53"/>#          }
<a name="54"/>#          etc...
<a name="55"/>#
<a name="56"/>#  More Iconish methods might include displaying successive
<a name="57"/>#  alternatives each time the user presses the tab key (this would,
<a name="58"/>#  however, require using the nonportable getch() routine).  Another
<a name="59"/>#  method might be to use the first string suspended by complete().
<a name="60"/>#
<a name="61"/>#  NOTE: This entire shebang could be replaced with a slightly slower
<a name="62"/>#  and much smaller program suggested to me by Jerry Nowlin and Bob
<a name="63"/>#  Alexander.
<a name="64"/>#
<a name="65"/>#      procedure terscompl(s, st)
<a name="66"/>#          suspend match(s, p := !st) &amp; p
<a name="67"/>#      end
<a name="68"/>#
<a name="69"/>#  This program will work fine for lists with just a few members, and
<a name="70"/>#  also for cases where s is fairly large.  It will also use much less
<a name="71"/>#  memory.
<a name="72"/>#
<a name="73"/>############################################################################
<a name="74"/>
<a name="75"/>package ipl.complete
<a name="76"/>
<a name="77"/>procedure complete(s,st)
<a name="78"/>
<a name="79"/>    local dfstn, c, l, old_chr, chr, newtbl, str, strset
<a name="80"/>    static t
<a name="81"/>    initial t := table()
<a name="82"/>
<a name="83"/>    # No-arg invocation wipes out static structures &amp; causes an
<a name="84"/>    # immediate garbage collection.
<a name="85"/>    if /s &amp; /st then {
<a name="86"/>	t := table()
<a name="87"/>	collect()		# do it NOW
<a name="88"/>	fail
<a name="89"/>    }
<a name="90"/>    type(st) == ("list"|"set") |
<a name="91"/>	runerr("complete:  List or set expected for arg2", st)
<a name="92"/>
<a name="93"/>    # Seriously, all that's being done here is that possible states
<a name="94"/>    # are being represented by sets containing possible completions of
<a name="95"/>    # s relative to st.  Each time a character is snarfed from s, we
<a name="96"/>    # check to see what strings in st might represent possible
<a name="97"/>    # completions, and store these in yet another set.  At some
<a name="98"/>    # point, we either run into a character in s that makes comple-
<a name="99"/>    # tion impossible (fail), or we run out of characters in s (in
<a name="100"/>    # which case we succeed, &amp; suspend each of the possible
<a name="101"/>    # completions).
<a name="102"/>
<a name="103"/>    # Store any sets we have to create in a static structure for later
<a name="104"/>    # re-use.
<a name="105"/>    /t[st] := table()
<a name="106"/>
<a name="107"/>    # We'll call the table entry for the current set dfstn.  (It really
<a name="108"/>    # does enable us to do things deterministically.)
<a name="109"/>    dfstn := t[st]
<a name="110"/>
<a name="111"/>    # Snarf one character at a time from s.
<a name="112"/>    every c := !s do {
<a name="113"/>
<a name="114"/>	# The state we're in is represented by the set of all possible
<a name="115"/>	# completions before c was read.  If we haven't yet seen char
<a name="116"/>	# c in this state, run through the current-possible-completion
<a name="117"/>	# set, popping off the first character of each possible
<a name="118"/>	# completion, and then construct a table which uses these
<a name="119"/>	# initial chars as keys, and makes the completions that are
<a name="120"/>	# possible for each of these characters into the values for
<a name="121"/>	# those keys.
<a name="122"/>	if /dfstn[st] then {
<a name="123"/>
<a name="124"/>	    # To get strings that start with the same char together,
<a name="125"/>	    # sort the current string set (st).
<a name="126"/>	    l := sort(st)
<a name="127"/>	    newtbl := table()
<a name="128"/>	    old_chr := ""
<a name="129"/>	    # Now pop off each member of the sorted string set.  Use
<a name="130"/>	    # first characters as keys, and then divvy up the full strings
<a name="131"/>	    # into sets of strings having the same initial letter.
<a name="132"/>	    every str := !l do {
<a name="133"/>		str ? { chr := move(1) | next; str := tab(0) }
<a name="134"/>		if old_chr ~==:= chr then {
<a name="135"/>		    strset := set(str)
<a name="136"/>		    insert(newtbl, chr, strset)
<a name="137"/>		}
<a name="138"/>		else insert(strset, str)
<a name="139"/>	    }
<a name="140"/>	    insert(dfstn, st, newtbl)
<a name="141"/>	}
<a name="142"/>
<a name="143"/>	# What we've done essentially is to create a table in which
<a name="144"/>	# the keys represent labeled arcs out of the current state,
<a name="145"/>	# and the values represent possible completion sets for those
<a name="146"/>	# paths.  What we need to do now is store that table in dfstn
<a name="147"/>	# as the value of the current state-set (i.e. the current
<a name="148"/>	# range of possible completions).  Once stored, we can then
<a name="149"/>	# see if there is any arc from the current state (dfstn[st])
<a name="150"/>	# with the label c (dfstn[st][c]).  If so, its value becomes
<a name="151"/>	# the new current state (st), and we cycle around again for
<a name="152"/>	# yet another c.
<a name="153"/>	st := \dfstn[st][c] | fail
<a name="154"/>	if *st = 1 &amp; match(s,!st)
<a name="155"/>	then break
<a name="156"/>    }
<a name="157"/>
<a name="158"/>    # Eventually we run out of characters in c.  The current state
<a name="159"/>    # (i.e. the set of possible completions) can simply be suspended
<a name="160"/>    # one element at a time, with s prefixed to each element.  If, for
<a name="161"/>    # instance, st had contained ["hello","help","hear"] at the outset
<a name="162"/>    # and s was equal to "hel", we would now be suspending "hel" ||
<a name="163"/>    # !set("lo","p").
<a name="164"/>    suspend s || !st
<a name="165"/>
<a name="166"/>end
</pre></body></html>
