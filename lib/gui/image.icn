#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

import graphics(Window)

#
# This class scales and displays an image.  The image source can
# be an image string, an external file, or another window, and
# can be changed at any time.
#
class Image(Component)
   public 
      image_str,
      image_window,
      image_cache,
      win,
      zoom_win,
      fill_dimensions

   #
   # Set an image to use; the parameter is passed to `ImageCache.load`
   # to load the image.
   #
   public set_image(x)
      self.image_str := self.image_cache := self.image_window := &null
      if is_initialized() then {
         close_image()
         self.image_str := x
         load_image()
         self.invalidate()
      } else
         self.image_str := x
      return self
   end

   #
   # Set an image to use; the parameter is passed to `ImageCache.get`
   # to load the image.
   #
   public set_cache(x)
      self.image_str := self.image_cache := self.image_window := &null
      if is_initialized() then {
         close_image()
         self.image_cache := x
         load_image()
         self.invalidate()
      } else
         self.image_cache := x
      return self
   end

   #
   # Set a window to use as the image source.  It will not be closed
   # by this Component.
   #
   public set_window(x)
      self.image_str := self.image_cache := self.image_window := &null
      if is_initialized() then {
         close_image()
         self.image_window := x
         load_image()
         self.invalidate()
      } else
         self.image_window := x
      return self
   end

   #
   # Blank the image
   #
   public clear_image()
      self.image_str := self.image_cache := self.image_window := &null
      if is_initialized() then {
         close_image()
         self.invalidate()
      }
      return self
   end

   public initially()
      Component.initially()
      load_image()
   end

   public load_image()
      win := if \self.image_str then
         ImageCache.load(self.image_str, self.cbwin)
      else if \self.image_cache then
         ImageCache.get(self.image_cache, self.cbwin).shared_copy()
      else if \self.image_window then
         self.image_window.shared_copy()
   end

   # This controls how the image will be expanded if its size is less
   # than that specified by `set_size()`.  If 0, then the image will
   # not be expanded; if 1 then the image will not be distorted, but
   # will be expanded to fill one of the dimensions depending on its
   # shape.  If 2, then the image will be distorted and expanded to
   # fill both dimensions.
   # 
   # If the image is bigger than the specified size then it will
   # always be scaled down, but if this setting is 2, then again the
   # image is distorted to fill both dimensions.
   #
   public set_fill_dimensions(n)
      self.fill_dimensions := n
      return self
   end

   public close_image()
      (\win).close()
      (\zoom_win).close()
      win := zoom_win := &null
   end

   public get_default_width()
      local ww
      ww := (\win).get_width() | 0
      return ww + border.get_total_width()
   end

   public get_default_height(dw)
      local t, wh, ww
      ww := (\win).get_width() | 0
      wh := (\win).get_height() | 0
      dw -:= border.get_total_width()
      t := if fill_dimensions < 2 & ww <= dw then
         wh
      else if ww > 0 then (dw * wh) / ww else 0
      return t + border.get_total_height()
   end

   public display()
      local ir, img_w, img_h,
         asp_r, asp_max, zoom_w, zoom_h, pt

      border.draw_rect(self.cbwin, self)

      \win | fail

      ir := border.get_inner_rect(self)
      if (ir.h | ir.w) <= 0 then
         fail

      img_w := win.get_width()
      img_h := win.get_height()

      if img_w = ir.w & img_h = ir.h then {
         win.copy_to(,,,, 
                     self.cbwin,
                     self.x + border.get_l_inset(),
                     self.y + border.get_t_inset())
      } else {
         #
         # Scale the image to the desired size
         #
         if (fill_dimensions = 0) & (img_w <= ir.w) & (img_h <= ir.h) then {
            zoom_w := img_w
            zoom_h := img_h
         } else if fill_dimensions = 2 then { 
            zoom_w := ir.w
            zoom_h := ir.h
         } else {
            asp_r := real(img_w) / img_h
            asp_max := real(ir.w) / ir.h

            if asp_r > asp_max then {
               zoom_w := ir.w
               zoom_h := integer(ir.w / asp_r)
            } else {
               zoom_w := integer(ir.h * asp_r)
               zoom_h := ir.h
            }
         }

         pt := ir.float(Size(zoom_w, zoom_h), border)

         zoom_w <:= 1
         zoom_h <:= 1

         if \zoom_win &
            zoom_win.get_width() = zoom_w & 
            zoom_win.get_height() = zoom_h then
               zoom_win.copy_to(,,,, self.cbwin, pt.x, pt.y)
         else {
            (\zoom_win).close()
            zoom_win := Window().set_size(zoom_w, zoom_h) | syserr("Couldn't open temp window")
            gui.zoom_win(win, zoom_win)
            zoom_win.copy_to(,,,, self.cbwin, pt.x, pt.y)
         }
      }
   end

   public finally()
      Component.finally()
      close_image()
   end

   public new()
      Component.new()
      self.set_constraint("x_fill", &yes)
      self.set_constraint("y_fill", &yes)
      self.set_constraint("x_weight", 1.0)
      self.set_constraint("y_weight",  1.0)
      set_border(RaisedBorder())
      fill_dimensions := 0
      return
   end
end
