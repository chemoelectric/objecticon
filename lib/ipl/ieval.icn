#
# Support procedures for ieval.
#

package ipl.ieval

import io, gui, lang, xdg, ipl.colmize, parser, eval, util, ipl.pdco, ipl.sort, ipl.termdialog, ipl.lists

$load IEVAL_LOGO "rpp.IEVAL_LOGO.png"

record Activation(coex, info)

class IevalTermDialog(TermDialog, MinimalObjectOutput)
end

class Ieval(MinimalObjectOutput)
   private 
      input, output, error, vars, ev, quiet_flag, par, consts,
      oos, trace_flag, parse_flag, last_runerr, ee, hist_line, hlim,
      elim, llim, imports, files, opts, history

   private static map1(x)
      return map(x[1])
   end

   private show_env()
      local p
      every p := !sort(vars) do {
         output.writes(p[1], " = ")
         oos.show(p[2])
         output.write()
      }
   end

   private show_help()
      output.
         write("!env        Show the values stored in the environment, excluding these predefined values.").
         write("!help       Show help.").
         write("!parse      Toggle parse mode, in which just the syntax structure of the command is printed.").
         write("!trace      Toggle tracing.").
         write("!wglob      Toggle the write-globals flag.").
         write("!traceback  Show the traceback of the last command that gave a runtime error.").
         write("!quiet      Don't force evaluation of all of the values in the expression, and don't output any expression value.").
         write("dir(x)      With no parameter, show all global variables.  With a parameter, show information about it.").
         write("!hist       Show the command line history.").
         write("old(s)      Search history for commands containing string s.").
         write("cmd(n)      Run command number n again.").
         write("hlim(n)     Set the history limit to n.").
         write("elim(n)     Set the expression limit to n.").
         write("llim(n)     Set the gui log area line limit to n.").
         write("oos         The ObjectOutputStream used to output results.").
         write("out         The OutputStream of the terminal.")
   end

   private list_syms()
      local s, e, w
      w := if is(output, TermDialog) then
         output.get_term_width()
      else
         LineEditorStream.get_console_size()[1]
      s := set()
      every e := lang.Prog.get_global_names() do
         if e ? ((not upto('.')) | (=!imports & ="." & (not upto('.')))) then
            insert(s, e)
      every output.write(colmize(isort(s, map), w))
   end

   private show_parse(x, level)
      /level := 0
      if is(x, Token) then
         output.write(repl("\t", level), x.s)
      else
         every show_parse(x.gen(), level + 1)
   end

   private flags_string(f)
      local s
      s := ""
      if iand(f, lang.Class.Method) ~= 0 then
         s ||:= "Method "
      if iand(f, lang.Class.Private) ~= 0 then
         s ||:= "Private "
      if iand(f, lang.Class.Public) ~= 0 then
         s ||:= "Public "
      if iand(f, lang.Class.Protected) ~= 0 then
         s ||:= "Protected "
      if iand(f, lang.Class.Package) ~= 0 then
         s ||:= "Package "
      if iand(f, lang.Class.Static) ~= 0 then
         s ||:= "Static "
      if iand(f, lang.Class.Const) ~= 0 then
         s ||:= "Const "
      if iand(f, lang.Class.Readable) ~= 0 then
         s ||:= "Readable "
      if iand(f, lang.Class.Defer) ~= 0 then
         s ||:= "Defer "
      if iand(f, lang.Class.Abstract) ~= 0 then
         s ||:= "Abstract "
      if iand(f, lang.Class.Native) ~= 0 then
         s ||:= "Native "
      if iand(f, lang.Class.Final) ~= 0 then
         s ||:= "Final "
      if iand(f, lang.Class.Special) ~= 0 then
         s ||:= "Special "
      s[-1] := ""
      return s
   end

   private comma_string(e)
      local s
      s := ""
      while s ||:= @e || ", "
      s[-2:0] := ""
      return s
   end

   private supers_string(c)
      return comma_string{lang.Class.get_name(lang.Class.get_supers(c))} 
   end

   private implements_string(c)
      return comma_string{lang.Class.get_name(lang.Class.get_implemented_classes(c))}
   end

   private fields_string(c)
      return comma_string{Constructor.get_field_names(c)}
   end

   private locn_string(l)
      return "at line " || l.line || " in " || l.file
   end

   private kind_string(f)
      return case f of {
         Proc.Procedure: "Procedure"
         Proc.Function: "Function"
         Proc.Keyword: "Keyword"
         Proc.Operator: "Operator"
         Proc.Internal: "Internal"
      }
   end

   private var_string(f)
      return case f of {
         Proc.Argument: "Argument"
         Proc.Dynamic: "Dynamic"
         Proc.Static: "Static"
      }
   end

   private args_string(f)
      local s
      s := Proc.get_n_arguments(f)
      if Proc.has_varargs(f) then
         s ||:= "[]"
      return s
   end

   private print_table(t)
      local w, widths, col, row
      widths := []
      every col := 1 to *t[1] - 1 do {
         w := 0
         every w <:= *(!t)[col]
         put(widths, w)
      }
      every row := !t do {
         every col := 1 to *t[1] - 1 do
            output.writes(left(row[col], 4 + widths[col]))
         output.write(row[-1])
      }
   end

   private dir(a[])
      local f, t, c, s
      if *a = 0 then
         list_syms()
      else case type(c := a[1]) of {
         "object"|"cast"|"class": {
            s := map(flags_string(lang.Class.get_class_flags(c)))
            if *s > 0 then
               output.writes(s, " ")
            output.write("class ", lang.Class.get_name(c), "(", supers_string(c), ")")
            output.write("   ", locn_string(lang.Class.get_location(c))) 
            output.write("   implements ", implements_string(c))
            t := []
            every f := lang.Class.get_field_names(c) do
               put(t, [f, 
                       lang.Class.get_name(lang.Class.get_field_defining_class(c, f)), 
                       right(lang.Class.get_field_index(c, f), *lang.Class.get_n_fields(c)),
                       flags_string(lang.Class.get_field_flags(c, f))])
            print_table(isort(t, map1))
         }
         "procedure"|"methp": {
            output.write(kind_string(Proc.get_kind(c)), " ", Proc.get_name(c), "(", args_string(c), ")")
            output.write("   ", locn_string(Proc.get_location(c))) 
            output.write("   method of ", lang.Class.get_name(Proc.get_defining_class(c)))
            t := []
            every f := Proc.get_local_names(c) do
               put(t, [f,
                       var_string(Proc.get_local_kind(c, f))])
            print_table(t)
         }
         "record"|"constructor": {
            output.write("constructor ",
                         Constructor.get_name(c), "(", fields_string(c), ")")
            output.write("   ", locn_string(Constructor.get_location(c))) 
         }
         default: {
            oos.show(c)
            output.write()
         }
      }
   end

   private hist(s)
      local i, e
      /s := u""
      s := map(ucs(s)) | runerr(128, s)
      is(input, TermDialog | LineEditorStream) | fail
      i := input.get_history_start_no()
      every e := !input.get_history() do {
         if find(s, map(e)) then
            output.write(right(i, 4), "  ", e)
         i +:= 1
      }
   end

   private wglob()
      ee.set_write_globals(toggle_flag(ee.write_globals_flag))
      return ee.write_globals_flag
   end

   private set_elim(n)
      elim := (10 < n)
      return elim
   end

   private set_hlim(n)
      hlim := (10 < n)
      if is(input, TermDialog | LineEditorStream) then
         input.set_history_limit(hlim)
      return hlim
   end

   private set_llim(n)
      llim := (10 < n)
      if is(input, TermDialog) then
         input.set_log_limit(llim)
      return llim
   end

   private traceback()
      local act_chain, depth, fe2, LIMIT, ae, fe, ce
      
      # Produce similar output to:-
      #    Coexpression.traceback(\last_runerr, &yes)

      ce := \last_runerr | fail
      act_chain := []
      until (!act_chain).coex === ce do {
         push(act_chain, Activation(ce, Coexpression.get_stack_info(ce)))
         ce := Coexpression.get_activator(ce) | break
      }

      depth := 0
      every depth +:= *(!act_chain).info

      LIMIT := 100
      output.write("Traceback:")
      every ae := !act_chain do {
         if depth - LIMIT >= *ae.info then
            depth -:= *ae.info
         else {
            if ce := Coexpression.get_activator(ae.coex) then
               output.write("co-expression#", serial(ae.coex), " activated by co-expression#", serial(ce))
            else
               output.write("co-expression#", serial(ae.coex), "  (never activated)")
            if depth > LIMIT then {
               if depth = LIMIT + 1 then
                  depth := LIMIT
               else
                  output.write("   ... ", depth - LIMIT, " calls omitted")
            }
            fe2 := &null
            every fe := back(ae.info) do {
               if depth <= LIMIT then {
                  output.writes("   ", fe.proc, "(", list2str(fe.args), ")")
                  if \fe2 then
                     output.write(" from line ", fe2.line, " in ", FilePath(fe2.file).get(-1))
                  else
                     output.write()
               }
               depth -:= 1
               fe2 := fe
            }
            if \fe2 then
               output.write("   at line ", fe2.line, " in ", FilePath(fe2.file).get(-1))
         }
      }
   end

   private cmd(n)
      if is(input, TermDialog | LineEditorStream) then 
         hist_line := input.get_history_item(n)
   end

   public new(imports, files, opts)
      self.imports := imports
      self.files := files
      self.opts := opts
      par := Parser()
      vars := table()
      consts := table()
      ee := DefaultEvaluatorEnv(vars, consts)
      if \opts["wglob"] then
         ee.set_write_globals(&yes)
      ev := Evaluator().
         set_env(ee).
         set_imports(imports)
      hlim := (10 < \opts["hlim"]) | 500
      llim := (10 < \opts["llim"]) | 600
      elim := (10 < \opts["elim"]) | 35
      return
   end

   public run()
      local hfile
      if \opts["s"] then
         do_stdin()
      else {
         hfile := FilePath(Xdg.ensure_data_home()).child("ieval").str() | stop("Couldn't access data dir: ", &why)
         history := decode_from_file(hfile) | []
         if \opts["g"] then
            do_gui()
         else
            do_line_editor()
         encode_to_file(hfile, input.get_history()) | ewrite("History not saved: ", &why)
      }
      write("Ciao")
   end

   private prelim()
      local f, s, n
      consts["env"] := create show_env()
      consts["help"] := create show_help()
      consts["trace"] := create trace_flag := toggle_flag(trace_flag)
      consts["parse"] := create parse_flag := toggle_flag(parse_flag)
      consts["quiet"] := create quiet_flag := toggle_flag(quiet_flag)
      consts["wglob"] := create wglob()
      consts["dir"] := dir
      consts["hist"] := create hist()
      consts["old"] := hist
      consts["elim"] := set_elim
      consts["hlim"] := set_hlim
      consts["llim"] := set_llim
      consts["traceback"] := create traceback()
      consts["cmd"] := cmd
      consts["oos"] := oos := ObjectOutputStream(output).set_indent(3)
      consts["out"] := output

      f := FilePath(Xdg.ensure_config_home()).child("ieval").str() | stop("Couldn't access config dir: ", &why)
      if Files.access(f) then
         push(files, f)
      every f := !files do {
         s := Files.file_to_string(f) | stop("Couldn't load ", f, ": ", &why)
         n := par.parse_expression(s) | stop("Couldn't parse ", f,  ": ", &why)
         ev.set_node(n) | stop("Couldn't parse ", f,  ": ", &why) 
         Safe{ev.eval()}
         if &errortext then {
            if &errornumber then
               ewrite("Runtime error ", &errornumber, ": ", &errortext)
            else
               ewrite("Runtime error: ", &errortext)
            ewrite("offending value: ", image(&errorvalue))
            last_runerr := &errorcoexpr
            errorclear()
            break
         }
      }
   end

   private body(s)
      local n, i, v, run

      run := create
         save_var{ { if \trace_flag then &trace := -1 ; Safe{ev.eval()} }, &trace }

      if n := par.parse_expression(s, "UTF-8") then {
         if \parse_flag & s ~== "!parse" then
            show_parse(n)
         else {
            if ev.set_node(n) then {
               if \quiet_flag then
                  !run
               else {
                  i := elim
                  every v := !run do {
                     i -:= 1
                     if i < 0 then {
                        output.write(".... (result sequence truncated)")
                        break
                     }
                     oos.show(v)
                     output.write()
                  }
               }
               if &errortext then {
                  if &errornumber then
                     error.write("Runtime error ", &errornumber, ": ", &errortext)
                  else
                     error.write("Runtime error: ", &errortext)
                  error.write("offending value: ", image(&errorvalue))
                  last_runerr := &errorcoexpr
                  errorclear()
               }
            } else
               error.write("Couldn't parse: ", &why)
         }
      } else
         error.write("Couldn't parse: ", &why)
   end

   private do_gui()
      local s, t, prompt

      input := IevalTermDialog().
         set_label("ieval").
         set_icon(IEVAL_LOGO).
         set_history_limit(hlim).
         set_log_limit(llim).
         set_history(history)
      error := output := input
      prelim()
      s := ""
      prompt := "> "
      input.connect(create {
         t := input.line
         repeat {
            output.write(prompt, t)
            hist_line := &null
            s ||:= t
            if s[-1] == "\\" then {
               s[-1] := ""
               prompt := ">> "
               break
            }
            body(s)
            prompt := "> "
            s := ""
            t := \hist_line | break
         }
      }, Event.ACTION)
      input.show_modal()
   end

   private do_stdin()
      local s, t, prompt

      output := FileStream.stdout
      error := FileStream.stderr
      input := FileStream.stdin
      prelim()
      s := ""
      prompt := "> "
      repeat {
         if \hist_line then {
            write(prompt, hist_line)
            t := hist_line
            hist_line := &null
         } else {
            writes(prompt)
            t := input.read_line() | stop("Failed to read file: ", &why)
            if /t then break
         }
         s ||:= t
         if s[-1] == "\\" then {
            s[-1] := ""
            prompt := ">> "
            next
         }
         body(s)
         prompt := "> "
         s := ""
      }
   end

   private do_line_editor()
      local s, t, prompt

      output := FileStream.stdout
      error := FileStream.stderr
      input := LineEditorStream().
         set_history_limit(hlim).
         set_history(history) | stop("Failed to create LineEditorStream: ", &why)
      prelim()
      s := ""
      prompt := "> "
      repeat {
         if \hist_line then {
            write(prompt, hist_line)
            t := hist_line
            hist_line := &null
         } else {
            input.set_prompt(prompt)
            t := input.read_line() | stop("Failed to read file: ", &why)
            if /t then break
         }
         s ||:= t
         if s[-1] == "\\" then {
            s[-1] := ""
            prompt := ">> "
            next
         }
         body(s)
         prompt := "> "
         s := ""
      }
   end
end
