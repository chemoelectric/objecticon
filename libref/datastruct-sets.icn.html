<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>sets.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: sets.icn 8938 2021-02-26 12:09:13Z rparlett $
<a name="3"/>#
<a name="4"/>
<a name="5"/>package datastruct
<a name="6"/>
<a name="7"/>import ipl.pdco(Index), lang, util
<a name="8"/>
<a name="9"/>#
<a name="10"/># This is a common superclass for a set-like data structure.
<a name="11"/>#
<a name="12"/># A subclass must implement different optional methods depending on
<a name="13"/># its capability mode, as follows :-
<a name="14"/>#
<a name="15"/>#  * `ORDER` - `back()`, `rank()` and `select()`
<a name="16"/>#  * `INSERT` - `insert()`
<a name="17"/>#  * `DELETE` - `delete()`
<a name="18"/>#
<a name="19"/># There are several other abstract methods which all classes must of
<a name="20"/># course implement, and others which may be overridden to provide more
<a name="21"/># efficient implementations than the default.
<a name="22"/>#
<a name="23"/># Note that the behaviour of the various generator methods should the
<a name="24"/># set be concurrently modified during the course of generation,
<a name="25"/># depends upon the particular set implementation.
<a name="26"/>#
<a name="27"/>abstract class Set(HasMode, ObjectOutput, ObjectHash, ObjectEquals)
<a name="28"/>   public static const
<a name="29"/>      # An empty set instance
<a name="30"/>      EMPTY_SET,
<a name="31"/>      # Constant indicating insert capability
<a name="32"/>      INSERT,
<a name="33"/>      # Constant indicating delete capability
<a name="34"/>      DELETE,
<a name="35"/>      # Constant indicating entries are stored in order
<a name="36"/>      ORDER
<a name="37"/>
<a name="38"/>   private static init()
<a name="39"/>      EMPTY_SET := EmptySet()
<a name="40"/>      INSERT := 2
<a name="41"/>      DELETE := 4
<a name="42"/>      ORDER := 8
<a name="43"/>   end
<a name="44"/>
<a name="45"/>   #
<a name="46"/>   # Insert a new member.  Always succeeds and returns `self`.  Only
<a name="47"/>   # implemented with INSERT capability.
<a name="48"/>   #
<a name="49"/>   public optional insert(x)
<a name="50"/>
<a name="51"/>   #
<a name="52"/>   # Succeed with `x` if it is a member of the set.
<a name="53"/>   #
<a name="54"/>   public abstract member(x)
<a name="55"/>
<a name="56"/>   #
<a name="57"/>   # Delete `x` from the set.  Fails if the key was not present,
<a name="58"/>   # otherwise succeeds and returns `self`.  Only implemented with
<a name="59"/>   # DELETE capability.
<a name="60"/>   #
<a name="61"/>   public optional delete(x)
<a name="62"/>
<a name="63"/>   #
<a name="64"/>   # Return a sorted list of members.
<a name="65"/>   #
<a name="66"/>   public sort()
<a name="67"/>      local l
<a name="68"/>      l := member_list()
<a name="69"/>      return if can(ORDER) then l else default.sort(member_list())
<a name="70"/>   end
<a name="71"/>
<a name="72"/>   #
<a name="73"/>   # Generate members.  With ORDER capability, the members are
<a name="74"/>   # generated in sorted order, starting with the member at index `i`
<a name="75"/>   # (default 1).
<a name="76"/>   #
<a name="77"/>   public abstract gen(i)
<a name="78"/>
<a name="79"/>   #
<a name="80"/>   # Generate the members in reverse order, starting with the member
<a name="81"/>   # before index `i` (thus generating the elements in the range 1:i);
<a name="82"/>   # `i` defaults to 0.  Only implemented with ORDER capability.
<a name="83"/>   #
<a name="84"/>   public optional back(i)
<a name="85"/>
<a name="86"/>   #
<a name="87"/>   # Return the rank of the given entry, ie its order number in the
<a name="88"/>   # set; fails if there is no matching entry in the set.  Only
<a name="89"/>   # implemented for sets with ORDER capability.
<a name="90"/>   #
<a name="91"/>   public optional rank(x)
<a name="92"/>
<a name="93"/>   #
<a name="94"/>   # Return the `i`th entry, in order, in the set.  Fails if `i` is
<a name="95"/>   # out of range, using standard icon indexing semantics.  Only
<a name="96"/>   # implemented for sets with ORDER capability.
<a name="97"/>   #
<a name="98"/>   public optional select(i)
<a name="99"/>
<a name="100"/>   #
<a name="101"/>   # Return the size of the set.
<a name="102"/>   #
<a name="103"/>   public abstract size()
<a name="104"/>
<a name="105"/>   #
<a name="106"/>   # Succeed iff the size is zero.
<a name="107"/>   #
<a name="108"/>   public empty()
<a name="109"/>      succeed size() = 0
<a name="110"/>   end
<a name="111"/>
<a name="112"/>   #
<a name="113"/>   # Clear the set of all elements. Always succeeds and returns
<a name="114"/>   # `self`.  Only implemented with DELETE capability.
<a name="115"/>   #
<a name="116"/>   public clear()
<a name="117"/>      while delete(gen())
<a name="118"/>      link
<a name="119"/>   end
<a name="120"/>
<a name="121"/>   #
<a name="122"/>   # Return a random member (cf ?s for a set).
<a name="123"/>   #
<a name="124"/>   public random()
<a name="125"/>      local r
<a name="126"/>      if r := ?(0 &lt; size()) then
<a name="127"/>         return if can(ORDER) then select(r) else Index{gen(), r}
<a name="128"/>   end
<a name="129"/>
<a name="130"/>   #
<a name="131"/>   # Return a list of the members, in the order produced by `gen()`.
<a name="132"/>   #
<a name="133"/>   public member_list()
<a name="134"/>      return ipl.pdco.List{ gen() }
<a name="135"/>   end
<a name="136"/>
<a name="137"/>   #
<a name="138"/>   # Custom equals mirrors the `equals()` behaviour for builtin sets.
<a name="139"/>   #
<a name="140"/>   protected override object_equals(other, seen)
<a name="141"/>      other.size() = self.size() | fail
<a name="142"/>      return hash_and_check(other.member_list(), self.member_list(), seen)
<a name="143"/>   end
<a name="144"/>
<a name="145"/>   #
<a name="146"/>   # Custom hash mirrors the `hash()` behaviour for builtin sets.
<a name="147"/>   #
<a name="148"/>   protected override object_hash(depth)
<a name="149"/>      local n
<a name="150"/>      n := size()
<a name="151"/>      if depth &gt; 1 then
<a name="152"/>         every n +:= hash(gen(), depth - 1)
<a name="153"/>      return n
<a name="154"/>   end
<a name="155"/>
<a name="156"/>   #
<a name="157"/>   # Output object
<a name="158"/>   #
<a name="159"/>   protected override object_output(oo)
<a name="160"/>      local elements, e, sep
<a name="161"/>      elements := sort()
<a name="162"/>      if oo.simple{!elements} then {
<a name="163"/>         oo.object_start(self)
<a name="164"/>         every e := !elements do {
<a name="165"/>            if \sep then
<a name="166"/>               oo.writes1(",")
<a name="167"/>            oo.traverse(e)
<a name="168"/>            sep := &amp;yes
<a name="169"/>         }
<a name="170"/>         oo.object_end(self)
<a name="171"/>      } else {
<a name="172"/>         oo.nl().
<a name="173"/>            object_start(self).
<a name="174"/>            iplus()
<a name="175"/>         every e := !elements do {
<a name="176"/>            if \sep then
<a name="177"/>               oo.writes1(",")
<a name="178"/>            oo.nl().
<a name="179"/>               traverse(e)
<a name="180"/>            sep := &amp;yes
<a name="181"/>         }
<a name="182"/>         oo.iminus().
<a name="183"/>            nl().
<a name="184"/>            object_end(self)
<a name="185"/>      }
<a name="186"/>   end
<a name="187"/>end
<a name="188"/>
<a name="189"/>#
<a name="190"/># A helpful abstract class for a table with `ORDER` capability, which
<a name="191"/># wishes to implement the generator methods `gen()` and `back()` in
<a name="192"/># terms of `select()`.
<a name="193"/>#
<a name="194"/># In the case of changes to the set during generation, the methods
<a name="195"/># behave like the builtin `forward()` and `back()` functions.
<a name="196"/>#
<a name="197"/>abstract class OrderSetImpl1(Set)
<a name="198"/>   public override gen(i)
<a name="199"/>      if i := first_forward(i, size()) then
<a name="200"/>         suspend |1(select(i), i +:= 1)
<a name="201"/>   end
<a name="202"/>
<a name="203"/>   public override back(i)
<a name="204"/>      if i := first_back(i, size()) then
<a name="205"/>         suspend |1(select(i), i -:= 1)
<a name="206"/>   end
<a name="207"/>end
<a name="208"/>
<a name="209"/>#
<a name="210"/># A helpful abstract class for a set with `ORDER` capability, which
<a name="211"/># wishes to implement `select()` in terms of `gen()`.
<a name="212"/>#
<a name="213"/>abstract class OrderSetImpl2(Set)
<a name="214"/>   public override select(i)
<a name="215"/>      return Index{ gen(), cvpos_item(i, size()) }
<a name="216"/>   end
<a name="217"/>end
<a name="218"/>
<a name="219"/>#
<a name="220"/># A class to provide an unmodifiable view of another set.
<a name="221"/>#
<a name="222"/>class UnmodifiableSet(Set)
<a name="223"/>   protected const
<a name="224"/>      s
<a name="225"/>
<a name="226"/>   public override member(x)
<a name="227"/>      return s.member(x)
<a name="228"/>   end
<a name="229"/>
<a name="230"/>   public override sort()
<a name="231"/>      return s.sort()
<a name="232"/>   end
<a name="233"/>
<a name="234"/>   public override gen(i)
<a name="235"/>      suspend s.gen(i)
<a name="236"/>   end
<a name="237"/>
<a name="238"/>   public override back(i)
<a name="239"/>      suspend s.back(i)
<a name="240"/>   end
<a name="241"/>
<a name="242"/>   public override rank(x)
<a name="243"/>      return s.rank(x)
<a name="244"/>   end
<a name="245"/>
<a name="246"/>   public override select(i)
<a name="247"/>      return s.select(i)
<a name="248"/>   end
<a name="249"/>
<a name="250"/>   public override size()
<a name="251"/>      return s.size()
<a name="252"/>   end
<a name="253"/>
<a name="254"/>   public override empty()
<a name="255"/>      return s.empty()
<a name="256"/>   end
<a name="257"/>
<a name="258"/>   public override random()
<a name="259"/>      return s.random()
<a name="260"/>   end
<a name="261"/>
<a name="262"/>   public override get_mode()
<a name="263"/>      return iand(ORDER, s.get_mode())
<a name="264"/>   end
<a name="265"/>
<a name="266"/>   public new(s)
<a name="267"/>      self.s := need_instance(s, Set)
<a name="268"/>      return
<a name="269"/>   end
<a name="270"/>end
<a name="271"/>
<a name="272"/>#
<a name="273"/># A Set which is a view of the keys of a `Table`.
<a name="274"/>#
<a name="275"/>class TableSet(Set)
<a name="276"/>   protected const
<a name="277"/>      t
<a name="278"/>
<a name="279"/>   public override insert(x)
<a name="280"/>      t.add(x)
<a name="281"/>      link
<a name="282"/>   end
<a name="283"/>
<a name="284"/>   public override member(x)
<a name="285"/>      if t.member(x) then
<a name="286"/>         return x
<a name="287"/>   end
<a name="288"/>
<a name="289"/>   public override delete(x)
<a name="290"/>      link t.delete(x)
<a name="291"/>   end
<a name="292"/>
<a name="293"/>   public override sort()
<a name="294"/>      return t.key_sort()
<a name="295"/>   end
<a name="296"/>
<a name="297"/>   public override gen(i)
<a name="298"/>      suspend t.key(i)
<a name="299"/>   end
<a name="300"/>
<a name="301"/>   public override back(i)
<a name="302"/>      suspend t.back_key(i)
<a name="303"/>   end
<a name="304"/>
<a name="305"/>   public override rank(x)
<a name="306"/>      return t.rank(x)
<a name="307"/>   end
<a name="308"/>
<a name="309"/>   public override select(i)
<a name="310"/>      return t.select(i)
<a name="311"/>   end
<a name="312"/>
<a name="313"/>   public override random()
<a name="314"/>      return t.random_key()
<a name="315"/>   end
<a name="316"/>
<a name="317"/>   public override size()
<a name="318"/>      return t.size()
<a name="319"/>   end
<a name="320"/>
<a name="321"/>   public override clear()
<a name="322"/>      t.clear()
<a name="323"/>      link
<a name="324"/>   end
<a name="325"/>
<a name="326"/>   public override get_mode()
<a name="327"/>      return iand(INSERT + DELETE + ORDER, t.get_mode())
<a name="328"/>   end
<a name="329"/>
<a name="330"/>   #
<a name="331"/>   # Create a new instance.
<a name="332"/>   #
<a name="333"/>   # :Parameters :
<a name="334"/>   # :  `t` - either the `Table` to wrap, or a class indicating the class of
<a name="335"/>   #     a new `Table`, which will be instantiated by calling its
<a name="336"/>   #     constructor with no parameters.
<a name="337"/>   # :  `entries` - initial entries to insert.
<a name="338"/>   #
<a name="339"/>   public new(t, entries[])
<a name="340"/>      if type(t) == "class" then
<a name="341"/>         t := t()
<a name="342"/>      self.t := need_instance(t, Table)
<a name="343"/>      every insert(!entries)
<a name="344"/>      return
<a name="345"/>   end
<a name="346"/>end
<a name="347"/>
<a name="348"/>#
<a name="349"/># Convenient subclass of `TableSet`, which uses an `EqTable`, to
<a name="350"/># provide a set with membership based on `equals()`.
<a name="351"/>#
<a name="352"/>class EqSet(TableSet)
<a name="353"/>   public override new(entries[])
<a name="354"/>      push(entries, EqTable)
<a name="355"/>      TableSet.new!entries
<a name="356"/>      return
<a name="357"/>   end
<a name="358"/>end
<a name="359"/>
<a name="360"/>#
<a name="361"/># An empty set.  An instance of this class is `Set.EMPTY_SET`.
<a name="362"/>#
<a name="363"/>class EmptySet(OrderSetImpl1)
<a name="364"/>   public override member(x)
<a name="365"/>   end
<a name="366"/>
<a name="367"/>   public override select(i)
<a name="368"/>   end
<a name="369"/>
<a name="370"/>   public override rank(x)
<a name="371"/>   end
<a name="372"/>
<a name="373"/>   public override size()
<a name="374"/>      return 0
<a name="375"/>   end
<a name="376"/>
<a name="377"/>   public override get_mode()
<a name="378"/>      return ORDER
<a name="379"/>   end
<a name="380"/>end
<a name="381"/>
<a name="382"/>#
<a name="383"/># A `Set` that is just a wrapper around a builtin set
<a name="384"/>#
<a name="385"/>class BuiltinSet(Set)
<a name="386"/>   private const
<a name="387"/>      s
<a name="388"/>
<a name="389"/>   public override insert(x)
<a name="390"/>      default.insert(s, x)
<a name="391"/>      link
<a name="392"/>   end
<a name="393"/>
<a name="394"/>   public override member(x)
<a name="395"/>      return default.member(s, x)
<a name="396"/>   end
<a name="397"/>
<a name="398"/>   public override delete(x)
<a name="399"/>      link default.delete(s, x)
<a name="400"/>   end
<a name="401"/>
<a name="402"/>   public override sort()
<a name="403"/>      return default.sort(s)
<a name="404"/>   end
<a name="405"/>
<a name="406"/>   public override gen()
<a name="407"/>      suspend !s
<a name="408"/>   end
<a name="409"/>
<a name="410"/>   public override size()
<a name="411"/>      return *s
<a name="412"/>   end
<a name="413"/>
<a name="414"/>   public override clear()
<a name="415"/>      default.clear(s)
<a name="416"/>      link
<a name="417"/>   end
<a name="418"/>
<a name="419"/>   public override random()
<a name="420"/>      return ?s
<a name="421"/>   end
<a name="422"/>
<a name="423"/>   public override get_mode()
<a name="424"/>      return INSERT + DELETE
<a name="425"/>   end
<a name="426"/>
<a name="427"/>   #
<a name="428"/>   # Create a new instance.
<a name="429"/>   #
<a name="430"/>   # :Parameters :
<a name="431"/>   # :  `s` - the set to wrap; if omitted a new set is created.
<a name="432"/>   #
<a name="433"/>   public new(s)
<a name="434"/>      self.s := need_set(\s) | set()
<a name="435"/>      return
<a name="436"/>   end
<a name="437"/>end
<a name="438"/>
<a name="439"/># A convenient equivalent to wrapping a BuiltinSet in an
<a name="440"/># UnmodifiableSet.
<a name="441"/>#
<a name="442"/>class UnmodifiableBuiltinSet(Set)
<a name="443"/>   private const
<a name="444"/>      s
<a name="445"/>
<a name="446"/>   public override member(x)
<a name="447"/>      return default.member(s, x)
<a name="448"/>   end
<a name="449"/>
<a name="450"/>   public override sort()
<a name="451"/>      return default.sort(s)
<a name="452"/>   end
<a name="453"/>
<a name="454"/>   public override gen()
<a name="455"/>      suspend !s
<a name="456"/>   end
<a name="457"/>
<a name="458"/>   public override size()
<a name="459"/>      return *s
<a name="460"/>   end
<a name="461"/>
<a name="462"/>   public override random()
<a name="463"/>      return ?s
<a name="464"/>   end
<a name="465"/>
<a name="466"/>   public override get_mode()
<a name="467"/>      return 0
<a name="468"/>   end
<a name="469"/>
<a name="470"/>   #
<a name="471"/>   # Create a new instance.
<a name="472"/>   #
<a name="473"/>   # :Parameters :
<a name="474"/>   # :  `s` - the set to wrap
<a name="475"/>   #
<a name="476"/>   public new(s)
<a name="477"/>      self.s := need_set(s)
<a name="478"/>      return
<a name="479"/>   end
<a name="480"/>end
</pre></body></html>
