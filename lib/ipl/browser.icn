package ipl.browser

import 
   gui, 
   lang, 
   mail,
   http,
   util,
   io,
   net,
   xml,
   posix,
   graphics,
   ipl.lists,
   ipl.pdco,
   ipl.sort,
   ipl.strings,
   ipl.caseless,
   ipl.timegui,
   ipl.colorgui,
   ipl.filegui,
   ipl.numbers

$load BROKEN_LINK "rpp.BROKEN_LINK_24.gif"

class Req()
   public const
      client, url, referer, callback, kind, form_data, on_status

   public new(client, url, referer, callback, kind, form_data, on_status)
      self.client := client
      self.url := url 
      self.referer := referer
      self.callback := callback
      self.kind := kind
      self.form_data := form_data
      self.on_status := on_status
      return
   end
end

class Resp()
   public const
      err, url, referer, data, fname, content_type, kind, form_data, data_file

   public new(err, url, referer, data, fname, content_type, kind, form_data, data_file)
      self.err := err
      self.url := url
      self.referer := referer
      self.data := data
      self.fname := fname
      self.content_type := content_type
      self.kind := kind
      self.form_data := form_data
      self.data_file := data_file
      return
   end
end

class StaticData()
   public const
      data, fname, content_type

   public new(data, fname, content_type)
      self.data := data
      self.fname := fname
      self.content_type := content_type
      return
   end
end

class CacheEntry(StaticData)
   public const
      url, expiry

   public new(url, expiry, data, fname, content_type)
      self.url := url
      self.data := data
      self.fname := fname
      self.content_type := content_type
      self.expiry := expiry
      return
   end
end

class Cache()
   private t, total, lim, id

   public get(url)
      local k, ent
      k := url.str()
      if ent := member(t, k) then {
         if \ent.expiry < Time.get_system_seconds() then
            del(ent)
         else
            return ent
      }
   end

   private del(ent)
      local k
      k := ent.url.str()
      total -:= *ent.data
      delete(t, k)
   end

   public add(url, expiry, data, fname, content_type)
      local k, old, ent
      ent := CacheEntry(url, expiry, data, fname, content_type)
      k := ent.url.str()
      #write("cache add key=", k, "\n\tdata=", *data, " bytes\n\tfname=", fname, "\n\tct=", to_string(content_type), "\n\texpiry=", (\ent.expiry - Time.get_system_seconds()) | "-")
      if old := member(t, k) then
         del(old)
      while *t > 0 &  total + *ent.data > lim do
         del(?t)
      insert(t, k, ent)
      total +:= *ent.data
      return
   end

   public create_url(expiry, data, fname, content_type)
      local url
      /expiry := Time.get_system_seconds() + 60
      url := URL(u"cache:" || (id +:= 1))
      add(url, expiry, data, fname, content_type)
      return url
   end

   private format_expiry(v)
      if /v then
         return "never"
      v -:= Time.get_system_seconds()
      if v < 0 then
         return "expired"
      if v < 300 then
         return v || "&nbsp;secs"
      v /:= 60
      if v < 120 then
         return v || "&nbsp;mins"
      v /:= 60
      if v <= 48 then
         return v || "&nbsp;hours"
      v /:= 24
      if v < 365 * 2 then
         return v || "&nbsp;days"
      v /:= 365
      return v || "&nbsp;years"
   end

   public get_status()
      local s, ce, n, sz, exp, ct, l
      s := "<html><title>Cache status</title>" || Browser.get_table_tag()
      s ||:= "<tr><th align=left>Filename</th><th align=right>Size&nbsp;</th><th>Expiry</th><th align=left>Content&nbsp;type</th><th align=left>URL</th></tr>"
      every ce := !t do {
         n := Browser.limit_text(\ce.fname, 200) | "-"
         sz := Format.numeric_to_string(*ce.data, 0, ',')
         exp := format_expiry(ce.expiry)
         ct := (\ce.content_type).to_rfc1521() | "-"
         l := ce.url
         s ||:= "<tr><td>" || Browser.to_content(n) || "</td><td align=right>" || sz || "&nbsp;</td><td>" || exp ||
                   "</td><td nowrap>" || Browser.to_content(ct) || "</td>" || Browser.mk_anchor_cell(l) || "</tr>" 
      }
      s ||:= "</table></html>"
      return s
   end

   public new(lim)
      t := table()
      self.lim := lim
      total := 0
      id := 0
      return
   end
end

abstract class SubWorker()
   public abstract cancel()
   public abstract get_read()
   public abstract get_length()
   public abstract get_data(worker)
end

class ProgSubWorker(SubWorker)
   private 
      data

   public cancel() end
   public get_length() end

   public get_read()
      return data.tell() - 1
   end

   public get_data(worker)
      local ts, f, d, ps, i
      if (\worker.req.referer).scheme == (u"http" | u"https") then
         return error("Can't run a prog from an http page")
      f := worker.req.url.get_decoded_path()
      d := use {
         ts := TaskStream(ps := ProgInputStream("/bin/sh", ["-c", f]), worker.task),
         StaticData(read_all(ts), "")     # Return StaticData in order to set a blank filename.
      } | fail
      i := ps.get_exit_info().param | syserr("No exit info")
      return if i = 0 then            
         d
      else
         error("/bin/sh returned non-zero status: " || i)
   end

   private read_all(ts)
      return use {
         data := RamStream(),
         ts.copy_to(data) & data.str()
      }
   end
end

class FileSubWorker(SubWorker)
   private 
      data

   public cancel() end
   public get_length() end

   public get_read()
      return data.tell() - 1
   end

   private static grname(gid, cache)
      local s
      (s := member(cache, gid)) | insert(cache, gid, s := (System.getgr(gid).name | gid))
      return s
   end

   private static uname(uid, cache)
      local s
      (s := member(cache, uid)) | insert(cache, uid, s := (System.getpw(uid).name | uid))
      return s
   end

   public get_data(worker)
      local f, e, l, t, path, rs, now, tf, gcache, ucache, ts
      f := worker.req.url.get_decoded_path()
      if Files.is_directory(f) then {
         l := isort(Files.ucs_list(f), Files.name_key) | fail
         now := Time.get_system_seconds()
         ucache := table()
         gcache := table()
         return use {
            rs := RamStream(),
            {
               rs.out("<html><title>Directory " || f || "</title>" || Browser.get_table_tag())
               path := FilePath(f)
               every e := !l do {
                  t := e.lstat
                  tf := if now - t.mtime > 180 * 86400 then
                     Time(t.mtime + Time.SYSTEM_BASE_OFFSET).format("MMM'&nbsp;'dd'&nbsp;&nbsp;'yyyy")
                  else
                     Time(t.mtime + Time.SYSTEM_BASE_OFFSET).format("MMM'&nbsp;'dd'&nbsp;'HH:mm")
                  rs.out("<tr><td>" || t.mode_str || "&nbsp;</td><td>" || uname(t.uid, ucache) || "&nbsp;</td><td>" || grname(t.gid, gcache) ||
                         "&nbsp;</td><td align=right>" || Format.numeric_to_string(t.size, 0, ',') || "&nbsp;</td><td>" || tf || "&nbsp;</td>" ||
                         "<td nowrap><a href=\"file://" || URL.percent_encode(path.child(e.name).canonical().str(), URL.UNRESERVED ++ '/') || "\">" || 
                                 Browser.to_content(e.name) || "</a></td></tr>\n")
               }
               rs.out("</table></html>")
               rs.str()
            }
         }
      } else {
         return use {
            ts := TaskStream(FileStream(f), worker.task),
            read_all(ts)
         }
      }
   end

   private read_all(ts)
      return use {
         data := RamStream(),
         ts.copy_to(data) & data.str()
      }
   end
end

class HttpSubWorker(SubWorker)
   private 
      httpc, tmp_file

   public cancel()
      httpc.abort()
      rm_tmp()
   end

   private rm_tmp()
      if \tmp_file then {
         save_why{Files.remove(tmp_file)}
         tmp_file := &null
      }
   end

   public get_length()
      return httpc.get_length()
   end

   public get_read()
      return httpc.get_read()
   end

   private static get_expiry(hres)
      local s, t, now, ma
      now := Time.get_system_seconds()
      if t := HttpClient.parse_generic_header(hres.get_first_header("Cache-Control")) then {
         if member(t, "no-cache") then
            fail
         if ma := integer(member(t, "max-age")) then
            return now + (0 < ma)
      }
      if s := hres.get_first_header("Expires") then {
         t := Time.parse(s, "E, d MMM yyyy hh:mm:ss z") | fail
         return now < t.get_unix_seconds()
      }
      return
   end

   public get_data(worker)
      local req, s, data, hreq, hres, fname, ct, x, ce, sc
      httpc := worker.httpc
      req := worker.req
      return if req.kind ~= Worker.REFRESH & /req.form_data & (ce := worker.pool.cache.get(req.url)) then
         ce
      else if req.kind = Worker.DOWNLOAD then {
         tmp_file := Files.make_temp_filename("http_oibrowser.", ".bin") | stop("Couldn't create temp file: ", &why)
         use {
            s := BufferStream(FileStream(tmp_file, 
                                         ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT))).
               set_buff_size(8192),
            {
               hreq := HttpRequest().
                  set_output_stream(s). 
                  set_url(req.url).
                  set_header("Accept-charset", "UTF-8, ISO-8859-1")
               if (\req.referer).scheme == (u"http" | u"https") then
                  hreq.set_referer(req.referer.str())
               if hres := httpc.retrieve(hreq) then {
                  fname := hres.get_filename()
                  ct := ContentType.parse_rfc2616(hres.get_first_header("Content-Type"))
                  Resp(, hres.url, req.referer,, fname, ct, req.kind, 
                       if hreq.url === hres.url then req.form_data else &null, tmp_file)
               } else {
                  rm_tmp()
                  Resp(&why, req.url, req.referer,,,, req.kind, req.form_data)
               }
            }
         }
      } else use {
         s := RamStream(),
         {
            hreq := HttpRequest().
               set_output_stream(s). 
               set_url(req.url).
               set_header("Accept-charset", "UTF-8, ISO-8859-1")
            if (\req.referer).scheme == (u"http" | u"https") then
               hreq.set_referer(req.referer.str())
            if \req.form_data then {
               if is(req.form_data, Message) then
                  hreq.set_multipart_form_data(req.form_data)
               else
                  hreq.set_html_form_data(req.form_data)
            }

            if hres := httpc.retrieve(hreq) then {
               data := s.str()
               fname := hres.get_filename()
               ct := ContentType.parse_rfc2616(hres.get_first_header("Content-Type"))
               # Note we have to take into account redirections in deciding whether to cache
               # and whether form data should be in the response.
               if httpc.request.method == "GET" & x := get_expiry(hres) then
                  worker.pool.cache.add(hres.url, x, data, fname, ct)
               Resp(, hres.url, req.referer, data, fname, ct, req.kind, 
                    if hreq.url === hres.url then req.form_data else &null)
            } else {
               # Decide whether to include http content together with
               # the error message, so it can be displayed
               if httpc.get_http_error() & 
                  hres := httpc.response &
                  sc := hres.get_status_code() &
                  400 <= sc <= 599 &
                  data := s.str() &
                  *data > 0 then
               {
                  fname := hres.get_filename()
                  ct := ContentType.parse_rfc2616(hres.get_first_header("Content-Type"))
                  Resp(&why, hres.url, req.referer, data, fname, ct, req.kind, 
                       if hreq.url === hres.url then req.form_data else &null)
               } else
                  Resp(&why, req.url, req.referer,,,, req.kind, req.form_data)
            }
         }
      }
   end
end

class Worker()
   private readable
      pool, httpc, cancelled, req, task, sub_worker

   public static const NORMAL, NAVIGATE, REFRESH, DOWNLOAD

   private static init()
      NORMAL := 1
      NAVIGATE := 2
      REFRESH := 3
      DOWNLOAD := 4
   end

   public initially()
      task.start()
   end

   public finally()
      if \req then
         cancel()
      else {
         # httpc may be null, since we may have started but never been run
         (\httpc).close()
         task.stop()
      }
   end

   public cancel()
      if \req then {
         cancelled := 1
         task.interrupt()
         (\sub_worker).cancel()
      }
   end

   public read()
      return (\sub_worker).get_read()
   end

   public length()
      return (\sub_worker).get_length()
   end

   private dwrite(a[])
      writes("[", serial(self), "] ")
      write!a
   end

   private writing_line(ev)
      dwrite("Sent: ", ev)
   end

   private read_line(ev)
      dwrite("Got : ", ev)
   end

   private read_string(ev)
      dwrite("Got : data - 0x", Format.int_to_string(*ev, 16), " bytes")
   end

   private writing_string(ev)
      dwrite("Sent: data - 0x", Format.int_to_string(*ev, 16), " bytes")
   end

   private failed(ev)
      dwrite("Failed ", &why, repl(" ", 20))
   end

   private retrying(ev)
      dwrite("Retrying ", &why, repl(" ", 20))
   end

   private other(ev, src, type)
      dwrite(type)
   end

   private status(ev, src, type)
      (\(\req).on_status)(ev, src, type)
   end

   private setup_httpc()
      httpc := HttpClient().
         set_task(task).
         set_cookies(pool.cookies).
         set_authentications(pool.authentications).
         set_authentication_function(pool.authentication_function).
         set_retry_while_data(&yes)
      httpc.set_user_agent(\pool.user_agent)

      every httpc.connect(status, 
                          NetClient.CONNECTING_EVENT |
                          NetClient.CONNECTED_EVENT |
                          NetClient.CLOSED_EVENT |
                          HttpClient.COMPLETE_EVENT |
                          HttpClient.FAILED_EVENT |
                          HttpClient.ABORTED_EVENT |
                          HttpClient.RETRYING_EVENT) 

      if \pool.log_http_flag then {
         httpc.connect(failed, HttpClient.FAILED_EVENT).
            connect(retrying, HttpClient.RETRYING_EVENT).
            connect(read_line, NetClient.READ_LINE_EVENT).
            connect(read_string, NetClient.READ_STRING_EVENT).
            connect(writing_line, NetClient.WRITING_LINE_EVENT).
            connect(writing_string, NetClient.WRITING_STRING_EVENT).
            connect(other, NetClient.CONNECTING_EVENT).
            connect(other, NetClient.CONNECTED_EVENT).
            connect(other, NetClient.CLOSED_EVENT).
            connect(other, HttpClient.COMPLETE_EVENT)
      }
   end

   # A little task to wait for the child process to exit, so that it
   # doesn't become a zombie process.
   private monitor(t, pid)
      while System.wait(pid, WaitOpt.WNOHANG).pid ~= pid do
         # ei.pid is presumably 0, meaning the child is still running.
         t.sleep(500)
      t.revert()
   end

   private handle_run_req()
      local pid, f, t
      if (\req.referer).scheme == (u"http" | u"https") then
         return error("Can't run a prog from an http page")
      f := req.url.get_decoded_path()
      pid := System.fork() | fail
      if pid > 0 then {
         t := Dispatcher.new_task{monitor(t, pid)}
         t.start()
         return
      }
      System.exec("/bin/sh", ["-c", f]) | stop(&why)
      syserr("Not reached")
   end

   private handle_cache_req()
      return pool.cache.get(req.url) | error("Cache entry expired")
   end

   private handle_func(f)
      local x, s
      if x := f(self) then {
         if /cancelled then {
            if is(x, SubWorker) then {
               sub_worker := x
               handle_func(x.get_data)
            } else if is(x, Resp) then
               req.callback(x)
            else if is(x, StaticData) then
               req.callback(Resp(, req.url, req.referer, x.data, x.fname, x.content_type, req.kind))
            else if s := string(x) then
               req.callback(Resp(, req.url, req.referer, s, req.url.get_decoded_path_last(),, req.kind))
            else if \x then
               runerr(103, x)
         }
      } else {
         if /cancelled then
            req.callback(Resp(&why, req.url, req.referer,,,, req.kind))
      }
   end

   private handle_req()
      local f, t
      t := string(req.url.scheme)
      case t of {
         "file": handle_func(FileSubWorker)
         "prog": handle_func(ProgSubWorker)
         "run": handle_func(handle_run_req)
         "cache": handle_func(handle_cache_req)
         "http"|"https": handle_func(HttpSubWorker)
         default: {
            if f := member(pool.scheme_handlers, t) then
               handle_func(f)
            else
               req.callback(Resp("Unknown url scheme", req.url, req.referer,,,, req.kind))
         }
      }
   end

   private run()
      setup_httpc()
      repeat {
         while /pool.active do {
            # finally() has been called; close resources and revert
            httpc.close()
            task.revert()
         }
         until req := pool.queue_get() do
            task.sleep()
         cancelled := &null
         handle_req()
         sub_worker := req := &null
      }
   end

   public new(pool)
      self.pool := pool
      task := Dispatcher.new_task{run()}
      return
   end
end

class WorkerPool()
   private
      queue,
      workers
   private readable
      active,
      log_http_flag,
      cookies,
      user_agent,
      cache,
      authentications,
      authentication_function,
      scheme_handlers

   public set_log_http(s)
      self.log_http_flag := check_flag(s)
      return self
   end

   public initially()
      active := 1
      every (!workers).initially()
   end

   public finally()
      active := &null
      every (!workers).finally()
      clear(queue)
   end

   public cancel(client)
      local w
      delete(queue, client)
      every w := !workers do 
         if (\w.req).client === client then
            w.cancel()
   end

   public get_worker(req)
      local w
      every w := !workers do 
         if w.req === req then
            return w
   end

   public start_worker(req)
      local w, l
      if l := member(queue, req.client) then
         put(l, req)
      else
         insert(queue, req.client, [req])
      # Wake up a sleeping task if possible
      every w := !workers do 
         if w.task.is_sleeping() then {
            w.task.notify()
            break
         }
   end

   public queue_size()
      local i
      i := 0
      every i +:= *!queue
      return i
   end

   package queue_get()
      local l, r
      l := ?queue | fail
      r := get(l) | syserr("Empty list in queue table")
      if *l = 0 then
         delete(queue, r.client)
      return r
   end

   public count(client)
      local i, w
      i := *member(queue, client) | 0
      every w := !workers do 
         if (\w.req).client === client then
            i +:= 1
      return i
   end

   # Return the amount read by this client's current requests.
   #
   public read(client)
      local i, w
      i := 0
      every w := !workers do
         if (\w.req).client === client then
            i +:= w.read()
      return i
   end

   # Return a length giving the remaining data to be downloaded for
   # this client; fails if that is unknown.
   #
   public length(client)
      local i, w
      if member(queue, client) then
         fail
      i := 0
      every w := !workers do
         if (\w.req).client === client then
            i +:= w.length() | fail
      return i
   end

   public set_cookies(cookies)
      self.cookies := cookies
      return self
   end

   public set_authentications(m)
      self.authentications := m
      return self
   end

   public set_authentication_function(f)
      self.authentication_function := f
      return self
   end

   public set_cache(c)
      self.cache := c
      return self
   end

   public set_scheme_handlers(m)
      self.scheme_handlers := m
      return self
   end

   public add_scheme_handler(scheme, func)
      insert(scheme_handlers, scheme, func)
      return self
   end

   #
   # Set the user-agent identification
   #
   public set_user_agent(s)
      self.user_agent := s
      return self
   end

   public get_status()
      local s, w, st, t, l, r, k, c
      s := "<html><title>Worker pool status</title>"

      s ||:= "<h1>Workers</h1>" || Browser.get_table_tag() || "<tr><th align=left>Serial</th><th align=left>Status</th><th align=left>URL</th></tr>"
      every w := !workers do {
         t := w.task
         st := if t.is_current() then "current"
         else if t.is_sleeping() then "sleeping"
         else if t.is_polling() then "polling"
         else if t.is_ready() then "ready"
         else if t.is_active() then "active"
         else "stopped"
         s ||:= "<tr><td>" || serial(w) || "</td><td>" || st || "</td>"
         if l := (\w.req).url then
            s ||:= Browser.mk_anchor_cell(l)
         else
            s ||:= "<td/>"
         s ||:= "</tr>"          
      }
      s ||:= "</table>"

      if *queue > 0 then {
         s ||:= "<h1>Queue</h1>" || Browser.get_table_tag() || "<tr><th align=left>Client</th><th align=left>Kind</th><th align=left>URL</th></tr>"
         every r := !!queue do {
            k := case r.kind of {
               Worker.NORMAL: "NORMAL"
               Worker.NAVIGATE: "NAVIGATE"
               Worker.REFRESH: "REFRESH"
               Worker.DOWNLOAD: "DOWNLOAD"
               default: "-"
            }
            c := Class.get_name(r.client) || "#" || serial(r.client)
            s ||:= "<tr><td>" || c || "</td><td>" || k || "</td>" || Browser.mk_anchor_cell(r.url) || "</tr>"
         }
         s ||:= "</table>"
      }

      s ||:= "</html>"
      return s
   end

   public new(n)
      /n := 6
      queue := table()
      cookies := table()
      cache := Cache(8*1024*1024)
      authentications := table()
      scheme_handlers := table()
      workers := []
      every 1 to n do
         put(workers, Worker(self))
      return
   end
end

class TblContent(Component)
   private
      hrules, vrules

   public whose_point(ex, ey)
      local c
      every c := layout_delegate.computed_g.cells_in_range(ey - y, 1).obj do {
         if c.is_unhidden() & c.inside(ex, ey) then
            return c
      }
   end

   public display()
      local ci, r, g, t
      r := get_cbwin_clip()
      g := layout_delegate.computed_g
      every ci := g.cells_in_range(r.y - y, r.h) do {
         display_child(ci.obj)
         if \vrules | \hrules then {
            t := Rect(x + g.a_col_x[ci.x],
                      y + g.a_row_y[ci.y],
                      Grid.slice(ci.x, ci.w, g.a_col_w),
                      Grid.slice(ci.y, ci.h, g.a_row_h))
            if r.intersect(t) then {
               if member(\vrules, ci.x) then
                  cbwin.draw_rectangle(t.x, t.y, 1, t.h)
               if member(\hrules, ci.y) then
                  cbwin.draw_rectangle(t.x, t.y, t.w, 1)
            }
         }
      }
   end

   public set_hrules(r)
      self.hrules := r
      return self
   end

   public set_vrules(r)
      self.vrules := r
      return self
   end
end

class Tbl(Border, HasMaxWidth)
   public get_max_width()
      local w1
      w1 := content.layout_delegate.get_max_width() + border.get_total_width()
      return if \title then
         max(w1, title.get_max_width() + 2 * TITLE_OFFSET)
      else
         w1
   end

   public new()
      cast(self,Border).new()
      set_content(TblContent(). 
                    set_layout(TableLayout()))
      set_border(NullBorder())
      return
   end
end

abstract class HasLastHighlight()
   public abstract set_last_highlight(u)
   public abstract get_last_highlight_index()
   public abstract set_last_highlight_index(n)
end

class Img(Image, HasLastHighlight)
   public const
      browser, context, form, img_url, alt, bg_area
   private readable
      over, img_data, img_name, map, map_id, held, err, highlight, last_highlight

   package got_data(res)
      local iw, ih
      if \res.err then {
         err := res.err
         set_cache("rpp.BROKEN_LINK")
         every remove_constraint("fix_w" | "fix_h" | "pct_w")
      } else {
         set_image(res.data)
         if /win then {
            err := &why
            set_cache("rpp.BROKEN_LINK")
            every remove_constraint("fix_w" | "fix_h" | "pct_w")
         } else {
            # Set width and perhaps height based on constraints.
            #
            # If pct_w is set, then set a small minimal value, since
            # otherwise the actual width of the image would be the
            # preferred width, and hence the minimum size which
            # TextFlow would allocate, whereas we want to allow the
            # image to shrink below its actual width.
            #
            if iw := integer(member(constraints, "fix_w")) then
               set_width(iw + border.get_total_width())
            else if integer(member(constraints, "pct_w")) then
               set_width(1 + border.get_total_width())
            if ih := integer(member(constraints, "fix_h")) then {
               if /w_spec then 
                  set_width(ih * win.get_width() / win.get_height() + border.get_total_width())
               else 
                  set_height(ih + border.get_total_height())
            }
            img_name := res.fname
            img_data := res.data
            set_fill_dimensions(2)
         }
      }
   end

   private handle_rpress(e)
      local pm, pm_menu
      *parent_dialog.held = 1 | fail
      if pm_menu := browser.create_image_menu(self) then {
         set_highlight(over)
         set_over()
         pm := PopupMenu()
         pm.connect(on_popup_closed, Event.POPUP_CLOSED)
         pm.popup(parent_dialog, pm_menu, e.x, e.y)
      }
   end

   private on_popup_closed()
      set_highlight()
   end

   private handle_lrelease(e, src)
      \held | fail
      if \over then {
         set_highlight()
         browser.link_left_clicked(over)
      }
      held := &null
   end

   private handle_mrelease(e)
      \held | fail
      if \over then {
         set_highlight()
         browser.link_middle_clicked(over)
      }
      held := &null
   end

   private handle_form_lrelease(e, src)
      if in_region(e) then
         form.submit(e, src)
   end

   private handle_exit(e)
      *parent_dialog.held = 0 | fail
      set_over()
   end

   package gen_areas()
      # Non-null bg_area implies we have some areas (ie, links) (see constructor below).
      if \bg_area then
         suspend get_map().gen_areas() | bg_area
   end

   private get_map()
      /map := browser.get_map(\map_id) | ipl.browser.Map()
      return map
   end

   private which_area(e)
      in_region(e) | fail
      return get_map().which_area(e.x - x - border.get_l_inset(), 
                                  e.y - y - border.get_t_inset()) | bg_area
   end

   private handle_lmpress(e)
      *parent_dialog.held = 1 | fail
      if \over then {
         set_highlight(over)
         held := over
      }
   end

   private set_over(u)
      if u ~=== over then {
         over := u
         if /over then
            browser.clear_msg(self)
         else
            browser.msg(over.str(),, self)
      }
      return self
   end

   public set_last_highlight(u)
      if u ~=== last_highlight then {
         last_highlight := u
         invalidate()
      }
      return self
   end

   public get_last_highlight_index()
      local a, u, n
      n := 0
      every a := gen_areas() do {
         if u := \a.url then {
            n +:= 1
            if last_highlight === u then
               return n
         }
      }
   end

   public set_last_highlight_index(n)
      local a, u
      every a := gen_areas() do {
         if u := \a.url then {
            n -:= 1
            if n = 0 then {
               last_highlight := u
               return self
            }
         }
      }
   end

   private set_highlight(u)
      if u ~=== highlight then {
         browser.set_last_highlight(self, \u)
         # Avoid resetting since that will reload the image data, which is slow.
         is(border, NullBorder | EmptyBorder) | {
            set_fg(if \u then browser.page_alink_color else context.fg)
            reset()
         }
         highlight := u
      }
      return self
   end

   private handle_lmdrag(e)
      \held | fail
      if \which_area(e).url === held then {
         set_over(held)
         set_highlight(held)
      } else {
         set_over()
         set_highlight()
      }
   end

   package wants_lpress(e)
      return \over | \form
   end

   private handle_in_chain(e)
      local u, t, a, f
      *parent_dialog.held = 0 | fail
      if e.code === (Key.SHIFT_L | Key.SHIFT_R) then {
         if /e.release then
            f := 1
      } else f := \e.shift
      t := which_area(e)
      a := (\t).title
      set_tooltip(a)
      if /f & (u := \ (\t).url) then {
         set_over(u)
         set_pointer("hand1")
      } else {
         set_over()
         set_pointer()
      }
   end

   public display()
      local r
      cast(self,Image).display()
      if r := browser.is_banded(self) then
         Gui.style.fill_selection_rectangle(cbwin, x, y, w, h)
      if \last_highlight then
         Gui.style.draw_dashed_rectangle(cbwin, x, y, w, h)
   end

   public new(browser, context, img_url, alt, form, map_id)
      cast(self,Image).new()
      clear_constraints()
      self.browser := browser
      self.context := context
      self.img_url := img_url
      self.form := form
      self.alt := alt
      self.map_id := map_id
      if \form then {
         set_pointer("hand1")
         connect(self.handle_form_lrelease, Event.MOUSE_LEFT_RELEASE)
      } else if \map_id | \context.url then {
         connect(self.handle_in_chain, Event.IN_POINT_CHAIN)
         connect(self.handle_lmdrag, Event.MOUSE_LEFT_DRAG)
         connect(self.handle_lmpress, Event.MOUSE_LEFT_PRESS)
         connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE)
         connect(self.handle_lmdrag, Event.MOUSE_MIDDLE_DRAG)
         connect(self.handle_lmpress, Event.MOUSE_MIDDLE_PRESS)
         connect(self.handle_mrelease, Event.MOUSE_MIDDLE_RELEASE)
         connect(self.handle_exit, Event.MOUSE_EXIT)
         bg_area := MapArea(,, context.url, context.title)
         set_tooltip_follows_mouse(&yes)
      }
      connect(self.handle_rpress, Event.MOUSE_RIGHT_PRESS)
      set_border(NullBorder())
      return
   end
end

abstract class FormEntry()
   package readable
      form_name, form_id, form_tabindex

   public validate_form()
      return
   end
                  
   public get_save_key()
      return \form_name | \form_id
   end

   public reset_form() end
   public get_save_subkey() end
   public get_save_value() end
   public restore_value(val) end

   public abstract get_form_value(ev, src, multipart_flag)
end

class FormToggle(ToggleTextButton, FormEntry)
   private const
      value,
      init_checked

   public reset_form()
      set_is_checked(init_checked)
   end

   public get_form_value(ev, src)
      if is_checked() then 
         return value
   end

   public get_save_subkey()
      return value
   end

   public get_save_value()
      return get_status()
   end

   public restore_value(val)
      set_is_checked(val)
   end

   public new(value, init_checked)
      cast(self,ToggleTextButton).new()
      self.value := value
      self.init_checked := init_checked
      set_is_checked(init_checked)
      return
   end
end

class FormButton(TextButton, FormEntry, HasAscent)
   private const
      value

   public get_form_value(ev, src)
      if src === self then
         return value
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset()
   end

   public new(value)
      cast(self,TextButton).new()
      self.value := value
      set_label(value)
      return
   end
end

class FormTextFlowButton(Button, FormEntry, HasMaxWidth, HasAscent)
   public const
      tf, value, form, type

   public get_form_value(ev, src)
      if src === self then
         return value
   end

   private handle_action(e, src)
      case type of { 
         "submit": form.submit(e, src)
         "reset": form.reset_form()
      }
   end

   public display()
      display_children()
      if \self.is_down then {
         Gui.style.fill_down_rectangle(self.cbwin, self.x, self.y, self.w, self.h)
         tf.border.draw_rev_rect(self.cbwin, self)
      }
      if self.has_focus() & self.is_unshaded() then
         tf.border.draw_focus_rect(self.cbwin, self)
   end

   #
   # Prevent children from getting in the point chain.
   #
   public build_point_chain(l)
   end

   public get_default_width()
      return tf.get_preferred_width()
   end

   public get_max_width()
      return tf.get_max_width()
   end

   public get_default_height(dw)
      return tf.get_preferred_height(dw)
   end

   public get_ascent(dw)
      return tf.get_ascent(dw)
   end

   public layout()
      tf.x := x
      tf.y := y
      tf.w := w
      tf.h := h
      tf.layout()
   end

   public new(form, value, type)
      cast(self,Button).new()
      tf := TextFlow(form.browser).
         set_border(CompoundBorder().
                    set_outer(RaisedBorder()).
                    set_inner(EmptyBorder()))
      add(tf)
      self.value := value
      self.form := form
      self.type := type
      connect(self.handle_action, Event.ACTION)
      return
   end
end

class Hidden(FormEntry)
   private const
      value

   public get_form_value()
      return value
   end

   public new(value)
      self.value := value
      return
   end
end

class FormLabel()
   public const
      id,
      form
   public
      comp

   public new(id, form)
      self.id := id
      self.form := form
      return
   end
end

class FormBrowse(Component, FormEntry, HasAscent)
   private const
      tf,
      browser

   public get_form_value(ev, src, multipart_flag)
      local s
      s := tf.get_contents()
      if *s = 0 then
         return ""
      return if /multipart_flag then
         tf.get_contents()
      else
         Files.file_to_string(s)
   end

   public validate_form()
      local s
      s := tf.get_contents()
      if *s = 0 then
         return
      return Files.access(s) | error("No such file")
   end

   public get_filename()
      return FilePath(tf.get_contents()).get(-1)
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + tf.border.get_t_inset()
   end

   public reset_form()
      tf.set_contents(u"")
   end

   public get_save_value()
      return tf.get_contents()
   end

   public restore_value(val)
      tf.set_contents(val)
   end

   private on_browse(ev)
      tf.assign_contents(ucs(browser.browse_for_file(tf.get_contents())), ev)
   end

   public new(browser, tf_size)
      cast(self,Component).new()
      self.browser := browser
      set_layout(GridLayout().set_doi(0).set_dii(0))
      tf := FileSuggestField().set_size(tf_size).set_contents(u"")
      add(tf)
      add(TextButton().set_label("Browse...").connect(on_browse, Event.ACTION))
      return
   end
end

class FormImgX(FormEntry)
   private const
      img

   public get_form_value(ev, src)
      if src === img then
         return ev.x - img.x
   end

   public new(img)
      self.img := img
      return
   end
end

class FormImgY(FormEntry)
   private const
      img

   public get_form_value(ev, src)
      if src === img then
         return ev.y - img.y
   end

   public new(img)
      self.img := img
      return
   end
end

class FormTextField(SuggestField, FormEntry, HasAscent)
   private const
      browser,
      init_val,
      datalist_id

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset()
   end

   public reset_form()
      set_contents(init_val)
   end

   public get_form_value()
      return get_contents()
   end

   public get_save_value()
      return get_contents()
   end

   public restore_value(val)
      set_contents(val)
   end

   public create_popup()
      return FormOptionList()
   end

   public convert_element(o)
      return o.value
   end

   protected do_request()
      local l, t, e, s
      l := browser.get_datalist(\datalist_id) | fail
      s := map(contents)
      t := []
      every e := !l do {
         if match(s, map(e.value)) then
            put(t, e)
      }
      return t
   end

   public handle_return(e)
      if \tl then
         keep_closed()
      else
         cast(self,TextField).handle_return(e)
   end

   public new(browser, init_val, datalist_id)
      cast(self,SuggestField).new()
      self.browser := browser
      self.init_val := init_val
      self.datalist_id := datalist_id
      set_contents(init_val)
      return
   end
end

class FormDateField(DateField, FormEntry, HasAscent)
   private const
      init_val

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset() + view.border.get_t_inset()
   end

   public reset_form()
      set_value(init_val)
   end

   public validate_form()
      return get_value() | error("Bad date format")
   end

   public get_form_value()
      return get_value().format("yyyy-MM-dd")
   end

   public get_save_value()
      return last_val
   end

   public restore_value(val)
      set_value(val)
   end

   public new(init_val)
      cast(self,DateField).new(init_val)
      self.init_val := init_val
      return
   end
end

class FormWeekField(WeekField, FormEntry, HasAscent)
   private const
      init_val

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset() + view.border.get_t_inset()
   end

   public reset_form()
      set_value(init_val)
   end

   public validate_form()
      return get_value() | error("Bad week format")
   end

   public get_form_value()
      return get_value().format("vvvv'-W'ww")
   end

   public static parse(s)
      local w, y
      s ? {
         (y := integer(tab(many(&digits))) &
          1000 <= y <= 9999 &
          ="-W" &
          w := integer(tab(many(&digits))) &
          1 <= w <= 53 &
          pos(0)) | fail
      }
      return Time.get_week_of_year(y, w)
   end

   public get_save_value()
      return last_val
   end

   public restore_value(val)
      set_value(val)
   end

   public new(init_val)
      cast(self,WeekField).new(init_val)
      self.init_val := init_val
      return
   end
end

class FormTimeField(TimeField, FormEntry, HasAscent)
   private const
      init_val

   public reset_form()
      set_value(init_val)
   end

   public validate_form()
      return get_value() | error("Bad time format")
   end

   public get_form_value()
      return get_value().format("HH':'mm':'ss")
   end

   public get_save_value()
      return last_val
   end

   public restore_value(val)
      set_value(val)
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset() + view.border.get_t_inset()
   end

   public static parse(s)
      s ?:= tab(upto('.'))
      return Time.parse(s, "HH':'mm':'ssx")
   end

   public new(init_val)
      cast(self,TimeField).new(init_val)
      self.init_val := init_val
      return
   end
end

class FormDateTimeLocalField(Component, FormEntry, HasAscent)
   private const
      date,
      time

   public get_ascent() 
      return date.get_ascent()
   end

   public reset_form()
      date.reset_form()
      time.reset_form()
   end

   public validate_form()
      return date.validate_form() & time.validate_form()
   end

   public static parse(s)
      s ?:= tab(upto('.'))
      return Time.parse(s, "yyyy-MM-dd'T'HH':'mm':'ssx")
   end

   public get_form_value()
      return date.get_form_value() || "T" || time.get_form_value()
   end

   public get_save_value()
      return [date.get_save_value(), time.get_save_value()]
   end

   public restore_value(val)
      date.restore_value(val[1])
      time.restore_value(val[2])
   end

   public new(init_val)
      cast(self,Component).new()
      set_layout(GridLayout().set_doi(0).set_dii(0))
      add(date := FormDateField(init_val))
      add(time := FormTimeField(init_val))
      return
   end
end

class FormTimezoneField(TimezoneField, FormEntry, HasAscent)
   private const
      init_val

   public reset_form()
      set_value(init_val)
   end

   public validate_form()
      return get_value() | error("Bad timezone format")
   end

   public get_form_value()
      local zone
      zone := get_value() | fail
      return if zone.offset = 0 then
         "Z"
      else (if zone.offset < 0 then "-" else "+") ||
         right(abs(zone.offset) / 3600, 2, "0") || ":" ||
         right((abs(zone.offset) % 3600) / 60, 2, "0")
   end

   public get_save_value()
      return last_val
   end

   public restore_value(val)
      set_value(val)
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset() + view.border.get_t_inset()
   end

   public new(init_val)
      cast(self,TimezoneField).new(init_val)
      self.init_val := init_val
      return
   end
end

class FormYearField(YearField, FormEntry, HasAscent)
   private const
      init_val

   public reset_form()
      set_value(init_val)
   end

   public validate_form()
      return get_value() | error("Bad timezone format")
   end

   public get_form_value()
      return string(get_value())
   end

   public get_save_value()
      return last_val
   end

   public restore_value(val)
      set_value(val)
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset() + view.border.get_t_inset()
   end

   public new(init_val)
      cast(self,YearField).new()
      set_value(init_val)
      self.init_val := init_val
      return
   end
end

class FormMonthField(MonthField, FormEntry, HasAscent)
   private const
      init_val

   public reset_form()
      set_selection(init_val)
   end

   public get_form_value()
      return string(get_selection())
   end

   public get_save_value()
      return get_selection()
   end

   public restore_value(val)
      set_selection(val)
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset() + view.border.get_t_inset()
   end

   public new(init_val)
      cast(self,MonthField).new()
      set_selection(init_val)
      self.init_val := init_val
      return
   end
end

class FormDateTimeField(Component, FormEntry, HasAscent)
   private const
      date,
      time,
      zone

   public get_ascent() 
      return date.get_ascent()
   end

   public reset_form()
      date.reset_form()
      time.reset_form()
      zone.reset_form()
   end

   public validate_form()
      return date.validate_form() & time.validate_form() & zone.validate_form()
   end

   public static parse(s)
      s ? {
         if s := tab(upto('.')) then {
            move(1)
            tab(many(&digits))
            s ||:= tab(0)
         }
      }
      return Time.parse(s, "yyyy-MM-dd'T'HH':'mm':'ssTx")
   end

   public get_form_value()
      return date.get_form_value() || "T" || time.get_form_value() || zone.get_form_value()
   end

   public get_save_value()
      return [date.get_save_value(), time.get_save_value(), zone.get_save_value()]
   end

   public restore_value(val)
      date.restore_value(val[1])
      time.restore_value(val[2])
      zone.restore_value(val[3])
   end

   public new(init_val)
      cast(self,Component).new()
      set_layout(GridLayout().set_doi(0).set_dii(0))
      add(date := FormDateField(init_val))
      add(time := FormTimeField(init_val))
      add(zone := FormTimezoneField(init_val.zone))
      return
   end
end

class FormMonthYearField(Component, FormEntry, HasAscent)
   private const
      month,
      year,
      init_val

   public get_ascent() 
      return month.get_ascent()
   end

   public reset_form()
      month.reset_form()
      year.reset_form()
   end

   public validate_form()
      return year.validate_form()
   end

   public static parse(s)
      local y, m
      s ? {
         (y := integer(tab(many(&digits))) &
          1000 <= y <= 9999 &
          ="-" &
          m := integer(tab(many(&digits))) &
          1 <= m <= 12 &
          pos(0)) | fail
      }
      return Time(y, m)
   end

   public get_form_value()
      return year.get_form_value() || "-" || month.get_form_value()
   end

   public get_save_value()
      return [year.get_save_value(), month.get_save_value()]
   end

   public restore_value(val)
      year.restore_value(val[1])
      month.restore_value(val[2])
   end

   public new(init_val)
      cast(self,Component).new()
      set_layout(GridLayout().set_doi(0).set_dii(0))
      add(month := FormMonthField(init_val.month))
      add(year := FormYearField(init_val.year))
      return
   end
end

class FormRange(Slider, FormEntry)
   private const
      init_val

   public reset_form()
      set_value(init_val)
   end

   public get_form_value()
      return get_value()
   end

   public get_save_value()
      return get_value()
   end

   public restore_value(val)
      set_value(val)
   end

   public new(init_val)
      cast(self,Slider).new()
      set_value(init_val)
      self.init_val := init_val
      return
   end
end

class FormNumberField(RangeSpin, FormEntry, HasAscent)
   private const
      init_val

   public reset_form()
      set_value(init_val)
   end

   public validate_form()
      return get_value() | error("Invalid number")
   end

   public get_form_value()
      return string(get_value())
   end

   public get_save_value()
      return last_val
   end

   public restore_value(val)
      set_value(val)
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset() + view.border.get_t_inset()
   end

   public new(init_val)
      cast(self,RangeSpin).new()
      set_value(init_val)
      self.init_val := init_val
      return
   end
end

class FormColorField(ColorField, FormEntry, HasAscent)
   private const
      init_val

   public reset_form()
      set_value(init_val)
   end

   public validate_form()
      return get_value() | error("Bad color format")
   end

   public get_form_value()
      local l, s
      l := Window.parse_color(get_value()) | fail
      s := "#"
      every s ||:= Format.int_to_string(l[1 to 3] / 256, 16, 2)
      return s
   end

   public get_save_value() 
      return last_val
   end

   public restore_value(val)
      set_value(val)
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + b.border.get_t_inset()
   end

   public static parse(s)
      return Window.color_value(s)
   end

   public new(init_val)
      cast(self,ColorField).new(init_val)
      self.init_val := init_val
      set_opaque(&yes)
      return
   end
end

class FormEditableTextList(EditableTextList, FormEntry)
   private const
      init_val

   public reset_form()
      set_contents_str(init_val)
      set_cursor(1, 1)
   end

   public get_form_value()
      return list2str(contents, "\r\n")
   end

   public get_save_value()
      return get_contents()
   end

   public restore_value(val)
      set_contents(val)
   end

   public new(init_val)
      cast(self,EditableTextList).new()
      self.init_val := init_val
      set_contents_str(init_val)
      return
   end
end

class FormOption()
   public const
      txt, label, value, selected, disabled, optgroup

   public new(txt, label, value, selected, disabled, optgroup)
      self.txt := txt
      self.label := label
      self.value := value
      self.selected := selected
      self.disabled := disabled
      self.optgroup := optgroup
      return
   end
end

class FormOptionList(SelectableScrollArea, FormEntry)
   private const
      init_val

   public end_handle(e)
      local i
      every i := !selections do {
         if /contents[i].value then
            delete(selections, i)
      }
      cast(self,SelectableScrollArea).end_handle(e)
   end

   public get_form_value(ev, src)
      suspend \contents[!selections].value
   end

   public reset_form()
      set_selections(init_val)
   end

   public get_save_value()
      return get_selections()
   end

   public restore_value(val)
      set_selections(val)
   end

   public calculate_line_height()
      return view.cbwin.get_font_height()
   end

   public calculate_subject_width()
      local mw, o
      mw := 0
      every o := !contents do
         mw <:= view.cbwin.text_width(o.txt)
      return mw + 2 * Gui.TEXT_INSET
   end

   public draw_line_data(xp, yp, lh, i)
      local o, W
      o := contents[i]
      if \o.disabled then {
         use {
            W := view.cbwin.clone().set_fg("gray"),
            draw_string_ex(W, xp + Gui.TEXT_INSET, yp, o.txt)
         }
      } else 
         draw_string_ex(view.cbwin, xp + Gui.TEXT_INSET, yp, o.txt)
   end

   public new(init_val)
      cast(self,SelectableScrollArea).new()
      self.init_val := init_val
      return
   end
end

class FormList(gui.List, FormEntry, HasAscent)
   private const
      init_val

   public get_ascent() 
      return cbwin.get_font_ascent() + view.border.get_t_inset() + border.get_t_inset()
   end

   private find_value(seq, e)
      local i
      while i := @seq do {
         if \selection_list[i].value then {
            start_change(e)
            set_selection(i, e)
            end_change(e)
            break
         }
      }
   end

   public do_increment(e)
      if /selection then
         find_value(create *selection_list to 1 by -1, e)
      else
         find_value(create (selection - 1 to 1 by -1) | (*selection_list to selection + 1 by -1), e)
   end

   public do_decrement(e)
      if /selection then
         find_value(create 1 to *selection_list, e)
      else
         find_value(create (1 + selection to *selection_list) | (1 to selection - 1), e)
   end

   public reset_form()
      set_selection(init_val)
   end

   public get_form_value(ev, src)
      return \object_get_selection().value
   end

   public get_save_value()
      return get_selection()
   end

   public restore_value(val)
      set_selection(val)
   end

   public create_popup()
      return FormOptionList()
   end

   public convert_element(o)
      return o.label
   end

   public get_default_width()
      local mw, o
      mw := 0
      every o := !selection_list do
         if \o.value then
            mw <:= view.cbwin.text_width(o.label)
      return border.get_total_width() + b.get_preferred_width() + mw + view.border.get_total_width()
   end

   public new(init_val)
      cast(self,gui.List).new()
      self.init_val := init_val
      return
   end
end

class Form()
   public const
      id,
      key,
      url,
      browser,
      method,
      enctype,
      items,
      labels,
      id_table,
      cbgs
   private readable
      autofocus

   private make_cgi_table(ev, src)
      local t, k, c, v
      t := table()
      every c := !items do {
         if k := \c.form_name then {
            every v := c.get_form_value(ev, src) do
               put(member(t, k), v) | insert(t, k, [v])
         }
      }
      return t
   end

   private static escape_1521_value(s)
      local t, ch
      t := u"\""
      s ? repeat {
         t ||:= tab(many(&uset -- '\"\\\r'))
         ch := move(1) | break
         t ||:= u"\\" || ch
      }
      return t || u"\""
   end

   private make_cgi_message(ev, src)
      local k, v, c, m, mp, m2
      m := Message()
      mp := Multipart()
      every c := !items do {
         if k := \c.form_name then {
            every v := c.get_form_value(ev, src, 1) do {
               m2 := Message()
               if is(c, FormBrowse) then {
                  m2.set_header("Content-Disposition", 
                                "form-data; name=" || escape_1521_value(k) || 
                                "; filename=" || escape_1521_value(c.get_filename()))
                  m2.set_header("Content-Type", "application/octet-stream")
               } else 
                  m2.set_header("Content-Disposition", 
                                "form-data; name=" || escape_1521_value(k))
               m2.set_decoded_content(v)
               mp.add_part(m2)
            }
         }
      }
      m.set_header("Content-Type", "multipart/form-data")
      m.set_content_object(mp) | stop("Failed to set_content_object:", &why)
      return m
   end

   public reset_form()
      every (!items).reset_form()
   end

   public submit(ev, src)
      local c
      \url | fail
      # Validate form.
      every c := !items do
         c.validate_form() | {
            if is(c, Component) then
               browser.parent_dialog.set_focus(c.gen_focusable())
            browser.msg("Invalid form: " || &why)
            fail
         }

      if method == "post" then {
         if map(enctype) == "multipart/form-data" then
            browser.goto(url, browser.page_url, make_cgi_message(ev, src))
         else 
            browser.goto(url, browser.page_url, make_cgi_table(ev, src))
      } else
         browser.goto(url.with_cgi_parameters(make_cgi_table(ev, src)), browser.page_url)
   end

   public add(name, item)
      put(items, item)
      item.form_name := name
   end

   public add_component(context, el, item)
      local l
      put(items, item)
      if el.get_attribute(u"AUTOFOCUS") then
         autofocus := item
      item.form_name := el.get_attribute(u"NAME")
      if item.form_id := el.get_attribute(u"ID") then
         insert(id_table, item.form_id, item)
      item.form_tabindex := integer(el.get_attribute(u"TABINDEX"))
      l := context.form_label
      # If we have a label in the context, and the for and id tags
      # make sense, link the component item to the label.
      if \l & (/l.id | /item.form_id | l.id == item.form_id) then
         /l.comp := item
   end

   public get_item_by_id(id)
      return member(id_table, id)
   end

   public get_autofocus()
      return \autofocus
   end

   public get_cbg(name)
      local x
      (x := member(cbgs, name)) | insert(cbgs, name, x := CheckBoxGroup())
      return x
   end

   public get_tab_children()
      local l, c
      l := []
      every c := !items do {
         if is(c, Component) then {
            if /c.form_tabindex | (c.form_tabindex >= 0) then
               put(l, c)
         }
      }
      return isort(l, tabindex_sort)
   end

   private tabindex_sort(c)
      return \c.form_tabindex | keyof(items, c)
   end

   public get_save_key()
      return \id | (\url).str()
   end

   public resolve_labels()
      local l
      every l := !labels do
         /l.comp := get_item_by_id(\l.id)
   end

   public new(browser, id, url, method, enctype)
      self.browser := browser
      self.id := id
      self.url := url
      self.method := method
      self.enctype := enctype
      self.items := []
      self.labels := []
      self.id_table := table()
      self.cbgs := table()
      return
   end
end

record TableContext(tbl, caption, x, y, occ, cell_border, tr, rowgroups, colgroups, curr_colgroup)
record TableColGroup(align, valign, width, span, cols)
record TableCol(align, valign, width, span)
record ListContext(tbl, index, type, kind)
record DefListContext(tbl)
record FieldSetContext(legend)
record MapContext(map)
record SelectContext(options, optgroup)
record DataListContext(options)
record Context(form, form_label, title, url, fg, font, align, pre, nowrap, underline, strike, underdash, mark,
               family, size, bold, italic, table, list, def_list, fieldset, select, map, datalist)

class MapArea()
   public const
      shape, coords, url, title

   public contains(x, y)
      return case shape of {
         "rect": check_rect(x, y)
         "poly": check_poly(x, y)
         "circle": check_circle(x, y)
         "default": &null
      }
   end

   private check_rect(x, y)
      return (coords[1] <= x <= coords[3]) & (coords[2] <= y <= coords[4])
   end

   private check_circle(x, y)
      return (x - coords[1]) ^ 2 + (y - coords[2]) ^ 2 <= coords[3] ^ 2
   end

   # Adapted from :-
   # http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
   #
   private check_poly(x, y)
      local i, j, n, c, xi, yi, xj, yj, b1, b2
      if *coords % 2 = 1 | *coords < 6 then
         fail
      j := n := *coords / 2
      c := 0
      every i := 1 to n do {
         xi := coords[2 * i - 1]
         yi := coords[2 * i]
         xj := coords[2 * j - 1]
         yj := coords[2 * j]
         b1 := if yi > y then 1 else 0
         b2 := if yj > y then 1 else 0
         if b1 ~= b2 & (x < (xj - xi) * (y - yi) / (yj - yi) + xi) then
            c +:= 1
         j := i
      }
      return c % 2 = 1
   end

   public new(shape, coords, url, title)
      self.shape := shape
      self.coords := coords
      self.url := url
      self.title := title
      return
   end
end

class Map()
   private const
      l

   public gen_areas()
      suspend .!l
   end

   public which_area(x, y)
      local e
      every e := !l do {
         if e.contains(x, y) then
            return e
      }
   end

   public add_area(area)
      put(l, area)
      return self
   end

   public new()
      l := []
      return
   end
end

record HistoryEntry(url,          # URL displayed (on a redirect may differ from that requested) 
                    title,        # Page title
                    referer,      # referer URL
                    form_values,  # Cached values of form components; updated when we move away from the page 
                    form_data,    # POST data used to get the page; on a redirect will always be null
                    focus_index,  # Index of focused component on moving away
                    last_highlight_component_index,  # Child index of last_highlight_component
                    last_highlight_index,            # Index of last_highlight within last_highlight_component
                    area_x,
                    area_y
                    ) 

abstract class BrowserUI()
   public abstract msg(s, n)
   public abstract clear_msg()
   public abstract page_loaded()
   public abstract page_fully_loaded()
   public abstract update_grey(gs)
   public abstract link_left_clicked(url)
   public abstract link_middle_clicked(url)
   public abstract create_link_menu(url)
   public abstract create_page_menu()
   public abstract create_image_menu(img)
   public abstract browse_for_file(s)
   public abstract is_visited(url)
end

class BrowserPrimarySelectionOwner(TextSelectionOwner)
   private parent, s

   protected get_text()
      return s
   end

   package set_text(s)
      self.s := s
      return self
   end

   public lost_ownership()
      parent.on_lost_primary_ownership()
   end

   public new(parent)
      self.parent := parent
      return
   end
end

record GreyState(prev, nxt, refresh, copy_page, save_page, stop)

class Browser(ComponentScrollArea)
   private
      ui,
      shared_worker_pool_flag,
      status_ticker,
      maps,
      datalists,
      forms,
      form_tab_children,
      scroll_ticker,
      scroll_ticker_interval,
      h_direction,
      v_direction,
      primary_selection_owner,
      msg_owner,
      outermost_border

   private readable
      history,
      history_pos,
      curr_history_entry,   # History entry currently being viewed.
      worker_pool,
      page_url,
      page_data,
      page_name,
      page_title,
      page_links,
      page_base,
      page_resp,
      page_text_color,
      page_link_color,
      page_alink_color,
      page_vlink_color,
      running,
      mark_x,
      mark_y,
      cursor_x,
      cursor_y,
      banded,
      searched,
      sorted_searched,
      highlighted_searched,
      searched_term,
      text_selection,
      links_selection,
      done_set_top_data,
      last_highlight_component

   public static const 
      COLORS,
      SIZES

   private static const
      default_font_clone

   private static init()
      local t
      COLORS := table(,
                      "aliceblue", "#F0F8FF",
                      "antiquewhite", "#FAEBD7",
                      "aqua", "#00FFFF",
                      "aquamarine", "#7FFFD4",
                      "azure", "#F0FFFF",
                      "beige", "#F5F5DC",
                      "bisque", "#FFE4C4",
                      "black", "#000000",
                      "blanchedalmond", "#FFEBCD",
                      "blue", "#0000FF",
                      "blueviolet", "#8A2BE2",
                      "brown", "#A52A2A",
                      "burlywood", "#DEB887",
                      "cadetblue", "#5F9EA0",
                      "chartreuse", "#7FFF00",
                      "chocolate", "#D2691E",
                      "coral", "#FF7F50",
                      "cornflowerblue", "#6495ED",
                      "cornsilk", "#FFF8DC",
                      "crimson", "#DC143C",
                      "cyan", "#00FFFF",
                      "darkblue", "#00008B",
                      "darkcyan", "#008B8B",
                      "darkgoldenrod", "#B8860B",
                      "darkgray", "#A9A9A9",
                      "darkgreen", "#006400",
                      "darkkhaki", "#BDB76B",
                      "darkmagenta", "#8B008B",
                      "darkolivegreen", "#556B2F",
                      "darkorange", "#FF8C00",
                      "darkorchid", "#9932CC",
                      "darkred", "#8B0000",
                      "darksalmon", "#E9967A",
                      "darkseagreen", "#8FBC8F",
                      "darkslateblue", "#483D8B",
                      "darkslategray", "#2F4F4F",
                      "darkturquoise", "#00CED1",
                      "darkviolet", "#9400D3",
                      "deeppink", "#FF1493",
                      "deepskyblue", "#00BFFF",
                      "dimgray", "#696969",
                      "dimgrey", "#696969",
                      "dodgerblue", "#1E90FF",
                      "firebrick", "#B22222",
                      "floralwhite", "#FFFAF0",
                      "forestgreen", "#228B22",
                      "fuchsia", "#FF00FF",
                      "gainsboro", "#DCDCDC",
                      "ghostwhite", "#F8F8FF",
                      "gold", "#FFD700",
                      "goldenrod", "#DAA520",
                      "gray", "#808080",
                      "green", "#008000",
                      "greenyellow", "#ADFF2F",
                      "honeydew", "#F0FFF0",
                      "hotpink", "#FF69B4",
                      "indianred", "#CD5C5C",
                      "indigo", "#4B0082",
                      "ivory", "#FFFFF0",
                      "khaki", "#F0E68C",
                      "lavender", "#E6E6FA",
                      "lavenderblush", "#FFF0F5",
                      "lawngreen", "#7CFC00",
                      "lemonchiffon", "#FFFACD",
                      "lightblue", "#ADD8E6",
                      "lightcoral", "#F08080",
                      "lightcyan", "#E0FFFF",
                      "lightgoldenrodyellow", "#FAFAD2",
                      "lightgray", "#D3D3D3",
                      "lightgreen", "#90EE90",
                      "lightpink", "#FFB6C1",
                      "lightsalmon", "#FFA07A",
                      "lightseagreen", "#20B2AA",
                      "lightskyblue", "#87CEFA",
                      "lightslategray", "#778899",
                      "lightsteelblue", "#B0C4DE",
                      "lightyellow", "#FFFFE0",
                      "lime", "#00FF00",
                      "limegreen", "#32CD32",
                      "linen", "#FAF0E6",
                      "magenta", "#FF00FF",
                      "maroon", "#800000",
                      "mediumaquamarine", "#66CDAA",
                      "mediumblue", "#0000CD",
                      "mediumorchid", "#BA55D3",
                      "mediumpurple", "#9370DB",
                      "mediumseagreen", "#3CB371",
                      "mediumslateblue", "#7B68EE",
                      "mediumspringgreen", "#00FA9A",
                      "mediumturquoise", "#48D1CC",
                      "mediumvioletred", "#C71585",
                      "midnightblue", "#191970",
                      "mintcream", "#F5FFFA",
                      "mistyrose", "#FFE4E1",
                      "moccasin", "#FFE4B5",
                      "navajowhite", "#FFDEAD",
                      "navy", "#000080",
                      "oldlace", "#FDF5E6",
                      "olive", "#808000",
                      "olivedrab", "#6B8E23",
                      "orange", "#FFA500",
                      "orangered", "#FF4500",
                      "orchid", "#DA70D6",
                      "palegoldenrod", "#EEE8AA",
                      "palegreen", "#98FB98",
                      "paleturquoise", "#AFEEEE",
                      "palevioletred", "#DB7093",
                      "papayawhip", "#FFEFD5",
                      "peachpuff", "#FFDAB9",
                      "peru", "#CD853F",
                      "pink", "#FFC0CB",
                      "plum", "#DDA0DD",
                      "powderblue", "#B0E0E6",
                      "purple", "#800080",
                      "red", "#FF0000",
                      "rosybrown", "#BC8F8F",
                      "royalblue", "#4169E1",
                      "saddlebrown", "#8B4513",
                      "salmon", "#FA8072",
                      "sandybrown", "#F4A460",
                      "seagreen", "#2E8B57",
                      "seashell", "#FFF5EE",
                      "sienna", "#A0522D",
                      "silver", "#C0C0C0",
                      "skyblue", "#87CEEB",
                      "slateblue", "#6A5ACD",
                      "slategray", "#708090",
                      "snow", "#FFFAFA",
                      "springgreen", "#00FF7F",
                      "steelblue", "#4682B4",
                      "tan", "#D2B48C",
                      "teal", "#008080",
                      "thistle", "#D8BFD8",
                      "tomato", "#FF6347",
                      "turquoise", "#40E0D0",
                      "violet", "#EE82EE",
                      "wheat", "#F5DEB3",
                      "white", "#FFFFFF",
                      "whitesmoke", "#F5F5F5",
                      "yellow", "#FFFF00",
                      "yellowgreen", "#9ACD32")

      t := Window.get_default_font_size()
      SIZES := [t-5, t-3, t, t+3, t+6, t+9, t+12] 
      ImageCache.name_image("rpp.BROKEN_LINK", BROKEN_LINK)
      default_font_clone := Window().set_font("sans")
   end

   public get_map(s)
      return member(maps, s)
   end

   public get_datalist(s)
      return member(datalists, s)
   end

   public set_last_highlight(c, u)
      if c ~=== \last_highlight_component then
         last_highlight_component.set_last_highlight()
      last_highlight_component := c
      last_highlight_component.set_last_highlight(u)
      return self
   end

   private convert_color(el, name)
      local s
      if s := el.get_attribute(name) then {
         return if s[1] == "#" then
            s
         else
            member(COLORS, map(trim(string(s))))
      }
   end

   public traverse_tab_order()
      coact(self)
      every (!self.form_tab_children).traverse_tab_order()
   end

   private synch_font(context)
      local s
      s := context.family
      if \context.bold then
         s ||:= ",bold"
      if \context.italic then
         s ||:= ",italic"
      s ||:= "," || SIZES[context.size]
      context.font := s
   end

   private status()
      local i, r, s, l
      repeat {
         status_ticker.sleep(200)
         i := worker_pool.count(self)
         if (i > 0) | (i ~=== running) then {
            if i = 0 then {
               msg("Done", 1500)
               # This flag will be &null if we haven't called
               # set_top_data; this may happen if we cancel a
               # request before downloading the top page data; in
               # that case there is no need to do anything.
               if \done_set_top_data then {
                  done_set_top_data := &null
                  page_fully_loaded()
               }
            } else {
               r := worker_pool.read(self)
               s := i || " running requests"
               if r > 0 then {
                  if l := (0 < worker_pool.length(self)) then
                     s ||:= ", read " || r || " of " || l || " bytes (" || ((r * 100) / l) || "%)"
                  else
                     s ||:= ", read " || r || " bytes"
               }
               msg(s)
            }
            if i ~=== running then {
               running := i
               do_update_grey()
            }
         }
      }
   end

   public link_left_clicked(url)
      (\ui).link_left_clicked(url)
      return self
   end

   public link_middle_clicked(url)
      (\ui).link_middle_clicked(url)
      return self
   end

   public create_link_menu(url)
      return (\ui).create_link_menu(url)
   end

   public create_page_menu()
      return (\ui).create_page_menu()
   end

   public is_visited(url)
      return (\ui).is_visited(url)
   end

   public create_image_menu(img)
      return (\ui).create_image_menu(img)
   end

   public set_ui(ui)
      self.ui := ui
      return self
   end

   public msg(s, n, owner)
      /owner := self
      (\ui).msg(s, n)
      msg_owner := owner
      return self
   end

   public clear_msg(owner)
      if /msg_owner | /owner | (owner === msg_owner) then {
         (\ui).clear_msg()
         msg_owner := &null
      }
      return self
   end

   public page_loaded()
      (\ui).page_loaded()
      return self
   end

   public update_grey(gs)
      (\ui).update_grey(gs)
      return self
   end

   public get_authentication(dom, realm)
      local d
      d := AuthenticationDialog(dom, realm)
      d.show_modal(parent_dialog)
      return \d.result
   end

   public do_update_grey()
      update_grey(GreyState(if history_pos > 1 then &no else &yes,
                            if history_pos < *history then &no else &yes,
                            if history[history_pos] then &no else &yes,
                            if \page_url then &no else &yes,
                            if \page_data then &no else &yes,
                            if running === 0 then &yes else &no))
   end

   private page_fully_loaded()
      local xp, yp, f
      reset_all_layouts()
      layout()
      invalidate()
      # Goto named anchor and maybe set focus unless user has started to scroll page
      if get_area_y() = get_area_x() = 0 then {
         if yp := \curr_history_entry.area_y | (lookup_named_anchor(page_url.get_fragment()) - view.y) then {
            set_area_y(yp)
            if xp := \curr_history_entry.area_x then
               set_area_x(xp)
         }
         # If the user has placed the focus in a component in the new
         # page, just ensure it's still visible; otherwise set the
         # focus to any history/autofocus component; this will scroll
         # to the component if necessary (see focus_scroll).  Note
         # that if this browser's tab is not current, then the various
         # focus methods fail and no change to the focus is made.
         if view === (f := parent_dialog.get_focus()).gen_parents() then
            focus_scroll(, f)
         else if page_resp.kind = Worker.NAVIGATE then
            parent_dialog.set_focus(get_nth_focusable(\curr_history_entry.focus_index))
         else {
            if f := (!forms).get_autofocus() then
               parent_dialog.set_focus(f.gen_focusable())
         }
      }
      parent_dialog.resynch_pointer()
      (\ui).page_fully_loaded()
   end

   private lookup_named_anchor(name)
      local c, yp
      every c := Seq{traverse_postorder()} do
         if is(c,TextFlow) & yp := c.lookup_named_anchor(name) then
            return yp
   end

   public static limit_text(s, n)
      return gui.limit_text(default_font_clone, s, n)
   end

   public initially()
      cast(self,ComponentScrollArea).initially()
      if /shared_worker_pool_flag then
         worker_pool.initially()
      status_ticker.start()
      do_update_grey()
   end

   public finally()
      cast(self,ComponentScrollArea).finally()
      if /shared_worker_pool_flag then
         worker_pool.finally()
      else
         worker_pool.cancel(self)
      running := 0
      scroll_ticker.stop()
      status_ticker.stop()
   end
   
   public do_next()
      local he
      he := history[history_pos +:= 1] 
      goto(he.url, he.referer, he.form_data, Worker.NAVIGATE)
      do_update_grey()
      return self
   end

   public do_prev()
      local he
      he := history[history_pos -:= 1] 
      goto(he.url, he.referer, he.form_data, Worker.NAVIGATE)
      do_update_grey()
      return self
   end

   public do_jump(he)
      history_pos := keyof(history, he) | fail
      goto(he.url, he.referer, he.form_data, Worker.NAVIGATE)
      do_update_grey()
      return self
   end

   private static point_comp(a, b)
      return (a.y < b.y) | (a.y = b.y & a.x < b.x)
   end

   private redo_search()
      local c, i
      \searched_term | fail
      i := keyof(sorted_searched, highlighted_searched)
      clear(searched)
      sorted_searched := []
      if *searched_term > 0 then {
         every c := Seq{traverse_postorder()} do
            if is(c,TextFlow) then
               c.search(searched_term, searched, sorted_searched)
      }
      qsort(sorted_searched, point_comp)
      highlighted_searched := sorted_searched[\i] | &null
   end

   public do_search(s)
      local c
      if *s > 0 then {
         searched_term := s
         clear(searched)
         sorted_searched := []
         every c := Seq{traverse_postorder()} do
            if is(c,TextFlow) then
               c.search(s, searched, sorted_searched)
         highlighted_searched := &null
         qsort(sorted_searched, point_comp)
      } else
         clear_searched()
      refresh()
      return self
   end

   private clear_searched()
      clear(searched)
      searched_term := sorted_searched := highlighted_searched := &null
   end

   public goto_searched(n)
      local t
      t := (\sorted_searched)[n] | fail
      (\highlighted_searched).textflow.invalidate(highlighted_searched.get_bounds())
      highlighted_searched := t.val
      highlighted_searched.textflow.invalidate(highlighted_searched.get_bounds())
      ensure_visible(highlighted_searched.get_bounds())
      return self
   end

   public do_refresh()
      local he
      he := history[history_pos] 
      goto(he.url, he.referer, he.form_data, Worker.REFRESH)
      do_update_grey()
      return self
   end

   public browse_for_file(s)
      return (\ui).browse_for_file(s)
   end

   public cancel()
      worker_pool.cancel(self)
   end

   private start_worker(req)
      worker_pool.start_worker(req)
      running := &null
   end

   private static is_image(ct, s)
      if map((\ct).type) == "image" then
         return
      return match("\x89PNG\x0D\x0A\x1A\x0A" |
                   "\xFF\xD8" |
                   "GIF87a" | "GIF89a", s)
   end

   private static is_text(ct, s)
      \ct | fail
      if (map(ct.type) == "text") |
         (map(ct.type) == "application" & map(ct.subtype) == "json") then
         return
   end

   private static is_html(ct, s)
      if map((\ct).subtype) == "html" then
         return
      s ? {
         while tab(upto('<')) do {
            if matchcl("<!doctype" | "<html" | "<meta") then
               return
            # Expect html comment (see htmlparser.icn)
            ="<!" | fail
            repeat {
               tab(upto('->'))
               if u">" then
                  break
               ="--" | fail
               tab(find("--")) | fail
               ="--"
            }
         }
      }
   end

   private save_form_values()
      local f, c, name, t1, t2, fk, k
      t1 := table()
      every f := !forms do {
         if fk := f.get_save_key() then {
            t2 := table()
            insert(t1, fk, t2)
            every c := !f.items do {
               if name := c.get_save_key() then {
                  k := Class.get_name(c) || u":" || name
                  k ||:= u":" || c.get_save_subkey()
                  insert(t2, k, c.get_save_value())
               }
            }
         }
      }
      curr_history_entry.form_values := t1
   end

   private restore_last_highlight()
      local c
      if c := get_nth_child(\curr_history_entry.last_highlight_component_index) &
         is(c, HasLastHighlight) &
         c.set_last_highlight_index(\curr_history_entry.last_highlight_index) then
         last_highlight_component := c
   end

   private restore_form_values()
      local f, c, name, t1, t2, k
      t1 := \curr_history_entry.form_values | fail
      every f := !forms do {
         if t2 := member(t1, f.get_save_key()) then {
            every c := !f.items do {
               if name := c.get_save_key() then {
                  k := Class.get_name(c) || u":" || name
                  k ||:= u":" || c.get_save_subkey()
                  c.restore_value(member(t2, k))
               }
            }
         }
      }
   end

   public static to_content(s)
      local t, ch
      t := ""
      string(s) ? repeat {
         t ||:= tab(upto('<&') | 0)
         ch := move(1) | break
         t ||:= case ch of {
            "<": "&lt;"
            "&": "&amp;"
         }
      }
      return t
   end

   public static to_attr(s)
      local t, ch
      t := ""
      string(s) ? repeat {
         t ||:= tab(upto('\"\'&') | 0)
         ch := move(1) | break
         t ||:= case ch of {
            "\"": "&quot;"
            "\'": "&apos;"
            "&": "&amp;"
         }
      }
      return t
   end

   public static mk_anchor(url, lim)
      local s1, s2
      /lim := 1000
      s1 := s2 := url.str()
      s2 := limit_text(s2, lim)
      return "<a href=\"" || to_attr(s1) || "\">" || Browser.to_content(s2) || "</a>"
   end

   public static mk_anchor_cell(url, lim)
      return "<td nowrap>" || mk_anchor(url, lim) || "</td>"
   end

   private get_nth_focusable(n)
      local c
      every c := view.gen_focusable() do {
         n -:= 1
         if n = 0 then
            return c
      }
   end

   private get_focusable_index(focus)
      local n, c
      n := 0
      every c := view.gen_focusable() do {
         n +:= 1
         if focus === c then
            return n
      }
   end

   private get_nth_child(n)
      local c
      every c := Seq{view.traverse_preorder()} do {
         n -:= 1
         if n = 0 then
            return c
      }
   end

   private get_child_index(child)
      local n, c
      n := 0
      every c := Seq{view.traverse_preorder()} do {
         n +:= 1
         if child === c then
            return n
      }
   end

   # Set a border around the outermost (top level) `TextFlow`; by
   # default this is a `NullBorder`.
   #
   public set_outermost_border(b)
      self.outermost_border := b
      return self
   end

   private set_top_data(res)
      local doc, s, row, c, cu
      if \curr_history_entry then {
         save_form_values()
         curr_history_entry.area_x := get_area_x()
         curr_history_entry.area_y := get_area_y()
         curr_history_entry.focus_index := get_focusable_index(parent_dialog.get_focus()) | &null
         curr_history_entry.last_highlight_component_index := get_child_index(\last_highlight_component) | &null
         curr_history_entry.last_highlight_index := (\last_highlight_component).get_last_highlight_index() | &null
      }
      set_area_y(0).set_area_x(0)
      if \res.err & /res.data then {
         s := "<html><title>Error</title>" || 
            "<h1>Error:</h1>Getting " || mk_anchor(res.url) || "<br><br>" || res.err || "</html>"
         page_data := &null
      } else {
         if is_html(res.content_type, res.data) then
            s := res.data
         else if is_text(res.content_type, res.data) then
            s := "<html><title>" || to_content(res.fname) || "</title>" || 
               "<pre>" || to_content(res.data) || "</pre></html>"
         else if is_image(res.content_type, res.data) then {
            cu := worker_pool.cache.create_url(, res.data, res.fname, res.content_type)
            s := "<html><title>" || to_content(res.fname) || "</title>" || 
               "<img src=\"" || to_attr(cu.str()) || "\"/></html>"
         } else
            s := "<html><title>Problem</title>" || 
               "<h1>Problem:</h1>Displaying " || mk_anchor(res.url) || "<br><br>This does not seem to be an HTML or text document or an image.</html>"
         page_data := res.data
      }
      page_name := res.fname
      page_resp := res
      page_url := res.url
      clear_searched()
      if res.kind = Worker.NORMAL then {
         # Reset history_pos, since we may have done a navigate
         # back/forward (changing history_pos), and cancelled it with
         # a normal click whist it was pending.
         history_pos := keyof(history, curr_history_entry)
         while *history > history_pos do
            pull(history)
         # Fields are set below
         put(history, HistoryEntry())
         history_pos +:= 1
      }
      do_update_grey()
      curr_history_entry := history[history_pos]
      # Note that the url/form_data may change even on a
      # navigate/refresh, if the server behaved differently (eg
      # redirect instead of error).
      curr_history_entry.url := page_url
      curr_history_entry.referer := res.referer
      curr_history_entry.form_data := res.form_data
      maps := table()
      datalists := table()
      forms := []
      form_tab_children := []
      # Convert s to ucs
      s := if map((\res.content_type).get_parameter("charset")) == "iso-8859-1" then
         Text.iso_8859_1_to_ucs(s)
      else
         Text.liberal_ucs(s)
      doc := HtmlParser().parse(s)
      page_base := page_url
      row := TextFlow(self).
         set_border(outermost_border)
      page_title := &null
      page_links := []
      page_alink_color := "red"
      page_vlink_color := "#800080"
      page_link_color := "blue"
      page_text_color := "black"
      c := Context()
      c.family := "sans"
      c.fg := page_text_color
      c.size := 3
      c.align := Align.L
      synch_font(c)
      traverse(doc, row, c)
      curr_history_entry.title := page_title
      if page_resp.kind = Worker.NAVIGATE then
         restore_form_values()
      every form_tab_children |||:= (!forms).get_tab_children()
      set_inner(row)
      layout()
      invalidate()
      if page_resp.kind = Worker.NAVIGATE then
         restore_last_highlight()
      else
         last_highlight_component := &null
      parent_dialog.resynch_pointer()
      setup_tabbing()
      page_loaded()
      done_set_top_data := 1
   end

   private focus_scroll(e, c)
      local d
      # Try and find a parent component which has this component as
      # its preferred focus (eg a Spin with a TextField); if found
      # then make the (larger) parent visible, rather than the child.
      every d := c.parent.gen_parents() do {
         if d.get_preferred_focus() === c then {
            c := d
            break
         }
      }
      ensure_visible(c)
   end

   private setup_tabbing()
      local c
      every c := Seq{(!self.form_tab_children).traverse_tab_order()} do {
         # Note that we the c may be hidden (since the browser tab may
         # be not be the current one), so the test is not the same as
         # say in find_focus().
         if c.accepts_focus() & c.is_unshaded() then
            c.connect(focus_scroll, Event.GOT_FOCUS)
      }
   end

   private mk_link(s)
      return URL(s) | page_base.get_relative(s)
   end

   private traverse_a(e, p, context)
      local url, c, na
      if na := e.get_attribute(u"NAME") then {
         put(p.input, NamedAnchorCmd(na, context))
         traverse(e, p, context)
      }
      else if url := mk_link(e.get_attribute(u"HREF")) then {
         put(page_links, url)
         c := copy(context)
         c.url := url
         c.fg := if is_visited(url) then page_vlink_color else page_link_color
         traverse(e, p, c)
      }
   end

   private traverse_hN(e, p, context)
      local c
      put_para(p, context)
      c := copy(context)
      c.size := 7 - e.name[-1]
      c.bold := 1
      synch_font(c)
      traverse(e, p, c)
      put_para(p, c)
   end

   private parse_size(s, curr)
      local i
      i := if any('+\-', s[1]) then
         curr + integer(s)
      else
         integer(s)
      return (0 < \i <= 7, i)
   end

   private static valid_family(fam)
      local w
      return use {
         w := Window(),
         w.set_font(fam) & fam
      }
   end

   private static select_family(faces)
      local e
      every e := map(trim(separate(string(faces)))) do {
         # If we have one of the four standard families (or their html
         # equivalent names), return that.
         if e := case e of {
            "serif": "serif"
            "sans"|"sans-serif": "sans"
            "mono"|"monospace": "mono"
            "typewriter": "typewriter"
         } then
            return e
         # If the face is usable as a family, return it.
         if valid_family(e) then
            return e
      }
      # Having failed with all alternatives, try a mapping of common
      # families based on the last family in the input list.
      if e := case e of {
         "cursive"|"fantasy"|"times"|"times new roman": "serif"
         "helvetica"|"arial": "sans"
         "courier": "typewriter"
      } then
         return e
   end

   private traverse_font(e, p, context)
      local c
      c := copy(context)
      c.fg := convert_color(e, u"COLOR")
      c.family := select_family(e.get_attribute(u"FACE"))
      c.size := parse_size(e.get_attribute(u"SIZE"), c.size)
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_tt(e, p, context)
      local c
      c := copy(context)
      c.family := "mono"
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_big(e, p, context)
      local c
      c := copy(context)
      if c.size < 7 then {
         c.size +:= 1
         synch_font(c)
      }
      traverse(e, p, c)
   end

   private traverse_small(e, p, context)
      local c
      c := copy(context)
      if c.size > 1 then {
         c.size -:= 1
         synch_font(c)
      }
      traverse(e, p, c)
   end

   private traverse_sup(e, p, context)
      local c
      c := copy(context)
      if c.size > 1 then {
         c.size -:= 1
         synch_font(c)
      }
      put(p.input, SupStartCmd(c))
      traverse(e, p, c)
      put(p.input, SupEndCmd(c))
   end

   private traverse_sub(e, p, context)
      local c
      c := copy(context)
      if c.size > 1 then {
         c.size -:= 1
         synch_font(c)
      }
      put(p.input, SubStartCmd(c))
      traverse(e, p, c)
      put(p.input, SubEndCmd(c))
   end

   private traverse_b(e, p, context)
      local c
      c := copy(context)
      c.bold := 1
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_i(e, p, context)
      local c
      c := copy(context)
      c.italic := 1
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_mark(e, p, context)
      local c
      c := copy(context)
      c.mark := 1
      traverse(e, p, c)
   end

   private traverse_address(e, p, context)
      local c
      c := copy(context)
      c.italic := 1
      synch_font(c)
      put_new_row(p, c)
      traverse(e, p, c)
      put_new_row(p, c)
   end

   private traverse_u(e, p, context)
      local c
      c := copy(context)
      c.underline := 1
      traverse(e, p, c)
   end

   private traverse_s(e, p, context)
      local c
      c := copy(context)
      c.strike := 1
      traverse(e, p, c)
   end

   private traverse_form(e, p, context)
      local m, c, t, url, id
      m := map(string(e.get_attribute(u"METHOD"))) | "get"
      t := string(e.get_attribute(u"ENCTYPE")) | "application/x-www-form-urlencoded"
      url := mk_link(e.get_attribute(u"ACTION"))
      id := e.get_attribute(u"ID" | u"NAME")
      c := copy(context)
      c.form := Form(self, id, url, m, t)
      put(forms, c.form)
      traverse(e, p, c)
      c.form.resolve_labels()
   end

   private traverse_label(e, p, context)
      local c, l, id
      \context.form | fail
      id := e.get_attribute(u"FOR")
      l := FormLabel(id, context.form)
      put(context.form.labels, l)
      c := copy(context)
      c.form_label := l
      traverse(e, p, c)
   end

   private dump_forms()
      local f, i
      every f := !forms do {
         every write(to_string(f,3,,1))
         every i := !f.items do {
            write("\t",image(i.form_id), "->", to_string(i,3,,0))
         }
      }
   end

   private add_component(p, c, context, align)
      /align := "absbottom"
      put(p.input, ComponentCmd(c, context, align))
      c.set_tooltip(context.title).
         set_fg(context.fg).
         set_font(context.font)
      p.add(c)
   end

   private traverse_button(e, p, context)
      local q, v, type
      \context.form | fail
      v := e.get_attribute(u"VALUE") | u""
      type := map(string(e.get_attribute(u"TYPE"))) | "submit"
      q := FormTextFlowButton(context.form, v, type)
      add_form_component(e, p, q, context)
      traverse(e, q.tf, context)
   end

   private traverse_img(e, p, context)
      local q, url, border, align, map, s, alt, hspace, vspace
      url := mk_link(e.get_attribute(u"SRC")) | fail
      if (s := e.get_attribute(u"USEMAP")) & (s[1] == u"#") then
         map := default.map(string(s[2:0]))
      alt := e.get_attribute(u"ALT")
      q := Img(self, context, url, alt,, map)
      do_width_param(e, q)
      do_height_param(e, q)
      # % width not allowed if no breaking mode, since it
      # would mean we couldn't calculate the blob widths in
      # the row (and hence the preferred width of the
      # TextFlow).
      if \context.nowrap | \context.pre then
         q.remove_constraint("pct_w")
      border := (0 < integer(e.get_attribute(u"BORDER"))) | 0
      hspace := (0 < integer(e.get_attribute(u"HSPACE"))) | 0
      vspace := (0 < integer(e.get_attribute(u"VSPACE"))) | 0
      if (hspace | vspace) > 0 then {
         if border > 0 then
            q.set_border(CompoundBorder().
                            set_outer(EmptyBorder().set_insets(hspace, hspace, vspace, vspace)).
                            set_inner(PlainBorder().set_line_width(border)))
         else
            q.set_border(EmptyBorder().set_insets(hspace, hspace, vspace, vspace))
      } else if border > 0 then
         q.set_border(PlainBorder().set_line_width(border))
      start_worker(Req(self, url, page_url, q.got_data, page_resp.kind))
      align := convert_comp_align(e, u"ALIGN") | Align.B
      add_component(p, q, context, align)
   end

   private add_form_component(e, p, q, context)
      if e.get_attribute(u"DISABLED") then
         q.set_is_shaded(&yes)
      else
         context.form.add_component(context, e, q)
      add_component(p, q, context, Align.B)
   end

   private traverse_select(e, p, context)
      local q, c, sc, size, mW, h, w, o, sel, sels, i, mode
      \context.form | fail
      sc := SelectContext()
      sc.options := []
      sc.optgroup := 0
      c := copy(context)
      c.select := sc
      traverse(e, p, c)
      sels := []
      every i := 1 to *sc.options do
         if \sc.options[i].selected then
            put(sels, i)
      if size := (1 < integer(e.get_attribute(u"SIZE"))) then {
         use {
            mW := cbwin.clone().set_font(context.font),
            {
               w := 0
               every o := !sc.options do
                  w <:= mW.text_width(o.txt)
               w +:= 2 * Gui.TEXT_INSET + 2 * Gui.BORDER_WIDTH
               h := (2 * Gui.BORDER_WIDTH + size * mW.get_font_height())
               if size < *sc.options then
                  w +:= ScrollArea.predict_scrollbar_size()
            }
         }
         if e.get_attribute(u"MULTIPLE") then
            mode := Select.MANY
         else {
            mode := Select.ONE
            while *sels > 1 do
               pull(sels)
         }
         q := FormOptionList(sels).
            set_contents(sc.options).
            set_size(w, h).
            set_select_mode(mode).
            set_selections(sels)
      } else {
         if *sels = 0 then {
            every i := 1 to *sc.options do
               if \sc.options[i].value then {
                  sel := i
                  break
               }
         } else
            sel := sels[1]
         q := FormList(sel).
            set_selection_list(sc.options).
            set_selection(sel)
      }
      add_form_component(e, p, q, context)
   end

   private traverse_option(e, p, context)
      local dc, sc, v, txt, label, disabled, selected
      if sc := \context.select then {
         label := e.get_trimmed_string_content()
         if e.get_attribute(u"DISABLED") then
            disabled := 1
         else {
            v := e.get_attribute(u"VALUE") | label
            if e.get_attribute(u"SELECTED") then
               selected := 1
         }
         txt := repl(u"    ", sc.optgroup) || label
         put(sc.options, FormOption(txt, label, v, selected, disabled))
      } else if dc := \context.datalist then {
         label := (u"" ~== e.get_trimmed_string_content())
         v := e.get_attribute(u"VALUE")
         /label := v
         /v := label
         if (not e.get_attribute(u"DISABLED")) & \label then
            put(dc.options, FormOption(label, label, v))
      }
   end

   private traverse_optgroup(e, p, context)
      local sc, label
      sc := \context.select | fail
      label := e.get_attribute(u"LABEL") | u""
      put(sc.options, FormOption(repl(u"    ", sc.optgroup) || u"--- " || label || u" ---", label,,,, 1))
      sc.optgroup +:= 1
      traverse(e, p, context)
      sc.optgroup -:= 1
   end

   private traverse_textarea(e, p, context)
      local q, w, h, mW
      \context.form | fail
      use {
         mW := cbwin.clone().set_font(context.font),
         {
            w := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + mW.text_width(repl("x", e.get_attribute(u"COLS")))) | 200
            h := (2 * Gui.BORDER_WIDTH + e.get_attribute(u"ROWS") * mW.get_font_height()) | 100
         }
      }
      # The ucs conversion is used here since an empty node will return "" (not u"").
      strip_newlines(e)
      q := FormEditableTextList(ucs(e.get_trimmed_string_content())).
         set_size(w, h)
      if e.get_attribute(u"READONLY") then
         q.set_is_editable(&no)
      add_form_component(e, p, q, context)
   end

   private traverse_input(e, p, context)
      local q, s, k, v, size, mW, url, checked, align, min, max, step, alt, did
      \context.form | fail
      s := string(map(e.get_attribute(u"TYPE"))) | "text"
      case s of {
         "file": {
            use {
               mW := cbwin.clone().set_font(context.font),
               size := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + mW.text_width(repl("x", e.get_attribute(u"SIZE")))) | 160
            }
            q := FormBrowse(self, size)
            add_form_component(e, p, q, context)
         }
         "submit" : {
            v := e.get_attribute(u"VALUE")
            if /v | (*v = 0) then
               v := u"Submit"
            q := FormButton(v).
                  connect(context.form.submit, Event.ACTION)
            add_form_component(e, p, q, context)
         }
         "button" : {
            v := e.get_attribute(u"VALUE") | u""
            q := FormButton(v)
            add_form_component(e, p, q, context)
         }
         "image" : {
            if url := mk_link(e.get_attribute(u"SRC")) then {
               alt := e.get_attribute(u"ALT")
               q := Img(self, context, url, alt, context.form)
               do_width_param(e, q)
               do_height_param(e, q)
               # % width not allowed if no breaking mode, since it
               # would mean we couldn't calculate the blob widths in
               # the row (and hence the preferred width of the
               # TextFlow).
               if \context.nowrap | \context.pre then
                  q.remove_constraint("pct_w")
               start_worker(Req(self, url, page_url, q.got_data, page_resp.kind))
               if e.get_attribute(u"DISABLED") then
                  q.set_is_shaded(&yes)
               else {
                  if k := e.get_attribute(u"NAME") then {
                     context.form.add(k || ".x", FormImgX(q))
                     context.form.add(k || ".y", FormImgY(q))
                  } else {
                     context.form.add("x", FormImgX(q))
                     context.form.add("y", FormImgY(q))
                  }
               }
               align := convert_comp_align(e, u"ALIGN") | Align.B
               add_component(p, q, context, align)
            }
         }
         "reset" : {
            v := e.get_attribute(u"VALUE")
            if /v | (*v = 0) then
               v := u"Reset"
            q := FormButton(v).
               connect(context.form.reset_form, Event.ACTION)
            add_form_component(e, p, q, context)
         }
         "hidden": {
            context.form.add(e.get_attribute(u"NAME"), Hidden(e.get_attribute(u"VALUE")))
         }
         "radio": {
            v := e.get_attribute(u"VALUE") | u"on"
            checked := if e.get_attribute(u"CHECKED") then &yes else &no
            q := FormToggle(v, checked).
               set_paint(ImagePaint().set_cache("gui.DIAMOND_UP")).
               set_paint_down(ImagePaint().set_cache("gui.DIAMOND_DOWN")).
               set_border(NullBorder())
            add_form_component(e, p, q, context)
            context.form.get_cbg(e.get_attribute(u"NAME")).add(q)
         }
         "checkbox": {
            v := e.get_attribute(u"VALUE") | u"on"
            checked := if e.get_attribute(u"CHECKED") then &yes else &no
            q := FormToggle(v, checked).
               set_paint(ImagePaint().set_cache("gui.BOX_UP")).
               set_paint_down(ImagePaint().set_cache("gui.BOX_DOWN")).
               set_border(NullBorder())
            add_form_component(e, p, q, context)
         }
         "date": {
            v := Time.parse(e.get_attribute(u"VALUE"), "yyyy-MM-dd") | Time()
            q := FormDateField(v)
            add_form_component(e, p, q, context)
         }
         "time": {
            v := FormTimeField.parse(e.get_attribute(u"VALUE")) | Time()
            q := FormTimeField(v)
            add_form_component(e, p, q, context)
         }
         "week": {
            v := FormWeekField.parse(e.get_attribute(u"VALUE")) | Time()
            q := FormWeekField(v)
            add_form_component(e, p, q, context)
         }
         "month": {
            v := FormMonthYearField.parse(e.get_attribute(u"VALUE")) | Time()
            q := FormMonthYearField(v)
            add_form_component(e, p, q, context)
         }
         "datetime": {
            v := FormDateTimeField.parse(e.get_attribute(u"VALUE")) | Time()
            q := FormDateTimeField(v)
            add_form_component(e, p, q, context)
         }
         "datetime-local": {
            v := FormDateTimeLocalField.parse(e.get_attribute(u"VALUE")) | Time()
            q := FormDateTimeLocalField(v)
            add_form_component(e, p, q, context)
         }
         "color": {
            v := FormColorField.parse(e.get_attribute(u"VALUE")) | "white"
            q := FormColorField(v)
            add_form_component(e, p, q, context)
         }
         "range": {
            min := numeric(e.get_attribute(u"MIN")) | 0
            v := e.get_attribute(u"STEP")
            step := if /v then 1 else if map(v) == u"any" then 1.0 else (0 < numeric(v)) | 1
            # If min and step are both integer, then the values must be too.
            if type(min) == type(step) == "integer" then {
               max := integer(e.get_attribute(u"MAX")) | (min + 10)
               v := integer(e.get_attribute(u"VALUE")) | min
            } else {
               min := real(min)
               step := real(step)
               max := real(e.get_attribute(u"MAX")) | (min + 10.0)
               v := real(e.get_attribute(u"VALUE")) | min
            }
            q := FormRange(v).
               set_range(min, max).
               set_snaps(step).
               set_is_horizontal(&yes).
               set_width(160)
            add_form_component(e, p, q, context)
         }
         "number": {
            min := numeric(e.get_attribute(u"MIN"))
            v := e.get_attribute(u"STEP")
            step := if /v then 1 else if map(v) == u"any" then 1.0 else (0 < numeric(v)) | 1
            # If min is null or integer, and step is integer, then the values must be integer too.
            if (/min | type(min) == "integer") & (type(step) == "integer") then {
               max := integer(e.get_attribute(u"MAX"))
               v := integer(e.get_attribute(u"VALUE")) | \min | 0
            } else {
               min := real(min)
               step := real(step)
               max := real(e.get_attribute(u"MAX"))
               v := real(e.get_attribute(u"VALUE")) | \min | 0.0
            }
            q := FormNumberField(v).
               set_range(min, max).
               set_increment_size(step)
            if /max then
               q.set_width(100)
            add_form_component(e, p, q, context)
         }

         # Assume something textual; could be password, text, email etc.
         default: {
            v := e.get_attribute(u"VALUE") | u""
            did := map(string(e.get_attribute(u"LIST")))
            use {
               mW := cbwin.clone().set_font(context.font),
               size := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + mW.text_width(repl("x", e.get_attribute(u"SIZE")))) | 160
            }
            q := FormTextField(self, v, did).
               set_width(size).
               connect(context.form.submit, Event.ACTION)
            if s == "password" then
               q.set_displaychar("*")
            if e.get_attribute(u"READONLY") then
               q.set_is_editable(&no)
            q.set_placeholder(e.get_attribute(u"PLACEHOLDER"))
            add_form_component(e, p, q, context)
         }
      }
      traverse(e, p, context)
   end

   private show_parents(c)
      write("chain of ",image(c))
      while \c do {
         write("\tc=",image(c))
         c := c.parent
      }
   end

   private show_input(ii, l)
      local s,a
      case classof(ii) of {
         TextCmd: {
            s := ii.s
            if *s > 30 then 
               s[30:0] := "...("||*s||")"
            a := ""
            a ||:= "fg="|| \ii.attr.fg
            a ||:= " font="|| \ii.attr.font
            write(repl("   ",l), image(s),"  ",a) 
         }
         ComponentCmd: show_structure(ii.c, l)
         default: write(repl("   ",l),image(ii))
      }
   end

   private show_output(xo, l)
      local s,a
      s := "Text @"||xo.x||","||xo.y
      s ||:= xo.s
      if *s > 30 then 
         s[30:0] := "...("||*s||")"
      a := ""
      a ||:= "fg="|| \xo.attr.fg
      a ||:= " font="|| \xo.attr.font
      write(repl("   ",l), image(s),"  ",a) 
   end

   private show_structure(c, l)
      local s, v, short
      /l := 0
      short := s := ""
      short ||:= "w="||\c.w||" h="||\c.h
      if is(c, TextFlow) then short ||:= "  " || *c.input || " items"
      if c.get_constraint("eol") then s ||:= "eol "
      if \c.get_constraint("x_fill") then s ||:= "x_fill "
      if v := c.get_constraint("x_weight") then s ||:= "x_weight=" || v
      if v := c.get_constraint("x_align") then s ||:= "x_align=" || v
      write(repl("   ",l), image(c),short,"\t\t\t",s)
      if is(c, TextFlow) then {
         every show_input((!c.input), l+1)
      } else
         every show_structure((!c.children), l+1)
   end

   private traverse_div(e, p, context)
      put_new_row(p, context)
      traverse(e, p, context)
   end

   private traverse_br(e, p, context)
      local clear
      clear := case string(map(e.get_attribute(u"CLEAR"))) of {
         "left": Align.L
         "right": Align.R
         "all"|"both": "all"
      }
      put(p.input, BreakCmd(clear, context))
   end

   private traverse_nobr(e, p, context)
      local c
      c := copy(context)
      c.nowrap := 1
      traverse(e, p, c)
   end

   private traverse_hr(e, p, context)
      local l, c
      l := Line().
         set_width(1)
      do_width_param(e, l) | l.set_constraint("pct_w", 100)
      c := copy(context)
      put_new_row(p, c)
      c.align := convert_halign(e, u"ALIGN") | Align.C
      add_component(p, l, c)
      put_new_row(p, c)
   end

   private traverse_q(e, p, context)
      put(p.input, TextCmd(u"\u201c", context))
      traverse(e, p, context)
      put(p.input, TextCmd(u"\u201d", context))
   end

   private traverse_p(e, p, context)
      local c
      c := copy(context)
      put_para(p, c)
      c.align := convert_halign(e, u"ALIGN")
      traverse(e, p, c)
      put_para(p, c)
   end

   # Strip optional start and end newlines from the child content
   private strip_newlines(e)
      local s
      text(e.children[1]) ? {
         if =(u"\n" | u"\r\n") then {
            s := tab(0)
            if *s = 0 then
               delete(e.children, 1)
            else
               e.children[1] := s
         }
      }
      text(e.children[-1]) ? {
         tab(0)
         if (move(-2) == u"\r\n") | (move(-1) == u"\n") then {
            s := tab(1)
            if *s = 0 then
               delete(e.children, -1)
            else
               e.children[-1] := s
         }
      }
   end

   private traverse_pre(e, p, context)
      local c
      put_para(p, context)
      c := copy(context)
      c.family := "mono"
      strip_newlines(e)
      synch_font(c)
      c.pre := 1
      traverse(e, p, c)
      put_para(p, c)
   end

   private put_para(p, context)
      put(p.input, ParaCmd(context))
   end

   private put_new_row(p, context)
      put(p.input, NewRowCmd(context))
   end

   private traverse_center(e, p, context)
      local c
      c := copy(context)
      c.align := Align.C
      put_new_row(p, context)
      traverse(e, p, c)
      put_new_row(p, context)
   end

   private convert_valign(el, name)
      return case string(map(el.get_attribute(name))) of {
         "top": Align.T
         "middle": Align.C
         "bottom": Align.B
         "baseline": "baseline"
      }
   end

   private convert_halign(el, name)
      return case string(map(el.get_attribute(name))) of {
         "left": Align.L
         "center": Align.C
         "right": Align.R
      }
   end

   private convert_cap_align(el, name)
      return case string(map(el.get_attribute(name))) of {
         "left": Align.L
         "right": Align.R
         "top": Align.T
         "bottom": Align.B
      }
   end

   private convert_comp_align(el, name)
      return case map(string(el.get_attribute(name))) of {
         "left": Align.L
         "right": Align.R
         "baseline"|"bottom": Align.B
         "texttop"|"top": Align.T
         "middle" | "center" | "centre": Align.C
         "absbottom":  "absbottom"
         "absmiddle":  "absmiddle"
      }
   end

   private do_width_param(e, c, def_w)
      local width
      return if width := (e.get_attribute(u"WIDTH") | \def_w) then {
         if width := (0 <= integer(width)) then
            c.set_constraint("fix_w", width)
         else if width[-1] == "%" & width := (0 <= integer(width[1:-1])) then
            c.set_constraint("pct_w", width)
      }
   end

   private do_height_param(e, c)
      local height
      return if height := e.get_attribute(u"HEIGHT") then {
         if height := (0 <= integer(height)) then
            c.set_constraint("fix_h", height)
      }
   end

   private traverse_table(e, p, context)
      local ct, tbl, border, hspace, vspace, cellpadding, cellspacing, cell_border, align, c, i, t

      tbl := Tbl()
      border := (0 < integer(e.get_attribute(u"BORDER"))) | 0
      # hspace, vspace are non-standard, but firefox has them.
      hspace := (0 < integer(e.get_attribute(u"HSPACE"))) | 0
      vspace := (0 < integer(e.get_attribute(u"VSPACE"))) | 0
      cellpadding := (0 < integer(e.get_attribute(u"CELLPADDING"))) | 0
      cellspacing := (0 <= integer(e.get_attribute(u"CELLSPACING"))) | 2

      tbl.content.layout_delegate.set_doi(cellspacing).set_dii(cellspacing/2)
      tbl.set_bg(convert_color(e, u"BGCOLOR"))

      cell_border := if border > 0 & not(e.get_attribute(u"RULES")) then
         CompoundBorder().
            set_outer(PlainBorder().set_line_width(1)).
            set_inner(EmptyBorder().set_insets(cellpadding, cellpadding, cellpadding, cellpadding))
         else
            EmptyBorder().set_insets(cellpadding, cellpadding, cellpadding, cellpadding)
      # The align param is a bit of a hybrid.  If left or right, then
      # it behaves like a left/right aligned image.  If center, then
      # it is like enclosing the table in <center>.
      align := convert_halign(e, u"ALIGN")
      c := copy(context)
      c.align := (align === Align.C)
      c.table := ct := TableContext()
      ct.tbl := tbl
      ct.x := ct.y := 1
      ct.occ := set()
      ct.cell_border := cell_border
      ct.rowgroups := []
      ct.colgroups := []
      traverse(e, p, c)
      case string(map(e.get_attribute(u"RULES"))) of {
         "groups": {
            # NB - either of these lists may be empty
            tbl.content.set_hrules(set!ct.rowgroups[2:0])
            tbl.content.set_vrules(set!get_colgroup_cols(ct)[2:0])
         }
         "all": {
            i := 1
            every i <:= (!tbl.content.children).get_constraint("x")
            tbl.content.set_vrules(Set{2 to i})
            tbl.content.set_hrules(Set{2 to ct.y - 1})
         }
         "cols": {
            i := 1
            every i <:= (!tbl.content.children).get_constraint("x")
            tbl.content.set_vrules(Set{2 to i})
         }
         "rows": {
            tbl.content.set_hrules(Set{2 to ct.y - 1})
         }
      }

      if t := \c.table.caption then {
         if (hspace | vspace) > 0 then
            t.set_border(EmptyBorder().set_insets(hspace, hspace, vspace, vspace))
         if border > 0 then
            tbl.set_border(PlainBorder().set_line_width(border))
      } else {
         if (hspace | vspace) > 0 then {
            if border > 0 then
               tbl.set_border(CompoundBorder().
                              set_outer(EmptyBorder().set_insets(hspace, hspace, vspace, vspace)).
                              set_inner(PlainBorder().set_line_width(border)))
            else
               tbl.set_border(EmptyBorder().set_insets(hspace, hspace, vspace, vspace))
         } else if border > 0 then
            tbl.set_border(PlainBorder().set_line_width(border))
         t := tbl
      }

      do_width_param(e, t)
      do_height_param(e, t)

      if align === (Align.L | Align.R) then
         add_component(p, t, c, align)
      else {
         put_new_row(p, c)
         add_component(p, t, c, Align.B)
         put_new_row(p, c)
      }
   end

   private traverse_tbody(e, p, context)
      local ct
      ct := \context.table | fail
      put(ct.rowgroups, ct.y)
      traverse(e, p, context)
   end

   private traverse_caption(e, p, context)
      local ct, cap, main, c, align
      ct := \context.table | fail
      /ct.caption | fail

      # A Tbl with two TextFlows; the caption and another containing just the table itself.
      ct.caption := Tbl()
      cap := TextFlow(self).set_dominant_width(TextFlow.PREFERRED_WIDTH)
      c := copy(context)
      c.align := Align.C
      traverse(e, cap, c)
      main := TextFlow(self)
      add_component(main, ct.tbl, context)
      ct.tbl.set_constraint("pct_w", 100)
      align := convert_cap_align(e, u"ALIGN") | Align.T
      case align of {
         Align.T: {
            cap.set_constraint("eol", &yes)
            ct.caption.content.add(cap).add(main)
         }
         Align.B: {
            main.set_constraint("eol", &yes)
            ct.caption.content.add(main).add(cap)
         }
         Align.L: {
            ct.caption.content.add(cap).add(main)
         }
         Align.R: {
            ct.caption.content.add(main).add(cap)
         }
      }
   end

   private traverse_colgroup(e, p, context)
      local ct, cg
      ct := \context.table | fail
      cg := TableColGroup()
      cg.span := (0 < integer(e.get_attribute(u"SPAN"))) | 1
      cg.width := e.get_attribute(u"WIDTH")
      cg.valign := convert_valign(e, u"VALIGN")
      cg.align := convert_halign(e, u"ALIGN")
      cg.cols := []
      put(ct.colgroups, cg)
      ct.curr_colgroup := cg
      traverse(e, p, context)
      ct.curr_colgroup := &null
   end

   private traverse_col(e, p, context)
      local ct, cg, tc
      ct := \context.table | fail
      cg := \ct.curr_colgroup | fail
      tc := TableCol()
      tc.span := (0 < integer(e.get_attribute(u"SPAN"))) | 1
      tc.width := e.get_attribute(u"WIDTH") | cg.width
      tc.valign := convert_valign(e, u"VALIGN") | cg.valign
      tc.align := convert_halign(e, u"ALIGN") | cg.align
      put(cg.cols, tc)
   end

   private traverse_tr(e, p, context)
      local ct
      ct := \context.table | fail
      ct.tr := e
      if ct.x > 1 then {
         ct.x := 1
         ct.y +:= 1
      }
      traverse(e, p, context)
      if ct.x > 1 then {
         ct.x := 1
         ct.y +:= 1
      }
      ct.tr := &null
   end

   private get_col_info(ct, n)
      local i, e, f
      i := 0
      every e := !ct.colgroups do {
         if *e.cols > 0 then {
            every f := !e.cols do {
               if i + f.span >= n then
                  return f
               i +:= f.span
            }
         } else {
            if i + e.span >= n then
               return e
            i +:= e.span
         }
      }
   end

   private get_colgroup_cols(ct)
      local i, e, l
      i := 1
      l := []
      every e := !ct.colgroups do {
         put(l, i)
         if *e.cols > 0 then
            every i +:= (!e.cols).span
         else
            i +:= e.span
      }
      return l
   end

   private traverse_td(e, p, context)
      local ct, row, c, colspan, rowspan, valign, col, def_w
      ct := \context.table | fail
      while member(ct.occ, ct.x || "," || ct.y) do
         ct.x +:= 1
      col := get_col_info(ct, ct.x)
      valign := convert_valign(e | \ct.tr, u"VALIGN") | \ (\col).valign | Align.C
      row := TextFlow(self).
         set_constraint("x", ct.x). 
         set_constraint("y", ct.y).
         set_border(ct.cell_border).
         set_v_align(valign)
      colspan := (0 < integer(e.get_attribute(u"COLSPAN"))) | 1
      row.set_constraint("w", colspan)
      rowspan := (0 < integer(e.get_attribute(u"ROWSPAN"))) | 1
      row.set_constraint("h", rowspan)
      row.set_bg(convert_color(e | \ct.tr, u"BGCOLOR"))
      every insert(ct.occ, (ct.x to ct.x + colspan - 1) || "," || (ct.y to ct.y + rowspan - 1))
      if colspan = 1 then
         def_w := (\col).width
      do_width_param(e, row, def_w)
      do_height_param(e, row)
      ct.tbl.content.add(row)

      c := copy(context)
      if e.get_attribute(u"NOWRAP") then
         c.nowrap := 1
      if e.name == u"TH" then {
         c.bold := 1
         c.size := min(c.size + 1, 7)
         synch_font(c)
         c.align := convert_halign(e | \ct.tr, u"ALIGN") | \ (\col).align | Align.C
      } else
         c.align := convert_halign(e | \ct.tr, u"ALIGN") | \ (\col).align | Align.L
      ct.x +:= colspan

      traverse(e, row, c)
   end

   private traverse_list(e, p, context)
      local tbl, lc, c
      tbl := Tbl()
      c := copy(context)
      lc := ListContext()
      lc.tbl := tbl
      lc.index := integer(e.get_attribute(u"START")) | 1
      lc.type := e.get_attribute(u"TYPE")
      lc.kind := e.name
      c.list := lc
      traverse(e, p, c)
      put_new_row(p, c)
      add_component(p, tbl, context, Align.B)
      put_new_row(p, c)
   end

   private traverse_li(e, p, context)
      local lc, row, val, type
      lc := \context.list | fail
      row := TextFlow(self).set_v_align("baseline")
      type := e.get_attribute(u"TYPE") | lc.type
      if lc.kind == u"OL" then {
         val := integer(e.get_attribute(u"VALUE")) | lc.index
         if val > 0 then {
            val := case string(type) of {
               "a": map(alphaseq(val))
               "A": alphaseq(val)
               "i": map(roman(val))
               "I": roman(val)
            }
         }
         put(row.input, TextCmd(val || u".\ua0\ua0\ua0", context))
         lc.index +:= 1
      } else {
         /type := "disc"
         val := case map(string(type)) of {
            "circle": u"o"
            "square": u"\u25ca"
            default: u"\u2022"
         }
         put(row.input, TextCmd(val || u"\ua0\ua0\ua0", context))
      }
      lc.tbl.content.add(row)
      row := TextFlow(self).set_v_align("baseline").set_constraint("eol", &yes)
      lc.tbl.content.add(row)
      traverse(e, row, context)
   end

   private traverse_dl(e, p, context)
      local tbl, dc, c
      tbl := Tbl()
      tbl.content.layout_delegate.set_fix_col1(&yes)
      dc := DefListContext()
      dc.tbl := tbl
      c := copy(context)
      c.def_list := dc
      traverse(e, p, c)
      put_new_row(p, c)
      add_component(p, tbl, context, Align.B)
      put_new_row(p, c)
   end

   private traverse_dt(e, p, context)
      local dc, row
      dc := \context.def_list | fail
      row := TextFlow(self) .set_constraint("eol", &yes).set_constraint("w", 2)
      dc.tbl.content.add(row)
      traverse(e, row, context)
   end

   private traverse_dd(e, p, context)
      local dc, row
      dc := \context.def_list | fail
      row := TextFlow(self).set_v_align("baseline").set_constraint("eol", &no)
      put(row.input, TextCmd(u"\u2022\ua0\ua0\ua0", context))
      dc.tbl.content.add(row)
      row := TextFlow(self).set_v_align("baseline").set_constraint("eol", &yes)
      dc.tbl.content.add(row)
      traverse(e, row, context)
   end

   private traverse_blockquote(e, p, context)
      local tbl, row
      put_new_row(p, context)
      tbl := Tbl()
      add_component(p, tbl, context)
      row := TextFlow(self)
      put(row.input, TextCmd(u"\ua0\ua0\ua0\ua0", context))
      tbl.content.add(row)
      row := TextFlow(self).set_constraint("eol", &yes)
      tbl.content.add(row)
      traverse(e, row, context)
      put_new_row(p, context)
   end

   private traverse_fieldset(e, p, context)
      local tbl, row, c, fc
      put_new_row(p, context)
      tbl := Tbl().set_border(CompoundBorder().
                              set_outer(SunkenBorder().set_line_width(1)).
                              set_inner(EmptyBorder()))
      add_component(p, tbl, context)
      row := TextFlow(self)
      tbl.content.add(row)
      fc := FieldSetContext()
      c := copy(context)
      c.fieldset := fc
      traverse(e, row, c)
      tbl.set_title(\fc.legend)
      put_new_row(p, context)
   end

   private traverse_legend(e, p, context)
      local fc
      fc := \context.fieldset | fail
      /fc.legend | fail
      fc.legend := TextFlow(self).
         set_dominant_width(TextFlow.MAX_WIDTH)
      traverse(e, fc.legend, context)
   end

   private traverse_map(e, p, context)
      local c, mc
      mc := MapContext()
      mc.map := ipl.browser.Map()
      c := copy(context)
      c.map := mc
      traverse(e, p, c)
      insert(maps, map(string(e.get_attribute(u"NAME"))), mc.map)
   end

   private traverse_datalist(e, p, context)
      local c, dc
      dc := DataListContext()
      dc.options := []
      c := copy(context)
      c.datalist := dc
      traverse(e, p, c)
      insert(datalists, map(string(e.get_attribute(u"ID"))), dc.options)
   end

   private traverse_area(e, p, context)
      local mc, coords
      mc := \context.map | fail
      coords := []
      every put(coords, integer(separate(e.get_attribute(u"COORDS"), ',; ')))
      mc.map.add_area(MapArea(map(string(e.get_attribute(u"SHAPE"))), 
                              coords,
                              mk_link(e.get_attribute(u"HREF")),
                              context.title))
   end

   private traverse_abbr(e, p, context)
      local c
      c := copy(context)
      c.underdash := 1
      traverse(e, p, c)
   end

   private traverse_body(e, p, context)
      local c
      c := copy(context)
      c.fg := page_text_color := convert_color(e, u"TEXT")
      page_link_color := convert_color(e, u"LINK")
      page_alink_color := convert_color(e, u"ALINK")
      page_vlink_color := convert_color(e, u"VLINK")
      p.set_bg(convert_color(e, u"BGCOLOR"))
      traverse(e, p, c)
   end

   private traverse_base(e, p, context)
      page_base := URL(e.get_attribute(u"HREF"))
   end

   private traverse_wbr(e, p, context)
      put(p.input, WbrCmd(context))
   end

   private traverse_text(e, p, context)
      put(p.input, TextCmd(e, context))
   end

   private traverse_title(e, p, context)
      page_title := e.get_trimmed_string_content()
   end

   private traverse(n, p, context)
      local e, id, title, c
      every e := !n.children do {
         if text(e) then
            traverse_text(e, p, context)
         else if is(e, HtmlElement) then {
            if id := e.get_attribute(u"ID") then
               put(p.input, NamedAnchorCmd(id, context))
            if title := (u"" ~== e.get_attribute(u"TITLE")) then {
               c := copy(context)
               c.title := title
            } else
               c := context
            case string(e.name) of {
               "META"|"LINK"|"SCRIPT"|"STYLE": {}
               "TITLE": traverse_title(e, p, c)
               "A": traverse_a(e, p, c)
               "FORM": traverse_form(e, p, c)
               "BUTTON": traverse_button(e, p, c)
               "LABEL": traverse_label(e, p, c)
               "FONT": traverse_font(e, p, c)
               "IMG": traverse_img(e, p, c)
               "SELECT": traverse_select(e, p, c)
               "OPTION": traverse_option(e, p, c)
               "OPTGROUP": traverse_optgroup(e, p, c)
               "TEXTAREA": traverse_textarea(e, p, c)
               "INPUT": traverse_input(e, p, c)
               "DIV": traverse_div(e, p, c)
               "BIG": traverse_big(e, p, c)
               "SMALL": traverse_small(e, p, c)
               "SAMP"|"KBD"|"CODE"|"TT": traverse_tt(e, p, c)
               "STRONG"|"DFN"|"B": traverse_b(e, p, c)
               "EM"|"CITE"|"I"|"VAR": traverse_i(e, p, c)
               "MARK": traverse_mark(e, p, c)
               "ADDRESS": traverse_address(e, p, c)
               "BR": traverse_br(e, p, c)
               "NOBR": traverse_nobr(e, p, c)
               "HR": traverse_hr(e, p, c)
               "CENTER": traverse_center(e, p, c)
               "H" || (1 to 6): traverse_hN(e, p, c)
               "TABLE": traverse_table(e, p, c)
               "THEAD"|"TBODY"|"TFOOT": traverse_tbody(e, p, c)
               "CAPTION": traverse_caption(e, p, c)
               "COLGROUP": traverse_colgroup(e, p, c)
               "COL": traverse_col(e, p, c)
               "TR": traverse_tr(e, p, c)
               "TD"|"TH": traverse_td(e, p, c)
               "DIR"|"MENU"|"OL"|"UL": traverse_list(e, p, c)
               "LI": traverse_li(e, p, c)
               "DL": traverse_dl(e, p, c)
               "DT": traverse_dt(e, p, c)
               "DD": traverse_dd(e, p, c)
               "BLOCKQUOTE": traverse_blockquote(e, p, c)
               "P": traverse_p(e, p, c)
               "Q": traverse_q(e, p, c)
               "INS"|"U": traverse_u(e, p, c)
               "DEL"|"STRIKE"|"S": traverse_s(e, p, c)
               "SUP": traverse_sup(e, p, c)
               "SUB": traverse_sub(e, p, c)
               "LISTING"|"PRE"|"XMP": traverse_pre(e, p, c)
               "FIELDSET": traverse_fieldset(e, p, c)
               "LEGEND": traverse_legend(e, p, c)
               "MAP": traverse_map(e, p, c)
               "AREA": traverse_area(e, p, c)
               "DATALIST": traverse_datalist(e, p, c)
               "WBR": traverse_wbr(e, p, c)
               "ABBR"|"ACRONYM": traverse_abbr(e, p, c)
               "BASE": traverse_base(e, p, c)
               "BODY": traverse_body(e, p, c)
               default : traverse(e, p, c)
            }
         }
      }
   end

   public set_worker_pool(worker_pool)
      self.worker_pool := worker_pool
      self.shared_worker_pool_flag := 1
      return self
   end

   public set_shared_worker_pool(s)
      self.shared_worker_pool_flag := check_flag(s)
      return self
   end

   public goto(url, referer, form_data, kind)
      /kind := Worker.NORMAL
      cancel()
      start_worker(Req(self, url, referer, set_top_data, kind, form_data))
      return self
   end

   private handle_lpress(e)
      *parent_dialog.held = 1 | fail
      /mark_x | fail
      running === 0 | fail
      can_lpress(e) | fail
      set_cursor_from_pos(e)
      mark_x := cursor_x
      mark_y := cursor_y
      view.inner.invalidate(calculate_banded_rect())
      clear_banded()
   end

   private set_cursor_from_pos(e)
      cursor_x := e.x - view.inner.x
      cursor_y := e.y - view.inner.y
      cursor_x <:= get_area_x()
      cursor_x >:= get_area_x() + view.w
      cursor_y <:= get_area_y()
      cursor_y >:= get_area_y() + view.h
   end

   private handle_ldrag(e)
      \mark_x | fail

      view.inner.invalidate(get_band_rect())
      view.inner.invalidate(calculate_banded_rect())
      set_cursor_from_pos(e)
      calculate_banded()
      view.inner.invalidate(get_band_rect())
      view.inner.invalidate(calculate_banded_rect())

      if cursor_y > 0 & e.y < self.view.y then {
         v_direction := "up"
         check_scroll_ticker(self.view.y - e.y)
      } else if cursor_y < view.inner.h & e.y >= self.view.y + self.view.h then {
         v_direction := "down"
         check_scroll_ticker(e.y - (self.view.y + self.view.h))
      } else
         v_direction := &null

      if cursor_x > 0 & e.x < self.view.x then {
         h_direction := "left"
         check_scroll_ticker(self.view.x - e.x)
      } else if cursor_x < view.inner.w & e.x >= self.view.x + self.view.w then {
         h_direction := "right"
         check_scroll_ticker(e.x - (self.view.x + self.view.w))
      } else
         h_direction := &null

      if /v_direction & /h_direction then
         scroll_ticker.stop()
   end

   public get_band_rect()
      local x1, y1, x2, y2
      \mark_x | fail
      if mark_x = mark_y & cursor_x = cursor_y then
         fail
      y1 := mark_y
      y2 := cursor_y
      if y2 < y1 then
         y1 :=: y2
      else if y2 = y1 then
         y2 +:= 1
      x1 := mark_x
      x2 := cursor_x
      if x2 < x1 then
         x1 :=: x2
      else if x2 = x1 then
         x2 +:= 1
      return Rect(view.inner.x + x1, view.inner.y + y1, x2 - x1, y2 - y1)
   end

   public layout()
      cast(self,ComponentScrollArea).layout()
      clear_mark()
      clear_banded()
      redo_search()
      scroll_ticker.stop()
   end

   public display()
      local W, r
      cast(self,ComponentScrollArea).display()
      if r := get_band_rect() then {
         use {
            W := view.cbwin.clone().set_fg("purple").set_masked_pattern("gray"),
            W.draw_rectangle(r.x, r.y, r.w, r.h)
         }
      }
   end

   package check_scroll_ticker(d)
      scroll_ticker_interval := Gui.style.distance2ticker_rate(d)
      scroll_ticker.change_sleep(scroll_ticker_interval)
      # Start it (if it isn't already running)
      scroll_ticker.start()
   end

   package is_banded(o)
      return member(banded, o)
   end

   package is_searched(o)
      suspend !member(searched, o)
   end

   private scroll_tick()
      local f
      repeat {
         f := &null
         case v_direction of {
            "up": {
               if cursor_y > 0 then {
                  cursor_y := max(0, cursor_y - 20)
                  set_area_y(cursor_y)
                  f := 1
               }
            }
            "down": {
               if cursor_y < view.inner.h then {
                  cursor_y := min(view.inner.h, cursor_y + 20)
                  set_area_y(cursor_y - view.h)
                  f := 1
               }
            }
         }
         case h_direction of {
            "left": {
               if cursor_x > 0 then {
                  cursor_x := max(0, cursor_x - 20)
                  set_area_x(cursor_x)
                  f := 1
               }
            }
            "right": {
               if cursor_x < view.inner.w then {
                  cursor_x := min(view.inner.w, cursor_x + 20)
                  set_area_x(cursor_x - view.w)
                  f := 1
               }
            }
         }
         if \f then
            calculate_banded()

         scroll_ticker.sleep(scroll_ticker_interval)
      }
   end

   private clear_mark()
      cursor_x := cursor_y := mark_x := mark_y := &null
   end

   private clear_banded()
      clear(banded)
      text_selection := links_selection := &null
   end

   package on_lost_primary_ownership()
      view.inner.invalidate(calculate_banded_rect())
      clear_banded()
   end

   private calculate_banded()
      local c, br
      clear_banded()
      br := get_band_rect() | fail
      every c := Seq{traverse_intersecting(view.inner, br)} do {
         if is(c, TextFlow) then
            c.calculate_banded(br, banded)
         else if is(c, Img) then
            insert(banded, c, c)
      }
   end

   private static traverse_intersecting(c, r)
      r := c.intersect(r) | fail
      coact(c)
      if is(c, TblContent) then
         every traverse_intersecting(c.layout_delegate.computed_g.cells_in_range(r.y - c.y, r.h).obj, r)
      else
         every traverse_intersecting(!c.children, r)
   end

   private show_bounds()
      local c
      every c := !banded do {
         if is(c, TextSelection) then
            write(image(c), " -> ", to_string(c.get_bounds()))
      }
   end

   private calculate_banded_rect()
      local c, t, r
      every c := !banded do {
         t := if is(c, TextSelection) then
            c.get_bounds()
         else if is(c, Img) then
            c
         r := (\r).union(t) | t
      }
      return \r
   end

   public get_current_text_selection()
      return \.text_selection
   end

   private calculate_text_selection()
      local br, s, c, l, e, y1
      text_selection := &null
      br := calculate_banded_rect() | fail
      l := []
      every c := Seq{traverse_intersecting(view.inner, br)} do {
         if is(c, TextFlow) then
            c.get_selected_text(br, l)
      }
      qsort(l, point_comp)
      s := u""
      every e := !l do {
         if *s > 0 then
            s ||:= if e.y > y1 then u"\n" else u" "
         s ||:= e.val
         y1 := e.y
      }
      if *s > 0 then
         text_selection := s
   end

   public get_current_links_selection()
      return \.links_selection
   end

   private calculate_links_selection()
      local l, c
      links_selection := &null
      l := []
      every c := !banded do {
         if is(c, TextSelection) then
            put(l, \c.textout.attr.url)
         else if is(c, Img) then
            every put(l, \c.gen_areas().url)
      }
      if *l > 0 then
         links_selection := l
   end

   private handle_lrelease(e)
      local s
      scroll_ticker.stop()
      if \mark_x then {
         view.inner.invalidate(get_band_rect())
         clear_mark()
      }
      calculate_text_selection()
      calculate_links_selection()
      if s := get_current_text_selection() then {
         primary_selection_owner.set_text(s)            
         parent_dialog.own_selection(Selection.PRIMARY, primary_selection_owner)
      }
   end

   private can_rpress(e)
      local c
      is(parent_dialog.point_chain[1], TextFlow | TblContent | Tbl) | fail
      every c := !parent_dialog.point_chain do {
         if is(c, TextFlow) & c.wants_rpress(e) then
            fail
      }
      return
   end

   private can_lpress(e)
      local c
      is(parent_dialog.point_chain[1], Img | TextFlow | TblContent | Tbl) | fail
      every c := !parent_dialog.point_chain do {
         if is(c, TextFlow) & c.wants_lpress(e) then
            fail
         if is(c, Img) & c.wants_lpress(e) then
            fail
      }
      return
   end

   private handle_rpress(e)
      local pm, pm_menu
      *parent_dialog.held = 1 | fail
      can_rpress(e) | fail
      if pm_menu := create_page_menu() then {
         pm := PopupMenu()
         pm.popup(parent_dialog, pm_menu, e.x, e.y)
      }
   end

   public get_page_info()
      local e, s, l, t, c, n, sz, m, f, imgs, ct

      s := "<html><title>Page info</title>"
      s ||:= "<h1>Page</h1>"

      if l := \page_url then
         s ||:= "URL: " || mk_anchor(l) || "<p>"
      if sz := *\page_data then
         s ||:= "Size: " || Format.numeric_to_string(sz, 0, ',') || " bytes<p>"
      if n := \page_name & *n > 0 then
         s ||:= "Name: " || to_content(n) || "<p>"
      if n := \page_title & *n > 0 then
         s ||:= "Title: " || to_content(n) || "<p>"
      if ct := \page_resp.content_type then
         s ||:= "Content-type: " || to_content(ct.to_rfc1521()) || "<p>"
      if l := \page_resp.referer & (l.scheme == (u"http" | u"https")) then
         s ||:= "Referer: " || mk_anchor(l) || "<p>"
      if e := \page_resp.err then
         s ||:= "Error: " || to_content(e) || "<p>"

      imgs := []
      t := table(u"")
      every c := Seq{traverse_postorder()} do {
         if is(c, TextFlow) then
            c.calculate_link_text(t)
         else if is(c, Img) then
            put(imgs, c)
      }

      if *forms > 0 then {
         s ||:= "<h1>Forms</h1>" || get_table_tag() || "<tr><th align=left>Name<th align=left>Method<th align=left>URL</tr>"
         every f := !forms do {
            if l := \f.url then {
               n := \f.id | "-"
               m := \f.method | "-"
               s ||:= "<tr><td>" || to_content(n) || "<td>" || m || mk_anchor_cell(l) || "</tr>" 
            }
         }
         s ||:= "</table>"
      }

      if *imgs > 0 then {
         s ||:= "<h1>Images</h1>" || get_table_tag() || "<tr><th align=left>Name<th align=right>Size&nbsp;<th align=left>URL</tr>"
         every c := !imgs do {
            l := c.img_url
            n := limit_text(\c.img_name, 200) | "-"
            sz := Format.numeric_to_string(*\c.img_data, 0, ',') | "-"
            s ||:= "<tr><td>" || to_content(n) || "<td align=right>" || sz || "&nbsp;" || mk_anchor_cell(l) || "</tr>"
         }
         s ||:= "</table>"
      }

      if *page_links > 0 then {
         s ||:= "<h1>Links</h1>" || get_table_tag() || "<tr><th align=left>Name<th align=left>URL</tr>"
         every l := !page_links do {
            n := limit_text(t[l], 200)
            s ||:= "<tr><td nowrap>" || to_content(n) || mk_anchor_cell(l) || "</tr>" 
         }      
         s ||:= "</table>"
      }
      s ||:= "</html>"
      return s
   end

   public static get_table_tag()
      return "<table cellspacing=4>"
   end

   public get_cache()
      return worker_pool.cache
   end

   public handle_copy(e)
      local s
      if s := get_current_text_selection() then
         parent_dialog.own_selection(Selection.CLIPBOARD, StaticTextSelectionOwner(s))
   end

   private additional_keys(e)
      case e.code of {
         "\^c" :  handle_copy(e)
      }
   end

   public new()
      cast(self,ComponentScrollArea).new()
      scroll_ticker := Dispatcher.new_task{scroll_tick()}
      worker_pool := WorkerPool().
         set_authentication_function(get_authentication)
      status_ticker := Dispatcher.new_task{status()}
      primary_selection_owner := BrowserPrimarySelectionOwner(self)
      set_inner(TextFlow(self))
      use_default_keys()
      connect(additional_keys, Event.KEY_PRESS)
      history := []
      history_pos := 0
      running := 0
      banded := table()
      searched := table()
      outermost_border := NullBorder()
      view.connect(self.handle_ldrag, Event.MOUSE_LEFT_DRAG).
         connect(self.handle_lpress, Event.MOUSE_LEFT_PRESS).
         connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE).
         connect(self.handle_rpress, Event.MOUSE_RIGHT_PRESS)
      return
   end
end

# A simple subclass of `Browser`, intended for displaying HTML pages
# with no user navigation and a minimalist interface.
#
# An HTML document may be shown by calling `set_page`, passing the
# document in string form.  Images may be included in the page by
# either specifying a normal external URL, or with URL img:name, where
# name is a name in the image cache (eg: <img src="img:gui.HOME_24">).
#
class SimpleBrowser(Browser)
   private readable
      page

   public static const
      LINK_LEFT_CLICKED,
      LINK_MIDDLE_CLICKED

   private static init()
      LINK_LEFT_CLICKED := "link_left_clicked"
      LINK_MIDDLE_CLICKED := "link_middle_clicked"
   end

   public link_left_clicked(url)
      cast(self, Browser).link_left_clicked(url)
      fire(LINK_LEFT_CLICKED, url)
      return self
   end

   public link_middle_clicked(url)
      cast(self, Browser).link_middle_clicked(url)
      fire(LINK_MIDDLE_CLICKED, url)
      return self
   end

   # Set the page to display as a string representing an HTML
   # document.
   #
   public set_page(page)
      self.page := page
      goto(URL("page:"))
      return self
   end

   private page_handler(worker)
      return \page | return error("No page set")
   end

   private img_handler(worker)
      local n
      n := string(worker.req.url.get_path())
      return ImageCache.get_named_image(n) | error("Unknown image")
   end

   public new()
      cast(self,Browser).new()
      worker_pool.
         add_scheme_handler("page", page_handler).
         add_scheme_handler("img", img_handler)
      return
   end
end
