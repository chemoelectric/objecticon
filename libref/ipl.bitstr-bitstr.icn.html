<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>bitstr.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     bitstr.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures for bits in Icon strings
<a name="6"/>#
<a name="7"/>#	Author:   Robert J. Alexander
<a name="8"/>#
<a name="9"/>#	Date:     August 14, 1996
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#  Procedures for working with strings made up of numeric values
<a name="18"/>#  represented by strings of an arbitrary number of bits, stored without
<a name="19"/>#  regard to character boundaries.
<a name="20"/>#
<a name="21"/>#  In conjunction with the "large integers" feature of Icon, this
<a name="22"/>#  facility can deal with bitstring segments of arbitrary size.  If
<a name="23"/>#  "large integers" are not supported, bitstring segments (i.e.  the
<a name="24"/>#  nbits parameter of BitStringGet and BitStringPut) wider that the
<a name="25"/>#  integer size of the platform are likely to produce incorrect results.
<a name="26"/>#
<a name="27"/>############################################################################
<a name="28"/>#
<a name="29"/>#  Usage of BitStringPut, by example:
<a name="30"/>#
<a name="31"/>#       record bit_value(value, nbits)
<a name="32"/>#       ...
<a name="33"/>#       bitString := BitString("")
<a name="34"/>#       while value := get_new_value() do       # loop to append to string
<a name="35"/>#               BitStringPut(bitString, value.nbits, value.value)
<a name="36"/>#       resultString := BitStringPut(bitString) # output any buffered bits
<a name="37"/>#
<a name="38"/>#  Note the interesting effect that BitStringPut(bitString), as well as
<a name="39"/>#  producing the complete string, pads the buffered string to an even
<a name="40"/>#  character boundary.  This can be dune during construction of a bit
<a name="41"/>#  string if the effect is desired.
<a name="42"/>#
<a name="43"/>#  The "value" argument defaults to zero.
<a name="44"/>#
<a name="45"/>############################################################################
<a name="46"/>#
<a name="47"/>#  Usage of BitStringGet, by example:
<a name="48"/>#
<a name="49"/>#       record bit_value(value, nbits)
<a name="50"/>#       ...
<a name="51"/>#       bitString := BitString(string_of_bits)
<a name="52"/>#       while value := BitStringGet(bitString, nbits) do
<a name="53"/>#               # do something with value
<a name="54"/>#
<a name="55"/>#  BitStringGet fails when too few bits remain to satisfy a request.
<a name="56"/>#  However, if bits remain in the string, subsequent calls with fewer
<a name="57"/>#  bits requested may succeed.  A negative "nbits" value gets the value
<a name="58"/>#  of the entire remainder of the string, to the byte boundary at its
<a name="59"/>#  end.
<a name="60"/>#
<a name="61"/>############################################################################
<a name="62"/>#
<a name="63"/>#  See also: bitstrm.icn
<a name="64"/>#
<a name="65"/>############################################################################
<a name="66"/>
<a name="67"/>package ipl.bitstr
<a name="68"/>
<a name="69"/>record BitString(s, buffer, bufferBits)
<a name="70"/>
<a name="71"/>procedure BitStringPut(bitString, nbits, value)
<a name="72"/>    local outvalue
<a name="73"/>    #
<a name="74"/>    #  Initialize.
<a name="75"/>    #
<a name="76"/>    /bitString.buffer := bitString.bufferBits := 0
<a name="77"/>    #
<a name="78"/>    #  If this is "close" call ("nbits" is null), flush buffer,
<a name="79"/>    #  reinitialize, and return the bit string with the final character
<a name="80"/>    #  value zero padded on the right.
<a name="81"/>    #
<a name="82"/>    if /nbits then {
<a name="83"/>	 if bitString.bufferBits &gt; 0 then
<a name="84"/>		  bitString.s ||:=
<a name="85"/>			   char(ishift(bitString.buffer, 8 - bitString.bufferBits))
<a name="86"/>	 bitString.buffer := bitString.bufferBits := 0
<a name="87"/>	 return bitString.s
<a name="88"/>	    }
<a name="89"/>    #
<a name="90"/>    #  Merge new value into buffer.
<a name="91"/>    #
<a name="92"/>    /value := 0
<a name="93"/>    bitString.buffer := ior(ishift(bitString.buffer, nbits), value)
<a name="94"/>    bitString.bufferBits +:= nbits
<a name="95"/>    #
<a name="96"/>    #  Output bits.
<a name="97"/>    #
<a name="98"/>    while bitString.bufferBits &gt;= 8 do {
<a name="99"/>	 bitString.s ||:= char(outvalue :=
<a name="100"/>	       ishift(bitString.buffer, 8 - bitString.bufferBits))
<a name="101"/>	 bitString.buffer :=
<a name="102"/>		  ixor(bitString.buffer, ishift(outvalue, bitString.bufferBits - 8))
<a name="103"/>	 bitString.bufferBits -:= 8
<a name="104"/>	    }
<a name="105"/>    return
<a name="106"/>end
<a name="107"/>
<a name="108"/>
<a name="109"/>procedure BitStringGet(bitString, nbits)
<a name="110"/>    local value, save, i
<a name="111"/>    #
<a name="112"/>    #  Initialize.
<a name="113"/>    #
<a name="114"/>    /bitString.buffer := bitString.bufferBits := 0
<a name="115"/>    #
<a name="116"/>    #  Get more data if necessary.
<a name="117"/>    #
<a name="118"/>    save := copy(bitString)
<a name="119"/>    while nbits &lt; 0 | bitString.bufferBits &lt; nbits do {
<a name="120"/>	 unless bitString.buffer :=
<a name="121"/>		  ior(ishift(bitString.buffer, 8), ord(bitString.s[1])) then {
<a name="122"/>	     #
<a name="123"/>	     #  There aren't enough bits left in the file.  Restore the
<a name="124"/>	     #  BitString to its state before the call (in case he wants to
<a name="125"/>	     #  try again), and fail.
<a name="126"/>	     #
<a name="127"/>	     if nbits &gt;= 0 then {
<a name="128"/>		  every i := 1 to *bitString do
<a name="129"/>			   bitString[i] := save[i]
<a name="130"/>		  fail
<a name="131"/>		     }
<a name="132"/>	     else {
<a name="133"/>		  bitString.s := ""
<a name="134"/>		  bitString.bufferBits := value := 0
<a name="135"/>		  value :=: bitString.buffer
<a name="136"/>		  return value
<a name="137"/>		     }
<a name="138"/>	        }
<a name="139"/>	 bitString.s[1] := ""
<a name="140"/>	 bitString.bufferBits +:= 8
<a name="141"/>	    }
<a name="142"/>    #
<a name="143"/>    #  Extract value from buffer and return.
<a name="144"/>    #
<a name="145"/>    value := ishift(bitString.buffer, nbits - bitString.bufferBits)
<a name="146"/>    bitString.buffer :=
<a name="147"/>	     ixor(bitString.buffer, ishift(value, bitString.bufferBits - nbits))
<a name="148"/>    bitString.bufferBits -:= nbits
<a name="149"/>    return value
<a name="150"/>end
</pre></body></html>
