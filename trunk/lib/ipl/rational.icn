############################################################################
#
#	File:     rational.icn
#
#	Subject:  Procedures for arithmetic on rational numbers
#
#	Author:   Ralph E. Griswold
#
#	Date:     June 10, 2001
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#	Contributor:  Gregg M. Townsend
#
############################################################################
#
#     These procedures perform arithmetic on rational numbers (fractions):
#
#     addrat(r1,r2) Add rational numbers r1 and r2.
#
#     divrat(r1,r2) Divide rational numbers r1 and r2.
#
#     medrat(r1,r2) Form mediant of r1 and r2.
#
#     mpyrat(r1,r2) Multiply rational numbers r1 and r2.
#
#     negrat(r)     Produce negative of rational number r.
#
#     rat2real(r)   Produce floating-point approximation of r
#
#     rat2str(r)    Convert the rational number r to its string
#                   representation.
#
#     real2rat(v,p) Convert real to rational with precision p.
#                   The default precision is 1e-10.
#                   (Too much precision gives huge, ugly factions.)
#
#     reciprat(r)   Produce the reciprocal of rational number r.
#
#     str2rat(s)    Convert the string representation of a rational number
#                   (such as "3/2") to a rational number.
#
#     subrat(r1,r2) Subtract rational numbers r1 and r2.
#    
############################################################################
#
#  Links: numbers
#
############################################################################

package ipl.rational

import
   ipl.numbers(gcd)

record rational(numer, denom, sign)

# sum of rationals
procedure addrat(r1, r2)		
   local denom, numer, div

   r1 := ratred(r1)
   r2 := ratred(r2)

   denom := r1.denom * r2.denom
   numer := r1.sign * r1.numer * r2.denom +
      r2.sign * r2.numer * r1.denom

   if numer = 0 then return rational (0, 1, 1)

   div := gcd(numer, denom)

   return rational(abs(numer / div), abs(denom / div), numer / abs(numer))

end

# divide rationals.
procedure divrat(r1, r2)		

   r1 := ratred(r1)
   r2 := ratred(r2)

   return mpyrat(r1, reciprat(r2))

end
 
# form rational mediant
procedure medrat(r1, r2)		
   local numer, denom, div

   r1 := ratred(r1)
   r2 := ratred(r2)

   numer := r1.numer + r2.numer
   denom := r1.denom + r2.denom

   div := gcd(numer, denom)

   return rational(numer / div, denom / div, r1.sign * r2.sign)

end
 
# multiply rationals
procedure mpyrat(r1, r2)		
   local numer, denom, div

   r1 := ratred(r1)
   r2 := ratred(r2)

   numer := r1.numer * r2.numer
   denom := r1.denom * r2.denom

   div := gcd(numer, denom)

   return rational(numer / div, denom / div, r1.sign * r2.sign)

end

# negative of rational
procedure negrat(r)		

   r := ratred(r)

   return rational(r.numer, r.denom, -r.sign)

end

# floating-point approximation of rational
procedure rat2real(r)		

   r := ratred(r)

   return (real(r.numer) * r.sign) / r.denom

end
  
# convert rational to string
procedure rat2str(r)		

   r := ratred(r)

   return "(" || (r.numer * r.sign) || "/" || r.denom || ")"

end

# reduce rational to lowest terms
procedure ratred(r)		
   local div, numer, denom, sign

   if r.denom = 0 then runerr(201)
   if abs(r.sign) ~= 1 then runerr("Rational sign must be +/- 1")

   if r.numer = 0 then return rational(0, 1, 1)

   sign := r.sign
   if r.numer < 0 then sign *:= -1
   if r.denom < 0 then sign *:= -1

   numer := abs(r.numer)
   denom := abs(r.denom)

   div := gcd(numer, denom)

   return rational(numer / div, denom / div, sign)

end

#  real2rat(v, p) -- convert real to rational with precision p
#
#  Originally based on a calculator algorithm posted to usenet on August 19,
#  1987, by Joseph D. Rudmin, Duke University Physics Dept. (duke!dukempd!jdr)

$define MAXITER 40		# maximum number of iterations
$define PRECISION 1e-10		# default conversion precision

# convert to rational with precision p
procedure real2rat(r, p)	
   local t, d, i, j
   static x, y
   initial { x := list(MAXITER); y := list(MAXITER + 2) }

   t := abs(r)
   /p := PRECISION
   every i := 1 to MAXITER do {
      x[i] := integer(t)
      y[i + 1] := 1
      y[i + 2] := 0
      every j := i to 1 by -1 do
         y[j] := x[j] * y[j + 1] + y[j + 2]
      if abs(y[1] / real(y[2]) - r) < p then break
      d := t - integer(t)
      if d < p then break
      t := 1.0 / d
      }
   return rational(y[1], y[2], if r >= 0 then 1 else -1)

end

# reciprocal of rational
procedure reciprat(r)		

   r := ratred(r)

   return rational(r.denom, r.numer, r.sign)

end

# floor of the given rational 
procedure floorrat(r)
   r := ratred(r)
   if r.denom = 1 then
      return r.numer * r.sign

   if r.sign < 0 then
      return -r.numer / r.denom - 1
   else
      return r.numer / r.denom
end

# ceiling of the given rational 
procedure ceilingrat(r)
   r := ratred(r)
   if r.denom = 1 then
      return r.numer * r.sign

   if r.sign < 0 then
      return -r.numer / r.denom
   else
      return r.numer / r.denom + 1
end

# round to nearest whole number
procedure roundrat(r)
   r := ratred(r)
   if r.sign < 0 then
      return (-2 * r.numer - r.denom) / (2 * r.denom)
   else
      return (2 * r.numer + r.denom) / (2 * r.denom)
end

# truncate the given rational
procedure truncaterat(r)
   r := ratred(r)
   return (r.numer * r.sign) / r.denom
end

# return the absolute of the given rational
procedure absrat(r)
   r := ratred(r)
   return rational(r.numer, r.denom, 1)
end

# convert string to rational
procedure str2rat(s)		
   local numer, denom

   s ? {
      ="(" &
      numer := integer(tab(upto('/'))) &
      move(1) &
      denom := (0 ~= integer(tab(upto(')')))) &
      pos(-1)
      } | fail

   return ratred(rational(numer, denom, 1))

end

# difference of rationals
procedure subrat(r1, r2)		

   r1 := ratred(r1)
   r2 := ratred(r2)

   return addrat(r1, negrat(r2))

end

# compare rationals
procedure cmprat(r1, r2)		
   local v1, v2

   r1 := ratred(r1)
   r2 := ratred(r2)

   v1 := r1.sign * r1.numer * r2.denom
   v2 := r2.sign * r2.numer * r1.denom

   return if v1 < v2 then -1 else if v1 > v2 then 1 else 0
end

procedure lessrat(r1, r2)
   if cmprat(r1, r2) < 0 then return r2
end

procedure leqrat(r1, r2)
   if cmprat(r1, r2) <= 0 then return r2
end

procedure gtrat(r1, r2)
   if cmprat(r1, r2) > 0 then return r2
end

procedure geqrat(r1, r2)
   if cmprat(r1, r2) >= 0 then return r2
end

procedure eqrat(r1, r2)
   if cmprat(r1, r2) = 0 then return r2
end

procedure neqrat(r1, r2)
   if cmprat(r1, r2) ~= 0 then return r2
end


#
# Generalized procedures which work with ints, reals or rationals.
#

procedure binop(a, b, numop, ratop)
   return gennorm(if is(a,rational) then {
      if is(b,rational) then
         ratop(a, b)
      else if type(b) == "integer" then
         ratop(a, rational(b,1,1))
      else
         numop(rat2real(a), b)
   } else if is(b,rational) then {
      if type(a) == "integer" then
         ratop(rational(a,1,1),b)
      else
         numop(a, rat2real(b))
   } else
      numop(a, b))
end

procedure genabs(a)
   return if is(a,rational) then
      absrat(a)
   else
      abs(a)
end

# If a is a rational with denominator = 1, return as an integer; otherwise
# return a.
procedure gennorm(a)
   return if is(a, rational) & (a.denom = 1) then a.numer * a.sign else a
end

procedure genneg(a)
   return if is(a,rational) then negrat(a) else -a
end

procedure genrecip(a)
   return if is(a,rational) then gennorm(reciprat(a)) else 1/a
end

procedure genfloor(a)
   local i
   return if is(a,rational) then
      floorrat(a)
   else {
      i := integer(a)
      if (a >= 0) | (i = a) then i else i - 1
   }         
end

procedure genceiling(a)
   local i
   return if is(a,rational) then
      ceilingrat(a)
   else {
      i := integer(a)
      if (a <= 0) | (i = a) then i else i + 1
   }         
end

procedure gentruncate(a)
   return if is(a,rational) then
      truncaterat(a)
   else
      integer(a)
end

procedure genround(a)
   return if is(a,rational) then
      roundrat(a)
   else if a < 0 then
      integer(a - 0.5)
   else
      integer(a + 0.5)
end

procedure genmod(a, b)
   return gennorm(gensub(a, genmult(b, genfloor(gendiv(a, b)))))
end

procedure genadd(a, b)
   return binop(a, b, proc("+",2), addrat)
end

procedure genmult(a, b)
   return binop(a, b, proc("*",2), mpyrat)
end

procedure gensub(a, b)
   return binop(a, b, proc("-",2), subrat)
end

procedure gendiv(a, b)
   return if type(a) == type(b) == "integer" then
      gennorm(ratred(rational(a, b, 1)))
   else
      binop(a, b, proc("/",2), divrat)
end

procedure genless(a, b)
   return binop(a, b, proc("<",2), lessrat)
end

procedure genleq(a, b)
   return binop(a, b, proc("<=",2), leqrat)
end

procedure gengt(a, b)
   return binop(a, b, proc(">",2), gtrat)
end

procedure gengeq(a, b)
   return binop(a, b, proc(">=",2), geqrat)
end

procedure geneq(a, b)
   return binop(a, b, proc("=",2), eqrat)
end

procedure genneq(a, b)
   return binop(a, b, proc("~=",2), neqrat)
end
