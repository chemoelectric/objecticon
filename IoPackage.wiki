#summary Describes the io package

= Introduction =

This page gives an overview of the `io` package, which provides Object Icon's object-oriented replacement to Icon's builtin `File` type.

= Details =

The central class in the `io` package is `Stream`.  This class models a file-like object which can have some or all of the following operations :-
 * input
 * output
 * seek and tell
 * truncation

The `io` package also provides some procedures which emulate the old Icon builtin functions which the package replaces (`write`, `open`, etc).

= File I/O =

The class `FileStream` provides conventional filesystem I/O.  To open a new `FileStream`, use the static `open` method :-
{{{
   f := FileStream.open("test.txt", ior(FileOpt.WRONLY, 
                                        FileOpt.TRUNC, 
                                        FileOpt.CREAT)) | stop(&why)
   f.write("some text")
   f.close()
}}}
The second parameter is made up by taking some constants from the `FileOpt` class and or-ing them together.  These constants match the constants used in the underlying Posix `open` system call, except that their names lack the "O" prefix.  So in the above example the `open` call is logically equivalent to the C call
{{{
   f = open("test.txt", O_WRONLY | O_TRUNC | O_CREAT);
}}}

As an alternative to using `FileStream` directly, the `open` procedure can be used to open a file, as follows :-
{{{
   f := open("test.txt", "w") | stop(&why)
   f.write("some text")
   f.close()
}}}
`open` emulates the traditional Icon builtin function of the same name.  It also returns a different type of `Stream` - rather than a `FileStream`, it returns a `BufferStream` wrapping a `FileStream`.  This provides better performance than a raw `FileStream` because it tends to read or write data to the underlying filesystem in larger chunks.

== Standard input and output ==
Standard input and output, and error output, are available via the following static constants.
 * `FileStream.stdin` - standard input
 * `FileStream.stdout` - standard output
 * `FileStream.stderr` - standard error output
These are all `FileStream` instances, and are hence unbuffered.  If you intend to read or write a large amount of data to one of these streams, performance will be improved by using a `BufferStream` wrapper.  For example, consider the following program to count lines :-
{{{
import io

procedure main()
   local n
   n := 0
   while read() do
      n +:= 1
   write("n=", n)
end
}}}
On my system this takes about 2.4 seconds to read a 47000-line file.  The following simple change reduces the run time to only 0.45 seconds :-
{{{
import io

procedure main()
   local n, f
   n := 0
   f := BufferStream("other=",FileStream.stdin)
   while f.read() do
      n +:= 1
   write("n=", n)
end
}}}

= Socket I/O =
The `SocketStream` class represents a stream based on an underlying socket.  There are several static methods in that class to create sockets either for a client or a server.  Both local and network sockets are supported.

Here is a simple example to create a client to perform a HTTP HEAD request.
{{{
import io

procedure main()
   local f
   f := SocketStream.socket()
   f.connect("inet:www.google.com:80") | stop(&why)
   f.writes("HEAD / HTTP/1.1\r\nConnection: close\r\n\r\n")
   while write(f.read())
   f.close()
end
}}}

= More robust socket i/o =
One problem with the bit of socket code shown above is that it is vulnerable to network problems.  Either the `connect`, `writes` or `read` calls could potentially hang and never return.  The `io` package provides the necessary interface to the underlying system calls which can be used to deal with this problem.

== Non-blocking mode ==
This mode is used to ensure an i/o request won't block.  To enable it, use the `flag` method as follows :-
{{{
   f.flag(FileOpt.NONBLOCK)
}}}
`flag` accepts a second parameter, which are flags to turn off, so you could turn non-blocking mode off again as follows :-
{{{
   f.flag(, FileOpt.NONBLOCK)
}}}
When set, calls to a stream's `in` and `out` methods will fail, setting `&why` to a message like "Resource temporarily unavailable (errno=11)".  The `errno` constant can be extracted from `&why` with the `errno()` procedure; in this case it would return 11, which is equal to the constant `Errno.EAGAIN`.  Both `errno` and `Errno` can be found in the `posix` package (they aren't in the `io` package because the errno feature applies more generally than just to i/o).

== The poll() method ==
`poll` is a static method in the `DescStream` class (the common parent of `FileStream` and `SocketStream`).  It provides an interface to the posix function of the same name, and is used to wait, with an optional timeout, for one or more files to become ready for i/o.  To use it, pass one or more argument pairs and an optional timeout.  Each pair consists of a stream followed by an integer flag, made up from the constants in `io.Poll`, which indicates what event(s) we are polling for.  For example :-
{{{
r := DescStream.poll(f1, Poll.OUT, f2, ior(Poll.IN,Poll.OUT), 5000)
}}}
This will wait for up to 5 seconds, polling `f1` for input and `f2` for input or output.  The return value is a list with an integer element for each pair indicating the flags which poll detected (or zero if no flags matched for that particular stream).   The call fails on timeout or error and sets `&why` appropriately.

Here is a longer example showing how to do the HTTP HEAD request of the previous example using `poll` on a non-blocking socket.
{{{
import io, posix

procedure main()
   local f, r, s, i

   #
   # Create a socket and switch on non-blocking mode
   #
   f := SocketStream.socket()
   f.flag(FileOpt.NONBLOCK) | fail

   #
   # Connect, which will probably fail with an EINPROGRESS error - that
   # isn't really an error.
   #
   f.connect("inet:www.google.com:80") | {
      errno() = Errno.EINPROGRESS | stop("Couldn't connect:" || &why)
      # Wait up to 5s for the connection to complete
      r := DescStream.poll(f, Poll.OUT, 5000) | stop(&why)
      r[1] = Poll.OUT | stop("Socket error")
   }

   #
   # Send the request, in more than one piece if necessary.
   #
   s := "HEAD / HTTP/1.1\r\nConnection: close\r\n\r\n"
   while *s > 0 do {
      r := DescStream.poll(f, Poll.OUT, 1000) | stop(&why)
      r[1] = Poll.OUT | stop("Socket error")
      i := f.out(s) | stop(&why)
      s := s[i+1 : 0]
   }

   # 
   # Read the data sent back, until end-of-file
   #
   repeat {
      r := DescStream.poll(f, Poll.IN, 1000) | stop(&why)
      r[1] = Poll.IN | stop("Socket error")
      s := f.in(1024) | break
      writes(s)
   }

   # Confirm we reached eof
   f.eof() | stop(&why)

   f.close()
end
}}}
Note that this code uses the methods `in` and `out` to read and write data, rather than `read`, `reads`, `write` and `writes`.   This is because those latter functions are implemented in terms of `in` and `out` and may call them several times in one invocation.  This makes them unsuitable for use with a non-blocking file, because we need to call `poll` or select immediately before each i/o call to ensure that call has something to read or write.  For similar reasons, it is not possible to use `BufferStream` to wrap a non-blocking stream.


