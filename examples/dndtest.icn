import gui

#
# A Dnd-enabled list
#
class CustomList(TextList)
   #
   # A drop has occurred; we succeed iff we accept it
   #
   public perform_drop(drag, drop)
      local l, ll, el
      if l := self.get_highlight() then {
         if drag.get_source() === self then {
            #
            # Move within the list itself
            #
            self.move_lines(self.get_gesture_selections(), l)
         } else {
            #
            # Copy from tree to list.  drag.get_content() gives
            # a list of the nodes being dragged.
            #
            ll := []
            every el := !drag.get_content() do {
               #
               # Don't drag folders.
               #
               if /el.is_folder_flag then
                  put(ll, el.get_label())
            }
            self.insert_lines(ll, l)
         }
         return
      }
   end

   #
   # This is invoked after a successful operation when the
   # list was the source.  If the destination (c) wasn't the
   # list, then we must delete the rows from the list.
   #
   public end_drag(drag, drop)
      if drop.get_source() ~=== self then
         self.delete_lines(self.get_gesture_selections())
   end
end


#
# A Dnd tree
#
class CustomTree(Tree)
   #
   # Called during a drag event
   #
   public can_drop(d,e)
      #
      # We succeed if and only if the user is dragging over a row
      # AND the thing we're over is a folder.
      #
      if cast(self,SelectableScrollArea).can_drop(d,e) then
         return \self.object_get_highlight().is_folder_flag
   end

   #
   # A drop has occurred; we succeed iff we accept it
   #
   public perform_drop(drag, drop)
      local other, n, el
      #
      # Only consider a drop on a folder
      #
      if other := self.object_get_highlight() & \other.is_folder_flag then {
         if drag.get_source() === self then {
            #
            # If self is the drop source, then we have a dnd from 
            # within the tree.  So, we just move the nodes.
            # d.get_content() will be a list of the nodes that were
            # dragged.
            #
            every el := !drag.get_content() do {
               el.get_parent().remove(el)
               other.add(el)
            }
         } else {
            #
            # Drop from list.  In this case d.get_content() will
            # be a list of strings.
            #
            every el := !drag.get_content() do {
               n := FolderNode()
               n.set_label(el)
               other.add(n)
            }
         }

         #
         # Notify the tree that the node data structure has altered.
         #
         self.tree_structure_changed()
         return
      }
   end

   #
   # This is invoked after a successful operation when the
   # tree was the source.  If the destination (c) wasn't the
   # tree, then we must delete the nodes from the tree.
   #
   public end_drag(drag, drop)
      local n

      if drop.get_source() ~=== self then {
         #
         # Delete all the nodes which will have been dragged.
         #
         every n := !self.object_get_gesture_selections() do {
            if /n.is_folder_flag then {
               n.get_parent().delete_node(n)
            }
         }

         #
         # Notify the tree that the node data structure has altered.
         #
         self.tree_structure_changed()
      }
   end
end


#
# We use a custom Node subclass to also store an "is_folder_flag" flag.
#
class FolderNode(TreeNode)
   public is_folder_flag

   public new(is_folder_flag)
      cast(self,TreeNode).new()
      self.is_folder_flag := is_folder_flag
      if \is_folder_flag then
         set_icon_paint(DNDTest.folder_paint,DNDTest.folder_paint,DNDTest.folder_paint)
      return
   end
end


#
# The main dialog.
#
class DNDTest(Dialog)
   public 
      tree,
      lst

   public static
      folder_paint

   public init_dialog()
      folder_paint := ImagePaint().set_cache("gui.CLOSED_FOLDER")
      folder_paint.initially(self)
      tree.set_root_node(create_tree())
   end

   #
   # Delete nodes handler
   #
   public on_delete_node()
      local n

      every n := !(tree.object_get_gesture_selections()) do {
         n.get_parent().delete_node(n)
      }
      #
      # Notify the tree that the node data structure has altered.
      #
      tree.tree_structure_changed()
   end

   #
   # Create a new folder
   #
   public on_new_folder()
      local n, o

      #
      # Simply add a new node under the cursor, and notify the
      # tree that the data structure changed.
      #
      if o := tree.object_get_cursor() then {
         n := FolderNode(1)
         n.set_label("New folder")
         o.add(n)
         tree.tree_structure_changed()
      }
   end

   #
   # Delete rows from the list
   #
   public on_delete_lines()
      lst.delete_lines(get_list_sel())
   end

   #
   # Add some rows to the list, at the cursor position.
   #
   public on_new_rows()
      local lno
      lno := lst.get_cursor() | 1
      lst.insert_lines(["new1", "new2", "new3"], lno)
   end

   #
   # Helper method to create a tree structure.
   #
   public create_tree()
      local r, n, s, t, o
      r := FolderNode(1)
      r.set_label("root")

      every s := "red" | "green" | "blue" | "yellow" do {
         n := FolderNode(1)
         n.set_label(s)
         r.add(n)
         every t := 1 to 5 do {
            o := FolderNode()
            o.set_label(s || "-" ||t)
            n.add(o)
         }
      }
      return r
   end

   private on_list_edit(ev, src)
      lst.set_lines([src.get_contents()], lst.get_cursor())
   end

   private on_list_rename(ev)
      local s, r, tf
      s := lst.object_get_cursor() | fail
      r := lst.get_line_rect(lst.get_cursor())
      tf := TextField().
         set_border(EmptyBorder().set_l_inset(Gui.TEXT_INSET).set_r_inset(Gui.TEXT_INSET)).
         set_contents(s).
         set_mark(1).
         connect(on_list_edit, Event.ACTION)
      PopupEditor(tf).
         set_geometry(r.x, r.y, r.w, r.h).
         popup(lst, ev)
   end

   private on_tree_edit(ev, src)
      local n
      n := tree.object_get_cursor() | fail
      n.set_label(src.get_contents())
      tree.tree_structure_changed()
   end

   private on_tree_rename(ev)
      local n, tf, r, cw
      n := tree.object_get_cursor() | fail
      r := tree.get_line_rect(tree.get_cursor())
      cw := n.depth * tree.col_w + tree.col_w
      r.x +:= cw
      r.w -:= cw
      if r.w < 10 then fail
      tf := TextField().
         set_border(EmptyBorder().set_l_inset(Gui.TEXT_INSET).set_r_inset(Gui.TEXT_INSET)).
         set_contents(n.label).
         set_mark(1).
         connect(on_tree_edit, Event.ACTION)
      PopupEditor(tf).
         set_geometry(r.x, r.y, r.w, r.h).
         popup(tree, ev)
   end

   #
   # A selection-up event on the tree
   #
   public on_tree_press(ev)
      local m, mi, pm, nl

      nl := tree.object_get_gesture_selections() | fail

      m := Menu()

      mi := TextMenuItem().set_label("Delete")
      mi.connect(self.on_delete_node, Event.ACTION)
      m.add(mi)

      if *nl = 1 then {
         mi := TextMenuItem().set_label("Rename")
         mi.connect(self.on_tree_rename, Event.ACTION)
         m.add(mi)
         if \nl[1].is_folder_flag then {
            mi := TextMenuItem().set_label("New folder")
            mi.connect(self.on_new_folder, Event.ACTION)
            m.add(mi)
         }
      }

      pm := PopupMenu()
      pm.popup(self, m, ev.x, ev.y)
   end

   private get_list_sel()
      local t
      t := lst.get_gesture_selections() | []
      if t[-1] = *lst.get_contents() then
         pull(t)
      return t
   end

   #
   # A mouse press event on the list
   #
   public on_list_press(ev)
      local m, mi, pm, t

      t := get_list_sel()
      m := Menu()
      if *t > 0 then {
         mi := TextMenuItem().set_label("Delete")
         mi.connect(self.on_delete_lines, Event.ACTION)
         m.add(mi)
      }
      if *t = 1 then {
         mi := TextMenuItem().set_label("Rename")
         mi.connect(self.on_list_rename, Event.ACTION)
         m.add(mi)
      }
      mi := TextMenuItem().set_label("Insert rows")
      mi.connect(self.on_new_rows, Event.ACTION)
      m.add(mi)

      pm := PopupMenu()
      pm.popup(self, m, ev.x, ev.y)
   end

   public component_setup()
      local quit, split

      set_resize(&yes)
      connect(self.dispose, Event.WINDOW_CLOSE_BUTTON)
      set_layout(GridLayout())

      tree := CustomTree().
         set_size(150,220).
         set_allow_drag(&yes).
         set_allow_drop(&yes).
         set_select_mode("many").
         set_show_root_handles(&no).
         connect(self.on_tree_press, Event.MOUSE_RIGHT_PRESS)


      #
      # Create a TextList, with some arbitrary content.
      #
      lst := CustomList().
         set_constraint("eol", &yes).
         set_size(150,220).
         set_allow_drag(&yes).
         set_allow_drop(&yes).
         set_select_mode("many").
         set_contents(["one","two","three","four","five","six",
                       "seven","eight","nine","ten","eleven","twelve",
                       "thirteen","fourteen","fifteen","sixteen","red","blue","green",""]).
         connect(self.on_list_press, Event.MOUSE_RIGHT_PRESS)

      split := Split().
         set_constraint("eol", &yes).
         set_left(tree).
         set_right(lst)
      add(split)

      quit := TextButton().
         set_label("Quit").
         connect(self.dispose, Event.ACTION)
      add(quit)
   end
end


procedure main()
   local d
   d := DNDTest()
   d.show_modal()
end



