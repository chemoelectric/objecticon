#
# $Id$
#

package datastruct

import ipl.pdco(Seq,Length,Index), lang, util

record Entry(key, val)

#
# This is a common superclass for several table-like data structures.
#
abstract class Table(HasMode, ObjectOutput, ObjectHash, ObjectEquals)
   public const def

   public static const
      # Empty table implementation
      EMPTY_TABLE,
      # Constant indicating modifiable capability
      MODIFY,
      # Constant indicating insert capability
      INSERT,
      # Constant indicating delete capability
      DELETE,
      # Constant indicating keys are stored in order
      ORDER

   private static init()
      EMPTY_TABLE := EmptyTable()
      MODIFY := 1
      INSERT := 2
      DELETE := 4
      ORDER := 8
   end
   
   #
   # Insert a new entry.  Always succeeds and returns `self`.  Only
   # implemented with INSERT capability.
   #
   public optional insert(key, val)

   # Return the value for the given key if it is in the table, or fail
   # if it is not present.  If the table has MODIFY capability, a
   # variable is returned; otherwise the value.
   #
   public abstract member(key)
   
   #
   # Delete the entry with the given key.  Fails if the key was not
   # present, otherwise succeeds and returns `self`.  Only implemented
   # with DELETE capability.
   #
   public optional delete(key)

   #
   # Return the value with the given key, or the default value if
   # the key is not present.  Equivalent to `.t[k]` for a table.
   #
   public get(key)
      return .member(key) | def
   end

   #
   # Like `member`, but if the key is not present a new entry is added
   # (with the default value).  If the table has MODIFY capability, a
   # variable for the new entry is returned, otherwise a value is
   # returned.
   #
   # Example :-
   # ~
   #    # Word counting
   #    t := SortTable(0)
   #    every w := words() do
   #       t.add(w) +:= 1
   # ~
   public add(key)
      return member(key) | (insert(key, def) & member(key))
   end

   #
   # Return a sorted list of key-value pairs.
   #
   public sort()
      local l
      l := entry_list()
      return if can(ORDER) then l else sortf(l, 1)
   end

   #
   # Return a sorted list of keys.
   #
   public key_sort()
      # This is defined in terms of sort() above rather than just
      # sorting key_list(), so that classes with a custom sort()
      # ordering don't need to override both sort methods.
      return if can(ORDER) then key_list() else ipl.pdco.List{(!sort())[1]}
   end

   #
   # Generate the keys (cf the builtin key() function).  With
   # ORDER capability, the keys are generated in sorted order.
   #
   public abstract key()

   #
   # Generate alternating key/value pairs (cf the builtin keyval()
   # function.)  If the table has MODIFY capability, the entry values
   # will be generated as variables, otherwise as values.
   #
   public keyval()
      local k
      every k := key() do
         suspend k | member(k)
   end

   #
   # Generate the keys (cf the builtin key() function) in reverse
   # order.  Only implemented with ORDER capability.
   #
   public optional back_key()

   #
   # Generate alternating key/values (cf the builtin keyval()
   # function.) in reverse order.  Only implemented with ORDER
   # capability.  If the table has MODIFY capability, the entry values
   # will be generated as variables, otherwise as values.
   #
   public back_keyval()
      local k
      every k := back_key() do
         suspend k | member(k)
   end

   #
   # Return the rank of the given key, ie its order number in the
   # table; fails if there is no matching key in the table.  Only
   # implemented for tables with ORDER capability.
   #
   public optional rank(key)

   #
   # Return the `i`th key, in order, in the table.  Fails if `i` is
   # out of range, using standard icon indexing semantics.  Only
   # implemented for tables with ORDER capability.
   #
   public select(i)
      can(ORDER) | runerr("Table doesn't have ORDER capability", self)
      return Index{key(), cvpos_item(i, size())}
   end

   #
   # Generate the values (cf !t for a table).  If the table has MODIFY
   # capability, variables are generated, otherwise values.
   #
   public gen()
      suspend member(key())
   end

   #
   # Generate the values in reverse order.  Only implemented with
   # ORDER capability.  If the table has MODIFY capability, variables
   # are generated, otherwise values.
   #
   public back()
      suspend member(back_key())
   end

   #
   # Return the size of the table.
   #
   public size()
      return Length{key()}
   end
      
   #
   # Succeed iff the size is zero.
   #
   public empty()
      succeed size() = 0
   end

   #
   # Clear the table of all elements. Always succeeds and returns
   # `self`.  Only implemented with DELETE capability.
   #
   public clear()
      while size() > 0 do
         delete(key())
      link
   end

   #
   # Generate key-value pairs as a sequence of `Entry` records.  NB -
   # for each invocation, the same record is returned every time, with
   # the values replaced.
   #
   public entries()
      local e, x, f
      e := Entry()
      every x := keyval() do {
         if /f then {
            e.key := x
            f := &yes
         } else {
            e.val := x
            suspend e
            f := &null
         }
      }
   end

   # Return a flat list, with alternating key-value entries.
   public flatten()
      return ipl.pdco.List{keyval()}
   end

   # Return an unsorted list of the keys.
   public key_list()
      return ipl.pdco.List{key()}
   end

   # Return an (unsorted) list of pairs of key-values.
   public entry_list()
      local e, x, r, f
      r := []
      every x := keyval() do {
         if /f then {
            e := Entry(x)
            f := &yes
         } else {
            e.val := x
            put(r, e)
            f := &null
         }
      }
      return r
   end

   #
   # Custom equals mirrors the `equals()` behaviour for builtin tables.
   #
   private override object_equals(other, seen)
      other.size() = self.size() | fail
      equals(other.def, self.def, seen) | fail
      return hash_and_check(other.entry_list(), self.entry_list(), seen)
   end

   #
   # Custom hash mirrors the `hash()` behaviour for builtin tables.
   #
   private override object_hash(depth)
      local n
      n := size()
      if depth > 1 then {
         n +:= hash(def, depth - 1)
         every n +:= hash(key(), depth - 1)
      }
      return n
   end

   #
   # Output object
   #
   private override object_output(oo)
      local pairs, e, sep
      pairs := sort()
      if oo.simple{!!pairs | def} then {
         oo.object_start(self)
         if \def then {
            oo.writes1("default=").
               traverse(def)
            sep := &yes
         }
         every e := !pairs do {
            if \sep then
               oo.writes1(";")
            oo.traverse(e.key).
               writes1("->").
               traverse(e.val)
            sep := &yes
         }
         oo.object_end(self)
      } else {
         oo.nl().
            object_start(self).
            iplus()
         if \def then {
            oo.nl().
               writes1("default=").
               iplus().
               traverse(def).
               iminus()
         }
         every e := !pairs do {
            oo.nl().
               traverse(e.key).
               writes1("->").
               iplus().
               traverse(e.val).
               iminus()
         }
         oo.iminus().
            nl().
            object_end(self)
      }
   end

   protected init_entries(entries)
      if *entries % 2 ~= 0 then
          runerr(168)
      while *entries > 0 do
         insert(default.get(entries), default.get(entries))
   end
end

#
# A class to provide an unmodifiable view of another table.
#
class UnmodifiableTable(Table)
   private const t

   public override member(key)
      return .t.member(key)
   end

   public override sort()
      return t.sort()
   end

   public override key_sort()
      return t.key_sort()
   end

   public override key()
      suspend t.key()
   end

   public override keyval()
      suspend .t.keyval()
   end

   public override back_key()
      suspend t.back_key()
   end

   public override back_keyval()
      suspend .t.back_keyval()
   end

   public override rank(key)
      return t.rank(key)
   end

   public override select(i)
      return t.select(i)
   end

   public override gen()
      suspend .t.gen()
   end

   public override back()
      suspend .t.back()
   end

   public override size()
      return t.size()
   end

   public override get_mode()
      return iand(ORDER, t.get_mode())
   end

   public new(t)
      self.t := t
      self.def := t.def
      return
   end
end

#
# A list-view of the keys of a table with ORDER capability.
#
class TableKeyList(List)
   private const t

   public override at(i)
      return t.select(i)
   end

   public override delete(i)
      link t.delete(t.select(i))
   end

   public override gen()
      suspend t.key()
   end

   public override back()
      suspend t.back_key()
   end

   public override size()
      return t.size()
   end

   public override clear()
      t.clear()
      link
   end

   public override get_mode()
      return iand(DELETE, t.get_mode())
   end

   public new(t)
      t.can(Table.ORDER) | runerr("Table doesn't have ORDER capability", t)
      self.t := t
      return
   end
end

package class SortTableNode()
   public key, val,
      l, r, is_red_flag, N

   public new(k, v)
      self.key := k
      self.val := v
      self.is_red_flag := &yes
      self.N := 1
      return
   end
end

#
# A `Table` which uses a red-black binary tree so that its members are always
# in sorted order.
#
class SortTable(Table)
   private root
   public const cmp

   public override insert(key, val)
      root := insert1(root, key, val)
      root.is_red_flag := &no
      link
   end

   private insert1(n, key, val)
      local i
      if /n then
         return SortTableNode(key, val)
      i := cmp(key, n.key)
      if i < 0 then
         n.l := insert1(n.l, key, val)
      else if i > 0 then
         n.r := insert1(n.r, key, val)
      else {
         n.key := key
         n.val := val
         return n
      }
      
      if is_red(n.r) & not is_red(n.l) then
         n := rotate_left(n)
      if is_red(n.l) & is_red(n.l.l) then
         n := rotate_right(n)
      if is_red(n.l) & is_red(n.r) then
         flip_colors(n)
      
      n.N := size1(n.l) + size1(n.r) + 1

      return n
   end

   public override member(key)
      local n, i
      n := root
      while \n do {
         i := cmp(key, n.key)
         if i = 0 then
            return n.val
         n := if i < 0 then
            n.l
         else
            n.r
      }
   end

   public override delete(key)
      member(key) | fail
      if not(is_red(root.l | root.r)) then
         root.is_red_flag := &yes
      root := delete1(root, key)
      (\root).is_red_flag := &no
      link
   end

   private delete1(n, key)
      local x
      if cmp(key, n.key) < 0 then {
         if not(is_red(n.l | n.l.l)) then
            n := move_red_left(n)
         n.l := delete1(n.l, key)
      } else {
         if is_red(n.l) then
            n := rotate_right(n)
         if cmp(key, n.key) = 0 & /n.r then
            return
         if not(is_red(n.r | n.r.l)) then
            n := move_red_right(n)
         if cmp(key, n.key) = 0 then {
            x := min1(n.r)
            n.key := x.key
            n.val := x.val
            n.r := delete_min1(n.r)
         } else
            n.r := delete1(n.r, key)
      }
      return balance(n)
   end

   private min1(n)
      while \n.l do
         n := n.l
      return n
   end

   private delete_min1(n)
      if /n.l then
         return
      if not(is_red(n.l | n.l.l)) then
         n := move_red_left(n)
      n.l := delete_min1(n.l)
      return balance(n)
   end

   private balance(n)
      if is_red(n.r) then
         n := rotate_left(n)
      if is_red(n.l) & is_red(n.l.l) then
         n := rotate_right(n)
      if is_red(n.l) & is_red(n.r) then
         flip_colors(n)
      n.N := size1(n.l) + size1(n.r) + 1
      return n
   end

   private rotate_right(n)
      local x
      x := n.l
      n.l := x.r
      x.r := n
      x.is_red_flag := x.r.is_red_flag
      x.r.is_red_flag := &yes
      x.N := n.N
      n.N := size1(n.l) + size1(n.r) + 1
      return x
   end

   private rotate_left(n)
      local x
      x := n.r
      n.r := x.l
      x.l := n
      x.is_red_flag := x.l.is_red_flag
      x.l.is_red_flag := &yes
      x.N := n.N
      n.N := size1(n.l) + size1(n.r) + 1
      return x
   end
   
   private move_red_left(n)
      flip_colors(n)
      if is_red(n.r.l) then {
         n.r := rotate_right(n.r)
         n := rotate_left(n)
      }
      return n
   end

   private move_red_right(n)
      flip_colors(n)
      if is_red(n.l.l) then
         n := rotate_right(n)
      return n
   end

   private flip_colors(n)
      n.is_red_flag := toggle_flag(n.is_red_flag)
      n.l.is_red_flag := toggle_flag(n.l.is_red_flag)
      n.r.is_red_flag := toggle_flag(n.r.is_red_flag)
      link
   end

   private traverse(n)
      \n | fail
      traverse(n.l)
      coact(n)
      traverse(n.r)
   end

   private back_traverse(n)
      \n | fail
      back_traverse(n.r)
      coact(n)
      back_traverse(n.l)
   end

   private is_red(n)
      succeed \ (\n).is_red_flag
   end

   private size1(n)
      return if /n then 0 else n.N
   end

   public override key()
      suspend .Seq{traverse(root)}.key
   end

   public override keyval()
      local e
      every e := Seq{traverse(root)} do
         suspend .e.key | e.val
   end

   public override back_key()
      suspend .Seq{back_traverse(root)}.key
   end

   public override back_keyval()
      local e
      every e := Seq{back_traverse(root)} do
         suspend .e.key | e.val
   end

   public override gen()
      suspend Seq{traverse(root)}.val
   end

   public override back()
      suspend Seq{back_traverse(root)}.val
   end

   public override clear()
      root := &null
      link
   end

   public override size()
      return size1(root)
   end

   public override select(i)
      i := cvpos_item(i, size()) | fail
      return .select1(root, i - 1).key
   end

   public override rank(k)
      return rank1(root, k) + 1
   end

   private select1(n, i)
      local t
      t := size1(n.l)
      return if t > i then
         select1(n.l, i)
      else if t < i then
         select1(n.r, i - t - 1)
      else
         n
   end
   
   private rank1(n, k)
      local t
      \n | fail
      t := cmp(k, n.key)
      return if t < 0 then
         rank1(n.l, k)
      else if t > 0 then 
         1 + size1(n.l) + rank1(n.r, k)
      else 
         size1(n.l)
   end

   #
   # Check the table for internal consistency.
   #
   public check()
      is_bst(root) | return error("Not in symmetric order")
      is_size_consistent(root)  | return error("Subtree counts not consistent")
      is_rank_consistent(root)  | return error("Ranks not consistent")
      is_23(root) | return error("Not a 2-3 tree")
      is_balanced() | return error("Not balanced")
      link
   end

   private is_balanced()
      local b, n
      b := 0
      n := root
      while \n do {
         is_red(n) | (b +:= 1)
         n := n.l
      }
      succeed is_balanced1(root, b)
   end

   private is_balanced1(n, b)
      if /n then succeed b = 0
      is_red(n) | (b -:= 1)
      succeed is_balanced1(n.l, b) & is_balanced1(n.r, b)
   end

   private is_23(n)
      if /n then return
      if is_red(n.r) then fail
      if n ~=== root & is_red(n) & is_red(n.l) then fail
      succeed is_23(n.l) & is_23(n.r)
   end

   private is_bst(n, min, max)
      if /n then return
      if cmp(n.key, \min) <= 0 then fail
      if cmp(n.key, \max) >= 0 then fail
      succeed is_bst(n.l, min, n.key) & is_bst(n.r, n.key, max)
   end

   private is_size_consistent(n)
      if /n then return
      (n.N = size1(n.l) + size1(n.r) + 1) | fail
      succeed is_size_consistent(n.l) & is_size_consistent(n.r)
   end

   private is_rank_consistent()
      local i, k
      every i := 1 to size() do
         (i = rank(select(i))) | fail
      every k := key() do
         (cmp(k, select(rank(k))) = 0) | fail
      return
   end

   public override get_mode()
      return MODIFY + INSERT + DELETE + ORDER
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `def` - the default value
   # :  `cmp` - a comparator function taking two arbitrary values and
   #     returning `<0`, `0` or `>0` by way of comparison.  The default
   #     value is `Internal.compare`.  The function must satisfy
   #     *  `sign(cmp(a,b)) = -sign(cmp(b,a))` for all `a,b`
   #     *  `cmp(a,b)>0 & cmp(b,c)>0 => cmp(a,c)>0`
   #     *  `cmp(a,b)=0 <=> sign(cmp(a,x))=sign(cmp(b,x))` for all other `x'.
   # :  `entries` - initial key-value entries.
   #
   public new(def, cmp, entries[])
      self.def := def
      /cmp := Internal.compare
      self.cmp := cmp
      init_entries(entries)
      return
   end
end

#
# A `Table` which uses the `lang.equals` procedure for key comparison,
# rather than the builtin `===` operator.
#
class EqTable(Table)
   private const t
   private sz

   public override insert(key, val)
      add(key) := val
      link
   end

   public override add(key)
      local h, l, e, n
      h := hash(key)
      if l := default.member(t, h) then {
         every e := !l do {
            if equals(e.key, key) then
               return e.val
         }
      }
      n := Entry(key, def)
      if \l then
         put(l, n)
      else
         default.insert(t, h, [n])
      sz +:= 1
      return n.val
   end

   public override member(key)
      local e
      every e := !default.member(t, hash(key)) do {
         if equals(e.key, key) then
            return e.val
      }
   end

   public override delete(key)
      local h, l, e, i
      h := hash(key)
      l := default.member(t, h) | fail
      i := 1
      every e := !l do {
         if equals(e.key, key) then {
            default.delete(l, i)
            if *l = 0 then
               default.delete(t, h)
            sz -:= 1
            link
         }
         i +:= 1
      }
   end

   public override key()
      suspend .(!!t).key
   end

   public override keyval()
      local e
      every e := !!t do
         suspend .e.key | e.val
   end

   public override gen()
      suspend (!!t).val
   end

   public override size()
      return .sz
   end

   public override clear()
      default.clear(t)
      sz := 0
      link
   end

   public override get_mode()
      return MODIFY + INSERT + DELETE
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `def` - the default value
   # :  `entries` - initial key-value entries.
   #
   public new(def, entries[])
      self.def := def
      t := table()
      sz := 0
      init_entries(entries)
      return
   end
end

#
# A `Table` which is just a wrapper around a builtin table.
#
class BuiltinTable(Table)
   private const t

   public override insert(key, val)
      default.insert(t, key, val)
      link
   end

   public override member(key)
      return default.member(t, key)
   end

   public override delete(key)
      link default.delete(t, key)
   end

   public override key()
      suspend default.key(t)
   end

   public override keyval()
      suspend default.keyval(t)
   end

   public override gen()
      suspend !t
   end

   public override clear()
      default.clear(t)
      link
   end

   public override size()
      return *t
   end

   public override get_mode()
      return MODIFY + INSERT + DELETE
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `t` - the table to wrap; if omitted then a new table is
   #       created.
   #
   public new(t)
      /t := table()
      self.t := t
      self.def := t[[]]
      return
   end
end

package class EmptyTable(Table, SelfClone)
   public override member(x)
   end

   public override key()
   end

   public override size()
      return 0
   end

   public override get_mode()
      return 0
   end

   package new()
      return
   end
end

#
# A `Table` which uses weak references
#
class WeakrefTable(Table)
   private const t
   private sz, last_purge, repeat_collect_flag

   # This flag can be set to force repeated collections during a
   # purge, whilst this reduces the size of the table.  This can be
   # useful in the case that the values in the table hold references
   # to objects that are also referenced as keys.  Unlike those keys,
   # these references count as non-weak.  What happens therefore is
   # that a single collect (and purge) will delete just those keys
   # that don't have references via values.  As those keys and values
   # are purged, the next level of references can be removed with
   # another collect and purge, and so on.  This flag causes such a
   # loop to be executed by each purge.
   #
   public set_repeat_collect(s)
      self.repeat_collect_flag := need_flag(s)
      link
   end

   public override insert(key, val)
      add(key) := val
      link
   end

   public override add(key)
      local h, l, e, n
      maybe_purge()
      h := Internal.hash(key)
      if l := default.member(t, h) then {
         every e := !l do {
            if weakrefval(e.key) === key then
               return e.val
         }
      }
      n := Entry(weakref(key), def) | runerr("Type of key cannot be used with weakref")
      if \l then
         put(l, n)
      else
         default.insert(t, h, [n])
      sz +:= 1
      return n.val
   end

   public override member(key)
      local e
      maybe_purge()
      every e := !default.member(t, Internal.hash(key)) do {
         if weakrefval(e.key) === key then
            return e.val
      }
   end

   public override delete(key)
      local h, l, e, i
      maybe_purge()
      h := Internal.hash(key)
      l := default.member(t, h) | fail
      i := 1
      every e := !l do {
         if weakrefval(e.key) === key then {
            default.delete(l, i)
            if *l = 0 then
               default.delete(t, h)
            sz -:= 1
            link
         }
         i +:= 1
      }
   end

   public override key()
      maybe_purge()
      suspend weakrefval((!!t).key)
   end

   public override keyval()
      local e
      maybe_purge()
      every e := !!t do
         suspend weakrefval(e.key) | e.val
   end

   public override gen()
      maybe_purge()
      suspend (!!t).val
   end

   public override clear()
      default.clear(t)
      sz := 0
      link
   end

   public override size()
      maybe_purge()
      return .sz
   end

   public maybe_purge()
      local old_sz
      if last_purge ~=== Prog.get_global_collection_count() then {
         repeat {
            old_sz := sz
            last_purge := Prog.get_global_collection_count()
            purge()
            if /repeat_collect_flag | (old_sz = sz) then
               break
            collect()
         }
      }
      link
   end

   private purge()
      local h, l, i
      every h := default.key(t) do {
         l := t[h]
         i := 1
         while i <= *l do {
            if weakrefval(l[i].key) then
               i +:= 1
            else {
               default.delete(l, i)
               sz -:= 1
            }
         }
         if *l = 0 then
            default.delete(t, h)
      }
   end

   public override get_mode()
      return MODIFY + INSERT + DELETE
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `def` - the default value
   # :  `entries` - initial key-value entries.
   #
   public new(def, entries[])
      self.def := def
      self.t := table()
      self.sz := 0
      init_entries(entries)
      return
   end
end

# A convenient equivalent to wrapping a BuiltinTable in an
# UnmodifiableTable.
#
class UnmodifiableBuiltinTable(Table)
   private const t

   public override member(key)
      return .default.member(t, key)
   end

   public override key()
      suspend default.key(t)
   end

   public override keyval()
      suspend .default.keyval(t)
   end

   public override gen()
      suspend .!t
   end

   public override size()
      return *t
   end

   public override get_mode()
      return 0
   end

   #
   # Create a new instance.
   #
   # :Parameters :
   # :  `t` - the table to wrap
   #
   public new(t)
      self.t := t
      self.def := t[[]]
      return
   end
end
