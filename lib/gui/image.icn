#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

import util, ipl.graphics(Zoom), graphics

#
# This class scales and displays an image.  The image source can
# be an image string, an external file, or another window, and
# can be changed at any time.
#
# @field image=string : see {set_image}
# @field file=string : see {set_file}
# @field window={Window} : see {set_window}
# @field scale_up=flag : see {set_scale_up}
# @field use_cache=flag : see {set_use_cache}
# @field see also {Component}
#
class Image(Component)
   public 
      image_file, 
      image_str,
      image_window,
      win,
      zoom_win,
      scale_up_flag,
      use_cache_flag,
      dont_close

   #
   # Set the name of the file from which to load the image;
   # re-display the image from the new file if appropriate.
   #
   public set_file(x)
      self.image_file := self.image_str := self.image_window := &null
      if is_initialized() then {
         close_image()
         self.image_file := x
         load_image()
         self.invalidate()
      } else {
         self.image_file := x
      }
   end

   #
   # Set an image in Icon image format.
   #
   public set_image(x)
      self.image_file := self.image_str := self.image_window := &null
      if is_initialized() then {
         close_image()
         self.image_str := x
         load_image()
         self.invalidate()
      } else {
         self.image_str := x
      }
   end

   #
   # Set a window to use as the image source.  It will not be closed
   # by this Component.
   #
   public set_window(x)
      self.image_file := self.image_str := self.image_window := &null
      if is_initialized() then {
         close_image()
         self.image_window := x
         load_image()
         self.invalidate()
      } else {
         self.image_window := x
      }
   end

   #
   # Blank the image
   #
   public clear_image()
      self.image_file := self.image_str := self.image_window := &null
      if is_initialized() then {
         close_image()
         self.invalidate()
      }
   end

   public initially()
      cast(self,Component).initially()
      load_image()
   end

   public load_image()
      local attribs
      if \self.image_str then {
         # Use our own attribs so that shade and highlight in the icon image
         # comes out according to our own cbwin.
         attribs := wattribs_to_list(self.get_effective_wattribs())
         win := Window.open!(attribs ||| ["size=" || (0 < image_width(self.image_str)) || 
                                          "," || (0 < image_height(self.image_str)),
                                          "canvas=hidden"])
         draw_image_ex(\win, 0, 0, self.image_str)
      } else if \self.image_file then {
         if \self.use_cache_flag then {
            if win := ImageCache.get(self.image_file) then
               dont_close := 1
         } else
            win := Window.open("image=" || self.image_file, "canvas=hidden")
      } else if \self.image_window then {
         win := self.image_window
         dont_close := 1
      }
   end

   #
   # If set, then the image will be scaled up to fit in the space
   # specified by {set_size()}.  The image will not be distorted, 
   # but will be expanded to fill one of the dimensions depending 
   # on its shape.  If the image is bigger than the specified size 
   # then it will always be scaled down.
   #
   public set_scale_up(s)
      self.scale_up_flag := check_flag(s)
   end

   public close_image()
      if \win & /dont_close then {
         Gui.style.dispose(win)
         win.close()
      }
      (\zoom_win).close()
      dont_close := win := zoom_win := &null
   end

   #
   # Indicate whether to use the image cache to load external files; by
   # default &yes.
   #
   public set_use_cache(s)
      self.use_cache_flag := check_flag(s)
   end

   public get_default_width()
      return (\win).attrib("width") + border.get_total_width()
   end

   public get_default_height()
      return (\win).attrib("height") + border.get_total_height()
   end

   public display()
      local ir, img_w, img_h,
         asp_r, asp_max, zoom_w, zoom_h, pt

      border.draw_rect(self.cbwin, self)

      \win | fail

      ir := border.get_inner_rect(self)

      img_w := win.attrib("width")
      img_h := win.attrib("height")

      if img_w = ir.w & img_h = ir.h then {
         Window.copy_area(win, 
                          self.cbwin,,,,, 
                          self.x + border.get_l_inset(),
                          self.y + border.get_l_inset())
      } else {
         #
         # Scale the image to the desired size
         #

         asp_r := real(img_w) / real(img_h)
         asp_max := real(ir.w) / real(ir.h)

         if /self.scale_up_flag & (img_w <= ir.w) & (img_h <= ir.h) then {
            zoom_w := img_w
            zoom_h := img_h
         } else {
            if asp_r > asp_max then {
               zoom_w := ir.w
               zoom_h := integer(ir.w / asp_r)
            } else {
               zoom_w := integer(ir.h * asp_r)
               zoom_h := ir.h
            }
         }

         pt := ir.float(Size(zoom_w, zoom_h), border)

         zoom_w <:= 1
         zoom_h <:= 1

         if \zoom_win &
            zoom_win.attrib("width") = zoom_w & 
            zoom_win.attrib("height") = zoom_h then
               Window.copy_area(zoom_win, self.cbwin, , , , , pt.x, pt.y)
         else {
            (\zoom_win).close()
            zoom_win := Window.open("size=" || zoom_w || "," || zoom_h, 
                              "canvas=hidden") | syserr("Couldn't open temp window")
            Zoom(win, zoom_win, 0, 0, img_w, img_h, 0, 0, zoom_w, zoom_h)
            Window.copy_area(zoom_win, self.cbwin, , , , , pt.x, pt.y)
         }
      }
   end

   public set_one(f)
      case f.attr of {
         "image" : set_image(f.string_val())
         "file" : set_file(f.string_val())
         "window" : set_window(f.object_val(Window))
         "scale_up" : set_scale_up(f.flag_val())
         "use_cache" : set_use_cache(f.flag_val())
         default: return cast(self,Component).set_one(f)
      }
      return
   end

   public finally()
      cast(self,Component).finally()
      close_image()
   end

   public new(a[])
      cast(self,Component).new()
      self.set_constraint("x_fill", &yes)
      self.set_constraint("y_fill", &yes)
      self.set_constraint("x_weight", "1")
      self.set_constraint("y_weight", "1")
      set_border(RaisedBorder())
      self.use_cache_flag := 1
      set_fields(a)
      return
   end
end



