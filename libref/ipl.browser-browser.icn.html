<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>browser.icn</title></head><body><pre>
<a name="1"/>package ipl.browser
<a name="2"/>
<a name="3"/>import 
<a name="4"/>   gui, 
<a name="5"/>   lang, 
<a name="6"/>   mail,
<a name="7"/>   http,
<a name="8"/>   util,
<a name="9"/>   io,
<a name="10"/>   net,
<a name="11"/>   xml,
<a name="12"/>   posix,
<a name="13"/>   graphics(Window,Key,Selection,Mouse),
<a name="14"/>   xdg,
<a name="15"/>   ipl.childwait,
<a name="16"/>   ipl.lists,
<a name="17"/>   ipl.tables,
<a name="18"/>   ipl.pdco,
<a name="19"/>   ipl.io,
<a name="20"/>   ipl.sort,
<a name="21"/>   ipl.strings,
<a name="22"/>   ipl.scan,
<a name="23"/>   ipl.timegui,
<a name="24"/>   ipl.colorgui,
<a name="25"/>   ipl.filegui,
<a name="26"/>   ipl.numbers,
<a name="27"/>   ipl.imagedetect,
<a name="28"/>   ipl.charset,
<a name="29"/>   ipl.dataurl,
<a name="30"/>   ipl.functional
<a name="31"/>
<a name="32"/>$load BROKEN_LINK "rpp.BROKEN_LINK_24.gif"
<a name="33"/>
<a name="34"/>class Req()
<a name="35"/>   public const
<a name="36"/>      client, url, referer, callback, kind, form_data, on_status
<a name="37"/>
<a name="38"/>   public new(client, url, referer, callback, kind, form_data, on_status)
<a name="39"/>      self.client := client
<a name="40"/>      self.url := url
<a name="41"/>      self.referer := referer
<a name="42"/>      self.callback := callback
<a name="43"/>      self.kind := kind
<a name="44"/>      self.form_data := form_data
<a name="45"/>      self.on_status := on_status
<a name="46"/>      return
<a name="47"/>   end
<a name="48"/>end
<a name="49"/>
<a name="50"/>class Resp()
<a name="51"/>   public const
<a name="52"/>      req, err, url, data, fname, content_type, content_disposition, data_file
<a name="53"/>
<a name="54"/>   public new(req, err, url, data, fname, content_type, content_disposition, data_file)
<a name="55"/>      self.req := req
<a name="56"/>      self.err := err
<a name="57"/>      self.url := url
<a name="58"/>      self.data := data
<a name="59"/>      self.fname := fname
<a name="60"/>      self.content_type := content_type
<a name="61"/>      self.content_disposition := content_disposition
<a name="62"/>      self.data_file := data_file
<a name="63"/>      return
<a name="64"/>   end
<a name="65"/>end
<a name="66"/>
<a name="67"/>class StaticData()
<a name="68"/>   public const
<a name="69"/>      data, fname, content_type, content_disposition
<a name="70"/>
<a name="71"/>   public new(data, fname, content_type, content_disposition)
<a name="72"/>      self.data := data
<a name="73"/>      self.fname := fname
<a name="74"/>      self.content_type := content_type
<a name="75"/>      self.content_disposition := content_disposition
<a name="76"/>      return
<a name="77"/>   end
<a name="78"/>end
<a name="79"/>
<a name="80"/>record CacheControl(expiry, last_modified, etag)
<a name="81"/>
<a name="82"/>abstract class CacheEntry()
<a name="83"/>   public const
<a name="84"/>      url
<a name="85"/>   protected readable
<a name="86"/>      expiry
<a name="87"/>
<a name="88"/>   public set_expiry(exp)
<a name="89"/>      self.expiry := exp
<a name="90"/>      link
<a name="91"/>   end
<a name="92"/>
<a name="93"/>   public hasnt_expired(now)
<a name="94"/>      /now := Time.get_system_seconds()
<a name="95"/>      succeed /expiry | (expiry &gt; now)
<a name="96"/>   end
<a name="97"/>
<a name="98"/>   public abstract is_valid(now)
<a name="99"/>end
<a name="100"/>
<a name="101"/>class CacheAlias(CacheEntry)
<a name="102"/>   public const
<a name="103"/>      dest
<a name="104"/>
<a name="105"/>   public override is_valid(now)
<a name="106"/>      return hasnt_expired(now)
<a name="107"/>   end
<a name="108"/>
<a name="109"/>   public new(url, expiry, dest)
<a name="110"/>      self.url := url
<a name="111"/>      self.expiry := expiry
<a name="112"/>      self.dest := dest
<a name="113"/>      return
<a name="114"/>   end
<a name="115"/>end
<a name="116"/>
<a name="117"/>class CacheData(CacheEntry, StaticData)
<a name="118"/>   public const
<a name="119"/>      last_modified, etag
<a name="120"/>
<a name="121"/>   public override is_valid(now)
<a name="122"/>      return hasnt_expired(now) | may_revalidate()
<a name="123"/>   end
<a name="124"/>
<a name="125"/>   public may_revalidate()
<a name="126"/>      succeed \ (last_modified | etag)
<a name="127"/>   end
<a name="128"/>
<a name="129"/>   #
<a name="130"/>   # Indicates whether this is a local "cache:" URL.
<a name="131"/>   #
<a name="132"/>   public is_local()
<a name="133"/>      succeed url.scheme == "cache"
<a name="134"/>   end
<a name="135"/>
<a name="136"/>   public override new(url, expiry, data, fname, content_type, content_disposition, last_modified, etag)
<a name="137"/>      self.url := url
<a name="138"/>      self.data := data
<a name="139"/>      self.fname := fname
<a name="140"/>      self.content_type := content_type
<a name="141"/>      self.content_disposition := content_disposition
<a name="142"/>      self.expiry := expiry
<a name="143"/>      self.last_modified := last_modified
<a name="144"/>      self.etag := etag
<a name="145"/>      return
<a name="146"/>   end
<a name="147"/>end
<a name="148"/>
<a name="149"/>class HttpRequestHelperImpl(HttpRequestHelper)
<a name="150"/>   public const
<a name="151"/>      worker
<a name="152"/>   private readable
<a name="153"/>      cache_entry
<a name="154"/>
<a name="155"/>   public override get_authentication(httpc, dom, realm)
<a name="156"/>      return worker.pool.owner.get_authentication(httpc, dom, realm)
<a name="157"/>   end
<a name="158"/>
<a name="159"/>   public override modify_redirect(httpc, hreq, hresp)
<a name="160"/>      local ce
<a name="161"/>      #write("modify redirect? ", hreq.url.str())
<a name="162"/>      # Just in case we have made an if-modified request that's been
<a name="163"/>      # answered with a redirect, we don't want the headers to go
<a name="164"/>      # forward in the request.
<a name="165"/>      cache_entry := &amp;null
<a name="166"/>      hreq.
<a name="167"/>         unset_header("if-modified-since").
<a name="168"/>         unset_header("if-none-match")
<a name="169"/>
<a name="170"/>      # Never use the cache on a refresh
<a name="171"/>      if worker.req.kind === Worker.REFRESH then
<a name="172"/>         fail
<a name="173"/>      # .. or on anything other than a GET
<a name="174"/>      (hreq.method == "GET") | fail
<a name="175"/>
<a name="176"/>      ce := worker.pool.cache.get(hreq.url) | fail
<a name="177"/>      if ce.hasnt_expired() then {
<a name="178"/>         # The cache can be used to satisfy the request; use a custom
<a name="179"/>         # status code so the client can identify it.  It also avoids
<a name="180"/>         # the possibility of muddling things up if a redirection
<a name="181"/>         # leads to a genuine http error (eg circular redirection).
<a name="182"/>         #
<a name="183"/>         hresp.set_status("HTTP/1.1 999 Satisfied By Cache")
<a name="184"/>         cache_entry := ce
<a name="185"/>         return
<a name="186"/>      } else {
<a name="187"/>         # The cache can be used to satisfy the request, but with
<a name="188"/>         # validation, so setup the headers.
<a name="189"/>         cache_entry := ce
<a name="190"/>         # At least one of these should succeed
<a name="191"/>         hreq.set_header("if-modified-since", \ce.last_modified)
<a name="192"/>         hreq.set_header("if-none-match", \ce.etag)
<a name="193"/>      }
<a name="194"/>   end
<a name="195"/>
<a name="196"/>   public get_cache_entry()
<a name="197"/>      return .\self.cache_entry
<a name="198"/>   end
<a name="199"/>
<a name="200"/>   public new(worker, ce)
<a name="201"/>      self.worker := worker
<a name="202"/>      self.cache_entry := ce
<a name="203"/>      return
<a name="204"/>   end
<a name="205"/>end
<a name="206"/>
<a name="207"/>class Cache()
<a name="208"/>   private const
<a name="209"/>      t
<a name="210"/>   private
<a name="211"/>      size,
<a name="212"/>      id
<a name="213"/>
<a name="214"/>   public set_size(x)
<a name="215"/>      self.size := need_integer(x, 0)
<a name="216"/>      link
<a name="217"/>   end
<a name="218"/>
<a name="219"/>   public tidy()
<a name="220"/>      local now, ce, total, nv
<a name="221"/>      now := Time.get_system_seconds()
<a name="222"/>      total := 0
<a name="223"/>      # Data entries we can evict to free up space.  We exclude local
<a name="224"/>      # (cache:) URLs, since these cannot be reloaded.
<a name="225"/>      nv := set()
<a name="226"/>      every ce := !t do {
<a name="227"/>         if ce.is_valid(now) then {
<a name="228"/>            case classof(ce) of {
<a name="229"/>               CacheData: {
<a name="230"/>                  total +:= *ce.data
<a name="231"/>                  ce.is_local() | insert(nv, ce)
<a name="232"/>               }
<a name="233"/>               CacheAlias: member(t, ce.dest.str()) | delete_entry(ce)
<a name="234"/>            }
<a name="235"/>         } else
<a name="236"/>            delete_entry(ce)
<a name="237"/>      }
<a name="238"/>      while total &gt; size &amp; ce := ?nv do {
<a name="239"/>         delete(nv, ce)
<a name="240"/>         delete_entry(ce)
<a name="241"/>         total -:= *ce.data
<a name="242"/>      }
<a name="243"/>      link
<a name="244"/>   end
<a name="245"/>
<a name="246"/>   public delete_entry(ce)
<a name="247"/>      delete(t, ce.url.str())
<a name="248"/>      link
<a name="249"/>   end
<a name="250"/>
<a name="251"/>   public get(url)
<a name="252"/>      local ce
<a name="253"/>      every 1 to 2 do {
<a name="254"/>         ce := member(t, url.str()) | fail
<a name="255"/>         ce.is_valid() | fail
<a name="256"/>         if is(ce, CacheData) then
<a name="257"/>            return ce
<a name="258"/>         url := ce.dest
<a name="259"/>      }
<a name="260"/>   end
<a name="261"/>
<a name="262"/>   public clear()
<a name="263"/>      default.clear(t)
<a name="264"/>      link
<a name="265"/>   end
<a name="266"/>
<a name="267"/>   public clear_local()
<a name="268"/>      local ce
<a name="269"/>      every ce := !t do {
<a name="270"/>         if is(ce, CacheData) &amp; ce.is_local() then
<a name="271"/>            delete_entry(ce)
<a name="272"/>      }
<a name="273"/>      link
<a name="274"/>   end
<a name="275"/>
<a name="276"/>   public update_expiry(url, exp)
<a name="277"/>      local ce
<a name="278"/>      ce := member(t, url.str()) | fail
<a name="279"/>      ce.set_expiry(exp)
<a name="280"/>      link
<a name="281"/>   end
<a name="282"/>
<a name="283"/>   public add_data(url, expiry, data, fname, content_type, content_disposition, last_modified, etag)
<a name="284"/>      insert(t, url.str(), CacheData(url, expiry, data, fname, content_type, content_disposition, last_modified, etag))
<a name="285"/>      link
<a name="286"/>   end
<a name="287"/>
<a name="288"/>   public add_alias(url, expiry, dest)
<a name="289"/>      insert(t, url.str(), CacheAlias(url, expiry, dest))
<a name="290"/>      link
<a name="291"/>   end
<a name="292"/>
<a name="293"/>   public create_url(expiry, data, fname, content_type, content_disposition)
<a name="294"/>      local url
<a name="295"/>      /expiry := Time.get_system_seconds() + 60
<a name="296"/>      url := URL(u"cache:" || (id +:= 1))
<a name="297"/>      add_data(url, expiry, data, fname, content_type, content_disposition)
<a name="298"/>      return url
<a name="299"/>   end
<a name="300"/>
<a name="301"/>   private static format_expiry(v)
<a name="302"/>      if /v then
<a name="303"/>         return "never"
<a name="304"/>      v -:= Time.get_system_seconds()
<a name="305"/>      if v &lt; 0 then
<a name="306"/>         fail
<a name="307"/>      if v &lt; 300 then
<a name="308"/>         return v || "&amp;nbsp;secs"
<a name="309"/>      v /:= 60
<a name="310"/>      if v &lt; 120 then
<a name="311"/>         return v || "&amp;nbsp;mins"
<a name="312"/>      v /:= 60
<a name="313"/>      if v &lt;= 48 then
<a name="314"/>         return v || "&amp;nbsp;hours"
<a name="315"/>      v /:= 24
<a name="316"/>      if v &lt; 365 * 2 then
<a name="317"/>         return v || "&amp;nbsp;days"
<a name="318"/>      v /:= 365
<a name="319"/>      return v || "&amp;nbsp;years"
<a name="320"/>   end
<a name="321"/>
<a name="322"/>   public get_status()
<a name="323"/>      local s1, s2, ce, n, sz, exp, ct, total
<a name="324"/>      s1 := "&lt;table&gt;&lt;tr&gt;&lt;th align=left&gt;Filename&lt;/th&gt;&lt;th align=right&gt;Size&amp;nbsp;&lt;/th&gt;&lt;th&gt;Expiry&lt;/th&gt;_
<a name="325"/>             &lt;th align=left&gt;Content&amp;nbsp;type&lt;/th&gt;&lt;th align=left&gt;URL&lt;/th&gt;&lt;/tr&gt;"
<a name="326"/>      s2 := "&lt;table&gt;&lt;tr&gt;&lt;th align=left&gt;Dest&lt;/th&gt;&lt;th&gt;Expiry&lt;/th&gt;&lt;th align=left&gt;URL&lt;/th&gt;&lt;/tr&gt;"
<a name="327"/>      total := 0
<a name="328"/>      every ce := !t do {
<a name="329"/>         case classof(ce) of {
<a name="330"/>            CacheData: {
<a name="331"/>               exp := format_expiry(ce.expiry) | (if ce.may_revalidate() then "revalidate" else "expired")
<a name="332"/>               n := Browser.limit_text(\ce.fname, scale(200)) | "-"
<a name="333"/>               sz := Format.numeric_to_string(*ce.data, 0, ',')
<a name="334"/>               ct := (\ce.content_type).to_rfc2616() | "-"
<a name="335"/>               s1 ||:= "&lt;tr&gt;&lt;td&gt;" || Browser.to_content(n) || "&lt;/td&gt;&lt;td align=right&gt;" || sz || "&amp;nbsp;&lt;/td&gt;&lt;td&gt;" || exp ||
<a name="336"/>                  "&lt;/td&gt;&lt;td&gt;" || Browser.to_content(ct) || "&lt;/td&gt;" || Browser.mk_anchor_cell(ce.url) || "&lt;/tr&gt;" 
<a name="337"/>               total +:= *ce.data
<a name="338"/>            }
<a name="339"/>            CacheAlias: {
<a name="340"/>               exp := format_expiry(ce.expiry) | "expired"
<a name="341"/>               s2 ||:= "&lt;tr&gt;" || Browser.mk_anchor_cell(ce.dest) || "&lt;td&gt;" || exp || "&lt;/td&gt;" || Browser.mk_anchor_cell(ce.url) || "&lt;/tr&gt;" 
<a name="342"/>            }
<a name="343"/>         }
<a name="344"/>      }
<a name="345"/>      s1 ||:= "&lt;/table&gt;"
<a name="346"/>      s2 ||:= "&lt;/table&gt;"
<a name="347"/>
<a name="348"/>      return "&lt;html&gt;&lt;title&gt;Cache status&lt;/title&gt;" || s1 || "&lt;p&gt;" || s2 || "&lt;p&gt;" ||
<a name="349"/>            "Usage " || Format.numeric_to_string(total, 0, ',') || " / " || 
<a name="350"/>            Format.numeric_to_string(size, 0, ',') || " (" || integer((total * 100) / size) || "%)" ||
<a name="351"/>            "&lt;/html&gt;"
<a name="352"/>   end
<a name="353"/>
<a name="354"/>   public new(size)
<a name="355"/>      /size := 4 * 1024*1024
<a name="356"/>      t := table()
<a name="357"/>      set_size(size)
<a name="358"/>      id := 0
<a name="359"/>      return
<a name="360"/>   end
<a name="361"/>end
<a name="362"/>
<a name="363"/>abstract class SubWorker()
<a name="364"/>   public abstract cancel()
<a name="365"/>   public abstract get_read()
<a name="366"/>   public abstract get_length()
<a name="367"/>   public abstract get_data(worker)
<a name="368"/>end
<a name="369"/>
<a name="370"/>class ProgSubWorker(SubWorker)
<a name="371"/>   private 
<a name="372"/>      data
<a name="373"/>
<a name="374"/>   public override cancel() end
<a name="375"/>   public override get_length() end
<a name="376"/>
<a name="377"/>   public override get_read()
<a name="378"/>      return data.tell() - 1
<a name="379"/>   end
<a name="380"/>
<a name="381"/>   public override get_data(worker)
<a name="382"/>      local ts, f, d, ps
<a name="383"/>      if (\worker.req.referer).scheme == ("http" | "https") then
<a name="384"/>         return error("Can't run a prog from an http page")
<a name="385"/>      f := worker.req.url.get_decoded_path()
<a name="386"/>      if d := use {
<a name="387"/>         ts := TaskStream(ps := ProgInputStream("/bin/sh", ["-c", f]), worker.task),
<a name="388"/>         StaticData(read_all(ts), "")     # Return StaticData in order to set a blank filename.
<a name="389"/>      } &amp; ps.succeeded() then
<a name="390"/>         return d
<a name="391"/>   end
<a name="392"/>
<a name="393"/>   private read_all(ts)
<a name="394"/>      return use {
<a name="395"/>         data := RamStream(),
<a name="396"/>         ts.copy_to(data) &amp; data.str()
<a name="397"/>      }
<a name="398"/>   end
<a name="399"/>end
<a name="400"/>
<a name="401"/>class FileSubWorker(SubWorker)
<a name="402"/>   private 
<a name="403"/>      data
<a name="404"/>
<a name="405"/>   public override cancel() end
<a name="406"/>   public override get_length() end
<a name="407"/>
<a name="408"/>   public override get_read()
<a name="409"/>      return data.tell() - 1
<a name="410"/>   end
<a name="411"/>
<a name="412"/>   private static grname(gid)
<a name="413"/>      return System.getgr(gid).name | gid
<a name="414"/>   end
<a name="415"/>
<a name="416"/>   private static uname(uid)
<a name="417"/>      return System.getpw(uid).name | uid
<a name="418"/>   end
<a name="419"/>
<a name="420"/>   public override get_data(worker)
<a name="421"/>      local f, g, e, l, t, path, rs, now, tf, gcache, ucache
<a name="422"/>$if ~ _MS_WIN32
<a name="423"/>      local ts
<a name="424"/>$endif
<a name="425"/>
<a name="426"/>      # This will fail if, on Unix (but not Windows), the file has a
<a name="427"/>      # non-local host.
<a name="428"/>      #
<a name="429"/>      f := Files.url_to_file(worker.req.url) | fail
<a name="430"/>
<a name="431"/>      if Files.is_directory(f) then {
<a name="432"/>         l := qsort(Files.ucs_list(f), Files.name_cmp) | fail
<a name="433"/>         now := Time.get_system_seconds()
<a name="434"/>         ucache := memoize1(uname)
<a name="435"/>         gcache := memoize1(grname)
<a name="436"/>         return use {
<a name="437"/>            rs := RamStream(),
<a name="438"/>            {
<a name="439"/>               rs.out("&lt;html&gt;&lt;title&gt;Directory " || f || "&lt;/title&gt;&lt;table&gt;")
<a name="440"/>               path := FilePath(f)
<a name="441"/>               every e := !l do {
<a name="442"/>                  t := e.lstat
<a name="443"/>                  tf := if now - t.mtime &gt; 180 * 86400 then
<a name="444"/>                     Time(t.mtime + Time.SYSTEM_BASE_OFFSET).format("NNN'&amp;nbsp;'dd'&amp;nbsp;&amp;nbsp;'yyyy")
<a name="445"/>                  else
<a name="446"/>                     Time(t.mtime + Time.SYSTEM_BASE_OFFSET).format("NNN'&amp;nbsp;'dd'&amp;nbsp;'HH:mm")
<a name="447"/>                  g := path.child(e.name).canonical().to_url()
<a name="448"/>                  rs.out("&lt;tr&gt;&lt;td&gt;" || t.mode_str || "&amp;nbsp;&lt;/td&gt;&lt;td&gt;" || ucache(t.uid) || "&amp;nbsp;&lt;/td&gt;&lt;td&gt;" || gcache(t.gid) ||
<a name="449"/>                         "&amp;nbsp;&lt;/td&gt;&lt;td align=right&gt;" || Format.numeric_to_string(t.size, 0, ',') || "&amp;nbsp;&lt;/td&gt;&lt;td&gt;" || string(tf) || "&amp;nbsp;&lt;/td&gt;" ||
<a name="450"/>                         "&lt;td nowrap&gt;&lt;a href=\"" || Browser.to_attr(g) || "\"&gt;" || 
<a name="451"/>                                 Browser.to_content(e.name) || "&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;\n")
<a name="452"/>               }
<a name="453"/>               rs.out("&lt;/table&gt;&lt;/html&gt;")
<a name="454"/>               rs.str()
<a name="455"/>            }
<a name="456"/>         }
<a name="457"/>      } else {
<a name="458"/>$if _MS_WIN32
<a name="459"/>         # Can't poll a file under win32.
<a name="460"/>         return Files.file_to_string(f)
<a name="461"/>$else
<a name="462"/>         return use {
<a name="463"/>            ts := TaskStream(FileStream(f), worker.task),
<a name="464"/>            read_all(ts)
<a name="465"/>         }
<a name="466"/>$endif
<a name="467"/>      }
<a name="468"/>   end
<a name="469"/>
<a name="470"/>   private read_all(ts)
<a name="471"/>      return use {
<a name="472"/>         data := RamStream(),
<a name="473"/>         ts.copy_to(data) &amp; data.str()
<a name="474"/>      }
<a name="475"/>   end
<a name="476"/>end
<a name="477"/>
<a name="478"/>class HttpSubWorker(SubWorker)
<a name="479"/>   private 
<a name="480"/>      httpc, tmp_file
<a name="481"/>
<a name="482"/>   public override cancel()
<a name="483"/>      httpc.abort()
<a name="484"/>      # Call this now in case the worker's Task is never resumed (eg
<a name="485"/>      # if the application is closing).  Otherwise, it will be called
<a name="486"/>      # again from get_data() after the file is closed (at which point
<a name="487"/>      # Win32 will allow its removal).
<a name="488"/>      rm_tmp()
<a name="489"/>   end
<a name="490"/>
<a name="491"/>   private rm_tmp()
<a name="492"/>      if \tmp_file then {
<a name="493"/>         # Win32 doesn't allow an open file to be removed, but it can
<a name="494"/>         # be truncated (better to leave an empty temp file behind).
<a name="495"/>$if _MS_WIN32
<a name="496"/>         save_why{Files.truncate(tmp_file, 0)}
<a name="497"/>$endif
<a name="498"/>         if save_why{Files.remove(tmp_file)} then
<a name="499"/>            tmp_file := &amp;null
<a name="500"/>      }
<a name="501"/>   end
<a name="502"/>
<a name="503"/>   public override get_length()
<a name="504"/>      return httpc.get_length()
<a name="505"/>   end
<a name="506"/>
<a name="507"/>   public override get_read()
<a name="508"/>      return httpc.get_read()
<a name="509"/>   end
<a name="510"/>
<a name="511"/>   private static get_control(hres)
<a name="512"/>      local s, t, now, exp, lm, etag, ma
<a name="513"/>      now := Time.get_system_seconds()
<a name="514"/>      if t := HttpClient.parse_generic_header(hres.get_first_header("Cache-Control")) then {
<a name="515"/>         ma := integer(t.member("max-age"))
<a name="516"/>         lm := hres.get_first_header("Last-modified")
<a name="517"/>         etag := hres.get_first_header("Etag")
<a name="518"/>         exp := now + \ma
<a name="519"/>         if /exp &amp;
<a name="520"/>            s := hres.get_first_header("Expires") then {
<a name="521"/>               exp := Time.parse(s, "E, d MMM yyyy HH':'mm':'ss z").get_unix_seconds() | fail
<a name="522"/>            }
<a name="523"/>         if \ (lm | etag) then
<a name="524"/>            return CacheControl(exp, lm, etag)
<a name="525"/>         if t.member("no-cache") then
<a name="526"/>            fail
<a name="527"/>         if \ma then
<a name="528"/>            return CacheControl(now + (0 &lt; ma))
<a name="529"/>      }
<a name="530"/>      if s := hres.get_first_header("Expires") then {
<a name="531"/>         exp := Time.parse(s, "E, d MMM yyyy HH':'mm':'ss z").get_unix_seconds() | fail
<a name="532"/>         return CacheControl(now &lt; exp)
<a name="533"/>      }
<a name="534"/>      return CacheControl()
<a name="535"/>   end
<a name="536"/>
<a name="537"/>   private static get_expiry(hres)
<a name="538"/>      return \get_control(hres).expiry
<a name="539"/>   end
<a name="540"/>
<a name="541"/>   # Copy the fragment part of url1 to url2, unless url2 has its own fragment.
<a name="542"/>   # See s4.1 at http://www.w3.org/TR/cuap#uri
<a name="543"/>   #
<a name="544"/>   private static adjust_fragment(url1, url2)
<a name="545"/>      local f
<a name="546"/>      if f := url1.get_fragment() &amp;
<a name="547"/>         not url2.get_fragment() then
<a name="548"/>         url2 := clone(url2).set_fragment(f)
<a name="549"/>      return url2
<a name="550"/>   end
<a name="551"/>
<a name="552"/>   private static update_aliases(pool, hres, url)
<a name="553"/>      local exp
<a name="554"/>      repeat {
<a name="555"/>         case hres.get_status_code() of {
<a name="556"/>            # Moved permanently, so cache permanently
<a name="557"/>            301: pool.cache.add_alias(hres.url,, url)
<a name="558"/>            # Redirect, cache only if we had an expiry
<a name="559"/>            302: if exp := get_expiry(hres) then 
<a name="560"/>               pool.cache.add_alias(hres.url, exp, url)
<a name="561"/>         }
<a name="562"/>         hres := hres.get_previous_response() | break
<a name="563"/>      }
<a name="564"/>   end
<a name="565"/>
<a name="566"/>   private static update_cache_with_entry(pool, hres, ce)
<a name="567"/>      local exp
<a name="568"/>      if hres.get_status_code() = 304 then {
<a name="569"/>         if exp := get_expiry(hres) then
<a name="570"/>            ce.set_expiry(exp)
<a name="571"/>         update_aliases(pool, hres.get_previous_response(), ce.url)
<a name="572"/>      } else
<a name="573"/>         update_aliases(pool, hres, ce.url)
<a name="574"/>   end
<a name="575"/>
<a name="576"/>   private static update_cache_with_data(pool, hres, data, fname, ct, cd)
<a name="577"/>      local ctrl
<a name="578"/>      ctrl := get_control(hres) | fail
<a name="579"/>      pool.cache.add_data(hres.url, ctrl.expiry, data, fname, ct, cd, ctrl.last_modified, ctrl.etag)
<a name="580"/>      update_aliases(pool, hres.get_previous_response(), hres.url)
<a name="581"/>   end
<a name="582"/>
<a name="583"/>   public override get_data(worker)
<a name="584"/>      local req, s, data, hreq, hres, fname, ct, cd, ce, sc, req_url_no_frag, helper, resp
<a name="585"/>      httpc := worker.httpc
<a name="586"/>      req := worker.req
<a name="587"/>      # The request URL without the fragment
<a name="588"/>      req_url_no_frag := clone(req.url).set_fragment()
<a name="589"/>
<a name="590"/>      if req.kind ~=== Worker.REFRESH &amp; /req.form_data then
<a name="591"/>         ce := worker.pool.cache.get(req_url_no_frag)
<a name="592"/>
<a name="593"/>      return if (\ce).hasnt_expired() then {
<a name="594"/>         Resp(req,, adjust_fragment(req.url, ce.url), ce.data, ce.fname, ce.content_type, ce.content_disposition)
<a name="595"/>      } else {
<a name="596"/>         helper := HttpRequestHelperImpl(worker, ce)
<a name="597"/>         hreq := HttpRequest().
<a name="598"/>            set_helper(helper).
<a name="599"/>            set_header("accept-charset", "UTF-8, ISO-8859-1")
<a name="600"/>         if (\req.referer).scheme == ("http" | "https") then
<a name="601"/>            hreq.set_referer(req.referer)
<a name="602"/>
<a name="603"/>         if req.kind === Worker.DOWNLOAD then {
<a name="604"/>            if tmp_file := Files.make_temp_filename("http_oibrowser.", ".bin") then {
<a name="605"/>               resp := use {
<a name="606"/>                  s := BufferStream(FileStream(tmp_file,
<a name="607"/>                                               ior(FileOpt.WRONLY, FileOpt.TRUNC, FileOpt.CREAT))).
<a name="608"/>                     set_buff_size(8192),
<a name="609"/>                  {
<a name="610"/>                     hreq.set_output_stream(s)
<a name="611"/>                     if /ce then 
<a name="612"/>                        hreq.set_url(req_url_no_frag)
<a name="613"/>                     else {
<a name="614"/>                        hreq.set_url(ce.url)
<a name="615"/>                        # At least one of these should succeed
<a name="616"/>                        hreq.set_header("if-modified-since", \ce.last_modified)
<a name="617"/>                        hreq.set_header("if-none-match", \ce.etag)
<a name="618"/>                     }
<a name="619"/>                     if hres := httpc.retrieve(hreq) then {
<a name="620"/>                        fname := hres.get_filename()
<a name="621"/>                        ct := ContentType.parse_rfc2616(hres.get_first_header("Content-Type"))
<a name="622"/>                        cd := ContentDisposition.parse_rfc2616(hres.get_first_header("Content-Disposition"))
<a name="623"/>                        Resp(req,, adjust_fragment(req.url, hres.url),, fname, ct, cd, tmp_file)
<a name="624"/>                     } else {
<a name="625"/>                        if httpc.get_http_error() &amp; 
<a name="626"/>                           hres := httpc.get_response() &amp;
<a name="627"/>                           sc := hres.get_status_code() &amp;
<a name="628"/>                           ce := helper.get_cache_entry() &amp;
<a name="629"/>                           sc = (304 | 999) then 
<a name="630"/>                        {
<a name="631"/>                           # Redirect or 304 not modified with a cache entry, so return
<a name="632"/>                           # the cached data.
<a name="633"/>                           update_cache_with_entry(worker.pool, hres, ce)
<a name="634"/>                           Resp(req,, adjust_fragment(req.url, ce.url), ce.data, ce.fname, ce.content_type, ce.content_disposition)
<a name="635"/>                        } else
<a name="636"/>                           Resp(req, &amp;why, req.url)
<a name="637"/>                     }
<a name="638"/>                  }
<a name="639"/>               } | Resp(req, "Problem with temporary download file: " || &amp;why, req.url)
<a name="640"/>               if \resp.err then
<a name="641"/>                  rm_tmp()
<a name="642"/>               tmp_file := &amp;null
<a name="643"/>               resp
<a name="644"/>            } else
<a name="645"/>               Resp(req, "Couldn't create temporary download file: " || &amp;why, req.url)
<a name="646"/>         } else use {
<a name="647"/>            s := RamStream(),
<a name="648"/>            {
<a name="649"/>               hreq.set_output_stream(s)
<a name="650"/>               if /ce then 
<a name="651"/>                  hreq.set_url(req_url_no_frag)
<a name="652"/>               else {
<a name="653"/>                  hreq.set_url(ce.url)
<a name="654"/>                  # At least one of these should succeed
<a name="655"/>                  hreq.set_header("if-modified-since", \ce.last_modified)
<a name="656"/>                  hreq.set_header("if-none-match", \ce.etag)
<a name="657"/>               }
<a name="658"/>               if \req.form_data then {
<a name="659"/>                  if is(req.form_data, Message) then
<a name="660"/>                     hreq.set_multipart_form_data(req.form_data)
<a name="661"/>                  else
<a name="662"/>                     hreq.set_html_form_data(req.form_data)
<a name="663"/>               }
<a name="664"/>
<a name="665"/>               if hres := httpc.retrieve(hreq) then {
<a name="666"/>                  data := s.str()
<a name="667"/>                  fname := hres.get_filename()
<a name="668"/>                  ct := ContentType.parse_rfc2616(hres.get_first_header("Content-Type"))
<a name="669"/>                  cd := ContentDisposition.parse_rfc2616(hres.get_first_header("Content-Disposition"))
<a name="670"/>                  # Check whether to cache any data, including redirections.  POST requests are never cached.
<a name="671"/>                  if hreq.method == "GET" then
<a name="672"/>                     update_cache_with_data(worker.pool, hres, data, fname, ct, cd)
<a name="673"/>                  Resp(req,, adjust_fragment(req.url, hres.url), data, fname, ct, cd)
<a name="674"/>               } else {
<a name="675"/>                  if httpc.get_http_error() &amp; 
<a name="676"/>                     hres := httpc.get_response() &amp;
<a name="677"/>                     sc := hres.get_status_code() then 
<a name="678"/>                  {
<a name="679"/>                     if ce := helper.get_cache_entry() &amp; 
<a name="680"/>                        sc = (304 | 999) then 
<a name="681"/>                     {
<a name="682"/>                        # Redirect or 304 not modified with a cache entry, so return
<a name="683"/>                        # the cached data.
<a name="684"/>                        update_cache_with_entry(worker.pool, hres, ce)
<a name="685"/>                        Resp(req,, adjust_fragment(req.url, ce.url), ce.data, ce.fname, ce.content_type, ce.content_disposition)
<a name="686"/>                     } else if (sc = 300) | (400 &lt;= sc &lt;= 599) &amp;
<a name="687"/>                        data := s.str() &amp;
<a name="688"/>                        *data &gt; 0 then
<a name="689"/>                     {
<a name="690"/>                        # Include http content together with the error
<a name="691"/>                        # message, so it can be displayed
<a name="692"/>                        fname := hres.get_filename()
<a name="693"/>                        ct := ContentType.parse_rfc2616(hres.get_first_header("Content-Type"))
<a name="694"/>                        cd := ContentDisposition.parse_rfc2616(hres.get_first_header("Content-Disposition"))
<a name="695"/>                        Resp(req, &amp;why, adjust_fragment(req.url, hres.url), data, fname, ct, cd)
<a name="696"/>                     } else
<a name="697"/>                        Resp(req, &amp;why, req.url)
<a name="698"/>                  } else
<a name="699"/>                     Resp(req, &amp;why, req.url)
<a name="700"/>               }
<a name="701"/>            }
<a name="702"/>         }
<a name="703"/>      }
<a name="704"/>   end
<a name="705"/>end
<a name="706"/>
<a name="707"/>class Worker()
<a name="708"/>   public const
<a name="709"/>      pool,
<a name="710"/>      task
<a name="711"/>   private readable
<a name="712"/>      httpc,
<a name="713"/>      cancelled,
<a name="714"/>      req,
<a name="715"/>      sub_worker
<a name="716"/>
<a name="717"/>   public static const NORMAL, NAVIGATE, REFRESH, DOWNLOAD
<a name="718"/>
<a name="719"/>   private static init()
<a name="720"/>      NORMAL := "normal"
<a name="721"/>      NAVIGATE := "navigate"
<a name="722"/>      REFRESH := "refresh"
<a name="723"/>      DOWNLOAD := "download"
<a name="724"/>   end
<a name="725"/>
<a name="726"/>   public initially()
<a name="727"/>      task.start()
<a name="728"/>   end
<a name="729"/>
<a name="730"/>   public finally()
<a name="731"/>      if \req then
<a name="732"/>         cancel()
<a name="733"/>      else {
<a name="734"/>         # httpc may be null, since we may have started but never been run
<a name="735"/>         (\httpc).close()
<a name="736"/>         task.stop()
<a name="737"/>      }
<a name="738"/>   end
<a name="739"/>
<a name="740"/>   public cancel()
<a name="741"/>      if \req &amp; /cancelled then {
<a name="742"/>         cancelled := &amp;yes
<a name="743"/>         task.interrupt()
<a name="744"/>         (\sub_worker).cancel()
<a name="745"/>      }
<a name="746"/>   end
<a name="747"/>
<a name="748"/>   public read()
<a name="749"/>      return (\sub_worker).get_read()
<a name="750"/>   end
<a name="751"/>
<a name="752"/>   public length()
<a name="753"/>      return (\sub_worker).get_length()
<a name="754"/>   end
<a name="755"/>
<a name="756"/>   private dwrite(a[])
<a name="757"/>      a := [ "[", serial(self), "] " ] ||| a
<a name="758"/>      pool.log_file.write!a
<a name="759"/>   end
<a name="760"/>
<a name="761"/>   private writing_line(ev)
<a name="762"/>      dwrite("Sent: ", ev)
<a name="763"/>   end
<a name="764"/>
<a name="765"/>   private read_line(ev)
<a name="766"/>      dwrite("Got : ", ev)
<a name="767"/>   end
<a name="768"/>
<a name="769"/>   private read_string(ev)
<a name="770"/>      dwrite("Got : data - 0x", Format.int_to_string(*ev, 16), " bytes")
<a name="771"/>   end
<a name="772"/>
<a name="773"/>   private writing_string(ev)
<a name="774"/>      dwrite("Sent: data - 0x", Format.int_to_string(*ev, 16), " bytes")
<a name="775"/>   end
<a name="776"/>
<a name="777"/>   private connecting(ev, src)
<a name="778"/>      dwrite("Connecting to ", URL.bracket_host(src.server), ":", src.port)
<a name="779"/>   end
<a name="780"/>
<a name="781"/>   private connected(ev)
<a name="782"/>      dwrite("Connected to ", ev)
<a name="783"/>   end
<a name="784"/>
<a name="785"/>   private failed(ev)
<a name="786"/>      dwrite("Failed: ", &amp;why)
<a name="787"/>   end
<a name="788"/>
<a name="789"/>   private retrying(ev)
<a name="790"/>      dwrite("Retrying: ", &amp;why)
<a name="791"/>   end
<a name="792"/>
<a name="793"/>   private http_error(ev)
<a name="794"/>      dwrite("HTTP Error: ", &amp;why)
<a name="795"/>   end
<a name="796"/>
<a name="797"/>   private other(ev, src, type)
<a name="798"/>      dwrite(type)
<a name="799"/>   end
<a name="800"/>
<a name="801"/>   private status(ev, src, type)
<a name="802"/>      (\(\req).on_status)(ev, src, type)
<a name="803"/>   end
<a name="804"/>
<a name="805"/>   private setup_httpc()
<a name="806"/>      httpc := HttpClient().
<a name="807"/>         set_task(task).
<a name="808"/>         set_cookies(pool.cookies).
<a name="809"/>         set_authentications(pool.authentications).
<a name="810"/>         set_retry_while_data(&amp;yes)
<a name="811"/>
<a name="812"/>      every httpc.connect(status, 
<a name="813"/>                          NetClient.CONNECTING_EVENT |
<a name="814"/>                          NetClient.CONNECTED_EVENT |
<a name="815"/>                          NetClient.CLOSED_EVENT |
<a name="816"/>                          HttpClient.BEGIN_EVENT |
<a name="817"/>                          HttpClient.COMPLETE_EVENT |
<a name="818"/>                          HttpClient.FAILED_EVENT |
<a name="819"/>                          HttpClient.HTTP_ERROR_EVENT |
<a name="820"/>                          HttpClient.HTTP_SUCCESS_EVENT |
<a name="821"/>                          HttpClient.ABORTED_EVENT |
<a name="822"/>                          HttpClient.RETRYING_EVENT) 
<a name="823"/>
<a name="824"/>      if \pool.log_file then {
<a name="825"/>         httpc.connect(failed, HttpClient.FAILED_EVENT).
<a name="826"/>            connect(http_error, HttpClient.HTTP_ERROR_EVENT).
<a name="827"/>            connect(other, HttpClient.HTTP_SUCCESS_EVENT).
<a name="828"/>            connect(other, HttpClient.BEGIN_EVENT).
<a name="829"/>            connect(other, HttpClient.ABORTED_EVENT).
<a name="830"/>            connect(retrying, HttpClient.RETRYING_EVENT).
<a name="831"/>            connect(read_line, NetClient.READ_LINE_EVENT).
<a name="832"/>            connect(read_string, NetClient.READ_STRING_EVENT).
<a name="833"/>            connect(writing_line, NetClient.WRITING_LINE_EVENT).
<a name="834"/>            connect(writing_string, NetClient.WRITING_STRING_EVENT).
<a name="835"/>            connect(connecting, NetClient.CONNECTING_EVENT).
<a name="836"/>            connect(connected, NetClient.CONNECTED_EVENT).
<a name="837"/>            connect(other, NetClient.CLOSED_EVENT).
<a name="838"/>            connect(other, HttpClient.COMPLETE_EVENT)
<a name="839"/>      }
<a name="840"/>
<a name="841"/>      pool.owner.configure_http_client(httpc)
<a name="842"/>   end
<a name="843"/>
<a name="844"/>   private handle_launch_req()
<a name="845"/>      local pid, f
<a name="846"/>      if (\req.referer).scheme == ("http" | "https") then
<a name="847"/>         return error("Can't launch a prog from an http page")
<a name="848"/>      f := req.url.get_decoded_path()
<a name="849"/>      pid := System.fork() | fail
<a name="850"/>      if pid &gt; 0 then {
<a name="851"/>         ChildWait.add_pid(pid)
<a name="852"/>         return
<a name="853"/>      }
<a name="854"/>      Files.chdir(Files.get_home())
<a name="855"/>      System.setpgid()
<a name="856"/>      null_stdio()
<a name="857"/>      Files.bulk_close(100)
<a name="858"/>      System.exec("/bin/sh", ["-c", "exec " || f]) | stop(&amp;why)
<a name="859"/>      syserr("Not reached")
<a name="860"/>   end
<a name="861"/>
<a name="862"/>   private handle_cache_req()
<a name="863"/>      return pool.cache.get(req.url) | error("Cache entry expired")
<a name="864"/>   end
<a name="865"/>
<a name="866"/>   private handle_func(f)
<a name="867"/>      local x, s
<a name="868"/>      if x := f(self) then {
<a name="869"/>         if /cancelled then {
<a name="870"/>            if is(x, SubWorker) then {
<a name="871"/>               sub_worker := x
<a name="872"/>               handle_func(x.get_data)
<a name="873"/>            } else if is(x, Resp) then
<a name="874"/>               req.callback(x)
<a name="875"/>            else if is(x, StaticData) then
<a name="876"/>               req.callback(Resp(req,, req.url, x.data, x.fname, x.content_type, x.content_disposition))
<a name="877"/>            else if s := string(x) then
<a name="878"/>               req.callback(Resp(req,, req.url, s, req.url.get_decoded_path_last()))
<a name="879"/>            else if \x then
<a name="880"/>               runerr(103, x)
<a name="881"/>         }
<a name="882"/>      } else {
<a name="883"/>         if /cancelled then
<a name="884"/>            req.callback(Resp(req, &amp;why, req.url))
<a name="885"/>      }
<a name="886"/>   end
<a name="887"/>
<a name="888"/>   private handle_data_req()
<a name="889"/>      local du
<a name="890"/>      return if du := DataURL(req.url) then
<a name="891"/>         Resp(req,, req.url, du.data,, du.content_type)
<a name="892"/>      else
<a name="893"/>         Resp(req, &amp;why, req.url)
<a name="894"/>   end
<a name="895"/>
<a name="896"/>   private handle_req()
<a name="897"/>      local f, t
<a name="898"/>      t := string(req.url.scheme)
<a name="899"/>      case t of {
<a name="900"/>         "file": handle_func(FileSubWorker)
<a name="901"/>         "data": handle_func(handle_data_req)
<a name="902"/>         "prog": handle_func(ProgSubWorker)
<a name="903"/>         "launch": handle_func(handle_launch_req)
<a name="904"/>         "cache": handle_func(handle_cache_req)
<a name="905"/>         "http"|"https": handle_func(HttpSubWorker)
<a name="906"/>         default: {
<a name="907"/>            if f := member(pool.scheme_handlers, t) then
<a name="908"/>               handle_func(f)
<a name="909"/>            else
<a name="910"/>               req.callback(Resp(req, "Unknown url scheme", req.url))
<a name="911"/>         }
<a name="912"/>      }
<a name="913"/>   end
<a name="914"/>
<a name="915"/>   private run()
<a name="916"/>      setup_httpc()
<a name="917"/>      repeat {
<a name="918"/>         while /pool.active do {
<a name="919"/>            # finally() has been called; close resources and revert
<a name="920"/>            httpc.close()
<a name="921"/>            task.revert()
<a name="922"/>         }
<a name="923"/>         until req := pool.queue_get() do
<a name="924"/>            task.sleep()
<a name="925"/>         insert(pool.req_worker, req, self)
<a name="926"/>         cancelled := &amp;null
<a name="927"/>         handle_req()
<a name="928"/>         delete(pool.req_worker, req)
<a name="929"/>         sub_worker := req := &amp;null
<a name="930"/>      }
<a name="931"/>   end
<a name="932"/>
<a name="933"/>   public new(pool)
<a name="934"/>      self.pool := pool
<a name="935"/>      task := Dispatcher.new_task{run()}
<a name="936"/>      return
<a name="937"/>   end
<a name="938"/>end
<a name="939"/>
<a name="940"/>#
<a name="941"/># This class contains additional methods implemented by the owner of a
<a name="942"/># `WorkerPool`.
<a name="943"/>#
<a name="944"/>abstract class WorkerPoolOwner()
<a name="945"/>   #
<a name="946"/>   # Called by a `Worker` when its `HttpClient` needs
<a name="947"/>   # authentication; see also `HttpRequestHelper.get_authentication`
<a name="948"/>   #
<a name="949"/>   public abstract get_authentication(httpc, dom, realm)
<a name="950"/>
<a name="951"/>   # Called by a `Worker` to allow custom configuration of its
<a name="952"/>   # `HttpClient`.  By default this method is empty, meaning accept
<a name="953"/>   # the default setup done by the worker.
<a name="954"/>   #
<a name="955"/>   public configure_http_client(httpc)
<a name="956"/>   end
<a name="957"/>end
<a name="958"/>
<a name="959"/>#
<a name="960"/># A pool of `Worker`s.
<a name="961"/>#
<a name="962"/>class WorkerPool()
<a name="963"/>   private const
<a name="964"/>      queue,
<a name="965"/>      workers
<a name="966"/>   package
<a name="967"/>      req_worker         # table mapping Req to Worker
<a name="968"/>   public const
<a name="969"/>      owner
<a name="970"/>   private readable
<a name="971"/>      active,
<a name="972"/>      log_file,
<a name="973"/>      cookies,
<a name="974"/>      cache,
<a name="975"/>      authentications,
<a name="976"/>      scheme_handlers
<a name="977"/>
<a name="978"/>   public set_log_file(f)
<a name="979"/>      self.log_file := f
<a name="980"/>      link
<a name="981"/>   end
<a name="982"/>
<a name="983"/>   public initially()
<a name="984"/>      active := &amp;yes
<a name="985"/>      every (!workers).initially()
<a name="986"/>   end
<a name="987"/>
<a name="988"/>   public finally()
<a name="989"/>      active := &amp;null
<a name="990"/>      every (!workers).finally()
<a name="991"/>      clear(queue)
<a name="992"/>   end
<a name="993"/>
<a name="994"/>   # Cancel all requests for a given client
<a name="995"/>   public cancel_all(client)
<a name="996"/>      local w
<a name="997"/>      delete(queue, client)
<a name="998"/>      every w := !workers do 
<a name="999"/>         if (\w.req).client === client then
<a name="1000"/>            w.cancel()
<a name="1001"/>      link
<a name="1002"/>   end
<a name="1003"/>
<a name="1004"/>   # Cancel an individual request
<a name="1005"/>   public cancel_req(req)
<a name="1006"/>      local l, i
<a name="1007"/>      if l := member(queue, req.client) then {
<a name="1008"/>         if i := keyof(l, req) then {
<a name="1009"/>            delete(l, i)
<a name="1010"/>            if *l = 0 then
<a name="1011"/>               delete(queue, req.client)
<a name="1012"/>            link
<a name="1013"/>         }
<a name="1014"/>      }
<a name="1015"/>      # Not found in queue, so look in the workers.
<a name="1016"/>      get_worker(req).cancel()
<a name="1017"/>      link
<a name="1018"/>   end
<a name="1019"/>
<a name="1020"/>   public get_worker(req)
<a name="1021"/>      return member(req_worker, req)
<a name="1022"/>   end
<a name="1023"/>
<a name="1024"/>   public enqueue(req)
<a name="1025"/>      local w, l
<a name="1026"/>      if l := member(queue, req.client) then
<a name="1027"/>         put(l, req)
<a name="1028"/>      else
<a name="1029"/>         insert(queue, req.client, [req])
<a name="1030"/>      # Wake up a sleeping task if possible.  Take care not to notify
<a name="1031"/>      # a sleeping task that is processing a request, or one which we
<a name="1032"/>      # have already started, but has yet to be run (and hence its
<a name="1033"/>      # request field is still null, and its state ready).
<a name="1034"/>      every w := !workers do
<a name="1035"/>         if /w.req &amp; w.task.is_sleeping() then {
<a name="1036"/>            w.task.notify()
<a name="1037"/>            break
<a name="1038"/>         }
<a name="1039"/>      link
<a name="1040"/>   end
<a name="1041"/>
<a name="1042"/>   public queue_size()
<a name="1043"/>      return Sum{ *!queue }
<a name="1044"/>   end
<a name="1045"/>
<a name="1046"/>   package queue_get()
<a name="1047"/>      local l, r
<a name="1048"/>      l := ?queue | fail
<a name="1049"/>      r := get(l) | syserr("Empty list in queue table")
<a name="1050"/>      if *l = 0 then
<a name="1051"/>         delete(queue, r.client)
<a name="1052"/>      return r
<a name="1053"/>   end
<a name="1054"/>
<a name="1055"/>   public count(client)
<a name="1056"/>      local i, w
<a name="1057"/>      i := *member(queue, client) | 0
<a name="1058"/>      every w := !workers do 
<a name="1059"/>         if (\w.req).client === client then
<a name="1060"/>            i +:= 1
<a name="1061"/>      return i
<a name="1062"/>   end
<a name="1063"/>
<a name="1064"/>   # Return the amount read by this client's current requests.
<a name="1065"/>   #
<a name="1066"/>   public read(client)
<a name="1067"/>      local i, w
<a name="1068"/>      i := 0
<a name="1069"/>      every w := !workers do
<a name="1070"/>         if (\w.req).client === client then
<a name="1071"/>            i +:= w.read()
<a name="1072"/>      return i
<a name="1073"/>   end
<a name="1074"/>
<a name="1075"/>   # Return a length giving the remaining data to be downloaded for
<a name="1076"/>   # this client; fails if that is unknown.
<a name="1077"/>   #
<a name="1078"/>   public length(client)
<a name="1079"/>      local i, w
<a name="1080"/>      if member(queue, client) then
<a name="1081"/>         fail
<a name="1082"/>      i := 0
<a name="1083"/>      every w := !workers do
<a name="1084"/>         if (\w.req).client === client then
<a name="1085"/>            i +:= w.length() | fail
<a name="1086"/>      return i
<a name="1087"/>   end
<a name="1088"/>
<a name="1089"/>   public set_cookies(cookies)
<a name="1090"/>      self.cookies := cookies
<a name="1091"/>      link
<a name="1092"/>   end
<a name="1093"/>
<a name="1094"/>   public set_authentications(m)
<a name="1095"/>      self.authentications := m
<a name="1096"/>      link
<a name="1097"/>   end
<a name="1098"/>
<a name="1099"/>   public set_cache(c)
<a name="1100"/>      self.cache := c
<a name="1101"/>      link
<a name="1102"/>   end
<a name="1103"/>
<a name="1104"/>   public set_scheme_handlers(m)
<a name="1105"/>      self.scheme_handlers := m
<a name="1106"/>      link
<a name="1107"/>   end
<a name="1108"/>
<a name="1109"/>   public add_scheme_handler(scheme, func)
<a name="1110"/>      insert(scheme_handlers, need_string(scheme), func)
<a name="1111"/>      link
<a name="1112"/>   end
<a name="1113"/>
<a name="1114"/>   public get_status()
<a name="1115"/>      local s, w, st, t, r
<a name="1116"/>      s := "&lt;html&gt;&lt;title&gt;Worker pool status&lt;/title&gt;"
<a name="1117"/>
<a name="1118"/>      s ||:= "&lt;h1&gt;Workers&lt;/h1&gt;&lt;table&gt;&lt;tr&gt;&lt;th align=left&gt;Serial&lt;/th&gt;&lt;th align=left&gt;Status&lt;/th&gt;_
<a name="1119"/>              &lt;th align=left&gt;Client&lt;/th&gt;&lt;th align=left&gt;Kind&lt;/th&gt;&lt;th align=left&gt;URL&lt;/th&gt;&lt;/tr&gt;"
<a name="1120"/>      every w := !workers do {
<a name="1121"/>         t := w.task
<a name="1122"/>         st := if t.is_current() then "current"
<a name="1123"/>         else if t.is_sleeping() then "sleeping"
<a name="1124"/>         else if t.is_polling() then "polling"
<a name="1125"/>         else if t.is_ready() then "ready"
<a name="1126"/>         else if t.is_active() then "active"
<a name="1127"/>         else if t.is_dormant() then "dormant"
<a name="1128"/>         else "unknown"
<a name="1129"/>         s ||:= "&lt;tr&gt;&lt;td&gt;" || serial(w) || "&lt;/td&gt;&lt;td&gt;" || st || "&lt;/td&gt;"
<a name="1130"/>         if r := \w.req then
<a name="1131"/>            s ||:= "&lt;td&gt;" || Class.get_name(r.client) || "#" || serial(r.client) || "&lt;/td&gt;&lt;td&gt;" ||
<a name="1132"/>                    r.kind || "&lt;/td&gt;" || Browser.mk_anchor_cell(r.url) || "&lt;/tr&gt;"
<a name="1133"/>         s ||:= "&lt;/tr&gt;"          
<a name="1134"/>      }
<a name="1135"/>      s ||:= "&lt;/table&gt;"
<a name="1136"/>
<a name="1137"/>      if *queue &gt; 0 then {
<a name="1138"/>         s ||:= "&lt;h1&gt;Queue&lt;/h1&gt;&lt;table&gt;&lt;tr&gt;&lt;th align=left&gt;Client&lt;/th&gt;&lt;th align=left&gt;Kind&lt;/th&gt;&lt;th align=left&gt;URL&lt;/th&gt;&lt;/tr&gt;"
<a name="1139"/>         every r := !!queue do {
<a name="1140"/>            s ||:= "&lt;tr&gt;&lt;td&gt;" || Class.get_name(r.client) || "#" || serial(r.client) || "&lt;/td&gt;&lt;td&gt;" ||
<a name="1141"/>                    r.kind || "&lt;/td&gt;" || Browser.mk_anchor_cell(r.url) || "&lt;/tr&gt;"
<a name="1142"/>         }
<a name="1143"/>         s ||:= "&lt;/table&gt;"
<a name="1144"/>      }
<a name="1145"/>
<a name="1146"/>      s ||:= "&lt;/html&gt;"
<a name="1147"/>      return s
<a name="1148"/>   end
<a name="1149"/>
<a name="1150"/>   public new(owner, n)
<a name="1151"/>      /n := 6
<a name="1152"/>      self.owner := owner
<a name="1153"/>      queue := table()
<a name="1154"/>      cookies := table()
<a name="1155"/>      cache := Cache(8*1024*1024)
<a name="1156"/>      authentications := table()
<a name="1157"/>      scheme_handlers := table()
<a name="1158"/>      workers := []
<a name="1159"/>      every 1 to n do
<a name="1160"/>         put(workers, Worker(self))
<a name="1161"/>      req_worker := table()
<a name="1162"/>      return
<a name="1163"/>   end
<a name="1164"/>end
<a name="1165"/>
<a name="1166"/>class TblContent(Component)
<a name="1167"/>   private
<a name="1168"/>      hrules, vrules
<a name="1169"/>
<a name="1170"/>   public override whose_point(ex, ey)
<a name="1171"/>      local c
<a name="1172"/>      every c := layout_delegate.computed_g.cells_in_range(ey - y, 1).obj do {
<a name="1173"/>         if c.is_unhidden() &amp; c.inside(ex, ey) then
<a name="1174"/>            return c
<a name="1175"/>      }
<a name="1176"/>   end
<a name="1177"/>
<a name="1178"/>   public override display()
<a name="1179"/>      local ci, r, g, t
<a name="1180"/>      r := get_cbwin_clip()
<a name="1181"/>      g := layout_delegate.computed_g
<a name="1182"/>      every ci := g.cells_in_range(r.y - y, r.h) do {
<a name="1183"/>         display_child(ci.obj)
<a name="1184"/>         if \vrules | \hrules then {
<a name="1185"/>            t := Rect(x + g.a_col_x[ci.x],
<a name="1186"/>                      y + g.a_row_y[ci.y],
<a name="1187"/>                      Grid.slice(ci.x, ci.w, g.a_col_w),
<a name="1188"/>                      Grid.slice(ci.y, ci.h, g.a_row_h))
<a name="1189"/>            if r.intersect(t) then {
<a name="1190"/>               if member(\vrules, ci.x) then
<a name="1191"/>                  cbwin.fill_rectangle(t.x, t.y, Gui.FINE_WIDTH, t.h)
<a name="1192"/>               if member(\hrules, ci.y) then
<a name="1193"/>                  cbwin.fill_rectangle(t.x, t.y, t.w, Gui.FINE_WIDTH)
<a name="1194"/>            }
<a name="1195"/>         }
<a name="1196"/>      }
<a name="1197"/>   end
<a name="1198"/>
<a name="1199"/>   public set_hrules(r)
<a name="1200"/>      self.hrules := r
<a name="1201"/>      link
<a name="1202"/>   end
<a name="1203"/>
<a name="1204"/>   public set_vrules(r)
<a name="1205"/>      self.vrules := r
<a name="1206"/>      link
<a name="1207"/>   end
<a name="1208"/>end
<a name="1209"/>
<a name="1210"/>class Tbl(Border, HasMaxWidth)
<a name="1211"/>   public override get_max_width()
<a name="1212"/>      local w1
<a name="1213"/>      w1 := content.layout_delegate.get_max_width() + border.get_total_width()
<a name="1214"/>      return if \title then
<a name="1215"/>         max(w1, title.get_max_width() + 2 * TITLE_OFFSET)
<a name="1216"/>      else
<a name="1217"/>         w1
<a name="1218"/>   end
<a name="1219"/>
<a name="1220"/>   public override new()
<a name="1221"/>      Border.new()
<a name="1222"/>      set_content(TblContent(). 
<a name="1223"/>                    set_layout(TableLayout()))
<a name="1224"/>      set_border(NullBorder())
<a name="1225"/>      return
<a name="1226"/>   end
<a name="1227"/>end
<a name="1228"/>
<a name="1229"/>abstract class HasLastHighlight()
<a name="1230"/>   public abstract set_last_highlight(u)
<a name="1231"/>   package abstract save_last_highlight(he)
<a name="1232"/>   package abstract restore_last_highlight(n, url)
<a name="1233"/>end
<a name="1234"/>
<a name="1235"/>class ImgPlainBorder(LineBorder)
<a name="1236"/>   private
<a name="1237"/>      img
<a name="1238"/>
<a name="1239"/>   public override initially(c)
<a name="1240"/>      LineBorder.initially(c)
<a name="1241"/>      self.img := c
<a name="1242"/>   end
<a name="1243"/>
<a name="1244"/>   public override draw(W, x, y, w, h)
<a name="1245"/>      use {
<a name="1246"/>         W := W.clone(),
<a name="1247"/>         {
<a name="1248"/>            if \img.highlight then
<a name="1249"/>               W.set_fg(img.browser.page_alink_color)
<a name="1250"/>            W.draw_rectangle(x, y, w, h, line_width)
<a name="1251"/>            if \img.over then {
<a name="1252"/>               # Make the border colour consistent with foreground link text colour.
<a name="1253"/>               use {
<a name="1254"/>                  W := Gui.style.get_over_clone(W),
<a name="1255"/>                  W.draw_rectangle(x, y, w, h, line_width)
<a name="1256"/>               }
<a name="1257"/>            }
<a name="1258"/>         }
<a name="1259"/>      }
<a name="1260"/>   end
<a name="1261"/>end
<a name="1262"/>
<a name="1263"/>class Img(Image, HasLastHighlight)
<a name="1264"/>   public const
<a name="1265"/>      browser, context, form, img_url, alt, bg_area, map_id
<a name="1266"/>   private readable
<a name="1267"/>      over, img_data, img_name, map, held, err, highlight, last_highlight
<a name="1268"/>
<a name="1269"/>   package got_data(res)
<a name="1270"/>      local iw, ih
<a name="1271"/>      if \res.err then {
<a name="1272"/>         err := res.err
<a name="1273"/>         set_cache("rpp.BROKEN_LINK")
<a name="1274"/>         every remove_constraint("fix_w" | "fix_h" | "pct_w")
<a name="1275"/>      } else {
<a name="1276"/>         set_image(res.data)
<a name="1277"/>         if has_image() then {
<a name="1278"/>            # Set width and perhaps height based on constraints.
<a name="1279"/>            #
<a name="1280"/>            # If pct_w is set, then set a small minimal value, since
<a name="1281"/>            # otherwise the actual width of the image would be the
<a name="1282"/>            # preferred width, and hence the minimum size which
<a name="1283"/>            # TextFlow would allocate, whereas we want to allow the
<a name="1284"/>            # image to shrink below its actual width.
<a name="1285"/>            #
<a name="1286"/>            if iw := integer(member(constraints, "fix_w")) then
<a name="1287"/>               set_width(iw + border.get_total_width())
<a name="1288"/>            else if integer(member(constraints, "pct_w")) then
<a name="1289"/>               set_width(1 + border.get_total_width())
<a name="1290"/>            if ih := integer(member(constraints, "fix_h")) then {
<a name="1291"/>               if /w_spec then 
<a name="1292"/>                  set_width(ih * get_image_width() / get_image_height() + border.get_total_width())
<a name="1293"/>               else 
<a name="1294"/>                  set_height(ih + border.get_total_height())
<a name="1295"/>            }
<a name="1296"/>            img_name := res.fname
<a name="1297"/>            img_data := res.data
<a name="1298"/>         } else {
<a name="1299"/>            err := &amp;why
<a name="1300"/>            set_cache("rpp.BROKEN_LINK")
<a name="1301"/>            every remove_constraint("fix_w" | "fix_h" | "pct_w")
<a name="1302"/>         }
<a name="1303"/>      }
<a name="1304"/>      # If neither set (/w_spec should imply /h_spec), ensure a
<a name="1305"/>      # scaled image with the true ratio.
<a name="1306"/>      if /w_spec then
<a name="1307"/>         set_width(scale(get_image_width()) + border.get_total_width())
<a name="1308"/>      set_fill_dimensions(2)
<a name="1309"/>   end
<a name="1310"/>
<a name="1311"/>   private handle_rpress(e)
<a name="1312"/>      local pm, pm_menu
<a name="1313"/>      parent_dialog.get_held_count() = 1 | fail
<a name="1314"/>      if pm_menu := browser.create_image_menu(self) then {
<a name="1315"/>         set_highlight(over)
<a name="1316"/>         set_over()
<a name="1317"/>         pm := PopupMenu()
<a name="1318"/>         pm.connect(on_popup_closed, Event.POPUP_CLOSED)
<a name="1319"/>         pm.popup(self, pm_menu, e.x, e.y)
<a name="1320"/>      }
<a name="1321"/>   end
<a name="1322"/>
<a name="1323"/>   private on_popup_closed()
<a name="1324"/>      set_highlight()
<a name="1325"/>   end
<a name="1326"/>
<a name="1327"/>   private handle_lrelease(e, src)
<a name="1328"/>      \held | fail
<a name="1329"/>      if \over then {
<a name="1330"/>         set_highlight()
<a name="1331"/>         browser.link_left_clicked(over)
<a name="1332"/>      }
<a name="1333"/>      held := &amp;null
<a name="1334"/>   end
<a name="1335"/>
<a name="1336"/>   private handle_mrelease(e)
<a name="1337"/>      \held | fail
<a name="1338"/>      if \over then {
<a name="1339"/>         set_highlight()
<a name="1340"/>         browser.link_middle_clicked(over)
<a name="1341"/>      }
<a name="1342"/>      held := &amp;null
<a name="1343"/>   end
<a name="1344"/>
<a name="1345"/>   private handle_form_lrelease(e, src)
<a name="1346"/>      if in_region(e) then
<a name="1347"/>         form.submit(e, src)
<a name="1348"/>   end
<a name="1349"/>
<a name="1350"/>   private handle_exit(e)
<a name="1351"/>      parent_dialog.get_held_count() = 0 | fail
<a name="1352"/>      set_over()
<a name="1353"/>   end
<a name="1354"/>
<a name="1355"/>   private handle_interrupted(e)
<a name="1356"/>      set_highlight()
<a name="1357"/>      set_over()
<a name="1358"/>      held := &amp;null
<a name="1359"/>   end
<a name="1360"/>
<a name="1361"/>   package gen_areas()
<a name="1362"/>      # Non-null bg_area implies we have some areas (ie, links) (see constructor below).
<a name="1363"/>      if \bg_area then
<a name="1364"/>         suspend get_map().gen_areas() | bg_area
<a name="1365"/>   end
<a name="1366"/>
<a name="1367"/>   private get_map()
<a name="1368"/>      /map := browser.get_map(\map_id) | ipl.browser.Map()
<a name="1369"/>      return map
<a name="1370"/>   end
<a name="1371"/>
<a name="1372"/>   private which_area(e)
<a name="1373"/>      if \bg_area then {
<a name="1374"/>         in_region(e) | fail
<a name="1375"/>         return get_map().which_area(e.x - x - border.get_l_inset(), 
<a name="1376"/>                                     e.y - y - border.get_t_inset()) | bg_area
<a name="1377"/>      }
<a name="1378"/>   end
<a name="1379"/>
<a name="1380"/>   private handle_mpress(e)
<a name="1381"/>      parent_dialog.get_held_count() = 1 | fail
<a name="1382"/>      if \over then {
<a name="1383"/>         set_highlight(over)
<a name="1384"/>         held := over
<a name="1385"/>      }
<a name="1386"/>   end
<a name="1387"/>
<a name="1388"/>   private handle_lpress(e)
<a name="1389"/>      parent_dialog.get_held_count() = 1 | fail
<a name="1390"/>      if \over then {
<a name="1391"/>         if /e.shift then {
<a name="1392"/>            set_highlight(over)
<a name="1393"/>            held := over
<a name="1394"/>         } else
<a name="1395"/>            browser.set_last_highlight(self, over)
<a name="1396"/>      }
<a name="1397"/>   end
<a name="1398"/>
<a name="1399"/>   private set_over(u)
<a name="1400"/>      if u ~=== over then {
<a name="1401"/>         over := u
<a name="1402"/>         if visible_border() then
<a name="1403"/>            invalidate()
<a name="1404"/>         if /over then
<a name="1405"/>            browser.msg()
<a name="1406"/>         else
<a name="1407"/>            browser.msg(over.str())
<a name="1408"/>      }
<a name="1409"/>      link
<a name="1410"/>   end
<a name="1411"/>
<a name="1412"/>   public override set_last_highlight(u)
<a name="1413"/>      if u ~=== last_highlight then {
<a name="1414"/>         last_highlight := u
<a name="1415"/>         invalidate()
<a name="1416"/>      }
<a name="1417"/>      link
<a name="1418"/>   end
<a name="1419"/>
<a name="1420"/>   package override save_last_highlight(he)
<a name="1421"/>      local a, u, n
<a name="1422"/>      n := 0
<a name="1423"/>      every a := gen_areas() do {
<a name="1424"/>         if u := \a.url then {
<a name="1425"/>            n +:= 1
<a name="1426"/>            if last_highlight === u then {
<a name="1427"/>               he.last_highlight_index := n
<a name="1428"/>               he.last_highlight := u
<a name="1429"/>               link
<a name="1430"/>            }
<a name="1431"/>         }
<a name="1432"/>      }
<a name="1433"/>   end
<a name="1434"/>
<a name="1435"/>   package override restore_last_highlight(n, url)
<a name="1436"/>      local a, u
<a name="1437"/>      every a := gen_areas() do {
<a name="1438"/>         if u := \a.url then {
<a name="1439"/>            n -:= 1
<a name="1440"/>            if n = 0 then {
<a name="1441"/>               URL.equiv(url, u) | fail
<a name="1442"/>               last_highlight := u
<a name="1443"/>               link
<a name="1444"/>            }
<a name="1445"/>         }
<a name="1446"/>      }
<a name="1447"/>   end
<a name="1448"/>
<a name="1449"/>   private set_highlight(u)
<a name="1450"/>      if u ~=== highlight then {
<a name="1451"/>         browser.set_last_highlight(self, \u)
<a name="1452"/>         highlight := u
<a name="1453"/>         if visible_border() then
<a name="1454"/>            invalidate()
<a name="1455"/>      }
<a name="1456"/>      link
<a name="1457"/>   end
<a name="1458"/>
<a name="1459"/>   private handle_lmdrag(e)
<a name="1460"/>      if which_area(e).url === \held then {
<a name="1461"/>         set_over(held)
<a name="1462"/>         set_highlight(held)
<a name="1463"/>      } else {
<a name="1464"/>         set_over()
<a name="1465"/>         set_highlight()
<a name="1466"/>      }
<a name="1467"/>   end
<a name="1468"/>
<a name="1469"/>   package wants_lpress(e)
<a name="1470"/>      succeed \over | \form
<a name="1471"/>   end
<a name="1472"/>
<a name="1473"/>   package handle_in_chain(e)
<a name="1474"/>      local u, t, f
<a name="1475"/>      parent_dialog.get_held_count() = 0 | fail
<a name="1476"/>      # This should succeed iff we have areas (ie a link and/or a map).
<a name="1477"/>      t := which_area(e) | fail
<a name="1478"/>      if e.code === (Key.CONTROL_L | Key.CONTROL_R) then {
<a name="1479"/>         if /e.release then
<a name="1480"/>            f := &amp;yes
<a name="1481"/>      } else f := \e.ctrl
<a name="1482"/>      set_tooltip(t.title)
<a name="1483"/>      if /f &amp; (u := \t.url) then {
<a name="1484"/>         set_over(u)
<a name="1485"/>         set_pointer("hand1")
<a name="1486"/>      } else {
<a name="1487"/>         set_over()
<a name="1488"/>         set_pointer()
<a name="1489"/>      }
<a name="1490"/>   end
<a name="1491"/>
<a name="1492"/>   private visible_border()
<a name="1493"/>      return not is(border, NullBorder | EmptyBorder)
<a name="1494"/>   end
<a name="1495"/>
<a name="1496"/>   public override display()
<a name="1497"/>      Image.display()
<a name="1498"/>      if browser.is_banded(self) then
<a name="1499"/>         Gui.style.fill_selection_rectangle(cbwin, x, y, w, h)
<a name="1500"/>      if \last_highlight then
<a name="1501"/>         Gui.style.draw_dashed_rectangle(cbwin, x, y, w, h)
<a name="1502"/>   end
<a name="1503"/>
<a name="1504"/>   public override new(browser, context, img_url, alt, form, map_id)
<a name="1505"/>      Image.new()
<a name="1506"/>      clear_constraints()
<a name="1507"/>      self.browser := browser
<a name="1508"/>      self.context := context
<a name="1509"/>      self.img_url := img_url
<a name="1510"/>      self.form := form
<a name="1511"/>      self.alt := alt
<a name="1512"/>      self.map_id := map_id
<a name="1513"/>      if \form then {
<a name="1514"/>         set_pointer("hand1")
<a name="1515"/>         connect(handle_form_lrelease, Event.MOUSE_LEFT_RELEASE)
<a name="1516"/>      } else if \map_id | \context.url then {
<a name="1517"/>         connect(handle_lmdrag, Event.MOUSE_LEFT_DRAG)
<a name="1518"/>         connect(handle_lpress, Event.MOUSE_LEFT_PRESS)
<a name="1519"/>         connect(handle_lrelease, Event.MOUSE_LEFT_RELEASE)
<a name="1520"/>         connect(handle_lmdrag, Event.MOUSE_MIDDLE_DRAG)
<a name="1521"/>         connect(handle_mpress, Event.MOUSE_MIDDLE_PRESS)
<a name="1522"/>         connect(handle_mrelease, Event.MOUSE_MIDDLE_RELEASE)
<a name="1523"/>         connect(handle_exit, Event.MOUSE_EXIT)
<a name="1524"/>         connect(handle_interrupted, Event.INTERRUPTED)
<a name="1525"/>         bg_area := MapArea(,, context.url, context.title)
<a name="1526"/>      }
<a name="1527"/>      connect(handle_rpress, Event.MOUSE_RIGHT_PRESS)
<a name="1528"/>      set_border(NullBorder())
<a name="1529"/>      return
<a name="1530"/>   end
<a name="1531"/>end
<a name="1532"/>
<a name="1533"/>abstract class FormEntry()
<a name="1534"/>   package readable
<a name="1535"/>      form_name, form_save_key, form_id, form_tabindex
<a name="1536"/>
<a name="1537"/>   public validate_form()
<a name="1538"/>      return
<a name="1539"/>   end
<a name="1540"/>                  
<a name="1541"/>   public get_save_key()
<a name="1542"/>      return \form_save_key
<a name="1543"/>   end
<a name="1544"/>
<a name="1545"/>   public reset_form() end
<a name="1546"/>   public get_save_value() end
<a name="1547"/>   public restore_value(val) end
<a name="1548"/>
<a name="1549"/>   public abstract get_form_value(ev, src, multipart_flag)
<a name="1550"/>end
<a name="1551"/>
<a name="1552"/>class FormToggle(ToggleTextButton, FormEntry)
<a name="1553"/>   private const
<a name="1554"/>      value,
<a name="1555"/>      init_checked
<a name="1556"/>
<a name="1557"/>   public override reset_form()
<a name="1558"/>      set_is_checked(init_checked)
<a name="1559"/>   end
<a name="1560"/>
<a name="1561"/>   public override get_form_value(ev, src)
<a name="1562"/>      if is_checked() then 
<a name="1563"/>         return value
<a name="1564"/>   end
<a name="1565"/>
<a name="1566"/>   public override get_save_value()
<a name="1567"/>      return get_status()
<a name="1568"/>   end
<a name="1569"/>
<a name="1570"/>   public override restore_value(val)
<a name="1571"/>      set_is_checked(val)
<a name="1572"/>   end
<a name="1573"/>
<a name="1574"/>   public override new(value, init_checked)
<a name="1575"/>      ToggleTextButton.new()
<a name="1576"/>      self.value := value
<a name="1577"/>      self.init_checked := init_checked
<a name="1578"/>      set_is_checked(init_checked)
<a name="1579"/>      return
<a name="1580"/>   end
<a name="1581"/>end
<a name="1582"/>
<a name="1583"/>class FormButton(TextButton, FormEntry, HasAscent)
<a name="1584"/>   private const
<a name="1585"/>      value
<a name="1586"/>
<a name="1587"/>   public override get_form_value(ev, src)
<a name="1588"/>      if src === self then
<a name="1589"/>         return value
<a name="1590"/>   end
<a name="1591"/>
<a name="1592"/>   public override get_ascent() 
<a name="1593"/>      return cbwin.get_line_ascent() + border.get_t_inset()
<a name="1594"/>   end
<a name="1595"/>
<a name="1596"/>   public override new(value)
<a name="1597"/>      TextButton.new()
<a name="1598"/>      self.value := value
<a name="1599"/>      set_label(value)
<a name="1600"/>      return
<a name="1601"/>   end
<a name="1602"/>end
<a name="1603"/>
<a name="1604"/>class FormTextFlowButton(Button, FormEntry, HasMaxWidth, HasAscent)
<a name="1605"/>   public const
<a name="1606"/>      tf, value, form, type
<a name="1607"/>
<a name="1608"/>   public override get_form_value(ev, src)
<a name="1609"/>      if src === self then
<a name="1610"/>         return value
<a name="1611"/>   end
<a name="1612"/>
<a name="1613"/>   private handle_action(e, src)
<a name="1614"/>      case type of { 
<a name="1615"/>         "submit": form.submit(e, src)
<a name="1616"/>         "reset": form.reset_form()
<a name="1617"/>      }
<a name="1618"/>   end
<a name="1619"/>
<a name="1620"/>   public override display()
<a name="1621"/>      display_children()
<a name="1622"/>      if \self.is_down then {
<a name="1623"/>         Gui.style.fill_down_rectangle(self.cbwin, self.x, self.y, self.w, self.h)
<a name="1624"/>         tf.border.draw_rev_rect(self.cbwin, self)
<a name="1625"/>      }
<a name="1626"/>      if should_draw_focus() then
<a name="1627"/>         tf.border.draw_focus_rect(self.cbwin, self)
<a name="1628"/>   end
<a name="1629"/>
<a name="1630"/>   #
<a name="1631"/>   # Prevent children from getting in the point chain.
<a name="1632"/>   #
<a name="1633"/>   public override build_point_chain()
<a name="1634"/>   end
<a name="1635"/>
<a name="1636"/>   public override get_default_width()
<a name="1637"/>      return tf.get_preferred_width()
<a name="1638"/>   end
<a name="1639"/>
<a name="1640"/>   public override get_max_width()
<a name="1641"/>      return tf.get_max_width()
<a name="1642"/>   end
<a name="1643"/>
<a name="1644"/>   public override get_default_height(dw)
<a name="1645"/>      return tf.get_preferred_height(dw)
<a name="1646"/>   end
<a name="1647"/>
<a name="1648"/>   public override get_ascent(dw)
<a name="1649"/>      return tf.get_ascent(dw)
<a name="1650"/>   end
<a name="1651"/>
<a name="1652"/>   public override layout()
<a name="1653"/>      tf.x := x
<a name="1654"/>      tf.y := y
<a name="1655"/>      tf.w := w
<a name="1656"/>      tf.h := h
<a name="1657"/>      tf.layout()
<a name="1658"/>   end
<a name="1659"/>
<a name="1660"/>   public override new(form, value, type)
<a name="1661"/>      Button.new()
<a name="1662"/>      tf := TextFlow(form.browser).
<a name="1663"/>         set_border(CompoundBorder().
<a name="1664"/>                    set_outer(RaisedBorder()).
<a name="1665"/>                    set_inner(EmptyBorder()))
<a name="1666"/>      add(tf)
<a name="1667"/>      self.value := value
<a name="1668"/>      self.form := form
<a name="1669"/>      self.type := type
<a name="1670"/>      connect(self.handle_action, Event.ACTION)
<a name="1671"/>      return
<a name="1672"/>   end
<a name="1673"/>end
<a name="1674"/>
<a name="1675"/>class Hidden(FormEntry)
<a name="1676"/>   private const
<a name="1677"/>      value
<a name="1678"/>
<a name="1679"/>   public override get_form_value()
<a name="1680"/>      return value
<a name="1681"/>   end
<a name="1682"/>
<a name="1683"/>   public new(value)
<a name="1684"/>      self.value := value
<a name="1685"/>      return
<a name="1686"/>   end
<a name="1687"/>end
<a name="1688"/>
<a name="1689"/>class FormLabel()
<a name="1690"/>   public const
<a name="1691"/>      id,
<a name="1692"/>      form
<a name="1693"/>   public
<a name="1694"/>      comp
<a name="1695"/>
<a name="1696"/>   public new(id, form)
<a name="1697"/>      self.id := id
<a name="1698"/>      self.form := form
<a name="1699"/>      return
<a name="1700"/>   end
<a name="1701"/>end
<a name="1702"/>
<a name="1703"/>class FormBrowse(Component, FormEntry, HasAscent)
<a name="1704"/>   private const
<a name="1705"/>      tf,
<a name="1706"/>      browser
<a name="1707"/>
<a name="1708"/>   public override get_form_value(ev, src, multipart_flag)
<a name="1709"/>      local s
<a name="1710"/>      s := tf.get_contents()
<a name="1711"/>      if *s = 0 then
<a name="1712"/>         return ""
<a name="1713"/>      return if /multipart_flag then
<a name="1714"/>         tf.get_contents()
<a name="1715"/>      else
<a name="1716"/>         Files.file_to_string(s)
<a name="1717"/>   end
<a name="1718"/>
<a name="1719"/>   public override validate_form()
<a name="1720"/>      local s
<a name="1721"/>      s := tf.get_contents()
<a name="1722"/>      if *s = 0 then
<a name="1723"/>         return
<a name="1724"/>      succeed Files.access(s) | error("No such file")
<a name="1725"/>   end
<a name="1726"/>
<a name="1727"/>   public get_filename()
<a name="1728"/>      return FilePath(tf.get_contents()).get(-1) | u""
<a name="1729"/>   end
<a name="1730"/>
<a name="1731"/>   public override get_ascent() 
<a name="1732"/>      return cbwin.get_line_ascent() + tf.border.get_t_inset()
<a name="1733"/>   end
<a name="1734"/>
<a name="1735"/>   public override reset_form()
<a name="1736"/>      tf.set_contents(u"")
<a name="1737"/>   end
<a name="1738"/>
<a name="1739"/>   public override get_save_value()
<a name="1740"/>      return tf.get_contents()
<a name="1741"/>   end
<a name="1742"/>
<a name="1743"/>   public override restore_value(val)
<a name="1744"/>      tf.set_contents(val)
<a name="1745"/>   end
<a name="1746"/>
<a name="1747"/>   private on_browse(ev)
<a name="1748"/>      tf.assign_contents(ucs(browser.browse_for_file(tf.get_contents())),, ev)
<a name="1749"/>   end
<a name="1750"/>
<a name="1751"/>   public override new(browser, tf_size)
<a name="1752"/>      Component.new()
<a name="1753"/>      self.browser := browser
<a name="1754"/>      set_layout(GridLayout().set_doi(0).set_dii(0))
<a name="1755"/>      tf := FileSuggestField().set_size(tf_size).set_contents(u"")
<a name="1756"/>      add(tf)
<a name="1757"/>      add(TextButton().set_label("Browse...").connect(on_browse, Event.ACTION))
<a name="1758"/>      return
<a name="1759"/>   end
<a name="1760"/>end
<a name="1761"/>
<a name="1762"/>class FormImgX(FormEntry)
<a name="1763"/>   private const
<a name="1764"/>      img
<a name="1765"/>
<a name="1766"/>   public override get_form_value(ev, src)
<a name="1767"/>      if src === img then
<a name="1768"/>         return round((ev.x - img.x) / Gui.SCALE)
<a name="1769"/>   end
<a name="1770"/>
<a name="1771"/>   public new(img)
<a name="1772"/>      self.img := img
<a name="1773"/>      return
<a name="1774"/>   end
<a name="1775"/>end
<a name="1776"/>
<a name="1777"/>class FormImgY(FormEntry)
<a name="1778"/>   private const
<a name="1779"/>      img
<a name="1780"/>
<a name="1781"/>   public override get_form_value(ev, src)
<a name="1782"/>      if src === img then
<a name="1783"/>         return round((ev.y - img.y) / Gui.SCALE)
<a name="1784"/>   end
<a name="1785"/>
<a name="1786"/>   public new(img)
<a name="1787"/>      self.img := img
<a name="1788"/>      return
<a name="1789"/>   end
<a name="1790"/>end
<a name="1791"/>
<a name="1792"/>class FormSuggestField(SuggestField, FormEntry, HasAscent)
<a name="1793"/>   private const
<a name="1794"/>      browser,
<a name="1795"/>      init_val,
<a name="1796"/>      datalist_id
<a name="1797"/>
<a name="1798"/>   public override get_ascent() 
<a name="1799"/>      return cbwin.get_line_ascent() + border.get_t_inset()
<a name="1800"/>   end
<a name="1801"/>
<a name="1802"/>   public override reset_form()
<a name="1803"/>      set_contents(init_val)
<a name="1804"/>   end
<a name="1805"/>
<a name="1806"/>   public override get_form_value()
<a name="1807"/>      return get_contents()
<a name="1808"/>   end
<a name="1809"/>
<a name="1810"/>   public override get_save_value()
<a name="1811"/>      return get_contents()
<a name="1812"/>   end
<a name="1813"/>
<a name="1814"/>   public override restore_value(val)
<a name="1815"/>      set_contents(val)
<a name="1816"/>   end
<a name="1817"/>
<a name="1818"/>   public override create_popup()
<a name="1819"/>      return FormOptionList()
<a name="1820"/>   end
<a name="1821"/>
<a name="1822"/>   public override convert_element(o)
<a name="1823"/>      return o.value
<a name="1824"/>   end
<a name="1825"/>
<a name="1826"/>   protected override do_request()
<a name="1827"/>      local l, t, e, s
<a name="1828"/>      l := browser.get_datalist(datalist_id) | fail
<a name="1829"/>      s := Text.lower(contents)
<a name="1830"/>      t := []
<a name="1831"/>      every e := !l do {
<a name="1832"/>         if match(s, Text.lower(e.value)) then
<a name="1833"/>            put(t, e)
<a name="1834"/>      }
<a name="1835"/>      return t
<a name="1836"/>   end
<a name="1837"/>
<a name="1838"/>   public override new(browser, init_val, datalist_id)
<a name="1839"/>      SuggestField.new()
<a name="1840"/>      self.browser := browser
<a name="1841"/>      self.init_val := init_val
<a name="1842"/>      self.datalist_id := datalist_id
<a name="1843"/>      set_contents(init_val)
<a name="1844"/>      set_action_while_popup(&amp;no)
<a name="1845"/>     return
<a name="1846"/>   end
<a name="1847"/>end
<a name="1848"/>
<a name="1849"/>class FormTextField(TextField, FormEntry, HasAscent)
<a name="1850"/>   private const
<a name="1851"/>      init_val
<a name="1852"/>
<a name="1853"/>   public override get_ascent() 
<a name="1854"/>      return cbwin.get_line_ascent() + border.get_t_inset()
<a name="1855"/>   end
<a name="1856"/>
<a name="1857"/>   public override reset_form()
<a name="1858"/>      set_contents(init_val)
<a name="1859"/>   end
<a name="1860"/>
<a name="1861"/>   public override get_form_value()
<a name="1862"/>      return get_contents()
<a name="1863"/>   end
<a name="1864"/>
<a name="1865"/>   public override get_save_value()
<a name="1866"/>      return get_contents()
<a name="1867"/>   end
<a name="1868"/>
<a name="1869"/>   public override restore_value(val)
<a name="1870"/>      set_contents(val)
<a name="1871"/>   end
<a name="1872"/>
<a name="1873"/>   public override new(init_val)
<a name="1874"/>      TextField.new()
<a name="1875"/>      self.init_val := init_val
<a name="1876"/>      set_contents(init_val)
<a name="1877"/>     return
<a name="1878"/>   end
<a name="1879"/>end
<a name="1880"/>
<a name="1881"/>class FormURLField(TextField, FormEntry, HasAscent)
<a name="1882"/>   private const
<a name="1883"/>      init_val
<a name="1884"/>
<a name="1885"/>   public override get_ascent()
<a name="1886"/>      return cbwin.get_line_ascent() + border.get_t_inset()
<a name="1887"/>   end
<a name="1888"/>
<a name="1889"/>   public override reset_form()
<a name="1890"/>      set_contents(init_val)
<a name="1891"/>   end
<a name="1892"/>
<a name="1893"/>   public override get_form_value()
<a name="1894"/>      return get_contents()
<a name="1895"/>   end
<a name="1896"/>
<a name="1897"/>   public override validate_form()
<a name="1898"/>      succeed URL(get_contents()) | error("Bad URL")
<a name="1899"/>   end
<a name="1900"/>
<a name="1901"/>   public override get_save_value()
<a name="1902"/>      return get_contents()
<a name="1903"/>   end
<a name="1904"/>
<a name="1905"/>   public override restore_value(val)
<a name="1906"/>      set_contents(val)
<a name="1907"/>   end
<a name="1908"/>
<a name="1909"/>   public override new(init_val)
<a name="1910"/>      TextField.new()
<a name="1911"/>      self.init_val := init_val
<a name="1912"/>      set_contents(init_val)
<a name="1913"/>      return
<a name="1914"/>   end
<a name="1915"/>end
<a name="1916"/>
<a name="1917"/>class FormDateField(DateField, FormEntry, HasAscent)
<a name="1918"/>   private const
<a name="1919"/>      init_val
<a name="1920"/>
<a name="1921"/>   public override get_ascent() 
<a name="1922"/>      return cbwin.get_line_ascent() + border.get_t_inset() + view.border.get_t_inset()
<a name="1923"/>   end
<a name="1924"/>
<a name="1925"/>   public override reset_form()
<a name="1926"/>      set_value(init_val)
<a name="1927"/>   end
<a name="1928"/>
<a name="1929"/>   public override validate_form()
<a name="1930"/>      succeed get_value() | error("Bad date format")
<a name="1931"/>   end
<a name="1932"/>
<a name="1933"/>   public override get_form_value()
<a name="1934"/>      return get_value().format("yyyy-MM-dd")
<a name="1935"/>   end
<a name="1936"/>
<a name="1937"/>   public override get_save_value()
<a name="1938"/>      return last_val
<a name="1939"/>   end
<a name="1940"/>
<a name="1941"/>   public override restore_value(val)
<a name="1942"/>      set_value(val)
<a name="1943"/>   end
<a name="1944"/>
<a name="1945"/>   public override new(init_val)
<a name="1946"/>      DateField.new(init_val)
<a name="1947"/>      self.init_val := init_val
<a name="1948"/>      return
<a name="1949"/>   end
<a name="1950"/>end
<a name="1951"/>
<a name="1952"/>class FormWeekField(WeekField, FormEntry, HasAscent)
<a name="1953"/>   private const
<a name="1954"/>      init_val
<a name="1955"/>
<a name="1956"/>   public override get_ascent() 
<a name="1957"/>      return cbwin.get_line_ascent() + border.get_t_inset() + view.border.get_t_inset()
<a name="1958"/>   end
<a name="1959"/>
<a name="1960"/>   public override reset_form()
<a name="1961"/>      set_value(init_val)
<a name="1962"/>   end
<a name="1963"/>
<a name="1964"/>   public override validate_form()
<a name="1965"/>      succeed get_value() | error("Bad week format")
<a name="1966"/>   end
<a name="1967"/>
<a name="1968"/>   public override get_form_value()
<a name="1969"/>      return get_value().format("vvvv'-W'ww")
<a name="1970"/>   end
<a name="1971"/>
<a name="1972"/>   public static parse(s)
<a name="1973"/>      local w, y
<a name="1974"/>      trim(s, ' \t') ? {
<a name="1975"/>         (y := integer(tab(many(&amp;digits))) &amp;
<a name="1976"/>          1000 &lt;= y &lt;= 9999 &amp;
<a name="1977"/>          ="-W" &amp;
<a name="1978"/>          w := integer(tab(many(&amp;digits))) &amp;
<a name="1979"/>          1 &lt;= w &lt;= 53 &amp;
<a name="1980"/>          pos(0)) | fail
<a name="1981"/>      }
<a name="1982"/>      return Time.from_week_date(y, w)
<a name="1983"/>   end
<a name="1984"/>
<a name="1985"/>   public override get_save_value()
<a name="1986"/>      return last_val
<a name="1987"/>   end
<a name="1988"/>
<a name="1989"/>   public override restore_value(val)
<a name="1990"/>      set_value(val)
<a name="1991"/>   end
<a name="1992"/>
<a name="1993"/>   public override new(init_val)
<a name="1994"/>      WeekField.new(init_val)
<a name="1995"/>      self.init_val := init_val
<a name="1996"/>      return
<a name="1997"/>   end
<a name="1998"/>end
<a name="1999"/>
<a name="2000"/>class FormTimeField(TimeField, FormEntry, HasAscent)
<a name="2001"/>   private const
<a name="2002"/>      init_val
<a name="2003"/>
<a name="2004"/>   public override reset_form()
<a name="2005"/>      set_value(init_val)
<a name="2006"/>   end
<a name="2007"/>
<a name="2008"/>   public override validate_form()
<a name="2009"/>      succeed get_value() | error("Bad time format")
<a name="2010"/>   end
<a name="2011"/>
<a name="2012"/>   public override get_form_value()
<a name="2013"/>      return get_value().format("HH':'mm':'ss")
<a name="2014"/>   end
<a name="2015"/>
<a name="2016"/>   public override get_save_value()
<a name="2017"/>      return last_val
<a name="2018"/>   end
<a name="2019"/>
<a name="2020"/>   public override restore_value(val)
<a name="2021"/>      set_value(val)
<a name="2022"/>   end
<a name="2023"/>
<a name="2024"/>   public override get_ascent() 
<a name="2025"/>      return cbwin.get_line_ascent() + border.get_t_inset() + view.border.get_t_inset()
<a name="2026"/>   end
<a name="2027"/>
<a name="2028"/>   public static parse(s)
<a name="2029"/>      s ?:= tab(upto('.'))
<a name="2030"/>      return Time.parse(s, "HH':'mm':'ss")
<a name="2031"/>   end
<a name="2032"/>
<a name="2033"/>   public override new(init_val)
<a name="2034"/>      TimeField.new(init_val)
<a name="2035"/>      self.init_val := init_val
<a name="2036"/>      return
<a name="2037"/>   end
<a name="2038"/>end
<a name="2039"/>
<a name="2040"/>class FormDateTimeLocalField(Component, FormEntry, HasAscent)
<a name="2041"/>   private const
<a name="2042"/>      date,
<a name="2043"/>      time
<a name="2044"/>
<a name="2045"/>   public override get_ascent() 
<a name="2046"/>      return date.get_ascent()
<a name="2047"/>   end
<a name="2048"/>
<a name="2049"/>   public override reset_form()
<a name="2050"/>      date.reset_form()
<a name="2051"/>      time.reset_form()
<a name="2052"/>   end
<a name="2053"/>
<a name="2054"/>   public override validate_form()
<a name="2055"/>      succeed date.validate_form() &amp; time.validate_form()
<a name="2056"/>   end
<a name="2057"/>
<a name="2058"/>   public static parse(s)
<a name="2059"/>      s ?:= tab(upto('.'))
<a name="2060"/>      return Time.parse(s, "yyyy'-'MM'-'dd'T'HH':'mm':'ss")
<a name="2061"/>   end
<a name="2062"/>
<a name="2063"/>   public override get_form_value()
<a name="2064"/>      return date.get_form_value() || "T" || time.get_form_value()
<a name="2065"/>   end
<a name="2066"/>
<a name="2067"/>   public override get_save_value()
<a name="2068"/>      return [date.get_save_value(), time.get_save_value()]
<a name="2069"/>   end
<a name="2070"/>
<a name="2071"/>   public override restore_value(val)
<a name="2072"/>      date.restore_value(val[1])
<a name="2073"/>      time.restore_value(val[2])
<a name="2074"/>   end
<a name="2075"/>
<a name="2076"/>   public override new(init_val)
<a name="2077"/>      Component.new()
<a name="2078"/>      set_layout(GridLayout().set_doi(0).set_dii(0))
<a name="2079"/>      add(date := FormDateField(init_val))
<a name="2080"/>      add(time := FormTimeField(init_val))
<a name="2081"/>      return
<a name="2082"/>   end
<a name="2083"/>end
<a name="2084"/>
<a name="2085"/>class FormTimezoneField(TimezoneField, FormEntry, HasAscent)
<a name="2086"/>   private const
<a name="2087"/>      init_val
<a name="2088"/>
<a name="2089"/>   public override reset_form()
<a name="2090"/>      set_value(init_val)
<a name="2091"/>   end
<a name="2092"/>
<a name="2093"/>   public override validate_form()
<a name="2094"/>      succeed get_value() | error("Bad timezone format")
<a name="2095"/>   end
<a name="2096"/>
<a name="2097"/>   public override get_form_value()
<a name="2098"/>      local zone
<a name="2099"/>      zone := get_value() | fail
<a name="2100"/>      return if zone.offset = 0 then
<a name="2101"/>         "Z"
<a name="2102"/>      else (if zone.offset &lt; 0 then "-" else "+") ||
<a name="2103"/>         right(abs(zone.offset) / 3600, 2, "0") || ":" ||
<a name="2104"/>         right((abs(zone.offset) % 3600) / 60, 2, "0")
<a name="2105"/>   end
<a name="2106"/>
<a name="2107"/>   public override get_save_value()
<a name="2108"/>      return last_val
<a name="2109"/>   end
<a name="2110"/>
<a name="2111"/>   public override restore_value(val)
<a name="2112"/>      set_value(val)
<a name="2113"/>   end
<a name="2114"/>
<a name="2115"/>   public override get_ascent() 
<a name="2116"/>      return cbwin.get_line_ascent() + border.get_t_inset() + view.border.get_t_inset()
<a name="2117"/>   end
<a name="2118"/>
<a name="2119"/>   public override new(init_val)
<a name="2120"/>      TimezoneField.new(init_val)
<a name="2121"/>      self.init_val := init_val
<a name="2122"/>      return
<a name="2123"/>   end
<a name="2124"/>end
<a name="2125"/>
<a name="2126"/>class FormYearField(YearField, FormEntry, HasAscent)
<a name="2127"/>   private const
<a name="2128"/>      init_val
<a name="2129"/>
<a name="2130"/>   public override reset_form()
<a name="2131"/>      set_value(init_val)
<a name="2132"/>   end
<a name="2133"/>
<a name="2134"/>   public override validate_form()
<a name="2135"/>      succeed get_value() | error("Bad timezone format")
<a name="2136"/>   end
<a name="2137"/>
<a name="2138"/>   public override get_form_value()
<a name="2139"/>      return string(get_value())
<a name="2140"/>   end
<a name="2141"/>
<a name="2142"/>   public override get_save_value()
<a name="2143"/>      return last_val
<a name="2144"/>   end
<a name="2145"/>
<a name="2146"/>   public override restore_value(val)
<a name="2147"/>      set_value(val)
<a name="2148"/>   end
<a name="2149"/>
<a name="2150"/>   public override get_ascent() 
<a name="2151"/>      return cbwin.get_line_ascent() + border.get_t_inset() + view.border.get_t_inset()
<a name="2152"/>   end
<a name="2153"/>
<a name="2154"/>   public override new(init_val)
<a name="2155"/>      YearField.new()
<a name="2156"/>      set_value(init_val)
<a name="2157"/>      self.init_val := init_val
<a name="2158"/>      return
<a name="2159"/>   end
<a name="2160"/>end
<a name="2161"/>
<a name="2162"/>class FormMonthField(MonthField, FormEntry, HasAscent)
<a name="2163"/>   private const
<a name="2164"/>      init_val
<a name="2165"/>
<a name="2166"/>   public override reset_form()
<a name="2167"/>      set_selection(init_val)
<a name="2168"/>   end
<a name="2169"/>
<a name="2170"/>   public override get_form_value()
<a name="2171"/>      return string(get_selection())
<a name="2172"/>   end
<a name="2173"/>
<a name="2174"/>   public override get_save_value()
<a name="2175"/>      return get_selection()
<a name="2176"/>   end
<a name="2177"/>
<a name="2178"/>   public override restore_value(val)
<a name="2179"/>      set_selection(val)
<a name="2180"/>   end
<a name="2181"/>
<a name="2182"/>   public override get_ascent() 
<a name="2183"/>      return cbwin.get_line_ascent() + border.get_t_inset() + view.border.get_t_inset()
<a name="2184"/>   end
<a name="2185"/>
<a name="2186"/>   public override new(init_val)
<a name="2187"/>      MonthField.new()
<a name="2188"/>      set_selection(init_val)
<a name="2189"/>      self.init_val := init_val
<a name="2190"/>      return
<a name="2191"/>   end
<a name="2192"/>end
<a name="2193"/>
<a name="2194"/>class FormDateTimeField(Component, FormEntry, HasAscent)
<a name="2195"/>   private const
<a name="2196"/>      date,
<a name="2197"/>      time,
<a name="2198"/>      zone
<a name="2199"/>
<a name="2200"/>   public override get_ascent() 
<a name="2201"/>      return date.get_ascent()
<a name="2202"/>   end
<a name="2203"/>
<a name="2204"/>   public override reset_form()
<a name="2205"/>      date.reset_form()
<a name="2206"/>      time.reset_form()
<a name="2207"/>      zone.reset_form()
<a name="2208"/>   end
<a name="2209"/>
<a name="2210"/>   public override validate_form()
<a name="2211"/>      succeed date.validate_form() &amp; time.validate_form() &amp; zone.validate_form()
<a name="2212"/>   end
<a name="2213"/>
<a name="2214"/>   public static parse(s)
<a name="2215"/>      s ? {
<a name="2216"/>         if s := tab(upto('.')) then {
<a name="2217"/>            move(1)
<a name="2218"/>            tab(many(&amp;digits))
<a name="2219"/>            s ||:= tab(0)
<a name="2220"/>         }
<a name="2221"/>      }
<a name="2222"/>      return Time.parse(s, "yyyy'-'MM'-'dd'T'HH':'mm':'ssT")
<a name="2223"/>   end
<a name="2224"/>
<a name="2225"/>   public override get_form_value()
<a name="2226"/>      return date.get_form_value() || "T" || time.get_form_value() || zone.get_form_value()
<a name="2227"/>   end
<a name="2228"/>
<a name="2229"/>   public override get_save_value()
<a name="2230"/>      return [date.get_save_value(), time.get_save_value(), zone.get_save_value()]
<a name="2231"/>   end
<a name="2232"/>
<a name="2233"/>   public override restore_value(val)
<a name="2234"/>      date.restore_value(val[1])
<a name="2235"/>      time.restore_value(val[2])
<a name="2236"/>      zone.restore_value(val[3])
<a name="2237"/>   end
<a name="2238"/>
<a name="2239"/>   public override new(init_val)
<a name="2240"/>      Component.new()
<a name="2241"/>      set_layout(GridLayout().set_doi(0).set_dii(0))
<a name="2242"/>      add(date := FormDateField(init_val))
<a name="2243"/>      add(time := FormTimeField(init_val))
<a name="2244"/>      add(zone := FormTimezoneField(init_val.zone))
<a name="2245"/>      return
<a name="2246"/>   end
<a name="2247"/>end
<a name="2248"/>
<a name="2249"/>class FormMonthYearField(Component, FormEntry, HasAscent)
<a name="2250"/>   private const
<a name="2251"/>      month,
<a name="2252"/>      year,
<a name="2253"/>      init_val
<a name="2254"/>
<a name="2255"/>   public override get_ascent() 
<a name="2256"/>      return month.get_ascent()
<a name="2257"/>   end
<a name="2258"/>
<a name="2259"/>   public override reset_form()
<a name="2260"/>      month.reset_form()
<a name="2261"/>      year.reset_form()
<a name="2262"/>   end
<a name="2263"/>
<a name="2264"/>   public override validate_form()
<a name="2265"/>      succeed year.validate_form()
<a name="2266"/>   end
<a name="2267"/>
<a name="2268"/>   public static parse(s)
<a name="2269"/>      local y, m
<a name="2270"/>      trim(s, ' \t') ? {
<a name="2271"/>         (y := integer(tab(many(&amp;digits))) &amp;
<a name="2272"/>          1000 &lt;= y &lt;= 9999 &amp;
<a name="2273"/>          ="-" &amp;
<a name="2274"/>          m := integer(tab(many(&amp;digits))) &amp;
<a name="2275"/>          1 &lt;= m &lt;= 12 &amp;
<a name="2276"/>          pos(0)) | fail
<a name="2277"/>      }
<a name="2278"/>      return Time(y, m, 1)
<a name="2279"/>   end
<a name="2280"/>
<a name="2281"/>   public override get_form_value()
<a name="2282"/>      return year.get_form_value() || "-" || month.get_form_value()
<a name="2283"/>   end
<a name="2284"/>
<a name="2285"/>   public override get_save_value()
<a name="2286"/>      return [year.get_save_value(), month.get_save_value()]
<a name="2287"/>   end
<a name="2288"/>
<a name="2289"/>   public override restore_value(val)
<a name="2290"/>      year.restore_value(val[1])
<a name="2291"/>      month.restore_value(val[2])
<a name="2292"/>   end
<a name="2293"/>
<a name="2294"/>   public override new(init_val)
<a name="2295"/>      Component.new()
<a name="2296"/>      set_layout(GridLayout().set_doi(0).set_dii(0))
<a name="2297"/>      add(month := FormMonthField(init_val.month))
<a name="2298"/>      add(year := FormYearField(init_val.year))
<a name="2299"/>      return
<a name="2300"/>   end
<a name="2301"/>end
<a name="2302"/>
<a name="2303"/>class FormRange(Slider, FormEntry)
<a name="2304"/>   private const
<a name="2305"/>      init_val
<a name="2306"/>
<a name="2307"/>   public override reset_form()
<a name="2308"/>      set_value(init_val)
<a name="2309"/>   end
<a name="2310"/>
<a name="2311"/>   public override get_form_value()
<a name="2312"/>      return get_value()
<a name="2313"/>   end
<a name="2314"/>
<a name="2315"/>   public override get_save_value()
<a name="2316"/>      return get_value()
<a name="2317"/>   end
<a name="2318"/>
<a name="2319"/>   public override restore_value(val)
<a name="2320"/>      set_value(val)
<a name="2321"/>   end
<a name="2322"/>
<a name="2323"/>   public override new(init_val)
<a name="2324"/>      Slider.new()
<a name="2325"/>      set_value(init_val)
<a name="2326"/>      self.init_val := init_val
<a name="2327"/>      return
<a name="2328"/>   end
<a name="2329"/>end
<a name="2330"/>
<a name="2331"/>class FormNumberField(RangeSpin, FormEntry, HasAscent)
<a name="2332"/>   private const
<a name="2333"/>      init_val
<a name="2334"/>
<a name="2335"/>   public override reset_form()
<a name="2336"/>      set_value(init_val)
<a name="2337"/>   end
<a name="2338"/>
<a name="2339"/>   public override validate_form()
<a name="2340"/>      succeed get_value() | error("Invalid number")
<a name="2341"/>   end
<a name="2342"/>
<a name="2343"/>   public override get_form_value()
<a name="2344"/>      return string(get_value())
<a name="2345"/>   end
<a name="2346"/>
<a name="2347"/>   public override get_save_value()
<a name="2348"/>      return last_val
<a name="2349"/>   end
<a name="2350"/>
<a name="2351"/>   public override restore_value(val)
<a name="2352"/>      set_value(val)
<a name="2353"/>   end
<a name="2354"/>
<a name="2355"/>   public override get_ascent() 
<a name="2356"/>      return cbwin.get_line_ascent() + border.get_t_inset() + view.border.get_t_inset()
<a name="2357"/>   end
<a name="2358"/>
<a name="2359"/>   public override new(init_val)
<a name="2360"/>      RangeSpin.new()
<a name="2361"/>      set_value(init_val)
<a name="2362"/>      self.init_val := init_val
<a name="2363"/>      return
<a name="2364"/>   end
<a name="2365"/>end
<a name="2366"/>
<a name="2367"/>class FormColorField(ColorField, FormEntry, HasAscent)
<a name="2368"/>   private const
<a name="2369"/>      init_val
<a name="2370"/>
<a name="2371"/>   public override reset_form()
<a name="2372"/>      set_value(init_val)
<a name="2373"/>   end
<a name="2374"/>
<a name="2375"/>   public override validate_form()
<a name="2376"/>      succeed get_value() | error("Bad color format")
<a name="2377"/>   end
<a name="2378"/>
<a name="2379"/>   public override get_form_value()
<a name="2380"/>      local l, s
<a name="2381"/>      l := Window.parse_color(get_value()) | fail
<a name="2382"/>      s := "#"
<a name="2383"/>      every s ||:= Format.int_to_string(l[1 to 3] / 256, 16, 2)
<a name="2384"/>      return s
<a name="2385"/>   end
<a name="2386"/>
<a name="2387"/>   public override get_save_value() 
<a name="2388"/>      return last_val
<a name="2389"/>   end
<a name="2390"/>
<a name="2391"/>   public override restore_value(val)
<a name="2392"/>      set_value(val)
<a name="2393"/>   end
<a name="2394"/>
<a name="2395"/>   public override get_ascent() 
<a name="2396"/>      return cbwin.get_line_ascent() + b.border.get_t_inset()
<a name="2397"/>   end
<a name="2398"/>
<a name="2399"/>   public static parse(s)
<a name="2400"/>      return Window.color_value(s)
<a name="2401"/>   end
<a name="2402"/>
<a name="2403"/>   public override new(init_val)
<a name="2404"/>      ColorField.new(init_val)
<a name="2405"/>      self.init_val := init_val
<a name="2406"/>      set_opaque(&amp;yes)
<a name="2407"/>      return
<a name="2408"/>   end
<a name="2409"/>end
<a name="2410"/>
<a name="2411"/>class FormEditableTextList(EditableTextList, FormEntry)
<a name="2412"/>   private const
<a name="2413"/>      init_val
<a name="2414"/>
<a name="2415"/>   public override reset_form()
<a name="2416"/>      set_contents_str(init_val)
<a name="2417"/>      set_cursor(1, 1)
<a name="2418"/>   end
<a name="2419"/>
<a name="2420"/>   public override get_form_value()
<a name="2421"/>      return list2str(contents, "\r\n")
<a name="2422"/>   end
<a name="2423"/>
<a name="2424"/>   public override get_save_value()
<a name="2425"/>      return get_contents()
<a name="2426"/>   end
<a name="2427"/>
<a name="2428"/>   public override restore_value(val)
<a name="2429"/>      set_contents(val)
<a name="2430"/>   end
<a name="2431"/>
<a name="2432"/>   public override new(init_val)
<a name="2433"/>      EditableTextList.new()
<a name="2434"/>      self.init_val := init_val
<a name="2435"/>      set_contents_str(init_val)
<a name="2436"/>      return
<a name="2437"/>   end
<a name="2438"/>end
<a name="2439"/>
<a name="2440"/>class FormOption()
<a name="2441"/>   public const
<a name="2442"/>      txt, label, value, selected, disabled, optgroup
<a name="2443"/>
<a name="2444"/>   public new(txt, label, value, selected, disabled, optgroup)
<a name="2445"/>      self.txt := txt
<a name="2446"/>      self.label := label
<a name="2447"/>      self.value := value
<a name="2448"/>      self.selected := selected
<a name="2449"/>      self.disabled := disabled
<a name="2450"/>      self.optgroup := optgroup
<a name="2451"/>      return
<a name="2452"/>   end
<a name="2453"/>end
<a name="2454"/>
<a name="2455"/>class FormOptionList(SelectableScrollArea, FormEntry)
<a name="2456"/>   private const
<a name="2457"/>      init_val
<a name="2458"/>
<a name="2459"/>   public override end_handle(e)
<a name="2460"/>      local i
<a name="2461"/>      every i := !selections do {
<a name="2462"/>         if /contents[i].value then
<a name="2463"/>            delete(selections, i)
<a name="2464"/>      }
<a name="2465"/>      SelectableScrollArea.end_handle(e)
<a name="2466"/>   end
<a name="2467"/>
<a name="2468"/>   public override get_form_value(ev, src)
<a name="2469"/>      suspend \contents[!selections].value
<a name="2470"/>   end
<a name="2471"/>
<a name="2472"/>   public override reset_form()
<a name="2473"/>      set_selections(init_val)
<a name="2474"/>   end
<a name="2475"/>
<a name="2476"/>   public override get_save_value()
<a name="2477"/>      return get_selections()
<a name="2478"/>   end
<a name="2479"/>
<a name="2480"/>   public override restore_value(val)
<a name="2481"/>      set_selections(val)
<a name="2482"/>   end
<a name="2483"/>
<a name="2484"/>   public override calculate_line_height()
<a name="2485"/>      return view.cbwin.get_line_height()
<a name="2486"/>   end
<a name="2487"/>
<a name="2488"/>   public override calculate_subject_width()
<a name="2489"/>      local mw, o
<a name="2490"/>      mw := 0
<a name="2491"/>      every o := !contents do
<a name="2492"/>         mw &lt;:= view.cbwin.text_width(o.txt)
<a name="2493"/>      return mw + 2 * Gui.TEXT_INSET
<a name="2494"/>   end
<a name="2495"/>
<a name="2496"/>   public override draw_line_data(xp, yp, lh, i)
<a name="2497"/>      local o, W
<a name="2498"/>      o := contents[i]
<a name="2499"/>      if \o.disabled then {
<a name="2500"/>         use {
<a name="2501"/>            W := view.cbwin.clone(),
<a name="2502"/>            W.set_fg("gray").
<a name="2503"/>              draw_string(xp + Gui.TEXT_INSET, yp + W.get_line_ascent(), o.txt)
<a name="2504"/>         }
<a name="2505"/>      } else 
<a name="2506"/>         view.cbwin.draw_string(xp + Gui.TEXT_INSET, yp + view.cbwin.get_line_ascent(), o.txt)
<a name="2507"/>   end
<a name="2508"/>
<a name="2509"/>   public override new(init_val)
<a name="2510"/>      SelectableScrollArea.new()
<a name="2511"/>      self.init_val := init_val
<a name="2512"/>      return
<a name="2513"/>   end
<a name="2514"/>end
<a name="2515"/>
<a name="2516"/>class FormList(gui.List, FormEntry, HasAscent)
<a name="2517"/>   private const
<a name="2518"/>      init_val
<a name="2519"/>
<a name="2520"/>   public override get_ascent() 
<a name="2521"/>      return cbwin.get_line_ascent() + view.border.get_t_inset() + border.get_t_inset()
<a name="2522"/>   end
<a name="2523"/>
<a name="2524"/>   private find_value(seq, e)
<a name="2525"/>      local i
<a name="2526"/>      while i := @seq do {
<a name="2527"/>         if \selection_list[i].value then {
<a name="2528"/>            start_change(e)
<a name="2529"/>            set_selection(i, e)
<a name="2530"/>            end_change(e)
<a name="2531"/>            break
<a name="2532"/>         }
<a name="2533"/>      }
<a name="2534"/>   end
<a name="2535"/>
<a name="2536"/>   public override do_increment(e)
<a name="2537"/>      if /selection then
<a name="2538"/>         find_value(create *selection_list to 1 by -1, e)
<a name="2539"/>      else
<a name="2540"/>         find_value(create (selection - 1 to 1 by -1) | (*selection_list to selection + 1 by -1), e)
<a name="2541"/>   end
<a name="2542"/>
<a name="2543"/>   public override do_decrement(e)
<a name="2544"/>      if /selection then
<a name="2545"/>         find_value(create 1 to *selection_list, e)
<a name="2546"/>      else
<a name="2547"/>         find_value(create (1 + selection to *selection_list) | (1 to selection - 1), e)
<a name="2548"/>   end
<a name="2549"/>
<a name="2550"/>   public override reset_form()
<a name="2551"/>      set_selection(init_val)
<a name="2552"/>   end
<a name="2553"/>
<a name="2554"/>   public override get_form_value(ev, src)
<a name="2555"/>      return \object_get_selection().value
<a name="2556"/>   end
<a name="2557"/>
<a name="2558"/>   public override get_save_value()
<a name="2559"/>      return get_selection()
<a name="2560"/>   end
<a name="2561"/>
<a name="2562"/>   public override restore_value(val)
<a name="2563"/>      set_selection(val)
<a name="2564"/>   end
<a name="2565"/>
<a name="2566"/>   public override create_popup()
<a name="2567"/>      return FormOptionList()
<a name="2568"/>   end
<a name="2569"/>
<a name="2570"/>   public override convert_element(o)
<a name="2571"/>      return o.label
<a name="2572"/>   end
<a name="2573"/>
<a name="2574"/>   public override get_default_width()
<a name="2575"/>      local mw, o
<a name="2576"/>      mw := 0
<a name="2577"/>      every o := !selection_list do
<a name="2578"/>         if \o.value then
<a name="2579"/>            mw &lt;:= view.cbwin.text_width(o.label)
<a name="2580"/>      return border.get_total_width() + b.get_preferred_width() + mw + view.border.get_total_width()
<a name="2581"/>   end
<a name="2582"/>
<a name="2583"/>   public override new(init_val)
<a name="2584"/>      gui.List.new()
<a name="2585"/>      self.init_val := init_val
<a name="2586"/>      return
<a name="2587"/>   end
<a name="2588"/>end
<a name="2589"/>
<a name="2590"/>class Form()
<a name="2591"/>   public const
<a name="2592"/>      id,
<a name="2593"/>      url,
<a name="2594"/>      save_key,
<a name="2595"/>      browser,
<a name="2596"/>      method,
<a name="2597"/>      enctype,
<a name="2598"/>      items,
<a name="2599"/>      labels,
<a name="2600"/>      id_table,
<a name="2601"/>      cbgs
<a name="2602"/>   private readable
<a name="2603"/>      autofocus
<a name="2604"/>
<a name="2605"/>   private make_cgi_table(ev, src)
<a name="2606"/>      local t, k, c, v
<a name="2607"/>      t := table()
<a name="2608"/>      every c := !items do {
<a name="2609"/>         if k := \c.form_name then {
<a name="2610"/>            every v := c.get_form_value(ev, src) do
<a name="2611"/>               inserts(t, k, v)
<a name="2612"/>         }
<a name="2613"/>      }
<a name="2614"/>      return t
<a name="2615"/>   end
<a name="2616"/>
<a name="2617"/>   private make_cgi_message(ev, src)
<a name="2618"/>      local k, v, c, m, mp, m2, fn, mt
<a name="2619"/>      m := Message()
<a name="2620"/>      mp := Multipart()
<a name="2621"/>      every c := !items do {
<a name="2622"/>         if k := \c.form_name then {
<a name="2623"/>            every v := c.get_form_value(ev, src, &amp;yes) do {
<a name="2624"/>               m2 := Message()
<a name="2625"/>               if is(c, FormBrowse) then {
<a name="2626"/>                  fn := c.get_filename()
<a name="2627"/>                  mt := Mime.get_mime_type_for_file(fn) | "application/octet-stream"
<a name="2628"/>                  m2.set_header("Content-Disposition", 
<a name="2629"/>                                "form-data; name=" || RFC822Parser.quote_string(k) || 
<a name="2630"/>                                "; filename=" || RFC822Parser.quote_string(fn))
<a name="2631"/>                  m2.set_header("Content-Type", mt)
<a name="2632"/>               } else 
<a name="2633"/>                  m2.set_header("Content-Disposition", 
<a name="2634"/>                                "form-data; name=" || RFC822Parser.quote_string(k))
<a name="2635"/>               m2.set_decoded_content(v)
<a name="2636"/>               mp.add_part(m2)
<a name="2637"/>            }
<a name="2638"/>         }
<a name="2639"/>      }
<a name="2640"/>      m.set_header("Content-Type", "multipart/form-data")
<a name="2641"/>      m.set_content_object(mp) | syserr("Failed to set_content_object")
<a name="2642"/>      return m
<a name="2643"/>   end
<a name="2644"/>
<a name="2645"/>   public reset_form()
<a name="2646"/>      every (!items).reset_form()
<a name="2647"/>   end
<a name="2648"/>
<a name="2649"/>   public submit(ev, src)
<a name="2650"/>      local c
<a name="2651"/>      \url | fail
<a name="2652"/>      # Validate form.
<a name="2653"/>      every c := !items do
<a name="2654"/>         unless c.validate_form() then {
<a name="2655"/>            if is(c, Component) then
<a name="2656"/>               browser.parent_dialog.set_focus(c.gen_focusable())
<a name="2657"/>            browser.msg("Invalid form: " || &amp;why)
<a name="2658"/>            fail
<a name="2659"/>         }
<a name="2660"/>
<a name="2661"/>      if method == "post" then {
<a name="2662"/>         if Text.lower(enctype) == "multipart/form-data" then
<a name="2663"/>            browser.goto(url, browser.page_url, make_cgi_message(ev, src))
<a name="2664"/>         else 
<a name="2665"/>            browser.goto(url, browser.page_url, make_cgi_table(ev, src))
<a name="2666"/>      } else
<a name="2667"/>         browser.goto(url.with_cgi_parameters(make_cgi_table(ev, src)), browser.page_url)
<a name="2668"/>   end
<a name="2669"/>
<a name="2670"/>   public add(name, item)
<a name="2671"/>      put(items, item)
<a name="2672"/>      item.form_name := name
<a name="2673"/>   end
<a name="2674"/>
<a name="2675"/>   public add_component(context, el, item)
<a name="2676"/>      local l
<a name="2677"/>      put(items, item)
<a name="2678"/>      if el.get_attribute(u"AUTOFOCUS") then
<a name="2679"/>         autofocus := item
<a name="2680"/>      item.form_name := el.get_attribute(u"NAME")
<a name="2681"/>      if item.form_id := el.get_attribute(u"ID") then
<a name="2682"/>         insert(id_table, item.form_id, item)
<a name="2683"/>      item.form_save_key := Class.get_name(item) || u":" || (\item.form_name | \item.form_id | u"?") || u":" || *items
<a name="2684"/>      item.form_tabindex := integer(el.get_attribute(u"TABINDEX"))
<a name="2685"/>      l := context.form_label
<a name="2686"/>      # If we have a label in the context, and the for and id tags
<a name="2687"/>      # make sense, link the component item to the label.
<a name="2688"/>      if \l &amp; (/l.id | /item.form_id | l.id == item.form_id) then
<a name="2689"/>         /l.comp := item
<a name="2690"/>   end
<a name="2691"/>
<a name="2692"/>   public get_item_by_id(id)
<a name="2693"/>      return member(id_table, id)
<a name="2694"/>   end
<a name="2695"/>
<a name="2696"/>   public get_autofocus()
<a name="2697"/>      return \autofocus
<a name="2698"/>   end
<a name="2699"/>
<a name="2700"/>   public get_cbg(name)
<a name="2701"/>      local x
<a name="2702"/>      (x := member(cbgs, name)) | insert(cbgs, name, x := CheckBoxGroup())
<a name="2703"/>      return x
<a name="2704"/>   end
<a name="2705"/>
<a name="2706"/>   public get_tab_children()
<a name="2707"/>      local l, c
<a name="2708"/>      l := []
<a name="2709"/>      every c := !items do {
<a name="2710"/>         if is(c, Component) then {
<a name="2711"/>            if /c.form_tabindex | (c.form_tabindex &gt;= 0) then
<a name="2712"/>               put(l, c)
<a name="2713"/>         }
<a name="2714"/>      }
<a name="2715"/>      return isort(l, tabindex_sort)
<a name="2716"/>   end
<a name="2717"/>
<a name="2718"/>   private tabindex_sort(c)
<a name="2719"/>      return \c.form_tabindex | keyof(items, c)
<a name="2720"/>   end
<a name="2721"/>
<a name="2722"/>   public get_save_key()
<a name="2723"/>      return save_key
<a name="2724"/>   end
<a name="2725"/>
<a name="2726"/>   public resolve_labels()
<a name="2727"/>      local l
<a name="2728"/>      every l := !labels do
<a name="2729"/>         /l.comp := get_item_by_id(\l.id)
<a name="2730"/>   end
<a name="2731"/>
<a name="2732"/>   public new(browser, save_key, id, url, method, enctype)
<a name="2733"/>      self.browser := browser
<a name="2734"/>      self.save_key := save_key
<a name="2735"/>      self.id := id
<a name="2736"/>      self.url := url
<a name="2737"/>      self.method := method
<a name="2738"/>      self.enctype := enctype
<a name="2739"/>      self.items := []
<a name="2740"/>      self.labels := []
<a name="2741"/>      self.id_table := table()
<a name="2742"/>      self.cbgs := table()
<a name="2743"/>      return
<a name="2744"/>   end
<a name="2745"/>end
<a name="2746"/>
<a name="2747"/>package record TableContext(tbl, caption, x, y, occ, cell_border, tr, rowgroups, colgroups, curr_colgroup)
<a name="2748"/>package record TableColGroup(align, valign, width, span, cols)
<a name="2749"/>package record TableCol(align, valign, width, span)
<a name="2750"/>package record ListContext(tbl, index, type, kind)
<a name="2751"/>package record DefListContext(tbl)
<a name="2752"/>package record FieldSetContext(legend)
<a name="2753"/>package record MapContext(map)
<a name="2754"/>package record SelectContext(options, optgroup)
<a name="2755"/>package record DataListContext(options)
<a name="2756"/>package record Context(form, form_label, title, url, fg, font, align, pre, nowrap, underline, strike, underdash, mark,
<a name="2757"/>                       family, size, bold, italic, table, list, def_list, fieldset, select, map, datalist)
<a name="2758"/>
<a name="2759"/>class MapArea()
<a name="2760"/>   public const
<a name="2761"/>      shape, coords, url, title
<a name="2762"/>
<a name="2763"/>   public contains(x, y)
<a name="2764"/>      return case shape of {
<a name="2765"/>         "rect": check_rect(x, y)
<a name="2766"/>         "poly": check_poly(x, y)
<a name="2767"/>         "circle": check_circle(x, y)
<a name="2768"/>         "default": &amp;null
<a name="2769"/>      }
<a name="2770"/>   end
<a name="2771"/>
<a name="2772"/>   private check_rect(x, y)
<a name="2773"/>      succeed (coords[1] &lt;= x &lt;= coords[3]) &amp; (coords[2] &lt;= y &lt;= coords[4])
<a name="2774"/>   end
<a name="2775"/>
<a name="2776"/>   private check_circle(x, y)
<a name="2777"/>      succeed (x - coords[1]) ^ 2 + (y - coords[2]) ^ 2 &lt;= coords[3] ^ 2
<a name="2778"/>   end
<a name="2779"/>
<a name="2780"/>   # Adapted from :-
<a name="2781"/>   # http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
<a name="2782"/>   #
<a name="2783"/>   private check_poly(x, y)
<a name="2784"/>      local i, j, n, c, xi, yi, xj, yj, b1, b2
<a name="2785"/>      if *coords % 2 = 1 | *coords &lt; 6 then
<a name="2786"/>         fail
<a name="2787"/>      j := n := *coords / 2
<a name="2788"/>      c := 0
<a name="2789"/>      every i := 1 to n do {
<a name="2790"/>         xi := coords[2 * i - 1]
<a name="2791"/>         yi := coords[2 * i]
<a name="2792"/>         xj := coords[2 * j - 1]
<a name="2793"/>         yj := coords[2 * j]
<a name="2794"/>         b1 := if yi &gt; y then 1 else 0
<a name="2795"/>         b2 := if yj &gt; y then 1 else 0
<a name="2796"/>         if b1 ~= b2 &amp; (x &lt; (xj - xi) * (y - yi) / (yj - yi) + xi) then
<a name="2797"/>            c +:= 1
<a name="2798"/>         j := i
<a name="2799"/>      }
<a name="2800"/>      succeed c % 2 = 1
<a name="2801"/>   end
<a name="2802"/>
<a name="2803"/>   public new(shape, coords, url, title)
<a name="2804"/>      self.shape := shape
<a name="2805"/>      self.coords := coords
<a name="2806"/>      self.url := url
<a name="2807"/>      self.title := title
<a name="2808"/>      return
<a name="2809"/>   end
<a name="2810"/>end
<a name="2811"/>
<a name="2812"/>class Map()
<a name="2813"/>   private const
<a name="2814"/>      l
<a name="2815"/>
<a name="2816"/>   public gen_areas()
<a name="2817"/>      suspend .!l
<a name="2818"/>   end
<a name="2819"/>
<a name="2820"/>   public which_area(x, y)
<a name="2821"/>      local e
<a name="2822"/>      every e := !l do {
<a name="2823"/>         if e.contains(x, y) then
<a name="2824"/>            return e
<a name="2825"/>      }
<a name="2826"/>   end
<a name="2827"/>
<a name="2828"/>   public add_area(area)
<a name="2829"/>      put(l, area)
<a name="2830"/>      link
<a name="2831"/>   end
<a name="2832"/>
<a name="2833"/>   public new()
<a name="2834"/>      l := []
<a name="2835"/>      return
<a name="2836"/>   end
<a name="2837"/>end
<a name="2838"/>
<a name="2839"/>record HistoryEntry(url,          # URL displayed (on a redirect may differ from that requested) 
<a name="2840"/>                    title,        # Page title
<a name="2841"/>                    referer,      # referer URL
<a name="2842"/>                    form_values,  # Cached values of form components; updated when we move away from the page 
<a name="2843"/>                    form_data,    # POST data used to get the page; on a redirect will always be null
<a name="2844"/>                    focus_index,  # Index of focused component on moving away
<a name="2845"/>                    last_highlight_component_index,  # Child index of last_highlight_component
<a name="2846"/>                    last_highlight_index,            # Index of last_highlight within last_highlight_component
<a name="2847"/>                    last_highlight,                  # Last highlight URL
<a name="2848"/>                    area_x,
<a name="2849"/>                    area_y
<a name="2850"/>                    ) 
<a name="2851"/>
<a name="2852"/>abstract class BrowserUI()
<a name="2853"/>   public abstract msg(s, n)
<a name="2854"/>   public abstract page_loaded()
<a name="2855"/>   public abstract page_fully_loaded()
<a name="2856"/>   public abstract update_grey(gs)
<a name="2857"/>   public abstract link_left_clicked(url)
<a name="2858"/>   public abstract link_middle_clicked(url)
<a name="2859"/>   public abstract create_link_menu(url)
<a name="2860"/>   public abstract create_page_menu()
<a name="2861"/>   public abstract create_image_menu(img)
<a name="2862"/>   public abstract browse_for_file(s)
<a name="2863"/>   public abstract is_visited(url)
<a name="2864"/>   public abstract display_search()
<a name="2865"/>   public abstract display_externally(res)
<a name="2866"/>   public abstract goto_externally(url)
<a name="2867"/>   public abstract save_attachment(file, res)
<a name="2868"/>
<a name="2869"/>   public info_msg(s)
<a name="2870"/>      return msg(s, Gui.INFO_DELAY)
<a name="2871"/>   end
<a name="2872"/>end
<a name="2873"/>
<a name="2874"/>package class BrowserPrimarySelectionOwner(TextSelectionOwner)
<a name="2875"/>   private const parent
<a name="2876"/>
<a name="2877"/>   protected override get_text()
<a name="2878"/>      return \parent.primary
<a name="2879"/>   end
<a name="2880"/>
<a name="2881"/>   public override lost_ownership()
<a name="2882"/>      parent.on_lost_primary_ownership()
<a name="2883"/>   end
<a name="2884"/>
<a name="2885"/>   public new(parent)
<a name="2886"/>      self.parent := parent
<a name="2887"/>      return
<a name="2888"/>   end
<a name="2889"/>end
<a name="2890"/>
<a name="2891"/>record GreyState(prev, nxt, history, refresh, copy_page, save_page, stop, copy_text, copy_links)
<a name="2892"/>
<a name="2893"/>class Browser(ComponentScrollArea, WorkerPoolOwner)
<a name="2894"/>   private
<a name="2895"/>      ui,
<a name="2896"/>      shared_worker_pool_flag,
<a name="2897"/>      maps,
<a name="2898"/>      datalists,
<a name="2899"/>      forms,
<a name="2900"/>      form_tab_children,
<a name="2901"/>      scroll_ticker_interval,
<a name="2902"/>      h_direction,
<a name="2903"/>      v_direction,
<a name="2904"/>      outermost_border
<a name="2905"/>
<a name="2906"/>   private const
<a name="2907"/>      status_ticker,
<a name="2908"/>      scroll_ticker,
<a name="2909"/>      tidy_cache_task,
<a name="2910"/>      primary_selection_owner
<a name="2911"/>
<a name="2912"/>   private readable
<a name="2913"/>      history,
<a name="2914"/>      history_pos,
<a name="2915"/>      history_size,
<a name="2916"/>      curr_history_entry,   # History entry currently being viewed.  Note this may not be history[history_pos]
<a name="2917"/>                            # if we've just done a navigation to a slowly loading page.  It may even be &amp;null
<a name="2918"/>                            # on a new browser or one with a cloned history.
<a name="2919"/>      worker_pool,
<a name="2920"/>      page_url,
<a name="2921"/>      page_data,
<a name="2922"/>      page_name,
<a name="2923"/>      page_title,
<a name="2924"/>      page_links,
<a name="2925"/>      page_base,
<a name="2926"/>      page_resp,
<a name="2927"/>      page_charset,
<a name="2928"/>      page_text_color,
<a name="2929"/>      page_link_color,
<a name="2930"/>      page_alink_color,
<a name="2931"/>      page_vlink_color,
<a name="2932"/>      page_favicon_resp,
<a name="2933"/>      page_favicon_url,
<a name="2934"/>      running,
<a name="2935"/>      primary,
<a name="2936"/>      mark_x,
<a name="2937"/>      mark_y,
<a name="2938"/>      cursor_x,
<a name="2939"/>      cursor_y,
<a name="2940"/>      draw_band,
<a name="2941"/>      banded,
<a name="2942"/>      searched,                # Map of TextOut to list of TextSelection, giving the highlighted
<a name="2943"/>                               # search result elements for each TextOut.
<a name="2944"/>      sorted_searched,         # List of SearchMatch
<a name="2945"/>      highlighted_searched,    # SearchMatch, one of sorted_searched, currently the highlighted search
<a name="2946"/>      searched_term,           # List of words being searched for.
<a name="2947"/>      text_selection,
<a name="2948"/>      links_selection,
<a name="2949"/>      done_set_top_data,
<a name="2950"/>      last_highlight_component,
<a name="2951"/>      font_factor
<a name="2952"/>
<a name="2953"/>   public static const 
<a name="2954"/>      COLORS,
<a name="2955"/>      SIZES,
<a name="2956"/>      SCROLL_INCREMENT,
<a name="2957"/>      DEFAULT_HISTORY_SIZE
<a name="2958"/>
<a name="2959"/>   private static const
<a name="2960"/>      default_font_clone
<a name="2961"/>
<a name="2962"/>   private static init()
<a name="2963"/>      local t
<a name="2964"/>      COLORS := table(,
<a name="2965"/>                      "aliceblue", "#F0F8FF",
<a name="2966"/>                      "antiquewhite", "#FAEBD7",
<a name="2967"/>                      "aqua", "#00FFFF",
<a name="2968"/>                      "aquamarine", "#7FFFD4",
<a name="2969"/>                      "azure", "#F0FFFF",
<a name="2970"/>                      "beige", "#F5F5DC",
<a name="2971"/>                      "bisque", "#FFE4C4",
<a name="2972"/>                      "black", "#000000",
<a name="2973"/>                      "blanchedalmond", "#FFEBCD",
<a name="2974"/>                      "blue", "#0000FF",
<a name="2975"/>                      "blueviolet", "#8A2BE2",
<a name="2976"/>                      "brown", "#A52A2A",
<a name="2977"/>                      "burlywood", "#DEB887",
<a name="2978"/>                      "cadetblue", "#5F9EA0",
<a name="2979"/>                      "chartreuse", "#7FFF00",
<a name="2980"/>                      "chocolate", "#D2691E",
<a name="2981"/>                      "coral", "#FF7F50",
<a name="2982"/>                      "cornflowerblue", "#6495ED",
<a name="2983"/>                      "cornsilk", "#FFF8DC",
<a name="2984"/>                      "crimson", "#DC143C",
<a name="2985"/>                      "cyan", "#00FFFF",
<a name="2986"/>                      "darkblue", "#00008B",
<a name="2987"/>                      "darkcyan", "#008B8B",
<a name="2988"/>                      "darkgoldenrod", "#B8860B",
<a name="2989"/>                      "darkgray", "#A9A9A9",
<a name="2990"/>                      "darkgreen", "#006400",
<a name="2991"/>                      "darkkhaki", "#BDB76B",
<a name="2992"/>                      "darkmagenta", "#8B008B",
<a name="2993"/>                      "darkolivegreen", "#556B2F",
<a name="2994"/>                      "darkorange", "#FF8C00",
<a name="2995"/>                      "darkorchid", "#9932CC",
<a name="2996"/>                      "darkred", "#8B0000",
<a name="2997"/>                      "darksalmon", "#E9967A",
<a name="2998"/>                      "darkseagreen", "#8FBC8F",
<a name="2999"/>                      "darkslateblue", "#483D8B",
<a name="3000"/>                      "darkslategray", "#2F4F4F",
<a name="3001"/>                      "darkturquoise", "#00CED1",
<a name="3002"/>                      "darkviolet", "#9400D3",
<a name="3003"/>                      "deeppink", "#FF1493",
<a name="3004"/>                      "deepskyblue", "#00BFFF",
<a name="3005"/>                      "dimgray", "#696969",
<a name="3006"/>                      "dimgrey", "#696969",
<a name="3007"/>                      "dodgerblue", "#1E90FF",
<a name="3008"/>                      "firebrick", "#B22222",
<a name="3009"/>                      "floralwhite", "#FFFAF0",
<a name="3010"/>                      "forestgreen", "#228B22",
<a name="3011"/>                      "fuchsia", "#FF00FF",
<a name="3012"/>                      "gainsboro", "#DCDCDC",
<a name="3013"/>                      "ghostwhite", "#F8F8FF",
<a name="3014"/>                      "gold", "#FFD700",
<a name="3015"/>                      "goldenrod", "#DAA520",
<a name="3016"/>                      "gray", "#808080",
<a name="3017"/>                      "green", "#008000",
<a name="3018"/>                      "greenyellow", "#ADFF2F",
<a name="3019"/>                      "honeydew", "#F0FFF0",
<a name="3020"/>                      "hotpink", "#FF69B4",
<a name="3021"/>                      "indianred", "#CD5C5C",
<a name="3022"/>                      "indigo", "#4B0082",
<a name="3023"/>                      "ivory", "#FFFFF0",
<a name="3024"/>                      "khaki", "#F0E68C",
<a name="3025"/>                      "lavender", "#E6E6FA",
<a name="3026"/>                      "lavenderblush", "#FFF0F5",
<a name="3027"/>                      "lawngreen", "#7CFC00",
<a name="3028"/>                      "lemonchiffon", "#FFFACD",
<a name="3029"/>                      "lightblue", "#ADD8E6",
<a name="3030"/>                      "lightcoral", "#F08080",
<a name="3031"/>                      "lightcyan", "#E0FFFF",
<a name="3032"/>                      "lightgoldenrodyellow", "#FAFAD2",
<a name="3033"/>                      "lightgray", "#D3D3D3",
<a name="3034"/>                      "lightgreen", "#90EE90",
<a name="3035"/>                      "lightpink", "#FFB6C1",
<a name="3036"/>                      "lightsalmon", "#FFA07A",
<a name="3037"/>                      "lightseagreen", "#20B2AA",
<a name="3038"/>                      "lightskyblue", "#87CEFA",
<a name="3039"/>                      "lightslategray", "#778899",
<a name="3040"/>                      "lightsteelblue", "#B0C4DE",
<a name="3041"/>                      "lightyellow", "#FFFFE0",
<a name="3042"/>                      "lime", "#00FF00",
<a name="3043"/>                      "limegreen", "#32CD32",
<a name="3044"/>                      "linen", "#FAF0E6",
<a name="3045"/>                      "magenta", "#FF00FF",
<a name="3046"/>                      "maroon", "#800000",
<a name="3047"/>                      "mediumaquamarine", "#66CDAA",
<a name="3048"/>                      "mediumblue", "#0000CD",
<a name="3049"/>                      "mediumorchid", "#BA55D3",
<a name="3050"/>                      "mediumpurple", "#9370DB",
<a name="3051"/>                      "mediumseagreen", "#3CB371",
<a name="3052"/>                      "mediumslateblue", "#7B68EE",
<a name="3053"/>                      "mediumspringgreen", "#00FA9A",
<a name="3054"/>                      "mediumturquoise", "#48D1CC",
<a name="3055"/>                      "mediumvioletred", "#C71585",
<a name="3056"/>                      "midnightblue", "#191970",
<a name="3057"/>                      "mintcream", "#F5FFFA",
<a name="3058"/>                      "mistyrose", "#FFE4E1",
<a name="3059"/>                      "moccasin", "#FFE4B5",
<a name="3060"/>                      "navajowhite", "#FFDEAD",
<a name="3061"/>                      "navy", "#000080",
<a name="3062"/>                      "oldlace", "#FDF5E6",
<a name="3063"/>                      "olive", "#808000",
<a name="3064"/>                      "olivedrab", "#6B8E23",
<a name="3065"/>                      "orange", "#FFA500",
<a name="3066"/>                      "orangered", "#FF4500",
<a name="3067"/>                      "orchid", "#DA70D6",
<a name="3068"/>                      "palegoldenrod", "#EEE8AA",
<a name="3069"/>                      "palegreen", "#98FB98",
<a name="3070"/>                      "paleturquoise", "#AFEEEE",
<a name="3071"/>                      "palevioletred", "#DB7093",
<a name="3072"/>                      "papayawhip", "#FFEFD5",
<a name="3073"/>                      "peachpuff", "#FFDAB9",
<a name="3074"/>                      "peru", "#CD853F",
<a name="3075"/>                      "pink", "#FFC0CB",
<a name="3076"/>                      "plum", "#DDA0DD",
<a name="3077"/>                      "powderblue", "#B0E0E6",
<a name="3078"/>                      "purple", "#800080",
<a name="3079"/>                      "red", "#FF0000",
<a name="3080"/>                      "rosybrown", "#BC8F8F",
<a name="3081"/>                      "royalblue", "#4169E1",
<a name="3082"/>                      "saddlebrown", "#8B4513",
<a name="3083"/>                      "salmon", "#FA8072",
<a name="3084"/>                      "sandybrown", "#F4A460",
<a name="3085"/>                      "seagreen", "#2E8B57",
<a name="3086"/>                      "seashell", "#FFF5EE",
<a name="3087"/>                      "sienna", "#A0522D",
<a name="3088"/>                      "silver", "#C0C0C0",
<a name="3089"/>                      "skyblue", "#87CEEB",
<a name="3090"/>                      "slateblue", "#6A5ACD",
<a name="3091"/>                      "slategray", "#708090",
<a name="3092"/>                      "snow", "#FFFAFA",
<a name="3093"/>                      "springgreen", "#00FF7F",
<a name="3094"/>                      "steelblue", "#4682B4",
<a name="3095"/>                      "tan", "#D2B48C",
<a name="3096"/>                      "teal", "#008080",
<a name="3097"/>                      "thistle", "#D8BFD8",
<a name="3098"/>                      "tomato", "#FF6347",
<a name="3099"/>                      "turquoise", "#40E0D0",
<a name="3100"/>                      "violet", "#EE82EE",
<a name="3101"/>                      "wheat", "#F5DEB3",
<a name="3102"/>                      "white", "#FFFFFF",
<a name="3103"/>                      "whitesmoke", "#F5F5F5",
<a name="3104"/>                      "yellow", "#FFFF00",
<a name="3105"/>                      "yellowgreen", "#9ACD32")
<a name="3106"/>
<a name="3107"/>      t := Window.get_default_font_size()
<a name="3108"/>      SIZES := [0.5 * t, 0.75 * t, t, 1.25 * t, 1.5 * t, 1.75 * t, 2.0 * t]
<a name="3109"/>      ImageCache.name_image("rpp.BROKEN_LINK", BROKEN_LINK)
<a name="3110"/>      default_font_clone := new_win().set_font("sans")
<a name="3111"/>      SCROLL_INCREMENT := env_scale("OI_BROWSER_SCROLL_INCREMENT") | scale(20)
<a name="3112"/>      DEFAULT_HISTORY_SIZE := env_int("OI_BROWSER_DEFAULT_HISTORY_SIZE", 0) | 100
<a name="3113"/>   end
<a name="3114"/>
<a name="3115"/>   public get_map(s)
<a name="3116"/>      return member(maps, s)
<a name="3117"/>   end
<a name="3118"/>
<a name="3119"/>   public get_datalist(s)
<a name="3120"/>      return member(datalists, s)
<a name="3121"/>   end
<a name="3122"/>
<a name="3123"/>   public set_last_highlight(c, u)
<a name="3124"/>      if c ~=== \last_highlight_component then
<a name="3125"/>         last_highlight_component.set_last_highlight()
<a name="3126"/>      last_highlight_component := c
<a name="3127"/>      last_highlight_component.set_last_highlight(u)
<a name="3128"/>      link
<a name="3129"/>   end
<a name="3130"/>
<a name="3131"/>   private convert_color(el, name)
<a name="3132"/>      local s
<a name="3133"/>      if s := el.get_attribute(name) then {
<a name="3134"/>         return if s[1] == "#" then
<a name="3135"/>            s
<a name="3136"/>         else
<a name="3137"/>            member(COLORS, Text.lower(trim(string(s))))
<a name="3138"/>      }
<a name="3139"/>   end
<a name="3140"/>
<a name="3141"/>   public override traverse_tab_order()
<a name="3142"/>      coact(self)
<a name="3143"/>      every (!self.form_tab_children).traverse_tab_order()
<a name="3144"/>   end
<a name="3145"/>
<a name="3146"/>   private synch_font(context)
<a name="3147"/>      local s
<a name="3148"/>      s := context.family
<a name="3149"/>      if \context.bold then
<a name="3150"/>         s ||:= ",bold"
<a name="3151"/>      if \context.italic then
<a name="3152"/>         s ||:= ",italic"
<a name="3153"/>      s ||:= "," || (SIZES[context.size] * font_factor)
<a name="3154"/>      context.font := s
<a name="3155"/>   end
<a name="3156"/>
<a name="3157"/>   private status()
<a name="3158"/>      local i, r, s, l
<a name="3159"/>      repeat {
<a name="3160"/>         status_ticker.sleep(200)
<a name="3161"/>         i := worker_pool.count(self)
<a name="3162"/>         if (i &gt; 0) | (i ~=== running) then {
<a name="3163"/>            if i = 0 then {
<a name="3164"/>               info_msg("Done")
<a name="3165"/>               # This flag will be &amp;null if we haven't called
<a name="3166"/>               # set_top_data; this may happen if we cancel a
<a name="3167"/>               # request before downloading the top page data; in
<a name="3168"/>               # that case there is no need to do anything.
<a name="3169"/>               if \done_set_top_data then {
<a name="3170"/>                  done_set_top_data := &amp;null
<a name="3171"/>                  page_fully_loaded()
<a name="3172"/>               }
<a name="3173"/>            } else {
<a name="3174"/>               r := worker_pool.read(self)
<a name="3175"/>               s := i || " running requests"
<a name="3176"/>               if r &gt; 0 then {
<a name="3177"/>                  if l := (0 &lt; worker_pool.length(self)) then
<a name="3178"/>                     s ||:= ", read " || r || " of " || l || " bytes (" || ((r * 100) / l) || "%)"
<a name="3179"/>                  else
<a name="3180"/>                     s ||:= ", read " || r || " bytes"
<a name="3181"/>               }
<a name="3182"/>               msg(s)
<a name="3183"/>            }
<a name="3184"/>            if i ~=== running then {
<a name="3185"/>               running := i
<a name="3186"/>               do_update_grey()
<a name="3187"/>            }
<a name="3188"/>         }
<a name="3189"/>      }
<a name="3190"/>   end
<a name="3191"/>
<a name="3192"/>   public link_left_clicked(url)
<a name="3193"/>      (\ui).link_left_clicked(url)
<a name="3194"/>      link
<a name="3195"/>   end
<a name="3196"/>
<a name="3197"/>   public link_middle_clicked(url)
<a name="3198"/>      (\ui).link_middle_clicked(url)
<a name="3199"/>      link
<a name="3200"/>   end
<a name="3201"/>
<a name="3202"/>   public create_link_menu(url)
<a name="3203"/>      return (\ui).create_link_menu(url)
<a name="3204"/>   end
<a name="3205"/>
<a name="3206"/>   public create_page_menu()
<a name="3207"/>      return (\ui).create_page_menu()
<a name="3208"/>   end
<a name="3209"/>
<a name="3210"/>   public is_visited(url)
<a name="3211"/>      succeed (\ui).is_visited(url)
<a name="3212"/>   end
<a name="3213"/>
<a name="3214"/>   public create_image_menu(img)
<a name="3215"/>      return (\ui).create_image_menu(img)
<a name="3216"/>   end
<a name="3217"/>
<a name="3218"/>   public set_ui(ui)
<a name="3219"/>      self.ui := ui
<a name="3220"/>      link
<a name="3221"/>   end
<a name="3222"/>
<a name="3223"/>   public info_msg(s)
<a name="3224"/>      (\ui).info_msg(s)
<a name="3225"/>      link
<a name="3226"/>   end
<a name="3227"/>
<a name="3228"/>   public msg(s, n)
<a name="3229"/>      (\ui).msg(s, n)
<a name="3230"/>      link
<a name="3231"/>   end
<a name="3232"/>
<a name="3233"/>   public page_loaded()
<a name="3234"/>      (\ui).page_loaded()
<a name="3235"/>      link
<a name="3236"/>   end
<a name="3237"/>
<a name="3238"/>   public update_grey(gs)
<a name="3239"/>      (\ui).update_grey(gs)
<a name="3240"/>      link
<a name="3241"/>   end
<a name="3242"/>
<a name="3243"/>   public override get_authentication(httpc, dom, realm)
<a name="3244"/>      local d
<a name="3245"/>      d := AuthenticationDialog(dom, realm)
<a name="3246"/>      d.show_modal(parent_dialog)
<a name="3247"/>      return \d.result
<a name="3248"/>   end
<a name="3249"/>
<a name="3250"/>   public do_update_grey()
<a name="3251"/>      update_grey(GreyState(No { history_pos &lt; *history },
<a name="3252"/>                            No { history_pos &gt; 1 },
<a name="3253"/>                            Yes{ *history = 0 },
<a name="3254"/>                            Yes{ /curr_history_entry },
<a name="3255"/>                            Yes{ /page_url },
<a name="3256"/>                            Yes{ /page_data },
<a name="3257"/>                            Yes{ running === 0 },
<a name="3258"/>                            Yes{ /text_selection },
<a name="3259"/>                            Yes{ /links_selection }))
<a name="3260"/>      link
<a name="3261"/>   end
<a name="3262"/>
<a name="3263"/>   private page_fully_loaded()
<a name="3264"/>      local xp, yp, f, k
<a name="3265"/>      reset_all_layouts()
<a name="3266"/>      layout()
<a name="3267"/>      invalidate()
<a name="3268"/>      k := page_resp.req.kind
<a name="3269"/>      # Goto named anchor and maybe set focus unless user has started to scroll page
<a name="3270"/>      if get_area_y() = get_area_x() = 0 then {
<a name="3271"/>         # The test for Worker.NORMAL ensures that when we click on a
<a name="3272"/>         # link to a page from within the page itself we reload and go
<a name="3273"/>         # back to the top of the page.
<a name="3274"/>         if yp := (k ~=== Worker.NORMAL &amp; \curr_history_entry.area_y) | (lookup_named_anchor(page_url.get_fragment()) - view.y) then {
<a name="3275"/>            set_area_y(yp)
<a name="3276"/>            if xp := (k ~=== Worker.NORMAL &amp; \curr_history_entry.area_x) then
<a name="3277"/>               set_area_x(xp)
<a name="3278"/>         }
<a name="3279"/>         # If the user has placed the focus in a component in the new
<a name="3280"/>         # page, just ensure it's still visible; otherwise set the
<a name="3281"/>         # focus to any history/autofocus component; this will scroll
<a name="3282"/>         # to the component if necessary (see focus_scroll).  Note
<a name="3283"/>         # that if this browser's tab is not current, then the various
<a name="3284"/>         # focus methods fail and no change to the focus is made.
<a name="3285"/>         if view === (f := parent_dialog.get_focus()).gen_parents() then
<a name="3286"/>            focus_scroll(, f)
<a name="3287"/>         else if k === Worker.NAVIGATE then
<a name="3288"/>            parent_dialog.set_focus(get_nth_focusable(\curr_history_entry.focus_index))
<a name="3289"/>         else {
<a name="3290"/>            if f := (!forms).get_autofocus() then
<a name="3291"/>               parent_dialog.set_focus(f.gen_focusable())
<a name="3292"/>         }
<a name="3293"/>      }
<a name="3294"/>      parent_dialog.resynch_pointer()
<a name="3295"/>      (\ui).page_fully_loaded()
<a name="3296"/>   end
<a name="3297"/>
<a name="3298"/>   private lookup_named_anchor(name)
<a name="3299"/>      local c, yp
<a name="3300"/>      every c := Seq{traverse_postorder()} do
<a name="3301"/>         if is(c,TextFlow) &amp; yp := c.lookup_named_anchor(name) then
<a name="3302"/>            return yp
<a name="3303"/>   end
<a name="3304"/>
<a name="3305"/>   public static limit_text(s, n)
<a name="3306"/>      return gui.limit_text(default_font_clone, s, n)
<a name="3307"/>   end
<a name="3308"/>
<a name="3309"/>   public override initially()
<a name="3310"/>      ComponentScrollArea.initially()
<a name="3311"/>      if /shared_worker_pool_flag then
<a name="3312"/>         worker_pool.initially()
<a name="3313"/>      status_ticker.start()
<a name="3314"/>      tidy_cache_task.start()
<a name="3315"/>      do_update_grey()
<a name="3316"/>   end
<a name="3317"/>
<a name="3318"/>   public override finally()
<a name="3319"/>      ComponentScrollArea.finally()
<a name="3320"/>      if /shared_worker_pool_flag then
<a name="3321"/>         worker_pool.finally()
<a name="3322"/>      else
<a name="3323"/>         worker_pool.cancel_all(self)
<a name="3324"/>      running := 0
<a name="3325"/>      scroll_ticker.stop()
<a name="3326"/>      status_ticker.stop()
<a name="3327"/>      tidy_cache_task.stop()
<a name="3328"/>   end
<a name="3329"/>   
<a name="3330"/>   public do_next()
<a name="3331"/>      local he
<a name="3332"/>      (history_pos &gt; 1) | fail
<a name="3333"/>      he := history[history_pos -:= 1] 
<a name="3334"/>      goto(he.url, he.referer, he.form_data, Worker.NAVIGATE)
<a name="3335"/>      do_update_grey()
<a name="3336"/>      link
<a name="3337"/>   end
<a name="3338"/>
<a name="3339"/>   public do_prev()
<a name="3340"/>      local he
<a name="3341"/>      (history_pos &lt; *history) | fail
<a name="3342"/>      he := history[history_pos +:= 1] 
<a name="3343"/>      goto(he.url, he.referer, he.form_data, Worker.NAVIGATE)
<a name="3344"/>      do_update_grey()
<a name="3345"/>      link
<a name="3346"/>   end
<a name="3347"/>
<a name="3348"/>   public do_jump(he)
<a name="3349"/>      history_pos := keyof(history, he) | fail
<a name="3350"/>      goto(he.url, he.referer, he.form_data, Worker.NAVIGATE)
<a name="3351"/>      do_update_grey()
<a name="3352"/>      link
<a name="3353"/>   end
<a name="3354"/>
<a name="3355"/>   private redo_search()
<a name="3356"/>      local c, i
<a name="3357"/>      \searched_term | fail
<a name="3358"/>      i := keyof(sorted_searched, highlighted_searched)
<a name="3359"/>      clear(searched)
<a name="3360"/>      sorted_searched := []
<a name="3361"/>      every c := Seq{traverse_postorder()} do
<a name="3362"/>         if is(c,TextFlow) then
<a name="3363"/>            c.search(searched_term, searched, sorted_searched)
<a name="3364"/>      qsort(sorted_searched, Point.cmp_yx)
<a name="3365"/>      highlighted_searched := sorted_searched[\i] | &amp;null
<a name="3366"/>   end
<a name="3367"/>
<a name="3368"/>   public do_search(s)
<a name="3369"/>      local c, l
<a name="3370"/>      s := Text.lower(s)
<a name="3371"/>      l := ipl.pdco.List{words(s)}
<a name="3372"/>      if *l &gt; 0 then {
<a name="3373"/>         searched_term := l
<a name="3374"/>         clear(searched)
<a name="3375"/>         sorted_searched := []
<a name="3376"/>         every c := Seq{traverse_postorder()} do
<a name="3377"/>            if is(c,TextFlow) then
<a name="3378"/>               c.search(l, searched, sorted_searched)
<a name="3379"/>         highlighted_searched := &amp;null
<a name="3380"/>         qsort(sorted_searched, Point.cmp_yx)
<a name="3381"/>      } else
<a name="3382"/>         clear_searched()
<a name="3383"/>      refresh()
<a name="3384"/>      link
<a name="3385"/>   end
<a name="3386"/>
<a name="3387"/>   private clear_searched()
<a name="3388"/>      clear(searched)
<a name="3389"/>      searched_term := sorted_searched := highlighted_searched := &amp;null
<a name="3390"/>   end
<a name="3391"/>
<a name="3392"/>   public goto_searched(n)
<a name="3393"/>      local t
<a name="3394"/>      t := (\sorted_searched)[n] | fail
<a name="3395"/>      (\highlighted_searched).textflow.invalidate(highlighted_searched.get_bounds())
<a name="3396"/>      highlighted_searched := t
<a name="3397"/>      highlighted_searched.textflow.invalidate(highlighted_searched.get_bounds())
<a name="3398"/>      ensure_region_visible(convert_to_area(highlighted_searched.get_bounds()).pad(scale(10), scale(30)))
<a name="3399"/>      link
<a name="3400"/>   end
<a name="3401"/>
<a name="3402"/>   private reset_history_pos()
<a name="3403"/>      if history_pos ~=:= keyof(history, curr_history_entry) then
<a name="3404"/>         do_update_grey()
<a name="3405"/>      link
<a name="3406"/>   end
<a name="3407"/>
<a name="3408"/>   public do_stop()
<a name="3409"/>      cancel()
<a name="3410"/>      # Since we may have done a navigate, then stopped it, we may as
<a name="3411"/>      # well reset the history pos back to the thing we're viewing.
<a name="3412"/>      reset_history_pos()
<a name="3413"/>      link
<a name="3414"/>   end
<a name="3415"/>
<a name="3416"/>   public do_refresh()
<a name="3417"/>      \curr_history_entry | fail
<a name="3418"/>      goto(curr_history_entry.url, curr_history_entry.referer, 
<a name="3419"/>           curr_history_entry.form_data, Worker.REFRESH)
<a name="3420"/>      link
<a name="3421"/>   end
<a name="3422"/>
<a name="3423"/>   public browse_for_file(s)
<a name="3424"/>      return (\ui).browse_for_file(s)
<a name="3425"/>   end
<a name="3426"/>
<a name="3427"/>   public display_externally(res)
<a name="3428"/>      return (\ui).display_externally(res)
<a name="3429"/>   end
<a name="3430"/>
<a name="3431"/>   public goto_externally(url)
<a name="3432"/>      return (\ui).goto_externally(url)
<a name="3433"/>   end
<a name="3434"/>
<a name="3435"/>   public save_attachment(file, res)
<a name="3436"/>      return (\ui).save_attachment(file, res)
<a name="3437"/>   end
<a name="3438"/>
<a name="3439"/>   public cancel()
<a name="3440"/>      worker_pool.cancel_all(self)
<a name="3441"/>      link
<a name="3442"/>   end
<a name="3443"/>
<a name="3444"/>   private enqueue(req)
<a name="3445"/>      worker_pool.enqueue(req)
<a name="3446"/>      running := &amp;null
<a name="3447"/>   end
<a name="3448"/>
<a name="3449"/>   private static is_image(ct, s)
<a name="3450"/>      if Text.lower((\ct).type) == "image" then
<a name="3451"/>         return
<a name="3452"/>      succeed match("\x89PNG\x0D\x0A\x1A\x0A" |
<a name="3453"/>                    "\xFF\xD8" |
<a name="3454"/>                    "GIF87a" | "GIF89a", s)
<a name="3455"/>   end
<a name="3456"/>
<a name="3457"/>   private static is_text(ct, s)
<a name="3458"/>      \ct | fail
<a name="3459"/>      if (Text.lower(ct.type) == "text") |
<a name="3460"/>         (Text.lower(ct.type) == "application" &amp; Text.lower(ct.subtype) == "json") then
<a name="3461"/>         return
<a name="3462"/>   end
<a name="3463"/>
<a name="3464"/>   private static is_html(ct, s)
<a name="3465"/>      if Text.lower((\ct).subtype) == "html" then
<a name="3466"/>         return
<a name="3467"/>      s ? {
<a name="3468"/>         while tab(upto('&lt;')) do {
<a name="3469"/>            if caseless_match("&lt;!doctype" | "&lt;html" | "&lt;meta") then
<a name="3470"/>               return
<a name="3471"/>            # Expect html comment (see htmlparser.icn)
<a name="3472"/>            ="&lt;!" | fail
<a name="3473"/>            unless =("&gt;" | "-&gt;" | "--&gt;" | "---&gt;") then {
<a name="3474"/>               ="--"
<a name="3475"/>               tab(find("--&gt;")) | fail
<a name="3476"/>            }
<a name="3477"/>         }
<a name="3478"/>      }
<a name="3479"/>   end
<a name="3480"/>
<a name="3481"/>   private save_form_values()
<a name="3482"/>      local f, c, t1, t2
<a name="3483"/>      t1 := table()
<a name="3484"/>      every f := !forms do {
<a name="3485"/>         t2 := table()
<a name="3486"/>         insert(t1, f.get_save_key(), t2)
<a name="3487"/>         every c := !f.items do
<a name="3488"/>            insert(t2, c.get_save_key(), c.get_save_value())
<a name="3489"/>      }
<a name="3490"/>      curr_history_entry.form_values := t1
<a name="3491"/>   end
<a name="3492"/>
<a name="3493"/>   private restore_last_highlight()
<a name="3494"/>      local c
<a name="3495"/>      if c := get_nth_child(\curr_history_entry.last_highlight_component_index) &amp;
<a name="3496"/>         is(c, HasLastHighlight) &amp;
<a name="3497"/>         c.restore_last_highlight(\curr_history_entry.last_highlight_index, \curr_history_entry.last_highlight) then
<a name="3498"/>         last_highlight_component := c
<a name="3499"/>   end
<a name="3500"/>
<a name="3501"/>   private restore_form_values()
<a name="3502"/>      local f, c, t1, t2
<a name="3503"/>      t1 := \curr_history_entry.form_values | fail
<a name="3504"/>      every f := !forms do {
<a name="3505"/>         if t2 := member(t1, f.get_save_key()) then {
<a name="3506"/>            every c := !f.items do
<a name="3507"/>               c.restore_value(member(t2, c.get_save_key()))
<a name="3508"/>         }
<a name="3509"/>      }
<a name="3510"/>   end
<a name="3511"/>
<a name="3512"/>   public static to_content(s)
<a name="3513"/>      return xml_escape(string(s), '&lt;&amp;')
<a name="3514"/>   end
<a name="3515"/>
<a name="3516"/>   public static to_attr(s)
<a name="3517"/>      return xml_escape(string(s), '\"\'&amp;')
<a name="3518"/>   end
<a name="3519"/>
<a name="3520"/>   public static mk_anchor(url, lim)
<a name="3521"/>      local s1, s2
<a name="3522"/>      /lim := scale(1000)
<a name="3523"/>      s1 := s2 := url.str()
<a name="3524"/>      s2 := limit_text(s2, lim)
<a name="3525"/>      return "&lt;a href=\"" || to_attr(s1) || "\"&gt;" || Browser.to_content(s2) || "&lt;/a&gt;"
<a name="3526"/>   end
<a name="3527"/>
<a name="3528"/>   public static mk_anchor_cell(url, lim)
<a name="3529"/>      return "&lt;td nowrap&gt;" || mk_anchor(url, lim) || "&lt;/td&gt;"
<a name="3530"/>   end
<a name="3531"/>
<a name="3532"/>   private get_nth_focusable(n)
<a name="3533"/>      local c
<a name="3534"/>      every c := view.gen_focusable() do {
<a name="3535"/>         n -:= 1
<a name="3536"/>         if n = 0 then
<a name="3537"/>            return c
<a name="3538"/>      }
<a name="3539"/>   end
<a name="3540"/>
<a name="3541"/>   private get_focusable_index(focus)
<a name="3542"/>      local n, c
<a name="3543"/>      n := 0
<a name="3544"/>      every c := view.gen_focusable() do {
<a name="3545"/>         n +:= 1
<a name="3546"/>         if focus === c then
<a name="3547"/>            return n
<a name="3548"/>      }
<a name="3549"/>   end
<a name="3550"/>
<a name="3551"/>   private get_nth_child(n)
<a name="3552"/>      local c
<a name="3553"/>      every c := Seq{view.traverse_preorder()} do {
<a name="3554"/>         n -:= 1
<a name="3555"/>         if n = 0 then
<a name="3556"/>            return c
<a name="3557"/>      }
<a name="3558"/>   end
<a name="3559"/>
<a name="3560"/>   private get_child_index(child)
<a name="3561"/>      local n, c
<a name="3562"/>      n := 0
<a name="3563"/>      every c := Seq{view.traverse_preorder()} do {
<a name="3564"/>         n +:= 1
<a name="3565"/>         if child === c then
<a name="3566"/>            return n
<a name="3567"/>      }
<a name="3568"/>   end
<a name="3569"/>
<a name="3570"/>   # Set a border around the outermost (top level) `TextFlow`; by
<a name="3571"/>   # default this is a `NullBorder`.
<a name="3572"/>   #
<a name="3573"/>   public set_outermost_border(b)
<a name="3574"/>      self.outermost_border := b
<a name="3575"/>      link
<a name="3576"/>   end
<a name="3577"/>
<a name="3578"/>   # Convert string s to ucs based on charset cs.  If cs is utf-8, or
<a name="3579"/>   # unknown, then just fail (the conversion is done by the caller).
<a name="3580"/>   private static convert_not_utf8(cs, s)
<a name="3581"/>      local i
<a name="3582"/>      Text.lower(cs) ? {
<a name="3583"/>         if ="iso-8859-" &amp; i := integer(tab(many(&amp;digits))) then
<a name="3584"/>            # This fails if i is an invalid number.
<a name="3585"/>            return ISO8859.to_ucs(s, i)
<a name="3586"/>      }
<a name="3587"/>   end
<a name="3588"/>
<a name="3589"/>   private static get_meta_charset(doc)
<a name="3590"/>      local meta, cs, ct
<a name="3591"/>      every meta := doc.get_root_element().search_tree(u"META") do
<a name="3592"/>         if (Text.lower(meta.get_attribute(u"HTTP-EQUIV")) == "content-type" &amp;
<a name="3593"/>                 ct := ContentType.parse_rfc2616(string(meta.get_attribute(u"CONTENT"))) &amp; 
<a name="3594"/>                 cs := ct.get_parameter("charset")) |
<a name="3595"/>             (cs := string(meta.get_attribute(u"CHARSET"))) then 
<a name="3596"/>            return cs
<a name="3597"/>   end
<a name="3598"/>
<a name="3599"/>   private set_top_data(res)
<a name="3600"/>      local doc, s, row, c, cu, id, cs, s2, cd, file
<a name="3601"/>      if \res.err &amp; /res.data then {
<a name="3602"/>         s := "&lt;html&gt;&lt;title&gt;Error&lt;/title&gt;" || 
<a name="3603"/>            "&lt;h1&gt;Error:&lt;/h1&gt;Getting " || mk_anchor(res.url) || "&lt;br&gt;&lt;br&gt;" || res.err || "&lt;/html&gt;"
<a name="3604"/>         page_data := &amp;null
<a name="3605"/>      } else {
<a name="3606"/>         if cd := \res.content_disposition &amp; Text.lower(cd.get_type()) == "attachment" then {
<a name="3607"/>            file := cd.get_filename() | res.fname
<a name="3608"/>            save_attachment(file, res)
<a name="3609"/>            return
<a name="3610"/>         } else if is_html(res.content_type, res.data) then
<a name="3611"/>            s := res.data
<a name="3612"/>         else if is_text(res.content_type, res.data) then
<a name="3613"/>            s := "&lt;html&gt;&lt;title&gt;" || to_content(res.fname) || "&lt;/title&gt;" || 
<a name="3614"/>               "&lt;pre&gt;" || to_content(res.data) || "&lt;/pre&gt;&lt;/html&gt;"
<a name="3615"/>         else if is_image(res.content_type, res.data) then {
<a name="3616"/>            cu := worker_pool.cache.create_url(, res.data, res.fname, res.content_type)
<a name="3617"/>            s := "&lt;html&gt;&lt;title&gt;" || to_content(res.fname) || "&lt;/title&gt;&lt;img src=\"" || to_attr(cu.str()) || "\""
<a name="3618"/>            # Set width and height param if possible; this allows the
<a name="3619"/>            # image to display before any favicon is loaded.
<a name="3620"/>            if id := detect(res.data) then
<a name="3621"/>               s ||:= " width=" || id.width || " height=" || id.height
<a name="3622"/>            s ||:= "/&gt;&lt;/html&gt;"
<a name="3623"/>         } else if display_externally(res) then
<a name="3624"/>            return
<a name="3625"/>         else
<a name="3626"/>            s := "&lt;html&gt;&lt;title&gt;Problem&lt;/title&gt;" || 
<a name="3627"/>               "&lt;h1&gt;Problem:&lt;/h1&gt;Displaying " || mk_anchor(res.url) || "&lt;br&gt;&lt;br&gt;This does not seem to be an HTML or text document or an image, or an externally viewable object&lt;/html&gt;"
<a name="3628"/>         page_data := res.data
<a name="3629"/>      }
<a name="3630"/>      if \curr_history_entry then {
<a name="3631"/>         save_form_values()
<a name="3632"/>         curr_history_entry.area_x := get_area_x()
<a name="3633"/>         curr_history_entry.area_y := get_area_y()
<a name="3634"/>         curr_history_entry.focus_index := get_focusable_index(parent_dialog.get_focus()) | &amp;null
<a name="3635"/>         # Save last highlight stuff
<a name="3636"/>         curr_history_entry.last_highlight_component_index := 
<a name="3637"/>            curr_history_entry.last_highlight_index := curr_history_entry.last_highlight := &amp;null
<a name="3638"/>         if curr_history_entry.last_highlight_component_index := get_child_index(\last_highlight_component) then
<a name="3639"/>            last_highlight_component.save_last_highlight(curr_history_entry)
<a name="3640"/>      }
<a name="3641"/>      set_area_y(0)
<a name="3642"/>      set_area_x(0)
<a name="3643"/>      page_name := res.fname
<a name="3644"/>      page_resp := res
<a name="3645"/>      page_url := res.url
<a name="3646"/>      clear_searched()
<a name="3647"/>      if res.req.kind === Worker.NORMAL &amp;
<a name="3648"/>         not URL.equiv(history[history_pos].url, page_url) then
<a name="3649"/>      {
<a name="3650"/>         every 1 to history_pos - 1 do
<a name="3651"/>            pop(history)
<a name="3652"/>         # Fields are set below
<a name="3653"/>         push(history, HistoryEntry())
<a name="3654"/>         history_pos := 1
<a name="3655"/>         while *history &gt; history_size do
<a name="3656"/>            pull(history)
<a name="3657"/>      }
<a name="3658"/>      curr_history_entry := history[history_pos]
<a name="3659"/>      # Note that the url/form_data may change even on a
<a name="3660"/>      # navigate/refresh, if the server behaved differently (eg
<a name="3661"/>      # redirect instead of error).
<a name="3662"/>      curr_history_entry.url := page_url
<a name="3663"/>      curr_history_entry.referer := res.req.referer
<a name="3664"/>      curr_history_entry.form_data := if URL.equiv(page_url, res.req.url) then res.req.form_data else &amp;null
<a name="3665"/>      do_update_grey()
<a name="3666"/>
<a name="3667"/>      maps := table()
<a name="3668"/>      datalists := table()
<a name="3669"/>      forms := []
<a name="3670"/>      form_tab_children := []
<a name="3671"/>      # Check for content type charset in metadata
<a name="3672"/>      if cs := (\res.content_type).get_parameter("charset") then {
<a name="3673"/>         page_charset := cs || " (from metadata)"
<a name="3674"/>         s2 := convert_not_utf8(cs, s) | Text.liberal_ucs(s)
<a name="3675"/>         doc := HtmlParser().parse(s2)
<a name="3676"/>      } else {
<a name="3677"/>         # No charset info, so assume ucs to start with.
<a name="3678"/>         page_charset := "UTF-8 (assumed)"
<a name="3679"/>         s2 := Text.liberal_ucs(s)
<a name="3680"/>         doc := HtmlParser().parse(s2)
<a name="3681"/>         # Check for meta tag content attribute
<a name="3682"/>         if cs := get_meta_charset(doc) then {
<a name="3683"/>            page_charset := cs || " (from META tag)"
<a name="3684"/>            if s2 := convert_not_utf8(cs, s) then {
<a name="3685"/>               # Our assumption of ucs was wrong, so re-parse.
<a name="3686"/>               doc := HtmlParser().parse(s2)
<a name="3687"/>            }
<a name="3688"/>         }
<a name="3689"/>      }
<a name="3690"/>
<a name="3691"/>      page_base := page_url
<a name="3692"/>      row := TextFlow(self).
<a name="3693"/>         set_border(outermost_border)
<a name="3694"/>      page_favicon_resp := page_favicon_url := page_title := &amp;null
<a name="3695"/>      page_links := []
<a name="3696"/>      page_alink_color := Style.FOCUS_COLOR
<a name="3697"/>      page_vlink_color := "#800080"
<a name="3698"/>      page_link_color := "blue"
<a name="3699"/>      page_text_color := "black"
<a name="3700"/>      c := Context()
<a name="3701"/>      c.family := "sans"
<a name="3702"/>      c.fg := page_text_color
<a name="3703"/>      c.size := 3
<a name="3704"/>      c.align := Align.L
<a name="3705"/>      synch_font(c)
<a name="3706"/>      traverse(doc, row, c)
<a name="3707"/>      if \page_data then
<a name="3708"/>         get_favicon()
<a name="3709"/>      curr_history_entry.title := page_title
<a name="3710"/>      if page_resp.req.kind === Worker.NAVIGATE then
<a name="3711"/>         restore_form_values()
<a name="3712"/>      every form_tab_children |||:= (!forms).get_tab_children()
<a name="3713"/>      set_inner(row)
<a name="3714"/>      layout()
<a name="3715"/>      invalidate()
<a name="3716"/>      last_highlight_component := &amp;null
<a name="3717"/>      if page_resp.req.kind === Worker.NAVIGATE then
<a name="3718"/>         restore_last_highlight()
<a name="3719"/>      parent_dialog.resynch_pointer()
<a name="3720"/>      setup_tabbing()
<a name="3721"/>      page_loaded()
<a name="3722"/>      done_set_top_data := &amp;yes
<a name="3723"/>   end
<a name="3724"/>
<a name="3725"/>   private focus_scroll(e, c)
<a name="3726"/>      local d
<a name="3727"/>      # Try and find a parent component which has this component as
<a name="3728"/>      # its preferred focus (eg a Spin with a TextField); if found
<a name="3729"/>      # then make the (larger) parent visible, rather than the child.
<a name="3730"/>      every d := c.parent.gen_parents() do {
<a name="3731"/>         if d.get_preferred_focus() === c then {
<a name="3732"/>            c := d
<a name="3733"/>            break
<a name="3734"/>         }
<a name="3735"/>      }
<a name="3736"/>      ensure_region_visible(convert_to_area(c).pad(scale(10), scale(30)))
<a name="3737"/>   end
<a name="3738"/>
<a name="3739"/>   private setup_tabbing()
<a name="3740"/>      local c
<a name="3741"/>      every c := Seq{(!self.form_tab_children).traverse_tab_order()} do {
<a name="3742"/>         # Note that c may be hidden (since the browser tab may be not
<a name="3743"/>         # be the current one), so the test is not the same as say in
<a name="3744"/>         # find_focus().
<a name="3745"/>         if c.accepts_focus() &amp; c.is_unshaded() then
<a name="3746"/>            c.connect(focus_scroll, Event.GOT_FOCUS)
<a name="3747"/>      }
<a name="3748"/>   end
<a name="3749"/>
<a name="3750"/>   private mk_link(s)
<a name="3751"/>      return URL(s) | page_base.get_relative(s)
<a name="3752"/>   end
<a name="3753"/>
<a name="3754"/>   private traverse_a(e, p, context)
<a name="3755"/>      local url, c, na
<a name="3756"/>      if na := e.get_attribute(u"NAME") then {
<a name="3757"/>         put(p.input, NamedAnchorCmd(na, context))
<a name="3758"/>         traverse(e, p, context)
<a name="3759"/>      }
<a name="3760"/>      else if url := mk_link(e.get_attribute(u"HREF")) then {
<a name="3761"/>         put(page_links, url)
<a name="3762"/>         c := copy(context)
<a name="3763"/>         c.url := url
<a name="3764"/>         c.fg := if is_visited(url) then page_vlink_color else page_link_color
<a name="3765"/>         traverse(e, p, c)
<a name="3766"/>      } else
<a name="3767"/>         traverse(e, p, context)
<a name="3768"/>   end
<a name="3769"/>
<a name="3770"/>   private check_id(e, p, context)
<a name="3771"/>      local id
<a name="3772"/>      if id := e.get_attribute(u"ID") then
<a name="3773"/>         put(p.input, NamedAnchorCmd(id, context))
<a name="3774"/>   end
<a name="3775"/>
<a name="3776"/>   private traverse_hN(e, p, context)
<a name="3777"/>      local c
<a name="3778"/>      put_para1(e, p, context)
<a name="3779"/>      c := copy(context)
<a name="3780"/>      c.size := 7 - e.name[-1]
<a name="3781"/>      c.bold := &amp;yes
<a name="3782"/>      synch_font(c)
<a name="3783"/>      traverse(e, p, c)
<a name="3784"/>      put_para(p, c)
<a name="3785"/>   end
<a name="3786"/>
<a name="3787"/>   private parse_size(s, curr)
<a name="3788"/>      local i
<a name="3789"/>      i := if any('+\-', s[1]) then
<a name="3790"/>         curr + integer(s)
<a name="3791"/>      else
<a name="3792"/>         integer(s)
<a name="3793"/>      return (0 &lt; \i &lt;= 7, i)
<a name="3794"/>   end
<a name="3795"/>
<a name="3796"/>   private valid_family(fam)
<a name="3797"/>      local w
<a name="3798"/>      return use {
<a name="3799"/>         w := cbwin.clone(),
<a name="3800"/>         w.set_font(fam) &amp; fam
<a name="3801"/>      }
<a name="3802"/>   end
<a name="3803"/>
<a name="3804"/>   private select_family(faces)
<a name="3805"/>      local e
<a name="3806"/>      every e := Text.lower(trim(separate(string(faces)))) do {
<a name="3807"/>         # If we have one of the four standard families (or their html
<a name="3808"/>         # equivalent names), return that.
<a name="3809"/>         if e := case e of {
<a name="3810"/>            "serif": "serif"
<a name="3811"/>            "sans"|"sans-serif": "sans"
<a name="3812"/>            "mono"|"monospace": "mono"
<a name="3813"/>            "typewriter": "typewriter"
<a name="3814"/>         } then
<a name="3815"/>            return e
<a name="3816"/>         # If the face is usable as a family, return it.
<a name="3817"/>         if valid_family(e) then
<a name="3818"/>            return e
<a name="3819"/>      }
<a name="3820"/>      # Having failed with all alternatives, try a mapping of common
<a name="3821"/>      # families based on the last family in the input list.
<a name="3822"/>      if e := case e of {
<a name="3823"/>         "cursive"|"fantasy"|"times"|"times new roman": "serif"
<a name="3824"/>         "helvetica"|"arial": "sans"
<a name="3825"/>         "courier": "typewriter"
<a name="3826"/>      } then
<a name="3827"/>         return e
<a name="3828"/>   end
<a name="3829"/>
<a name="3830"/>   private traverse_font(e, p, context)
<a name="3831"/>      local c
<a name="3832"/>      c := copy(context)
<a name="3833"/>      c.fg := convert_color(e, u"COLOR")
<a name="3834"/>      c.family := select_family(e.get_attribute(u"FACE"))
<a name="3835"/>      c.size := parse_size(e.get_attribute(u"SIZE"), c.size)
<a name="3836"/>      synch_font(c)
<a name="3837"/>      traverse(e, p, c)
<a name="3838"/>   end
<a name="3839"/>
<a name="3840"/>   private traverse_tt(e, p, context)
<a name="3841"/>      local c
<a name="3842"/>      c := copy(context)
<a name="3843"/>      c.family := "mono"
<a name="3844"/>      synch_font(c)
<a name="3845"/>      traverse(e, p, c)
<a name="3846"/>   end
<a name="3847"/>
<a name="3848"/>   private traverse_big(e, p, context)
<a name="3849"/>      local c
<a name="3850"/>      c := copy(context)
<a name="3851"/>      if c.size &lt; 7 then {
<a name="3852"/>         c.size +:= 1
<a name="3853"/>         synch_font(c)
<a name="3854"/>      }
<a name="3855"/>      traverse(e, p, c)
<a name="3856"/>   end
<a name="3857"/>
<a name="3858"/>   private traverse_small(e, p, context)
<a name="3859"/>      local c
<a name="3860"/>      c := copy(context)
<a name="3861"/>      if c.size &gt; 1 then {
<a name="3862"/>         c.size -:= 1
<a name="3863"/>         synch_font(c)
<a name="3864"/>      }
<a name="3865"/>      traverse(e, p, c)
<a name="3866"/>   end
<a name="3867"/>
<a name="3868"/>   private traverse_sup(e, p, context)
<a name="3869"/>      local c
<a name="3870"/>      c := copy(context)
<a name="3871"/>      if c.size &gt; 1 then {
<a name="3872"/>         c.size -:= 1
<a name="3873"/>         synch_font(c)
<a name="3874"/>      }
<a name="3875"/>      put(p.input, SupStartCmd(c))
<a name="3876"/>      traverse(e, p, c)
<a name="3877"/>      put(p.input, SupEndCmd(c))
<a name="3878"/>   end
<a name="3879"/>
<a name="3880"/>   private traverse_sub(e, p, context)
<a name="3881"/>      local c
<a name="3882"/>      c := copy(context)
<a name="3883"/>      if c.size &gt; 1 then {
<a name="3884"/>         c.size -:= 1
<a name="3885"/>         synch_font(c)
<a name="3886"/>      }
<a name="3887"/>      put(p.input, SubStartCmd(c))
<a name="3888"/>      traverse(e, p, c)
<a name="3889"/>      put(p.input, SubEndCmd(c))
<a name="3890"/>   end
<a name="3891"/>
<a name="3892"/>   private traverse_b(e, p, context)
<a name="3893"/>      local c
<a name="3894"/>      c := copy(context)
<a name="3895"/>      c.bold := &amp;yes
<a name="3896"/>      synch_font(c)
<a name="3897"/>      traverse(e, p, c)
<a name="3898"/>   end
<a name="3899"/>
<a name="3900"/>   private traverse_i(e, p, context)
<a name="3901"/>      local c
<a name="3902"/>      c := copy(context)
<a name="3903"/>      c.italic := &amp;yes
<a name="3904"/>      synch_font(c)
<a name="3905"/>      traverse(e, p, c)
<a name="3906"/>   end
<a name="3907"/>
<a name="3908"/>   private traverse_mark(e, p, context)
<a name="3909"/>      local c
<a name="3910"/>      c := copy(context)
<a name="3911"/>      c.mark := &amp;yes
<a name="3912"/>      traverse(e, p, c)
<a name="3913"/>   end
<a name="3914"/>
<a name="3915"/>   private traverse_address(e, p, context)
<a name="3916"/>      local c
<a name="3917"/>      c := copy(context)
<a name="3918"/>      c.italic := &amp;yes
<a name="3919"/>      synch_font(c)
<a name="3920"/>      put_new_row1(e, p, c)
<a name="3921"/>      traverse(e, p, c)
<a name="3922"/>      put_new_row(p, c)
<a name="3923"/>   end
<a name="3924"/>
<a name="3925"/>   private traverse_u(e, p, context)
<a name="3926"/>      local c
<a name="3927"/>      c := copy(context)
<a name="3928"/>      c.underline := &amp;yes
<a name="3929"/>      traverse(e, p, c)
<a name="3930"/>   end
<a name="3931"/>
<a name="3932"/>   private traverse_s(e, p, context)
<a name="3933"/>      local c
<a name="3934"/>      c := copy(context)
<a name="3935"/>      c.strike := &amp;yes
<a name="3936"/>      traverse(e, p, c)
<a name="3937"/>   end
<a name="3938"/>
<a name="3939"/>   private traverse_form(e, p, context)
<a name="3940"/>      local m, c, t, v, url, id, save_key
<a name="3941"/>      m := Text.lower(string(e.get_attribute(u"METHOD"))) | "get"
<a name="3942"/>      t := string(e.get_attribute(u"ENCTYPE")) | "application/x-www-form-urlencoded"
<a name="3943"/>      # The default action is empty string, which resolves to the
<a name="3944"/>      # current page.
<a name="3945"/>      v := e.get_attribute(u"ACTION") | u""
<a name="3946"/>      url := mk_link(v)
<a name="3947"/>      id := e.get_attribute(u"ID" | u"NAME")
<a name="3948"/>      save_key :=  (\id | (\url).ucs() | u"?") || u":" || (*forms + 1)
<a name="3949"/>      c := copy(context)
<a name="3950"/>      c.form := Form(self, save_key, id, url, m, t)
<a name="3951"/>      put(forms, c.form)
<a name="3952"/>      put_new_row1(e, p, c)
<a name="3953"/>      traverse(e, p, c)
<a name="3954"/>      put_new_row(p, c)
<a name="3955"/>      c.form.resolve_labels()
<a name="3956"/>   end
<a name="3957"/>
<a name="3958"/>   private traverse_label(e, p, context)
<a name="3959"/>      local c, l, id
<a name="3960"/>      \context.form | fail
<a name="3961"/>      id := e.get_attribute(u"FOR")
<a name="3962"/>      l := FormLabel(id, context.form)
<a name="3963"/>      put(context.form.labels, l)
<a name="3964"/>      c := copy(context)
<a name="3965"/>      c.form_label := l
<a name="3966"/>      traverse(e, p, c)
<a name="3967"/>   end
<a name="3968"/>
<a name="3969"/>   private dump_forms()
<a name="3970"/>      local f, i
<a name="3971"/>      every f := !forms do {
<a name="3972"/>         every write(to_string(f,3,,1))
<a name="3973"/>         every i := !f.items do {
<a name="3974"/>            write("\t",image(i.form_id), "-&gt;", to_string(i,3,,0))
<a name="3975"/>         }
<a name="3976"/>      }
<a name="3977"/>   end
<a name="3978"/>
<a name="3979"/>   private add_component(p, c, context, align)
<a name="3980"/>      /align := "absbottom"
<a name="3981"/>      put(p.input, ComponentCmd(c, context, align))
<a name="3982"/>      c.set_tooltip(context.title).
<a name="3983"/>         set_fg(context.fg).
<a name="3984"/>         set_font(context.font)
<a name="3985"/>      p.add(c)
<a name="3986"/>   end
<a name="3987"/>
<a name="3988"/>   private traverse_button(e, p, context)
<a name="3989"/>      local q, v, type
<a name="3990"/>      \context.form | fail
<a name="3991"/>      v := e.get_attribute(u"VALUE") | u""
<a name="3992"/>      type := Text.lower(string(e.get_attribute(u"TYPE"))) | "submit"
<a name="3993"/>      q := FormTextFlowButton(context.form, v, type)
<a name="3994"/>      add_form_component(e, p, q, context)
<a name="3995"/>      traverse(e, q.tf, context)
<a name="3996"/>   end
<a name="3997"/>
<a name="3998"/>   private traverse_img(e, p, context)
<a name="3999"/>      local q, url, border, align, map, s, alt, hspace, vspace
<a name="4000"/>      url := mk_link(e.get_attribute(u"SRC")) | fail
<a name="4001"/>      if (s := e.get_attribute(u"USEMAP")) &amp; (s[1] == "#") then
<a name="4002"/>         map := Text.lower(string(s[2:0]))
<a name="4003"/>      alt := e.get_attribute(u"ALT")
<a name="4004"/>      q := Img(self, context, url, alt,, map)
<a name="4005"/>      do_width_param(e, q)
<a name="4006"/>      do_height_param(e, q)
<a name="4007"/>      # % width not allowed if no breaking mode, since it
<a name="4008"/>      # would mean we couldn't calculate the blob widths in
<a name="4009"/>      # the row (and hence the preferred width of the
<a name="4010"/>      # TextFlow).
<a name="4011"/>      if \context.nowrap | \context.pre then
<a name="4012"/>         q.remove_constraint("pct_w")
<a name="4013"/>      border := scale(0 &lt; integer(e.get_attribute(u"BORDER"))) | 0
<a name="4014"/>      hspace := scale(0 &lt; integer(e.get_attribute(u"HSPACE"))) | 0
<a name="4015"/>      vspace := scale(0 &lt; integer(e.get_attribute(u"VSPACE"))) | 0
<a name="4016"/>      if (hspace | vspace) &gt; 0 then {
<a name="4017"/>         if border &gt; 0 then
<a name="4018"/>            q.set_border(CompoundBorder().
<a name="4019"/>                            set_outer(EmptyBorder().set_insets(hspace, hspace, vspace, vspace)).
<a name="4020"/>                            set_inner(ImgPlainBorder().set_line_width(border)))
<a name="4021"/>         else
<a name="4022"/>            q.set_border(EmptyBorder().set_insets(hspace, hspace, vspace, vspace))
<a name="4023"/>      } else if border &gt; 0 then
<a name="4024"/>         q.set_border(ImgPlainBorder().set_line_width(border))
<a name="4025"/>      enqueue(Req(self, url, page_url, q.got_data, page_resp.req.kind))
<a name="4026"/>      align := convert_comp_align(e, u"ALIGN") | Align.B
<a name="4027"/>      add_component(p, q, context, align)
<a name="4028"/>   end
<a name="4029"/>
<a name="4030"/>   private add_form_component(e, p, q, context)
<a name="4031"/>      if e.get_attribute(u"DISABLED") then
<a name="4032"/>         q.set_is_shaded(&amp;yes)
<a name="4033"/>      else
<a name="4034"/>         context.form.add_component(context, e, q)
<a name="4035"/>      add_component(p, q, context, Align.B)
<a name="4036"/>   end
<a name="4037"/>
<a name="4038"/>   private traverse_select(e, p, context)
<a name="4039"/>      local q, c, sc, size, mW, h, w, o, sel, sels, i, mode
<a name="4040"/>      \context.form | fail
<a name="4041"/>      sc := SelectContext()
<a name="4042"/>      sc.options := []
<a name="4043"/>      sc.optgroup := 0
<a name="4044"/>      c := copy(context)
<a name="4045"/>      c.select := sc
<a name="4046"/>      traverse(e, p, c)
<a name="4047"/>      sels := []
<a name="4048"/>      every i := 1 to *sc.options do
<a name="4049"/>         if \sc.options[i].selected then
<a name="4050"/>            put(sels, i)
<a name="4051"/>      if size := (1 &lt; integer(e.get_attribute(u"SIZE"))) then {
<a name="4052"/>         use {
<a name="4053"/>            mW := cbwin.clone(),
<a name="4054"/>            {
<a name="4055"/>               mW.set_font(context.font)
<a name="4056"/>               w := 0
<a name="4057"/>               every o := !sc.options do
<a name="4058"/>                  w &lt;:= mW.text_width(o.txt)
<a name="4059"/>               w +:= 2 * Gui.TEXT_INSET + 2 * Gui.BORDER_WIDTH
<a name="4060"/>               h := (2 * Gui.BORDER_WIDTH + size * mW.get_line_height())
<a name="4061"/>               if size &lt; *sc.options then
<a name="4062"/>                  w +:= ScrollArea.SCROLLBAR_SIZE
<a name="4063"/>            }
<a name="4064"/>         }
<a name="4065"/>         if e.get_attribute(u"MULTIPLE") then
<a name="4066"/>            mode := Select.MANY
<a name="4067"/>         else {
<a name="4068"/>            mode := Select.ONE
<a name="4069"/>            while *sels &gt; 1 do
<a name="4070"/>               pull(sels)
<a name="4071"/>         }
<a name="4072"/>         q := FormOptionList(sels).
<a name="4073"/>            set_contents(sc.options).
<a name="4074"/>            set_size(w, h).
<a name="4075"/>            set_select_mode(mode).
<a name="4076"/>            set_selections(sels)
<a name="4077"/>      } else {
<a name="4078"/>         if *sels = 0 then {
<a name="4079"/>            every i := 1 to *sc.options do
<a name="4080"/>               if \sc.options[i].value then {
<a name="4081"/>                  sel := i
<a name="4082"/>                  break
<a name="4083"/>               }
<a name="4084"/>         } else
<a name="4085"/>            sel := sels[1]
<a name="4086"/>         q := FormList(sel).
<a name="4087"/>            set_selection_list(sc.options).
<a name="4088"/>            set_selection(sel)
<a name="4089"/>      }
<a name="4090"/>      add_form_component(e, p, q, context)
<a name="4091"/>   end
<a name="4092"/>
<a name="4093"/>   private traverse_option(e, p, context)
<a name="4094"/>      local dc, sc, v, txt, label, disabled, selected
<a name="4095"/>      if sc := \context.select then {
<a name="4096"/>         label := e.get_trimmed_string_content()
<a name="4097"/>         if e.get_attribute(u"DISABLED") then
<a name="4098"/>            disabled := &amp;yes
<a name="4099"/>         else {
<a name="4100"/>            v := e.get_attribute(u"VALUE") | label
<a name="4101"/>            if e.get_attribute(u"SELECTED") then
<a name="4102"/>               selected := &amp;yes
<a name="4103"/>         }
<a name="4104"/>         txt := repl(u"    ", sc.optgroup) || label
<a name="4105"/>         put(sc.options, FormOption(txt, label, v, selected, disabled))
<a name="4106"/>      } else if dc := \context.datalist then {
<a name="4107"/>         label := (u"" ~== e.get_trimmed_string_content())
<a name="4108"/>         v := e.get_attribute(u"VALUE")
<a name="4109"/>         /label := v
<a name="4110"/>         /v := label
<a name="4111"/>         if (not e.get_attribute(u"DISABLED")) &amp; \label then
<a name="4112"/>            put(dc.options, FormOption(label, label, v))
<a name="4113"/>      }
<a name="4114"/>   end
<a name="4115"/>
<a name="4116"/>   private traverse_optgroup(e, p, context)
<a name="4117"/>      local sc, label
<a name="4118"/>      sc := \context.select | fail
<a name="4119"/>      label := e.get_attribute(u"LABEL") | u""
<a name="4120"/>      put(sc.options, FormOption(repl(u"    ", sc.optgroup) || u"--- " || label || u" ---", label,,,, &amp;yes))
<a name="4121"/>      sc.optgroup +:= 1
<a name="4122"/>      traverse(e, p, context)
<a name="4123"/>      sc.optgroup -:= 1
<a name="4124"/>   end
<a name="4125"/>
<a name="4126"/>   private traverse_textarea(e, p, context)
<a name="4127"/>      local q, w, h, mW
<a name="4128"/>      \context.form | fail
<a name="4129"/>      use {
<a name="4130"/>         mW := cbwin.clone(),
<a name="4131"/>         {
<a name="4132"/>            mW.set_font(context.font)
<a name="4133"/>            w := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + mW.text_width(repl("x", integer(e.get_attribute(u"COLS"))))) | scale(200)
<a name="4134"/>            h := (2 * Gui.BORDER_WIDTH + integer(e.get_attribute(u"ROWS")) * mW.get_line_height()) | scale(100)
<a name="4135"/>         }
<a name="4136"/>      }
<a name="4137"/>      # The ucs conversion is used here since an empty node will return "" (not u"").
<a name="4138"/>      strip_newlines(e)
<a name="4139"/>      q := FormEditableTextList(ucs(e.get_trimmed_string_content())).
<a name="4140"/>         set_size(w, h)
<a name="4141"/>      if e.get_attribute(u"READONLY") then
<a name="4142"/>         q.set_is_editable(&amp;no)
<a name="4143"/>      add_form_component(e, p, q, context)
<a name="4144"/>   end
<a name="4145"/>
<a name="4146"/>   private traverse_input(e, p, context)
<a name="4147"/>      local q, s, k, v, size, mW, url, checked, align, min, max, step, alt, did
<a name="4148"/>      \context.form | fail
<a name="4149"/>      s := Text.lower(string(e.get_attribute(u"TYPE"))) | "text"
<a name="4150"/>      case s of {
<a name="4151"/>         "file": {
<a name="4152"/>            use {
<a name="4153"/>               mW := cbwin.clone(),
<a name="4154"/>               {
<a name="4155"/>                  mW.set_font(context.font)
<a name="4156"/>                  size := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + mW.text_width(repl("x", integer(e.get_attribute(u"SIZE"))))) | scale(160)
<a name="4157"/>               }
<a name="4158"/>            }
<a name="4159"/>            q := FormBrowse(self, size)
<a name="4160"/>            add_form_component(e, p, q, context)
<a name="4161"/>         }
<a name="4162"/>         "submit" : {
<a name="4163"/>            v := e.get_attribute(u"VALUE")
<a name="4164"/>            if /v | (*v = 0) then
<a name="4165"/>               v := u"Submit"
<a name="4166"/>            q := FormButton(v).
<a name="4167"/>                  connect(context.form.submit, Event.ACTION)
<a name="4168"/>            add_form_component(e, p, q, context)
<a name="4169"/>         }
<a name="4170"/>         "button" : {
<a name="4171"/>            v := e.get_attribute(u"VALUE") | u""
<a name="4172"/>            q := FormButton(v)
<a name="4173"/>            add_form_component(e, p, q, context)
<a name="4174"/>         }
<a name="4175"/>         "image" : {
<a name="4176"/>            if url := mk_link(e.get_attribute(u"SRC")) then {
<a name="4177"/>               alt := e.get_attribute(u"ALT")
<a name="4178"/>               q := Img(self, context, url, alt, context.form)
<a name="4179"/>               do_width_param(e, q)
<a name="4180"/>               do_height_param(e, q)
<a name="4181"/>               # % width not allowed if no breaking mode, since it
<a name="4182"/>               # would mean we couldn't calculate the blob widths in
<a name="4183"/>               # the row (and hence the preferred width of the
<a name="4184"/>               # TextFlow).
<a name="4185"/>               if \context.nowrap | \context.pre then
<a name="4186"/>                  q.remove_constraint("pct_w")
<a name="4187"/>               enqueue(Req(self, url, page_url, q.got_data, page_resp.req.kind))
<a name="4188"/>               if e.get_attribute(u"DISABLED") then
<a name="4189"/>                  q.set_is_shaded(&amp;yes)
<a name="4190"/>               else {
<a name="4191"/>                  if k := e.get_attribute(u"NAME") then {
<a name="4192"/>                     context.form.add(k || ".x", FormImgX(q))
<a name="4193"/>                     context.form.add(k || ".y", FormImgY(q))
<a name="4194"/>                  } else {
<a name="4195"/>                     context.form.add("x", FormImgX(q))
<a name="4196"/>                     context.form.add("y", FormImgY(q))
<a name="4197"/>                  }
<a name="4198"/>               }
<a name="4199"/>               align := convert_comp_align(e, u"ALIGN") | Align.B
<a name="4200"/>               add_component(p, q, context, align)
<a name="4201"/>            }
<a name="4202"/>         }
<a name="4203"/>         "reset" : {
<a name="4204"/>            v := e.get_attribute(u"VALUE")
<a name="4205"/>            if /v | (*v = 0) then
<a name="4206"/>               v := u"Reset"
<a name="4207"/>            q := FormButton(v).
<a name="4208"/>               connect(context.form.reset_form, Event.ACTION)
<a name="4209"/>            add_form_component(e, p, q, context)
<a name="4210"/>         }
<a name="4211"/>         "hidden": {
<a name="4212"/>            context.form.add(e.get_attribute(u"NAME"), Hidden(e.get_attribute(u"VALUE")))
<a name="4213"/>         }
<a name="4214"/>         "radio": {
<a name="4215"/>            v := e.get_attribute(u"VALUE") | u"on"
<a name="4216"/>            checked := Yes{ e.get_attribute(u"CHECKED") }
<a name="4217"/>            q := FormToggle(v, checked).
<a name="4218"/>               set_paint(ImagePaint().set_cache("gui.DIAMOND_UP")).
<a name="4219"/>               set_paint_down(ImagePaint().set_cache("gui.DIAMOND_DOWN")).
<a name="4220"/>               set_border(NullBorder())
<a name="4221"/>            add_form_component(e, p, q, context)
<a name="4222"/>            context.form.get_cbg(e.get_attribute(u"NAME")).add(q)
<a name="4223"/>         }
<a name="4224"/>         "checkbox": {
<a name="4225"/>            v := e.get_attribute(u"VALUE") | u"on"
<a name="4226"/>            checked := Yes{ e.get_attribute(u"CHECKED") }
<a name="4227"/>            q := FormToggle(v, checked).
<a name="4228"/>               set_paint(ImagePaint().set_cache("gui.BOX_UP")).
<a name="4229"/>               set_paint_down(ImagePaint().set_cache("gui.BOX_DOWN")).
<a name="4230"/>               set_border(NullBorder())
<a name="4231"/>            add_form_component(e, p, q, context)
<a name="4232"/>         }
<a name="4233"/>         "date": {
<a name="4234"/>            v := Time.parse(e.get_attribute(u"VALUE"), "yyyy'-'MM'-'dd") | Time()
<a name="4235"/>            q := FormDateField(v)
<a name="4236"/>            add_form_component(e, p, q, context)
<a name="4237"/>         }
<a name="4238"/>         "time": {
<a name="4239"/>            v := FormTimeField.parse(e.get_attribute(u"VALUE")) | Time()
<a name="4240"/>            q := FormTimeField(v)
<a name="4241"/>            add_form_component(e, p, q, context)
<a name="4242"/>         }
<a name="4243"/>         "week": {
<a name="4244"/>            v := FormWeekField.parse(e.get_attribute(u"VALUE")) | Time()
<a name="4245"/>            q := FormWeekField(v)
<a name="4246"/>            add_form_component(e, p, q, context)
<a name="4247"/>         }
<a name="4248"/>         "month": {
<a name="4249"/>            v := FormMonthYearField.parse(e.get_attribute(u"VALUE")) | Time()
<a name="4250"/>            q := FormMonthYearField(v)
<a name="4251"/>            add_form_component(e, p, q, context)
<a name="4252"/>         }
<a name="4253"/>         "datetime": {
<a name="4254"/>            v := FormDateTimeField.parse(e.get_attribute(u"VALUE")) | Time()
<a name="4255"/>            q := FormDateTimeField(v)
<a name="4256"/>            add_form_component(e, p, q, context)
<a name="4257"/>         }
<a name="4258"/>         "datetime-local": {
<a name="4259"/>            v := FormDateTimeLocalField.parse(e.get_attribute(u"VALUE")) | Time()
<a name="4260"/>            q := FormDateTimeLocalField(v)
<a name="4261"/>            add_form_component(e, p, q, context)
<a name="4262"/>         }
<a name="4263"/>         "color": {
<a name="4264"/>            v := FormColorField.parse(e.get_attribute(u"VALUE")) | "white"
<a name="4265"/>            q := FormColorField(v)
<a name="4266"/>            add_form_component(e, p, q, context)
<a name="4267"/>         }
<a name="4268"/>         "range": {
<a name="4269"/>            min := numeric(e.get_attribute(u"MIN")) | 0
<a name="4270"/>            v := e.get_attribute(u"STEP")
<a name="4271"/>            step := if /v then 1 else if Text.lower(v) == "any" then 1.0 else (0 &lt; numeric(v)) | 1
<a name="4272"/>            # If min and step are both integer, then the values must be too.
<a name="4273"/>            if type(min) == type(step) == "integer" then {
<a name="4274"/>               max := integer(e.get_attribute(u"MAX")) | (min + 10)
<a name="4275"/>               v := integer(e.get_attribute(u"VALUE")) | min
<a name="4276"/>            } else {
<a name="4277"/>               min := real(min)
<a name="4278"/>               step := real(step)
<a name="4279"/>               max := real(e.get_attribute(u"MAX")) | (min + 10.0)
<a name="4280"/>               v := real(e.get_attribute(u"VALUE")) | min
<a name="4281"/>            }
<a name="4282"/>            q := FormRange(v).
<a name="4283"/>               set_range(min, max).
<a name="4284"/>               set_snaps(step).
<a name="4285"/>               set_is_horizontal(&amp;yes).
<a name="4286"/>               set_width(160)
<a name="4287"/>            add_form_component(e, p, q, context)
<a name="4288"/>         }
<a name="4289"/>         "number": {
<a name="4290"/>            min := numeric(e.get_attribute(u"MIN"))
<a name="4291"/>            v := e.get_attribute(u"STEP")
<a name="4292"/>            step := if /v then 1 else if Text.lower(v) == "any" then 1.0 else (0 &lt; numeric(v)) | 1
<a name="4293"/>            # If min is null or integer, and step is integer, then the values must be integer too.
<a name="4294"/>            if (/min | type(min) == "integer") &amp; (type(step) == "integer") then {
<a name="4295"/>               max := integer(e.get_attribute(u"MAX"))
<a name="4296"/>               v := integer(e.get_attribute(u"VALUE")) | \min | 0
<a name="4297"/>            } else {
<a name="4298"/>               min := real(min)
<a name="4299"/>               step := real(step)
<a name="4300"/>               max := real(e.get_attribute(u"MAX"))
<a name="4301"/>               v := real(e.get_attribute(u"VALUE")) | \min | 0.0
<a name="4302"/>            }
<a name="4303"/>            q := FormNumberField(v).
<a name="4304"/>               set_range(min, max).
<a name="4305"/>               set_increment_size(step)
<a name="4306"/>            if /max then
<a name="4307"/>               q.set_width(scale(100))
<a name="4308"/>            add_form_component(e, p, q, context)
<a name="4309"/>         }
<a name="4310"/>         "url": {
<a name="4311"/>            v := e.get_attribute(u"VALUE") | u""
<a name="4312"/>            use {
<a name="4313"/>               mW := cbwin.clone(),
<a name="4314"/>               {
<a name="4315"/>                  mW.set_font(context.font)
<a name="4316"/>                  size := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + 
<a name="4317"/>                           mW.text_width(repl("x", integer(e.get_attribute(u"SIZE"))))) | scale(160)
<a name="4318"/>               }
<a name="4319"/>            }
<a name="4320"/>            q := FormURLField(v).
<a name="4321"/>               set_width(size).
<a name="4322"/>               connect(context.form.submit, Event.ACTION)
<a name="4323"/>            if e.get_attribute(u"READONLY") then
<a name="4324"/>               q.set_is_editable(&amp;no)
<a name="4325"/>            q.set_placeholder(e.get_attribute(u"PLACEHOLDER"))
<a name="4326"/>            add_form_component(e, p, q, context)
<a name="4327"/>         }
<a name="4328"/>         # Assume something textual; could be password, text, email etc.
<a name="4329"/>         default: {
<a name="4330"/>            v := e.get_attribute(u"VALUE") | u""
<a name="4331"/>            did := Text.lower(string(e.get_attribute(u"LIST")))
<a name="4332"/>            use {
<a name="4333"/>               mW := cbwin.clone(),
<a name="4334"/>               {
<a name="4335"/>                  mW.set_font(context.font)
<a name="4336"/>                  size := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + 
<a name="4337"/>                           mW.text_width(repl("x", integer(e.get_attribute(u"SIZE"))))) | scale(160)
<a name="4338"/>               }
<a name="4339"/>            }
<a name="4340"/>            q := if /did then
<a name="4341"/>               FormTextField(v)
<a name="4342"/>            else
<a name="4343"/>               FormSuggestField(self, v, did)
<a name="4344"/>            q.set_width(size).
<a name="4345"/>               connect(context.form.submit, Event.ACTION)
<a name="4346"/>            if s == "password" then
<a name="4347"/>               q.set_displaychar("*")
<a name="4348"/>            if e.get_attribute(u"READONLY") then
<a name="4349"/>               q.set_is_editable(&amp;no)
<a name="4350"/>            q.set_placeholder(e.get_attribute(u"PLACEHOLDER"))
<a name="4351"/>            add_form_component(e, p, q, context)
<a name="4352"/>         }
<a name="4353"/>      }
<a name="4354"/>      traverse(e, p, context)
<a name="4355"/>   end
<a name="4356"/>
<a name="4357"/>   private show_parents(c)
<a name="4358"/>      write("chain of ",image(c))
<a name="4359"/>      while \c do {
<a name="4360"/>         write("\tc=",image(c))
<a name="4361"/>         c := c.parent
<a name="4362"/>      }
<a name="4363"/>   end
<a name="4364"/>
<a name="4365"/>   private show_input(ii, l)
<a name="4366"/>      local s,a
<a name="4367"/>      case classof(ii) of {
<a name="4368"/>         TextCmd: {
<a name="4369"/>            s := ii.s
<a name="4370"/>            if *s &gt; 30 then 
<a name="4371"/>               s[30:0] := "...("||*s||")"
<a name="4372"/>            a := ""
<a name="4373"/>            a ||:= "fg="|| \ii.attr.fg
<a name="4374"/>            a ||:= " font="|| \ii.attr.font
<a name="4375"/>            write(repl("   ",l), image(s),"  ",a) 
<a name="4376"/>         }
<a name="4377"/>         ComponentCmd: show_structure(ii.c, l)
<a name="4378"/>         default: write(repl("   ",l),image(ii))
<a name="4379"/>      }
<a name="4380"/>   end
<a name="4381"/>
<a name="4382"/>   private show_output(xo, l)
<a name="4383"/>      local s,a
<a name="4384"/>      s := "Text @"||xo.x||","||xo.y
<a name="4385"/>      s ||:= xo.s
<a name="4386"/>      if *s &gt; 30 then 
<a name="4387"/>         s[30:0] := "...("||*s||")"
<a name="4388"/>      a := ""
<a name="4389"/>      a ||:= "fg="|| \xo.attr.fg
<a name="4390"/>      a ||:= " font="|| \xo.attr.font
<a name="4391"/>      write(repl("   ",l), image(s),"  ",a) 
<a name="4392"/>   end
<a name="4393"/>
<a name="4394"/>   private show_structure(c, l)
<a name="4395"/>      local s, v, short
<a name="4396"/>      /l := 0
<a name="4397"/>      short := s := ""
<a name="4398"/>      short ||:= "w="||\c.w||" h="||\c.h
<a name="4399"/>      if is(c, TextFlow) then short ||:= "  " || *c.input || " items"
<a name="4400"/>      if c.get_constraint("eol") then s ||:= "eol "
<a name="4401"/>      if \c.get_constraint("x_fill") then s ||:= "x_fill "
<a name="4402"/>      if v := c.get_constraint("x_weight") then s ||:= "x_weight=" || v
<a name="4403"/>      if v := c.get_constraint("x_align") then s ||:= "x_align=" || v
<a name="4404"/>      write(repl("   ",l), image(c),short,"\t\t\t",s)
<a name="4405"/>      if is(c, TextFlow) then {
<a name="4406"/>         every show_input((!c.input), l+1)
<a name="4407"/>      } else
<a name="4408"/>         every show_structure((!c.children), l+1)
<a name="4409"/>   end
<a name="4410"/>
<a name="4411"/>   private traverse_div(e, p, context)
<a name="4412"/>      put_new_row1(e, p, context)
<a name="4413"/>      traverse(e, p, context)
<a name="4414"/>   end
<a name="4415"/>
<a name="4416"/>   private traverse_br(e, p, context)
<a name="4417"/>      local clear
<a name="4418"/>      clear := case Text.lower(string(e.get_attribute(u"CLEAR"))) of {
<a name="4419"/>         "left": Align.L
<a name="4420"/>         "right": Align.R
<a name="4421"/>         "all"|"both": "all"
<a name="4422"/>      }
<a name="4423"/>      put(p.input, BreakCmd(clear, context))
<a name="4424"/>   end
<a name="4425"/>
<a name="4426"/>   private traverse_nobr(e, p, context)
<a name="4427"/>      local c
<a name="4428"/>      c := copy(context)
<a name="4429"/>      c.nowrap := &amp;yes
<a name="4430"/>      traverse(e, p, c)
<a name="4431"/>   end
<a name="4432"/>
<a name="4433"/>   private traverse_hr(e, p, context)
<a name="4434"/>      local l, c
<a name="4435"/>      l := Line().
<a name="4436"/>         set_width(1)
<a name="4437"/>      do_width_param(e, l) | l.set_constraint("pct_w", 100)
<a name="4438"/>      c := copy(context)
<a name="4439"/>      put_new_row1(e, p, c)
<a name="4440"/>      c.align := convert_halign(e, u"ALIGN") | Align.C
<a name="4441"/>      add_component(p, l, c)
<a name="4442"/>      put_new_row(p, c)
<a name="4443"/>   end
<a name="4444"/>
<a name="4445"/>   private traverse_q(e, p, context)
<a name="4446"/>      put(p.input, TextCmd(u"\u201c", context))
<a name="4447"/>      traverse(e, p, context)
<a name="4448"/>      put(p.input, TextCmd(u"\u201d", context))
<a name="4449"/>   end
<a name="4450"/>
<a name="4451"/>   private traverse_p(e, p, context)
<a name="4452"/>      local c
<a name="4453"/>      c := copy(context)
<a name="4454"/>      put_para1(e, p, c)
<a name="4455"/>      c.align := convert_halign(e, u"ALIGN")
<a name="4456"/>      traverse(e, p, c)
<a name="4457"/>      put_para(p, c)
<a name="4458"/>   end
<a name="4459"/>
<a name="4460"/>   # Strip optional start and end newlines from the child content
<a name="4461"/>   private static strip_newlines(e)
<a name="4462"/>      local s
<a name="4463"/>      text(e.children[1]) ? {
<a name="4464"/>         if =("\n" | "\r\n") then {
<a name="4465"/>            s := tab(0)
<a name="4466"/>            if *s = 0 then
<a name="4467"/>               delete(e.children, 1)
<a name="4468"/>            else
<a name="4469"/>               e.children[1] := s
<a name="4470"/>         }
<a name="4471"/>      }
<a name="4472"/>      text(e.children[-1]) ? {
<a name="4473"/>         tab(0)
<a name="4474"/>         if (move(-2) == "\r\n") | (move(-1) == "\n") then {
<a name="4475"/>            s := tab(1)
<a name="4476"/>            if *s = 0 then
<a name="4477"/>               delete(e.children, -1)
<a name="4478"/>            else
<a name="4479"/>               e.children[-1] := s
<a name="4480"/>         }
<a name="4481"/>      }
<a name="4482"/>   end
<a name="4483"/>
<a name="4484"/>   private traverse_pre(e, p, context)
<a name="4485"/>      local c
<a name="4486"/>      put_para1(e, p, context)
<a name="4487"/>      c := copy(context)
<a name="4488"/>      c.family := "mono"
<a name="4489"/>      strip_newlines(e)
<a name="4490"/>      synch_font(c)
<a name="4491"/>      c.pre := &amp;yes
<a name="4492"/>      traverse(e, p, c)
<a name="4493"/>      put_para(p, c)
<a name="4494"/>   end
<a name="4495"/>
<a name="4496"/>   private put_para(p, context)
<a name="4497"/>      put(p.input, ParaCmd(context))
<a name="4498"/>   end
<a name="4499"/>
<a name="4500"/>   private put_para1(e, p, context)
<a name="4501"/>      put_para(p, context)
<a name="4502"/>      check_id(e, p, context)
<a name="4503"/>   end
<a name="4504"/>
<a name="4505"/>   private put_new_row(p, context)
<a name="4506"/>      put(p.input, NewRowCmd(context))
<a name="4507"/>   end
<a name="4508"/>
<a name="4509"/>   private put_new_row1(e, p, context)
<a name="4510"/>      put_new_row(p, context)
<a name="4511"/>      check_id(e, p, context)
<a name="4512"/>   end
<a name="4513"/>
<a name="4514"/>   private traverse_center(e, p, context)
<a name="4515"/>      local c
<a name="4516"/>      c := copy(context)
<a name="4517"/>      c.align := Align.C
<a name="4518"/>      put_new_row1(e, p, context)
<a name="4519"/>      traverse(e, p, c)
<a name="4520"/>      put_new_row(p, context)
<a name="4521"/>   end
<a name="4522"/>
<a name="4523"/>   private convert_valign(el, name)
<a name="4524"/>      return case Text.lower(string(el.get_attribute(name))) of {
<a name="4525"/>         "top": Align.T
<a name="4526"/>         "middle": Align.C
<a name="4527"/>         "bottom": Align.B
<a name="4528"/>         "baseline": "baseline"
<a name="4529"/>      }
<a name="4530"/>   end
<a name="4531"/>
<a name="4532"/>   private convert_halign(el, name)
<a name="4533"/>      return case Text.lower(string(el.get_attribute(name))) of {
<a name="4534"/>         "left": Align.L
<a name="4535"/>         "center": Align.C
<a name="4536"/>         "right": Align.R
<a name="4537"/>      }
<a name="4538"/>   end
<a name="4539"/>
<a name="4540"/>   private convert_cap_align(el, name)
<a name="4541"/>      return case Text.lower(string(el.get_attribute(name))) of {
<a name="4542"/>         "left": Align.L
<a name="4543"/>         "right": Align.R
<a name="4544"/>         "top": Align.T
<a name="4545"/>         "bottom": Align.B
<a name="4546"/>      }
<a name="4547"/>   end
<a name="4548"/>
<a name="4549"/>   private convert_comp_align(el, name)
<a name="4550"/>      return case Text.lower(string(el.get_attribute(name))) of {
<a name="4551"/>         "left": Align.L
<a name="4552"/>         "right": Align.R
<a name="4553"/>         "baseline"|"bottom": Align.B
<a name="4554"/>         "texttop"|"top": Align.T
<a name="4555"/>         "middle" | "center" | "centre": Align.C
<a name="4556"/>         "absbottom":  "absbottom"
<a name="4557"/>         "absmiddle":  "absmiddle"
<a name="4558"/>      }
<a name="4559"/>   end
<a name="4560"/>
<a name="4561"/>   private do_width_param(e, c, def_w)
<a name="4562"/>      local width
<a name="4563"/>      return if width := (e.get_attribute(u"WIDTH") | \def_w) then {
<a name="4564"/>         if width := scale(0 &lt;= integer(width)) then
<a name="4565"/>            c.set_constraint("fix_w", width)
<a name="4566"/>         else if width[-1] == "%" &amp; width := (0 &lt;= integer(width[1:-1])) then
<a name="4567"/>            c.set_constraint("pct_w", width)
<a name="4568"/>      }
<a name="4569"/>   end
<a name="4570"/>
<a name="4571"/>   private do_height_param(e, c)
<a name="4572"/>      local height
<a name="4573"/>      if height := scale(0 &lt;= integer(e.get_attribute(u"HEIGHT"))) then
<a name="4574"/>         return c.set_constraint("fix_h", height)
<a name="4575"/>   end
<a name="4576"/>
<a name="4577"/>   private traverse_table(e, p, context)
<a name="4578"/>      local ct, tbl, border, hspace, vspace, cellpadding, cellspacing, cell_border, align, c, i, t
<a name="4579"/>
<a name="4580"/>      tbl := Tbl()
<a name="4581"/>      border := scale(0 &lt; integer(e.get_attribute(u"BORDER"))) | 0
<a name="4582"/>      # hspace, vspace are non-standard, but firefox has them.
<a name="4583"/>      hspace := scale(0 &lt; integer(e.get_attribute(u"HSPACE"))) | 0
<a name="4584"/>      vspace := scale(0 &lt; integer(e.get_attribute(u"VSPACE"))) | 0
<a name="4585"/>      cellpadding := scale(0 &lt; integer(e.get_attribute(u"CELLPADDING"))) | 0
<a name="4586"/>      cellspacing := scale_even(0 &lt;= integer(e.get_attribute(u"CELLSPACING")) | 4)
<a name="4587"/>
<a name="4588"/>      tbl.content.layout_delegate.set_doi(cellspacing).set_dii(cellspacing / 2)
<a name="4589"/>      tbl.set_bg(convert_color(e, u"BGCOLOR"))
<a name="4590"/>
<a name="4591"/>      cell_border := if border &gt; 0 &amp; not(e.get_attribute(u"RULES")) then
<a name="4592"/>         CompoundBorder().
<a name="4593"/>            set_outer(PlainBorder().set_line_width(Gui.FINE_WIDTH)).
<a name="4594"/>            set_inner(EmptyBorder().set_insets(cellpadding, cellpadding, cellpadding, cellpadding))
<a name="4595"/>         else
<a name="4596"/>            EmptyBorder().set_insets(cellpadding, cellpadding, cellpadding, cellpadding)
<a name="4597"/>      # The align param is a bit of a hybrid.  If left or right, then
<a name="4598"/>      # it behaves like a left/right aligned image.  If center, then
<a name="4599"/>      # it is like enclosing the table in &lt;center&gt;.
<a name="4600"/>      align := convert_halign(e, u"ALIGN")
<a name="4601"/>      c := copy(context)
<a name="4602"/>      c.align := (align === Align.C)
<a name="4603"/>      c.table := ct := TableContext()
<a name="4604"/>      ct.tbl := tbl
<a name="4605"/>      ct.x := ct.y := 1
<a name="4606"/>      ct.occ := set()
<a name="4607"/>      ct.cell_border := cell_border
<a name="4608"/>      ct.rowgroups := []
<a name="4609"/>      ct.colgroups := []
<a name="4610"/>      traverse(e, p, c)
<a name="4611"/>      case Text.lower(string(e.get_attribute(u"RULES"))) of {
<a name="4612"/>         "groups": {
<a name="4613"/>            # NB - either of these lists may be empty
<a name="4614"/>            tbl.content.set_hrules(set!ct.rowgroups[2:0])
<a name="4615"/>            tbl.content.set_vrules(set!get_colgroup_cols(ct)[2:0])
<a name="4616"/>         }
<a name="4617"/>         "all": {
<a name="4618"/>            i :=  MaxNN{ (!tbl.content.children).get_constraint("x") }
<a name="4619"/>            tbl.content.set_vrules(Set{2 to i})
<a name="4620"/>            tbl.content.set_hrules(Set{2 to ct.y - 1})
<a name="4621"/>         }
<a name="4622"/>         "cols": {
<a name="4623"/>            i := MaxNN{ (!tbl.content.children).get_constraint("x") }
<a name="4624"/>            tbl.content.set_vrules(Set{2 to i})
<a name="4625"/>         }
<a name="4626"/>         "rows": {
<a name="4627"/>            tbl.content.set_hrules(Set{2 to ct.y - 1})
<a name="4628"/>         }
<a name="4629"/>      }
<a name="4630"/>
<a name="4631"/>      if t := \c.table.caption then {
<a name="4632"/>         if (hspace | vspace) &gt; 0 then
<a name="4633"/>            t.set_border(EmptyBorder().set_insets(hspace, hspace, vspace, vspace))
<a name="4634"/>         if border &gt; 0 then
<a name="4635"/>            tbl.set_border(PlainBorder().set_line_width(border))
<a name="4636"/>      } else {
<a name="4637"/>         if (hspace | vspace) &gt; 0 then {
<a name="4638"/>            if border &gt; 0 then
<a name="4639"/>               tbl.set_border(CompoundBorder().
<a name="4640"/>                              set_outer(EmptyBorder().set_insets(hspace, hspace, vspace, vspace)).
<a name="4641"/>                              set_inner(PlainBorder().set_line_width(border)))
<a name="4642"/>            else
<a name="4643"/>               tbl.set_border(EmptyBorder().set_insets(hspace, hspace, vspace, vspace))
<a name="4644"/>         } else if border &gt; 0 then
<a name="4645"/>            tbl.set_border(PlainBorder().set_line_width(border))
<a name="4646"/>         t := tbl
<a name="4647"/>      }
<a name="4648"/>
<a name="4649"/>      do_width_param(e, t)
<a name="4650"/>      do_height_param(e, t)
<a name="4651"/>
<a name="4652"/>      if align === (Align.L | Align.R) then
<a name="4653"/>         add_component(p, t, c, align)
<a name="4654"/>      else {
<a name="4655"/>         put_new_row1(e, p, c)
<a name="4656"/>         add_component(p, t, c, Align.B)
<a name="4657"/>         put_new_row(p, c)
<a name="4658"/>      }
<a name="4659"/>   end
<a name="4660"/>
<a name="4661"/>   private traverse_tbody(e, p, context)
<a name="4662"/>      local ct
<a name="4663"/>      ct := \context.table | fail
<a name="4664"/>      put(ct.rowgroups, ct.y)
<a name="4665"/>      traverse(e, p, context)
<a name="4666"/>   end
<a name="4667"/>
<a name="4668"/>   private traverse_caption(e, p, context)
<a name="4669"/>      local ct, cap, main, c, align
<a name="4670"/>      ct := \context.table | fail
<a name="4671"/>      /ct.caption | fail
<a name="4672"/>
<a name="4673"/>      # A Tbl with two TextFlows; the caption and another containing just the table itself.
<a name="4674"/>      ct.caption := Tbl()
<a name="4675"/>      cap := TextFlow(self).set_dominant_width(TextFlow.PREFERRED_WIDTH)
<a name="4676"/>      c := copy(context)
<a name="4677"/>      c.align := Align.C
<a name="4678"/>      traverse(e, cap, c)
<a name="4679"/>      main := TextFlow(self)
<a name="4680"/>      add_component(main, ct.tbl, context)
<a name="4681"/>      ct.tbl.set_constraint("pct_w", 100)
<a name="4682"/>      align := convert_cap_align(e, u"ALIGN") | Align.T
<a name="4683"/>      case align of {
<a name="4684"/>         Align.T: {
<a name="4685"/>            cap.set_constraint("eol", &amp;yes)
<a name="4686"/>            ct.caption.content.add(cap).add(main)
<a name="4687"/>         }
<a name="4688"/>         Align.B: {
<a name="4689"/>            main.set_constraint("eol", &amp;yes)
<a name="4690"/>            ct.caption.content.add(main).add(cap)
<a name="4691"/>         }
<a name="4692"/>         Align.L: {
<a name="4693"/>            ct.caption.content.add(cap).add(main)
<a name="4694"/>         }
<a name="4695"/>         Align.R: {
<a name="4696"/>            ct.caption.content.add(main).add(cap)
<a name="4697"/>         }
<a name="4698"/>      }
<a name="4699"/>   end
<a name="4700"/>
<a name="4701"/>   private traverse_colgroup(e, p, context)
<a name="4702"/>      local ct, cg
<a name="4703"/>      ct := \context.table | fail
<a name="4704"/>      cg := TableColGroup()
<a name="4705"/>      cg.span := (0 &lt; integer(e.get_attribute(u"SPAN"))) | 1
<a name="4706"/>      cg.width := e.get_attribute(u"WIDTH")
<a name="4707"/>      cg.valign := convert_valign(e, u"VALIGN")
<a name="4708"/>      cg.align := convert_halign(e, u"ALIGN")
<a name="4709"/>      cg.cols := []
<a name="4710"/>      put(ct.colgroups, cg)
<a name="4711"/>      ct.curr_colgroup := cg
<a name="4712"/>      traverse(e, p, context)
<a name="4713"/>      ct.curr_colgroup := &amp;null
<a name="4714"/>   end
<a name="4715"/>
<a name="4716"/>   private traverse_col(e, p, context)
<a name="4717"/>      local ct, cg, tc
<a name="4718"/>      ct := \context.table | fail
<a name="4719"/>      cg := \ct.curr_colgroup | fail
<a name="4720"/>      tc := TableCol()
<a name="4721"/>      tc.span := (0 &lt; integer(e.get_attribute(u"SPAN"))) | 1
<a name="4722"/>      tc.width := e.get_attribute(u"WIDTH") | cg.width
<a name="4723"/>      tc.valign := convert_valign(e, u"VALIGN") | cg.valign
<a name="4724"/>      tc.align := convert_halign(e, u"ALIGN") | cg.align
<a name="4725"/>      put(cg.cols, tc)
<a name="4726"/>   end
<a name="4727"/>
<a name="4728"/>   private traverse_tr(e, p, context)
<a name="4729"/>      local ct
<a name="4730"/>      ct := \context.table | fail
<a name="4731"/>      ct.tr := e
<a name="4732"/>      if ct.x &gt; 1 then {
<a name="4733"/>         ct.x := 1
<a name="4734"/>         ct.y +:= 1
<a name="4735"/>      }
<a name="4736"/>      traverse(e, p, context)
<a name="4737"/>      if ct.x &gt; 1 then {
<a name="4738"/>         ct.x := 1
<a name="4739"/>         ct.y +:= 1
<a name="4740"/>      }
<a name="4741"/>      ct.tr := &amp;null
<a name="4742"/>   end
<a name="4743"/>
<a name="4744"/>   private get_col_info(ct, n)
<a name="4745"/>      local i, e, f
<a name="4746"/>      i := 0
<a name="4747"/>      every e := !ct.colgroups do {
<a name="4748"/>         if *e.cols &gt; 0 then {
<a name="4749"/>            every f := !e.cols do {
<a name="4750"/>               if i + f.span &gt;= n then
<a name="4751"/>                  return f
<a name="4752"/>               i +:= f.span
<a name="4753"/>            }
<a name="4754"/>         } else {
<a name="4755"/>            if i + e.span &gt;= n then
<a name="4756"/>               return e
<a name="4757"/>            i +:= e.span
<a name="4758"/>         }
<a name="4759"/>      }
<a name="4760"/>   end
<a name="4761"/>
<a name="4762"/>   private get_colgroup_cols(ct)
<a name="4763"/>      local i, e, l
<a name="4764"/>      i := 1
<a name="4765"/>      l := []
<a name="4766"/>      every e := !ct.colgroups do {
<a name="4767"/>         put(l, i)
<a name="4768"/>         if *e.cols &gt; 0 then
<a name="4769"/>            every i +:= (!e.cols).span
<a name="4770"/>         else
<a name="4771"/>            i +:= e.span
<a name="4772"/>      }
<a name="4773"/>      return l
<a name="4774"/>   end
<a name="4775"/>
<a name="4776"/>   private traverse_td(e, p, context)
<a name="4777"/>      local ct, row, c, colspan, rowspan, valign, col, def_w
<a name="4778"/>      ct := \context.table | fail
<a name="4779"/>      while member(ct.occ, ct.x || "," || ct.y) do
<a name="4780"/>         ct.x +:= 1
<a name="4781"/>      col := get_col_info(ct, ct.x)
<a name="4782"/>      valign := convert_valign(e | \ct.tr, u"VALIGN") | \ (\col).valign | Align.C
<a name="4783"/>      row := TextFlow(self).
<a name="4784"/>         set_constraint("x", ct.x). 
<a name="4785"/>         set_constraint("y", ct.y).
<a name="4786"/>         set_border(ct.cell_border).
<a name="4787"/>         set_v_align(valign)
<a name="4788"/>      colspan := (0 &lt; integer(e.get_attribute(u"COLSPAN"))) | 1
<a name="4789"/>      row.set_constraint("w", colspan)
<a name="4790"/>      rowspan := (0 &lt; integer(e.get_attribute(u"ROWSPAN"))) | 1
<a name="4791"/>      row.set_constraint("h", rowspan)
<a name="4792"/>      row.set_bg(convert_color(e | \ct.tr, u"BGCOLOR"))
<a name="4793"/>      every insert(ct.occ, (ct.x to ct.x + colspan - 1) || "," || (ct.y to ct.y + rowspan - 1))
<a name="4794"/>      if colspan = 1 then
<a name="4795"/>         def_w := (\col).width
<a name="4796"/>      do_width_param(e, row, def_w)
<a name="4797"/>      do_height_param(e, row)
<a name="4798"/>      ct.tbl.content.add(row)
<a name="4799"/>
<a name="4800"/>      c := copy(context)
<a name="4801"/>      if e.get_attribute(u"NOWRAP") then
<a name="4802"/>         c.nowrap := &amp;yes
<a name="4803"/>      if e.name == "TH" then {
<a name="4804"/>         c.bold := &amp;yes
<a name="4805"/>         c.size := min(c.size + 1, 7)
<a name="4806"/>         synch_font(c)
<a name="4807"/>         c.align := convert_halign(e | \ct.tr, u"ALIGN") | \ (\col).align | Align.C
<a name="4808"/>      } else
<a name="4809"/>         c.align := convert_halign(e | \ct.tr, u"ALIGN") | \ (\col).align | Align.L
<a name="4810"/>      ct.x +:= colspan
<a name="4811"/>
<a name="4812"/>      traverse(e, row, c)
<a name="4813"/>   end
<a name="4814"/>
<a name="4815"/>   private traverse_list(e, p, context)
<a name="4816"/>      local tbl, lc, c
<a name="4817"/>      tbl := Tbl()
<a name="4818"/>      c := copy(context)
<a name="4819"/>      lc := ListContext()
<a name="4820"/>      lc.tbl := tbl
<a name="4821"/>      lc.index := integer(e.get_attribute(u"START")) | 1
<a name="4822"/>      lc.type := e.get_attribute(u"TYPE")
<a name="4823"/>      lc.kind := e.name
<a name="4824"/>      c.list := lc
<a name="4825"/>      traverse(e, p, c)
<a name="4826"/>      put_new_row1(e, p, c)
<a name="4827"/>      add_component(p, tbl, context, Align.B)
<a name="4828"/>      put_new_row(p, c)
<a name="4829"/>   end
<a name="4830"/>
<a name="4831"/>   private traverse_li(e, p, context)
<a name="4832"/>      local lc, row, val, type, c
<a name="4833"/>      lc := \context.list | fail
<a name="4834"/>      row := TextFlow(self).set_v_align("baseline")
<a name="4835"/>      type := e.get_attribute(u"TYPE") | lc.type
<a name="4836"/>      if lc.kind == "OL" then {
<a name="4837"/>         val := integer(e.get_attribute(u"VALUE")) | lc.index
<a name="4838"/>         if val &gt; 0 then {
<a name="4839"/>            val := case string(type) of {
<a name="4840"/>               "a": Text.lower(alphaseq(val))
<a name="4841"/>               "A": alphaseq(val)
<a name="4842"/>               "i": Text.lower(roman(val))
<a name="4843"/>               "I": roman(val)
<a name="4844"/>            }
<a name="4845"/>         }
<a name="4846"/>         # Integers are right aligned, others left aligned.
<a name="4847"/>         c := copy(context)
<a name="4848"/>         c.align := if default.type(val) == "integer" then Align.R else Align.L
<a name="4849"/>         put(row.input, TextCmd(val || u".\ua0\ua0\ua0", c))
<a name="4850"/>         lc.index +:= 1
<a name="4851"/>      } else {
<a name="4852"/>         /type := "disc"
<a name="4853"/>         val := case Text.lower(string(type)) of {
<a name="4854"/>            "circle": u"o"
<a name="4855"/>            "square": u"\u25ca"
<a name="4856"/>            default: u"\u2022"
<a name="4857"/>         }
<a name="4858"/>         put(row.input, TextCmd(val || u"\ua0\ua0\ua0", context))
<a name="4859"/>      }
<a name="4860"/>      lc.tbl.content.add(row)
<a name="4861"/>      row := TextFlow(self).
<a name="4862"/>         set_trim(&amp;no).
<a name="4863"/>         set_v_align("baseline").
<a name="4864"/>         set_constraint("eol", &amp;yes)
<a name="4865"/>      lc.tbl.content.add(row)
<a name="4866"/>      traverse(e, row, context)
<a name="4867"/>   end
<a name="4868"/>
<a name="4869"/>   private traverse_dl(e, p, context)
<a name="4870"/>      local tbl, dc, c
<a name="4871"/>      tbl := Tbl()
<a name="4872"/>      tbl.content.layout_delegate.set_fix_col1(&amp;yes)
<a name="4873"/>      dc := DefListContext()
<a name="4874"/>      dc.tbl := tbl
<a name="4875"/>      c := copy(context)
<a name="4876"/>      c.def_list := dc
<a name="4877"/>      traverse(e, p, c)
<a name="4878"/>      put_new_row1(e, p, c)
<a name="4879"/>      add_component(p, tbl, context, Align.B)
<a name="4880"/>      put_new_row(p, c)
<a name="4881"/>   end
<a name="4882"/>
<a name="4883"/>   private traverse_dt(e, p, context)
<a name="4884"/>      local dc, row
<a name="4885"/>      dc := \context.def_list | fail
<a name="4886"/>      row := TextFlow(self).
<a name="4887"/>         set_trim(&amp;no).
<a name="4888"/>         set_constraint("eol", &amp;yes).
<a name="4889"/>         set_constraint("w", 2)
<a name="4890"/>      dc.tbl.content.add(row)
<a name="4891"/>      traverse(e, row, context)
<a name="4892"/>   end
<a name="4893"/>
<a name="4894"/>   private traverse_dd(e, p, context)
<a name="4895"/>      local dc, row
<a name="4896"/>      dc := \context.def_list | fail
<a name="4897"/>      row := TextFlow(self).
<a name="4898"/>         set_v_align("baseline").
<a name="4899"/>         set_constraint("eol", &amp;no)
<a name="4900"/>      put(row.input, TextCmd(u"\ua0\ua0\ua0\ua0\ua0", context))
<a name="4901"/>      dc.tbl.content.add(row)
<a name="4902"/>      row := TextFlow(self).
<a name="4903"/>         set_trim(&amp;no).
<a name="4904"/>         set_v_align("baseline").
<a name="4905"/>         set_constraint("eol", &amp;yes)
<a name="4906"/>      dc.tbl.content.add(row)
<a name="4907"/>      traverse(e, row, context)
<a name="4908"/>   end
<a name="4909"/>
<a name="4910"/>   private traverse_blockquote(e, p, context)
<a name="4911"/>      local tbl, row
<a name="4912"/>      put_new_row1(e, p, context)
<a name="4913"/>      tbl := Tbl()
<a name="4914"/>      add_component(p, tbl, context)
<a name="4915"/>      row := TextFlow(self)
<a name="4916"/>      put(row.input, TextCmd(u"\ua0\ua0\ua0\ua0", context))
<a name="4917"/>      tbl.content.add(row)
<a name="4918"/>      row := TextFlow(self).
<a name="4919"/>         set_trim(&amp;no).
<a name="4920"/>         set_constraint("eol", &amp;yes)
<a name="4921"/>      tbl.content.add(row)
<a name="4922"/>      traverse(e, row, context)
<a name="4923"/>      put_new_row(p, context)
<a name="4924"/>   end
<a name="4925"/>
<a name="4926"/>   private traverse_fieldset(e, p, context)
<a name="4927"/>      local tbl, row, c, fc
<a name="4928"/>      put_new_row1(e, p, context)
<a name="4929"/>      tbl := Tbl().set_border(CompoundBorder().
<a name="4930"/>                              set_outer(SunkenBorder().set_line_width(Gui.FINE_WIDTH)).
<a name="4931"/>                              set_inner(EmptyBorder()))
<a name="4932"/>      add_component(p, tbl, context)
<a name="4933"/>      row := TextFlow(self)
<a name="4934"/>      tbl.content.add(row)
<a name="4935"/>      fc := FieldSetContext()
<a name="4936"/>      c := copy(context)
<a name="4937"/>      c.fieldset := fc
<a name="4938"/>      traverse(e, row, c)
<a name="4939"/>      tbl.set_title(\fc.legend)
<a name="4940"/>      put_new_row(p, context)
<a name="4941"/>   end
<a name="4942"/>
<a name="4943"/>   private traverse_legend(e, p, context)
<a name="4944"/>      local fc
<a name="4945"/>      fc := \context.fieldset | fail
<a name="4946"/>      /fc.legend | fail
<a name="4947"/>      fc.legend := TextFlow(self).
<a name="4948"/>         set_dominant_width(TextFlow.MAX_WIDTH)
<a name="4949"/>      traverse(e, fc.legend, context)
<a name="4950"/>   end
<a name="4951"/>
<a name="4952"/>   private traverse_map(e, p, context)
<a name="4953"/>      local c, mc
<a name="4954"/>      mc := MapContext()
<a name="4955"/>      mc.map := ipl.browser.Map()
<a name="4956"/>      c := copy(context)
<a name="4957"/>      c.map := mc
<a name="4958"/>      traverse(e, p, c)
<a name="4959"/>      insert(maps, Text.lower(string(e.get_attribute(u"NAME"))), mc.map)
<a name="4960"/>   end
<a name="4961"/>
<a name="4962"/>   private traverse_datalist(e, p, context)
<a name="4963"/>      local c, dc
<a name="4964"/>      dc := DataListContext()
<a name="4965"/>      dc.options := []
<a name="4966"/>      c := copy(context)
<a name="4967"/>      c.datalist := dc
<a name="4968"/>      traverse(e, p, c)
<a name="4969"/>      insert(datalists, Text.lower(string(e.get_attribute(u"ID"))), dc.options)
<a name="4970"/>   end
<a name="4971"/>
<a name="4972"/>   private traverse_area(e, p, context)
<a name="4973"/>      local mc, coords, h
<a name="4974"/>      mc := \context.map | fail
<a name="4975"/>      coords := []
<a name="4976"/>      every put(coords, scale(integer(separate(e.get_attribute(u"COORDS"), ',; '))))
<a name="4977"/>      # The link attribute is optional.
<a name="4978"/>      h := mk_link(e.get_attribute(u"HREF"))
<a name="4979"/>      mc.map.add_area(MapArea(Text.lower(string(e.get_attribute(u"SHAPE"))), 
<a name="4980"/>                              coords,
<a name="4981"/>                              h,
<a name="4982"/>                              context.title))
<a name="4983"/>   end
<a name="4984"/>
<a name="4985"/>   private traverse_abbr(e, p, context)
<a name="4986"/>      local c
<a name="4987"/>      c := copy(context)
<a name="4988"/>      c.underdash := &amp;yes
<a name="4989"/>      traverse(e, p, c)
<a name="4990"/>   end
<a name="4991"/>
<a name="4992"/>   private traverse_body(e, p, context)
<a name="4993"/>      local c
<a name="4994"/>      c := copy(context)
<a name="4995"/>      c.fg := page_text_color := convert_color(e, u"TEXT")
<a name="4996"/>      page_link_color := convert_color(e, u"LINK")
<a name="4997"/>      page_alink_color := convert_color(e, u"ALINK")
<a name="4998"/>      page_vlink_color := convert_color(e, u"VLINK")
<a name="4999"/>      p.set_bg(convert_color(e, u"BGCOLOR"))
<a name="5000"/>      traverse(e, p, c)
<a name="5001"/>   end
<a name="5002"/>
<a name="5003"/>   private traverse_base(e, p, context)
<a name="5004"/>      page_base := URL(e.get_attribute(u"HREF"))
<a name="5005"/>   end
<a name="5006"/>
<a name="5007"/>   private traverse_wbr(e, p, context)
<a name="5008"/>      put(p.input, WbrCmd(context))
<a name="5009"/>   end
<a name="5010"/>
<a name="5011"/>   private traverse_text(e, p, context)
<a name="5012"/>      put(p.input, TextCmd(e, context))
<a name="5013"/>   end
<a name="5014"/>
<a name="5015"/>   private traverse_title(e, p, context)
<a name="5016"/>      page_title := e.get_trimmed_string_content()
<a name="5017"/>   end
<a name="5018"/>
<a name="5019"/>   private got_favicon(res)
<a name="5020"/>      page_favicon_resp := res
<a name="5021"/>   end
<a name="5022"/>
<a name="5023"/>   private get_favicon()
<a name="5024"/>      if /page_favicon_url then {
<a name="5025"/>         page_url.scheme == ("http" | "https") | fail
<a name="5026"/>         page_favicon_url := clone(page_url).set_path(u"/favicon.ico")
<a name="5027"/>      }
<a name="5028"/>      enqueue(Req(self, page_favicon_url, page_url, got_favicon, page_resp.req.kind))
<a name="5029"/>   end
<a name="5030"/>
<a name="5031"/>   private traverse_link(e, p, context)
<a name="5032"/>      if Text.lower(e.get_attribute(u"REL")) == ("icon" | "shortcut icon") then {
<a name="5033"/>         # Favour png file if available
<a name="5034"/>         if /page_favicon_url | (Text.lower(e.get_attribute(u"TYPE")) == "image/png") then
<a name="5035"/>            page_favicon_url := mk_link(e.get_attribute(u"HREF"))
<a name="5036"/>      }
<a name="5037"/>   end
<a name="5038"/>
<a name="5039"/>   # Convert a "title" attribute into a grid paint string if it
<a name="5040"/>   # contains CR or NL chars; this allows multi-line tooltips.
<a name="5041"/>   private static title_grid(s)
<a name="5042"/>      local t
<a name="5043"/>      if upto('\r\n', s) then {
<a name="5044"/>         t := u".cell\n.x_ialign l\n"
<a name="5045"/>         every t ||:= separate_lines(s) || u"\n.br\n"
<a name="5046"/>         return t
<a name="5047"/>      } else
<a name="5048"/>         return s
<a name="5049"/>   end
<a name="5050"/>
<a name="5051"/>   private traverse(n, p, context)
<a name="5052"/>      local e, title, c
<a name="5053"/>      every e := !n.children do {
<a name="5054"/>         if text(e) then
<a name="5055"/>            traverse_text(e, p, context)
<a name="5056"/>         else if is(e, HtmlElement) then {
<a name="5057"/>            check_id(e, p, context)
<a name="5058"/>            if title := (u"" ~== e.get_attribute(u"TITLE")) then {
<a name="5059"/>               c := copy(context)
<a name="5060"/>               c.title := title_grid(title)
<a name="5061"/>            } else
<a name="5062"/>               c := context
<a name="5063"/>            case string(e.name) of {
<a name="5064"/>               "META"|"SCRIPT"|"STYLE": {}
<a name="5065"/>               "LINK": traverse_link(e, p, c)
<a name="5066"/>               "TITLE": traverse_title(e, p, c)
<a name="5067"/>               "A": traverse_a(e, p, c)
<a name="5068"/>               "FORM": traverse_form(e, p, c)
<a name="5069"/>               "BUTTON": traverse_button(e, p, c)
<a name="5070"/>               "LABEL": traverse_label(e, p, c)
<a name="5071"/>               "FONT": traverse_font(e, p, c)
<a name="5072"/>               "IMG": traverse_img(e, p, c)
<a name="5073"/>               "SELECT": traverse_select(e, p, c)
<a name="5074"/>               "OPTION": traverse_option(e, p, c)
<a name="5075"/>               "OPTGROUP": traverse_optgroup(e, p, c)
<a name="5076"/>               "TEXTAREA": traverse_textarea(e, p, c)
<a name="5077"/>               "INPUT": traverse_input(e, p, c)
<a name="5078"/>               "DIV": traverse_div(e, p, c)
<a name="5079"/>               "BIG": traverse_big(e, p, c)
<a name="5080"/>               "SMALL": traverse_small(e, p, c)
<a name="5081"/>               "SAMP"|"KBD"|"CODE"|"TT": traverse_tt(e, p, c)
<a name="5082"/>               "STRONG"|"DFN"|"B": traverse_b(e, p, c)
<a name="5083"/>               "EM"|"CITE"|"I"|"VAR": traverse_i(e, p, c)
<a name="5084"/>               "MARK": traverse_mark(e, p, c)
<a name="5085"/>               "ADDRESS": traverse_address(e, p, c)
<a name="5086"/>               "BR": traverse_br(e, p, c)
<a name="5087"/>               "NOBR": traverse_nobr(e, p, c)
<a name="5088"/>               "HR": traverse_hr(e, p, c)
<a name="5089"/>               "CENTER": traverse_center(e, p, c)
<a name="5090"/>               "H" || (1 to 6): traverse_hN(e, p, c)
<a name="5091"/>               "TABLE": traverse_table(e, p, c)
<a name="5092"/>               "THEAD"|"TBODY"|"TFOOT": traverse_tbody(e, p, c)
<a name="5093"/>               "CAPTION": traverse_caption(e, p, c)
<a name="5094"/>               "COLGROUP": traverse_colgroup(e, p, c)
<a name="5095"/>               "COL": traverse_col(e, p, c)
<a name="5096"/>               "TR": traverse_tr(e, p, c)
<a name="5097"/>               "TD"|"TH": traverse_td(e, p, c)
<a name="5098"/>               "DIR"|"MENU"|"OL"|"UL": traverse_list(e, p, c)
<a name="5099"/>               "LI": traverse_li(e, p, c)
<a name="5100"/>               "DL": traverse_dl(e, p, c)
<a name="5101"/>               "DT": traverse_dt(e, p, c)
<a name="5102"/>               "DD": traverse_dd(e, p, c)
<a name="5103"/>               "BLOCKQUOTE": traverse_blockquote(e, p, c)
<a name="5104"/>               "P": traverse_p(e, p, c)
<a name="5105"/>               "Q": traverse_q(e, p, c)
<a name="5106"/>               "INS"|"U": traverse_u(e, p, c)
<a name="5107"/>               "DEL"|"STRIKE"|"S": traverse_s(e, p, c)
<a name="5108"/>               "SUP": traverse_sup(e, p, c)
<a name="5109"/>               "SUB": traverse_sub(e, p, c)
<a name="5110"/>               "PLAINTEXT"|"LISTING"|"PRE"|"XMP": traverse_pre(e, p, c)
<a name="5111"/>               "FIELDSET": traverse_fieldset(e, p, c)
<a name="5112"/>               "LEGEND": traverse_legend(e, p, c)
<a name="5113"/>               "MAP": traverse_map(e, p, c)
<a name="5114"/>               "AREA": traverse_area(e, p, c)
<a name="5115"/>               "DATALIST": traverse_datalist(e, p, c)
<a name="5116"/>               "WBR": traverse_wbr(e, p, c)
<a name="5117"/>               "ABBR"|"ACRONYM": traverse_abbr(e, p, c)
<a name="5118"/>               "BASE": traverse_base(e, p, c)
<a name="5119"/>               "BODY": traverse_body(e, p, c)
<a name="5120"/>               default : traverse(e, p, c)
<a name="5121"/>            }
<a name="5122"/>         }
<a name="5123"/>      }
<a name="5124"/>   end
<a name="5125"/>
<a name="5126"/>   #
<a name="5127"/>   # Set a custom `WorkerPool` to use.  This also sets the shared
<a name="5128"/>   # worker pool flag; see `set_shared_worker_pool`.
<a name="5129"/>   #
<a name="5130"/>   public set_worker_pool(worker_pool)
<a name="5131"/>      self.worker_pool := worker_pool
<a name="5132"/>      self.shared_worker_pool_flag := &amp;yes
<a name="5133"/>      link
<a name="5134"/>   end
<a name="5135"/>
<a name="5136"/>   #
<a name="5137"/>   # A flag setting; if set then the worker pool is not initialized
<a name="5138"/>   # and finalized by this component.  By default off.
<a name="5139"/>   #
<a name="5140"/>   public set_shared_worker_pool(s)
<a name="5141"/>      self.shared_worker_pool_flag := need_flag(s)
<a name="5142"/>      link
<a name="5143"/>   end
<a name="5144"/>
<a name="5145"/>   public goto(url, referer, form_data, kind)
<a name="5146"/>      /kind := Worker.NORMAL
<a name="5147"/>      cancel()
<a name="5148"/>      # Anything other than a navigate puts us back at the page we're viewing.
<a name="5149"/>      if kind ~=== Worker.NAVIGATE then
<a name="5150"/>         reset_history_pos()
<a name="5151"/>      goto_externally(url) |
<a name="5152"/>         enqueue(Req(self, url, referer, set_top_data, kind, form_data))
<a name="5153"/>      link
<a name="5154"/>   end
<a name="5155"/>
<a name="5156"/>   private handle_lpress(e)
<a name="5157"/>      parent_dialog.get_held_count() = 1 | fail
<a name="5158"/>      running === 0 | fail
<a name="5159"/>      unless can_lpress(e) then {
<a name="5160"/>         clear_mark()
<a name="5161"/>         fail
<a name="5162"/>      }
<a name="5163"/>      view.inner.invalidate(calculate_banded_rect())
<a name="5164"/>      set_cursor_from_pos(e)
<a name="5165"/>      if \e.shift then {
<a name="5166"/>         /mark_y := cursor_y
<a name="5167"/>         /mark_x := cursor_x
<a name="5168"/>         calculate_banded()
<a name="5169"/>         view.inner.invalidate(get_band_rect())
<a name="5170"/>         view.inner.invalidate(calculate_banded_rect())
<a name="5171"/>      } else {
<a name="5172"/>         mark_x := cursor_x
<a name="5173"/>         mark_y := cursor_y
<a name="5174"/>         clear_selections()
<a name="5175"/>      }
<a name="5176"/>      draw_band := &amp;yes
<a name="5177"/>   end
<a name="5178"/>
<a name="5179"/>   private set_cursor_from_pos(e)
<a name="5180"/>      cursor_x := e.x - view.inner.x
<a name="5181"/>      cursor_y := e.y - view.inner.y
<a name="5182"/>      cursor_x &lt;:= get_area_x()
<a name="5183"/>      cursor_x &gt;:= get_area_x() + view.w - 1
<a name="5184"/>      cursor_y &lt;:= get_area_y()
<a name="5185"/>      cursor_y &gt;:= get_area_y() + view.h - 1
<a name="5186"/>   end
<a name="5187"/>
<a name="5188"/>   private handle_ldrag(e)
<a name="5189"/>      \draw_band | fail
<a name="5190"/>
<a name="5191"/>      view.inner.invalidate(get_band_rect())
<a name="5192"/>      view.inner.invalidate(calculate_banded_rect())
<a name="5193"/>      set_cursor_from_pos(e)
<a name="5194"/>      calculate_banded()
<a name="5195"/>      view.inner.invalidate(get_band_rect())
<a name="5196"/>      view.inner.invalidate(calculate_banded_rect())
<a name="5197"/>
<a name="5198"/>      if cursor_y &gt; 0 &amp; e.y &lt; self.view.y then {
<a name="5199"/>         v_direction := "up"
<a name="5200"/>         check_scroll_ticker(self.view.y - e.y)
<a name="5201"/>      } else if cursor_y &lt; view.inner.h - 1 &amp; e.y &gt;= self.view.y + self.view.h then {
<a name="5202"/>         v_direction := "down"
<a name="5203"/>         check_scroll_ticker(e.y - (self.view.y + self.view.h))
<a name="5204"/>      } else
<a name="5205"/>         v_direction := &amp;null
<a name="5206"/>
<a name="5207"/>      if cursor_x &gt; 0 &amp; e.x &lt; self.view.x then {
<a name="5208"/>         h_direction := "left"
<a name="5209"/>         check_scroll_ticker(self.view.x - e.x)
<a name="5210"/>      } else if cursor_x &lt; view.inner.w - 1 &amp; e.x &gt;= self.view.x + self.view.w then {
<a name="5211"/>         h_direction := "right"
<a name="5212"/>         check_scroll_ticker(e.x - (self.view.x + self.view.w))
<a name="5213"/>      } else
<a name="5214"/>         h_direction := &amp;null
<a name="5215"/>
<a name="5216"/>      if /v_direction &amp; /h_direction then
<a name="5217"/>         scroll_ticker.stop()
<a name="5218"/>   end
<a name="5219"/>
<a name="5220"/>   public get_band_rect()
<a name="5221"/>      local x1, y1, x2, y2
<a name="5222"/>      \mark_x | fail
<a name="5223"/>      # A 1x1 pixel drawn with the "gray" pattern is invisible 50% of
<a name="5224"/>      # the time, so require that we have more than one pixel.
<a name="5225"/>      if mark_x = cursor_x &amp; mark_y = cursor_y then
<a name="5226"/>         fail
<a name="5227"/>      y1 := mark_y
<a name="5228"/>      y2 := cursor_y
<a name="5229"/>      if y2 &lt; y1 then
<a name="5230"/>         y1 :=: y2
<a name="5231"/>      x1 := mark_x
<a name="5232"/>      x2 := cursor_x
<a name="5233"/>      if x2 &lt; x1 then
<a name="5234"/>         x1 :=: x2
<a name="5235"/>      return Rect(view.inner.x + x1, view.inner.y + y1, x2 - x1 + 1, y2 - y1 + 1)
<a name="5236"/>   end
<a name="5237"/>
<a name="5238"/>   public override layout()
<a name="5239"/>      ComponentScrollArea.layout()
<a name="5240"/>      clear_mark()
<a name="5241"/>      clear_selections()
<a name="5242"/>      redo_search()
<a name="5243"/>      scroll_ticker.stop()
<a name="5244"/>   end
<a name="5245"/>
<a name="5246"/>   public override display()
<a name="5247"/>      local W, r
<a name="5248"/>      ComponentScrollArea.display()
<a name="5249"/>      if \draw_band &amp; r := get_band_rect() then {
<a name="5250"/>         use {
<a name="5251"/>            W := view.cbwin.clone(),
<a name="5252"/>            W.set_fg("purple").
<a name="5253"/>              set_masked_pattern("gray").
<a name="5254"/>              draw_rectangle(r.x, r.y, r.w, r.h, Gui.FINE_WIDTH)
<a name="5255"/>         }
<a name="5256"/>      }
<a name="5257"/>   end
<a name="5258"/>
<a name="5259"/>   package check_scroll_ticker(d)
<a name="5260"/>      scroll_ticker_interval := Gui.style.distance2ticker_rate(d)
<a name="5261"/>      scroll_ticker.change_time(scroll_ticker_interval)
<a name="5262"/>      # Start it (if it isn't already running)
<a name="5263"/>      scroll_ticker.start()
<a name="5264"/>   end
<a name="5265"/>
<a name="5266"/>   package is_banded(o)
<a name="5267"/>      return member(banded, o)
<a name="5268"/>   end
<a name="5269"/>
<a name="5270"/>   package is_searched(o)
<a name="5271"/>      suspend !member(searched, o)
<a name="5272"/>   end
<a name="5273"/>
<a name="5274"/>   private tidy_cache()
<a name="5275"/>      repeat {
<a name="5276"/>         worker_pool.cache.tidy()
<a name="5277"/>         tidy_cache_task.sleep(15000)
<a name="5278"/>      }
<a name="5279"/>   end
<a name="5280"/>
<a name="5281"/>   private scroll_tick()
<a name="5282"/>      local f
<a name="5283"/>      repeat {
<a name="5284"/>         f := &amp;null
<a name="5285"/>         case v_direction of {
<a name="5286"/>            "up": {
<a name="5287"/>               if cursor_y &gt; 0 then {
<a name="5288"/>                  cursor_y := max(0, cursor_y - SCROLL_INCREMENT)
<a name="5289"/>                  set_area_y(cursor_y)
<a name="5290"/>                  f := &amp;yes
<a name="5291"/>               }
<a name="5292"/>            }
<a name="5293"/>            "down": {
<a name="5294"/>               if cursor_y &lt; view.inner.h - 1 then {
<a name="5295"/>                  cursor_y := min(view.inner.h - 1, cursor_y + SCROLL_INCREMENT)
<a name="5296"/>                  set_area_y(cursor_y - view.h + 1)
<a name="5297"/>                  f := &amp;yes
<a name="5298"/>               }
<a name="5299"/>            }
<a name="5300"/>         }
<a name="5301"/>         case h_direction of {
<a name="5302"/>            "left": {
<a name="5303"/>               if cursor_x &gt; 0 then {
<a name="5304"/>                  cursor_x := max(0, cursor_x - SCROLL_INCREMENT)
<a name="5305"/>                  set_area_x(cursor_x)
<a name="5306"/>                  f := &amp;yes
<a name="5307"/>               }
<a name="5308"/>            }
<a name="5309"/>            "right": {
<a name="5310"/>               if cursor_x &lt; view.inner.w - 1 then {
<a name="5311"/>                  cursor_x := min(view.inner.w - 1, cursor_x + SCROLL_INCREMENT)
<a name="5312"/>                  set_area_x(cursor_x - view.w + 1)
<a name="5313"/>                  f := &amp;yes
<a name="5314"/>               }
<a name="5315"/>            }
<a name="5316"/>         }
<a name="5317"/>         if \f then
<a name="5318"/>            calculate_banded()
<a name="5319"/>
<a name="5320"/>         scroll_ticker.sleep(scroll_ticker_interval)
<a name="5321"/>      }
<a name="5322"/>   end
<a name="5323"/>
<a name="5324"/>   private clear_mark()
<a name="5325"/>      mark_x := mark_y := &amp;null
<a name="5326"/>   end
<a name="5327"/>
<a name="5328"/>   private clear_selections()
<a name="5329"/>      clear(banded)
<a name="5330"/>      text_selection := links_selection := &amp;null
<a name="5331"/>      do_update_grey()
<a name="5332"/>   end
<a name="5333"/>
<a name="5334"/>   package on_lost_primary_ownership()
<a name="5335"/>      clear_mark()
<a name="5336"/>      view.inner.invalidate(calculate_banded_rect())
<a name="5337"/>      clear_selections()
<a name="5338"/>      primary := &amp;null
<a name="5339"/>   end
<a name="5340"/>
<a name="5341"/>   private calculate_banded()
<a name="5342"/>      local c, br
<a name="5343"/>      clear(banded)
<a name="5344"/>      br := get_band_rect() | fail
<a name="5345"/>      every c := Seq{traverse_intersecting(view.inner, br)} do {
<a name="5346"/>         if is(c, TextFlow) then
<a name="5347"/>            c.calculate_banded(br, banded)
<a name="5348"/>         else if is(c, Img) then
<a name="5349"/>            insert(banded, c, c)
<a name="5350"/>      }
<a name="5351"/>   end
<a name="5352"/>
<a name="5353"/>   private static traverse_intersecting(c, r)
<a name="5354"/>      r := c.intersect(r) | fail
<a name="5355"/>      coact(c)
<a name="5356"/>      if is(c, TblContent) then
<a name="5357"/>         every traverse_intersecting(c.layout_delegate.computed_g.cells_in_range(r.y - c.y, r.h).obj, r)
<a name="5358"/>      else
<a name="5359"/>         every traverse_intersecting(!c.children, r)
<a name="5360"/>   end
<a name="5361"/>
<a name="5362"/>   private show_bounds()
<a name="5363"/>      local c
<a name="5364"/>      every c := !banded do {
<a name="5365"/>         if is(c, TextSelection) then
<a name="5366"/>            write(image(c), " -&gt; ", to_string(c.get_bounds()))
<a name="5367"/>      }
<a name="5368"/>   end
<a name="5369"/>
<a name="5370"/>   private calculate_banded_rect()
<a name="5371"/>      local c, t, r
<a name="5372"/>      every c := !banded do {
<a name="5373"/>         t := if is(c, TextSelection) then
<a name="5374"/>            c.get_bounds()
<a name="5375"/>         else if is(c, Img) then
<a name="5376"/>            c
<a name="5377"/>         r := (\r).union(t) | t
<a name="5378"/>      }
<a name="5379"/>      return \r
<a name="5380"/>   end
<a name="5381"/>
<a name="5382"/>   # This is used to forward an in chain event to Imgs and TextFlows
<a name="5383"/>   # in the point chain.  The reason they don't simply listen
<a name="5384"/>   # themselves is that they would then process the event in the wrong
<a name="5385"/>   # order.  Since the bottom components come last (ie the base
<a name="5386"/>   # TextFlow), when the mouse leaves a link in the top-level and
<a name="5387"/>   # moves to a link in another TextFlow (above the base one), the
<a name="5388"/>   # base TextFlow would process the event last, and would clear the
<a name="5389"/>   # UI message, overwriting the new message written by the upper
<a name="5390"/>   # level link.  So this traverses the point chain backwards, which
<a name="5391"/>   # is the correct order for this case.
<a name="5392"/>   #
<a name="5393"/>   private handle_in_chain(e)
<a name="5394"/>      local c
<a name="5395"/>      every c := back(parent_dialog.get_point_chain()) do {
<a name="5396"/>         if is(c, Img | TextFlow) then
<a name="5397"/>            c.handle_in_chain(e)
<a name="5398"/>      }
<a name="5399"/>   end
<a name="5400"/>
<a name="5401"/>   public get_current_text_selection()
<a name="5402"/>      return \.text_selection
<a name="5403"/>   end
<a name="5404"/>
<a name="5405"/>   private calculate_text_selection()
<a name="5406"/>      local br, s, c, l, e, y1
<a name="5407"/>      text_selection := &amp;null
<a name="5408"/>      br := calculate_banded_rect() | fail
<a name="5409"/>      l := []
<a name="5410"/>      every c := Seq{traverse_intersecting(view.inner, br)} do {
<a name="5411"/>         if is(c, TextFlow) then
<a name="5412"/>            c.get_selected_text(br, l)
<a name="5413"/>      }
<a name="5414"/>      qsort(l, Point.cmp_yx)
<a name="5415"/>      s := ""
<a name="5416"/>      every e := !l do {
<a name="5417"/>         if *s &gt; 0 then
<a name="5418"/>            s ||:= if e.y &gt; y1 then "\N" else " "
<a name="5419"/>         s ||:= string(e.val)
<a name="5420"/>         y1 := e.y
<a name="5421"/>      }
<a name="5422"/>      if *s &gt; 0 then
<a name="5423"/>         text_selection := ucs(s)
<a name="5424"/>   end
<a name="5425"/>
<a name="5426"/>   public get_current_links_selection()
<a name="5427"/>      return \.links_selection
<a name="5428"/>   end
<a name="5429"/>
<a name="5430"/>   private calculate_links_selection()
<a name="5431"/>      local l, c, u, b, seen
<a name="5432"/>      links_selection := &amp;null
<a name="5433"/>      l := []
<a name="5434"/>      seen := set()
<a name="5435"/>      every c := !banded do {
<a name="5436"/>         if is(c, TextSelection) then {
<a name="5437"/>            if u := \c.textout.attr.url &amp; not member(seen, u) then {
<a name="5438"/>               b := c.get_bounds()
<a name="5439"/>               insert(seen, u)
<a name="5440"/>               put(l, PointResult(b.x, b.y, u))
<a name="5441"/>            }
<a name="5442"/>         } else if is(c, Img) then {
<a name="5443"/>            every u := \c.gen_areas().url do {
<a name="5444"/>               unless member(seen, u) then {
<a name="5445"/>                  insert(seen, u)
<a name="5446"/>                  put(l, PointResult(c.x, c.y, u))
<a name="5447"/>               }
<a name="5448"/>            }
<a name="5449"/>         }
<a name="5450"/>      }
<a name="5451"/>      if *l &gt; 0 then {
<a name="5452"/>         qsort(l, Point.cmp_yx)
<a name="5453"/>         links_selection := ipl.pdco.List{ (!l).val }
<a name="5454"/>      }
<a name="5455"/>   end
<a name="5456"/>
<a name="5457"/>   private handle_lrelease(e)
<a name="5458"/>      scroll_ticker.stop()
<a name="5459"/>      view.inner.invalidate(get_band_rect())
<a name="5460"/>      draw_band := &amp;no
<a name="5461"/>      finish_selection()
<a name="5462"/>   end
<a name="5463"/>
<a name="5464"/>   private finish_selection()
<a name="5465"/>      calculate_text_selection()
<a name="5466"/>      calculate_links_selection()
<a name="5467"/>      do_update_grey()
<a name="5468"/>      if primary := \text_selection then
<a name="5469"/>         parent_dialog.own_selection(Selection.PRIMARY, primary_selection_owner)
<a name="5470"/>   end
<a name="5471"/>
<a name="5472"/>   private handle_interrupted()
<a name="5473"/>      if view.is_held(Mouse.LEFT_PRESS) then
<a name="5474"/>         handle_lrelease()
<a name="5475"/>   end
<a name="5476"/>
<a name="5477"/>   public handle_select_all(e)
<a name="5478"/>      /draw_band | fail
<a name="5479"/>      running === 0 | fail
<a name="5480"/>      mark_x := mark_y := 0
<a name="5481"/>      cursor_x := view.inner.w
<a name="5482"/>      cursor_y := view.inner.h
<a name="5483"/>      calculate_banded()
<a name="5484"/>      view.inner.invalidate(calculate_banded_rect())
<a name="5485"/>      finish_selection()
<a name="5486"/>   end
<a name="5487"/>
<a name="5488"/>   private can_rpress(e)
<a name="5489"/>      local c
<a name="5490"/>      is(parent_dialog.get_point_chain()[1], TextFlow | TblContent | Tbl) | fail
<a name="5491"/>      every c := !parent_dialog.get_point_chain() do {
<a name="5492"/>         if is(c, TextFlow) &amp; c.wants_rpress(e) then
<a name="5493"/>            fail
<a name="5494"/>      }
<a name="5495"/>      return
<a name="5496"/>   end
<a name="5497"/>
<a name="5498"/>   private can_lpress(e)
<a name="5499"/>      local c
<a name="5500"/>      is(parent_dialog.get_point_chain()[1], Img | TextFlow | TblContent | Tbl) | fail
<a name="5501"/>      every c := !parent_dialog.get_point_chain() do {
<a name="5502"/>         if is(c, TextFlow | Img) &amp; c.wants_lpress(e) then
<a name="5503"/>            fail
<a name="5504"/>      }
<a name="5505"/>      return
<a name="5506"/>   end
<a name="5507"/>
<a name="5508"/>   private handle_rpress(e)
<a name="5509"/>      local pm, pm_menu
<a name="5510"/>      parent_dialog.get_held_count() = 1 | fail
<a name="5511"/>      can_rpress(e) | fail
<a name="5512"/>      if pm_menu := create_page_menu() then {
<a name="5513"/>         pm := PopupMenu()
<a name="5514"/>         pm.popup(self, pm_menu, e.x, e.y)
<a name="5515"/>      }
<a name="5516"/>   end
<a name="5517"/>
<a name="5518"/>   public get_page_info()
<a name="5519"/>      local e, s, l, t, c, n, sz, m, f, imgs, ct
<a name="5520"/>
<a name="5521"/>      \page_url | fail
<a name="5522"/>      s := "&lt;html&gt;&lt;title&gt;Page info&lt;/title&gt;"
<a name="5523"/>      s ||:= "&lt;h1&gt;Page&lt;/h1&gt;"
<a name="5524"/>
<a name="5525"/>      s ||:= "URL: " || mk_anchor(page_url) || "&lt;p&gt;"
<a name="5526"/>      if sz := *\page_data then
<a name="5527"/>         s ||:= "Size: " || Format.numeric_to_string(sz, 0, ',') || " bytes&lt;p&gt;"
<a name="5528"/>      if \page_charset then
<a name="5529"/>         s ||:= "Charset: " || to_content(page_charset) || "&lt;p&gt;"
<a name="5530"/>      if *\page_name &gt; 0 then
<a name="5531"/>         s ||:= "Name: " || to_content(page_name) || "&lt;p&gt;"
<a name="5532"/>      if *\page_title &gt; 0 then
<a name="5533"/>         s ||:= "Title: " || to_content(page_title) || "&lt;p&gt;"
<a name="5534"/>      if ct := \page_resp.content_type then
<a name="5535"/>         s ||:= "Content-type: " || to_content(ct.to_rfc2616()) || "&lt;p&gt;"
<a name="5536"/>      if l := \page_resp.req.referer &amp; (l.scheme == ("http" | "https")) then
<a name="5537"/>         s ||:= "Referer: " || mk_anchor(l) || "&lt;p&gt;"
<a name="5538"/>      if e := \page_resp.err then
<a name="5539"/>         s ||:= "Error: " || to_content(e) || "&lt;p&gt;"
<a name="5540"/>
<a name="5541"/>      imgs := []
<a name="5542"/>      t := table(u"")
<a name="5543"/>      every c := Seq{traverse_postorder()} do {
<a name="5544"/>         if is(c, TextFlow) then
<a name="5545"/>            c.calculate_link_text(t)
<a name="5546"/>         else if is(c, Img) then
<a name="5547"/>            put(imgs, c)
<a name="5548"/>      }
<a name="5549"/>
<a name="5550"/>      if *forms &gt; 0 then {
<a name="5551"/>         s ||:= "&lt;h1&gt;Forms&lt;/h1&gt;&lt;table&gt;&lt;tr&gt;&lt;th align=left&gt;Name&lt;th align=left&gt;Method&lt;th align=left&gt;URL&lt;/tr&gt;"
<a name="5552"/>         every f := !forms do {
<a name="5553"/>            if l := \f.url then {
<a name="5554"/>               n := \f.id | "-"
<a name="5555"/>               m := \f.method | "-"
<a name="5556"/>               s ||:= "&lt;tr&gt;&lt;td&gt;" || to_content(n) || "&lt;td&gt;" || m || mk_anchor_cell(l) || "&lt;/tr&gt;" 
<a name="5557"/>            }
<a name="5558"/>         }
<a name="5559"/>         s ||:= "&lt;/table&gt;"
<a name="5560"/>      }
<a name="5561"/>
<a name="5562"/>      if *imgs &gt; 0 then {
<a name="5563"/>         s ||:= "&lt;h1&gt;Images&lt;/h1&gt;&lt;table&gt;&lt;tr&gt;&lt;th align=left&gt;Name&lt;th align=right&gt;Size&amp;nbsp;&lt;th align=left&gt;URL&lt;/tr&gt;"
<a name="5564"/>         every c := !imgs do {
<a name="5565"/>            l := c.img_url
<a name="5566"/>            n := limit_text(\c.img_name, scale(200)) | "-"
<a name="5567"/>            sz := Format.numeric_to_string(*\c.img_data, 0, ',') | "-"
<a name="5568"/>            s ||:= "&lt;tr&gt;&lt;td&gt;" || to_content(n) || "&lt;td align=right&gt;" || sz || "&amp;nbsp;" || mk_anchor_cell(l) || "&lt;/tr&gt;"
<a name="5569"/>         }
<a name="5570"/>         s ||:= "&lt;/table&gt;"
<a name="5571"/>      }
<a name="5572"/>
<a name="5573"/>      if *page_links &gt; 0 then {
<a name="5574"/>         s ||:= "&lt;h1&gt;Links&lt;/h1&gt;&lt;table&gt;&lt;tr&gt;&lt;th align=left&gt;Name&lt;th align=left&gt;URL&lt;/tr&gt;"
<a name="5575"/>         every l := !page_links do {
<a name="5576"/>            n := limit_text(t[l], scale(200))
<a name="5577"/>            s ||:= "&lt;tr&gt;&lt;td nowrap&gt;" || to_content(n) || mk_anchor_cell(l) || "&lt;/tr&gt;" 
<a name="5578"/>         }      
<a name="5579"/>         s ||:= "&lt;/table&gt;"
<a name="5580"/>      }
<a name="5581"/>      s ||:= "&lt;/html&gt;"
<a name="5582"/>      return s
<a name="5583"/>   end
<a name="5584"/>
<a name="5585"/>   public get_cache()
<a name="5586"/>      return worker_pool.cache
<a name="5587"/>   end
<a name="5588"/>
<a name="5589"/>   public handle_copy(e)
<a name="5590"/>      local s
<a name="5591"/>      if s := \text_selection then
<a name="5592"/>         parent_dialog.own_selection(Selection.CLIPBOARD, StaticTextSelectionOwner(s))
<a name="5593"/>   end
<a name="5594"/>
<a name="5595"/>   public handle_copy_links(e)
<a name="5596"/>      local l
<a name="5597"/>      if l := \links_selection then {
<a name="5598"/>         parent_dialog.own_selection(Selection.CLIPBOARD, URLSelectionOwner(l))
<a name="5599"/>         info_msg(*l || " link(s) copied")
<a name="5600"/>      } else
<a name="5601"/>         info_msg("No links in selection")
<a name="5602"/>   end
<a name="5603"/>
<a name="5604"/>   private static scale_font(s, f)
<a name="5605"/>      return s ? tab(backto(',',, 0)) || real(tab(0)) * f
<a name="5606"/>   end
<a name="5607"/>
<a name="5608"/>   # Magnify the fonts in the page by multiplying by the given factor.
<a name="5609"/>   #
<a name="5610"/>   public magnify(f)
<a name="5611"/>      local c, i, seen, s
<a name="5612"/>      seen := set()
<a name="5613"/>      every c := Seq{traverse_postorder()} do {
<a name="5614"/>         if is(c,TextFlow) then {
<a name="5615"/>            every i := !c.input do {
<a name="5616"/>               unless member(seen, i.attr) then {
<a name="5617"/>                  insert(seen, i.attr)
<a name="5618"/>                  i.attr.font := scale_font(i.attr.font, f)
<a name="5619"/>               }
<a name="5620"/>            }
<a name="5621"/>         }
<a name="5622"/>         if s := c.get_wattrib(WAttrib.FONT) then
<a name="5623"/>            c.set_font(scale_font(s, f))
<a name="5624"/>      }
<a name="5625"/>      # We could just call reset() here, but that would mean we
<a name="5626"/>      # couldn't use this function during page loading (since it would
<a name="5627"/>      # reset the worker pool).  So just reset the view() and call
<a name="5628"/>      # layout() and invalidate() as reset() would have done.
<a name="5629"/>      view.reset()
<a name="5630"/>      layout()
<a name="5631"/>      invalidate()
<a name="5632"/>      link
<a name="5633"/>   end
<a name="5634"/>
<a name="5635"/>   # Increase the fonts by 5%
<a name="5636"/>   #
<a name="5637"/>   public do_increase_font()
<a name="5638"/>      return magnify(1.05)
<a name="5639"/>   end
<a name="5640"/>
<a name="5641"/>   # Decrease the fonts by 5%
<a name="5642"/>   # 
<a name="5643"/>  public do_decrease_font()
<a name="5644"/>      return magnify(1.0/1.05)
<a name="5645"/>   end
<a name="5646"/>
<a name="5647"/>   private additional_keys(e)
<a name="5648"/>      case e.code of {
<a name="5649"/>         "-" : if \e.ctrl then do_decrease_font()
<a name="5650"/>         "=" : if \e.ctrl then do_increase_font()
<a name="5651"/>         "\^c" :  handle_copy(e)
<a name="5652"/>         "\^a" :  handle_select_all(e)
<a name="5653"/>         "\^f" : (\ui).display_search()
<a name="5654"/>      }
<a name="5655"/>   end
<a name="5656"/>
<a name="5657"/>   # Set a scaling factor to apply to all fonts (default 1.0).
<a name="5658"/>   #
<a name="5659"/>   public set_font_factor(n)
<a name="5660"/>      self.font_factor := need_real(n)
<a name="5661"/>      link
<a name="5662"/>   end
<a name="5663"/>
<a name="5664"/>   #
<a name="5665"/>   # Set the maximum size of the history, default 100
<a name="5666"/>   #
<a name="5667"/>   public set_history_size(n)
<a name="5668"/>      self.history_size := need_integer(n, 0)
<a name="5669"/>      link
<a name="5670"/>   end
<a name="5671"/>
<a name="5672"/>   public override handle_wheel_up(e)
<a name="5673"/>      if /e.ctrl then
<a name="5674"/>         ComponentScrollArea.handle_wheel_up(e)
<a name="5675"/>      else
<a name="5676"/>         do_increase_font()
<a name="5677"/>   end
<a name="5678"/>
<a name="5679"/>   public override handle_wheel_down(e)
<a name="5680"/>      if /e.ctrl then
<a name="5681"/>         ComponentScrollArea.handle_wheel_down(e)
<a name="5682"/>      else
<a name="5683"/>         do_decrease_font()
<a name="5684"/>   end
<a name="5685"/>
<a name="5686"/>   public clone_history(other)
<a name="5687"/>      local he
<a name="5688"/>      # Note that we don't clone curr_history_entry, since we're not
<a name="5689"/>      # actually looking at that page in the cloned browser tab.
<a name="5690"/>      history := clone(other.history)
<a name="5691"/>      history_pos := other.history_pos
<a name="5692"/>      curr_history_entry := &amp;null
<a name="5693"/>      do_update_grey()
<a name="5694"/>      he := history[history_pos]
<a name="5695"/>      goto(he.url, he.referer, he.form_data, Worker.NAVIGATE)
<a name="5696"/>      link
<a name="5697"/>   end
<a name="5698"/>
<a name="5699"/>   public override create_vsb()
<a name="5700"/>      return ScrollBar().
<a name="5701"/>         set_increment_size(SCROLL_INCREMENT)
<a name="5702"/>   end
<a name="5703"/>
<a name="5704"/>   public override create_hsb()
<a name="5705"/>      return ScrollBar().
<a name="5706"/>         set_increment_size(SCROLL_INCREMENT)
<a name="5707"/>   end
<a name="5708"/>
<a name="5709"/>   public override new()
<a name="5710"/>      ComponentScrollArea.new()
<a name="5711"/>      scroll_ticker := Dispatcher.new_task{scroll_tick()}
<a name="5712"/>      tidy_cache_task := Dispatcher.new_task{tidy_cache()}
<a name="5713"/>      worker_pool := WorkerPool(self)
<a name="5714"/>      status_ticker := Dispatcher.new_task{status()}
<a name="5715"/>      primary_selection_owner := BrowserPrimarySelectionOwner(self)
<a name="5716"/>      set_inner(TextFlow(self))
<a name="5717"/>      set_use_default_keys(&amp;yes)
<a name="5718"/>      connect(additional_keys, Event.KEY_PRESS)
<a name="5719"/>      history := []
<a name="5720"/>      history_pos := 0
<a name="5721"/>      history_size := DEFAULT_HISTORY_SIZE
<a name="5722"/>      running := 0
<a name="5723"/>      banded := table()
<a name="5724"/>      searched := table()
<a name="5725"/>      outermost_border := NullBorder()
<a name="5726"/>      font_factor := 1.0
<a name="5727"/>      view.connect(self.handle_ldrag, Event.MOUSE_LEFT_DRAG).
<a name="5728"/>         connect(self.handle_lpress, Event.MOUSE_LEFT_PRESS).
<a name="5729"/>         connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE).
<a name="5730"/>         connect(self.handle_rpress, Event.MOUSE_RIGHT_PRESS).
<a name="5731"/>         connect(self.handle_in_chain, Event.IN_POINT_CHAIN)
<a name="5732"/>      connect(handle_interrupted, Event.INTERRUPTED)
<a name="5733"/>      return
<a name="5734"/>   end
<a name="5735"/>end
<a name="5736"/>
<a name="5737"/>#
<a name="5738"/># A `BrowserUI` to use with `SimpleBrowser`
<a name="5739"/>#
<a name="5740"/>class SimpleBrowserUI(BrowserUI)
<a name="5741"/>   public const browser
<a name="5742"/>
<a name="5743"/>   public override msg(s, n) end
<a name="5744"/>
<a name="5745"/>   public override page_loaded()
<a name="5746"/>      browser.fire(SimpleBrowser.PAGE_LOADED)
<a name="5747"/>   end
<a name="5748"/>
<a name="5749"/>   public override page_fully_loaded()  
<a name="5750"/>      browser.fire(SimpleBrowser.PAGE_FULLY_LOADED)
<a name="5751"/>   end
<a name="5752"/>
<a name="5753"/>   public override update_grey(gs) end
<a name="5754"/>
<a name="5755"/>   public override link_left_clicked(url)
<a name="5756"/>      browser.fire(SimpleBrowser.LINK_LEFT_CLICKED, url)
<a name="5757"/>   end
<a name="5758"/>
<a name="5759"/>   public override link_middle_clicked(url)
<a name="5760"/>      browser.fire(SimpleBrowser.LINK_MIDDLE_CLICKED, url)
<a name="5761"/>   end
<a name="5762"/>
<a name="5763"/>   protected copy_link(url)
<a name="5764"/>      browser.parent_dialog.own_selection(Selection.CLIPBOARD, URLSelectionOwner([url]))
<a name="5765"/>   end
<a name="5766"/>
<a name="5767"/>   protected populate_link_menu(url, m)
<a name="5768"/>      m.add(TextMenuItem().
<a name="5769"/>            set_label("Copy link").
<a name="5770"/>            connect(create copy_link(url), Event.ACTION))
<a name="5771"/>   end
<a name="5772"/>
<a name="5773"/>   protected is_external(url)
<a name="5774"/>      return not(url.scheme == ("page" | "img"))
<a name="5775"/>   end
<a name="5776"/>
<a name="5777"/>   public override create_link_menu(url)
<a name="5778"/>      local m
<a name="5779"/>      m := Menu()
<a name="5780"/>      populate_link_menu(url, m)
<a name="5781"/>      return m
<a name="5782"/>   end
<a name="5783"/>
<a name="5784"/>   public override create_page_menu()
<a name="5785"/>      local m, u, i
<a name="5786"/>      m := Menu()
<a name="5787"/>      if u := \browser.page_url &amp; is_external(u) then {
<a name="5788"/>         m.add(TextMenuItem().
<a name="5789"/>               set_label("Copy page").
<a name="5790"/>               connect(create copy_link(u), Event.ACTION))
<a name="5791"/>      }
<a name="5792"/>      if \browser.page_data then {
<a name="5793"/>         i := TextMenuItem().
<a name="5794"/>               set_label("Select all").
<a name="5795"/>               connect(browser.handle_select_all, Event.ACTION)
<a name="5796"/>         if browser.accepts_focus() then
<a name="5797"/>            i.set_label_right("^A")
<a name="5798"/>         m.add(i)
<a name="5799"/>      }
<a name="5800"/>      if browser.get_current_text_selection() then {
<a name="5801"/>         i := TextMenuItem().
<a name="5802"/>               set_label("Copy text").
<a name="5803"/>               connect(browser.handle_copy, Event.ACTION)
<a name="5804"/>         if browser.accepts_focus() then
<a name="5805"/>            i.set_label_right("^C")
<a name="5806"/>         m.add(i)
<a name="5807"/>      }
<a name="5808"/>      if browser.get_current_links_selection() then
<a name="5809"/>         m.add(TextMenuItem().
<a name="5810"/>               set_label("Copy links").
<a name="5811"/>               connect(browser.handle_copy_links, Event.ACTION))
<a name="5812"/>      if *m.children &gt; 0 then
<a name="5813"/>         return m
<a name="5814"/>   end
<a name="5815"/>
<a name="5816"/>   public override create_image_menu(img)
<a name="5817"/>      local m, url
<a name="5818"/>      url := if img.img_url.scheme == "cache" then browser.page_url else img.img_url
<a name="5819"/>      m := Menu()
<a name="5820"/>      if is_external(url) then
<a name="5821"/>         m.add(TextMenuItem().
<a name="5822"/>               set_label("Copy image").
<a name="5823"/>               connect(create copy_link(url), Event.ACTION))
<a name="5824"/>      if \img.over then
<a name="5825"/>         populate_link_menu(img.over, m)
<a name="5826"/>      if *m.children &gt; 0 then
<a name="5827"/>         return m
<a name="5828"/>   end
<a name="5829"/>
<a name="5830"/>   public override browse_for_file(s) end
<a name="5831"/>   public override is_visited(url) end
<a name="5832"/>   public override display_search() end
<a name="5833"/>   public override display_externally(res) end
<a name="5834"/>   public override goto_externally(url) end
<a name="5835"/>   public override save_attachment(file, res) end
<a name="5836"/>
<a name="5837"/>   public new(browser)
<a name="5838"/>      self.browser := browser
<a name="5839"/>      return
<a name="5840"/>   end
<a name="5841"/>end
<a name="5842"/>
<a name="5843"/># A simple subclass of `Browser`, intended for displaying HTML pages
<a name="5844"/># with no user navigation and a minimalist interface.
<a name="5845"/>#
<a name="5846"/># An HTML document may be shown by calling `set_page`, passing the
<a name="5847"/># document in string form.  Images may be included in the page by
<a name="5848"/># either specifying a normal external URL, or with URL img:name, where
<a name="5849"/># name is a name in the image cache (eg: &lt;img src="img:gui.HOME_24"&gt;).
<a name="5850"/>#
<a name="5851"/>class SimpleBrowser(Browser)
<a name="5852"/>   private readable
<a name="5853"/>      page
<a name="5854"/>
<a name="5855"/>   public static const
<a name="5856"/>      LINK_LEFT_CLICKED,
<a name="5857"/>      LINK_MIDDLE_CLICKED,
<a name="5858"/>      PAGE_LOADED,
<a name="5859"/>      PAGE_FULLY_LOADED
<a name="5860"/>
<a name="5861"/>   private static init()
<a name="5862"/>      LINK_LEFT_CLICKED := "link_left_clicked"
<a name="5863"/>      LINK_MIDDLE_CLICKED := "link_middle_clicked" 
<a name="5864"/>      PAGE_LOADED := "page loaded"
<a name="5865"/>      PAGE_FULLY_LOADED := "page fully loaded"
<a name="5866"/>   end
<a name="5867"/>
<a name="5868"/>   # Set the page to display as a string representing an HTML
<a name="5869"/>   # document.
<a name="5870"/>   #
<a name="5871"/>   public set_page(page)
<a name="5872"/>      self.page := need_string(page)
<a name="5873"/>      goto(URL("page:"))
<a name="5874"/>      link
<a name="5875"/>   end
<a name="5876"/>
<a name="5877"/>   private page_handler(worker)
<a name="5878"/>      return \page | return error("No page set")
<a name="5879"/>   end
<a name="5880"/>
<a name="5881"/>   private img_handler(worker)
<a name="5882"/>      local n, v
<a name="5883"/>      n := string(worker.req.url.get_path())
<a name="5884"/>      v := ImageCache.get_named_image(n) | error("Unknown image")
<a name="5885"/>      return string(v) | error("Cached image not a string")
<a name="5886"/>   end
<a name="5887"/>
<a name="5888"/>   public override new()
<a name="5889"/>      Browser.new()
<a name="5890"/>      set_ui(SimpleBrowserUI(self))
<a name="5891"/>      worker_pool.
<a name="5892"/>         add_scheme_handler("page", page_handler).
<a name="5893"/>         add_scheme_handler("img", img_handler)
<a name="5894"/>      return
<a name="5895"/>   end
<a name="5896"/>end
</pre></body></html>
