<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>suggestfield.icn</title></head><body><pre>
<a name="1"/>package gui
<a name="2"/>
<a name="3"/>import graphics, util, lang
<a name="4"/>
<a name="5"/>class Conversion()
<a name="6"/>   public const
<a name="7"/>      str, pos
<a name="8"/>
<a name="9"/>   public new(str, pos)
<a name="10"/>      self.str := need_text(str)
<a name="11"/>      self.pos := need_integer(\pos, 1, *self.str + 1) | *self.str + 1
<a name="12"/>      return
<a name="13"/>   end
<a name="14"/>end
<a name="15"/>
<a name="16"/># This class is a `TextField` which provides suggested completions in
<a name="17"/># a popup list based on partial input.
<a name="18"/>#
<a name="19"/>abstract class SuggestField(TextField, MenuMode)
<a name="20"/>   public 
<a name="21"/>      popup,
<a name="22"/>      direction,
<a name="23"/>      max_height,
<a name="24"/>      max_width,
<a name="25"/>      select_using_enter_flag,
<a name="26"/>      action_while_popup_flag,
<a name="27"/>      popup_on_tab_flag,
<a name="28"/>      forward_home_end_flag     # Forward home/end key to list?
<a name="29"/>
<a name="30"/>   protected
<a name="31"/>      req, 
<a name="32"/>      req_held,
<a name="33"/>      req_doing,
<a name="34"/>      last,
<a name="35"/>      mod,
<a name="36"/>      applied_event,
<a name="37"/>      list_data
<a name="38"/>
<a name="39"/>   #
<a name="40"/>   # Set the direction to pop-up in.  Options are `Direction.UP`, `Direction.DOWN` or
<a name="41"/>   # `Direction.BEST` (the default).
<a name="42"/>   #
<a name="43"/>   public set_direction(s)
<a name="44"/>      self.direction := s
<a name="45"/>      link
<a name="46"/>   end
<a name="47"/>
<a name="48"/>   #
<a name="49"/>   # Forward home/end key to list?  Default is yes.
<a name="50"/>   #
<a name="51"/>   public set_forward_home_end(s)
<a name="52"/>      self.forward_home_end_flag := need_flag(s)
<a name="53"/>      link
<a name="54"/>   end
<a name="55"/>
<a name="56"/>   #
<a name="57"/>   # Only popup when the tab key is pressed.
<a name="58"/>   #
<a name="59"/>   public set_popup_on_tab(s)
<a name="60"/>      self.popup_on_tab_flag := need_flag(s)
<a name="61"/>      link
<a name="62"/>   end
<a name="63"/>
<a name="64"/>   #
<a name="65"/>   # If set, the enter key is used to select from the list, rather than items being selected
<a name="66"/>   # using the cursor keys.  Default is yes.
<a name="67"/>   #
<a name="68"/>   public set_select_using_enter(s)
<a name="69"/>      self.select_using_enter_flag := need_flag(s)
<a name="70"/>      link
<a name="71"/>   end
<a name="72"/>
<a name="73"/>   #
<a name="74"/>   # If set, then an ACTION event is fired if return is pressed whilst
<a name="75"/>   # the selection popup is open.  Default is yes.
<a name="76"/>   #
<a name="77"/>   public set_action_while_popup(s)
<a name="78"/>      self.action_while_popup_flag := need_flag(s)
<a name="79"/>      link
<a name="80"/>   end
<a name="81"/>
<a name="82"/>   public create_popup()
<a name="83"/>      return TextList()
<a name="84"/>   end
<a name="85"/>
<a name="86"/>   #
<a name="87"/>   # Set the maximum height of the dropdown list; by default it is as large as is necessary
<a name="88"/>   # and can be accommodated on the screen.
<a name="89"/>   #
<a name="90"/>   public set_max_height(n)
<a name="91"/>      self.max_height := /n | need_integer(n, 1)
<a name="92"/>      link
<a name="93"/>   end
<a name="94"/>
<a name="95"/>   #
<a name="96"/>   # Set the maximum width of the dropdown list; by default it is as wide as is necessary
<a name="97"/>   # and can be accommodated on the screen.
<a name="98"/>   #
<a name="99"/>   public set_max_width(n)
<a name="100"/>      self.max_width := /n | need_integer(n, 1)
<a name="101"/>      link
<a name="102"/>   end
<a name="103"/>
<a name="104"/>   public on_popup_selection(e)
<a name="105"/>      synch_contents(e)
<a name="106"/>      member(Key.NAVIGATE, e.code) | close_popup()
<a name="107"/>   end
<a name="108"/>
<a name="109"/>   public synch_contents(ev)
<a name="110"/>      apply_value(popup.object_first_selection(), ev, &amp;yes)
<a name="111"/>   end
<a name="112"/>
<a name="113"/>   public convert_element(o)
<a name="114"/>      return text(o)
<a name="115"/>   end
<a name="116"/>
<a name="117"/>   private requests()
<a name="118"/>      local l
<a name="119"/>      repeat {
<a name="120"/>         until mod === 1 do {
<a name="121"/>            req_held := &amp;yes
<a name="122"/>            req.sleep()
<a name="123"/>            req_held := &amp;null
<a name="124"/>         }
<a name="125"/>         mod := &amp;null
<a name="126"/>         req_doing := &amp;yes
<a name="127"/>         l := do_request() | &amp;null
<a name="128"/>         req_doing := &amp;null
<a name="129"/>         # If finally() has been called, close any request resources,
<a name="130"/>         # and stop the task.
<a name="131"/>         if /cbwin then {
<a name="132"/>            close_request()
<a name="133"/>            req.revert()
<a name="134"/>         }
<a name="135"/>         if \l then {
<a name="136"/>            # If contents have changed, skip, and repeat request if
<a name="137"/>            # mod = 1, or go to sleep if mod = 2
<a name="138"/>            if \mod then
<a name="139"/>               next
<a name="140"/>            open_popup(l)
<a name="141"/>         }
<a name="142"/>      }
<a name="143"/>   end
<a name="144"/>
<a name="145"/>   # This method is implemented to provide the list of suggestions, based on
<a name="146"/>   # the current contents of the textfield.  `fg` is a flag, indicating
<a name="147"/>   # whether we are called from the background task, or in the foreground,
<a name="148"/>   # (after the tab key is pressed).
<a name="149"/>   #
<a name="150"/>   protected abstract do_request(fg)
<a name="151"/>
<a name="152"/>   # This method is called to abort a request in progress; do_request() should then
<a name="153"/>   # fail.
<a name="154"/>   #
<a name="155"/>   protected abort_request()
<a name="156"/>   end
<a name="157"/>
<a name="158"/>   # This is invoked whilst `do_request` is not in progress to allow
<a name="159"/>   # any resources which remain open between `do_request` calls to be
<a name="160"/>   # closed.  Note that `do_request` may later be invoked again.
<a name="161"/>   #
<a name="162"/>   protected close_request()
<a name="163"/>   end
<a name="164"/>
<a name="165"/>   public on_change(ev)
<a name="166"/>      if \popup_on_tab_flag then {
<a name="167"/>         if \select_using_enter_flag | not member(Key.NAVIGATE, ev.code) then
<a name="168"/>            keep_closed()
<a name="169"/>      } else if applied_event === ev then
<a name="170"/>         mod := 2
<a name="171"/>      else if *contents = 0 &amp; ev.code ~=== "\t" then
<a name="172"/>         keep_closed()
<a name="173"/>      else {
<a name="174"/>         mod := 1
<a name="175"/>         # Wakeup req if waiting
<a name="176"/>         if \req_held then
<a name="177"/>            req.notify()
<a name="178"/>      }
<a name="179"/>   end
<a name="180"/>
<a name="181"/>   protected open_popup(data)
<a name="182"/>      local max_h, max_w, spc_below, spc_above, spc_right, d, dim, win,
<a name="183"/>         use_direction, rs
<a name="184"/>
<a name="185"/>      # If the list is already open with the same data, do nothing.
<a name="186"/>      # This avoids the flickering of opening and closing the popup.
<a name="187"/>      if equals(data, list_data) then
<a name="188"/>         fail
<a name="189"/>
<a name="190"/>      close_popup()
<a name="191"/>
<a name="192"/>      # If no data, or the focus has moved away, leave closed.
<a name="193"/>      if (*data = 0) | (parent_dialog.get_focus() ~=== self) then
<a name="194"/>         fail
<a name="195"/>
<a name="196"/>      self.parent_dialog.enter_menu_mode(self) | fail
<a name="197"/>
<a name="198"/>      list_data := copy(data)
<a name="199"/>      win := parent_dialog.win
<a name="200"/>      dim := win.get_display_size()
<a name="201"/>      # Screen rectangle, in adjusted co-ordinates
<a name="202"/>      rs := Rect(-win.get_x() - win.get_dx(), -win.get_y() - win.get_dy(), dim.width, dim.height)
<a name="203"/>
<a name="204"/>      # Space available for popup limited by screen size
<a name="205"/>      spc_above := self.y - rs.y
<a name="206"/>      spc_below := rs.y + rs.h - self.y - self.h
<a name="207"/>      spc_right := rs.x + rs.w - self.x
<a name="208"/>
<a name="209"/>      max_h := case self.direction of {
<a name="210"/>         Direction.UP: spc_above
<a name="211"/>         Direction.DOWN: spc_below
<a name="212"/>         Direction.BEST: 
<a name="213"/>            if Gui.POPUP_LIST_DIRECTION_FACTOR * spc_below &gt; spc_above then spc_below else spc_above
<a name="214"/>         default: runerr("Unknown direction", self.direction)
<a name="215"/>      }
<a name="216"/>      max_w := spc_right
<a name="217"/>      max_w &gt;:= \self.max_width
<a name="218"/>      max_h &gt;:= \self.max_height
<a name="219"/>
<a name="220"/>      self.popup := create_popup().
<a name="221"/>         set_wattrib_ancestor(self).
<a name="222"/>         connect(on_popup_selection, Event.SELECTION_CHANGED).
<a name="223"/>         set_contents(data).
<a name="224"/>         set_accepts_focus(&amp;no).
<a name="225"/>         set_draggable_cursor(&amp;yes).
<a name="226"/>         set_motion_cursor(&amp;yes).
<a name="227"/>         set_always_show_focus_cursor(&amp;yes).
<a name="228"/>         set_wrap_on_up_down(&amp;yes).
<a name="229"/>         set_select_mode(Select.ONE).
<a name="230"/>         set_z(self.parent_dialog.get_top_z())
<a name="231"/>
<a name="232"/>      if /popup_on_tab_flag | /select_using_enter_flag then
<a name="233"/>         popup.set_cursor()
<a name="234"/>
<a name="235"/>      if \select_using_enter_flag then
<a name="236"/>         popup.set_selection_on_key_moves(&amp;no)
<a name="237"/>
<a name="238"/>      self.parent_dialog.add(popup)
<a name="239"/>      self.popup.set_ideal_size(self.w, max_w,
<a name="240"/>                             scale(5), max_h)
<a name="241"/>
<a name="242"/>      use_direction := if direction == Direction.BEST then {
<a name="243"/>         if spc_below &gt;= (popup.h_spec | spc_above) then
<a name="244"/>            Direction.DOWN
<a name="245"/>         else
<a name="246"/>            Direction.UP
<a name="247"/>      } else
<a name="248"/>         direction
<a name="249"/>
<a name="250"/>      popup.
<a name="251"/>         set_pos(win.get_dx() + x,
<a name="252"/>                 win.get_dy() + if use_direction == Direction.DOWN then 
<a name="253"/>                    y + h
<a name="254"/>                  else
<a name="255"/>                    y - popup.h_spec).
<a name="256"/>         resize()
<a name="257"/>
<a name="258"/>      if Gui.allow_internal_popups() &amp;
<a name="259"/>         parent_dialog.contains(popup) then {
<a name="260"/>         popup.invalidate()
<a name="261"/>      } else {
<a name="262"/>         # Remove popup from dialog and use add to popup window.
<a name="263"/>         parent_dialog.remove(popup)
<a name="264"/>         d := PureDialog().
<a name="265"/>            set_canvas(Canvas.POPUP).
<a name="266"/>            set_width(popup.w).
<a name="267"/>            set_height(popup.h).
<a name="268"/>            set_dx(-popup.x).
<a name="269"/>            set_dy(-popup.y).
<a name="270"/>            set_x(win.get_x() + win.get_dx() + popup.x).
<a name="271"/>            set_y(win.get_y() + win.get_dy() + popup.y).
<a name="272"/>            copy_wattrib(WAttrib.DISPLAY, parent_dialog).
<a name="273"/>            add(popup)
<a name="274"/>
<a name="275"/>         popup.set_pos(0, 0)
<a name="276"/>         parent_dialog.add_popup(d)
<a name="277"/>         d.show()
<a name="278"/>      }
<a name="279"/>      fire(Event.POPUP_OPENED)
<a name="280"/>      link
<a name="281"/>   end
<a name="282"/>
<a name="283"/>   protected close_popup()
<a name="284"/>      \popup | fail
<a name="285"/>      if popup.parent_dialog === parent_dialog then {
<a name="286"/>         popup.invalidate()
<a name="287"/>         parent_dialog.remove(popup)
<a name="288"/>      } else {
<a name="289"/>         parent_dialog.remove_popup(popup.parent_dialog)
<a name="290"/>         popup.parent_dialog.dispose()
<a name="291"/>      }
<a name="292"/>      list_data := popup := &amp;null
<a name="293"/>      parent_dialog.exit_menu_mode(self)
<a name="294"/>      fire(Event.POPUP_CLOSED)
<a name="295"/>      link
<a name="296"/>   end
<a name="297"/>
<a name="298"/>   public override get_nesting_component()
<a name="299"/>      link
<a name="300"/>   end
<a name="301"/>
<a name="302"/>   public override gen_popup_components()
<a name="303"/>      return popup
<a name="304"/>   end
<a name="305"/>
<a name="306"/>   public override allow_nested(c)
<a name="307"/>   end
<a name="308"/>
<a name="309"/>   public override close_all()
<a name="310"/>      keep_closed()
<a name="311"/>   end
<a name="312"/>
<a name="313"/>   public override should_close(e)
<a name="314"/>      succeed member(Mouse.PRESS, e.code) &amp; not(popup.in_region(e))
<a name="315"/>   end
<a name="316"/>
<a name="317"/>   # Close the textlist (if it is open), and stop any running
<a name="318"/>   # background request from re-opening it (until the next key
<a name="319"/>   # modification).
<a name="320"/>   #
<a name="321"/>   public keep_closed()
<a name="322"/>      close_popup()
<a name="323"/>      if \req_doing then
<a name="324"/>         abort_request()
<a name="325"/>      mod := &amp;null
<a name="326"/>   end
<a name="327"/>
<a name="328"/>   public override initially()
<a name="329"/>      TextField.initially()
<a name="330"/>      mod := &amp;null
<a name="331"/>      req.start()
<a name="332"/>   end
<a name="333"/>
<a name="334"/>   public override finally()
<a name="335"/>      if \req_doing then
<a name="336"/>         abort_request()
<a name="337"/>      else {
<a name="338"/>         close_request()
<a name="339"/>         req.stop()
<a name="340"/>      }
<a name="341"/>      close_popup()
<a name="342"/>      TextField.finally()
<a name="343"/>   end
<a name="344"/>
<a name="345"/>   public override keeps(e)
<a name="346"/>      succeed e.code === "\t" | member(Key.CURSOR_H, e.code)
<a name="347"/>   end
<a name="348"/>
<a name="349"/>   public was_applied(ev)
<a name="350"/>      succeed ev === applied_event
<a name="351"/>   end
<a name="352"/>
<a name="353"/>   public override handle_return(e)
<a name="354"/>      if \popup then {
<a name="355"/>         if \select_using_enter_flag then
<a name="356"/>            forward_key(e)
<a name="357"/>         keep_closed()
<a name="358"/>         if \action_while_popup_flag then
<a name="359"/>            TextField.handle_return(e)
<a name="360"/>      } else
<a name="361"/>         TextField.handle_return(e)
<a name="362"/>   end
<a name="363"/>
<a name="364"/>   public forward_key(e)
<a name="365"/>      (\popup).fire(Event.KEY_PRESS, e)
<a name="366"/>   end
<a name="367"/>
<a name="368"/>   public handle_key_up(e)
<a name="369"/>      forward_key(e)
<a name="370"/>   end
<a name="371"/>
<a name="372"/>   public handle_key_down(e)
<a name="373"/>      forward_key(e)
<a name="374"/>   end
<a name="375"/>
<a name="376"/>   public handle_key_page_up(e)
<a name="377"/>      forward_key(e)
<a name="378"/>   end
<a name="379"/>
<a name="380"/>   public handle_key_page_down(e)
<a name="381"/>      forward_key(e)
<a name="382"/>   end
<a name="383"/>
<a name="384"/>   public override handle_key_home(e)
<a name="385"/>      if \popup &amp; \forward_home_end_flag then
<a name="386"/>         forward_key(e)
<a name="387"/>      else
<a name="388"/>         TextField.handle_key_home(e)
<a name="389"/>   end
<a name="390"/>
<a name="391"/>   public override handle_key_end(e)
<a name="392"/>      if \popup &amp; \forward_home_end_flag then
<a name="393"/>         forward_key(e)
<a name="394"/>      else
<a name="395"/>         TextField.handle_key_end(e)
<a name="396"/>   end
<a name="397"/>
<a name="398"/>   # This method may be overridden to return a non-empty string to
<a name="399"/>   # insert before the popup is opened.  `l` is the list of
<a name="400"/>   # completions returned by `do_request`.
<a name="401"/>   #
<a name="402"/>   public get_insertion(l)
<a name="403"/>   end
<a name="404"/>
<a name="405"/>   public handle_tab(ev)
<a name="406"/>      local l, o
<a name="407"/>      if \popup then {
<a name="408"/>         if \select_using_enter_flag &amp; o := popup.object_get_cursor() then {
<a name="409"/>            apply_value(o, ev)
<a name="410"/>            if /changed then
<a name="411"/>               keep_closed()
<a name="412"/>         } else {
<a name="413"/>            if o := get_insertion(list_data) then
<a name="414"/>               apply_value(o, ev)
<a name="415"/>            else
<a name="416"/>               keep_closed()
<a name="417"/>         }
<a name="418"/>      } else {
<a name="419"/>         l := do_request(&amp;yes) | fail
<a name="420"/>         if o := get_insertion(l) then {
<a name="421"/>            apply_value(o, ev)
<a name="422"/>            if *l &gt; 1 then
<a name="423"/>               open_popup(l)
<a name="424"/>         } else
<a name="425"/>            open_popup(l)
<a name="426"/>      }
<a name="427"/>   end
<a name="428"/>
<a name="429"/>   public apply_value(v, ev, apply)
<a name="430"/>      local p
<a name="431"/>      v := convert_element(v) | contents[1:1]
<a name="432"/>      if is(v, Conversion) then {
<a name="433"/>         p := v.pos
<a name="434"/>         v := v.str
<a name="435"/>      }
<a name="436"/>      if /apply then
<a name="437"/>         assign_contents(v, p, ev)
<a name="438"/>      else
<a name="439"/>         assign_contents(v, p, applied_event := ev, toggle_flag(select_using_enter_flag))
<a name="440"/>   end
<a name="441"/>
<a name="442"/>   public override handle_key(e)
<a name="443"/>      case e.code of {
<a name="444"/>         "\t" : handle_tab(e)
<a name="445"/>         "\e" : keep_closed()
<a name="446"/>         Key.UP : handle_key_up(e)
<a name="447"/>         Key.DOWN : handle_key_down(e)
<a name="448"/>         Key.PGUP : handle_key_page_up(e)
<a name="449"/>         Key.PGDN : handle_key_page_down(e)
<a name="450"/>         default:
<a name="451"/>            TextField.handle_key(e)
<a name="452"/>      }
<a name="453"/>   end
<a name="454"/>
<a name="455"/>   public override new()
<a name="456"/>      TextField.new()
<a name="457"/>      connect(on_change, Event.CONTENT_CHANGED)
<a name="458"/>      req := Dispatcher.new_task{requests()}
<a name="459"/>      direction := Direction.BEST
<a name="460"/>      forward_home_end_flag := select_using_enter_flag := action_while_popup_flag := &amp;yes
<a name="461"/>      return
<a name="462"/>   end
<a name="463"/>end
</pre></body></html>
