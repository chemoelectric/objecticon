#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

import 
   graphics,
   util,
   lang

#
# This is the parent class of the button classes, including
# checkboxes.
#
# A {Button} produces a {Event.BUTTON_PRESS} when the button is
# depressed, and code {Event.BUTTON_RELEASE} when it is released,
# as well as an {Event.ACTION}.
# 
# By default, when a button holds the keyboard focus a dashed
# line appears just within the button.  Then, when return is
# pressed an {Event.ACTION} is generated.  The method
# {Dialog.set_initial_focus()} can be used to have the button
# have the focus when the dialog is first displayed.
#
# Buttons also repeatedly produce a {Event.BUTTON_HELD} whilst they
# are held down, rather like a repeating keyboard press.  The
# delay between the initial repeat event and subsequent repeat
# events is set in the {Style} object.
#
class Button(Toggle,Component)
   public 
      is_down,
      parent_button_group,
      repeat_delay,
      no_click_focus_flag,
      toggles_flag,
      repeat_ticker

   public set_parent_button_group(x)
      self.parent_button_group := x
      return self
   end

   #
   # Set the no-click-focus behaviour.  If set, the component will
   # not get the focus on a left click.
   #
   public set_no_click_focus(s)
      self.no_click_focus_flag := check_flag(s)
      return self
   end

   public finally()
      repeat_ticker.stop()
      cast(self,Component).finally()
   end

   public repeat_tick()
      repeat {
         if Prog.get_runtime_millis() > self.repeat_delay then
            fire(Event.BUTTON_HELD)
         repeat_ticker.sleep(Gui.REPEAT_RATE)
      }
   end

   public go_down()
      self.is_down := 1
      repeat_ticker.start()
   end

   public go_up()
      self.is_down := &null
      repeat_ticker.stop()
   end

   public handle_lpress(e)
      local b

      if /self.is_down then {
         go_down()
         self.repeat_delay := Prog.get_runtime_millis() + Gui.REPEAT_DELAY
         every b := !(\self.parent_button_group).buttons do {
            if b.is_unhidden() & b.is_unshaded() then {
               parent_dialog.hold(b, e.code)
               b.repeat_delay := self.repeat_delay
            }
         }
         self.invalidate()
         fire(Event.BUTTON_PRESS, e)
      }
   end

   public handle_ldrag(e)
      #
      # Button held down; toggle on/off as it goes over the button 
      #
      if self.in_region(e) then {
         if /self.is_down then {
            go_down()
            invalidate()
         }
      } else {
         if \self.is_down then {
            go_up()
            invalidate()
         }
      }
   end

   public handle_lrelease(e)
      if \self.is_down then {
         go_up()
         fire(Event.BUTTON_RELEASE, e)
         on_action(e)
      }
   end

   public on_action(e)
      local t
      if \self.toggles_flag then {
         if \self.parent_check_box_group then {
            t := self.parent_check_box_group.which_one
            self.set_is_checked(&yes)
            if t ~=== self.parent_check_box_group.which_one then
               self.parent_check_box_group.fire(Event.SELECTION_CHANGED, e)
         } else
            self.toggle_is_checked()
      } else
         self.invalidate()
      fire(Event.ACTION, e)
   end

   #
   # Visualize the given (keyboard) event, by making the button go down
   # for a short time (50ms), before making it go up again, and then
   # calling {on_action}
   #
   public visualize_action(e)
      local t
      self.is_down := 1
      self.invalidate()
      t := Dispatcher.new_task{{
         t.sleep(50)
         self.is_down := &null
         on_action(e)
      }}
      t.start()
   end

   public handle_accel(e)
      if /self.no_click_focus_flag then
         grab_focus(e)
      visualize_action(e)
   end

   public handle_key(e)
      if e.code == ("\r"|"\l"|" ") then
         visualize_action(e)
   end

   #
   # Set the status to checked.
   #
   public set_is_checked(s)
      cast(self,Toggle).set_is_checked(s)
      self.invalidate()
      return self
   end

   public accepts_focus(e)
      if e.code === Mouse.LEFT_PRESS & \self.no_click_focus_flag then
         fail
      return cast(self,Component).accepts_focus(e)
   end

   #
   # Set the button so that when it is pressed, it toggles
   # between two states, as indicated by the is_checked
   # flag.
   #
   # Instances of Checkbox have this flag on by default, but 
   # TextButton and IconButton do not.  When the flag is on,
   # the latter classes indicate their checked status by
   # showing the button as being "down".
   #
   public set_toggles(s)
      self.toggles_flag := check_flag(s)
      return self
   end

   public new()
      cast(self,Component).new()
      repeat_ticker := Dispatcher.new_task{repeat_tick()}
      self.accepts_focus_flag := 1
      connect(self.handle_lpress, Event.MOUSE_LEFT_PRESS)
      connect(self.handle_ldrag, Event.MOUSE_LEFT_DRAG)
      connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE)
      connect(self.handle_key, Event.KEY_PRESS)
      return
   end
end



