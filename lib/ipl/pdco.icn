############################################################################
#
#	File:     pdco.icn
#
#	Subject:  Procedures for programmer-defined control operations
#
#	Authors:  Ralph E. Griswold and Robert J. Alexander
#
#	Date:     June 10, 2001
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#  
#  These procedures use co-expressions to used to model the built-in
#  control structures of Icon and also provide new ones.
#
#   AddTabby{e, i}	adds tabby to treadling sequence
#  
#   Allpar{e1,e2, ...}
#			parallel evaluation with last result
#			used for short sequences
#
#   Alt{e1,e2}	models e1 | e2
#
#   CFapprox{e}	produce sequence of approximations for the
#			continued-fraction sequence e
#  
#   Compare{e1,e2}	compares result sequences of e1 and e2
#  
#   Complint{e}	produces the integers not in e
#
#   Compl{e}	   produces the integers not in e
#
#   Cond{e1,e2, ...}
#			models the generalized Lisp conditional
#
#   Cumsum{e}	generates the cumulative sum of the terms of e
#  
#   Cyclepar{e1,e2, ...}
#			parallel evaluation with shorter sequences
#			re-evaluated
#
#   Decimate{e1, e2}
#			"decimate" e1 by deleting e2-numbered terms
#			(e2 is assumed to be an increasing sequence).
#
#   Decimation{e}	produce a decimation sequence from e1 by
#			deleting even-valued terms and replacing
#			odd-valued terms by their position.
#
#   Decollate{e, i}	decollate e according to parity of i
#
#   Delta{e1}	produces the difference of the values in e1
#
#   Delta2{e, i}	   produces the difference of values in e by
#			   i places	  
#   Elevate{e1, m, n}
#			elevate e1 mod n to n values
#  
#   Every{e1,e2}	models every e1 do e2
#
#   ExtendSeq{e1,i}	extends e1 to i results
#  
#   Extract{e1,e2, ...}
#			extract results of even-numbered arguments
#			according to odd-numbered values
#
#   Fifo{e1,e2, ...}	reversal of lifo evaluation
#
#   Friendly{m, k, e3}
#			friendly sequence starting at k shaft mod m
#
#   Galt{e1,e2, ...}
#			produces the results of concatenating the
#   		   	sequences for e1, e2, ...
#
#   Gconj{e1,e2,...}
#			models generalized conjunction: e1 & e2 & ...
#
#   The programmer-defined control operation above shows an interesting
#   technique for modeling conjunction via recursive generative
#   procedures.
#
#   Histo{e}	        generates histogram for e
#			default 100.
#
#   Increasing{e}	filters out non-increasing values in integer
#			sequence
#
#   Index{e1,e2}	produce e1-th terms from e2
#
#   Inter{e1,e2, ...}
#			produces results of e1, e2, ... alternately
#  
#   Lcond{e1,e2, ...}
#			models the Lisp conditional
#
#   Length{e}	returns the length of e
#  
#   Lifo{e1,e2, ...}	models standard Icon "lifo" evaluation
#
#   Limit{e1,e2}	models e1 \ e2
#
#   List{e}	        produces a list of the results from e
#
#   LowerTrim{e}	lower trim
#
#   Map{e1,e2}	maps values of e1 in the order they first appear
#			to values of e2 (as needed)
#
#   OddEven{e}		forces odd/even sequence
#
#   Palin{e}	x produces results of concatenating the
#			sequences for e and then its reverse.
#
#  
#   Parallel{e1,e2, ...}
#			parallel evaluation terminating on
#			shortest sequence
#
#   PatternPalin{e}
#			produces pattern palindrome.
#
#   Period{e, i}	generates the periodic part of e; i values are
#			used to find the period
#
#   Permute{e1,e2}	permutes each n-subsequence of e1 by the
#   		  	n positional values in lists from e2.  If a list does
#			not consist of all the integers in the range 1 to
#   		  	n, "interesting" things happen (see the use
#   		   	of map() for transpositions).
#
#   Pivot{e, m}	produces pivot points from e % m; m default 100
#
#   PosDiff{e1,e2}	produces positions at which e1 and e2 differ
#
#   Positions{e, v}	generates the positions at which v occurs in e.
#  
#   Random{e1,e2, ...}
#			produces results of e1, e2, ... at random
#
#   Reduce{op, x, e}
#			"reduces" the sequence e by starting with the value x
#			and repetitively applying op to the current
#		  	value and values from e.
#
#   RemoveDupl{e}	removes duplicate adjacent values.
#  
#   Repalt{e}	models |e
#
#   Repeat{e1, e2}	repeats the sequence for e1 e2 times
#
#   Repl{e1,e2}	replicates each value in e1 by the corresponding
#   		   	integer value in e2.
#  
#   Resume{e1,e2,e3}
#			models every e1 \ e2 do e3
#
#   Reverse{e}  	produces the results of e in reverse order.
#  
#   Rotate(e, i)	rotates the sequence for e left by i; negative
#   		   	i rotates to the right
#
#   Selfrepl{e1,i}	produces e1 * j copies of e1
#
#   Simple{e1,e2, ...}
#			simple evaluation with only success or
#			failure
#
#   Skip{e1,e2}	generate e1 skipping each e2 terms
#
#   Smod{e1,e2}	reduce terms in e1 (shaft) modulus e2
#
#   Span{e,m}	fill in between consecutive (integer) values in
#			e % m; m default 100
#
#   Sumlimit{e, i, j}
#			produces values of e until their sum exceeds
#			i.  Values less than j are discarded.
#
#   Unique{e}	produces the unique results of e in the order
#			they first appear
#
#   UpperTrim{e}	upper trim
#
#
#   Wobble{e}	produces e(1), e(2), e(1), e(2), e(3), e(2), ...
#  
#   Comments: Some constructions, such as break and return, cannot be
#   used in arguments to programmer-defined control operations.
#  
############################################################################
#
#  Requires:  co-expressions
#
############################################################################
#
#  Links:  lists, periodic, rational
#
############################################################################

package ipl.pdco

import
   ipl.callable(callable),
   ipl.lists(lmap, lrotate),
   ipl.numbers(residue),
   ipl.periodic(repeater),
   ipl.rational(rational),
   lang(Internal),
   util(save_state, HandlerState, cvpos_item)

# PDCO to add tabby to treadling
procedure AddTabby(e, i)	
   /i :=  4	# number of regular treadles

   suspend Inter![e, create |((i + 1) | (i + 2))]

end

# Parallel evaluation with repeats
procedure Allpar(L[])	
   local i, L1, done

   L1 := list(*L)

   done := list(*L,1)

   every i := 1 to *L do L1[i] := @L[i] | fail

   repeat {
      suspend L1
      every i := 1 to *L do
         if done[i] = 1 then ((L1[i] := @L[i]) | (done[i] := 0))
      if not(!done = 1) then fail
      }

end

# PDCO to model alternation
procedure Alt(e1, e2)	

   suspend |@e1
   suspend |@e2

end

# PDCO for continued-fraction approximations
procedure CFapprox(e)	
  local prev_n, prev_m, n, m, t

  prev_n := [1]
  prev_m := [0, 1]

  put(prev_n, (@e).denom) | fail

  while t := @e do {
     n := t.denom * get(prev_n) + t.numer * prev_n[1]
     m := t.denom * get(prev_m) + t.numer * prev_m[1]
     suspend rational(n, m, 1)
     put(prev_n, n)
     put(prev_m, m)
     if t.denom ~= 0 then {		# renormalize
        every !prev_n /:= t.denom
        every !prev_m /:= t.denom
        }
     }

end

# PDCO to compare sequences
procedure Compare(e1, e2)	
   local x1

   while x1 := @e1 do
      (x1 === @e2) | fail
   if @e2 then fail else return

end

# PDCO to generate integers not in sequence
procedure Complint(e)	
   local i, j			# EXPECTS MONOTONE NON-DECREASING SEQUENCE

   j := 0

   while i := @e do {
      i := integer(i) | runerr(101, i)
      suspend j to i - 1
      j := i + 1
      }

   suspend seq(j)

end

# PDCO for generalized Lisp conditional
procedure Cond(L[])	
   local i, x

   every i := 1 to *L do
      if x := @L[i] then {
         suspend x
         suspend |@L[i]
         fail
         }

end

# PDCO to produce cumulative sum
procedure Cumsum(e)		
   local i

   i := 0

   while i +:= @e do
      suspend i

end

# PDCO to produce sum
procedure Sum(e)		
   local i

   i := 0

   while i +:= @e

   return i
end

# parallel evaluation with cycling
procedure Cyclepar(L[])	
   local i, L1, done

   L1 := list(*L)

   done := list(*L,1)

   every i := 1 to *L do L1[i] := @L[i] | fail

   repeat {
      suspend L1
      every i := 1 to *L do {
         if not(L1[i] := @L[i]) then {
            done[i] := 0
            if !done = 1 then {
               L[i] := ^L[i]
               L1[i] := @L[i] | fail
               }
            else fail
            }
         }
      }
end

# PDCO to decimate sequence
procedure Decimate(e1, e2)	
   local i, j, count

   count := 0

   while j := @e2 do {
      while i := @e1 | fail do {
         count +:= 1
         if count = j then break next
         else suspend i
         }
      }

end

# PDCO to create decimation sequence
procedure Decimation(e)	
   local i, count

   count := 0

   while i := @e do {
      count +:= 1
      if i % 2 = 1 then suspend count
      }

end
# PDCO to decollate sequence
procedure Decollate(e1, e2)	
   local i, j, x

   i := pdco_param(e2, 1, integer, 101) | fail

   i %:= 2
 
   j := 0

   while x := @e1 do {
      j +:= 1
      if j % 2 = i then suspend x
      }

end

# PDCO to generate difference sequence 
procedure Delta(e)	
   local i, j

   i := @e | fail

   while j := @e do {
      suspend j - i
      i := j
      }

end

# PDCO to elevate sequence
procedure Elevate(e1, e2, e3)	
   local n, m, shafts, i, j, k

   m := @e2 | fail
   n := @e3 | fail

   shafts := list(m)

   every !shafts := []

   every i := 1 to m do
      every put(shafts[i], i to n by m)

   while j := @e1 do {
      i := j % m + 1
      k := get(shafts[i])
      suspend k
      put(shafts[i], k)
      }

end

# PDCO to model iteration
procedure Every(e1, e2)	

   while @e1 do @^e2

end

# PDCO to extend sequence
procedure ExtendSeq(e1, e2)	
   local count

   count := @e2 | fail
   count := integer(count) | runerr(101, count)
   if count < 1 then fail

   repeat {
      suspend |@e1 do {
         count -:= 1
         if count = 0 then fail
         }
      if *e1 = 0 then fail
      e1 := ^e1
      }

end

# Extract values
procedure Extract(L[])	
   local i, n, L1

   L1 := list(*L/2)

   repeat {
      i := 1
      while i < *L do {
         n := @L[i] | fail
         every 1 to n do
            L1[(i + 1)/2] := @L[i + 1] | fail
         L[i + 1] := ^L[i + 1]
         i +:= 2
         }
      suspend L1
      } 

end

# Reversal of {Lifo} evaluation
procedure Fifo(L[])	
   local L1, j

   L1 := list(*L)

   j := *L

   repeat {
      if L1[j] := @L[j] then {
         if j = 1 then
            suspend L1
         else
            j -:= 1
      } else {
         if j = *L then fail
         L[j] := ^L[j]
         j +:= 1
      }
   }
end

# PDCO for friendly sequences
procedure Friendly(e1, e2, e3)	
   local mod, state, value

   mod := @e1 | fail
   state := @e2
   if /state then state := ?mod

   repeat {
      suspend state
      value := @e3 | fail
      if value % 2 = 0 then state +:= 1
      else state -:= 1
      state := residue(state, mod, 1)
      }

end

# PDCO to concatenate sequences
procedure Galt(L[])		
   local C

   every C := !L do
      suspend |@C

end

# PDCO for generalized conjunction
procedure Gconj(L[])	

   suspend Gconj_(L,1)

end

procedure Gconj_(L,i,v)

   local e
   if e := L[i] then {
      suspend v:= |@e & Gconj_(L,i + 1,v)
      L[i] := ^e
      }
   else suspend v

end

# histogram
procedure Histo(e1)		
   local results, seq

   seq := []

   while put(seq, @e1)

   results := list(max ! seq, 0)

   every results[!seq] +:= 1

   suspend !results

end


# PDCO to filter out non-increasing values
procedure Increasing(e)	
   local last, current

   last := @e | fail

   suspend last

   while current := @e do {
      if current <= last then next
      else {
         suspend current
         last := current
         }
      }

end

# PDCO to select terms by position
procedure Index(e1, e2)		
   local i, j, x

   j := @e2 | fail

   every i := seq() do {	# position
      x := @e1 | fail
      if j = i then {
         suspend x
         repeat {
            j := @e2 | fail
            if j > i then break
            }
         }
      }

end

# PDCO to interleave sequences
procedure Inter(L[])	

   suspend |@!L

end

# PDCO for Lisp conditional
procedure Lcond(L[])	
   local i

   every i := 1 to *L by 2 do
      if @L[i] then {
         suspend |@L[i + 1]
         fail
         }

end

# PDCO to produce length of sequence
procedure Length(e)	
   local i

   i := 0

   while @e do i +:= 1

   return i

end

# Generate the results from the several expressions in the same
# left-to-right order as in normal icon evaluation.
# 
# For example Lifo{1 to 3, !"ab"} generates [1,"a"], [1,"b"], [2,
# "a"] etc.
#
# Note that the same list instance is suspended each time, and should
# not be altered.
#
procedure Lifo(L[])	
   local L1, j

   L1 := list(*L)

   j := 1

   repeat {
      if L1[j] := @L[j] then {
         if j = *L then
            suspend L1
         else
            j +:= 1
      } else {
         if j = 1 then fail
         L[j] := ^L[j]
         j -:= 1
      }
   }
end

# PDCO to model limtation
procedure Limit(e1, e2)	
   local i, x

   while i := @e2 do {
      every 1 to i do
         if x := @e1 then suspend x
         else break
      e1 := ^e1
      }

end

#
# Create a list from the result sequence of the given co-expression.
#
# @example
# @   # Results in the list [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
# @   List{(e := 0 to 9, e * e)}
#
procedure List(e)		
   local t
   t := []
   while put(t, @e)
   return t
end

#
# Create a set from the result sequence of the given co-expression.
#
# @example
# @   # Results in the set {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}
# @   Set{(e := 0 to 9, e * e)}
#
procedure Set(e)		
   local t
   t := set()
   while insert(t, @e)
   return t
end


# Construct a table from a result sequence.  The expression {e} should
# produce 2-element lists representing key-value pairs to add to the
# table.
#
# @example
# @   # Results in the table {1->1, 2->4, 3->9, 4->16}
# @   Table{(i := 1 to 4, [i, i * i])}
#
procedure Table(e)
   local t, x
   t := table()
   while x := @e do
      insert(t, x[1], x[2])
   return t
end

# lower trimming
procedure LowerTrim(e)	
   local i

   while i := @e do {
      i -:= 1
      if i ~= 0 then suspend i
      }

end

# PDCO to map values
procedure Map(e1, e2)		
   local maptbl, x

   maptbl := table()

   while x := @e1 do {
      /maptbl[x] := (@e2 | fail)
      suspend maptbl[x]
      }

end

# PDCO to force odd/even sequence
procedure OddEven(e)	
   local val, val_old

   while val := @e do {
      if val % 2 = \val_old % 2 then
         suspend val_old + 1
      suspend val
      val_old := val
      }

end

# PDCO to produce palindromic sequence
procedure Palin(e)	
   local tail, x

   tail := []

   while x := @e do {
      suspend x
      push(tail, x)
      } 

   every suspend !tail

end


# Parallel evaluation
procedure Parallel(L[])	
   local i, L1

   L1 := list(*L)

   repeat {
      every i := 1 to *L do
         L1[i] := @L[i] | fail
      suspend L1
      }

end

# PDCO to produce pattern palindrome
procedure PatternPalin(e)	
   local tail, x

   tail := []
   while x := @e do {
      suspend x
      push(tail, x)
   }

   get(tail)

   pull(tail)

   every suspend !tail

end

# PDCO for periodic part of sequence
procedure Period(e1, e2)		
   local limit, result

   limit := pdco_param(e2, 300, integer, 101) | fail

   result := []

   every put(result, |@e1) \ limit

   result := repeater(result)

   suspend !result[2]

end

# PDCO for permutations
procedure Permute(e1, e2)	
   local temp1, temp2, chunk, i

   repeat {
      temp1 := @e2 | fail
      temp2 := []
      every put(temp2, i := 1 to *temp1)
      chunk := []
      every 1 to i do
         put(chunk, @e1) | fail
      suspend !lmap(temp1, temp2, chunk)
      }

end

# PDCO to generate pivot points
procedure Pivot(e1, e2)		
   local current, direction, m, new

   m := pdco_param(e2, 100, integer, 101) | fail

   direction := "+"

   current := @e1 % m | fail

   suspend current

   repeat {
      new := @e1 % m | break
      if new = current then next
      case direction of {
         "+":  {
            if new > current then {
               current := new
               next
               }
            else {
               suspend current
               current := new
               direction := "-"
               }
            }
         "-":  {
            if new < current then {
               current := new
               next
               }
            else {
               suspend current
               current := new
               direction := "+"
               }
            }
         }

      }

   return current

end

# positions in e of i
procedure Positions(e1, e2)	
   local v, count, x

   v := @e2 | fail

   count := 0

   while x := @e1 do {
      count +:= 1
      if x === v then suspend count
      }

end

# PDCO to generate positions of difference
procedure PosDiff(e1, e2)	
   local i, x, y

   i := 0

   while x := @e1 & y := @e2 do {
      i +:= 1
      if x ~=== y then suspend i
      }

end

# PDCO to generate from sequences at random
procedure Random(L[])	
   local x

   while x := @?L do suspend x

end

# PDCO to model repeated alternation
procedure Repalt(e)	
   repeat {
      suspend |@e
      if *e == 0 then fail
      e := ^e
      }

end

# PDCO to reduce sequence using binary operation
procedure Reduce(e1, e2, e3)	
   local op, x

   op := @e1 | fail
   op := callable(op, 2) | runerr("invalid operation for Reduce{}", op)

   x := @e2 | fail

   while x := op(x, @e3)

   return x

end

# PDCO to repeat sequence
procedure Repeat(e1, e2)	
   local i

   while i := @e2 do {
      i := integer(i) | runerr(101, i)
      every 1 to i do {
         suspend |@e1
         e1 := ^e1
         }
      }

end

# PDCO for remove duplicate values in a sequence
procedure RemoveDupl(e)	
   local old, new

   old := @e | fail
   suspend old

   repeat {
      new := @e | fail
      if new === old then next
      else {
         suspend new
         old := new
         }
      }

end

# PDCO to replicate values in a sequence
procedure Repl(e1, e2)	
   local x, i

   while x := @e1 do {
      i := @\e2 | 1
      suspend (1 to i) & x
      }

end

# PDCO to model limited iteration
procedure Resume(e1, e2, e3)	
   local i

   while i := @e2 do {
      e1 := ^e1
      every 1 to i do if @e1 then @^e3 else break
   }

end

# PDCO to reverse sequence
procedure Reverse(e)
   local result
   result := []
   while push(result, @e)
   suspend !result
end

# PDCO to rotate sequence
procedure Rotate(e1, e2)		
   local result, i, x

   i := @e2 | fail
   i := integer(i) | runerr(101, i)

   result := []

   if i <= 0 then {		# if not to right, works for infinite sequence
      every 1 to -i do
         put(result, @e1) | break
      while x := @e1 do
         suspend x
      suspend !result
      }

   else {
      while put(result, @e1)
      suspend !lrotate(result, i)
      }

end

# PDCO to produce multiple of values in sequence
procedure Selfrepl(e1, e2)	
   local i, j
   j := pdco_param(e2, 1, integer, 101) | fail
   while i := @e1 do {
      i := integer(i) | runerr(101, i)
      suspend (1 to i * j) & i
      }

end

# PDCO to generate integers not in sequence
procedure Compl(e)	
   local i, j

   j := 1

   while i := @e do {
      i := integer(i) | runerr(101, i)
      suspend j to i - 1
      j := i + 1
      }

   suspend seq(j)

end

# PDCO to generate differences in sequences 
procedure Delta2(e1, e2)	
   local C, i

   C := ^e1
   every 1 to @e2 do @C

   while i := @C - @e1 do
     suspend i

end

# simple evaluation
procedure Simple(L[])	
   local i, L1

   L1 := list(*L)

   every i := 1 to *L do
      L1[i] := @L[i] | fail

   return L1

end

# PDCO to skip terms
procedure Skip(e1, e2)	
   local gap

   suspend @e1

   repeat {
      gap := @e2 | fail
      every 1 to gap do
         @e1 | fail
      suspend @e1
      }

end

# generalized modular reduction
procedure Smod(e1, e2)		
   local i, m

   while i := @e1 do {
      m := @e2 | fail
      suspend residue(i, m, 1)
      }

end

# fill in gaps in integer sequences
procedure Span(e1, e2)		
   local i, j, m

   m := pdco_param(e2, 100, integer, 101) | fail

   j := @e1 | fail
   while i := residue(@e1, m, 1) do {
      if i > j then suspend j to i - 1
      else if i < j then suspend j to i + 1 by -1
      j := i
      } 

   suspend j

end

# PDCO to sum sequence to a limit
procedure Sumlimit(e1, e2, e3) 	
   local sum, min, limit, i

   limit := pdco_param(e2, 2^15, integer, 101) | fail
   min := pdco_param(e3, 0, integer, 101) | fail
   sum := 0

   while i := @e1 do {
      if i < min then next
      if (sum + i) > limit then fail
      sum +:= i
      suspend i
      }

end

# PDCO to filter out duplication values
procedure Unique(e)	
   local done, x

   done := set()

   while x := @e do
      if not member(done, x) then {
         insert(done, x)
         suspend x
         }

end

# upper sequence trimming
procedure UpperTrim(e)	
   local done, i

   done := set()

   while i := @e do {
      if not member(done, i) then
         insert(done, i)
      else suspend i
      }

end


# PDCO to produce sequence values alternately
procedure Wobble(e)	
   local x, y

   x := @e | fail
   suspend x

   while y := @e do {
      suspend y | x | y
      x := y
      }

end

#
# Evaluate the given expression, suspending its results, whilst
# ignoring any non-fatal runtime errors.  After failure,
# {&errortext} can be tested to see whether or not failure was
# caused by a runtime error.
#
procedure Safe(e)
   suspend save_state(e, HandlerState(&current))
end

# A useful wrapper around {Safe}.  {Safe} is called with {e} to get
# its first result.  If no runerr occurs, then the result produced by
# {e} is returned.  If {e} fails, {&null} is returned.  If a runerr
# occurs, {errorclear} is called, {&why} is set and the procedure
# fails.
#
procedure Safe1(e)
   local v
   v := Safe(e)
   if &errortext then {
      &why := if &errornumber then
         "Runtime error " || &errornumber || ": " || &errortext
      else                                                     
         "Runtime error: " || &errortext                       
      &why ||:= "; offending value: " || image(&errorvalue)
      errorclear()
   } else
      return v
end

# Dijkstra non-deterministic if construct
procedure If(a[])
   local x, i
   x := []
   every i := 1 to *a by 2 do 
      if @a[i] then 
         put(x, i)

   if *x = 0 then
      runerr("If : no guard succeeded")

   i := ?x + 1
   suspend |@a[i]
end

# Dijkstra non-deterministic do construct
procedure Do(a[])
   local x, i
   repeat {
      x := []
      every i := 1 to *a by 2 do
         if @^a[i] then 
            put(x, i)

      if *x = 0 then
         break

      @^a[?x + 1]
   }
end

#
# Generate the results of a co-expression as a sequence.
#
procedure Seq(e)
   suspend |@e
end


# Evaluate each element of e, suspending all the results of the nth element.
#
procedure Each(e1, e[])
   local f, n
   n := @e1 | fail
   n := integer(n) | runerr(101, n)
   n := cvpos_item(n, *e) | fail
   every f := !e do {
      if (n -:= 1) = 0 then
         suspend |@f
      else
         @f
   }
end

#
# Parallel assignment to each result of e from each corresponding result of f.
#
procedure Assign(e, f)
   while @e := @f
end

#
# Parallel swap between corresponding results of e and f.
#
procedure Swap(e, f)
   while @e :=: @f
end

#
# Generate results from co-expression `e`, while function `f`, applied
# to each result, succeeds.
#
procedure TakeWhile(f, e)
   local i
   f := @f | fail
   f := callable(f) | runerr("invalid function for TakeWhile{}", f)
   while f(i := @e) do
      suspend i
end

#
# Discard results from co-expression `e`, while function `f`, applied
# to each result, succeeds.  Then generate the remainder of the
# results from `e`.
#
procedure DropWhile(f, e)
   local i
   f := @f | fail
   f := callable(f) | runerr("invalid function for DropWhile{}", f)
   repeat {
      i := @e | fail
      f(i) | break
   }
   suspend i | |@e
end

#
# Generate results from co-expression `e`, filtered by function `f`.
#
procedure Filter(f, e)
   local i
   f := @f | fail
   f := callable(f) | runerr("invalid function for Filter{}", f)
   while i := @e do
      if f(i) then
         suspend i
end

#
# Apply a function, given by the first parameter, to the remaining sequences.
#
procedure Zip(ef, el[])
   local n, f, e, t
   # Allow operators if 1-3 parameters
   if 1 <= *el <= 3 then
      n := *el
   f := @ef | fail
   f := callable(f, n) | runerr("invalid operation for Zip{}", f)
   if *el = 0 then
      fail
   repeat {
      t := []
      every e := !el do
         put(t, @e) | fail
      suspend f!t
      if f := @ef then
         f := callable(f, n) | runerr("invalid operation for Zip{}", f)
   }
end

package procedure MinMaxImpl(e, cmp, dir)
   local i, v
   cmp := pdco_param(cmp, Internal.compare, callable, "invalid function for Min/Max{}") | fail
   v := @e | fail
   while i := @e do {
      if dir * cmp(i, v) > 0 then
         v := i
   }
   return v
end

# Return the maximum element in the sequence `e`, based on the
# comparison function `cmp`, which defaults to `Internal.compare`.
#
procedure Max(e, cmp)
   return MinMaxImpl(e, cmp, 1)
end

# Return the minimum element in the sequence `e`, based on the
# comparison function `cmp`, which defaults to `Internal.compare`.
#
procedure Min(e, cmp)
   return MinMaxImpl(e, cmp, -1)
end

# Helper function to convert an optional parameter specified in a pdco
# invocation.  `v` is the parameter (a coexpression or &null).  `def`
# is a default value if `v` is &null.  If the coexpression fails to
# produce a result, the procedure fails.  If the optional conversion
# function fails, then a runerr is signalled with the given error
# message.
#
procedure pdco_param(v, def, cvt, err)
   if /v then
      return def
   v := @v | fail
   if \cvt then
      v := cvt(v) | runerr(err, v)
   return v
end
