<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>genrfncs.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     genrfncs.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures to generate sequences
<a name="6"/>#
<a name="7"/>#	Author:   Ralph E. Griswold
<a name="8"/>#
<a name="9"/>#	Date:     June 10, 2001
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#  
<a name="17"/>#  These procedures generate sequences of results.
<a name="18"/>#
<a name="19"/>#  arandseq(i, j)	arithmetic sequence starting at i with randomly
<a name="20"/>#			chosen increment between 1 and j
<a name="21"/>#  
<a name="22"/>#  arithseq(i, j)	arithmetic sequence starting at i with increment j
<a name="23"/>#
<a name="24"/>#  beatty1seq()		Beatty's first sequence i * Math.PHI
<a name="25"/>#
<a name="26"/>#  beatty2seq()		Beatty's second sequence i * Math.PHI ^ 2
<a name="27"/>#
<a name="28"/>#  catlnseq(i)		sequence of generalized Catalan numbers
<a name="29"/>#
<a name="30"/>#  cfseq(i, j)		continued-fraction sequence for i / j
<a name="31"/>#
<a name="32"/>#  chaosseq()		chaotic sequence
<a name="33"/>#
<a name="34"/>#  chexmorphseq()	sequence of centered hexamorphic numbers
<a name="35"/>#
<a name="36"/>#  connellseq(p)	generalized Connell sequence
<a name="37"/>#
<a name="38"/>#  dietzseq(s)		Dietz sequence for polynomial
<a name="39"/>#
<a name="40"/>#  dressseq(i)		dress sequence with increment i, default 1 (Schroeder)
<a name="41"/>#
<a name="42"/>#  factseq()		factorial sequence
<a name="43"/>#
<a name="44"/>#  fareyseq(i, k)	Farey fraction sequence; k = 0, the default, produces
<a name="45"/>#			numerator sequence; k = 1 produces denominator
<a name="46"/>#			sequence
<a name="47"/>#
<a name="48"/>#  fibseq(i, j, k, m)	generalized Fibonacci sequence (Lucas sequence)
<a name="49"/>#			with initial values i and j and additive constant
<a name="50"/>#			k.  If m is supplied, the results are produced
<a name="51"/>#			mod m.
<a name="52"/>#
<a name="53"/>#  figurseq(i)		series of ith figurate number
<a name="54"/>#
<a name="55"/>#  fileseq(s, i)	generate from file s; if i is null, lines are generated.
<a name="56"/>#			Otherwise characters, except line terminators.
<a name="57"/>#
<a name="58"/>#  friendseq(k)		generate random friendly sequence from k values, 1 to k
<a name="59"/>#			(in a friendly sequence, successive terms differ by 1).
<a name="60"/>#
<a name="61"/>#
<a name="62"/>#  geomseq(i, j)	geometric sequence starting at i with multiplier j
<a name="63"/>#
<a name="64"/>#  hailseq(i)		hailstone sequence starting at i
<a name="65"/>#
<a name="66"/>#  irepl(i, j)		j instances of i
<a name="67"/>#
<a name="68"/>#  lrrcseq(L1, L2)
<a name="69"/>#			generalized linear recurrence with constant
<a name="70"/>#			coefficients; L1 is a list of initial terms,
<a name="71"/>#			L2 is a list of coefficients for n prevous values,
<a name="72"/>#			where n = *L2
<a name="73"/>#
<a name="74"/>#  meanderseq(s, n)	sequences of all characters that contain all n-tuples
<a name="75"/>#			of characters from s
<a name="76"/>#	
<a name="77"/>#  mthueseq()		Morse-Thue sequence
<a name="78"/>#
<a name="79"/>#  mthuegseq(i)		Morse-Thue sequence for base i
<a name="80"/>#
<a name="81"/>#  multiseq(i, j, k)	sequence of (i * j + k) i's
<a name="82"/>#
<a name="83"/>#  ngonalseq(i)		sequence of the ith polygonal number
<a name="84"/>#
<a name="85"/>#  nibonacciseq(values[])
<a name="86"/>#			generalized Fibonacci sequence that sums the
<a name="87"/>#			previous n terms, where n = *values.
<a name="88"/>#
<a name="89"/>#  partitseq(i, j, k)	sequence of integer partitions of i with minimum j
<a name="90"/>#			and maximum k
<a name="91"/>#
<a name="92"/>#  pellseq(i, j, k)	generalized Pell's sequence starting with i, j and
<a name="93"/>#			using multiplier k
<a name="94"/>#
<a name="95"/>#  perrinseq()		Perrin sequence
<a name="96"/>#
<a name="97"/>#  polyseq(coeff[])	polynomial in x evaluated for x := seq()
<a name="98"/>#	
<a name="99"/>#  primeseq()		the sequence of prime numbers
<a name="100"/>#
<a name="101"/>#  powerseq(i)		sequence n ^ i, n = 1, 2, 3, 4, ...
<a name="102"/>#
<a name="103"/>#  powersofseq(i)	sequence i ^ n, n = 1, 2, 3, 4, ...n
<a name="104"/>#
<a name="105"/>#  rabbitseq()		rabbit sequence
<a name="106"/>#
<a name="107"/>#  ratsseq(i)		versumseq() with sort
<a name="108"/>#
<a name="109"/>#  signaseq(r)		signature sequence of r
<a name="110"/>#
<a name="111"/>#  spectseq(r)		spectral sequence integer(i * r), i - 1, 2, 3, ...
<a name="112"/>#
<a name="113"/>#  srpseq(n, m)		palindromic part of the continued-fraction sequence
<a name="114"/>#			for sqrt(n^2+m)
<a name="115"/>#
<a name="116"/>#  versumseq(i, j)	generalized sequence of added reversed integers with
<a name="117"/>#			seed i (default 196) and increment j (default 0)
<a name="118"/>#
<a name="119"/>#  versumopseq(i, p)	procedure p (default 1) applied to versumseq(i)
<a name="120"/>#
<a name="121"/>#  vishwanathseq()	random variation on Fibonacci sequence
<a name="122"/>#
<a name="123"/>#  zebra(values[])	zebra colors, alternating 2 and 1, for number of
<a name="124"/>#			times given by successive values
<a name="125"/>#  
<a name="126"/>############################################################################
<a name="127"/>#
<a name="128"/>#  Requires:  co-expressions
<a name="129"/>#
<a name="130"/>############################################################################
<a name="131"/>#
<a name="132"/>#  Links:  convert, factors, fastfncs, io, lindgen, lists, numbers,
<a name="133"/>#	partit, periodic, polynom, rational, strings, xcode
<a name="134"/>#
<a name="135"/>############################################################################
<a name="136"/>
<a name="137"/>package ipl.genrfncs
<a name="138"/>
<a name="139"/>import
<a name="140"/>   io(close),
<a name="141"/>   ipl.convert(exbase10),
<a name="142"/>   ipl.io(dopen),
<a name="143"/>   ipl.lists(lequiv, lreverse),
<a name="144"/>   ipl.numbers(adr, gcd),
<a name="145"/>   ipl.partit(partit),
<a name="146"/>   ipl.periodic(Sqrt),
<a name="147"/>   ipl.polynom(poly2profile, polyadd, polyexp, polymul,
<a name="148"/>               polysub, str2poly),
<a name="149"/>   ipl.strings(csort, deletec),
<a name="150"/>   util(Math)
<a name="151"/>
<a name="152"/># arithmetic sequence with random intervals
<a name="153"/>procedure arandseq(i, j)	
<a name="154"/>
<a name="155"/>   /i := 1
<a name="156"/>   /j := 1
<a name="157"/>
<a name="158"/>   suspend seq(i) + ?j
<a name="159"/>
<a name="160"/>end
<a name="161"/>
<a name="162"/># arithmetic sequence
<a name="163"/>procedure arithseq(i, j)	
<a name="164"/>
<a name="165"/>   /i := 1
<a name="166"/>   /j := 0
<a name="167"/>
<a name="168"/>   suspend seq(i + j)
<a name="169"/>
<a name="170"/>end
<a name="171"/>
<a name="172"/># Beatty sequence 1
<a name="173"/>procedure beatty1seq(r)		
<a name="174"/>
<a name="175"/>   /r := Math.PHI
<a name="176"/>
<a name="177"/>   suspend integer(seq() * r)
<a name="178"/>
<a name="179"/>end
<a name="180"/>
<a name="181"/># Beatty sequence 2
<a name="182"/>procedure beatty2seq(r)		
<a name="183"/>
<a name="184"/>   /r := Math.PHI
<a name="185"/>
<a name="186"/>   suspend integer(seq() * (r / (r - 1)))
<a name="187"/>
<a name="188"/>end
<a name="189"/>
<a name="190"/># generalized Catalan sequence
<a name="191"/>procedure catlnseq(i)		
<a name="192"/>   local k
<a name="193"/>
<a name="194"/>  /i := 1
<a name="195"/>
<a name="196"/>   suspend (i := 1, k := seq(), i *:= 4 * k + 2, i /:= k + 2)
<a name="197"/>
<a name="198"/>end
<a name="199"/>
<a name="200"/># Hofstadter's chaotic sequence
<a name="201"/>procedure chaosseq(q)		
<a name="202"/>
<a name="203"/>   suspend q(seq())
<a name="204"/>
<a name="205"/>end
<a name="206"/>
<a name="207"/>#  The generalization here is to allow a generating procedure, p to
<a name="208"/>#  be specified.  The default is seq().  Arguments are given in args.
<a name="209"/>
<a name="210"/># generalized Connell sequence
<a name="211"/>procedure connellseq(p, args[])	
<a name="212"/>   local i, j, count, parity, parity2, C
<a name="213"/>
<a name="214"/>   C := create (\p | seq) ! args
<a name="215"/>
<a name="216"/>   count := 0
<a name="217"/>   parity := 0
<a name="218"/>   parity2 := 1
<a name="219"/>
<a name="220"/>   repeat {
<a name="221"/>      count +:= 1
<a name="222"/>      parity :=: parity2
<a name="223"/>      j := 0
<a name="224"/>      repeat {
<a name="225"/>         i := @C | fail
<a name="226"/>         if i % 2 = parity then {
<a name="227"/>            suspend i
<a name="228"/>            j +:= 1
<a name="229"/>            if j = count then break
<a name="230"/>            }
<a name="231"/>         }
<a name="232"/>      }
<a name="233"/>
<a name="234"/>end
<a name="235"/>   
<a name="236"/># sequence of centered hexamorphic numbers
<a name="237"/>procedure chexmorphseq()	
<a name="238"/>   local i, j
<a name="239"/>
<a name="240"/>   every (i := seq(), j := 3 * i * (i - 1) + 1, j ? {
<a name="241"/>      tab(-*i)
<a name="242"/>      if =i then suspend j
<a name="243"/>      })
<a name="244"/>
<a name="245"/>end
<a name="246"/>
<a name="247"/># continued-fraction sequence
<a name="248"/>procedure cfseq(i, j)	
<a name="249"/>   local r
<a name="250"/>
<a name="251"/>   until j = 0 do {
<a name="252"/>     suspend integer(i / j)
<a name="253"/>     r := i % j
<a name="254"/>     i := j
<a name="255"/>     j := r
<a name="256"/>     }
<a name="257"/>
<a name="258"/>end
<a name="259"/>
<a name="260"/>procedure dietzseq(str)
<a name="261"/>   local vars
<a name="262"/>
<a name="263"/>   str := deletec(str, ' ')		# delete blanks
<a name="264"/>
<a name="265"/>   vars := &amp;letters ** cset(str)
<a name="266"/>
<a name="267"/>   suspend !map(poly2profile(eval(str)), vars, &amp;digits[2+:*vars])
<a name="268"/>
<a name="269"/>end
<a name="270"/>
<a name="271"/>procedure eval(str)
<a name="272"/>
<a name="273"/>   while str ?:= 2(="(", tab(bal(')')), =")", pos(0))
<a name="274"/>
<a name="275"/>   return oper(str) | str2poly(str)
<a name="276"/>
<a name="277"/>end
<a name="278"/>
<a name="279"/>procedure oper(str)
<a name="280"/>
<a name="281"/>   return str ? form(tab(bal('\-+*^')), move(1), tab(0))
<a name="282"/>
<a name="283"/>end
<a name="284"/>
<a name="285"/>procedure form(str1, op, str2)
<a name="286"/>
<a name="287"/>   return case op of {
<a name="288"/>      "+"  :  polyadd(eval(str1), eval(str2))
<a name="289"/>      "-"  :  polysub(eval(str1), eval(str2))
<a name="290"/>      "*"  :  polymul(eval(str1), eval(str2))
<a name="291"/>      "^"  :  polyexp(eval(str1), str2)
<a name="292"/>      }
<a name="293"/>
<a name="294"/>end
<a name="295"/>
<a name="296"/># dress sequence
<a name="297"/>procedure dressseq(i)		
<a name="298"/>   local s, t
<a name="299"/>
<a name="300"/>   /i := 1
<a name="301"/>
<a name="302"/>   s := [0]
<a name="303"/>
<a name="304"/>   suspend !s
<a name="305"/>
<a name="306"/>   repeat {
<a name="307"/>      t := []
<a name="308"/>      every put(t, !s + i)
<a name="309"/>      suspend !t
<a name="310"/>      s |||:= t
<a name="311"/>      }
<a name="312"/>
<a name="313"/>end
<a name="314"/>
<a name="315"/>
<a name="316"/># factorial sequence
<a name="317"/>procedure factseq()		
<a name="318"/>   local i
<a name="319"/>
<a name="320"/>   i := 1
<a name="321"/>
<a name="322"/>   suspend i *:= seq()
<a name="323"/>
<a name="324"/>end
<a name="325"/>
<a name="326"/>record farey(magnitude, n, d)
<a name="327"/>
<a name="328"/># Farey fraction sequence
<a name="329"/>procedure fareyseq(i, k)		
<a name="330"/>   local farey_list, n, d
<a name="331"/>
<a name="332"/>   /k := 0				# default numerators
<a name="333"/>
<a name="334"/>   k := integer(k) | fail
<a name="335"/>
<a name="336"/>   farey_list := [farey(0.0, 0, 1)]
<a name="337"/>
<a name="338"/>   every d := 1 to i do
<a name="339"/>      every n := 1 to d do {
<a name="340"/>         if gcd(n, d) = 1 then
<a name="341"/>            put(farey_list, farey(real(n) / d, n, d))
<a name="342"/>         }
<a name="343"/>
<a name="344"/>   farey_list := sortf(farey_list, 1)
<a name="345"/>
<a name="346"/>   case k of {
<a name="347"/>      0  :  every suspend (!farey_list).n	# numerator sequence
<a name="348"/>      1  :  every suspend (!farey_list).d	# denominator sequence
<a name="349"/>      }
<a name="350"/>
<a name="351"/>end
<a name="352"/>      
<a name="353"/># Farey fraction denominator sequence
<a name="354"/>procedure fareydseq(i)		
<a name="355"/>   local parity, j
<a name="356"/>
<a name="357"/>   parity := 1
<a name="358"/>
<a name="359"/>   every j := fareyseq(i) do {
<a name="360"/>      if parity &lt; 0 then suspend j
<a name="361"/>      parity *:= -1
<a name="362"/>      }
<a name="363"/>
<a name="364"/>end
<a name="365"/>
<a name="366"/># Farey fraction numerator sequence
<a name="367"/>procedure fareynseq(i)		
<a name="368"/>   local parity, j
<a name="369"/>
<a name="370"/>   parity := 1
<a name="371"/>
<a name="372"/>   every j := fareyseq(i) do {
<a name="373"/>      if parity &gt; 0 then suspend j
<a name="374"/>      parity *:= -1
<a name="375"/>      }
<a name="376"/>
<a name="377"/>end
<a name="378"/>
<a name="379"/># Farey fraction numerator sequence, 1-based
<a name="380"/>procedure fareyn1seq(i)		
<a name="381"/>
<a name="382"/>   suspend fareynseq(i) + 1
<a name="383"/>
<a name="384"/>end
<a name="385"/>
<a name="386"/># generalized Fibonacci sequence
<a name="387"/>procedure fibseq(i, j, k, m)	
<a name="388"/>   local n
<a name="389"/>
<a name="390"/>   /i := 1
<a name="391"/>   /j := 1
<a name="392"/>   /k := 0
<a name="393"/>
<a name="394"/>   if /m then {
<a name="395"/>      suspend i | j | |{
<a name="396"/>         n := i + j + k
<a name="397"/>         i := j
<a name="398"/>         j := n
<a name="399"/>         }
<a name="400"/>      }
<a name="401"/>   else {
<a name="402"/>      suspend i % m | j % m | |{
<a name="403"/>         n := (i + j + k) % m
<a name="404"/>         i := j
<a name="405"/>         j := n
<a name="406"/>         }
<a name="407"/>      }
<a name="408"/>
<a name="409"/>end
<a name="410"/>
<a name="411"/>#  Warning; if not all lines are generated from the input file, the
<a name="412"/>#  file is not closed until the next call of fileseq().
<a name="413"/>
<a name="414"/># sequence from file
<a name="415"/>procedure fileseq(s, i)		
<a name="416"/>   static input
<a name="417"/>
<a name="418"/>   close(\input)
<a name="419"/>
<a name="420"/>   input := dopen(s) | fail
<a name="421"/>
<a name="422"/>   if /i then suspend !input
<a name="423"/>   else suspend !!input
<a name="424"/>
<a name="425"/>   close(input)
<a name="426"/>
<a name="427"/>   input := &amp;null
<a name="428"/>
<a name="429"/>end
<a name="430"/>
<a name="431"/># sequence of figurate numbers
<a name="432"/>procedure figurseq(i)		
<a name="433"/>   local j, k
<a name="434"/>
<a name="435"/>   /i := 1
<a name="436"/>
<a name="437"/>   suspend (j := 1, k := seq(i), j *:= k + 1, j /:= k + 1 - i)
<a name="438"/>
<a name="439"/>end
<a name="440"/>
<a name="441"/># random friendly sequence
<a name="442"/>procedure friendseq(k)		
<a name="443"/>   local state
<a name="444"/>
<a name="445"/>   state := ?k
<a name="446"/>
<a name="447"/>   repeat {
<a name="448"/>      suspend state
<a name="449"/>      case state of {
<a name="450"/>         1        :  state +:= 1
<a name="451"/>         k        :  state -:= 1
<a name="452"/>         default  :  state +:= ?[1, -1]
<a name="453"/>         }
<a name="454"/>      }
<a name="455"/>
<a name="456"/>end
<a name="457"/>      
<a name="458"/># geometric sequence
<a name="459"/>procedure geomseq(i, j)		
<a name="460"/>
<a name="461"/>   /i := 1
<a name="462"/>   /j := 1
<a name="463"/>
<a name="464"/>   suspend seq(i) * j
<a name="465"/>
<a name="466"/>end
<a name="467"/>
<a name="468"/># hailstone sequence
<a name="469"/>procedure hailseq(i)		
<a name="470"/>
<a name="471"/>   /i := 1
<a name="472"/>
<a name="473"/>   suspend |if i % 2 = 0 then i /:= 2 else i := 3 * i + 1
<a name="474"/>
<a name="475"/>end
<a name="476"/>
<a name="477"/># repeated sequence
<a name="478"/>procedure irepl(i, j)		
<a name="479"/>
<a name="480"/>   /i := 1
<a name="481"/>   /j := 1
<a name="482"/>
<a name="483"/>   suspend |i \ j
<a name="484"/>
<a name="485"/>end
<a name="486"/>
<a name="487"/># synonym for lrrcseq
<a name="488"/>procedure linrecseq(terms, coeffs)	
<a name="489"/>   linrecseq := lrrcseq
<a name="490"/>
<a name="491"/>   suspend lrrcseq(terms, coeffs)
<a name="492"/>
<a name="493"/>end
<a name="494"/>
<a name="495"/># linear recurrence sequence
<a name="496"/>procedure lrrcseq(terms, coeffs)	
<a name="497"/>   local i, term
<a name="498"/>
<a name="499"/>   suspend !terms
<a name="500"/>
<a name="501"/>   repeat {
<a name="502"/>      term := 0
<a name="503"/>      every i := 1 to *coeffs do
<a name="504"/>         term +:= terms[i] * coeffs[-i]
<a name="505"/>      suspend term
<a name="506"/>      get(terms)
<a name="507"/>      put(terms, term)
<a name="508"/>      }
<a name="509"/>
<a name="510"/>end
<a name="511"/>
<a name="512"/># generate meandering characters
<a name="513"/>procedure meanderseq(alpha, n)	
<a name="514"/>   local sequence, trial, i, c
<a name="515"/>
<a name="516"/>   i := *alpha
<a name="517"/>
<a name="518"/>   sequence := repl(alpha[1], n - 1)			# base string
<a name="519"/>
<a name="520"/>   while c := alpha[i] do {			# try a character
<a name="521"/>      trial := right(sequence, n - 1) || c
<a name="522"/>      if find(trial, sequence) then
<a name="523"/>         i -:= 1
<a name="524"/>      else {
<a name="525"/>         sequence ||:= c				# add it
<a name="526"/>         i := *alpha				# and start from end again
<a name="527"/>         suspend c
<a name="528"/>         }
<a name="529"/>      }
<a name="530"/>
<a name="531"/>end
<a name="532"/>
<a name="533"/># Morse-Thue sequence
<a name="534"/>procedure mthueseq()		
<a name="535"/>   local s, t
<a name="536"/>
<a name="537"/>   s := 0
<a name="538"/>
<a name="539"/>   suspend s
<a name="540"/>
<a name="541"/>   repeat {
<a name="542"/>      t := map(s, "01", "10")
<a name="543"/>      every suspend integer(!t)
<a name="544"/>      s ||:= t
<a name="545"/>      }
<a name="546"/>
<a name="547"/>end
<a name="548"/>
<a name="549"/># generalized Morse-Thue sequence
<a name="550"/>procedure mthuegseq(j)		
<a name="551"/>
<a name="552"/>   suspend adr(exbase10(seq(0), j)) % j		# only works through base 10
<a name="553"/>      
<a name="554"/>end
<a name="555"/>   
<a name="556"/># sequence of repeated integers
<a name="557"/>procedure multiseq(i, j, k)	
<a name="558"/>
<a name="559"/>   /i := 1
<a name="560"/>   /j := 1
<a name="561"/>   /k := 0
<a name="562"/>
<a name="563"/>   suspend (i := seq(i), (|i \ (i * j + k)) &amp; i)
<a name="564"/>
<a name="565"/>end
<a name="566"/>
<a name="567"/># sequence of polygonal numbers
<a name="568"/>procedure ngonalseq(i)		
<a name="569"/>   local j, k
<a name="570"/>
<a name="571"/>   /i := 2
<a name="572"/>
<a name="573"/>   k := i - 2
<a name="574"/>
<a name="575"/>   suspend ((j := 1) | (j +:= 1 + k * seq()))
<a name="576"/>
<a name="577"/>end
<a name="578"/>
<a name="579"/># n-valued Fibonacci generalization
<a name="580"/>procedure nibonacciseq(values[])	
<a name="581"/>   local sum
<a name="582"/>
<a name="583"/>   if *values = 0 then fail
<a name="584"/>
<a name="585"/>   suspend !values
<a name="586"/>
<a name="587"/>   repeat {
<a name="588"/>      sum := 0
<a name="589"/>      every sum +:= !values
<a name="590"/>      suspend sum
<a name="591"/>      get(values)
<a name="592"/>      put(values, sum)
<a name="593"/>      }
<a name="594"/>
<a name="595"/>end
<a name="596"/>
<a name="597"/># sequence of integer partitions
<a name="598"/>procedure partitseq(i, j, k)	
<a name="599"/>
<a name="600"/>   /i := 1
<a name="601"/>   /j := 1
<a name="602"/>   /k := i
<a name="603"/>
<a name="604"/>   suspend !partit(i, j, k)
<a name="605"/>
<a name="606"/>end
<a name="607"/>
<a name="608"/># generalized Pell sequence
<a name="609"/>procedure pellseq(i, j, k)	
<a name="610"/>   local m
<a name="611"/>
<a name="612"/>   /i := 1
<a name="613"/>   /j := 2
<a name="614"/>   /k := 2
<a name="615"/>
<a name="616"/>   suspend i | j | |{
<a name="617"/>      m := i + k * j
<a name="618"/>      i := j
<a name="619"/>      j := m
<a name="620"/>      }
<a name="621"/>
<a name="622"/>end
<a name="623"/>
<a name="624"/># perrin sequence
<a name="625"/>procedure perrinseq()		
<a name="626"/>   local i, j, k, l
<a name="627"/>
<a name="628"/>   suspend i := 0
<a name="629"/>   suspend j := 2
<a name="630"/>   suspend k := 3
<a name="631"/>
<a name="632"/>   repeat {
<a name="633"/>      suspend l := i + j
<a name="634"/>      i := j
<a name="635"/>      j := k
<a name="636"/>      k := l
<a name="637"/>      }
<a name="638"/>
<a name="639"/>end
<a name="640"/>
<a name="641"/># sequence of polynomial evaluations
<a name="642"/>procedure polyseq(coeff[])	
<a name="643"/>   local i, j, sum
<a name="644"/>
<a name="645"/>   every i := seq() do {
<a name="646"/>      sum := 0
<a name="647"/>      every j := 1 to *coeff do
<a name="648"/>         sum +:= coeff[j] * i ^ (j - 1)
<a name="649"/>      suspend sum
<a name="650"/>      }
<a name="651"/>
<a name="652"/>end
<a name="653"/>
<a name="654"/># sequence of prime numbers
<a name="655"/>procedure primeseq()		
<a name="656"/>   local i, k
<a name="657"/>
<a name="658"/>   suspend 2 | ((i := seq(3, 2)) &amp; (not(i = (k := (3 to Math.sqrt(i) by 2)) *
<a name="659"/>      (i / k))) &amp; i)
<a name="660"/>
<a name="661"/>end
<a name="662"/>
<a name="663"/># powers
<a name="664"/>procedure powersofseq(i)		
<a name="665"/>
<a name="666"/>   /i := 2
<a name="667"/>
<a name="668"/>   suspend i ^ seq(i)
<a name="669"/>
<a name="670"/>end
<a name="671"/>
<a name="672"/># powers sequence
<a name="673"/>procedure powerseq(i)		
<a name="674"/>
<a name="675"/>   suspend seq() ^ i
<a name="676"/>
<a name="677"/>end
<a name="678"/>
<a name="679"/># rabbit sequence
<a name="680"/>procedure rabbitseq()		
<a name="681"/>   local seq, i
<a name="682"/>
<a name="683"/>   seq := [0]
<a name="684"/>
<a name="685"/>   suspend 1
<a name="686"/>
<a name="687"/>   repeat {
<a name="688"/>      i := get(seq)
<a name="689"/>      suspend i
<a name="690"/>      if i = 0 then put(seq, 1)
<a name="691"/>      else every put(seq, 1 | 0)
<a name="692"/>      }
<a name="693"/>
<a name="694"/>end
<a name="695"/>   
<a name="696"/># reverse add and then sort sequence
<a name="697"/>procedure ratsseq(i, p)		
<a name="698"/>
<a name="699"/>   /p := 1
<a name="700"/>
<a name="701"/>   repeat {
<a name="702"/>      i +:= reverse(i)
<a name="703"/>      i := integer(p(csort(i)))
<a name="704"/>      suspend i
<a name="705"/>      }
<a name="706"/>
<a name="707"/>end
<a name="708"/>
<a name="709"/>record entry(value, i, j)
<a name="710"/>
<a name="711"/># signature sequence
<a name="712"/>procedure signaseq(r, n, m)	
<a name="713"/>   local i, j, result
<a name="714"/>
<a name="715"/>   /n := 100
<a name="716"/>   /m := 100
<a name="717"/>
<a name="718"/>   result := []
<a name="719"/>
<a name="720"/>   every j := 1 to n do 
<a name="721"/>      every i := 1 to m do
<a name="722"/>         put(result, entry(i + j * r, i, j))
<a name="723"/>
<a name="724"/>   result := sortf(result, 1)
<a name="725"/>
<a name="726"/>   suspend (!result)[2]
<a name="727"/>
<a name="728"/>end
<a name="729"/>
<a name="730"/># spectral sequence
<a name="731"/>procedure spectseq(r)		
<a name="732"/>
<a name="733"/>   /r := 1.0
<a name="734"/>
<a name="735"/>   suspend integer(seq() * r)
<a name="736"/>
<a name="737"/>end
<a name="738"/>
<a name="739"/>
<a name="740"/># generate square-root palindrome
<a name="741"/>procedure srpseq(n, m)		
<a name="742"/>   local iter, count, okay, rat, j, pal
<a name="743"/>
<a name="744"/>   unless 1 &lt;= m &lt;= 2 * n then fail
<a name="745"/>
<a name="746"/>   iter := 5
<a name="747"/>
<a name="748"/>   repeat {
<a name="749"/>      pal := []
<a name="750"/>      count := 0
<a name="751"/>      okay := &amp;yes
<a name="752"/>      rat := Sqrt(n ^ 2 + m, iter)
<a name="753"/>      every j := cfseq(rat.numer, rat.denom) do {
<a name="754"/>         count +:= 1
<a name="755"/>         if count = 1 then next	# don't examine first term
<a name="756"/>         if j = 2 * n then {	# presumed end
<a name="757"/>            lequiv(pal, lreverse(pal)) | break
<a name="758"/>            okay := &amp;null
<a name="759"/>            break
<a name="760"/>            }
<a name="761"/>         else if j &gt; n then break			# too big; error
<a name="762"/>         else put(pal, j)
<a name="763"/>         }
<a name="764"/>      if \okay then {
<a name="765"/>         iter +:= 1			# back to repeat loop
<a name="766"/>         if iter &gt; 12 then fail		# too many iterations required.
<a name="767"/>         next
<a name="768"/>         }
<a name="769"/>      break
<a name="770"/>      }
<a name="771"/>
<a name="772"/>   suspend !pal
<a name="773"/>
<a name="774"/>end
<a name="775"/>
<a name="776"/># generalized reversed-sum sequence
<a name="777"/>procedure versumseq(i, j)	
<a name="778"/>
<a name="779"/>   /j := 0
<a name="780"/>
<a name="781"/>   /i := 196
<a name="782"/>
<a name="783"/>   repeat {
<a name="784"/>      i +:= reverse(i) + j
<a name="785"/>      suspend i
<a name="786"/>      }
<a name="787"/>
<a name="788"/>end
<a name="789"/>
<a name="790"/># versum sequence with operator
<a name="791"/>procedure versumopseq(i, p, args[])	
<a name="792"/>
<a name="793"/>   /i := 196
<a name="794"/>
<a name="795"/>   /p := csort
<a name="796"/>
<a name="797"/>   push(args, &amp;null)			# make room for first argument
<a name="798"/>
<a name="799"/>   repeat {
<a name="800"/>      i := reverse(i)
<a name="801"/>      args[1] := i		# make current i first argument
<a name="802"/>      i := integer(p ! args)
<a name="803"/>      suspend i
<a name="804"/>      }
<a name="805"/>
<a name="806"/>end
<a name="807"/>
<a name="808"/># random variation on Fibonacci sequence
<a name="809"/>procedure vishwanathseq(i, j)	
<a name="810"/>   local m
<a name="811"/>
<a name="812"/>   /i := 1
<a name="813"/>   /j := 1
<a name="814"/>
<a name="815"/>   suspend i | j | |{
<a name="816"/>      m := case ?4 of {
<a name="817"/>         1  :  i + j
<a name="818"/>         2  :  i - j
<a name="819"/>         3  :  -i + j
<a name="820"/>         4  :  -i - j
<a name="821"/>         }
<a name="822"/>      i := j
<a name="823"/>      j := m
<a name="824"/>      }
<a name="825"/>
<a name="826"/>end
<a name="827"/>
<a name="828"/># black and white bands
<a name="829"/>procedure zebra(args[])		
<a name="830"/>   local i, clr, clr_alt
<a name="831"/>
<a name="832"/>   clr := 2			# light
<a name="833"/>   clr_alt := 1			# dark
<a name="834"/>
<a name="835"/>   while i := get(args) do {
<a name="836"/>      suspend (1 to i) &amp; clr
<a name="837"/>      clr :=: clr_alt
<a name="838"/>      }
<a name="839"/>
<a name="840"/>end
</pre></body></html>
