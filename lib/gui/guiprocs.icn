#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

import graphics, lang, util, xdg, ipl.strings

class Event()
   public static const
      MOUSE_LEFT_PRESS,
      MOUSE_MIDDLE_PRESS,
      MOUSE_RIGHT_PRESS,
      MOUSE_LEFT_RELEASE,
      MOUSE_MIDDLE_RELEASE,
      MOUSE_RIGHT_RELEASE,
      MOUSE_LEFT_DRAG,
      MOUSE_MIDDLE_DRAG,
      MOUSE_RIGHT_DRAG,
      MOUSE_MOVEMENT,
      MOUSE_WHEEL_UP,
      MOUSE_WHEEL_DOWN,
      WINDOW_RESIZE,
      MOUSE_LEFT_DRAG_OVER,
      MOUSE_MIDDLE_DRAG_OVER,
      MOUSE_RIGHT_DRAG_OVER,
      MOUSE_LEFT_RELEASE_OVER,
      MOUSE_MIDDLE_RELEASE_OVER,
      MOUSE_RIGHT_RELEASE_OVER,
      WINDOW_CLOSE_BUTTON,
      # This event listens for all window-system generated events
      ICON,
      BUTTON_RELEASE,
      BUTTON_PRESS,
      BUTTON_HELD,
      SELECTION_CHANGED,
      CONTENT_CHANGED,
      CURSOR_MOVED,
      VALUE_CHANGED,
      ACTION,
      TREE_NODE_EXPANSION,
      SIZER_PRESS,
      SIZER_DRAG,
      SIZER_RELEASE,
      MOUSE_ENTER,
      MOUSE_EXIT,
      KEY_PRESS,
      KEY_RELEASE,
      GOT_FOCUS,
      LOST_FOCUS,
      DIALOG_DISPOSED,
      IN_POINT_CHAIN,
      POPUP_CLOSED

   private static init()
      MOUSE_LEFT_PRESS := Mouse.LEFT_PRESS
      MOUSE_MIDDLE_PRESS := Mouse.MIDDLE_PRESS
      MOUSE_RIGHT_PRESS := Mouse.RIGHT_PRESS
      MOUSE_LEFT_RELEASE := Mouse.LEFT_RELEASE
      MOUSE_MIDDLE_RELEASE := Mouse.MIDDLE_RELEASE
      MOUSE_RIGHT_RELEASE := Mouse.RIGHT_RELEASE
      MOUSE_LEFT_DRAG := 11
      MOUSE_MIDDLE_DRAG := 12
      MOUSE_RIGHT_DRAG := 13
      MOUSE_MOVEMENT := Mouse.MOVEMENT
      MOUSE_WHEEL_UP := Mouse.WHEEL_UP
      MOUSE_WHEEL_DOWN := Mouse.WHEEL_DOWN
      WINDOW_RESIZE := Window.RESIZE
      WINDOW_CLOSE_BUTTON := Window.CLOSE_BUTTON
      ICON := 1
      BUTTON_RELEASE := 20
      BUTTON_PRESS := 21
      BUTTON_HELD := 22
      SELECTION_CHANGED := 40
      CONTENT_CHANGED := 50
      CURSOR_MOVED := 51
      VALUE_CHANGED := 55
      ACTION := 60
      TREE_NODE_EXPANSION := 70
      SIZER_PRESS := 80
      SIZER_DRAG := 81
      SIZER_RELEASE := 82
      MOUSE_ENTER := 94
      MOUSE_EXIT := 95
      KEY_PRESS := 100
      KEY_RELEASE := 101
      MOUSE_LEFT_DRAG_OVER := 201
      MOUSE_MIDDLE_DRAG_OVER := 202
      MOUSE_RIGHT_DRAG_OVER := 203
      MOUSE_LEFT_RELEASE_OVER := 204
      MOUSE_MIDDLE_RELEASE_OVER := 205
      MOUSE_RIGHT_RELEASE_OVER := 206
      GOT_FOCUS := 400
      LOST_FOCUS := 401
      DIALOG_DISPOSED := 500
      IN_POINT_CHAIN :=  501
      POPUP_CLOSED := 502
   end
end

class Select()
   public static const 
      NONE,
      ONE,
      MANY

   private static init()
      NONE := "none"
      ONE := "one"
      MANY := "many"
   end
end

class Direction()
   public static const
      UP,
      DOWN,
      BEST

   private static init()
      UP := "up"
      DOWN := "down"
      BEST := "best"
   end
end

class Gui()
   public static 
      BORDER_WIDTH,
      TEXT_INSET,
      X_INSET,
      Y_INSET,
      REPEAT_DELAY,            
      REPEAT_RATE,
      CURSOR_BLINK,
      IDLE_SLEEP,
      TAB_WIDTH,                 # Default tab char width
      style

   public static const 
      CONSTRAINT_SET,
      WATTRIB_SET,
      CONTEXT_WATTRIB_SET,      # attribs that affect the graphical drawing context
      PRINTABLE_1,              # Printable on a single line of text
      PRINTABLE_N               # Printable on multi lines of text

   private static init()
      BORDER_WIDTH := 2
      TEXT_INSET := 3
      X_INSET := 6
      Y_INSET := 3
      REPEAT_DELAY := 500
      REPEAT_RATE := 100
      CURSOR_BLINK := 400
      TAB_WIDTH := 8
      IDLE_SLEEP := 50
      style := Style()
      PRINTABLE_1 := '\x20-\x7e\x80-\U10ffff'
      PRINTABLE_N := '\t\n\x20-\x7e\x80-\U10ffff'
      CONSTRAINT_SET := set("x_tab", "y_tab", "eol", "x", "y", "w", "h", "l_inset", "r_inset", "t_inset", "b_inset", 
                            "x_fill", "y_fill", "x_align", "y_align", "x_weight", "y_weight")
      WATTRIB_SET := set("label", "x", "pos", "y", "resize", "size", "height", 
                         "width", "w", "h", "image", "canvas", "pointer", 
                         "display", "depth", "fg", "bg", "draw_op", "icon",
                         "font", "line_width", "geometry", "transient_for",
                         "line_style", "pattern", "clip", "unclip",
                         "dx", "dy", "input_mask", "min_width", "min_height", "min_size", "max_width", 
                         "max_height", "max_size")
      CONTEXT_WATTRIB_SET := set("fg", "bg", "draw_op", "font", "line_width", "line_style", 
                                 "pattern")
   end

   public static is_constraint(s)
      return member(CONSTRAINT_SET, s)
   end

   public static is_window_attrib(s)
      return member(WATTRIB_SET, s)
   end
end

procedure tab_ws()
   return tab(many(' \t\n\r'))
end

procedure is_image_string(v)
   v := text(v) | fail
   v ? {
      tab_ws()
      tab(many(&digits)) | fail
      tab_ws()
      ="," | fail
      return
   }
end

procedure parse_image_string(s, W)
   local q, width, height, pal, data, extra, k, v
   s := string(s) | runerr(103, s)
   s ? {
      tab_ws()
      width := (0 < integer(tab(many(&digits)))) | return error("Width expected")
      tab_ws()
      ="," | return error("Comma expected")
      tab_ws()
      if any('cg') then {
         pal := (move(1) || tab(many(&digits))) | return error("Palette expected")
         tab_ws()
      }
      if any('(') then {
         move(1)
         extra := tab(upto(')')) | return error("Missing )")
         move(1)
         tab_ws()
      }
      ="," | return error("Comma expected")
      data := tab(0)
      if *data = 0 | *data % width ~= 0 then
         return error("Wrong number of image characters")
      height := *data / width
      q := Pixels(width, height, Pixels.PALETTE8).
         set_data(data)
      # Add chars from palette, if specified.
      if \pal then {
         q.load_palette(pal) | {
            q.close()
            fail
         }
      }
      # Add extra chars
      if \extra then {
         extra ? repeat {
            tab_ws()
            k := move(1) | break
            ="=" | {
               q.close()
               return error("= expected")
            }
            v := tab(upto(';') | 0)
            case v of {
               "hilite" : v := Gui.style.get_hilite_color(W)
               "shadow" : v := Gui.style.get_shadow_color(W)
               "fg" : v := W.get_fg()
               "bg" : v := W.get_bg()
            }
            move(1)
            q.set_palette(ord(k), v) | {
               q.close()
               return error("invalid colour in image spec: " || v)
            }
         }
      }
   }
   return q
end

#
# Extended TextWidth function, handling tabs in s.  Returns the
# width of the string from positions i through j.
#
procedure text_width_ex(win, s, i, j, tw)
   if /i then {
      i := 1
      j := *s + 1
   } else {
      /j:= i + 1
      if j <= 0 then
         j +:= *s + 1
   }
   if not upto('\t', s) then
      return win.text_width(s[i:j])
   /tw := 8
   return win.text_width(detab(s[1:j], tw + 1)) - win.text_width(detab(s[1:i], tw + 1))
end

procedure draw_string_ex(win, x, y, s, k)
   local i
   y +:= win.get_font_ascent()
   win.draw_string(x, y, s)
   if i := upto(\k, map(s)) then {
      win.fill_rectangle(x + win.text_width(s[1:i]),
                         y + win.get_font_descent() - 1,
                         win.text_width(s[i]), 1)
   }
end

procedure image_width(s)
   s ? {
      if ="(" then {
         tab(upto(')')) 
         move(1)
      }
      return integer(tab(upto(',')))
   }
end

procedure image_height(s)
   local w
   s ? {
      if ="(" then {
         tab(upto(')')) 
         move(1)
      }
      w := integer(tab(upto(',')))
      move(1)
      tab(upto(','))
      move(1)
      return *tab(0) / (0 ~= \w)
   }
end

#
# This utility takes a string or ucs and returns a string or ucs
# according to the target parameter.  Strings are assumed to be in
# iso-8859 format, rather than utf8 format.
#
procedure text_convert(s, target)
   s := text(s) | fail
   if type(s) == target then
      return s
   return case target of {
      "ucs": Text.iso_8859_1_to_ucs(s)
      "string": Text.ucs_to_iso_8859_1(s)
      default: runerr("Bad target type", target)
   }
end

#
# This utility takes a string or ucs and returns a string or ucs
# according to the target parameter.  The format of strings are
# guessed using the ucs() function; if that fails they are assumed to
# be in iso-8859 format.
#
procedure text_guess_convert(s, target)
   s := text(s) | fail
   return case target of {
      "ucs": ucs(s) | Text.iso_8859_1_to_ucs(s)
      "string": Text.ucs_to_iso_8859_1(ucs(s)) | s
      default: runerr("Bad target type", target)
   }
end

#
# Given a result from a selection request ({target_type} and {data}), produce
# a corresponding string or a ucs as appropriate.
#
procedure selection_convert(target_type, data)
   case target_type of {
      Selection.UTF8_STRING_TARGET : return ucs(data)
      Selection.STRING_TARGET : return string(data)
      default: fail
   }
end

procedure open_win_with(t)
   local w, e, v
   w := Window(t["display"]) | fail
   every e := !sort(t) do {
      v := e[2]
      case e[1] of {
         "label": w.set_label(v)
         "x": w.set_x(v)
         "pos":  w.set_pos(v[1],v[2])
         "y": w.set_y(v)
         "resize": w.set_resize(v)
         "size": w.set_size(v[1],v[2])
         "height": w.set_height(v)
         "width": w.set_width(v)
         "w": w.set_width(v)
         "h": w.set_height(v)
         "image": w.set_image(v)
         "pointer": w.set_pointer(v)
         "fg": w.set_fg(v)
         "bg": w.set_bg(v)
         "draw_op": w.set_draw_op(v)
         "icon": w.set_icon(v)
         "font": w.set_font(v)
         "line_width": w.set_line_width(v)
         "geometry": w.set_geometry(v[1],v[2],v[3],v[4])
         "transient_for": w.set_transient_for(v)
         "line_style": w.set_line_style(v)
         "pattern": w.set_pattern(v)
         "clip": w.set_clip(v[1],v[2],v[3],v[4])
         "unclip": w.set_unclip()
         "dx": w.set_dx(v)
         "dy": w.set_dy(v)
         "input_mask": w.set_input_mask(v)
         "min_width": w.set_min_width(v)
         "min_height": w.set_min_height(v)
         "min_size": w.set_min_size(v[1],v[2])
         "max_width": w.set_max_width(v)
         "max_height": w.set_max_height(v)
         "max_size": w.set_max_size(v[1],v[2])
      }
   }
   w.erase_area()
   if v := member(t, "canvas") then {
      w.set_canvas(v) | {
         w.close()
         fail
      }
   }
   return w
end

procedure apply_context_table(w, t)
   local e, v
   every e := !sort(t) do {
      v := e[2]
      case e[1] of {
         "fg": w.set_fg(v)
         "bg": w.set_bg(v)
         "draw_op": w.set_draw_op(v)
         "font": w.set_font(v)
         "line_width": w.set_line_width(v)
         "line_style": w.set_line_style(v)
         "pattern": w.set_pattern(v)
         "clip": w.set_clip(v[1],v[2],v[3],v[4])
         "unclip": w.set_unclip()
         "dx": w.set_dx(v)
         "dy": w.set_dy(v)
      }
   }
   return w
end

procedure clone_win_with(w, t)
   return apply_context_table(w.clone(), t)
end

procedure fresh_clone_win_with(w, t)
   local wt
   return use {
      wt := Window(w.get_display()).
         set_dx(w.get_dx()).
         set_dy(w.get_dy()),
      apply_context_table(w.couple(wt), t)
   }
end

#
# Produce a string which is an initial substring of s, but tries to
# fit into n pixels of width.  If truncation takes place, the result
# ends in "...".
#
procedure limit_text(W, s, n)
   local i, t
   t := s
   i := *s
   while i > 0 & W.text_width(t) > n do {
      t := s[1:i] || "..."
      i -:= 1
   }
   return t
end

#
# Given a string, font and width, return a `GridPaint` format string
# which splits the string up into multiple lines broken at the given
# width.
#
procedure split_string(s, f, n)
   local W, w, l, r
   use {
      W := Window().set_font(f),
      {
         r := u".cell\n.attr ia_x=l\n"
         l := u""
         every w := words(s) do {
            if *l > 0 then
               l ||:= u" "
            l ||:= w
            if W.text_width(l) > n then {
               r ||:= l || u"\n.br\n"
               l := u""
            }
         }
         if *l > 0 then
            r ||:= l || u"\n.br\n"
      }
   }
   return r
end

abstract class HasOrientation()
   public 
      is_horizontal_flag

   #
   # Configure the orientation.
   #
   public set_is_horizontal(s)
      self.is_horizontal_flag := check_flag(s)
      return self
   end
end

#
# This is a Dialog whose only purpose is to retrieve a given selection.
# @example
# @ d := GetSelection(Selection.CLIPBOARD).show_modal()
# @ ... the clipboard is now stored in d.result (which may be null).
#
class GetSelection(Dialog)
   private readable
      result
   private
      sel

   private respond(target_type, data, e)
      result := data
      dispose()
   end

   public show()
      cast(self, Dialog).show()
      # Now we have an underlying window, we can request the selection.
      request_selection(sel,
                        [Selection.UTF8_STRING_TARGET, Selection.STRING_TARGET], 
                        respond)
      return self
   end

   public new(sel)
      cast(self, Dialog).new()
      set_canvas("withdrawn")
      set_size(100, 100)
      self.sel := sel
      return
   end
end

procedure theme_toolbar_button(b, icon)
   if is(b, IconButton) then
      b.set_paint(get_toolbar_theme_paint(icon)) | fail
   else if is(b, MenuButton) then
      b.menu.set_paint_mid(get_toolbar_theme_paint(icon)) | fail
   b.set_size(28, 28)
   return b
end

procedure get_toolbar_theme_paint(icon)
   local k, w
   k := Xdg.find_icon_and_cache(icon, 24) | fail
   w := ImageCache.get(k)
   if w.get_width() > 24 then
      k := ImageCache.get_key_with_resize(k, 24, 24)
   return ImagePaint().set_cache(k)
end
