#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

import
   xml(xml_escape),
   parser, 
   ipl.sort,
   io,
   util

class HtmlOutputter(Outputter)
   private
      output_dir,
      done_files,
      subclass_table

   private get_id(sym)
      local v
      static sym_id_table
      initial {
         sym_id_table := table()
      }

      if v := member(sym_id_table, sym) then
         return v

      v := if is(sym, Symbol) then
         sym.get_fq_name_default()
      else if is(sym, ScannedFile) then
         (\sym.pack | "default") || "_" || FilePath(sym.filename).get(-1)
      else
         syserr("Unknown type to get_id")

      insert(sym_id_table, sym, v)
      return v
   end

   public output()
      local nav, fname, index, s, all_classes, all_others, begin, c, all

      done_files := set()
      output_dir := \opts["o"] | stop("Please specify an output directory")
      fname := output_dir || "/index.html"
      use {index := open(fname, "w") | stop("Couldn't open ", fname), {
         write(index, "<html>")
         write(index, "<title>")
         write(index, "Generated Documentation")
         write(index, "</title>")
         write(index, "</head>")
         write(index, "<frameset cols=\"20%,80%\">")
         write(index, "<frameset rows=\"30%,70%\">")
         write(index, "<frame src=\"nav.html\" name=\"navFrame\">")
         write(index, "<frame src=\"all.html\" name=\"listFrame\">")
         write(index, "</frameset>")
         write(index, "<frame src=\"begin.html\" name=\"displayFrame\">")
         write(index, "</frameset>")
         write(index, "<noframes>")
         write(index, "<h2>")
         write(index, "Frame Alert</h2>")
         write(index, "<p>")
         write(index, "This document is designed to be viewed using the frames feature.")
         write(index, "If you see this message, you are using a non-frame-capable web client.")
         write(index, "</html>")
      }}

      all_classes := []
      all_others := []
      subclass_table := table()
      every c := symbol_table.gen_symbols() do {
         if is(c, ClassSymbol) then {
            put(all_classes, c)
            every s := c.get_resolved_supers() do {
               /subclass_table[s] := []
               put(subclass_table[s], c)
            }
         } else 
            put(all_others, c)
      }

      fname := output_dir || "/nav.html"
      use {nav := open(fname, "w") | stop("Couldn't open ", fname), {
         write(nav, "<html><body>")
         write(nav, "<h1>Packages</h1><p>")
         write(nav, "<a href=\"all.html\" target=\"listFrame\">All</a><p>")
         every s := get_packages() do {
            if should_print_package(s) then
               write(nav, "<a href=\"", s || ".html" || "\" target=\"listFrame\">", s, "</a><br>")
            output_package(s)
         }
         write(nav, "</body></html>")
      }}
           
      fname := output_dir || "/begin.html"
      use {begin := open(fname, "w") | stop("Couldn't open ", fname), {
         write(begin, "<html><body>")
         write(begin, "<h1>Object Icon generated documentation</h1>")
         write(begin, "This is the automatically generated documentation for the following packages.<p>")
         every s := get_packages() do
            if should_print_package(s) then
               write(begin, "<a href=\"", s || ".html" || "\" target=\"listFrame\">", s, "</a><br>")
         write(begin, "</body></html>")
      }}

      fname := output_dir || "/all.html"
      use {all := open(fname, "w") | stop("Couldn't open ", fname), {
         write(all, "<html><body>")
         write(all, "<h1>All packages</h1><p>")
         write(all, "<h1>Classes</h1><p>")
         every c := !isort(all_classes, name_sort) do {
            if should_print_symbol(c) then
               write(all, "<a href=\"", 
                     get_id(c) || ".html\" target=\"displayFrame\">", 
                     c.name, "</a><br>")
         }
         write(all, "<p><h1>Other Symbols</h1><p>")
         every c := !isort(all_others, name_sort) do {
            if should_print_symbol(c) then
               write(all, 
                     "<a href=\"", get_id(c) || ".html\" target=\"displayFrame\">", 
                     c.name, "</a><br>")
         }
      }}
   end

   # Output the summary list for one package set
   private output_package(s)
      local f, fname, c
      fname := output_dir || "/" || s || ".html"
      use {f := open(fname, "w") | stop("couldn't open " || fname), {
         write(f, "<html><head><title>", s, "</title></head><body>")
         write(f, "<h1>Package ", s, "</h1><p>")
         write(f, "<h1>Classes</h1><p>")
         every c := get_classes_in(s) do {
            output_class(c)
            write(f, "<a href=\"", get_id(c) || ".html\" target=\"displayFrame\">", c.name, "</a><br>")
         }
         write(f, "<p><h1>Other Symbols</h1><p>")
         every c := get_others_in(s) do {
            output_other(c)
            write(f, "<a href=\"", get_id(c) || ".html\" target=\"displayFrame\">", c.name, "</a><br>")
         }
      }}
   end

   # Output one class description
   private output_class(c)
      local s, f, fname, supers, o, subs, d, overrides, meths, m, vars, mm, x, type
      fname := output_dir || "/" || get_id(c) || ".html"
      use {f := open(fname, "w") | stop("couldn't open " || fname), {
         write(f, "<html><head><title>", c.name, "</title></head><body>")
         type := get_class_prefix(c)
         if *type > 0 then
            type ||:= " class "
         else
            type := "class "
         write(f, "<h1>", c.name, "</h1>")
         write(f, "<dl>")
         write(f, "<dt>Type :</dt><dd>", type, "</dd>")

         # Superclass list
         supers := []
         every o := c.get_resolved_supers() do {
            put(supers, "<a href=\"" || get_id(o) || ".html\" target=\"displayFrame\">" || o.get_fq_name() || "</a>")
         }
         if *supers > 0 then {
            write(f, "<dt>Superclasses :</dt><dd>")
            every write(f, !supers, "<br>")
            write(f, "</dd>")
         }

         # Subclass list
         subs := []
         every d := !\subclass_table[c] do {
            put(subs, "<a href=\"" || get_id(d) || ".html\">" || d.get_fq_name() || "</a>")
         }
         if *subs > 0 then {
            write(f, "<dt>Subclasses :</dt><dd>")
            every write(f, !subs, "<br>")
            write(f, "</dd>")
         }

         s := c.get_package() | "default"
         write(f, "<dt>Package :</dt><dd><a href=\"", s || ".html" || "\" target=\"listFrame\">", s, "</a></dd>")
         write(f, "</dl><p>")

         if is(c.obj, Tree) then {
            output_file(c)
            comment_and_fields(f, c)
            write(f, "<p>")
         }

         pretty_heading(f, "Class summary")
         overrides := table()
         do_inherited(f, c, overrides)

         meths := []
         vars := []
         every x := c.get_fields() do {
            if is(x, ClassVariable) then
               put(vars, x)
            else
               put(meths, x)
         }
         meths := isort(meths, name_sort)
         vars := isort(vars, name_sort)

         if *meths > 0 then {
            tbl_start(f, "Methods defined in this class")
            every m := !meths do {
               write(f,"<a href=\"#" || m.name || "\">" || m.name || "()</a>")
            }
            tbl_end(f)
         }

         if *vars > 0 then {
            tbl_start(f, "Variables defined in this class")
            every m := !vars do {
               write(f,"<a href=\"#" || m.name || "\">" || m.name || "</a>")
            }
            tbl_end(f)
         }

         write(f, "<p>")

         if *meths > 0 then {
            pretty_heading(f, "Method detail")
            every m := !meths do {
               write(f, "<a name=\"", m.name, "\"/>")
               write(f, "<h3>", m.name, "(", get_param_string(m.obj) ,")</h3>")
               write(f, get_access_string(m.obj), "<p>")
               write(f, "<dl>")
               if member(overrides, m.name) then {
                  o := overrides[m.name]
                  mm := o.get_field(m.name) | stop("Internal error")
                  write(f,"<dd>Overrides <a href=\"" || get_id(o) || ".html#" || mm.name || "\">" || mm.name || "()</a> in <a href=\"", get_id(o), ".html\" target=\"displayFrame\">", o.get_fq_name(), "</a></dd>")
               }
               if is(m.obj, Tree) then {
                  write(f, "<dd>")
                  comment_and_fields(f, m)
                  write(f, "</dd>")
               }
               write(f, "</dl><hr>")
            }
         }

         if *vars > 0 then {
            pretty_heading(f, "Variable detail")
            every m := !vars do {
               write(f, "<a name=\"", m.name, "\"/>")
               write(f, "<h3>", m.name, "</h3>")
               write(f, get_access_string(m.decl_obj), "<p>")
               write(f, "<dl>")
               if is(m.obj, Tree) then {
                  write(f, "<dd>")
                  comment_and_fields(f, m)
                  write(f, "</dd>")
               }
               write(f, "</dl><hr>")
            }
         }

         write(f, "</body></html>")
      }}
   end

   private do_inherited(f, c, overrides)
      local l, m, d, x, tm, tv
      l := []
      every push(l, c ~=== c.get_implemented_classes())

      tm := table()
      tv := table()
      every x := c.get_implemented_fields() do {
         if is(x, ClassVariable) then {
            /tv[x.defining_class] := []
            put(tv[x.defining_class], x)
         } else {
            /tm[x.defining_class] := []
            put(tm[x.defining_class], x)
         }
      }

      every d := !l do {
         # Note any overridden fields
         every x := c.get_fields() do {
            if d.get_field(x.name) then
               overrides[x.name] := d
         }

         if *\tm[d] > 0 then {
            tbl_start(f, "Methods inherited from " || d.get_fq_name())
            every m := !isort(tm[d], name_sort) do {
               write(f,"<a href=\"" || get_id(d) || ".html#" || m.name || "\">" || m.name || "()</a>")
            }
            tbl_end(f)
         }
         if *\tv[d] > 0 then {
            tbl_start(f, "Variables inherited from " || d.get_fq_name())
            every m := !isort(tv[d], name_sort) do {
               write(f,"<a href=\"" || get_id(d) || ".html#" || m.name || "\">" || m.name || "</a>")
            }
            tbl_end(f)
         }
      }
   end

   private pretty_heading(f, s)
      write(f, "<table border=\"1\" cellpadding=\"3\" cellspacing=\"0\" width=\"100%\">")
      write(f, "<tr bgcolor=\"#ccccff\">")
      write(f, "<td colspan=1><font size=\"+2\">")
      write(f, "<b>", s, "</b></font></td>")
      write(f, "</tr>")
      write(f, "</table>")
   end

   private tbl_start(f, s)
      write(f, "<table border=\"1\" cellpadding=\"3\" cellspacing=\"0\" width=\"100%\">")
      write(f, "<tr bgcolor=\"\#eeeeff\">")
      write(f, "<td><b>",s,"</b></td></tr>")
      write(f, "<tr bgcolor=\"white\"><td>")
   end

   private tbl_end(f)
      write(f, "</td></tr></table>")
   end

   private comment_and_fields(f, c)
      local k, com
      com := Comment(c)
      every write(f, html_unbracket(!com.comment, c))
      write(f, "<dl>")
      every k := !com.keys do
         html_fields(f, c, k, com.fields[k])
      write(f, "<dt><a href=\"", 
            get_id(c.scanned_file) || ".html#", 
            c.obj.get_first_token().line , 
            "\" target=\"displayFrame\">Source - ", 
            FilePath(c.obj.get_first_token().filename).get(-1),
            " </a></dt>")
      write(f, "</dl>")
   end

   private html_fields(f, c, key, vals)
      local name, l
      case key of {
         "param" : {
            write(f, "<dt>Parameters :</dt>")
            every l := !vals do {
               l[1] ? {
                  tab(many(WHITESPACE))
                  name := tab(many(ID_CHAR))
                  l[1] := tab(0)
               }
               writes(f, "<dd>", name, " - ")
               every write(f, html_unbracket(!l, c))
               write(f, "</dd>")
            }
         }

         "return" : {
            write(f, "<dt>Returns :</dt>")
            write(f, "<dd>")
            every write(f, html_unbracket(!vals[1], c))
            write(f, "</dd>")
         }

         "generate" : {
            write(f, "<dt>Generates :</dt>")
            write(f, "<dd>")
            every write(f, html_unbracket(!vals[1], c))
            write(f, "</dd>")
         }

         "fail" : {
            write(f, "<dt>Fails :</dt>")
            write(f, "<dd>")
            every write(f, html_unbracket(!vals[1], c))
            write(f, "</dd>")
         }

         "runerr" : {
            write(f, "<dt>Runtime error :</dt>")
            write(f, "<dd>")
            every write(f, html_unbracket(!vals[1], c))
            write(f, "</dd>")
         }

         "example" : {
            write(f, "<dt>Example :</dt><dd><pre>")
            every l := !vals do
               every write(f, l[2 to *l])
            write(f, "</pre></dd>")
         }
      }
   end

   private html_unbracket(s, c)
      local r, t, w
      r := ""
      s ? {
         w := tab(many(WHITESPACE))
         while r ||:= xml_escape(tab(upto('`{')), '<>&') do {
            if any('`') then {
               move(1)
               t := tab(upto('`') | 0)
            } else {
               move(1)
               t := tab(upto('}') | 0)
            }
            move(1)
            r ||:= create_link(t, c)
         }
         r ||:= xml_escape(tab(0), '<>&')
      }
      if *r = 0 then
         r := "<p>"
      else if (*\w > 1) then
         r := "<br>" || repl("&nbsp;", *w - 1) || r

      return r
   end

   private resolve_link(sym, name)
      local i, j, d
      name := (name ? tab(upto('({') | 0))
      if is(sym, ClassField) &
         i := sym.defining_class.get_implemented_field(name) then
            return i
      if is(sym, ClassSymbol) &
         i := sym.get_implemented_field(name) then
            return i
      #
      # Is it a global - note the test for scanned_file is so we fail on
      # a builtin function.
      if i := symbol_table.resolve(sym.scanned_file, name) then
         return \i.scanned_file & i

      #
      # Is it in the form <Class>.<Field> ?
      every d := find(".", name)
      if \d & (i := symbol_table.resolve(sym.scanned_file, name[1:d])) & 
              is(i, ClassSymbol) &
              (j := i.get_implemented_field(name[d+1:0])) then
         return j
   end

   #
   # Get a link (if possible) for the string s.  c is the current comment.
   #
   private create_link(s, c)
      local o
      o := resolve_link(c, s) | return s
      if is(o, ClassField) then {
         # Link within the parent class's page
         return "<a href=\"" || get_id(o.defining_class) || ".html#" || 
            get_id(o) || "\">" || s || "</a>"
      } else {
         # Link to the absolute page
         return "<a href=\"" || get_id(o) || ".html\" target=\"displayFrame\">" || s || "</a>"
      }
   end

   private output_file(c)
      local f, fname, line_no, g, s, filename

      filename := c.obj.get_first_token().filename
      if member(done_files, filename) then
         return
      insert(done_files, filename)

      fname := output_dir || "/" || get_id(c.scanned_file) || ".html"
      use {f := open(fname, "w") | stop("couldn't open " || fname), {
         write(f, "<html><head><title>", FilePath(filename).get(-1), "</title></head><body><pre>")
         # filename may be unavailable if a #line directive gave a path which was inaccessible
         use { g := open(filename) , {
            line_no := 0
            while s := read(g) do {
               line_no +:= 1
               writes(f, "<a name=\"", line_no, "\"/>")
               write(f, xml_escape(s, '<>&'))
            }
         }}

         write(f, "</pre></body></html>")
      }}
   end

   private output_other(c)
      local s, f, fname, type, fullname
      fullname := c.name
      case classof(c) of {
         ProcedureSymbol : {
            type := "procedure"
            fullname := c.name || "(" || get_param_string(c.obj) || ")"
         }
         RecordSymbol : type := "record"
         GlobalSymbol : type := "global"
         default : stop("Unknown type:", image(c))
      }

      if is(c, GlobalSymbol) & c.has_readable_flag() then
         type := "package readable " || type
      else if c.has_package_flag() then
         type := "package " || type
      fname := output_dir || "/" || get_id(c) || ".html"
      use {f := open(fname, "w") | stop("couldn't open " || fname), {
         write(f, "<html><head><title>", c.name, "</title></head><body>")
         write(f, "<h1>", fullname, "</h1>")
         write(f, "<dl>")
         s := c.get_package() | "default"
         write(f, "<dt>Package :</dt><dd><a href=\"", s || ".html" || "\" target=\"listFrame\">", s, "</a></dd>")
         write(f, "<dt>Type :</dt><dd>", type, "</dd>")
         write(f, "</dl><p>")
         if is(c.obj, Tree) then {
            output_file(c)
            comment_and_fields(f, c)
            write(f, "<p>")
         }
         write(f, "</body></html>")
      }}
   end
end

