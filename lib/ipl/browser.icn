package ipl.browser

import 
   gui, 
   lang, 
   mail,
   graphics,
   http,
   util,
   io,
   net,
   xml,
   ipl.pdco,
   ipl.sort,
   ipl.scan,
   ipl.strings,
   ipl.caseless

$load BROKEN_LINK "rpp.BROKEN_LINK_24.gif"

class Req()
   public const
      url, referer, callback, kind, form_data

   public new(url, referer, callback, kind, form_data)
      self.url := url 
      self.referer := referer
      self.callback := callback
      self.kind := kind
      self.form_data := form_data
      return
   end
end

class Resp()
   public const
      err, url, referer, data, fname, content_type, kind, form_data

   public new(err, url, referer, data, fname, content_type, kind, form_data)
      self.err := err
      self.url := url
      self.referer := referer
      self.data := data
      self.fname := fname
      self.content_type := content_type
      self.kind := kind
      self.form_data := form_data
      return
   end
end

class Authentication()
   public const
      username, password

   public new(username, password)
      self.username := username
      self.password := password
      return
   end
end

class CacheEntry()
   public const
      url, data, fname, content_type, expiry

   public new(url, data, fname, content_type, expiry)
      self.url := url
      self.data := data
      self.fname := fname
      self.content_type := content_type
      self.expiry := expiry
      return
   end
end

class Cache()
   private t, total, lim

   public get(url)
      local k, ent
      k := string(url.str())
      if ent := member(t, k) then {
         if \ent.expiry < Time.get_system_seconds() then
            del(ent)
         else
            return ent
      }
   end

   private del(ent)
      local k
      k := string(ent.url.str())
      total -:= *ent.data
      delete(t, k)
   end

   public add(ent)
      local k, old
      k := string(ent.url.str())
      #write("cache add ",k, " expiry ", (\ent.expiry - Time.get_system_seconds()) | "-")
      if old := member(t, k) then
         del(old)
      while *t > 0 &  total + *ent.data > lim do
         del(?t)
      insert(t, k, ent)
      total +:= *ent.data
      return
   end

   public new(lim)
      t := table()
      self.lim := lim
      total := 0
      return
   end
end

class Worker()
   private
      browser, httpc

   private readable
      doing, task, cancelled
   
   public static const NORMAL, NAVIGATE, REFRESH

   private static init()
      NORMAL := 1
      NAVIGATE := 2
      REFRESH := 3
   end

   public initially()
      task.start()
   end

   public finally()
      if \doing then
         cancel()
      else {
         httpc.close()
         task.stop()
      }
   end

   public cancel()
      if \doing then {
         cancelled := 1
         task.interrupt()
         httpc.abort()
      }
   end

   private dwrite(a[])
      writes("[", serial(self), "] ")
      write!a
   end

   private writing_line(ev)
      dwrite("Sent: ", ev)
   end

   private read_line(ev)
      dwrite("Got : ", ev)
   end

   private read_string(ev)
      dwrite("Got : data - 0x", Format.int_to_string(*ev, 16), " bytes")
   end

   private writing_string(ev)
      dwrite("Sent: data - 0x", Format.int_to_string(*ev, 16), " bytes")
   end

   private failed(ev)
      dwrite("Failed ", &why, repl(" ", 20))
   end

   private retrying(ev)
      dwrite("Retrying ", &why, repl(" ", 20))
   end

   private other(ev, src, type)
      dwrite(type)
   end

   public read()
      if \doing then return httpc.get_read()
   end

   public count()
      return if \doing then 1 else 0
   end

   private static ls_sort(x)
      return map(x[1])
   end

   private cvt_file(f)
      local e, l, maxl, maxsz, maxuid, maxgid, t, path, rs, now, tf
      if Files.is_directory(f) then {
         l := isort(Files.list(f), ls_sort) | fail
         now := Time.get_system_seconds()
         return use {
            rs := RamStream(),
            {
               rs.out("<html><head><title>Directory " || f || "</title></head><pre>")
               maxsz := maxl := maxuid := maxgid := 0
               every e := !l do {
                  maxl <:= *e[1]
                  maxsz <:= *e[2].size
                  maxuid <:= *e[2].uid
                  maxgid <:= *e[2].gid
               }
               path := Files.get_path(f)
               every e := !l do {
                  t := e[2]
                  tf := if now - t.mtime > 180 * 86400 then
                     Time(t.mtime + Time.SYSTEM_BASE_OFFSET).format("MMM dd  yyyy")
                  else
                     Time(t.mtime + Time.SYSTEM_BASE_OFFSET).format("MMM dd HH:mm")
                  rs.out(t.mode_str || "  " || left(t.uid, maxuid + 1) || left(t.gid, maxgid + 1) ||
                         right(t.size, maxsz) || " " || tf || " " ||
                         "<a href=\"file://" || path.child(e[1]).canonical().str() || "\">" || e[1] || "</a>" || "\n")
               }
               rs.out("</pre></html>")
               rs.str()
            }
         }
      } else
         return Files.file_to_string(f)
   end

   private setup_httpc()
      httpc := HttpClient().
         set_task(task).
         set_ssl_verify(&no).
         set_cookies(browser.cookies)
      httpc.set_user_agent(\browser.user_agent)
      if \browser.log_http_flag then {
         httpc.connect(failed, HttpClient.FAILED_EVENT).
            connect(retrying, HttpClient.RETRYING_EVENT).
            connect(read_line, NetClient.READ_LINE_EVENT).
            connect(read_string, NetClient.READ_STRING_EVENT).
            connect(writing_line, NetClient.WRITING_LINE_EVENT).
            connect(writing_string, NetClient.WRITING_STRING_EVENT).
            connect(other, NetClient.CONNECTING_EVENT).
            connect(other, NetClient.CONNECTED_EVENT).
            connect(other, NetClient.CLOSED_EVENT).
            connect(other, HttpClient.COMPLETE_EVENT)
      }
   end

   private handle_file_req(r)
      local data
      if data := cvt_file(r.url.get_path()) then
         r.callback(Resp(, r.url, r.referer, data, r.url.get_file_last(1),, r.kind))
      else
         r.callback(Resp(&why, r.url, r.referer,,,, r.kind))
   end

   private get_expiry(hres)
      local s, t, now, ma
      now := Time.get_system_seconds()
      if s := hres.get_first_header("Cache-Control") then {
         if find("no-cache", s) then
            fail
         s ? if tab(past("max-age=")) & ma := integer(tab(many(&digits))) then
            return now + (0 < ma)
      }
      if s := hres.get_first_header("Expires") then {
         t := Time.parse(s, "E, d MMM yyyy hh:mm:ss z") | fail
         return now < t.get_unix_seconds()
      }
      return
   end

   private handle_http_req(r, auth)
      local s, data, hreq, hres, fname, ct, x, t
      use {
         s := RamStream(),
         {
            hreq := HttpRequest().
               set_output_stream(s). 
               set_url(r.url).
               set_header("Accept-charset", "UTF-8, ISO-8859-1")
            if \auth then
               hreq.set_username(auth.username).
                  set_password(auth.password)
            if (\r.referer).protocol ~== u"file" then
               hreq.set_referer(r.referer.str())
            if \r.form_data then {
               if is(r.form_data, Message) then
                  hreq.set_multipart_form_data(r.form_data)
               else
                  hreq.set_html_form_data(r.form_data)
            }
            if hres := httpc.retrieve(hreq) then {
               data := s.str()
               fname := hres.get_filename()
               ct := ContentType.parse(hres.get_first_header("Content-Type"))
               # Note we have to take into account redirections in deciding whether to cache
               # and whether form data should be in the response.
               if httpc.request.method == "GET" & x := get_expiry(hres) then
                  browser.cache.add(CacheEntry(hres.url, data, fname, ct, x))
               if /cancelled then
                  r.callback(Resp(, hres.url, r.referer, data, fname, ct, r.kind, 
                                  if hreq.url === hres.url then r.form_data else &null))
            } else {
               if /auth & 
                  find("401", \httpc.response.status) &
                  t := HttpClient.parse_generic_header(httpc.response.get_first_header("www-authenticate")) & 
                  auth := browser.lookup_authentication(httpc.response.url, member(t, "realm")) then
                  handle_http_req(r, auth)
               else if /cancelled then
                  r.callback(Resp(&why, r.url, r.referer,,,, r.kind, r.form_data))
            }
         }
      }
   end

   private handle_req(r)
      local ce
      if r.url.protocol == u"file" then
         handle_file_req(r)
      else if r.kind ~= REFRESH & /r.form_data & (ce := browser.cache.get(r.url)) then
         r.callback(Resp(, r.url, r.referer, ce.data, ce.fname, ce.content_type, r.kind))
      else 
         handle_http_req(r)
   end

   private run()
      setup_httpc()
      repeat {
         while /browser.cbwin do {
            # finally() has been called; close resources and revert
            httpc.close()
            task.revert()
         }
         while *browser.queue = 0 do
            task.sleep()
         doing := 1
         cancelled := &null
         handle_req(pop(browser.queue))
         doing := &null
      }
   end

   public new(browser)
      self.browser := browser
      task := Dispatcher.new_task{run()}
      return
   end
end

class Tbl(Border)
   public get_max_width()
      local w1
      w1 := content.layout_delegate.get_max_width()  + border.get_total_width()
      return if \title then
         max(w1, title.get_max_width() + 2 * TITLE_OFFSET)
      else
         w1
   end

   public get_ascent(dw, dh)
      /title | return dh
      dw -:= border.get_total_width()
      return content.layout_delegate.get_ascent(dw) + border.get_t_inset() | dh
   end

   public new(url)
      cast(self,Border).new()
      set_content(Component(). 
                    set_layout(TableLayout()))
      set_border(NullBorder())
      return
   end
end

class Img(Label)
   private browser, img_url, link_url, wrote, imgw, imgh, img_data, img_name, form, map, held

   public got_data(res)
      if \res.err then
         set_paint(ImagePaint().set_cache("rpp.BROKEN_LINK"))
      else {
         set_paint(ImagePaint().
                      set_image(res.data).
                      set_max_size(imgw, imgh).
                      set_fill_dimensions(2))
         if /paint.win then
            set_paint(ImagePaint().set_cache("rpp.BROKEN_LINK"))
         else {
            img_name := res.fname
            img_data := res.data
         }
      }
   end

   private copy_image()
      parent_dialog.own_selection(Selection.CLIPBOARD, URLSelectionOwner([img_url]))
   end

   private copy_link(u)
      parent_dialog.own_selection(Selection.CLIPBOARD, URLSelectionOwner([u]))
   end

   private save_image()
      browser.do_save_image(img_name, img_data)
   end

   private handle_rpress(e)
      local pm, pm_menu, u
      pm_menu := Menu()
      pm_menu.add(TextMenuItem().
                  set_label("Copy image").
                  connect(copy_image, Event.ACTION))
      if u := \wrote then
         pm_menu.add(TextMenuItem().
                     set_label("Copy link").
                     connect(create copy_link(u), Event.ACTION))
      if \img_data then
         pm_menu.add(TextMenuItem().
                     set_label("Save image...").
                     connect(save_image, Event.ACTION))
      pm := PopupMenu()
      pm.popup(parent_dialog, pm_menu, e.x, e.y)
   end

   private handle_lrelease(e, src)
      set_pointer()
      if \wrote then
         browser.goto(wrote, browser.page_url, Worker.NORMAL)
   end

   private handle_form_lrelease(e, src)
      if in_region(e) then
         form.submit(e, src)
   end

   private handle_exit(e)
      if \wrote then {
         browser.clear_msg()
         wrote := &null
         set_pointer()
      }
   end

   private which_url(e)
      local m, u
      in_region(e) | fail
      if m := browser.get_map(\map) &
         u := m.over_url(e.x - x - border.get_l_inset(), 
                         e.y - y - border.get_t_inset()) then 
         return u
      return \link_url
   end

   private handle_lpress(e)
      held := wrote
   end

   private handle_ldrag(e)
      local u
      if u := which_url(e) & u === held then {
         if wrote ~=== u then {
            browser.msg(u.str())
            wrote := u
         }
      } else if \wrote then {
         browser.clear_msg()
         wrote := &null
      }
   end

   private handle_move(e)
      local u
      if u := which_url(e) then {
         if wrote ~=== u then {
            set_pointer("hand1")
            browser.msg(u.str())
            wrote := u
         }
      } else if \wrote then {
         browser.clear_msg()
         wrote := &null
         set_pointer()
      }
   end

   public new(browser, img_url, link_url, form, imgw, imgh, map)
      cast(self,Label).new()
      self.browser := browser
      self.imgw := imgw
      self.imgh := imgh
      self.img_url := img_url
      self.form := form
      self.link_url := link_url
      self.map := map
      if \form then {
         set_pointer("hand1")
         connect(self.handle_form_lrelease, Event.MOUSE_LEFT_RELEASE)
      } else if \map | \link_url then {
         connect(self.handle_move, Event.MOUSE_MOVEMENT)
         connect(self.handle_ldrag, Event.MOUSE_LEFT_DRAG)
         connect(self.handle_lpress, Event.MOUSE_LEFT_PRESS)
         connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE)
         connect(self.handle_exit, Event.MOUSE_EXIT)
      }
      connect(self.handle_rpress, Event.MOUSE_RIGHT_PRESS)
      set_paint(NullPaint())
      set_border(NullBorder())
      return
   end
end

class FormEntry()
   public reset() end

   public get_ascent(cw, ch) 
      return ch
   end 

   public get_save_subkey() end
   public get_save_value() end
   public restore_value(val) end

   public defer get_value(ev, src, multipart_flag)
end

class FormToggle(ToggleTextButton, FormEntry)
   private const
      value,
      init_checked

   public reset()
      set_is_checked(init_checked)
   end

   public get_value(ev, src)
      if is_checked() then 
         return value
   end

   public get_save_subkey()
      return value
   end

   public get_save_value()
      return get_status()
   end

   public restore_value(val)
      set_is_checked(val)
   end

   public new(value, init_checked)
      cast(self,ToggleTextButton).new()
      self.value := value
      self.init_checked := init_checked
      set_is_checked(init_checked)
      return
   end
end

class FormButton(TextButton, FormEntry)
   private const
      value

   public get_value(ev, src)
      if src === self then
         return value
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset()
   end

   public new(value)
      cast(self,TextButton).new()
      self.value := value
      set_label(value)
      return
   end
end

class FormTbl(Tbl, FormEntry)
   private const
      value, form, type

   public get_value(ev, src)
      if src === self then
         return value
   end

   private handle_form_lrelease(e, src)
      if in_region(e) then {
         case type of { 
            "submit": form.submit(e, src)
            "reset": form.reset()
         }
      }
   end

   #
   # Prevent children from getting in the point chain.
   #
   public build_point_chain(l)
   end

   public new(form, value, type)
      cast(self,Tbl).new()
      self.value := value
      self.form := form
      self.type := type
      content.layout_delegate.set_align_baselines(&yes)
      set_border(CompoundBorder().
                 set_outer(RaisedBorder()).
                 set_inner(EmptyBorder()))
      set_pointer("hand1")
      connect(self.handle_form_lrelease, Event.MOUSE_LEFT_RELEASE)
      return
   end
end

class Hidden(FormEntry)
   private const
      value

   public get_value()
      return value
   end

   public new(value)
      self.value := value
      return
   end
end

class FormLabel()
   public const
      id
   public
      comp

   public new(id)
      self.id := id
      return
   end
end

class FormBrowse(Component, FormEntry)
   private const
      tf,
      browser

   public get_value(ev, src, multipart_flag)
      return if /multipart_flag then
         tf.get_contents()
      else
         Files.file_to_string(tf.get_contents())
   end

   public get_filename()
      return Files.get_path(tf.get_contents()).get(-1)
   end

   public get_ascent() 
      return cbwin.get_font_ascent() + Gui.Y_INSET
   end

   public reset()
      tf.set_contents(u"")
   end

   public get_save_value()
      return tf.get_contents()
   end

   public restore_value(val)
      tf.set_contents(val)
   end

   private on_browse()
      tf.set_contents(browser.do_browse_for_file())
   end

   public new(browser, tf_size)
      cast(self,Component).new()
      self.browser := browser
      set_layout(GridLayout().set_doi(0).set_dii(0))
      tf := TextField().set_size(tf_size).set_contents(u"")
      add(tf)
      add(TextButton().set_label("Browse...").connect(on_browse, Event.ACTION))
      return
   end
end

class FormImgX(FormEntry)
   private const
      img

   public get_value(ev, src)
      if src === img then
         return ev.x - img.x
   end

   public new(img)
      self.img := img
      return
   end
end

class FormImgY(FormEntry)
   private const
      img

   public get_value(ev, src)
      if src === img then
         return ev.y - img.y
   end

   public new(img)
      self.img := img
      return
   end
end

class FormTextField(TextField, FormEntry)
   private const
      init_val

   public get_ascent() 
      return cbwin.get_font_ascent() + border.get_t_inset()
   end

   public reset()
      set_contents(init_val)
   end

   public get_value()
      return get_contents()
   end

   public get_save_value()
      return get_contents()
   end

   public restore_value(val)
      set_contents(val)
   end

   public new(init_val)
      cast(self,TextField).new()
      self.init_val := init_val
      set_contents(init_val)
      return
   end
end

class FormEditableTextList(EditableTextList, FormEntry)
   private const
      init_val

   public reset()
      set_contents_str(init_val)
      set_cursor(1, 1)
   end

   public get_value()
      return get_contents_str()
   end

   public get_save_value()
      return get_contents()
   end

   public restore_value(val)
      set_contents(val)
   end

   public new(init_val)
      cast(self,EditableTextList).new()
      self.init_val := init_val
      set_contents_str(init_val)
      return
   end
end

class FormList(gui.List, FormEntry)
   private const
      init_val

   public get_ascent() 
      return cbwin.get_font_ascent() + view.border.get_t_inset() + border.get_t_inset()
   end

   public reset()
      set_selection(init_val)
   end

   public get_value(ev, src)
      return object_get_selection()
   end

   public get_save_value()
      return get_selection()
   end

   public restore_value(val)
      set_selection(val)
   end

   public new(list, init_val)
      cast(self,gui.List).new()
      self.init_val := init_val
      set_selection_list(list)
      set_selection(init_val)
      return
   end
end

class Form()
   private readable
      url,
      browser,
      method,
      enctype,
      items,
      labels,   # table of FormLabels with ids set (the "for" attribute)
      cbgs,
      ids       # table of Components with ids set ("id" attribute) which will be matched to entries in labels.

   private make_cgi_table(ev, src)
      local t, k, c, v, x
      t := table()
      every k := key(items) do {
         every c := !items[k] do {
            if v := c.get_value(ev, src) then {
               (x := member(t, k)) | insert(t, k, x := [])
               put(x, v)
            }
         }
      }
      return t
   end

   private static escape_1521_value(s)
      local t
      t := u"\""
      s ? repeat {
         t ||:= tab(many(&uset -- '\"\\\r'))
         if pos(0) then
            break
         t ||:= u"\\" || move(1)
      }
      return t || u"\""
   end

   private make_cgi_message(ev, src)
      local k, v, c, m, mp, m2
      m := Message()
      mp := Multipart()
      every k := key(items) do {
         every c := !items[k] do {
            if v := c.get_value(ev, src, 1) then {
               m2 := Message()
               if is(c, FormBrowse) then {
                  m2.set_header("Content-Disposition", 
                                "form-data; name=" || escape_1521_value(k) || 
                                "; filename=" || escape_1521_value(c.get_filename()))
                  m2.set_header("Content-Type", "application/octet-stream")
               } else 
                  m2.set_header("Content-Disposition", 
                                "form-data; name=" || escape_1521_value(k))
               m2.set_decoded_content(v)
               mp.add_part(m2)
            }
         }
      }
      m.set_header("Content-Type", "multipart/form-data")
      m.set_content_object(mp) | stop("Failed to set_content_object:",m.get_reason())
      return m
   end

   public reset()
      every (!!items).reset()
   end

   public submit(ev, src)
      if map(method) == "post" then {
         if map(enctype) == "multipart/form-data" then
            browser.goto(url, browser.page_url, Worker.NORMAL, make_cgi_message(ev, src))
         else 
            browser.goto(url, browser.page_url, Worker.NORMAL, make_cgi_table(ev, src))
      } else
         browser.goto(clone(url).set_cgi_parameters(make_cgi_table(ev, src)), browser.page_url, Worker.NORMAL)
   end

   public add(name, item)
      local x
      (x := member(items, name)) | insert(items, name, x := [])
      put(x, item)
   end

   public add_label(l)
      insert(labels, l.id, l)
   end

   public link_label(id, curr_label, comp)
      # If we have a label in the context, and the for and id tags
      # make sense, link the comp to the label; otherwise put the comp
      # in ids so its id can be resolved at the end of the form.
      if \curr_label & (/curr_label.id | /id | curr_label.id == id) then
         /curr_label.comp := comp
      else
         insert(ids, \id, comp)
   end

   public resolve_link_labels()
      local id
      every id := key(ids) do
         /member(labels, id).comp := ids[id]
   end

   public get_cbg(name)
      local x
      (x := member(cbgs, name)) | insert(cbgs, name, x := CheckBoxGroup())
      return x
   end

   public new(browser, url, method, enctype)
      self.browser := browser
      self.url := url
      self.method := method
      self.enctype := enctype
      self.items := table()
      self.cbgs := table()
      self.labels := table()
      self.ids := table()
      return
   end
end

record TableContext(tbl, caption, x, y, occ, cell_border, tr)
record ListContext(tbl, index, root)
record DefListContext(tbl)
record FieldSetContext(legend)
record MapContext(map)
record SelectContext(options, sel)
record Context(base, form, form_label, url, fg, link_fg, font, align, pre, underline, strike, 
               baseline_off, face, size, bold, italic, kind, table, list, def_list, fieldset, select, map)

class MapArea()
   public const
      shape, coords, url

   public new(shape, coords, url)
      self.shape := shape
      self.coords := coords
      self.url := url
      return
   end
end

class Map()
   private const
      l

   public over_url(x, y)
      local e, co
      every e := !l do {
         co := e.coords
         case e.shape of {
            "rect": if (co[1] <= x <= co[3]) & (co[2] <= y <= co[4]) then
               return e.url
         }
      }
   end

   public add_area(area)
      put(l, area)
   end

   public new()
      l := []
      return
   end
end

record HistoryEntry(url,          # URL displayed (on a redirect may differ from that requested) 
                    referer,      # referer URL
                    form_values,  # Cached values of form components; updated when we move away from the page 
                    form_data,    # POST data used to get the page; on a redirect will always be null
                    area_y
                    ) 

class BrowserUI()
   public defer msg(s, n)
   public defer clear_msg()
   public defer set_url_field(val)
   public defer update_grey(gs)
   public defer set_title(s)
   public defer get_authentication(site)
end

record GreyState(prev, nxt, refresh, copy_page, save_page, stop)

class Browser(Component)
   private
      ui,
      workers,
      top_panel,
      status_ticker,
      maps,
      forms,
      curr_history_entry   # History entry currently being viewed.

   private readable
      history,
      history_pos,
      page_url,
      page_data,
      page_name,
      page_title,
      queue,
      running,
      cookies,
      user_agent,
      log_http_flag,
      cache,
      file_dialog,
      authentications

   public static const 
      COLORS,
      FACES,
      SIZES

   private static init()
      COLORS := table(,
                      "aqua", "#00FFFF",
                      "black", "#x000000",
                      "blue", "#0000CC",
                      "fuchsia", "#FF00FF",
                      "gray", "#808080",
                      "green", "#008000",
                      "lime", "#00FF00",
                      "maroon", "#800000",
                      "navy", "#000080",
                      "olive", "#808000",
                      "purple", "#800080",
                      "red", "#FF0000",
                      "silver", "#C0C0C0",
                      "teal", "#008080",
                      "white", "#FFFFFF",
                      "yellow", "#FFFF00")

      FACES := table(,
                     "serif", "serif",
                     "sans-serif", "sans",
                     "monospace", "mono",
                     "sans", "sans",
                     "mono", "mono",
                     "typewriter", "typewriter",
                     "cursive", "serif",
                     "fantasy", "serif",
                     "helvetica", "sans",
                     "arial", "sans",
                     "times", "serif",
                     "times new roman", "serif",
                     "courier", "typewriter")

      SIZES := [7,9,11,14,17,20,23]
      ImageCache.name_image("rpp.BROKEN_LINK", BROKEN_LINK)
   end

   public get_map(s)
      return member(maps, s)
   end

   private convert_color(el, name)
      local s
      if s := el.get_attribute(name) then {
         return if s[1] == "#" then
            s
         else
            member(COLORS, map(trim(string(s))))
      }
   end

   private synch_font(context)
      local s
      s := member(FACES, map(trim(separate(string(context.face))))) | "sans"
      if \context.bold then
         s ||:= ",bold"
      if \context.italic then
         s ||:= ",italic"
      s ||:= "," || SIZES[context.size]
      context.font := s
   end

   private status()
      local i, r, s
      repeat {
         status_ticker.sleep(200)
         i := *queue
         every i +:= (!workers).count()
         if (i > 0) | (i ~=== running) then {
            if i = 0 then {
               msg("Done")
               page_fully_loaded()
            } else {
               r := 0
               every r +:= (!workers).read()
               s := i || " running requests"
               if r > 0 then
                  s ||:= ", read " || r || " bytes"
               msg(s)
            }
            if i ~=== running then {
               running := i
               do_update_grey()
            }
         }
      }
   end

   public lookup_authentication(url, realm)
      local k, v
      k := realm || " at " || string(url.address)
      if v := member(authentications, k) then
         return v
      if v := get_authentication(k) then {
         insert(authentications, k, v)
         return v
      } 
   end

   public set_ui(ui)
      self.ui := ui
      return self
   end

   public msg(s, n)
      (\ui).msg(s, n)
   end

   public clear_msg()
      (\ui).clear_msg()
   end

   public set_url_field(val)
      (\ui).set_url_field(val)
   end

   public update_grey(gs)
      (\ui).update_grey(gs)
   end

   public set_title(s)
      (\ui).set_title(s)
   end

   public get_authentication(site)
      return (\ui).get_authentication(site)
   end

   public do_update_grey()
      update_grey(GreyState(if history_pos > 1 then &no else &yes,
                            if history_pos < *history then &no else &yes,
                            if history[history_pos] then &no else &yes,
                            if \page_url then &no else &yes,
                            if \page_data then &no else &yes,
                            if \running > 0 then &no else &yes))
   end

   private page_fully_loaded()
      local yp
      top_panel.reset_all_layouts()
      top_panel.layout()
      top_panel.invalidate()
      # Goto named anchor unless user has started to scroll page
      if top_panel.get_area_y() = 0 then {
         if yp := \curr_history_entry.area_y | (lookup_named_anchor(page_url.get_ref()) - top_panel.view.y) then
            top_panel.set_area_y(yp)
      }
      parent_dialog.resynch_pointer()
   end

   private lookup_named_anchor(name)
      local c, yp
      every c := Seq{top_panel.traverse_components_postorder()} do
         if is(c,TextFlow) & yp := c.lookup_named_anchor(name) then
            return yp
   end

   public initially()
      cast(self,Component).initially()
      every (!workers).initially()
      status_ticker.start()
      do_update_grey()
   end

   public finally()
      cast(self,Component).finally()
      every (!workers).finally()
      clear(queue)
      running := 0
      status_ticker.stop()
   end

   public do_next()
      local he
      he := history[history_pos +:= 1] 
      goto(he.url, he.referer, Worker.NAVIGATE, he.form_data)
      do_update_grey()
   end

   public do_prev()
      local he
      he := history[history_pos -:= 1] 
      goto(he.url, he.referer, Worker.NAVIGATE, he.form_data)
      do_update_grey()
   end

   public do_refresh()
      local he
      he := history[history_pos] 
      goto(he.url, he.referer, Worker.REFRESH, he.form_data)
      do_update_grey()
   end

   public do_save_page()
      local s
      file_dialog.set_file(\page_name)
      file_dialog.show_modal(parent_dialog)
      if s := file_dialog.get_result() then {
         if Files.string_to_file(s, page_data) then
            msg("Saved OK", 3000)
         else
            msg(&why, 3000)
      }
   end

   public do_copy_page()
      parent_dialog.own_selection(Selection.CLIPBOARD, URLSelectionOwner([page_url]))
   end

   public do_save_image(img_name, img_data)
      local s
      file_dialog.set_file(\img_name)
      file_dialog.show_modal(parent_dialog)
      if s := file_dialog.get_result() then {
         if Files.string_to_file(s, img_data) then
            msg("Saved OK", 3000)
         else
            msg(&why, 3000)
      }
   end

   public do_browse_for_file()
      file_dialog.show_modal(parent_dialog)
      return file_dialog.get_result()
   end

   private cancel()
      every (!workers).cancel()
      clear(queue)
   end

   private start_worker(req)
      local w
      put(queue, req)
      running := &null
      every w := !workers do 
         if w.task ~=== Dispatcher.scheduler.curr_task then
            w.task.notify()
   end

   private static is_html(ct, s)
      if (\ct).subtype == "html" then
         return
      s ? {
         while tab(upto('<')) do {
            if matchcl("<!doctype" | "<html" | "<meta") then
               return
            # Expect html comment (see htmlparser.icn)
            ="<!" | fail
            repeat {
               tab(upto('->'))
               if u">" then
                  break
               ="--" | fail
               tab(find("--")) | fail
               ="--"
            }
         }
      }
   end

   private convert_to_ucs(ct, s)
      return if (\ct).get_parameter("charset") == "ISO-8859-1" then
         Text.iso_8859_1_to_ucs(s)
      else
         Text.liberal_ucs(s)
   end

   private save_form_values()
      local f, c, name, t1, t2, k
      t1 := table()
      every f := !forms do {
         t2 := table()
         insert(t1, f.url.str(), t2)
         every name := key(f.items) do {
            every c := !f.items[name] do {
               k := Class.get_name(c) || u":" || name
               k ||:= u":" || c.get_save_subkey()
               insert(t2, k, c.get_save_value())
            }
         }
      }
      curr_history_entry.form_values := t1
   end

   private restore_form_values()
      local f, c, name, t1, t2, k
      t1 := \curr_history_entry.form_values | fail
      every f := !forms do {
         if t2 := member(t1, f.url.str()) then {
            every name := key(f.items) do {
               every c := !f.items[name] do {
                  k := Class.get_name(c) || u":" || name
                  k ||:= u":" || c.get_save_subkey()
                  c.restore_value(member(t2, k))
               }
            }
         }
      }
      
   end

   private set_top_data(res)
      local doc, base, n, s, row, c, view_img
      if \curr_history_entry then {
         save_form_values()
         curr_history_entry.area_y := top_panel.get_area_y()
      }
      if \res.err then {
         s := u"<html><h1>Error:</h1>Getting " || res.url.str() || u"<br><br>" || res.err || u"</html>"
         page_data := &null
      } else if is_html(res.content_type, res.data) then {
         s := page_data := res.data
      } else if view_img := Window.open_image(res.data) then {
         view_img.close()
         row := Image().set_border(NullBorder()).set_image(res.data)
         page_data := res.data
      } else {
         s := u"<html><h1>Problem:</h1>Displaying " || res.url.str() || u"<br><br>This does not seem to be an HTML document</html>"
         page_data := res.data
      }

      page_name := res.fname
      page_url := res.url
      if res.kind = Worker.NORMAL then {
         # Reset history_pos, since we may have done a navigate
         # back/forward (changing history_pos), and cancelled it with
         # a normal click whist it was pending.
         history_pos := keyof(history, curr_history_entry)
         while *history > history_pos do
            pull(history)
         # Fields are set below
         put(history, HistoryEntry())
         history_pos +:= 1
      }
      do_update_grey()
      set_url_field(page_url.str())
      curr_history_entry := history[history_pos]
      # Note that the url/form_data may change even on a
      # navigate/refresh, if the server behaved differently (eg
      # redirect instead of error).
      curr_history_entry.url := page_url
      curr_history_entry.referer := res.referer
      curr_history_entry.form_data := res.form_data
      maps := table()
      forms := []
      if /view_img then {
         #Files.string_to_file("/tmp/browser.html",s)
         s := convert_to_ucs(res.content_type, s)
         doc := HtmlParser().parse(s)
         base := page_url
         if n := doc.get_root_element().search_tree(u"BASE") then
            base := URL.parse(n.get_attribute(u"HREF"))

         row := TextFlow(self)
         page_title := &null
         c := Context()
         c.base := base
         c.face := "sans"
         c.fg := "black"
         c.link_fg := "blue"
         c.size := 3
         c.baseline_off := 0
         c.kind := res.kind   # Tells images whether to refresh or not
         synch_font(c)
         if n := doc.get_root_element().search_tree(u"BODY") then {
            row.set_bg(convert_color(n, u"BGCOLOR"))
            c.fg := convert_color(n, u"TEXT")
            c.link_fg := convert_color(n, u"LINK")
         }
         traverse(doc, row, c)
         if res.kind ~= Worker.REFRESH then
            restore_form_values()
      } else
         page_title := page_name
      set_title(page_title)
      top_panel.set_area_y(0)
      top_panel.view.inner.finally()
      top_panel.set_inner(row)
      row.initially()
      top_panel.layout()
      top_panel.invalidate()
      parent_dialog.resynch_pointer()
   end

   private mk_link(base, s)
      if match(u"http://" | u"https://" | u"file://", map(s)) then
         return URL.parse(s)
      else if \base then
         return base.get_relative(s)
   end

   private traverse_a(e, p, context)
      local url, c, na
      if na := e.get_attribute(u"NAME") then {
         put(p.input, NamedAnchorCmd(na))
         traverse(e, p, context)
      }
      else if url := mk_link(context.base, e.get_attribute(u"HREF")) then {
         c := copy(context)
         c.url := url
         c.fg := c.link_fg
         traverse(e, p, c)
      }
   end

   private traverse_hN(e, p, context)
      local c
      put_para(p)
      c := copy(context)
      c.size := 7 - e.name[-1]
      c.bold := 1
      synch_font(c)
      traverse(e, p, c)
      put_para(p)
   end

   private parse_size(s, curr)
      local i
      i := if any('+\-', s[1]) then
         curr + integer(s)
      else
         integer(s)
      return (0 < \i <= 7, i)
   end

   private traverse_font(e, p, context)
      local c
      c := copy(context)
      c.fg := convert_color(e, u"COLOR")
      c.face := e.get_attribute(u"FACE")
      c.size := parse_size(e.get_attribute(u"SIZE"), c.size)
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_tt(e, p, context)
      local c
      c := copy(context)
      c.face := "mono"
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_big(e, p, context)
      local c
      c := copy(context)
      if c.size < 7 then {
         c.size +:= 1
         synch_font(c)
      }
      traverse(e, p, c)
   end

   private traverse_small(e, p, context)
      local c
      c := copy(context)
      if c.size > 1 then {
         c.size -:= 1
         synch_font(c)
      }
      traverse(e, p, c)
   end

   private traverse_sup(e, p, context)
      local c
      c := copy(context)
      if c.size > 1 then {
         c.size -:= 1
         synch_font(c)
      }
      c.baseline_off +:= 1
      traverse(e, p, c)
   end

   private traverse_sub(e, p, context)
      local c
      c := copy(context)
      if c.size > 1 then {
         c.size -:= 1
         synch_font(c)
      }
      c.baseline_off -:= 1
      traverse(e, p, c)
   end

   private traverse_b(e, p, context)
      local c
      c := copy(context)
      c.bold := 1
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_i(e, p, context)
      local c
      c := copy(context)
      c.italic := 1
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_u(e, p, context)
      local c
      c := copy(context)
      c.underline := 1
      traverse(e, p, c)
   end

   private traverse_s(e, p, context)
      local c
      c := copy(context)
      c.strike := 1
      traverse(e, p, c)
   end

   private traverse_form(e, p, context)
      local m, c, t
      m := e.get_attribute(u"METHOD") | "get"
      t := e.get_attribute(u"ENCTYPE") | "application/x-www-form-urlencoded"
      c := copy(context)
      if c.form := Form(self, mk_link(context.base, e.get_attribute(u"ACTION")), m, t) then
         put(forms, c.form)
      traverse(e, p, c)
      (\c.form).resolve_link_labels()
   end

   private traverse_label(e, p, context)
      local c, l, id
      \context.form | fail
      id := e.get_attribute(u"FOR")
      l := FormLabel(id)
      if \id then
         context.form.add_label(l)
      c := copy(context)
      c.form_label := l
      traverse(e, p, c)
   end

   private add_component(p, c, context, align)
      /align := "absbottom"
      put(p.input, ComponentCmd(c, context, align))
      p.add(c)
   end

   private traverse_button(e, p, context)
      local q, row, v, type
      \context.form | fail
      v := e.get_attribute(u"VALUE") | u""
      type := map(string(e.get_attribute(u"TYPE")))
      q := FormTbl(context.form, v, type)
      if e.get_attribute(u"DISABLED") then
         q.set_is_shaded(&yes)
      else
         context.form.add(e.get_attribute(u"NAME"), q)
      row := TextFlow(self)
      q.content.add(row)
      add_component(p, q, context, Align.B)
      traverse(e, row, context)
   end

   private traverse_img(e, p, context)
      local q, url, border, iw, ih, align, map, s
      if url := mk_link(context.base, e.get_attribute(u"SRC")) then {
         iw := (0 <= integer(e.get_attribute(u"WIDTH")))
         ih := (0 <= integer(e.get_attribute(u"HEIGHT")))
         if (s := e.get_attribute(u"USEMAP")) & (s[1] == u"#") then
            map := default.map(string(s[2:0]))
         q := Img(self, url, context.url,, iw, ih, map)
         border := (0 < integer(e.get_attribute(u"BORDER"))) | 0
         if border > 0 then
            q.set_border(PlainBorder().set_line_width(border))
         start_worker(Req(url, page_url, q.got_data, context.kind))
         align := convert_comp_align(e, u"ALIGN") | Align.B
         add_component(p, q, context, align)
      }
   end

   private traverse_select(e, p, context)
      local q, id, c, sc
      \context.form | fail
      id := e.get_attribute(u"ID")
      sc := SelectContext()
      sc.options := []
      sc.sel := 1
      c := copy(context)
      c.select := sc
      traverse(e, p, c)
      q := FormList(sc.options, sc.sel). 
         set_font(context.font).
         set_fg(context.fg)
      if e.get_attribute(u"DISABLED") then
         q.set_is_shaded(&yes)
      else
         context.form.add(e.get_attribute(u"NAME"), q)
      context.form.link_label(id, context.form_label, q)
      add_component(p, q, context, Align.B)
   end

   private traverse_option(e, p, context)
      local sc
      sc := \context.select | fail
      put(sc.options, e.get_trimmed_string_content())
      if e.get_attribute(u"SELECTED") then
         sc.sel := *sc.options
   end

   private traverse_textarea(e, p, context)
      local q, w, h, mW, id
      \context.form | fail
      id := e.get_attribute(u"ID")
      mW := cbwin.clone().set_font(context.font)
      w := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + mW.text_width(repl("x", e.get_attribute(u"COLS")))) | 200
      h := (2 * Gui.BORDER_WIDTH + e.get_attribute(u"ROWS") * mW.get_font_height()) | 100
      mW.uncouple()
      # The ucs conversion is used here since an empty node will return "" (not u"").
      q := FormEditableTextList(ucs(e.get_trimmed_string_content())).
         set_font(context.font).
         set_fg(context.fg).
         set_size(w, h)
      if e.get_attribute(u"DISABLED") then
         q.set_is_shaded(&yes)
      else {
         if e.get_attribute(u"READONLY") then
            q.set_is_editable(&no)
         context.form.add(e.get_attribute(u"NAME"), q)
      }
      context.form.link_label(id, context.form_label, q)
      add_component(p, q, context)
   end

   private traverse_input(e, p, context)
      local q, s, k, v, size, mW, id, url, checked, align
      \context.form | fail
      s := string(map(e.get_attribute(u"TYPE"))) | "text"
      case s of {
         "file": {
            mW := cbwin.clone().set_font(context.font)
            size := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + mW.text_width(repl("x", e.get_attribute(u"SIZE")))) | 160
            mW.uncouple()
            q := FormBrowse(self, size).
                  set_font(context.font).
                  set_fg(context.fg)
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else
               context.form.add(e.get_attribute(u"NAME"), q)
            add_component(p, q, context, Align.B)
         }
         "submit" : {
            v := e.get_attribute(u"VALUE")
            if /v | (*v = 0) then
               v := u"Submit"
            q := FormButton(v).
                  set_font(context.font).
                  set_fg(context.fg).
                  connect(context.form.submit, Event.ACTION)
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else
               context.form.add(e.get_attribute(u"NAME"), q)
            add_component(p, q, context, Align.B)
         }
         "image" : {
            if url := mk_link(context.base, e.get_attribute(u"SRC")) then {
               q := Img(self, url,, context.form)
               start_worker(Req(url, page_url, q.got_data, context.kind))
               if e.get_attribute(u"DISABLED") then
                  q.set_is_shaded(&yes)
               else {
                  if k := e.get_attribute(u"NAME") then {
                     context.form.add(k || ".x", FormImgX(q))
                     context.form.add(k || ".y", FormImgY(q))
                  } else {
                     context.form.add("x", FormImgX(q))
                     context.form.add("y", FormImgY(q))
                  }
               }
               align := convert_comp_align(e, u"ALIGN") | Align.B
               add_component(p, q, context, align)
            }
         }
         "reset" : {
            v := e.get_attribute(u"VALUE")
            if /v | (*v = 0) then
               v := u"Reset"
            q := FormButton(v).
               set_font(context.font).
               set_fg(context.fg).
               connect(context.form.reset, Event.ACTION)
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            add_component(p, q, context, Align.B)
         }
         "hidden": {
            context.form.add(e.get_attribute(u"NAME"), Hidden(e.get_attribute(u"VALUE")))
         }
         "radio": {
            v := e.get_attribute(u"VALUE") | u"on"
            id := e.get_attribute(u"ID")
            checked := if e.get_attribute(u"CHECKED") then &yes else &no
            q := FormToggle(v, checked).
               set_paint(ImagePaint().set_cache("gui.DIAMOND_UP")).
               set_paint_down(ImagePaint().set_cache("gui.DIAMOND_DOWN")).
               set_border(NullBorder())
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else
               context.form.add(e.get_attribute(u"NAME"), q)
            add_component(p, q, context, Align.B)
            context.form.link_label(id, context.form_label, q)
            context.form.get_cbg(e.get_attribute(u"NAME")).add(q)
         }
         "checkbox": {
            v := e.get_attribute(u"VALUE") | u"on"
            id := e.get_attribute(u"ID")
            checked := if e.get_attribute(u"CHECKED") then &yes else &no
            q := FormToggle(v, checked).
               set_paint(ImagePaint().set_cache("gui.BOX_UP")).
               set_paint_down(ImagePaint().set_cache("gui.BOX_DOWN")).
               set_border(NullBorder())
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else
               context.form.add(e.get_attribute(u"NAME"), q)
            add_component(p, q, context, Align.B)
            context.form.link_label(id, context.form_label, q)
         }
         "text" | "password": {
            v := e.get_attribute(u"VALUE") | u""
            id := e.get_attribute(u"ID")
            mW := cbwin.clone().set_font(context.font)
            size := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + mW.text_width(repl("x", e.get_attribute(u"SIZE")))) | 160
            mW.uncouple()
            q := FormTextField(v).
               set_fg(context.fg).
               set_font(context.font).
               set_size(size).
               connect(context.form.submit, Event.ACTION)
            if s == "password" then
               q.set_displaychar("*")
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else {
               if e.get_attribute(u"READONLY") then
                  q.set_is_editable(&no)
               context.form.add(e.get_attribute(u"NAME"), q)
            }
            context.form.link_label(id, context.form_label, q)
            add_component(p, q, context, Align.B)
         }
      }
      traverse(e, p, context)
   end

   private show_parents(c)
      write("chain of ",image(c))
      while \c do {
         write("\tc=",image(c))
         c := c.parent
      }
   end

   private show_input(ii, l)
      local s,a
      case classof(ii) of {
         TextCmd: {
            s := ii.s
            if *s > 30 then 
               s[30:0] := "...("||*s||")"
            a := ""
            a ||:= "fg="|| \ii.attr.fg
            a ||:= " font="|| \ii.attr.font
            write(repl("   ",l), image(s),"  ",a) 
         }
         ComponentCmd: show_structure(ii.c, l)
         default: write(repl("   ",l),image(ii))
      }
   end

   private show_output(xo, l)
      local s,a
      s := "Text @"||xo.x||","||xo.y
      s ||:= xo.s
      if *s > 30 then 
         s[30:0] := "...("||*s||")"
      a := ""
      a ||:= "fg="|| \xo.attr.fg
      a ||:= " font="|| \xo.attr.font
      write(repl("   ",l), image(s),"  ",a) 
   end

   private show_structure(c, l)
      local s, v, short
      /l := 0
      short := s := ""
      short ||:= "w="||\c.w||" h="||\c.h
      if is(c, TextFlow) then short ||:= "  " || *c.input || " items"
      if c.get_constraint("eol") then s ||:= "eol "
      if \c.get_constraint("x_fill") then s ||:= "x_fill "
      if v := c.get_constraint("x_weight") then s ||:= "x_weight=" || v
      if v := c.get_constraint("x_align") then s ||:= "x_align=" || v
      write(repl("   ",l), image(c),short,"\t\t\t",s)
      if is(c, TextFlow) then {
         every show_input((!c.input), l+1)
      } else
         every show_structure((!c.children), l+1)
   end

   private traverse_div(e, p, context)
      put_new_row(p)
      traverse(e, p, context)
   end

   private traverse_br(e, p, context)
      local clear
      clear := case string(map(e.get_attribute(u"CLEAR"))) of {
         "left": Align.L
         "right": Align.R
         "all"|"both": "all"
      }
      put(p.input, BreakCmd(clear))
   end

   private traverse_hr(e, p, context)
      put_new_row(p)
      add_component(p, Line().set_width(5), context)
      put_new_row(p)
   end

   private traverse_q(e, p, context)
      put(p.input, TextCmd(u"\u201c", context))
      traverse(e, p, context)
      put(p.input, TextCmd(u"\u201d", context))
   end

   private traverse_p(e, p, context)
      local c
      c := copy(context)
      put_para(p)
      c.align := case string(map(e.get_attribute(u"ALIGN"))) of {
         "left": Align.L
         "center": Align.C
         "right": Align.R
      }
      traverse(e, p, c)
      put_para(p)
   end

   private traverse_pre(e, p, context)
      local c
      put_para(p)
      c := copy(context)
      c.face := "mono"
      synch_font(c)
      c.pre := 1
      traverse(e, p, c)
      put_para(p)
   end

   private put_para(p)
      put(p.input, ParaCmd())
   end

   private put_new_row(p)
      put(p.input, NewRowCmd())
   end

   private traverse_center(e, p, context)
      local c
      c := copy(context)
      c.align := Align.C
      traverse(e, p, c)
   end

   private convert_valign(el, name)
      return case string(map(el.get_attribute(name))) of {
         "top": Align.T
         "middle": Align.C
         "bottom"|"baseline": Align.B
      }
   end

   private convert_halign(el, name)
      return case string(map(el.get_attribute(name))) of {
         "left": Align.L
         "center": Align.C
         "right": Align.R
      }
   end

   private convert_cap_align(el, name)
      return case string(map(el.get_attribute(name))) of {
         "left": Align.L
         "right": Align.R
         "top": Align.T
         "bottom": Align.B
      }
   end

   private convert_comp_align(el, name)
      return case map(string(el.get_attribute(name))) of {
         "left": Align.L
         "right": Align.R
         "baseline"|"bottom": Align.B
         "texttop"|"top": Align.T
         "middle" | "center" | "centre": Align.C
         "absbottom":  "absbottom"
         "absmiddle":  "absmiddle"
      }
   end

   private traverse_table(e, p, context)
      local ct, tbl, width, border, cellpadding, cellspacing, cell_border, align, c

      tbl := Tbl()
      if width := (0 <= integer(e.get_attribute(u"WIDTH"))) then
         tbl.set_width(width)
      border := integer(e.get_attribute(u"BORDER")) | 0
      cellpadding := integer(e.get_attribute(u"CELLPADDING")) | 0
      cellspacing := integer(e.get_attribute(u"CELLSPACING")) | 2
      tbl.content.layout_delegate.set_doi(cellspacing).set_dii(cellspacing/2)
      if border > 0 then
         tbl.set_border(PlainBorder().set_line_width(border))
      tbl.set_bg(convert_color(e, u"BGCOLOR"))

      cell_border := if border > 0 then
         CompoundBorder().
            set_outer(PlainBorder().set_line_width(1)).
            set_inner(EmptyBorder().set_insets(cellpadding, cellpadding, cellpadding, cellpadding))
         else
            EmptyBorder().set_insets(cellpadding, cellpadding, cellpadding, cellpadding)
      align := convert_comp_align(e, u"ALIGN") | Align.C

      c := copy(context)
      c.table := ct := TableContext()
      ct.tbl := tbl
      ct.x := ct.y := 1
      ct.occ := set()
      ct.cell_border := cell_border
      traverse(e, p, c)

      if not(align === (Align.L | Align.R)) then
         put_new_row(p)
      if \c.table.caption then
         add_component(p, c.table.caption, context, align)
      else
         add_component(p, tbl, context, align)

      if not(align === (Align.L | Align.R)) then
         put_new_row(p)
   end

   private traverse_caption(e, p, context)
      local ct, cap, main, c, align
      ct := \context.table | fail
      /ct.caption | fail

      # A Tbl with two TextFlows; the caption and another containing just the table itself.
      ct.caption := Tbl()
      cap := TextFlow(self).set_dominant_width(TextFlow.DEFAULT_WIDTH)
      c := copy(context)
      c.align := Align.C
      traverse(e, cap, c)
      main := TextFlow(self)
      add_component(main, ct.tbl, context)
      align := convert_cap_align(e, u"ALIGN") | Align.T
      case align of {
         Align.T: {
            cap.set_constraint("eol", &yes)
            ct.caption.inner.add(cap).add(main)
         }
         Align.B: {
            main.set_constraint("eol", &yes)
            ct.caption.inner.add(main).add(cap)
         }
         Align.L: {
            ct.caption.inner.add(cap).add(main)
         }
         Align.R: {
            ct.caption.inner.add(main).add(cap)
         }
      }
   end

   private traverse_tr(e, p, context)
      local ct
      ct := \context.table | fail
      ct.tr := e
      if ct.x > 1 then {
         ct.x := 1
         ct.y +:= 1
      }
      traverse(e, p, context)
      if ct.x > 1 then {
         ct.x := 1
         ct.y +:= 1
      }
      ct.tr := &null
   end

   private traverse_td(e, p, context)
      local ct, row, c, colspan, rowspan, width, valign
      ct := \context.table | fail
      while member(ct.occ, ct.x || "," || ct.y) do
         ct.x +:= 1
      valign := convert_valign(e | \ct.tr, u"VALIGN") |  Align.C
      row := TextFlow(self).
         set_constraint("x", ct.x). 
         set_constraint("y", ct.y).
         set_border(ct.cell_border).
         set_v_align(valign)
      colspan := (0 < integer(e.get_attribute(u"COLSPAN"))) | 1
      row.set_constraint("w", colspan)
      rowspan := (0 < integer(e.get_attribute(u"ROWSPAN"))) | 1
      row.set_constraint("h", rowspan)
      row.set_bg(convert_color(e | \ct.tr, u"BGCOLOR"))
      every insert(ct.occ, (ct.x to ct.x + colspan - 1) || "," || (ct.y to ct.y + rowspan - 1))
      if width := e.get_attribute(u"WIDTH") then {
         if width := (0 <= integer(width)) then
            row.set_width(width)
         else if width[-1] == "%" & width := (0 <= integer(width[1:-1])) then
            row.set_constraint("pct_w", width)
      }
      ct.tbl.content.add(row)

      c := copy(context)
      if e.name == u"TH" then {
         c.bold := 1
         c.size := min(c.size + 1, 7)
         synch_font(c)
         c.align := convert_halign(e | \ct.tr, u"ALIGN") | Align.C
      } else
         c.align := convert_halign(e | \ct.tr, u"ALIGN") | Align.L
      ct.x +:= colspan

      traverse(e, row, c)
   end

   private traverse_list(e, p, context)
      local tbl, lc, c
      tbl := Tbl()
      tbl.content.layout_delegate.set_align_baselines(&yes)
      c := copy(context)
      lc := ListContext()
      lc.tbl := tbl
      lc.index := 0
      lc.root := e
      c.list := lc
      traverse(e, p, c)
      put_new_row(p)
      add_component(p, tbl, context, Align.B)
      put_new_row(p)
   end

   private traverse_li(e, p, context)
      local lc, row
      lc := \context.list | fail
      row := TextFlow(self)
      if lc.root.name == u"OL" then
         put(row.input, TextCmd((lc.index +:= 1) || u".\ua0\ua0\ua0", context))
      else
         put(row.input, TextCmd(u"\u2022\ua0\ua0\ua0", context))
      lc.tbl.content.add(row)
      row := TextFlow(self) .set_constraint("eol", &yes)
      lc.tbl.content.add(row)
      traverse(e, row, context)
   end

   private traverse_dl(e, p, context)
      local tbl, dc, c
      tbl := Tbl()
      tbl.content.layout_delegate.set_fix_col1(&yes).set_align_baselines(&yes)
      dc := DefListContext()
      dc.tbl := tbl
      c := copy(context)
      c.def_list := dc
      traverse(e, p, c)
      put_new_row(p)
      add_component(p, tbl, context, Align.B)
      put_new_row(p)
   end

   private traverse_dt(e, p, context)
      local dc, row
      dc := \context.def_list | fail
      row := TextFlow(self) .set_constraint("eol", &yes).set_constraint("w", 2)
      dc.tbl.content.add(row)
      traverse(e, row, context)
   end

   private traverse_dd(e, p, context)
      local dc, row
      dc := \context.def_list | fail
      row := TextFlow(self) .set_constraint("eol", &no)
      put(row.input, TextCmd(u"\u2022\ua0\ua0\ua0", context))
      dc.tbl.content.add(row)
      row := TextFlow(self) .set_constraint("eol", &yes)
      dc.tbl.content.add(row)
      traverse(e, row, context)
   end

   private traverse_blockquote(e, p, context)
      local tbl, row
      put_new_row(p)
      tbl := Tbl()
      add_component(p, tbl, context)
      row := TextFlow(self)
      put(row.input, TextCmd(u"\ua0\ua0\ua0\ua0", context))
      tbl.content.add(row)
      row := TextFlow(self) .set_constraint("eol", &yes)
      tbl.content.add(row)
      traverse(e, row, context)
      put_new_row(p)
   end

   private traverse_fieldset(e, p, context)
      local tbl, row, c, fc
      put_new_row(p)
      tbl := Tbl().set_border(CompoundBorder().
                              set_outer(SunkenBorder().set_line_width(1)).
                              set_inner(EmptyBorder()))
      add_component(p, tbl, context)
      row := TextFlow(self)
      tbl.content.add(row)
      fc := FieldSetContext()
      c := copy(context)
      c.fieldset := fc
      traverse(e, row, c)
      tbl.set_title(\fc.legend)
      put_new_row(p)
   end

   private traverse_legend(e, p, context)
      local fc
      fc := \context.fieldset | fail
      /fc.legend | fail
      fc.legend := TextFlow(self).
         set_dominant_width(TextFlow.MAX_WIDTH)
      traverse(e, fc.legend, context)
   end

   private traverse_map(e, p, context)
      local c, mc
      mc := MapContext()
      mc.map := ipl.browser.Map()
      c := copy(context)
      c.map := mc
      traverse(e, p, c)
      insert(maps, map(string(e.get_attribute(u"NAME"))), mc.map)
   end

   private traverse_area(e, p, context)
      local mc, s, coords
      mc := \context.map | fail
      if s := e.get_attribute(u"COORDS") then {
         coords := []
         every put(coords, integer(separate(s)))
         mc.map.add_area(MapArea(map(string(e.get_attribute(u"SHAPE"))), 
                                 coords,
                                 mk_link(context.base, e.get_attribute(u"HREF"))))
      }
   end

   private traverse_text(e, p, context)
      put(p.input, TextCmd(e, context))
   end

   private traverse_title(e, p, context)
      page_title := e.get_trimmed_string_content()
   end

   private traverse(n, p, context)
      local e, id
      every e := !n.children do {
         if text(e) then
            traverse_text(e, p, context)
         else if is(e, HtmlElement) then {
            if id := e.get_attribute(u"ID") then
               put(p.input, NamedAnchorCmd(id))
            case string(e.name) of {
               "META"|"LINK"|"SCRIPT"|"STYLE": {}
               "TITLE": traverse_title(e, p, context)
               "A": traverse_a(e, p, context)
               "FORM": traverse_form(e, p, context)
               "BUTTON": traverse_button(e, p, context)
               "LABEL": traverse_label(e, p, context)
               "FONT": traverse_font(e, p, context)
               "IMG": traverse_img(e, p, context)
               "SELECT": traverse_select(e, p, context)
               "OPTION": traverse_option(e, p, context)
               "TEXTAREA": traverse_textarea(e, p, context)
               "INPUT": traverse_input(e, p, context)
               "DIV": traverse_div(e, p, context)
               "BIG": traverse_big(e, p, context)
               "SMALL": traverse_small(e, p, context)
               "SAMP"|"KBD"|"CODE"|"TT": traverse_tt(e, p, context)
               "DFN"|"B": traverse_b(e, p, context)
               "EM"|"CITE"|"I": traverse_i(e, p, context)
               "BR": traverse_br(e, p, context)
               "HR": traverse_hr(e, p, context)
               "CENTER": traverse_center(e, p, context)
               "H" || (1 to 6): traverse_hN(e, p, context)
               "TABLE": traverse_table(e, p, context)
               "CAPTION": traverse_caption(e, p, context)
               "TR": traverse_tr(e, p, context)
               "TD"|"TH": traverse_td(e, p, context)
               "DIR"|"MENU"|"OL"|"UL": traverse_list(e, p, context)
               "LI": traverse_li(e, p, context)
               "DL": traverse_dl(e, p, context)
               "DT": traverse_dt(e, p, context)
               "DD": traverse_dd(e, p, context)
               "BLOCKQUOTE": traverse_blockquote(e, p, context)
               "P": traverse_p(e, p, context)
               "Q": traverse_q(e, p, context)
               "INS"|"U": traverse_u(e, p, context)
               "DEL"|"STRIKE"|"S": traverse_s(e, p, context)
               "SUP": traverse_sup(e, p, context)
               "SUB": traverse_sub(e, p, context)
               "LISTING"|"PRE": traverse_pre(e, p, context)
               "FIELDSET": traverse_fieldset(e, p, context)
               "LEGEND": traverse_legend(e, p, context)
               "MAP": traverse_map(e, p, context)
               "AREA": traverse_area(e, p, context)
               default : traverse(e, p, context)
            }
         }
      }
   end

   public goto(url, referer, kind, form_data)
      cancel()
      start_worker(Req(url, referer, set_top_data, kind, form_data))
   end

   public set_cookies(cookies)
      self.cookies := cookies
      return self
   end

   #
   # Set the user-agent identification
   #
   public set_user_agent(s)
      self.user_agent := s
      return self
   end

   public set_log_http(s)
      self.log_http_flag := check_flag(s)
      return self
   end

   public new()
      cast(self,Component).new()
      self.cookies := table()
      self.cache := Cache(8*1024*1024)
      file_dialog := FileDialog()
      authentications := table()
      queue := []
      workers := []
      every 1 to 6 do
         put(workers, Worker(self))
      status_ticker := Dispatcher.new_task{status()}
      top_panel := ComponentScrollArea().
         set_inner(Component().set_size(10,10)).
         use_default_keys()
      set_layout(GridLayout().set_doi(0))
      add(top_panel)
      history := []
      history_pos := 0
      running := 0
      return
   end
end
