<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>gtrace.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     gtrace.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures to process graphic traces
<a name="6"/>#
<a name="7"/>#	Author:   Ralph E. Griswold
<a name="8"/>#
<a name="9"/>#	Date:     November 19, 1997
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#  As used here, the term "trace" refers to a sequence of points that
<a name="18"/>#  generally consists of locations on a curve or other geometrical object.
<a name="19"/>#  These procedures process such traces in various ways.
<a name="20"/>#
<a name="21"/>############################################################################
<a name="22"/>#
<a name="23"/>#  See also:  gtraces.doc
<a name="24"/>#
<a name="25"/>############################################################################
<a name="26"/>#
<a name="27"/>#  Links:  calls, numbers, gobject
<a name="28"/>#
<a name="29"/>############################################################################
<a name="30"/>
<a name="31"/>package ipl.gtrace
<a name="32"/>
<a name="33"/>import
<a name="34"/>   io(read, write),
<a name="35"/>   ipl.calls(invoke),
<a name="36"/>   ipl.gobject(Point),
<a name="37"/>   ipl.numbers(decipos)
<a name="38"/>
<a name="39"/>#  list_coords(call) lists the coordinates of the trace produced by
<a name="40"/>#  invoke(call)
<a name="41"/>
<a name="42"/>procedure list_coords(call, p, w)
<a name="43"/>   local point
<a name="44"/>
<a name="45"/>   /p := 6
<a name="46"/>   /w := 20
<a name="47"/>
<a name="48"/>   every point := invoke(call) do
<a name="49"/>      write(decipos(point.x, p, w), decipos(point.y, p, w))
<a name="50"/>
<a name="51"/>end
<a name="52"/>
<a name="53"/>#
<a name="54"/>#  point_list(call, i) returns a list of the points in the trace produced
<a name="55"/>#  by invoke(call).  If i is nonnull, the list is limited to i points.
<a name="56"/>
<a name="57"/>procedure point_list(call, i)
<a name="58"/>   local plist
<a name="59"/>
<a name="60"/>   plist := []
<a name="61"/>
<a name="62"/>   if \i then {
<a name="63"/>      every put(plist, invoke(call)) \ i
<a name="64"/>      }
<a name="65"/>   else {
<a name="66"/>      every put(plist, invoke(call))
<a name="67"/>      }
<a name="68"/>
<a name="69"/>   return plist
<a name="70"/>
<a name="71"/>end
<a name="72"/>
<a name="73"/>#
<a name="74"/>#  coord_list(call, i) returns a list of the x,y coordinates in the trace
<a name="75"/>#  produced by invoke(call).  If i is nonnull, the list is limited
<a name="76"/>#  to i points.
<a name="77"/>
<a name="78"/>procedure coord_list(call, limit)
<a name="79"/>   local clist
<a name="80"/>
<a name="81"/>   clist := []
<a name="82"/>
<a name="83"/>   if \limit then {
<a name="84"/>      every put(clist, !(invoke(call))) \ (limit * 2)
<a name="85"/>      }
<a name="86"/>   else {
<a name="87"/>      every put(clist, !(invoke(call)))
<a name="88"/>      }
<a name="89"/>
<a name="90"/>   return clist
<a name="91"/>
<a name="92"/>end
<a name="93"/>
<a name="94"/>#  read_trace(f) produces a trace from the coordinate file f
<a name="95"/>
<a name="96"/>procedure read_trace(f)
<a name="97"/>   local line
<a name="98"/>   static schar
<a name="99"/>
<a name="100"/>   initial schar := &amp;digits ++ '.'
<a name="101"/>
<a name="102"/>   while line := read(f) do
<a name="103"/>      line ? {
<a name="104"/>         suspend Point(
<a name="105"/>            tab(upto(schar)) &amp; tab(many(schar)),
<a name="106"/>            tab(upto(schar)) &amp; tab(many(schar))
<a name="107"/>            )
<a name="108"/>         }
<a name="109"/>
<a name="110"/>end
<a name="111"/>
<a name="112"/>#  write_trace(header, call) writes a trace file from the trace of call.
<a name="113"/>
<a name="114"/>procedure write_trace(header, call)
<a name="115"/>   local point
<a name="116"/>
<a name="117"/>   write(header, ":")
<a name="118"/>
<a name="119"/>   every point := invoke(call) do
<a name="120"/>      write(point.x, " ", point.y)
<a name="121"/>
<a name="122"/>end
<a name="123"/>
<a name="124"/>#  compose_trace(call_1, call_2) composes the trace for call_1 with the
<a name="125"/>#  trace for call_2; that is, the trace for call_1 is passed through
<a name="126"/>#  call_2.  For example, if call_1 traces a circle and call_2 draws a
<a name="127"/>#  star, the result is a star on each point of the circle.
<a name="128"/>#
<a name="129"/>#  The procedure assumes that the first two arguments to call_2 are
<a name="130"/>#  the x and y coordinates of the point in which it is interested
<a name="131"/>#  (standard trace format).
<a name="132"/>
<a name="133"/>procedure compose_trace(trace, call_1, call_2)
<a name="134"/>   local point
<a name="135"/>
<a name="136"/>   every point := invoke(call_1) do {
<a name="137"/>      call_2.args[1] := point.x		# set the origin for call_2
<a name="138"/>      call_2.args[2] := point.y
<a name="139"/>      suspend invoke(call_2)
<a name="140"/>      }
<a name="141"/>
<a name="142"/>end
<a name="143"/>
<a name="144"/>#  tcompress(call, i) discards all but the ith points on the trace
<a name="145"/>#  produced by call.  The first point of the trace is the first
<a name="146"/>#  point of the trace produced by calls.
<a name="147"/>
<a name="148"/>procedure tcompress(call, i)
<a name="149"/>   local j, point
<a name="150"/>
<a name="151"/>   j := 0
<a name="152"/>
<a name="153"/>   every point := invoke(call) do {
<a name="154"/>      if j % i = 0 then suspend point
<a name="155"/>      i +:= 1
<a name="156"/>      }
<a name="157"/>
<a name="158"/>end
<a name="159"/>
<a name="160"/>#  interp_call(call) inserts a point midway on a line between every two points
<a name="161"/>#  on the trace produced by call.
<a name="162"/>
<a name="163"/>procedure interp_trace(call)
<a name="164"/>   local point, last_point
<a name="165"/>
<a name="166"/>   every point := invoke(call) do {
<a name="167"/>      if \last_point then {
<a name="168"/>         suspend last_point
<a name="169"/>         suspend Point(
<a name="170"/>            (point.x - last_point.x) / 2,
<a name="171"/>            (point.y - last_point.y) / 2
<a name="172"/>            )
<a name="173"/>         }
<a name="174"/>      last_point := point
<a name="175"/>      }
<a name="176"/>
<a name="177"/>   suspend last_point
<a name="178"/>
<a name="179"/>end
<a name="180"/>
<a name="181"/>#  coord2point(cl) creates a list of points from a list of coordinates.
<a name="182"/>#  It destroys cl.
<a name="183"/>
<a name="184"/>procedure coord2point(cl)
<a name="185"/>   local pl
<a name="186"/>
<a name="187"/>   pl := []
<a name="188"/>
<a name="189"/>   while put(pl, Point(get(cl), get(cl)))
<a name="190"/>
<a name="191"/>   return pl
<a name="192"/>
<a name="193"/>end
<a name="194"/>
<a name="195"/>#  point2coord(pl) creates a list of coordinates from a list of points.
<a name="196"/>#  It does not destroy pl.
<a name="197"/>
<a name="198"/>procedure point2coord(pl)
<a name="199"/>   local cl
<a name="200"/>
<a name="201"/>   cl := []
<a name="202"/>
<a name="203"/>   every put(cl, !!pl)
<a name="204"/>
<a name="205"/>   return cl
<a name="206"/>
<a name="207"/>end
</pre></body></html>
