#
# $Id$
#

package datastruct

import ipl.pdco(Seq), lang

#
# This is a common superclass for several table-like data structures.
#
abstract class Table(ObjectOutput, ObjectHash, ObjectEquals)
   public const def

   #
   # Insert a new entry.  Always succeeds and returns {self}.
   #
   public abstract insert(key, val)

   #
   # Return the value for the given key (as a variable) if it is in
   # the table, or fail if it is not present.
   #
   public abstract member(key)

   #
   # Delete the entry with the given key.  Fails if the key was not
   # present, otherwise succeeds and returns {self}.
   #
   public abstract delete(key)

   #
   # Return the value with the given key, or the default value if
   # the key is not present.  Equivalent to {.t[k]} for a table.
   #
   public get(key)
      return .member(key) | def
   end

   #
   # Like {member}, but if the key is not present a new entry is added
   # (with the default value).  In any case a variable for the new
   # entry is returned.
   #
   # @example
   # @  # Word counting
   # @  t := SortTable(0)
   # @  every w := words() do
   # @     t.add(w) +:= 1
   #
   public add(key)
      return member(key) | (insert(key, def) & member(key))
   end

   #
   # Return a sorted list of key-value pairs.
   #
   public abstract sort()

   #
   # Generate the keys (cf the builtin key() function.)
   #
   public abstract key()

   #
   # Generate alternating key/values (cf the builtin keyval() function.)
   #
   public abstract keyval()

   #
   # Generate the keys (cf the builtin key() function.) in reverse
   # order.  Only implemented for tables which store their keys in
   # sorted order.
   #
   public defer back_key()

   #
   # Generate alternating key/values (cf the builtin keyval()
   # function.) in reverse order.  Only implemented for tables which
   # store their keys in sorted order.
   #
   public defer back_keyval()

   #
   # Generate the values (cf !t for a table).
   #
   public abstract gen()

   #
   # Return the size of the table.
   #
   public abstract size()

   #
   # Clear the table of all elements. Always succeeds and returns {self}.
   #
   public abstract clear()

   #
   # Generate key-value pairs as a sequence of 2-element lists.  NB - for each
   # invocation, the same list is returned every time, with the values replaced.
   #
   public entries()
      local l, e
      l := []
      every e := keyval() do {
         put(l, e)
         if *l = 2 then {
            suspend l
            default.clear(l)
         }
      }
   end

   # Return a flat list, with alternating key-value entries.
   public flatten()
      local l
      l := []
      every put(l, keyval())
      return l
   end

   # Return an (unsorted) list of pairs of key-values.
   public entry_list()
      local l, e, r
      r := []
      l := []
      every e := keyval() do {
         put(l, e)
         if *l = 2 then {
            put(r, l)
            l := []
         }
      }
      return r
   end

   #
   # Custom equals mirrors the {equals()} behaviour for builtin tables.
   #
   private object_equals(other, seen)
      other.size() = self.size() | fail
      equals(other.def, self.def, seen) | fail
      return hash_and_check(other.entry_list(), self.entry_list(), seen)
   end

   #
   # Custom hash mirrors the {hash()} behaviour for builtin tables.
   #
   private object_hash(depth)
      local n
      n := size()
      if depth > 1 then {
         n +:= hash(def, depth - 1)
         every n +:= hash(key(), depth - 1)
      }
      return n
   end

   #
   # Output object
   #
   private object_output(oo)
      local pairs, e, sep
      pairs := sort()
      if oo.simple{!!pairs | def} then {
         oo.object_start(self)
         if \def then {
            oo.writes1("default=").
               traverse(def)
            sep := 1
         }
         every e := !pairs do {
            if \sep then
               oo.writes1(";")
            oo.traverse(e[1]).
               writes1("->").
               traverse(e[2])
            sep := 1
         }
         oo.object_end(self)
      } else {
         oo.nl().
            object_start(self).
            iplus()
         if \def then {
            oo.nl().
               writes1("default=").
               iplus().
               traverse(def).
               iminus()
         }
         every e := !pairs do {
            oo.nl().
               traverse(e[1]).
               writes1("->").
               iplus().
               traverse(e[2]).
               iminus()
         }
         oo.iminus().
            nl().
            object_end(self)
      }
   end

   protected init_entries(entries)
      if *entries % 2 ~= 0 then
          runerr(134)
      while *entries > 0 do
         insert(default.get(entries), default.get(entries))
   end
end

#
# A {Table} that ignores case in its keys.
#
class ClTable(Table)
   private 
      t

   public insert(key, val)
      default.insert(t, map(key), [key, val])
      return self
   end

   public add(key)
      local mkey, e
      mkey := map(key)
      (e := default.member(t, mkey)) | default.insert(t, mkey, e := [key, def])
      return e[2]
   end

   public member(key)
      return default.member(t, map(key))[2]
   end

   public delete(key)
      return default.delete(t, map(key)) & self
   end

   public sort()
      local l
      l := []
      every put(l, (!default.sort(t))[2])
      return l
   end

   public key()
      suspend .(!t)[1]
   end

   public keyval()
      local e
      every e := !t do
         suspend .e[1] | e[2]
   end

   public gen()
      suspend (!t)[2]
   end

   public clear()
      default.clear(t)
      return self
   end

   public size()
      return *t
   end

   #
   # Create a new instance.
   #
   # @param def the default value
   # @param entries initial key-value entries.
   #
   public new(def, entries[])
      self.def := def
      t := table(def)
      init_entries(entries)
      return
   end
end

package class SortTableNode()
   public const key
   public val
   private l, r

   public insert(k, v, tbl)
      local i
      i := tbl.cmp(k, key)
      if i = 0 then {
         self.val := v
         return self
      } else if i < 0 then {
         if /l := SortTableNode(k, v) then {
            tbl.sz +:= 1
            return l
         } else
            return l.insert(k, v, tbl)
      } else {
         if /r := SortTableNode(k, v) then {
            tbl.sz +:= 1
            return r
         } else 
            return r.insert(k, v, tbl)
      }
   end

   public add(k, tbl)
      local i
      i := tbl.cmp(k, key)
      if i = 0 then
         return self
      else if i < 0 then {
         if /l := SortTableNode(k, tbl.def) then {
            tbl.sz +:= 1
            return l
         } else
            return l.add(k, tbl)
      } else {
         if /r := SortTableNode(k, tbl.def) then {
            tbl.sz +:= 1
            return r
         } else 
            return r.add(k, tbl)
      }
   end

   public member(k, tbl)
      local i
      i := tbl.cmp(k, key)
      return if i = 0 then
         self
      else if i < 0 then
         (\l).member(k, tbl)
      else
         (\r).member(k, tbl)
   end

   public delete(k, tbl)
      local i
      i := tbl.cmp(k, key)
      if i = 0 then {
         tbl.sz -:= 1
         if /l then
            return r
         if /r then
            return l
         # Make l the left child of the smallest node in r.
         Seq{r.traverse()}.l := l
         return r
      } else if i < 0 then {
         \l := l.delete(k, tbl)
         return self
      } else {
         \r := r.delete(k, tbl)
         return self
      }
   end

   public traverse()
      (\l).traverse()
      coact(self)
      (\r).traverse()
   end

   public back_traverse()
      (\r).back_traverse()
      coact(self)
      (\l).back_traverse()
   end

   public new(k, v)
      self.key := k
      self.val := v
      return
   end
end

#
# A {Table} which uses a binary tree so that its members are always
# in sorted order.
#
class SortTable(Table)
   private root
   public const cmp
   package readable sz

   public insert(key, val)
      if /root := SortTableNode(key, val) then
         sz := 1
      else
         root.insert(key, val, self)
      return self
   end

   public add(key)
      if /root := SortTableNode(key, def) then {
         sz := 1
         return root.val
      } else
         return root.add(key, self).val
   end

   public member(key)
      return (\root).member(key, self).val
   end

   public delete(key)
      local t
      t := sz
      \root := root.delete(key, self)
      if sz < t then
         return self
   end

   public sort()
      local e, l
      l := []
      every e := Seq{(\root).traverse()} do
         put(l, [e.key, e.val])
      return l
   end

   public key()
      suspend Seq{(\root).traverse()}.key
   end

   public keyval()
      local e
      every e := Seq{(\root).traverse()} do
         suspend e.key | e.val
   end

   public back_key()
      suspend Seq{(\root).back_traverse()}.key
   end

   public back_keyval()
      local e
      every e := Seq{(\root).back_traverse()} do
         suspend e.key | e.val
   end

   public gen()
      suspend Seq{(\root).traverse()}.val
   end

   public clear()
      root := &null
      sz := 0
      return self
   end

   public size()
      return .sz
   end

   #
   # Create a new instance.
   #
   # @param def the default value
   # @param cmp a comparator function taking two arbitrary values and
   # @   returning {-1}, {0} or {+1} by way of comparison.  The default
   # @   value is {Internal.compare}.
   # @param entries initial key-value entries.
   #
   public new(def, cmp, entries[])
      self.def := def
      /cmp := Internal.compare
      self.cmp := cmp
      self.sz := 0
      init_entries(entries)
      return
   end
end

#
# A {Table} which uses the {lang.equals} procedure for key comparison,
# rather than the builtin {===} operator.
#
class EqTable(Table)
   private t, sz

   public insert(key, val)
      local h, l, e, n
      h := hash(key)
      l := t[h]
      every e := !\l do {
         if equals(e[1], key) then {
            e[2] := val
            return self
         }
      }
      n := [key, val]
      if \l then
         put(l, n)
      else
         default.insert(t, h, [n])
      sz +:= 1
      return self
   end

   public add(key)
      local h, l, e, n
      h := hash(key)
      l := t[h]
      every e := !\l do {
         if equals(e[1], key) then
            return e[2]
      }
      n := [key, def]
      if \l then
         put(l, n)
      else
         default.insert(t, h, [n])
      sz +:= 1
      return n[2]
   end

   public member(key)
      local e
      every e := !\t[hash(key)] do {
         if equals(e[1], key) then
            return e[2]
      }
   end

   public delete(key)
      local h, l, e, i
      h := hash(key)
      l := t[h]
      i := 1
      every e := !\l do {
         if equals(e[1], key) then {
            default.delete(l, i)
            if *l = 0 then
               default.delete(t, h)
            sz -:= 1
            return self
         }
         i +:= 1
      }
   end

   public sort()
      local l
      l := []
      every put(l, copy(!!t))
      return default.sortf(l, 1)
   end

   public key()
      suspend .(!!t)[1]
   end

   public keyval()
      local e
      every e := !!t do
         suspend .e[1] | e[2]
   end

   public gen()
      suspend (!!t)[2]
   end

   public size()
      return .sz
   end

   public clear()
      default.clear(t)
      sz := 0
      return self
   end

   #
   # Create a new instance.
   #
   # @param def the default value
   # @param entries initial key-value entries.
   #
   public new(def, entries[])
      self.def := def
      t := table()
      sz := 0
      init_entries(entries)
      return
   end
end

#
# A {Table} which is just a wrapper around a builtin table.
#
class BuiltinTable(Table)
   private t

   public insert(key, val)
      default.insert(t, key, val)
      return self
   end

   public member(key)
      return default.member(t, key)
   end

   public delete(key)
      return default.delete(t, key) & self
   end

   public sort()
      return default.sort(t)
   end

   public key()
      suspend default.key(t)
   end

   public keyval()
      suspend default.keyval(t)
   end

   public gen()
      suspend !t
   end

   public clear()
      default.clear(t)
      return self
   end

   public size()
      return *t
   end

   #
   # Create a new instance.
   #
   # @param t the table to wrap; if omitted then a new table is
   # @     created.
   #
   public new(t)
      /t := table()
      self.t := t
      self.def := t[[]]
      return
   end
end

#
# A {Table} which uses weak references
#
class WeakrefTable(Table)
   private 
      t, sz, last_purge

   public insert(key, val)
      local h, l, e, n
      maybe_purge()
      h := Internal.hash(key)
      l := t[h]
      every e := !\l do {
         if weakrefval(e[1]) === key then {
            e[2] := val
            return self
         }
      }
      n := [weakref(key), val] | runerr("Type of key cannot be used with weakref")
      if \l then
         put(l, n)
      else
         default.insert(t, h, [n])
      sz +:= 1
      return self
   end

   public add(key)
      local h, l, e, n
      maybe_purge()
      h := Internal.hash(key)
      l := t[h]
      every e := !\l do {
         if weakrefval(e[1]) === key then
            return e[2]
      }
      n := [weakref(key), def] | runerr("Type of key cannot be used with weakref")
      if \l then
         put(l, n)
      else
         default.insert(t, h, [n])
      sz +:= 1
      return n[2]
   end

   public member(key)
      local e
      maybe_purge()
      every e := !\t[Internal.hash(key)] do {
         if weakrefval(e[1]) === key then
            return e[2]
      }
   end

   public delete(key)
      local h, l, e, i
      maybe_purge()
      h := Internal.hash(key)
      l := t[h]
      i := 1
      every e := !\l do {
         if weakrefval(e[1]) === key then {
            default.delete(l, i)
            if *l = 0 then
               default.delete(t, h)
            sz -:= 1
            return self
         }
         i +:= 1
      }
   end

   public sort()
      local e, x
      maybe_purge()
      x := table()
      every e := !!t do
         default.insert(x, weakrefval(e[1]), e[2])
      return default.sort(x)
   end

   public key()
      maybe_purge()
      suspend weakrefval((!!t)[1])
   end

   public keyval()
      local e
      maybe_purge()
      every e := !!t do
         suspend weakrefval(e[1]) | e[2]
   end

   public gen()
      maybe_purge()
      suspend (!!t)[2]
   end

   public clear()
      default.clear(t)
      sz := 0
      return self
   end

   public size()
      maybe_purge()
      return .sz
   end

   public maybe_purge()
      if last_purge ~=== Prog.get_global_collection_count() then {
         last_purge := Prog.get_global_collection_count()
         purge()
      }
   end

   private purge()
      local h, l, i
      every h := default.key(t) do {
         l := t[h]
         i := 1
         while i <= *l do {
            if weakrefval(l[i][1]) then
               i +:= 1
            else {
               default.delete(l, i)
               sz -:= 1
            }
         }
         if *l = 0 then
            default.delete(t, h)
      }
   end

   #
   # Create a new instance.
   #
   # @param def the default value
   # @param entries initial key-value entries.
   #
   public new(def, entries[])
      self.def := def
      self.t := table()
      self.sz := 0
      init_entries(entries)
      return
   end
end
