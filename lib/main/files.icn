package util

import 
   ipl.random

#
# This class has several static methods which provide
# system-independent access to the file system.
#
class Files()
   private static const FS

   private static init()
      FS := 
         if has_feature("MS Windows NT" | "MS-DOS") then 
            WindowsFileSystem()
         else if has_feature("UNIX" | "PLAN9") then
            UnixFileSystem()
         else
            stop("Can't init_file_system: unknown o/s type")
   end

   #
   # Read the given directory returning a list of {DirEntry} objects.
   #
   public static list(s)
      return FS.list(s)
   end

   #
   # Return a {FilePath} corresponding to the given path in string
   # form.
   #
   public static get_path(s)
      return FS.get_path(s)
   end

   #
   # Return a {FilePath} corresponding to the elements in the given
   # list.
   #
   public static get_path_from_list(l)
      return FS.get_path_from_list(copy(l))
   end

   #
   # Return the home directory.
   #
   public static get_home()
      return FS.get_home()
   end

   #
   # Return the temporary directory.
   #
   public static get_temp()
      return FS.get_temp()
   end

   #
   # Succeed iff the given file is hidden.
   #
   public static is_hidden(s)
      return FS.is_hidden(s)
   end

   #
   # Succeed iff the given file is a relative directory name (on Unix,
   # "." or "..").
   #
   public static is_relative_dir(s)
      return FS.is_relative_dir(s)
   end

   #
   # Get the roots of the file system.
   #
   public static get_roots()
      suspend FS.get_roots()
   end

   #
   # Split a list of paths (such as the $PATH variable) into its
   # constituent elements.
   #
   public static split_paths(s)
      suspend FS.split_paths(s)
   end

   #
   # Return the error reason for calls delegated to the
   # system-specific FileSystem instance.
   #
   public static get_reason()
      return FS.get_reason()
   end

   #
   # Load a file into a string, failing if the file doesn't exist.
   #
   public static file_to_string(fn)
      local res, f
      f := open(fn, "ru") | fail
      res := ""
      while res ||:= reads(f, 8192)
      close(f)
      return res
   end

   #
   # Write a string to a file.
   #
   public static string_to_file(fn, s)
      local f
      f := open(fn, "wu") | fail
      writes(f, s)
      close(f)
      return s
   end

   #
   # Make a temporary filename.
   # @param prefix, by default empty
   # @param suffix, by default empty
   # @param path, the directory, by default {get_temp()}
   # @param len, the number of digits in the result, default 8
   #
   public static make_temp_filename(prefix, suffix, path, len)
      local p, name

      /prefix := ""
      /suffix := ""
      /path := get_temp()
      /len := 8

      randomize()

      p := get_path(path)
      repeat {
         ?1                                # change &random
         name := p.child(prefix || left(&random, len, "0") || suffix).str()
         if not open(name) then {
            # Touch the filename to stop anyone else using it.
            close(open(name, "w"))
            return name
         }
      }
   end

   #
   # Succeed iff the two given files have the same content.
   #
   public static equal_files(n1, n2)
      local f1, f2, r

      stat(n1).size = stat(n2).size | fail

      f1 := open(n1, "ru") | fail
      f2 := open(n2, "ru") | {
         close(f1)
         fail
      }

      if equal_files1(f1, f2) then
         r := 1

      close(f1)
      close(f2)

      return \r
   end

   private static equal_files1(f1, f2)
      local s1, s2

      while s1 := reads(f1, 8192) do {
         s2 := reads(f2, 8192) | fail
         s1 == s2 | fail
      }
      
      return not(reads(f2))
   end

   #
   # Succeed iff the given file is a directory.
   #
   public static is_directory(s)
      return stat(s).mode[1] == "d"
   end

   #
   # Rename a file.  If that fails, try to copy the file then delete
   # the original, or if that fails, fail.
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static rename_file(s1, s2)
      if rename(s1, s2) then
         return
      copy_file(s1, s2) | fail
      remove(s1)
      return
   end

   #
   # Copy a file.
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static copy_file(s1, s2)
      local f1, f2
      f1 := open(s1, "ru") | fail
      f2 := open(s2, "wu") | {
         close(f1)
         fail
      }
      # The writes will give a runtime error 214 on failure (eg device full).
      while writes(f2, reads(f1, 8192))
      close(f1)
      close(f2)
      return
   end

   #
   # Append file {s1} onto {s2}.
   # @param s1 the source filename
   # @param s2 the target filename
   #
   public static append_file(s1, s2)
      local f1, f2
      f1 := open(s1, "ru") | fail
      f2 := open(s2, "au") | {
         close(f1)
         fail
      }
      # The writes will give a runtime error 214 on failure (eg device full).
      while writes(f2, reads(f1, 8192))
      close(f1)
      close(f2)
      return
   end

   #
   # Given a stem filename, return another unique filename based upon it.
   #
   public static ensure_unique_filename(stem)
      local i, p, s
      stat(stem) | return stem
      i := 1
      every p := find(".", stem)
      repeat {
         s := stem
         if /p then
            s ||:= "_" || i
         else
            s[p] := "_" || i || s[p]
         stat(s) | return s
         i +:= 1
      }
   end

   #
   # This procedure searches for a file on a environment-defined path.
   # It follows the same logic as the C function pathfind() in
   # mlocal.c
   #
   # @param f the file to look for
   # @param n the name of the environment variable holding the path
   #
   public static path_find(f, n)
      local p, s

      # First of all see if it exists without any search
      if stat(f) then
         return f

      p := get_path(f)
      # We never append absolute paths to the search path
      if p.is_absolute() then
         fail

      # Search all the elements in the path
      every s := get_path(split_paths(getenv(n))).append(p).str() do {
         if stat(s) then
            return s
      }
   end
end

#
# This class provides implementations of some of the methods in
# {Files}.  It is not used directly by clients.
#
class FileSystem(Error)
   public defer list(s)

   public defer get_path(s)

   public defer get_path_from_list(l)

   public defer get_home()

   public defer get_temp()

   public defer is_hidden(s)

   public defer is_relative_dir(s)

   public defer get_roots()

   public defer split_paths(s)
end

#
# This class manipulates file paths by treating them as a list of
# elements.  Instances are not created directly by the client, rather
# they are created initially via {Files.get_path()} and then via other
# methods in this class.
#
# Instances of this class are immutable.
#
class FilePath()
   protected l

   #
   # Return the number of elements in the path.
   #
   public size()
      return *l
   end

   #
   # Return the {i}th element in the path.
   #
   public get(i)
      return .l[i]
   end

   #
   # Generate the elements in the path.
   #
   public gen()
      suspend .!l
   end

   #
   # Return the path formed by appending the elements of this path to
   # the other path.
   #
   public append(other)
      return classof(self)(l ||| other.l)
   end

   #
   # Return the parent path, ie a path with everything but the last
   # element.  Fails if the path has no elements.
   #
   public parent()
      return classof(self)(l[1:-1])
   end

   #
   # Return the child path, ie a path with the same elements plus the
   # element {s}.
   #
   public child(s)
      return classof(self)(l ||| [s])
   end

   #
   # Return a path which represents the absolute path of this
   # path.
   #
   public defer absolute()

   #
   # Convert the path back into a string.
   #
   public defer str()

   #
   # Succeed iff this path represents an absolute path.
   #
   public defer is_absolute()

   #
   # Canonicalize a path, which means trying to turn it into a
   # standard form.  This involves (at least) getting the absolute
   # path and removing any redundant path elements.
   #
   public defer canonical()

   package new(l)
      self.l := l
      return
   end
end

#
# This class represents an entry in a directory listing.
#
class DirEntry()
   public const 
      name, 
      dev,
      ino,
      mode,
      nlink,
      uid,
      gid,
      rdev,
      size,
      atime,
      mtime,
      ctime,
      blksize,
      blocks,
      symlink

   package new(name, ps)
      self.name := name
      self.dev := ps[1]
      self.ino := ps[2]
      self.mode := ps[3]
      self.nlink := ps[4]
      self.uid := ps[5]
      self.gid := ps[6]
      self.rdev := ps[7]
      self.size := ps[8]
      self.atime := ps[9]
      self.mtime := ps[10]
      self.ctime := ps[11]
      self.blksize := ps[12]
      self.blocks := ps[13]
      self.symlink := ps[14]
      return
   end
end

class UnixFilePath(FilePath)
   public str()
      local e, s
      s := ""
      every e := !l do {
         if s[-1] ~== "/" then 
            s ||:= "/"
         s ||:= e
      }
      return s
   end

   public is_absolute()
      return l[1] == "/"
   end

   public absolute()
      if is_absolute() then
         return self
      return Files.get_path(chdir()).append(self)
   end

   public canonical()
      local e, r
      r := []
      every e := !absolute().l do {
         if e == "." then
            next
         else if e == ".." then {
            # /.. -> /
            if r[-1] ~== "/" then
               pull(r)
         } else
            put(r, e)
      }
      return UnixFilePath(r)
   end
end

class UnixFileSystem(FileSystem)
   public list(s)
      local l, p, s2, sr
      if (*s > 1) & (s[-1] == "/") then 
         s[-1] := ""
      p := open(s) | return error("Can't open " || image(s))
      if s[-1] ~== "/" then 
         s ||:= "/"
      l := []
      while s2 := read(p) do {
         sr := stat(s || s2) | {
            close(p)
            return error("Can't stat " || image(s || s2) || ":" || errno_str())
         }
         put(l, DirEntry(s2, sr))
      }
      close(p)
      return l
   end

   public get_path(s)
      local l, t
      l := []
      s ? {
         put(l, ="/")
         while not pos(0) do {
            t := tab(upto('/') | 0)
            if *t > 0 then
               put(l, t)
            move(1)
         }
      }
      return UnixFilePath(l)
   end

   public get_path_from_list(l)
      return UnixFilePath(l)
   end

   public get_home()
      return getenv("HOME")
   end

   public get_temp()
      return getenv("TEMP") | "/tmp"
   end

   public is_hidden(s)
      return any('.', s)
   end

   public is_relative_dir(s)
      return s == ("." | "..")
   end

   public get_roots()
      return "/"
   end

   public split_paths(s)
      local t
      s ? repeat {
         t := tab(upto(':') | 0)
         if *t = 0 then
            t := "."
         suspend t
         if pos(0) then
            break
         move(1)
      }
   end
end

class WindowsFilePath(FilePath)
   public str()
      local e, s
      s := ""
      every e := !l do {
         if *s > 0 & not any("\\:", s[-1]) then
            s ||:= "\\"
         s ||:= e
      }
      return s
   end

   public is_absolute()
      return l[1] == "\\\\" | l[1][2:0] == ":\\"
   end

   public absolute()
      local s
      if is_absolute() then
         return self
      if l[1] == "\\" then
         return WindowsFilePath([chdir()[1:4]] ||| l[2:0])
      if l[1][2:0] == ":" then {
         s := getdcwd(l[1][1]) | l[1] || "\\"
         return Files.get_path(s).append(WindowsFilePath(l[2:0]))
      }
      return Files.get_path(chdir()).append(self)
   end

   private static defer getdcwd(d)

   public canonical()
      local e, r
      r := []
      every e := !absolute().l do {
         if e == "." then
            next
         else if e == ".." then
            pull(r)
         else
            put(r, map(e))
      }
      return WindowsFilePath(r)
   end
end

class WindowsFileSystem(FileSystem)
   #
   # Read a directory.
   #
   public list(s)
      local l, p, s2, sr
      s := map(s, "/", "\\")
      if s[2:4] == ":\\" then {
         if *s > 3 & s[-1] == "\\" then
            s[-1] := ""
      } else {
         if *s > 1 & s[-1] == "\\" then
            s[-1] := ""
      }
      p := open(s) | return error("Can't open " || image(s))
      if s[-1] ~== "\\" then 
         s ||:= "\\"
      l := []
      while s2 := read(p) do {
         sr := stat(s || s2) | {
            close(p)
            return error("Can't stat " || image(s || s2) || ":" || errno_str())
         }
         put(l, DirEntry(s2, sr))
      }
      close(p)
      return l
   end

   public get_path(s)
      local l, t
      l := []
      s := map(s, "/", "\\")
      s ? {
         if &subject[2:4] == ":\\" then       # X:\
            put(l, move(3))
         else if &subject[2] == ":" then      # X:
            put(l, move(2))
         else if &subject[1:3] == "\\\\" then # \\X
            put(l, move(2))
         else if &subject[1] == "\\" then     # \X
            put(l, move(1))                
         while not pos(0) do {
            t := tab(upto('\\') | 0)
            if *t > 0 then
               put(l, t)
            move(1)
         }
      }
      return WindowsFilePath(l)
   end

   public get_path_from_list(l)
      return WindowsFilePath(l)
   end

   public get_home()
      return getenv("HOME")
   end

   public get_temp()
      return getenv("TEMP") | "C:\\TEMP"
   end

   public is_hidden(s)
   end

   public is_relative_dir(s)
      return s == ("." | "..")
   end

   public defer get_roots()

   public split_paths(s)
      local t
      s ? repeat {
         t := tab(upto(';') | 0)
         if *t = 0 then
            t := "."
         suspend t
         if pos(0) then
            break
         move(1)
      }
   end
end
