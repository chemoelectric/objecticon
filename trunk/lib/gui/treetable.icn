#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

#
# A node in a {TreeTable}.  It provides the column data
# for the extra (non-tree) columns.  For example if
# the TreeTable's columns were named A, B, C, then a
# {TreeTableNode} might be created as follows :-
#
# @example
# @ n := TreeTableNode("label=Col A label")
# @ n.set_contents(["Col B data", "Col C data"])
#
class TreeTableNode(TreeNode)
   public contents

   #
   # Set the column data to fill the columns 2 onwards.
   #
   public set_contents(l)
      self.contents := l
   end

   public set_one(f)
      case f.attr of {
         "contents" : set_contents(f.list_val())
         default: return cast(self,TreeNode).set_one(f)
      }
      return
   end
end


#
# This class provides the table content for a TreeTable.  It extends
# Tree, and uses that class's methods for event handling and drawing
# of the first column.
#
class TreeTableContent(Tree)
   public calculate_line_height()
      local t, m, h, r, e, i, j, cols
      t := []
      m := 0
      cols := parent.table_header.children
      every j := 1 to *cols do {
         h := if j = 1 then
            cast(self,Tree).calculate_line_height()
         else
            cols[j].calculate_line_height(self.cbwin)
         if integer(h) then
            m <:= h
         else
            put(t, h)
      }
      #
      # Easy case, all columns report fixed row heights, so the row height for the
      # table is the maximum.
      if *t = 0 then
         return m

      r := list(*t[1], m)
      every e := !t do {
         *e = *r | syserr("Inconsistent table column row height list sizes returned")
         every i := 1 to *r do
            r[i] <:= e[i]
      }

      return r
   end

   public slice(col)
      suspend (\(!contents).contents)[col - 1]
   end

   public get_cell(row, col)
      return (\contents[row].contents)[col - 1]
   end

   public calculate_subject_width()
      return parent.get_total_column_width()
   end

   public on_hsb()
      cast(self,Tree).on_hsb()
      synch_header()
   end

   public handle_key_right(e)
      cast(self,Tree).handle_key_right(e)
      synch_header()
   end

   public handle_key_left(e)
      cast(self,Tree).handle_key_left(e)
      synch_header()
   end

   # Synch buttons because of the horizontal movement.
   public synch_header()
      parent.table_header.layout()
      parent.table_header.invalidate()
   end

   public get_column(n)
      return parent.table_header.children[n]
   end

   public draw_line(xp, yp, lh, i, r, selection_cw, cursor_cw, highlight_cw)
      local j, cols, clip_x, clip_w, col, N
      N := self.contents[i]
      cols := parent.table_header.children
      every j := 1 to *cols do {
         col := cols[j]
         # Clip on the cell
         clip_x := max(col.x, r.x)
         clip_w := min(col.x + col.w, r.x + r.w) - clip_x
         if clip_w > 0 then {
            view.cbwin.clip(clip_x, self.view.y, clip_w, self.view.h)
            if j = 1 then
               cast(self,Tree).draw_line(xp, yp, lh, i, r)
            else
               col.draw_cell(view.cbwin, (\N.contents)[j - 1], i, j, yp, lh)
         }
      }
      view.cbwin.clip(r.x, r.y, r.w, r.h)

      if \selection_cw then
         selection_cw.fill_rectangle(self.view.x, yp, self.view.w, lh)

      if \cursor_cw then 
         rectangle(cursor_cw, self.view.x, yp, self.view.w, lh)

      if \highlight_cw then
         rectangle(highlight_cw, self.view.x, yp, self.view.w, lh)
   end
end


#
# A {TreeTable} is a {Table} where the first column is
# a Tree.  The data for the component is provided as
# a tree of {TreeTableNode}s.
#
# See the example program ttexplorer.icn for one in use.
#
class TreeTable(Table)
   public create_table_content()
      return TreeTableContent()
   end
end

