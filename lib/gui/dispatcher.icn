#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

import graphics, io

#
#
# This class handles Icon events, dispatching them to
# the appropriate dialog.  It also controls any active Tasks,
# activating them between events as and when appropriate.
#
final abstract class Dispatcher()
   public static const 
      dialogs,
      scheduler

   private static const
      BLOCKED_ALLOW,
      BLOCKED_QUIET,
      REPEATING

   private static init()
      BLOCKED_ALLOW := Selection.EVENTS ++ set(Window.INVOKE_LATER, 
                                               Window.RESIZE, Window.STATE, Window.MOVE)
      BLOCKED_QUIET := set(Mouse.RELEASE, Mouse.MOVEMENT) ++ Mouse.CROSSING
      REPEATING := Mouse.DRAG_OR_MOVEMENT ++ set(Window.RESIZE)
      dialogs := set()
      scheduler := Scheduler(Gui.IDLE_SLEEP)
   end

   #
   # Add a dialog
   #
   public static add_dialog(d)
      insert(dialogs, d)
      return Dispatcher
   end

   #
   # Delete a dialog
   #
   public static remove_dialog(d)
      delete(dialogs, d)
      return Dispatcher
   end

   #
   # Try to do some work, succeeding if something was done, failing if it wasn't.
   #
   public static work()
      return do_event() | do_validate() | do_scheduler()
   end

   #
   # Loop until dialog r is closed processing events and {Task}s.  If r
   # is omitted, then loop until there are no open dialogs.
   #
   public static message_loop(r)
      if /r then {
         while *dialogs > 0 do
            work_or_sleep()
      } else {
         while \r.win do
            work_or_sleep()
      }
   end

   # This is similar to the normal {message_loop} method, but instead
   # of returning only when there are no dialogs open, this method
   # will also return when it first finds it has no work to do,
   # allowing the caller to undertake some activity before calling it
   # again.  When using this method, it is best to configure the
   # {Dispatcher}'s scheduler so that it does not sleep in poll, by
   # setting its poll timeout to 0.  This prevents {work} from ever
   # sleeping.
   #
   public static service(r)
      if /r then {
         while *dialogs > 0 do
            work() | break
      } else {
         while \r.win do
            work() | break
      }
   end

   #
   # A further variant of the message loop which never returns.  Even
   # when there are no dialogs open, {Task}s continue to be activated.
   #
   public static message_loop_forever()
      repeat
         work_or_sleep()
   end

   #
   # Convenient method to call work(), and if no work is done, to
   # sleep for the idle period.
   #
   public static work_or_sleep()
      work() | delay(Gui.IDLE_SLEEP)
   end

   public static do_event()
      local d, bag, l
      every d := !dialogs do {
         l := d.win.pending()
         if *l > 0 then {
            /bag := []
            if /d.is_blocked_flag then
               put(bag, d)
            else {
               # Consume all blocked events, or until a BLOCKED_ALLOW
               # event is encountered.
               while *l > 0 do {
                  if member(BLOCKED_ALLOW, l[1]) then {
                     put(bag, d)
                     break
                  }
                  # Discard and maybe beep in the window.
                  member(BLOCKED_QUIET, l[1]) | d.win.alert()
                  d.win.event()
               }
            }
         }
      }
      if d := ?\bag then {
         l := d.win.event()
         # Discard unwanted repeating events.
         if member(REPEATING, l[1]) then {
            while d.win.pending()[1] === l[1] do
               l := d.win.event()
         }
         d.process_event(l)
         return
      }
   end

   public static do_validate()
      local d, bag
      every d := !dialogs do {
         if d.needs_validate() then {
            /bag := []
            put(bag, d)
         }
      }
      if d := ?\bag then {
         d.validate()
         return
      }
   end

   public static do_scheduler()
      return scheduler.work()
   end

   #
   # Return a list of unblocked dialogs.
   #
   public static list_unblocked()
      local d, res

      res := []
      every d := !dialogs do
         if /d.is_blocked_flag then
            put(res, d)

      return res
   end

   #
   # Generate any (unblocked) dialogs which are instances of
   # the given class.  If the parameter is omitted, all unblocked
   # dialogs are generated.
   #
   public static find_dialog(cl)
      local d
      every d := !dialogs do {
         if /d.is_blocked_flag & 
            (/cl | is(d, cl)) then
             suspend d
      }
   end

   public static new_task(e, v)
      return Task(scheduler, e, v)
   end

   public static get_curr_task()
      return \scheduler.curr_task
   end
end
