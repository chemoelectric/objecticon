package ipl.streams

import
   io(FileOpt, FileStream, GeneratorStream, HasUnderlyingStream, stop),
   ipl.strings(replace)


#
# This {Stream} takes a list of other {Stream}s.  Their lines of
# output are interspersed together to form the output.
#
class IntersperseStream(GeneratorStream, HasUnderlyingStream)
   private
      a

   protected gen()
      local e, s, t, u
      u := a
      while *u > 0 do {
         t := []
         every e := !u do {
            s := e.read_line() | fail
            if \s then {
               put(t, e)
               suspend s
            }
         }
         u := t
      }
      return
   end

   public close()
      local e, f
      if \close_underlying_flag then {
         every e := !a do
            e.close() | (f := 1)
      }
      return /f
   end

   public new(a[])
      self.a := a
      return cast(self,GeneratorStream).new()
   end
end

#
# Return a writable file to /dev/null.  The returned file is shared
# and so should not be closed.
#
procedure get_null()
   static nul
   initial
      nul := FileStream.open("/dev/null", FileOpt.WRONLY) | stop("Can't open /dev/null: ", &why)
   return nul
end

#
# Trim the output from a command's stderr, making it suitable for
# assigning to &why.
#
procedure trim_stderr(s)
   return trim(replace(s, "\n", " "))
end
