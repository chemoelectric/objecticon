#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

#
# A node in a {TreeTable}.  It provides the column data
# for the extra (non-tree) columns.  For example if
# the TreeTable's columns were named A, B, C, then a
# {TreeTableNode} might be created as follows :-
#
# @example
# @ n := TreeTableNode("label=Col A label")
# @ n.set_contents(["Col B data", "Col C data"])
#
# @field contents=list: see {set_contents}
# @field see also {TreeNode}
#
class TreeTableNode(TreeNode)
   public contents

   #
   # Set the column data to fill the columns 2 onwards.
   #
   public set_contents(l)
      self.contents := l
      return self
   end

   public set_one(f)
      case f.attr of {
         "contents" : set_contents(f.list_val())
         default: return cast(self,TreeNode).set_one(f)
      }
      return
   end
end


#
# This class provides the table content for a TreeTable.  It extends
# Tree, and uses that class's methods for event handling and drawing
# of the first column.
#
class TreeTableContent(Tree)
   public calculate_line_height()
      local t, m, h, r, e, i, j, cols
      t := []
      m := 0
      cols := parent.table_header.children
      every j := 1 to *cols do {
         h := if j = 1 then
            cast(self,Tree).calculate_line_height()
         else
            cols[j].calculate_line_height(self.cbwin)
         if integer(h) then
            m <:= h
         else
            put(t, h)
      }
      #
      # Easy case, all columns report fixed row heights, so the row height for the
      # table is the maximum.
      if *t = 0 then
         return m

      r := list(*t[1], m)
      every e := !t do {
         *e = *r | syserr("Inconsistent table column row height list sizes returned")
         every i := 1 to *r do
            r[i] <:= e[i]
      }

      return r
   end

   public slice(col)
      suspend (\(!contents).contents)[col - 1]
   end

   public get_cell(row, col)
      return (\contents[row].contents)[col - 1]
   end

   public calculate_subject_width()
      return parent.get_total_column_width()
   end

   public on_hsb()
      cast(self,Tree).on_hsb()
      synch_header()
   end

   public handle_key_right(e)
      cast(self,Tree).handle_key_right(e)
      synch_header()
   end

   public handle_key_left(e)
      cast(self,Tree).handle_key_left(e)
      synch_header()
   end

   # Synch buttons because of the horizontal movement.
   public synch_header()
      parent.table_header.layout()
      parent.table_header.invalidate()
   end

   public get_column(n)
      return parent.table_header.children[n]
   end

   public draw()
      local xp, yp, i, j, info, h, lh, r, cols, col, cc

      r := view.get_cbwin_clip()

      info := get_line_info(r) | fail
      h := get_line_height()

      cols := parent.table_header.children
      every j := 1 to *cols do {
         col := cols[j]
         # If the column is visible
         if cc := view.cbwin.drawable(col.x, r.y, col.w, r.h) then {
            # Clip on the column.
            view.cbwin.clip!cc
            yp := r.y - info.offset
            xp := view.x - get_area_x()
            # Write each line in this column
            every i := info.first to info.last do {
               lh := integer(h) | h[i]
               if j = 1 then
                  cast(self,Tree).draw_line(xp, yp, lh, i)
               else
                  col.draw_cell(view.cbwin, 
                                (\self.contents[i].contents)[j - 1], i, j, yp, lh)
               yp +:= lh
            }
            # Reset the clip.
            view.cbwin.clip(r.x, r.y, r.w, r.h)
         }
      }
      # Call the superclass draw to do the selection, highlight etc.
      cast(self,SelectableScrollArea).draw()
   end

   # Re-override draw_line so that call to SelectableScrollArea.draw() above draws
   # the selections etc (rather than displaying the tree column again).
   public draw_line(xp, yp, lh, i, sel, cur)
      draw_line_sel_cur(self.view.x, yp, self.view.w, lh, sel, cur)
   end
end


#
# A {TreeTable} is a {Table} where the first column is
# a Tree.  The data for the component is provided as
# a tree of {TreeTableNode}s.
#
# See the example program ttexplorer.icn for one in use.
#
class TreeTable(Table)
   public create_table_content()
      return TreeTableContent()
   end
end

