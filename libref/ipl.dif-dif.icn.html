<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>dif.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     dif.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedure to check for differences
<a name="6"/>#
<a name="7"/>#	Author:   Robert J. Alexander
<a name="8"/>#
<a name="9"/>#	Date:     August 14, 1996
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#	dif(stream, compare, eof, group)
<a name="18"/>#		generates a sequence of differences between an	arbitrary
<a name="19"/>#		number of input streams.  Each result is returned as a list
<a name="20"/>#		of diff_recs, one for each input stream, with each diff_rec
<a name="21"/>#		containing a list of items that differ and their position
<a name="22"/>#		in the input stream.
<a name="23"/>#
<a name="24"/>#  The diff_rec type is declared as:
<a name="25"/>#
<a name="26"/>#		record diff_rec(pos,diffs)
<a name="27"/>#
<a name="28"/>#  dif() fails if there are no differences, i.e. it produces an empty
<a name="29"/>#  result sequence.
<a name="30"/>#
<a name="31"/>############################################################################
<a name="32"/>#
<a name="33"/>#  For example, if two input streams are:
<a name="34"/>#
<a name="35"/>#	a b c d e f g h
<a name="36"/>#	a b d e f i j
<a name="37"/>#
<a name="38"/>#  the output sequence would be:
<a name="39"/>#
<a name="40"/>#	[diff_rec(3,[c]),diff_rec(3,[])]
<a name="41"/>#	[diff_rec(7,[g,h]),diff_rec(6,[i,j])
<a name="42"/>#
<a name="43"/>#  The arguments to dif(stream,compare,eof,group) are:
<a name="44"/>#
<a name="45"/>#	stream		A list of data objects that represent input streams
<a name="46"/>#			from which dif will extract its input "records".
<a name="47"/>#			The elements can be of several different types which
<a name="48"/>#			result in different actions, as follows:
<a name="49"/>#
<a name="50"/>#			   Type			   Action
<a name="51"/>#			===========	=============================
<a name="52"/>#			file		file is "read" to get records
<a name="53"/>#
<a name="54"/>#			co-expression	co-expression is activated to
<a name="55"/>#					get records
<a name="56"/>#
<a name="57"/>#			list		records are "gotten" (get()) from
<a name="58"/>#					the list
<a name="59"/>#
<a name="60"/>#			diff_proc	a record type defined in "dif" to
<a name="61"/>#					allow a procedure (or procedures)
<a name="62"/>#					suppled by dif's caller to be called
<a name="63"/>#					to get records.  Diff_proc has two
<a name="64"/>#					fields, the procedure to call and the
<a name="65"/>#					argument to call it with.  Its
<a name="66"/>#					definition looks like this:
<a name="67"/>#
<a name="68"/>#					   record diff_proc(proc,arg)
<a name="69"/>#			
<a name="70"/>#
<a name="71"/>#  Optional arguments:
<a name="72"/>#
<a name="73"/>#	compare		Item comparison procedure -- succeeds if
<a name="74"/>#			"equal", otherwise fails (default is the
<a name="75"/>#			identity "===" comparison).  The comparison
<a name="76"/>#			must allow for the fact that the eof object
<a name="77"/>#			(see next) might be an argument, and a pair of
<a name="78"/>#			eofs must compare equal.
<a name="79"/>#
<a name="80"/>#	eof		An object that is distinguishable from other
<a name="81"/>#			objects in the stream.  Default is &amp;null.
<a name="82"/>#
<a name="83"/>#	group		A procedure that is called with the current number
<a name="84"/>#			of unmatched items as its argument.  It must
<a name="85"/>#			return the number of matching items required
<a name="86"/>#			for file synchronization to occur.  Default is
<a name="87"/>#			the formula Trunc((2.0 * Log(M)) + 2.0) where
<a name="88"/>#			M is the number of unmatched items.
<a name="89"/>#
<a name="90"/>############################################################################
<a name="91"/>
<a name="92"/>package ipl.dif
<a name="93"/>
<a name="94"/>import
<a name="95"/>   io(Stream),
<a name="96"/>   lang(Prog)
<a name="97"/>
<a name="98"/>record diff_rec(pos,diffs)
<a name="99"/>record diff_proc(proc,arg)
<a name="100"/>record diff_file(stream,queue)
<a name="101"/>
<a name="102"/>
<a name="103"/>procedure dif(stream,compare,eof,group)
<a name="104"/>  local f,linenbr,line,difflist,gf,i,j,k,l,m,n,x,test,
<a name="105"/>	result,synclist,nsyncs
<a name="106"/>  #
<a name="107"/>  #  Provide default arguments and initialize data.
<a name="108"/>  #
<a name="109"/>  /compare := Prog.get_operator("===",2)
<a name="110"/>  /group := groupfactor
<a name="111"/>  f := []
<a name="112"/>  every put(f,diff_file(!stream,[]))
<a name="113"/>  linenbr := list(*stream,0)
<a name="114"/>  line := list(*stream)
<a name="115"/>  test := list(*stream)
<a name="116"/>  difflist := list(*stream)
<a name="117"/>  every !difflist := []
<a name="118"/>  #
<a name="119"/>  #  Loop to process all records of all input streams.
<a name="120"/>  #
<a name="121"/>  repeat {
<a name="122"/>    #
<a name="123"/>    #  This is the "idle loop" where we spin until we find a discrepancy
<a name="124"/>    #  among the data streams.  A line is read from each stream, with a
<a name="125"/>    #  check for eof on all streams.  Then the line from the first
<a name="126"/>    #  stream is compared to the lines from all the others.
<a name="127"/>    #
<a name="128"/>    repeat {
<a name="129"/>      every i := 1 to *stream do
<a name="130"/>        line[i] := diffread(f[i]) | eof
<a name="131"/>      if not (every x := !line do
<a name="132"/>        (x === eof) | break) then break break
<a name="133"/>      every !linenbr +:= 1
<a name="134"/>      if (every x := !line[2:0] do
<a name="135"/>        compare(x,line[1]) | break) then break
<a name="136"/>    }
<a name="137"/>    #
<a name="138"/>    #  Aha!  We have found a difference.  Create a difference list,
<a name="139"/>    #  one entry per stream, primed with the differing line we just found.
<a name="140"/>    #
<a name="141"/>    every i := 1 to *stream do
<a name="142"/>      difflist[i] := [line[i]]
<a name="143"/>    repeat {
<a name="144"/>      #
<a name="145"/>      #  Add a new input line from each stream to the difference list.
<a name="146"/>      #  Then build lists of the subset of different lines we need to
<a name="147"/>      #  actually compare.
<a name="148"/>      #
<a name="149"/>      every i := 1 to *stream do
<a name="150"/>        put(difflist[i],diffread(f[i]) | eof)
<a name="151"/>      gf := group(*difflist[1])
<a name="152"/>      every i := 1 to *stream do
<a name="153"/>        test[i] := difflist[i][-gf:0]
<a name="154"/>      #
<a name="155"/>      #  Create a "synchronization matrix", with a row and column for
<a name="156"/>      #  each input stream.  The entries will be initially &amp;null, then
<a name="157"/>      #  will be set to the synchronization position if sync is
<a name="158"/>      #  achieved between the two streams.  Another list is created to
<a name="159"/>      #  keep track of how many syncs have been achieved for each stream.
<a name="160"/>      #
<a name="161"/>      j := *difflist[1] - gf + 1
<a name="162"/>      synclist := list(*stream)
<a name="163"/>      every !synclist := list(*stream)
<a name="164"/>      every k := 1 to *stream do
<a name="165"/>        synclist[k][k] := j
<a name="166"/>      nsyncs := list(*stream,1)
<a name="167"/>      #
<a name="168"/>      #  Loop through positions to start comparing lines.  This set of
<a name="169"/>      #  nested loops will be exited when a stream achieves sync with
<a name="170"/>      #  all other streams.
<a name="171"/>      #
<a name="172"/>      every i := 1 to j do {
<a name="173"/>        #
<a name="174"/>        #  Loop through all streams.
<a name="175"/>        #
<a name="176"/>        every k := 1 to *stream do {
<a name="177"/>          #
<a name="178"/>          #  Loop through all streams.
<a name="179"/>          #
<a name="180"/>	  every l := 1 to *stream do {
<a name="181"/>	    if /synclist[k][l] then {	# avoid unnecessary comparisons
<a name="182"/>	      #
<a name="183"/>              #  Compare items of the test list to the differences list
<a name="184"/>              #  at all possible positions.  If they compare, store the
<a name="185"/>              #  current position in the sync matrix and bump the count
<a name="186"/>              #  of streams sync'd to this stream.  If all streams are in
<a name="187"/>	      #  sync, exit all loops but the outer one.
<a name="188"/>	      #
<a name="189"/>	      m := i - 1
<a name="190"/>	      if not every n := 1 to gf do {
<a name="191"/>	        compare(test[k][n],difflist[l][m +:= 1]) | break
<a name="192"/>	      } then {
<a name="193"/>	        synclist[k][l] := i	# store current position
<a name="194"/>	        if (nsyncs[k] +:= 1) = *stream then break break break break
<a name="195"/>	      }
<a name="196"/>	    }
<a name="197"/>	  }
<a name="198"/>	}
<a name="199"/>      }
<a name="200"/>    }
<a name="201"/>    #
<a name="202"/>    #  Prepare an output set.  Since we have read the input streams past
<a name="203"/>    #  the point of synchronization, we must queue those lines before their
<a name="204"/>    #  input streams. 
<a name="205"/>    #
<a name="206"/>    synclist := synclist[k]
<a name="207"/>    result := list(*stream)
<a name="208"/>    every i := 1 to *stream do {
<a name="209"/>      j := synclist[i]
<a name="210"/>      while difflist[i][j -:= 1] === eof	# trim past eof
<a name="211"/>      result[i] := diff_rec(linenbr[i],difflist[i][1:j + 1])
<a name="212"/>      f[i].queue := difflist[i][synclist[i] + gf:0] ||| f[i].queue
<a name="213"/>      linenbr[i] +:= synclist[i] + gf - 2
<a name="214"/>      difflist[i] := []
<a name="215"/>    }
<a name="216"/>    suspend result
<a name="217"/>  }
<a name="218"/>end
<a name="219"/>
<a name="220"/>#
<a name="221"/>#  diffread() -- Read a line from an input stream.
<a name="222"/>#
<a name="223"/>procedure diffread(f)
<a name="224"/>  local x
<a name="225"/>  if x := get(f.queue) then
<a name="226"/>     return x
<a name="227"/>  x := f.stream
<a name="228"/>  if is(x, Stream) then
<a name="229"/>     return x.read()
<a name="230"/>  if is(x, diff_proc) then
<a name="231"/>     return x.proc(x.arg)
<a name="232"/>  return case type(x := f.stream) of {
<a name="233"/>    "co-expression": @x
<a name="234"/>    "list": get(x)
<a name="235"/>  }
<a name="236"/>end
<a name="237"/>
<a name="238"/>#
<a name="239"/>#  groupfactor() -- Determine how many like lines we need to close
<a name="240"/>#  off a group of differences.  This is the default routine -- the
<a name="241"/>#  caller may provide his own.
<a name="242"/>#
<a name="243"/># Compute: Trunc((2.0 * Log(m)) + 2.0)
<a name="244"/>procedure groupfactor(m)  
<a name="245"/>  m := string(m)
<a name="246"/>  return 2 * *m + if m &lt;&lt;= "316227766"[1+:*m] then 0 else 1
<a name="247"/>end
<a name="248"/>
</pre></body></html>
