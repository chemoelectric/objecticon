############################################################################
#
#	File:     lists.icn
#
#	Subject:  Procedures to manipulate lists
#
#	Author:   Ralph E. Griswold
#
#	Date:     June 11, 2001
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#	Contributor:  Richard L. Goerwitz
#
############################################################################

package ipl.lists

import
   io(Files,open),
   ipl.indices(indices),
   ipl.numbers(residue),
   ipl.sets(elementset),
   ipl.strings(separate,separate_lines),
   lang(equals,Prog),
   util(cvpos, cvslice, cvslice_def, cvpos_item)

# Create list from lines in file
procedure file2lst(s)			
   local input, result, x

   input := open(s) | fail

   result := []

   while x := input.read() do {
      x := numeric(x)			# kludge
      put(result, x)
      }

   input.close()

   return result

end

# Convert `limage()` output to list
procedure imag2lst(seqimage)		
   local seq, term

   seq := []

   seqimage[2:-1] ? {
      while term := tab(upto(',') | 0) do {
         term := numeric(term)			# special interest
         put(seq, term)
         move(1) | break
         }
      }

   return seq

end

procedure lblock(L1, L2)
   local L3, i, j

   if *L1 < *L2 then L1 := lextend(L1, *L2) | fail
   else if *L2 < *L1 then L2 := lextend(L2, *L1) | fail

   L3 := []

    every i := 1 to *L1 do
       every j := 1 to L2[i] do
          put(L3, L2[i])

      return L3

end

# Layer and interleave `args[1], args[2], ...`
procedure llayer(args[])		
   local offsets, offset, seq, arg, lists, k

   lists := []

   every put(lists, lcompact(!args))

   offsets := []

   offset := 0

   every arg := !lists do {
      put(offsets, offset)
      offset +:= max ! arg
      }

   seq := []

   repeat {
      every k := 1 to *lists do {
         arg := lists[k]
         put(seq, get(arg) + offsets[k]) | break break
         }
      }

   return seq

end

# Compact list, mapping out missing values
procedure lcompact(seq)			
   local unique, target

   unique := elementset(seq)

   target := []

   every put(target, 1 to *unique)

   return lmap(seq, sort(unique), target)

end

# Close open palindrome
procedure lclose(L)			

   if equals(L, lreverse(L)) then return L
   else {
      L := copy(L)
      put(L, L[1])
      return L
      }

end

package procedure lcomb1(L, start, R, k)
   local i
   if *R - k > *L - start then
      fail
   if k > *R then
      return R
   every i := start to *L do {
      R[k] := L[i]
      suspend lcomb1(L, i + 1, R, k + 1)
   }
end

# Generate all combinations of length `i` from list `L`.  NB: the same results
# list is suspended each time.
procedure lcomb(L,i)			
   suspend lcomb1(L, 1, list(i), 1)
end


# List decollation
procedure ldecollate(indices, L)	
   local result, i, x

   indices := copy(indices)

   result := list(max ! indices)	# list of lists to return
   every !result := []			# initially empty

   every x := !L do {
      i := get(indices)	| fail
      put(indices, i)
      put(result[i], x)
      }

   return result

end

# Delete all instances of `x` from the list `l`.
procedure ldel(l, x)
   local i
   i := 1
   while i <= *l do {
      if l[i] === x then
         delete(l, i)
      else
         i +:= 1
   }
   return l
end

# Delete just the first occurence of `x` from list `l`.
# Returns `l` if `x` was found in `l`, fails otherwise.
#
procedure ldel1(l, x)
   return delete(l, keyof(l, x))
end

# Delete specified list elements; returns a new list
procedure ldelelements(L, spec)		
   local i, tmp

   tmp := indices(spec, *L) | fail		# bad specification

   while i := pull(tmp) do
      L := L[1+:i - 1] ||| L[i + 1:0]

   return L

end

# List term duplication
procedure ldupl(L1, L2)			
   local L3, i, j

   if integer(L2) then L2 := [L2]

   L3 := []

   every i := !L2 do
      every j := !L1 do
        every 1 to i do
           put(L3, j)

   return L3

end

# Compare lists for equivalence
procedure lequiv(x,y)			
   local i

   if x === y then return y
   if type(x) == type(y) == "list" then {
      if *x ~= *y then fail
      every i := 1 to *x do
         if not lequiv(x[i],y[i]) then fail
      return y
     }

end

# Elevate values
procedure levate(seq, m, n)		
   local shafts, reseq, i, j, k

   shafts := list(m)

   every !shafts := []

   every i := 1 to m do
      every put(shafts[i], i to n by m)

   reseq := []

   while j := get(seq) do {
      i := j % m + 1
      k := get(shafts[i])
      put(reseq, k)
      put(shafts[i], k)
      }

   return reseq

end
	
# List extension
procedure lextend(L, i)			
   local result

   if *L = 0 then fail

   result := copy(L)

   until *result >= i do
      result |||:= L

   result := result[1+:i]

   return result
 
end

# List horizontal flip (reversal)
procedure lfliph(L)			

   return lreverse(L)

end

# List vertical flip
procedure lflipv(L)			
   local L1, m, i

   m := max ! L

   L1 := []

   every i := !L do
      put(L1, residue(-i + 1, m, 1))

   return L1

end

# Unadorned list image
procedure limage(L)			
   local result

   if type(L) ~== "list" then fail

   result := ""

   every result ||:= image(!L) || ","

   return ("[" || result[1:-1] || "]") | "[]"

end

# Generalized list collation;; like `linterl()` except stops on short list.
procedure lcollate(args[])		
   local seq, arg, lists, k

   lists := []

   every put(lists, copy(!args))

   seq := []

   repeat {
      every k := 1 to *lists do {
         arg := lists[k]
         put(seq, get(arg)) | break break
         }
      }

   return seq

end

# Succeeds and returns element if all elements are the same
procedure lconstant(L)			

   if *elementset(L) = 1 then return .L[1]
   else fail

end

# List interleaving
procedure linterl(L1, L2)		
   local L3, i

   if *L1 < *L2 then L1 := lextend(L1, *L2) | fail
   else if *L2 < *L1 then L2 := lextend(L2, *L1) | fail

   L3 := []

   every i := 1 to *L1 do
      every put(L3, L1[i] | L2[i])

   return L3

end

# List padding at left
procedure llpad(L, i, x)		

   L := copy(L)

   while *L < i do push(L, x)

   return L

end

# List run up
procedure lrunup(L1, L2, L3)		
   local L4

   /L3 := [1]		# could be /L3 := 1 ...

   L4 := []

   every put(L4, !L1 to !L2 by !L3)

   return L4

end

# List run down
procedure lrundown(L1, L2, L3)		
   local L4

   /L3 := [1]		# could be /L3 := 1 ...

   L4 := []

   every put(L4, !L1 to !L2 by -!L3)

   return L4

end


# List left trimming
procedure lltrim(L, S)			

   L := copy(L)

   while member(S, L[1]) do
      get(L)

    return L

end

#  __About List Mapping__
#
#  The procedure `lmap(L1,L2,L3)` maps elements of `L1` according to
#  `L2` and `L3`.  This procedure is the analog for lists of the
#  built-in string-mapping function `map(s1,s2,s3)`. Elements in `L1`
#  that are the same as elements in `L2` are mapped into the
#  corresponding elements of `L3`. For example, given the lists
#  ~
#     L1 := [1,2,3,4]
#     L2 := [4,3,2,1]
#     L3 := ["a","b","c","d"]
#  ~
#  then
#  ~
#     lmap(L1,L2,L3)
#  ~
#  produces a new list
#  ~
#     ["d","c","b","a"]
#  ~
#     Lists that are mapped can have any kinds of elements. The
#  operation
#  ~
#     x === y
#  ~
#  is used to determine if elements `x` and `y` are equivalent.
#  
#     All cases in `lmap` are handled as they are in `map`, except
#  that no defaults are provided for omitted arguments. As with `map`,
#  `lmap` can be used for transposition as well as substitution.
#  
#  **Warning:**
#
#     If `lmap` is called with the same lists `L2` and `L3` as in the
#  immediately preceding call, the same mapping is performed, even if
#  the values in `L2` and `L3` have been changed. This improves
#  performance, but it may cause unexpected effects.
#  
#     This "caching" of the mapping table based on `L2` and `L3`
#  can be easily removed to avoid this potential problem.
#
procedure lmap(L1,L2,L3)		
   static lmem2, lmem3, lmaptbl, tdefault
   local i, a

   initial tdefault := []

   if type(a := L1 | L2 | L3) ~== "list" then runerr(108,a)
   if *L2 ~= *L3 then runerr(208,L2)

   L1 := copy(L1)

   if not(lmem2 === L2 & lmem3 === L3) then {	# if an argument is new, rebuild
      lmem2 := L2				# save for future reference
      lmem3 := L3
      lmaptbl := table(tdefault)		# new mapping table
      every i := 1 to *L2 do			# build the map
         lmaptbl[L2[i]] := L3[i]
      }
   every i := 1 to *L1 do			# map the values
      L1[i] := (tdefault ~=== lmaptbl[L1[i]])
   return L1

end

# List residue
procedure lresidue(L, m, i)		
   local result

   /i := 0

   result := []

   every put(result, residue(!L, m, i))

   return result

end

# List palindrome
procedure lpalin(L, x)			

   L |||:= lreverse(L)

   if /x then pull(L)

   return L

end

# Heap's algorithm for permutation generation.
# See : <https://en.wikipedia.org/wiki/Heap%27s_algorithm>
#
package procedure lpermute1(L, n)
   local i
   if n <= 1 then
      return L
   every i := 1 to n - 1 do {
      suspend lpermute1(L, n - 1)
      if i % 2 = 1 then
         L[i] :=: L[n]
      else
         L[1] :=: L[n]
   }
   suspend lpermute1(L, n - 1)
end

# List permutations.  NB: the same result list is suspended each time.
#
procedure lpermute(L)			
   suspend lpermute1(copy(L), *L)
end


# List reflection.  Returns `L` concatenated with its reversal to
# produce palindrome; the values of `i` determine "end conditions" for
# the reversal:
#  *  0       omit first and last elements; default
#  *  1       omit first element
#  *  2       omit last element
#  *  3       don't omit element
#
procedure lreflect(L, i)		
   local L1

   /i := 0

   if i > 3 then runerr("*** invalid argument to lreflect()")

   if i < 3 then L1 := copy(L)

   return L ||| lreverse(
      case i of {
         0:   {get(L1); pull(L1); L1}
         1:   {get(L1); L1}
         2:   {pull(L1); L1}
         3:   L
         }
      )

end

# Remove values from list
procedure lremvals(L, x[])		
   local result, y

   result := []

   every y := !L do
      if y === !x then next
      else put(result, y)

   return result

end

# List replication
procedure lrepl(L, i)			
   local j, k

   i := (0 < integer(i)) | runerr("*** invalid replication factor in lrepl()")

   L := copy(L)

   j := *L

   every 1 to i - 1 do
      every k := 1 to j do
         put(L, L[k])

   return L

end

# List reverse, returning a new list.  If `pos1` and `pos2` are given,
# then only the sublist `pos1:pos2` is reversed.
#
procedure lreverse(L, pos1, pos2)			
   return lreverse_mod(copy(L), pos1, pos2)
end

# List reverse, modifying `L`.  If `pos1` and `pos2` are given, then
# only the sublist `pos1:pos2` is reversed.
#
procedure lreverse_mod(L, pos1, pos2)
   local s, i, j
   s := cvslice_def(pos1, pos2, *L) | fail
   i := s.lo
   j := s.hi - 1
   while i < j do {
      L[i] :=: L[j]
      i +:= 1
      j -:= 1
   }
   return L
end

# List rotation
procedure lrotate(L, i)			

   /i := 1

   L := copy(L)

   if i > 0 then
      every 1 to i do
         put(L, get(L))
   else
      every 1 to -i do
         push(L, pull(L))

   return L

end

# List right padding
procedure lrpad(L, i, x)		

   L := copy(L)

   while *L < i do put(L, x)

   return L

end

# List right trimming
procedure lrtrim(L, S)			

   L := copy(L)

   while member(S, L[-1]) do
      pull(L)

    return L

end

# Shift list terms
procedure lshift(L, i)			

   L := copy(L)

   every !L +:= i

   return L

end

# List element swap
procedure lswap(L)			
   local i

   L := copy(L)

   every i := 1 to *L by 2 do
      L[i] :=: L[i + 1]

   return L

end

# Keep only unique list elements
procedure lunique(L)			
   local result, culls, x

   result := []
   culls := elementset(L)

   every x := !L do
      if member(culls, x) then {
         delete(culls, x)
         put(result, x)
         }

   return result

end

# Returns the size of the largest value in `L`.  If `p` is given, it
# is applied to each string as as a "length" procedure.  The default
# for `p` is :-
# ~
#      Prog.get_operator("*", 1)
# ~
procedure lmaxlen(L, p)			
   local i

   /p := Prog.get_operator("*", 1)

   i := p(L[1]) | fail

   every i <:= p(!L)

   return i

end

# Returns the size of the smallest value in `L`.  If `p` is given, it
# is applied to each string as a "length" procedure.  The default for
# `p` is
# ~
#      Prog.get_operator("*", 1)
# ~
procedure lminlen(L, p)			
   local i

   /p := Prog.get_operator("*", 1)

   i := p(L[1]) | fail

   every i >:= p(!L)

   return i

end

# Extract keys from sorted list, returning list of keys from `L`,
# where `L` is the result of sorting a table with option 3 or 4.
#
procedure sortkeys(L)			
   local result

   result := []

   every put(result, L[1 to *L by 2])

   return result

end

# Extract values from sorted list, returning list of values from `L`,
# where `L` is the result of sorting a table with option 3 or 4.
#
procedure sortvalues(L)			
   local result

   result := []

   every put(result, L[2 to *L by 2])

   return result

end

# Creates list with `i`-character lines from `s`.  The default for `i`
# is 1.
#
procedure splitstring(s, i)			
   local L

   /i := 1

   L := []

   s ? {
      while put(L, move(i))
      if not pos(0) then put(L, tab(0))
      }

   return L

end

#
# Convert a string to a list.
#
# @param s the string to convert
# @param sep cset of the separator chars, default ',' - note each separator
# @      in the string is always one character wide.
# @param f func to apply to each element before adding to list
#
procedure str2list(s, sep, f)
   local l, t
   /sep := ','
   /f := 1
   l := []
   every t := separate(s, sep) do
      put(l, f(t)) | runerr("str2list: conversion proc failed")
   return l
end

#
# Convert a list to a string.  Note: to be compatible for re-input to str2list above,
# the separator must be one character long.
#
# @param l the list
# @param sep the separator char, default ","
# @param f func to apply to each element before appending to result
#
procedure list2str(l, sep, f)
   local s, e
   /sep := ","
   /f := 1
   s := ""
   every e := !l do
      s ||:= f(e) || sep | runerr("list2str: conversion proc failed")
   s[-*sep:0] := ""
   return s
end

#
# Convert a string to a list, breaking on lines ending with \n or \r\n.
#
# @param s the string to convert
# @param f func to apply to each element before adding to list
#
procedure break_lines(s, f)
   local l, t
   /f := 1
   l := []
   every t := separate_lines(s) do
      put(l, f(t)) | runerr("break_lines: conversion proc failed")
   return l
end

#
# Convert a list to a string, separating elements by the platform's
# end-of-line character(s).
#
# @param l the list
# @param f func to apply to each element before appending to result
#
procedure cat_lines(l, f)
   local s, e
   /f := 1
   s := ""
   every e := !l do
      s ||:= f(e) || Files.EOL | runerr("cat_lines: conversion proc failed")
   s[-*Files.EOL:0] := ""
   return s
end

#
# Put all the parameters on the given list.
#
procedure put_n(l, a[])
   every put(l, !a)
   return l
end

#
# Push all the parameters on the given list.
#
procedure push_n(l, a[])
   every push(l, !a)
   return l
end

#
# Move the element in `L` at position `i` to position `j`.
#
procedure lmove(L, i, j)
   i := cvpos_item(i, *L) | fail
   j := cvpos_item(j, *L) | fail
   if i ~= j then {
      if i > j then {
         insert(L, j, L[i])
         delete(L, i + 1)
      } else {
         insert(L, j + 1, L[i])
         delete(L, i)
      }
   }
   return L
end

#
# Extract the elements L[i:j], from L, returning them as a list.
# i defaults to 1, j to 0.
#
procedure lextract(L, i, j)
   local l, s
   s := cvslice_def(i, j, *L) | fail
   i := s.lo; j := s.hi
   l := L[i:j]
   every 1 to j - i do
      delete(L, i)
   return l
end

#
# Insert the elements of `l` into `L`, starting at `i`.  `l` is left unchanged.
#
procedure linsert(L, l, i)
   /i := 0
   i := cvpos(i, *L) | fail
   every insert(L, i, back(l))
   return L
end

# Remove the elements `i:j` from `L`, and insert the elements of `l` in their place.
#
procedure lsplice(L, l, i, j)
   local s
   s := cvslice(i, j, *L) | fail
   i := s.lo; j := s.hi
   every 1 to j - i do
      delete(L, i)
   linsert(L, \l, i)
   return L
end
