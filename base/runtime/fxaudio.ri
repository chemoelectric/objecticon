/*
 * File: fxaudio.ri - Unicon Audio + VoIP Interface
 *  Contents: PlayAudio, StopAudio, VWho, VAttrib.
 */

"PlayAudio(s) - Play audio file."
function{0,1} PlayAudio(fname)

   declare {
      tended struct descrip filename;
      }

    abstract {
      return file;
      }

   body {
      tended char *fnamestr;
      int status;
      FILE * f;
      struct b_file *fl;

      /*
       * get a C string for the file name
       */
      if (!cnv:C_string(fname, fnamestr))
	 runerr(103,fname);

      if (strlen(fnamestr) != StrLen(fname))
	 fail;

      f = (FILE*) StartAudioThread(fnamestr);
      status = 1;
      StrLen(filename) = strlen(fnamestr);
      StrLoc(filename) = fnamestr;
      Protect(fl = alcfile(f, status, &filename), runerr(0));
      return file(fl);
      }
end

"StopAudio - kill the audio thread."
function{1} StopAudio(f)

   if !is:file(f) then
      runerr(105, f)

   abstract {
      return integer;
      }

   body {
      /* we are passing the file name as struct */
      AudioPtr Ptr;
      Ptr = (AudioPtr)BlkLoc(f)->file.fd.fp;
      StopAudioThread(Ptr);
      return C_integer 1;
      }
end


"VWho(f) - List the destinations in the voice session."
function{1} VWho(f)

   if !is:file(f) then
      runerr(105, f)		/* f is not a file */

   abstract {
      return list;
      }
   body {
      int i , k;
#ifdef HAVE_VOICE
      PVSESSION Ptr;
      char *s;
      struct descrip Str;
	
      tended struct descrip L;
      tended struct b_list *hp;

      /* create empty list  */
      if ((hp=alclist(0, MinListSlots)) == NULL) fail;
      L.dword=D_List;
      L.vword.bptr=(union block *) hp;

      Ptr = (PVSESSION) BlkLoc(f)->file.fd.fp;
      k = GetVListSize(Ptr);
      for(i=0; i<= k; ++i) {
	 s = FetchListener(Ptr,i);
	 MakeStr(s,strlen(s),&Str);
	 c_put(&L, &Str);	
	 }

      return L;
#else
      fail;
#endif
      }
end


"VAttrib(f,attrib) - set voice attribute. "
function{0,1} VAttrib(f,attrib)

   if !is:file(f) then
      runerr(105, f)		/* f is not a file */

   if !cnv:C_string(attrib) then
      runerr(103, attrib)

   abstract {
      return integer ++ string ++ list;
      }
   body {
      /* char tmpstr[MaxCvtLen]; */
#ifdef HAVE_VOICE
      PVSESSION Ptr;
      Ptr = (PVSESSION)BlkLoc(f)->file.fd.fp;

      if (strstr(attrib, "+=") || strstr(attrib, "-=") ) {
	 SetVoiceAttrib(Ptr, attrib);
	 return C_integer 1;
	 }
      else {
	 if (strchr(attrib,'=')){
	    /* forming the attrib list  */
	    int i , k;
	    char *s;
	    struct descrip Str;
	    tended struct descrip L;
	    tended struct b_list *hp;

	    /* create empty list  */
	    if ((hp=alclist(0, MinListSlots)) == NULL) fail;
	    L.dword=D_List;
	    L.vword.bptr=(union block *) hp;

	    /* forming the list */
	    k = GetVListSize(Ptr);
	    if (strstr(attrib,"name") && (!strstr(attrib,"address"))){
	       for(i=0; i<= k; ++i){
		  s = FetchName(Ptr,i);
		  if (s != NULL) {
		     MakeStr(s,strlen(s),&Str);
		     c_put(&L, &Str);
		     }
		  }
	       }
	    else {
	       if (strstr(attrib,"address") && (!strstr(attrib,"name"))) {
		  for(i=0; i<= k; ++i){
		     s = FetchAddress(Ptr,i);
		     if (s != NULL) {
			MakeStr(s,strlen(s),&Str);
			c_put(&L, &Str);
			}
		     }
		  }
	       else	
		  for(i=0; i<= k; ++i) {
		     s = FetchListener(Ptr,i);
		     if (s != NULL) {
			MakeStr(s,strlen(s),&Str);
			c_put(&L, &Str);
			}
		     }/* end for */
	       }
	    return L;
	    }
	 else {
	    /* forming the attrib string   */
	    char tmpstr[MaxCvtLen],*str;
	    int i, k = GetVListSize(Ptr), len=0;
	    tmpstr[0] = '\0';
	    for (i=0; i<= k; ++i) {
	       str = FetchListener(Ptr, i);
	       if (str != NULL) {
		  strcat(tmpstr, str);
		  strcat(tmpstr, ",");
		  }
	       }
	    len = strlen(tmpstr)-1;
	    tmpstr[len] = '\0';
	    return C_string tmpstr;
	    }
	 return C_integer 1;
	 }
      return C_integer 1;
#else
      fail;
#endif
      }
end
