package io

import lang

class WorkerStream(Stream)
   private readable
      timeout,
      other,
      when_timeout,
      io_group, 
      coex,
      poll_for

   public sched(x)
      when_timeout := Prog.get_runtime_millis() + timeout
      self.poll_for := x
      self.coex := &current
      return io_group.add_stream(self)
   end

   public in(n)
      sched(Poll.IN) | fail
      return other.in(n)
   end

   public out(s)
      sched(Poll.OUT) | fail
      return other.out(s)
   end

   public set_timeout(t)
      self.timeout := t
   end

   public close()
      return other.close()
   end

   public eof()
      return other.eof()
   end

   public get_mode()
      return other.get_mode()
   end

   public flag(on, off)
      return other.flag(on, off)
   end

   public connect(addr)
      return other.connect(addr)
   end

   public new(other, io_group)
      self.other := other
      self.io_group := io_group
      self.timeout := 1000
      return
   end
end

class IoGroup()
   private readable coex
   private starters, streams, caller, poll_l

   public new()
      streams := set()
      starters := set()
      return
   end

   public add_starter(w)
      insert(starters, w)
   end

   public add_stream(w)
      insert(streams, w)
      poll_l := &null
      return @coex
   end

   public work()
      coex := &current
      if do_work() then {
         coex := &null
         return
      } else
         coex := &null
   end

   public empty()
      return not(*(starters | streams) > 0)
   end

   private do_work()
      local e, t, now, r
      if *starters > 0 then {
         e := ?starters
         delete(starters, e)
         # Don't use coex, since this should be a new coexpression.
         @e
         return
      } 
      if *streams > 0 then {
         if /poll_l then {
            poll_l := []
            every e := !streams do {
               put(poll_l, e.other)
               put(poll_l, ior(e.poll_for,Poll.ERR))
            }
            put(poll_l, 0)
         }

         write("poll:",to_string(poll_l,"depth=1"))
         r := DescStream.poll!poll_l | {
            ewrite("poll failed:",&why)
            fail
         }
         now := Prog.get_runtime_millis()
         if \r then
            *r = *streams | syserr("Odd result from poll")
         every e := !streams do {
            t := pop(\r) | 0
            case t of {
               e.poll_for: {
                  delete(streams, e)
                  poll_l := &null
                  coact(, e.coex)
                  return
               }
               Poll.ERR: {
                  delete(streams, e)
                  poll_l := &null
                  &why := "socket error"
                  coact(, e.coex,, 1)
                  return
               }
               0: {
                  if now > e.when_timeout then {
                     write("send timeout to ",image(e))
                     delete(streams, e)
                     poll_l := &null
                     &why := "timeout"
                     coact(, e.coex,, 1)
                     return
                  }
               }
               default: syserr("Odd value from poll:" || t)
            }
         }
      }
   end
end
