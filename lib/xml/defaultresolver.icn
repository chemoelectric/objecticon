#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package xml

import http, net, util, io

#
# The default resolver resolves from a URL or the local file system.
#
# If the system id begins with "http://", it is treated as a web URL, and
# loaded over the network.  
#
# If it begins with "file://", then it is treated as a
# local file (for an absolute path on Unix like systems, that would be
# three forward slashes at the start : "file:///tmp/file.dtd").
#
# Otherwise, the system id is treated as a filename.
#
class DefaultResolver(Resolver)
   private
      public_mapping,
      uri_cache,
      cache_uris_flag,
      http_client

   #
   # Set a mapping from a public id to an alternative URI.  The alternative URI
   # will then be loaded when the public id is encountered, rather than the
   # given system id.  The alternative may be a simple filename if desired.
   #
   # Example :-
   # ~
   #    set_public_mapping("-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN", 
   #                       "/tmp/web-app_2_3.dtd")
   # ~
   # @param pub_id the public id
   # @param uri the alternative uri
   #
   public set_public_mapping(pub_id, uri)
      insert(public_mapping, pub_id, uri)
      return self
   end

   #
   # Configure whether the resolver remembers URIs internally to save getting them
   # more than once.  This is on by default.
   #
   public set_cache_uris(s)
      self.cache_uris_flag := check_flag(s)
      return self
   end

   #
   # Use the given HttpClient for getting http:// URLs.  Use this to set custom timeout
   # or retry values for example.
   #
   public set_http_client(hc)
      self.http_client := hc
      return self
   end

   #
   # Cache an individual system id (URI) to the given value.
   #
   public cache_uri(sys_id, val)
      val := string(val) | runerr(103, val)
      insert(uri_cache, sys_id, val)
      return self
   end

   public resolve(base, external_id)
      local sys_id, res, u, t

      #
      # Try to map from the public id (if any) to an alternative URI
      #
      sys_id := member(public_mapping, 
                       external_id.get_public_id()) | external_id.get_system_id()

      sys_id := string(sys_id)

      # 
      # Make an absolute filename a URL
      #
      if sys_id[1] == "/" then
         sys_id := "file://" || sys_id

      #
      # Try to make an absolute URL of sys_id, using base.
      #
      if \base &
         not match("http://" | "https://" | "file://", sys_id) &
         match("http://" | "https://" | "file://", base) &
         u := URL(base) then
      {
         sys_id := u.get_relative(sys_id).str()
      }

      #
      # Try the cache.
      #
      if \cache_uris_flag & t := member(uri_cache, sys_id) then
         return Resolved(sys_id, t)

      res := resolve_impl(sys_id) | fail

      #
      # Cache if appropriate
      #
      if \cache_uris_flag then
         cache_uri(sys_id, res)

      return Resolved(sys_id, res)
   end

   private resolve_impl(sys_id)
      if match("http://" | "https://", sys_id) then
         return get_http(sys_id)

      if match("file://", sys_id) then
         return get_local(sys_id[8:0])

      return get_local(sys_id)
   end

   private get_local(sys_id)
      return Files.file_to_string(sys_id) | error("Couldn't open:" || sys_id)
   end

   private get_http(sys_id)
      local url, sb
      url := URL(sys_id) | fail
      return use { 
         http_client,
         use {
            sb := RamStream(),
            if http_client.retrieve(HttpRequest().set_url(url).set_output_stream(sb)) then
               sb.str()
         }
      }
   end

   public new()
      public_mapping := table()
      uri_cache := table()
      cache_uris_flag := &yes
      self.http_client := HttpClient()
      return
   end
end

