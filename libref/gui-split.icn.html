<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>split.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: split.icn 8282 2020-05-11 18:28:41Z rparlett $
<a name="3"/>
<a name="4"/>package gui
<a name="5"/>
<a name="6"/>import util
<a name="7"/>
<a name="8"/>#
<a name="9"/># This `Component` contains two children whose sizes can be adjusted with
<a name="10"/># a `Sizer` component between them.
<a name="11"/>#
<a name="12"/>class Split(Component)
<a name="13"/>   public 
<a name="14"/>      first,
<a name="15"/>      second,
<a name="16"/>      sizer,
<a name="17"/>      min_first,
<a name="18"/>      min_second,
<a name="19"/>      weight,
<a name="20"/>      step,
<a name="21"/>      start_size_first,
<a name="22"/>      start_size_second
<a name="23"/>
<a name="24"/>   #
<a name="25"/>   # Set the left `Component`, and lay out horizontally.
<a name="26"/>   #
<a name="27"/>   public set_left(c)
<a name="28"/>      remove(\self.first)
<a name="29"/>      self.first := c
<a name="30"/>      add(self.first, 1)
<a name="31"/>      self.sizer.set_is_horizontal(&amp;no)
<a name="32"/>      link
<a name="33"/>   end
<a name="34"/>
<a name="35"/>   #
<a name="36"/>   # Set the top `Component`, and lay out vertically.
<a name="37"/>   #
<a name="38"/>   public set_top(c)
<a name="39"/>      remove(\self.first)
<a name="40"/>      self.first := c
<a name="41"/>      add(self.first, 1)
<a name="42"/>      self.sizer.set_is_horizontal(&amp;yes)
<a name="43"/>      link
<a name="44"/>   end
<a name="45"/>
<a name="46"/>   #
<a name="47"/>   # Set the right `Component`.
<a name="48"/>   #
<a name="49"/>   public set_right(c)
<a name="50"/>      remove(\self.second)
<a name="51"/>      self.second := c
<a name="52"/>      add(self.second)
<a name="53"/>      link
<a name="54"/>   end
<a name="55"/>
<a name="56"/>   #
<a name="57"/>   # Set the bottom `Component`.
<a name="58"/>   #
<a name="59"/>   public set_bottom(c)
<a name="60"/>      remove(\self.second)
<a name="61"/>      self.second := c
<a name="62"/>      add(self.second)
<a name="63"/>      link
<a name="64"/>   end
<a name="65"/>
<a name="66"/>   public override initially()
<a name="67"/>      \self.first | runerr("Left/top not set")
<a name="68"/>      \self.second | runerr("Right/bottom not set")
<a name="69"/>      *self.children = 3 | runerr("Should be exactly 3 children")
<a name="70"/>      Component.initially()
<a name="71"/>   end
<a name="72"/>
<a name="73"/>   public override get_default_width()
<a name="74"/>      local t
<a name="75"/>      if \first.is_hidden_flag then
<a name="76"/>         return second.get_preferred_width()
<a name="77"/>      else if \second.is_hidden_flag then
<a name="78"/>         return first.get_preferred_width()
<a name="79"/>      else if /self.sizer.is_horizontal_flag then {
<a name="80"/>         t := 0
<a name="81"/>         every t +:= (!self.children).get_preferred_width()
<a name="82"/>         return t
<a name="83"/>      } else {
<a name="84"/>         return max(first.get_preferred_width(),
<a name="85"/>                    second.get_preferred_width())
<a name="86"/>      }
<a name="87"/>   end
<a name="88"/>
<a name="89"/>   public override get_default_height(dw)
<a name="90"/>      local t
<a name="91"/>      if \first.is_hidden_flag then
<a name="92"/>         return second.get_preferred_height(dw)
<a name="93"/>      else if \second.is_hidden_flag then
<a name="94"/>         return first.get_preferred_height(dw)
<a name="95"/>      else if /self.sizer.is_horizontal_flag then {
<a name="96"/>         return max(first.get_preferred_height(dw),
<a name="97"/>                    second.get_preferred_height(dw))
<a name="98"/>      } else {
<a name="99"/>         t := 0
<a name="100"/>         every t +:= (!self.children).get_preferred_height(dw)
<a name="101"/>         return t
<a name="102"/>      }
<a name="103"/>   end
<a name="104"/>
<a name="105"/>   # Hide the first component (and the sizer), so that the second
<a name="106"/>   # component takes up all the space in the split.
<a name="107"/>   #
<a name="108"/>   public hide_first()
<a name="109"/>      if /first.is_hidden_flag then {
<a name="110"/>         first.set_is_hidden(&amp;yes)
<a name="111"/>         sizer.set_is_hidden(&amp;yes)
<a name="112"/>         second.set_is_hidden(&amp;no)
<a name="113"/>         if is_live() then
<a name="114"/>            do_layout().invalidate()
<a name="115"/>      }
<a name="116"/>      link
<a name="117"/>   end
<a name="118"/>
<a name="119"/>   # Hide the second component (and the sizer), so that the first
<a name="120"/>   # component takes up all the space in the split.
<a name="121"/>   #
<a name="122"/>   public hide_second()
<a name="123"/>      if /second.is_hidden_flag then {
<a name="124"/>         first.set_is_hidden(&amp;no)
<a name="125"/>         sizer.set_is_hidden(&amp;yes)
<a name="126"/>         second.set_is_hidden(&amp;yes)
<a name="127"/>         if is_live() then
<a name="128"/>            do_layout().invalidate()
<a name="129"/>      }
<a name="130"/>      link
<a name="131"/>   end
<a name="132"/>
<a name="133"/>   # After a call to `hide_first()` or a `hide_second()`, reset the
<a name="134"/>   # hidden state back to normal, so that both first and second
<a name="135"/>   # components, and the sizer, are shown.
<a name="136"/>   #
<a name="137"/>   public hide_neither()
<a name="138"/>      if \sizer.is_hidden_flag then {
<a name="139"/>         first.set_is_hidden(&amp;no)
<a name="140"/>         sizer.set_is_hidden(&amp;no)
<a name="141"/>         second.set_is_hidden(&amp;no)
<a name="142"/>         if is_live() then
<a name="143"/>            do_layout().invalidate()
<a name="144"/>      }
<a name="145"/>      link
<a name="146"/>   end
<a name="147"/>
<a name="148"/>   public override layout()
<a name="149"/>      local c, p1, p2, ex
<a name="150"/>      if /self.sizer.is_horizontal_flag then {
<a name="151"/>         first.x := self.x
<a name="152"/>         sizer.w := sizer.get_preferred_width()
<a name="153"/>         p1 := first.get_preferred_width()
<a name="154"/>         p2 := second.get_preferred_width()
<a name="155"/>         ex := self.w - (sizer.w + p1 + p2)
<a name="156"/>         first.w := p1 + integer(ex * weight)
<a name="157"/>         # Ensure first.w in range that tries to keep both minimum
<a name="158"/>         # values valid.
<a name="159"/>         first.w &lt;:= min_first
<a name="160"/>         first.w &gt;:= self.w - sizer.w - min_second
<a name="161"/>         sizer.x := first.x + first.w
<a name="162"/>         second.x := sizer.x + sizer.w
<a name="163"/>         # Set to ensure the total width is the sum of the parts.
<a name="164"/>         second.w := self.w - sizer.w - first.w
<a name="165"/>         # If either component is hidden, adjust the other to cover
<a name="166"/>         # the full width.
<a name="167"/>         if \first.is_hidden_flag then {
<a name="168"/>            second.x := self.x
<a name="169"/>            second.w := self.w
<a name="170"/>         } else if \second.is_hidden_flag then
<a name="171"/>            first.w := self.w
<a name="172"/>         every c := !self.children do {
<a name="173"/>            c.y := self.y
<a name="174"/>            c.h := self.h
<a name="175"/>            c.layout()
<a name="176"/>         }
<a name="177"/>      } else {
<a name="178"/>         first.y := self.y
<a name="179"/>         sizer.h := sizer.get_preferred_height(self.w)
<a name="180"/>         p1 := first.get_preferred_height(self.w)
<a name="181"/>         p2 := second.get_preferred_height(self.w)
<a name="182"/>         ex := self.h - (sizer.h + p1 + p2)
<a name="183"/>         first.h := p1 + integer(ex * weight)
<a name="184"/>         first.h &lt;:= min_first
<a name="185"/>         first.h &gt;:= self.h - sizer.h - min_second
<a name="186"/>         sizer.y := first.y + first.h
<a name="187"/>         second.y := sizer.y + sizer.h
<a name="188"/>         second.h := self.h - sizer.h - first.h
<a name="189"/>         if \first.is_hidden_flag then {
<a name="190"/>            second.y := self.y
<a name="191"/>            second.h := self.h
<a name="192"/>         } else if \second.is_hidden_flag then
<a name="193"/>            first.h := self.h
<a name="194"/>         every c := !self.children do {
<a name="195"/>            c.x := self.x
<a name="196"/>            c.w := self.w
<a name="197"/>            c.layout()
<a name="198"/>         }
<a name="199"/>      }
<a name="200"/>   end
<a name="201"/>
<a name="202"/>   #
<a name="203"/>   # Set the minimum allowed sizer resize for the left and right (or top
<a name="204"/>   # and bottom) components respectively.  The default for both is zero.
<a name="205"/>   #
<a name="206"/>   public set_min(f, s)
<a name="207"/>      self.min_first := need_integer(f)
<a name="208"/>      self.min_second := need_integer(s)
<a name="209"/>      link
<a name="210"/>   end
<a name="211"/>
<a name="212"/>   #
<a name="213"/>   # Set the proportion of any extra space to allocate to the left/top
<a name="214"/>   # component.  By default zero, ie the right/bottom component gets all
<a name="215"/>   # the extra.
<a name="216"/>   #
<a name="217"/>   public set_weight(w)
<a name="218"/>      self.weight := need_numeric(w)
<a name="219"/>      link
<a name="220"/>   end
<a name="221"/>
<a name="222"/>   #
<a name="223"/>   # If set, then the slider will move in steps of this amount.
<a name="224"/>   #
<a name="225"/>   public set_step(v)
<a name="226"/>      self.step := /v | need_integer(v)
<a name="227"/>      link
<a name="228"/>   end
<a name="229"/>
<a name="230"/>   #
<a name="231"/>   # If this flag is set then whilst the sizer moves, an intermediate bar is
<a name="232"/>   # shown and the `Component`s are not laid out, until the mouse is released.
<a name="233"/>   # This is helpful if the inner `Component`s are expensive to lay out.
<a name="234"/>   #
<a name="235"/>   public set_show_inter(s)
<a name="236"/>      sizer.set_show_inter(s)
<a name="237"/>      link
<a name="238"/>   end
<a name="239"/>
<a name="240"/>   public on_sizer_press(ev)
<a name="241"/>      if /self.sizer.is_horizontal_flag then {
<a name="242"/>         start_size_first := first.w
<a name="243"/>         start_size_second := second.w
<a name="244"/>         # These same limits are actually also imposed by layout() above, but
<a name="245"/>         # setting here prevents the w_spec values going outside the range too, and
<a name="246"/>         # looks better with an inter style sizer, so that the inter bar stays in range.
<a name="247"/>         sizer.set_range(self.min_first, self.w - self.min_second - sizer.w)
<a name="248"/>      } else {
<a name="249"/>         start_size_first := first.h
<a name="250"/>         start_size_second := second.h
<a name="251"/>         sizer.set_range(self.min_first, self.h - self.min_second - sizer.h)
<a name="252"/>      }
<a name="253"/>   end
<a name="254"/>
<a name="255"/>   public on_sizer_drag(ev)
<a name="256"/>      if /sizer.show_inter_flag then
<a name="257"/>         update()
<a name="258"/>   end
<a name="259"/>
<a name="260"/>   public on_sizer_release(ev)
<a name="261"/>      if \sizer.show_inter_flag then
<a name="262"/>         update()
<a name="263"/>   end
<a name="264"/>
<a name="265"/>   public update()
<a name="266"/>      local d
<a name="267"/>      d := sizer.get_delta()
<a name="268"/>      d -:= d % \step
<a name="269"/>      if /self.sizer.is_horizontal_flag then {
<a name="270"/>         first.w_spec := start_size_first + d
<a name="271"/>         second.w_spec := start_size_second - d
<a name="272"/>      } else {
<a name="273"/>         first.h_spec := start_size_first + d
<a name="274"/>         second.h_spec := start_size_second - d
<a name="275"/>      }
<a name="276"/>      layout()
<a name="277"/>      invalidate()
<a name="278"/>   end
<a name="279"/>
<a name="280"/>   # A useful function to dynamically reorient the split (reverse the
<a name="281"/>   # horizontal/vertical orientation).
<a name="282"/>   #
<a name="283"/>   public reorient()
<a name="284"/>      sizer.set_is_horizontal(toggle_flag(sizer.is_horizontal_flag))
<a name="285"/>      if is_live() then {
<a name="286"/>         sizer.reset()
<a name="287"/>         layout()
<a name="288"/>         invalidate()
<a name="289"/>      }
<a name="290"/>      link
<a name="291"/>   end
<a name="292"/>
<a name="293"/>   public override new()
<a name="294"/>      Component.new()
<a name="295"/>      sizer := Sizer()
<a name="296"/>      add(sizer)
<a name="297"/>      sizer.connect(self.on_sizer_drag, Event.SIZER_DRAG)
<a name="298"/>      sizer.connect(self.on_sizer_press, Event.SIZER_PRESS)
<a name="299"/>      sizer.connect(self.on_sizer_release, Event.SIZER_RELEASE)
<a name="300"/>      weight := min_first := min_second := 0
<a name="301"/>      self.set_constraint("x_fill", &amp;yes)
<a name="302"/>      self.set_constraint("y_fill", &amp;yes)
<a name="303"/>      self.set_constraint("x_weight", 1.0)
<a name="304"/>      self.set_constraint("y_weight",  1.0)
<a name="305"/>      return
<a name="306"/>   end
<a name="307"/>end
</pre></body></html>
