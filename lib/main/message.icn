#
# $Id$
#

package mail

import util, io

#
# This class represents an email message
#
# @field content=string: see {set_content}
# @field decoded_content=string: see {set_decoded_content}
# @field content_object=value: see {set_content_object}
# @field date={Time}: see {set_date}
# @field to=value: see {set_to}
# @field reply_to=value: see {set_reply_to}
# @field resent_to=value: see {set_resent_to}
# @field cc=value: see {set_cc}
# @field resent_cc=value: see {set_resent_cc}
# @field bcc=value: see {set_bcc}
# @field resent_bcc=value: see {set_resent_bcc}
# @field from=value: see {set_from}
# @field sender={Mailbox}: see {set_sender}
# @field resent_from=value: see {set_resent_from}
# @field resent_sender={Mailbox}: see {set_resent_sender}
# @field resent_date={Time}: see {set_resent_date}
# @field content_type={ContentType}: see {set_content_type}
# @field content_disposition={ContentDisposition}: see {set_content_disposition}
# @field content_transfer_encoding=string: see {set_content_transfer_encoding}
# @field subject=string: see {set_subject}
#
class Message(SetFields, MimeHeaders)
   private readable 
      content

   #
   # Set the content
   #
   public set_content(s)
      self.content := string(s) | runerr(103, s)
   end

   #
   # Get the content
   #
   public get_content()
      return content
   end

   #
   # Get the decoded content, based on the Content-Transfer-Encoding attribute.
   #
   public get_decoded_content()
      local h

      #
      # Get the handler
      #
      h := get_encoding_handler() | fail

      #
      # Use the handler to convert the data.
      #
      return h.decode_data(self, content)
   end

   #
   # Set the decoded content.  The content itself will then be set based on the
   # Content-Transfer-Encoding.
   #
   public set_decoded_content(s)
      local h

      #
      # Get the handler
      #
      h := get_encoding_handler() | fail

      #
      # Use the handler to convert the data.
      #
      return content := h.encode_data(self, s)
   end

   #
   # Retrieve an object representation of the decoded data, based on
   # the Content-Type attribute.
   #
   public get_content_object()
      local data, h

      data := get_decoded_content() | fail

      #
      # Get the handler
      #
      h := get_type_handler() | fail

      #
      # Use the handler to convert the data.
      #
      return h.convert_to_object(self, data)
   end

   #
   # Set the content from the given object, which must be consistent
   # with the Content-Type specified in the message.
   #
   public set_content_object(o)
      local data, h

      #
      # Get the handler
      #
      h := get_type_handler() | fail

      data := h.convert_from_object(self, o) | fail

      return set_decoded_content(data)
   end

   #
   # Helper to get the specified encoding, or the standard default.
   # 
   private get_actual_content_transfer_encoding()
      if has_header("Content-Transfer-Encoding") then
         return get_content_transfer_encoding()
      else
         return "7bit"
   end

   #
   # Helper to get the specified content type, or the standard default.
   # 
   private get_actual_content_type()
      if has_header("Content-Type") then
         return get_content_type()
      else
         return ContentType.parse("text/plain")
   end

   #
   # Helper to get the appropriate encoding handler
   # 
   private get_encoding_handler()
      local enc, e
      enc := get_actual_content_transfer_encoding()
      every e := !EncodingHandler.ENCODING_HANDLERS do {
         if e.can_handle(enc) then
            return e
      }
      return error("Unknown or unhandled encoding")
   end

   #
   # Helper to get the appropriate type handler
   #
   private get_type_handler()
      local ct, e
      ct := get_actual_content_type() | fail
      every e := !TypeHandler.TYPE_HANDLERS do {
         if e.can_handle(ct) then
            return e
      }
      return error("Unknown or unhandled content type")
   end

   #
   # Return a string representation of the message in RFC822 format.
   # 
   public to_rfc822()
      local b
      b := RamStream()
      to_rfc822_stream(b)
      return b.done()
   end

   #
   # Output the message in RFC822 format to the given stream.
   #
   public to_rfc822_stream(f)
      local h, t
      every h := !headers.sort() do {
         every t := !h[2] do
            f.writes(fold(h[1] || ": " || t), "\r\n") | fail
      }
      f.writes("\r\n", content) | fail
      return
   end

   #
   # Fold a line into several CRLF lines of <= 78 chars
   # 
   public static fold(s)
      local res, l, t

      # Drop trailing w/s
      while any(' \t', s[-1]) do
         s[-1] := ""

      # Check for simple quick case
      if *s <= 78 then
         return s

      res := ""
      # l is the current line
      l := ""
      s ? repeat {
         #
         # Get a block of text being w/s followed by non-ws eg
         #             "   here"
         #
         t := tab(many(' \t')) | ""
         t ||:= tab(upto(' \t') | 0)
         if *l + *t > 78 then {
            # Too big, so start a new line.
            res := fold1(res, l)
            l := t
         } else {
            # Not too big, so continue this line.
            l ||:= t
         }
         if pos(0) then {
            # Add any remainder.
            return fold1(res, l)
         }
      }
   end

   #
   # 
   private static fold1(res, l)
      if *l > 0 then {
         if *res > 0 then {
            res ||:= "\r\n"
         }
         res ||:= l
      }
      return res
   end

   #
   # Debug output function
   #
   public show_message()
      show_headers()
      write()
      write(content)
   end

   #
   # Parse the given raw data into a Message.
   #
   public static parse(data)
      local s, p, m
      m := Message()
      p := RFC822Parser()
      data ? {
         while s := tab(find("\r\n")) do {
            move(2)
            if *s = 0 then {
               m.content := tab(0)
               return m
            }
            while any(' \t') do {
               s ||:= tab(find("\r\n")) | return error("Unexpected end of message")
               move(2)
            }
            p.parse_field(s, m) | fail
         }
         return error("Unexpected end of message")
      }
   end

   #
   # Turn the given parameter into a delim-separated list of addresses.  The
   # param is either an {Address} or a list of {Address}es.
   # 
   private catenate_addresses(a, delim)
      local s, e
      if type(a) == "list" then {
         s := ""
         every e := !a do {
            if *s > 0 then 
               s ||:= delim
            s ||:= e
         }
         return s
      }
      else {
         return a.to_rfc822()
      }
   end

   # 
   private header_error(h, s)
      return error("Error parsing " || h || " header: " || image(s) || ": " || &why)
   end

   #
   # Get the "Date" header as a {Time} object.
   # @fail if the "Date" header is absent or cannot be parsed.
   # @return a {Time} instance
   #
   public get_date()
      local s, p
      s := get_first_header("Date") | return error("Missing header: Date")
      p := RFC822Parser()
      return p.parse_date_time(s) | header_error("Date", s)
   end

   #
   # Set the "Date" header from the given {Time} object.
   # @param t the {Time} from which to set the date field.
   #
   public set_date(t)
      set_header("Date", t.to_rfc822())
   end

   #
   # Get the "To" header(s) as a list of {Address} instances.
   # @return a list of {Address} instances
   # @fail if the "To" header is absent or cannot be parsed as a 
   # @     list of {Address}es
   #
   public get_to()
      local s, p
      s := get_catenated_headers("To") | return error("Missing header: To")
      p := RFC822Parser()
      return p.parse_address_list(s) | header_error("To", s)
   end

   #
   # Set the "To" header from the given parameter, which may be either
   # a single {Address}, or a list of several {Address}es.  To add further "To"
   # headers, use {add_to}.
   # @param a an {Address} or a list of {Address}es.
   #
   public set_to(a)
      set_header("To", catenate_addresses(a))
   end

   #
   # Add a "To" header from the given parameter, which may be either
   # a single {Address}, or a list of several {Address}es.
   # @param a an {Address} or a list of {Address}es.
   #
   public add_to(a)
      add_header("To", catenate_addresses(a))
   end

   #
   # Get the "Reply-To" header(s) as a list of {Address} instances.
   # @return a list of {Address} instances
   # @fail if the "Reply-To" header is absent or cannot be parsed as a 
   # @     list of {Address}es
   #
   public get_reply_to()
      local s, p
      s := get_catenated_headers("Reply-To") | return error("Missing header: Reply-To")
      p := RFC822Parser()
      return p.parse_address_list(s, 1) | header_error("Reply-To", s)
   end

   #
   # Set the "Reply-To" header from the given parameter, which may be either
   # a single {Address}, or a list of several {Address}es.  To add further "Reply-To"
   # headers, use {add_reply_to}.
   # @param a an {Address} or a list of {Address}es.
   #
   public set_reply_to(a)
      set_header("Reply-To", catenate_addresses(a))
   end

   #
   # Add a "Reply-To" header from the given parameter, which may be either
   # a single {Address}, or a list of several {Address}es.
   # @param a an {Address} or a list of {Address}es.
   #
   public add_reply_to(a)
      add_header("Reply-To", catenate_addresses(a))
   end

   #
   # Get the "Resent-To" header(s) as a list of {Address} instances.
   # @return a list of {Address} instances
   # @fail if the "Resent-To" header is absent or cannot be parsed as a 
   # @     list of {Address}es
   #
   public get_resent_to()
      local s, p
      s := get_catenated_headers("Resent-To") | return error("Missing header: Resent-To")
      p := RFC822Parser()
      return p.parse_address_list(s) | header_error("Resent-To", s)
   end

   #
   # Set the "Resent-To" header from the given parameter, which may be either
   # a single {Address}, or a list of several {Address}es.  To add further "Resent-To"
   # headers, use {add_resent_to}.
   # @param a an {Address} or a list of {Address}es.
   #
   public set_resent_to(a)
      set_header("Resent-To", catenate_addresses(a))
   end

   #
   # Add a "Resent-To" header from the given parameter, which may be either
   # a single {Address}, or a list of several {Address}es.
   # @param a an {Address} or a list of {Address}es.
   #
   public add_resent_to(a)
      add_header("Resent-To", catenate_addresses(a))
   end

   #
   # Get the "cc" header(s) as a list of {Address} instances.
   # @return a list of {Address} instances
   # @fail if the "bcc" header is absent or cannot be parsed as a 
   # @     list of {Address}es
   #
   public get_cc()
      local s, p
      s := get_catenated_headers("cc") | return error("Missing header: cc")
      p := RFC822Parser()
      return p.parse_address_list(s) | header_error("cc", s)
   end

   #
   # Set the "cc" header from the given parameter, which may be either
   # a single {Address}, or a list of several {Address}es.  To add further "cc"
   # headers, use {add_cc}.
   # @param a an {Address} or a list of {Address}es.
   #
   public set_cc(a)
      set_header("cc", catenate_addresses(a))
   end

   #
   # Add a "cc" header from the given parameter, which may be either
   # a single {Address}, or a list of several {Address}es.
   # @param a an {Address} or a list of {Address}es.
   #
   public add_cc(a)
      add_header("cc", catenate_addresses(a))
   end

   #
   # Get the "Resent-cc" header(s) as a list of {Address} instances.
   # @return a list of {Address} instances
   # @fail if the "Resent-cc" header is absent or cannot be parsed as a 
   # @     list of {Address}es
   #
   public get_resent_cc()
      local s, p
      s := get_catenated_headers("Resent-cc") | return error("Missing header: Resent-cc")
      p := RFC822Parser()
      return p.parse_address_list(s) | header_error("Resent-cc", s)
   end

   #
   # Set the "Resent-cc" header from the given parameter, which may be either
   # a single {Address}, or a list of several {Address}es.  To add further "Resent-cc"
   # headers, use {add_resent_cc}.
   # @param a an {Address} or a list of {Address}es.
   #
   public set_resent_cc(a)
      set_header("Resent-cc", catenate_addresses(a))
   end

   #
   # Add a "Resent-cc" header from the given parameter, which may be either
   # a single {Address}, or a list of several {Address}es.
   # @param a an {Address} or a list of {Address}es.
   #
   public add_resent_cc(a)
      add_header("Resent-cc", catenate_addresses(a))
   end

   #
   # Get the "bcc" header(s) as a list of {Address} instances.
   # @return a list of {Address} instances
   # @fail if the "bcc" header is absent or cannot be parsed as a 
   # @     list of {Address}es
   #
   public get_bcc()
      local s, p
      s := get_catenated_headers("bcc") | return error("Missing header: bcc")
      p := RFC822Parser()
      return p.parse_address_list(s, 1) | header_error("bcc", s)
   end

   #
   # Set the "bcc" header from the given parameter, which may be either
   # a single {Address}, or a list of several {Address}es.  To add further "bcc"
   # headers, use {add_bcc}.
   # @param a an {Address} or a list of {Address}es.
   #
   public set_bcc(a)
      set_header("bcc", catenate_addresses(a))
   end

   #
   # Add a "bcc" header from the given parameter, which may be either
   # a single {Address}, or a list of several {Address}es.
   # @param a an {Address} or a list of {Address}es.
   #
   public add_bcc(a)
      add_header("bcc", catenate_addresses(a))
   end

   #
   # Get the "Resent-bcc" header(s) as a list of {Address} instances.
   # @return a list of {Address} instances
   # @fail if the "Reset-bcc" header is absent or cannot be parsed as a 
   # @     list of {Address}es
   #
   public get_resent_bcc()
      local s, p
      s := get_catenated_headers("Resent-bcc") | return error("Missing header: Resent-bcc")
      p := RFC822Parser()
      return p.parse_address_list(s, 1) | header_error("Resent-bcc", s)
   end

   #
   # Set the "Resent-bcc" header from the given parameter, which may be either
   # a single {Address}, or a list of several {Address}es.  To add further "Resent-bcc"
   # headers, use {add_resent_bcc}.
   # @param a an {Address} or a list of {Address}es.
   #
   public set_resent_bcc(a)
      set_header("Resent-bcc", catenate_addresses(a))
   end

   #
   # Add a "Resent-bcc" header from the given parameter, which may be either
   # a single {Address}, or a list of several {Address}es.
   # @param a an {Address} or a list of {Address}es.
   #
   public add_resent_bcc(a)
      add_header("Resent-bcc", catenate_addresses(a))
   end

   #
   # Get the "From" header(s) as a list of {Mailbox} instances.
   # @return a list of {Mailbox} instances
   # @fail if the "From" header is absent or cannot be parsed as a 
   # @     list of {Mailbox}es
   #
   public get_from()
      local s, p
      s := get_catenated_headers("From") | return error("Missing header: From")
      p := RFC822Parser()
      return p.parse_mailbox_list(s) | header_error("From", s)
   end

   #
   # Set the "From" header from the given parameter, which may be either
   # a single {Mailbox}, or a list of several {Mailbox}es.  To add further "From"
   # headers, use {add_from}.
   # @param a an {Mailbox} or a list of {Mailbox}es.
   #
   public set_from(m)
      set_header("From", catenate_addresses(m))
   end

   #
   # Add a "From" header from the given parameter, which may be either
   # a single {Mailbox}, or a list of several {Mailbox}es.
   # @param a an {Mailbox} or a list of {Mailbox}es.
   #
   public add_from(m)
      add_header("From", catenate_addresses(m))
   end

   #
   # Get the "Sender" header as a {Mailbox} instance.
   # @return a {Mailbox}
   # @fail if the "Sender" header is absent or cannot be parsed as a 
   # @     {Mailbox}
   #
   public get_sender()
      local s, p
      s := get_first_header("Sender") | return error("Missing header: Sender")
      p := RFC822Parser()
      return p.parse_mailbox(s) | header_error("Sender", s)
   end

   #
   # Set the "Sender" header from the given {Mailbox} instance.
   # @param m a {Mailbox}
   #
   public set_sender(m)
      set_header("Sender", m.to_rfc822())
   end

   #
   # Add a "Resent-From" header from the given parameter, which may be either
   # a single {Mailbox}, or a list of several {Mailbox}es.
   # @param a an {Mailbox} or a list of {Mailbox}es.
   #
   public get_resent_from()
      local s, p
      s := get_catenated_headers("Resent-From") | return error("Missing header: Resent-From")
      p := RFC822Parser()
      return p.parse_mailbox_list(s) | header_error("Resent-From", s)
   end

   #
   # Set the "Resent-From" header from the given parameter, which may be either
   # a single {Mailbox}, or a list of several {Mailbox}es.  To add further "Resent-From"
   # headers, use {add_resent_from}.
   # @param a an {Mailbox} or a list of {Mailbox}es.
   #
   public set_resent_from(m)
      set_header("Resent-From", catenate_addresses(m))
   end

   #
   # Add a "Resent-From" header from the given parameter, which may be either
   # a single {Mailbox}, or a list of several {Mailbox}es.
   # @param a an {Mailbox} or a list of {Mailbox}es.
   #
   public add_resent_from(m)
      add_header("Resent-From", catenate_addresses(m))
   end

   #
   # Get the "Resent-Sender" header as a {Mailbox} instance.
   # @return a {Mailbox}
   # @fail if the "Resent-Sender" header is absent or cannot be parsed as a 
   # @     {Mailbox}
   #
   public get_resent_sender()
      local s, p
      s := get_first_header("Resent-Sender") | return error("Missing header: Resent-Sender")
      p := RFC822Parser()
      return p.parse_mailbox(s) | header_error("Resent-Sender", s)
   end

   #
   # Set the "Resent-Sender" header from the given {Mailbox} instance.
   # @param m a {Mailbox}
   #
   public set_resent_sender(m)
      set_header("Resent-Sender", m.to_rfc822())
   end

   #
   # Get the "Resent-Date" header as a {Time} instance.
   # @return a {Time}
   #
   public get_resent_date()
      local s, p
      s := get_first_header("Resent-Date") | return error("Missing header: Resent-Date")
      p := RFC822Parser()
      return p.parse_date_time(s) | header_error("Resent-Date", s)
   end

   #
   # Set the "Resent-Date" header from the given {Time} instance.
   # @param t a {Time}
   #
   public set_resent_date(t)
      set_header("Resent-Date", t.to_rfc822())
   end

   #
   # Get the "Content-Type" header as a {ContentType} intance.
   # @return a {ContentType}
   # @fail if the "Content-Type" header is absent or cannot be parsed.
   #
   public get_content_type()
      local s, p
      s := get_first_header("Content-Type") | return error("Missing header: Content-Type")
      p := RFC822Parser()
      return p.parse_content_type(s) | header_error("Content-Type", s)
   end

   #
   # Set the "ContentType" header from a {ContentType} instance.
   # @param ct a {ContentType}
   #
   public set_content_type(ct)
      set_header("Content-Type", ct.to_rfc1521())
   end

   #
   # Get the "Content-Disposition" header as a {ContentDisposition} intance.
   # @return a {ContentDisposition}
   # @fail if the "Content-Disposition" header is absent or cannot be parsed.
   #
   public get_content_disposition()
      local s, p
      s := get_first_header("Content-Disposition") | return error("Missing header: Content-Disposition")
      p := RFC822Parser()
      return p.parse_content_disposition(s) | header_error("Content-Disposition", s)
   end

   #
   # Set the "ContentDisposition" header from a {ContentDisposition} instance.
   # @param cd a {ContentDisposition}
   #
   public set_content_disposition(cd)
      set_header("Content-Disposition", cd.to_rfc1521())
   end

   #
   # Get the "Content-Transfer-Encoding" field, as a string, or fail if it is
   # absent or an invalid value.
   # @return a string
   #
   public get_content_transfer_encoding()
      local s, p
      s := get_first_header("Content-Transfer-Encoding") | return error("Missing header: Content-Transfer-Encoding")
      p := RFC822Parser()
      return p.parse_content_transfer_encoding(s) | header_error("Content-Transfer-Encoding", s)
   end

   #
   # Set the "Content-Transfer-Encoding" from the given string.
   #
   public set_content_transfer_encoding(s)
      set_header("Content-Transfer-Encoding", s)
   end

   #
   # Set the subject to the given string.
   # @param s a string
   #
   public set_subject(s)
      set_header("Subject", s)
   end

   #
   # Get the subject
   #
   public get_subject()
      return get_first_header("Subject")
   end

   public set_one(f)
      case f.attr of {
         "content": set_content(f.string_val())
         "decoded_content": set_decoded_content(f.string_val())
         "content_object": set_content_object(f.val)
         "date": set_date(f.object_val(Time))
         "to": set_to(f.val)
         "reply_to": set_reply_to(f.val)
         "resent_to": set_resent_to(f.val)
         "cc": set_cc(f.val)
         "resent_cc": set_resent_cc(f.val)
         "bcc": set_bcc(f.val)
         "resent_bcc": set_resent_bcc(f.val)
         "from": set_from(f.val)
         "sender": set_sender(f.object_val(Mailbox))
         "resent_from": set_resent_from(f.val)
         "resent_sender": set_resent_sender(f.object_val(Mailbox))
         "resent_date": set_resent_date(f.object_val(Time))
         "content_type": set_content_type(f.object_val(ContentType))
         "content_disposition": set_content_disposition(f.object_val(ContentDisposition))
         "content_transfer_encoding": set_content_transfer_encoding(f.string_val())
         "subject": set_subject(f.string_val())
         default: fail
      }
      return
   end

   public new(a[])
      cast(self,MimeHeaders).new()
      content := ""
      set_fields(a)
      return
   end
end

#
# Utility to get all the mailboxes from a list of Addresses, which will
# contain either Mailboxes or Groups.
#
procedure get_all_mailboxes(l)
   local res
   res := []
   every put(res, (!l).generate_mailboxes())
   return res
end
