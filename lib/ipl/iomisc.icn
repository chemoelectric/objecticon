package ipl.io

import
   io(Files, FileOpt, FileStream, DirStream, FilePath, stop), 
   util(use),
   exception(throw)

#
# Return an open file to /dev/null.  The returned file is shared
# and so should not be closed.
#
procedure get_null()
   static nul
   initial
      nul := FileStream(Files.NULL_FILE, FileOpt.RDWR) | stop("Can't open " || Files.NULL_FILE || ": ", &why)
   return nul
end

#
# Return an open file to /dev/zero.  The returned file is shared
# and so should not be closed.
#
procedure get_zero()
   static zero
   initial
      zero := FileStream("/dev/zero", FileOpt.RDWR) | stop("Can't open /dev/zero: ", &why)
   return zero
end

package record Msg(file, revert)

package procedure dir_recurse2(s, f, revert, strict)
   local p, f2, l
   coact(Msg(f, &current), revert)
   p := FilePath(f)
   repeat {
      l := s.read_line() | fail
      if /l then
         return
      if Files.is_relative_dir(l) then
         next
      f2 := p.child(l).str() 
      if Files.is_directory(f2) then
         dir_recurse1(f2, revert, strict)
      else
         coact(Msg(f2, &current), revert)
   }
end

package procedure dir_recurse1(f, revert, strict)
   local s
   use {
      s := DirStream(f),
      dir_recurse2(s, f, revert, strict)
   } | if \strict then throw("Failed to read dir " || f || ": " || &why)
end

#
# Recursively traverse directory `f`, generating all the filenames
# (including directories).  If this generator isn't used to
# exhaustion, the call must be wrapped in the `util.clean()` function,
# in order to close all outstanding files.  If the `strict` flag is
# set, then on an error reading a directory, an exception is thrown.
# In this case the call should also be enclosed with one of the try
# procedures.
#
# @example
# @   clean{try1{{
# @      every f := dir_recurse(d, &yes) \ 50 do
# @         write("got ", f)
# @   }}} | write("Problem: ", &why)
#
procedure dir_recurse(f, strict)
   local v, here, e
   here := &current
   e := create dir_recurse1(f, here, strict)
   v := @e | fail
   repeat {
      suspend v.file
      v := coact(, v.revert) | fail
   }
end
