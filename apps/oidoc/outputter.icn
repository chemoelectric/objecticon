import
   lang(Class, Text),
   parser(ClassSymbol, DeferredMethod, Tree, ULocal,
          UMethod, ProcedureSymbol, RecordSymbol, GlobalSymbol),
   ipl.scan(many0),
   ipl.sort(qsort),
   datastruct(SortTable),
   util(Yes, toggle_flag)

abstract class Outputter()
   public static const
      WHITESPACE,
      ID_CHAR

   protected const
      symbol_table,
      opts

   private
      ul, ol, li, pre, bar, bold, underline, italic

   private static init()
      WHITESPACE := ' \t'
      ID_CHAR := &ucase ++ &lcase ++ '_0987654321'
   end

   protected static name_sort(a, b)
      return Text.consistent_compare(a.name, b.name)
   end

   protected get_packages()
      local ps, e
      ps := SortTable(, Text.consistent_compare)
      every e := symbol_table.gen_symbols() do
         ps.insert(get_package(e))
      suspend ps.key()
   end

   protected get_package(e)
      return \(\e.scanned_file).pack | "default"
   end

   protected should_print_symbol(e)
      return should_print_package(get_package(e))
   end

   protected should_print_package(p)
      return (p == "default") | /opts["r"] | member(arg_packs, p)
   end

   protected get_symbols_in(p)
      local l, e
      if p == "default" then
         p := &null
      l := []
      every e := symbol_table.gen_symbols() do {
         if (\e.scanned_file).pack === p then
            put(l, e)
      }
      qsort(l, name_sort)
      suspend !l
   end

   protected get_classes_in(p)
      local e
      every e := get_symbols_in(p) do
         if is(e, ClassSymbol) then
            suspend e
   end

   protected get_others_in(p)
      local e
      every e := get_symbols_in(p) do
         if not is(e, ClassSymbol) then
            suspend e
   end

   protected get_param_string(obj)
      local s, a, has_self
      s := ""
      if is(obj, Tree) then {
         every a := obj.get_args().gen() do
            s ||:= a.str() || ", "
         s[-2:0] := ""
         if obj.has_varargs() then
            s ||:= "[]"
      } else {
         # A non-static method will have an implicit self param.
         if is(obj, UMethod) & iand(obj.flags, Class.Static) = 0 then
            has_self := &yes
         every a := obj.get_locals() do {
            if iand(a.flags, ULocal.Argument) ~= 0 then {
               if \has_self then
                  has_self := &null
               else
                  s ||:= a.id || ", "
            }
         }
         s[-2:0] := ""
         if iand(obj.locals[-1].flags, ULocal.Vararg) ~= 0 then
            s ||:= "[]"
      }
      return s
   end

   protected get_record_fields(obj)
      suspend if is(obj, Tree) then
         obj.get_ids().gen().str()
      else
         obj.get_fields()
   end

   protected get_record_field_string(obj)
      local s
      s := ""
      every s ||:= get_record_fields(obj) || ", "
      s[-2:0] := ""
      return s
   end

   protected get_class_prefix(c)
      local s
      s := ""
      if c.has_package_flag() then
         s ||:= "package "
      if c.is_final() then
         s ||:= "final "
      if c.is_abstract() then
         s ||:= "abstract "
      s ||:= "class"
      return s
   end

   protected get_top_level_type(c)
      local s
      s := ""
      if c.has_package_flag() then
         s ||:= "package "
      if is(c, GlobalSymbol) & c.has_readable_flag() then
         s ||:= " readable "
      if is(c, ClassSymbol) then {
         if c.is_final() then
            s ||:= "final "
         if c.is_abstract() then
            s ||:= "abstract "
      }
      s ||:= case classof(c) of {
         ProcedureSymbol : "procedure"
         RecordSymbol : "record"
         GlobalSymbol : "global"
         ClassSymbol : "class"
         default : syserr("Unknown type")
      }
      return s
   end

   protected get_access_string(obj)
      local s
      s := ""
      if is(obj, Tree) then {
         every s ||:= obj.get_access().gen().str() || " "
         if is(obj, DeferredMethod) then
            s ||:= obj.get_defer_type().str() || " "
      } else {
         if iand(obj.flags, Class.Private) ~= 0 then
            s ||:= "private "
         if iand(obj.flags, Class.Public) ~= 0 then
            s ||:= "public "
         if iand(obj.flags, Class.Protected) ~= 0 then
            s ||:= "protected "
         if iand(obj.flags, Class.Package) ~= 0 then
            s ||:= "package "
         if iand(obj.flags, Class.Static) ~= 0 then
            s ||:= "static "
         if iand(obj.flags, Class.Const) ~= 0 then
            s ||:= "const "
         if iand(obj.flags, Class.Readable) ~= 0 then
            s ||:= "readable "
         if iand(obj.flags, Class.Abstract) ~= 0 then
            s ||:= "abstract "
         if iand(obj.flags, Class.Native) ~= 0 then
            s ||:= "native "
         if iand(obj.flags, Class.Defer) ~= 0 then
            s ||:= "defer "
         if iand(obj.flags, Class.Final) ~= 0 then
            s ||:= "final "
      }
      s[-1] := ""
      return s
   end

   private markdown_line(s)
      local t
      s ? {
         while t := tab(upto('/`{*_~<')) do {
            output_fragment(t)
            if ="`" then {
               t := tab(upto('`\'') | 0)
               if move(1)\1 == "`" then
                  output_link(t)
               else
                  output_code(t)
            } else if ="{" then {
               t := tab(upto('}') | 0)
               move(1)
               output_link(t)
            } else if ="~~" then {
               t := tab(find("~~") | 0)
               move(2)
               output_code(t)
            } else if ="**" then {
               if /bold then
                  begin_bold()
               else
                  end_bold()
               bold := toggle_flag(bold)
            } else if not any(':/',, &pos - 1) & ="//" then {    # Try to avoid clashes with urls... http:// or file:///
               if /italic then
                  begin_italic()
               else
                  end_italic()
               italic := toggle_flag(italic)
            } else if ="__" then {
               if /underline then
                  begin_underline()
               else
                  end_underline()
               underline := toggle_flag(underline)
            } else if ="<" & match("http:"|"https:"|"file:"|"ftp:") then {
               t := tab(find(">") | 0)
               move(1)
               output_anchor(t)
            } else {
               t := move(1)
               output_fragment(t)
            }
         }
         t := tab(0)
         output_fragment(t)
      }
      # Two or more spaces at the end of a line indicate a line break.
      end_line(Yes{s[-2:0] == "  "})
      return self
   end

   private close_ul()
      if \ul then {
         end_ul()
         ul := &null
      }
   end

   private close_ol()
      if \ol then {
         end_ol()
         ol := &null
      }
   end

   private close_li()
      if \li then {
         end_li()
         li := &null
      }
   end

   private close_pre()
      if \pre then {
         end_pre()
         pre := &null
      }
   end

   private close_bar()
      if \bar then {
         end_bar()
         bar := &null
      }
   end

   private close_fonts()
      if \bold then {
         end_bold()
         bold := &null
      }
      if \underline then {
         end_underline()
         underline := &null
      }
      if \italic then {
         end_italic()
         italic := &null
      }
   end

   protected markdown(l)
      local pre_mark, s
      every !l ? {
         if \pre then {
            if tab(many0(WHITESPACE)) & =pre_mark & pos(0) then
               close_pre()
            else {
               s := tab(0)
               output_pre(s)
            }
         } else {
            tab(many(WHITESPACE))
            if (pre_mark <- tab(many('~'))) & pos(0) then {
               close_bar()
               begin_pre()
               pre := &yes
            } else if ="|" then {
               s := tab(many0(WHITESPACE))
               output_bar(*s)
               markdown_line(tab(0))
               bar := &yes
            } else if ="*" & tab(many(WHITESPACE)) then {
               close_bar()
               close_li()
               if /ul then {
                  close_ol()
                  begin_ul()
                  ul := &yes
               }
               begin_li()
               li := &yes
               markdown_line(tab(0))
            } else if tab(many(&digits)) & ="." & tab(many(WHITESPACE)) then {
               close_bar()
               close_li()
               if /ol then {
                  close_ul()
                  begin_ol()
                  ol := &yes
               }
               begin_li()
               li := &yes
               markdown_line(tab(0))
            } else if pos(0) then {
               close_bar()
               close_li()
               close_ul()
               close_ol()
               new_para()
            } else {
               close_bar()
               markdown_line(tab(0))
            }
         }
      }
      close_pre()
      close_bar()
      close_li()
      close_ul()
      close_ol()
      close_fonts()
      return self
   end

   protected abstract output_fragment(s)
   protected abstract output_link(s)
   protected abstract output_code(s)
   protected abstract output_anchor(s)
   protected abstract end_line(fl)
   protected abstract begin_pre()
   protected abstract output_pre(s)
   protected abstract end_pre()
   protected abstract output_bar(n)
   protected abstract end_bar()
   protected abstract begin_ul()
   protected abstract end_ul()
   protected abstract begin_ol()
   protected abstract end_ol()
   protected abstract begin_li()
   protected abstract end_li()
   protected abstract new_para()
   protected abstract begin_bold()
   protected abstract end_bold()
   protected abstract begin_underline()
   protected abstract end_underline()
   protected abstract begin_italic()
   protected abstract end_italic()

   public new(opts, symbol_table)
      self.opts := opts
      self.symbol_table := symbol_table
      return
   end
end
