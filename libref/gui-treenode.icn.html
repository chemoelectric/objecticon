<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>treenode.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: treenode.icn 7416 2019-01-25 17:16:59Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package gui
<a name="10"/>
<a name="11"/>import util, ipl.pdco, ipl.lists
<a name="12"/>
<a name="13"/>#
<a name="14"/># This class represents a node in a `Tree` object.
<a name="15"/>#
<a name="16"/>class TreeNode()
<a name="17"/>   public 
<a name="18"/>      label,
<a name="19"/>      icon_paint,
<a name="20"/>      always_expandable_flag,
<a name="21"/>      depth,
<a name="22"/>      is_expanded_flag,
<a name="23"/>      children,
<a name="24"/>      draw_line,
<a name="25"/>      parent
<a name="26"/>
<a name="27"/>   #
<a name="28"/>   # Traverse all the `TreeNode`s in this subtree, including this
<a name="29"/>   # `TreeNode`, in preorder ordering.
<a name="30"/>   #
<a name="31"/>   public traverse_all_preorder()
<a name="32"/>      coact(self)
<a name="33"/>      every (!children).traverse_all_preorder()
<a name="34"/>   end
<a name="35"/>
<a name="36"/>   #
<a name="37"/>   # Traverse all the `TreeNode`s in this subtree, including this
<a name="38"/>   # `TreeNode`, in postorder ordering.
<a name="39"/>   #
<a name="40"/>   public traverse_all_postorder()
<a name="41"/>      every (!children).traverse_all_postorder()
<a name="42"/>      coact(self)
<a name="43"/>   end
<a name="44"/>
<a name="45"/>   #
<a name="46"/>   # Traverse all the open `TreeNode`s in this subtree, including this
<a name="47"/>   # `TreeNode`, in preorder ordering.
<a name="48"/>   #
<a name="49"/>   public traverse_open_preorder()
<a name="50"/>      coact(self)
<a name="51"/>      if \self.is_expanded_flag then
<a name="52"/>         every (!children).traverse_open_preorder()
<a name="53"/>   end
<a name="54"/>
<a name="55"/>   #
<a name="56"/>   # Traverse all open `TreeNode`s in this subtree, including this
<a name="57"/>   # `TreeNode`, in postorder ordering.
<a name="58"/>   #
<a name="59"/>   public traverse_open_postorder()
<a name="60"/>      if \self.is_expanded_flag then
<a name="61"/>         every (!children).traverse_open_postorder()
<a name="62"/>      coact(self)
<a name="63"/>   end
<a name="64"/>
<a name="65"/>   #
<a name="66"/>   # Expand all the `TreeNode`s below this node.  Nodes with no children
<a name="67"/>   # are not expanded unless the force flag is set to &amp;yes.
<a name="68"/>   #
<a name="69"/>   public expand(force)
<a name="70"/>      local n
<a name="71"/>      every n := Seq{traverse_all_postorder()} do
<a name="72"/>         if \force | *n.children &gt; 0 then
<a name="73"/>            n.is_expanded_flag := &amp;yes
<a name="74"/>      link
<a name="75"/>   end
<a name="76"/>
<a name="77"/>   #
<a name="78"/>   # This method expands the path from this node to the root,
<a name="79"/>   # thereby ensuring it is visible.  This node itself is not
<a name="80"/>   # expanded, only its parents.
<a name="81"/>   #
<a name="82"/>   public expand_to_root()
<a name="83"/>      local n
<a name="84"/>      n := self
<a name="85"/>      while n := n.get_parent() do
<a name="86"/>         n.set_expanded(&amp;yes)
<a name="87"/>      link
<a name="88"/>   end
<a name="89"/>
<a name="90"/>   #
<a name="91"/>   # Set the label for this node.
<a name="92"/>   #
<a name="93"/>   public set_label(x)
<a name="94"/>      self.label := x
<a name="95"/>      link
<a name="96"/>   end
<a name="97"/>
<a name="98"/>   #
<a name="99"/>   # Return the label
<a name="100"/>   #
<a name="101"/>   public get_label()
<a name="102"/>      return self.label
<a name="103"/>   end
<a name="104"/>
<a name="105"/>   # Set the icons for this node, as three `Paint` instances.  The
<a name="106"/>   # first is displayed if the `TreeNode` is open and has children,
<a name="107"/>   # the second is displayed if the `TreeNode` is closed and has
<a name="108"/>   # children, and the third is displayed if the node has no children.
<a name="109"/>   #
<a name="110"/>   # Note that these instances are neither initialized or finalized by
<a name="111"/>   # this class (nor by `Tree`) - that must be done externally by the
<a name="112"/>   # owner.  (This does mean many nodes can share the same instance
<a name="113"/>   # however).
<a name="114"/>   #
<a name="115"/>   public set_icon_paint(i1, i2, i3)
<a name="116"/>      self.icon_paint := [i1, i2, i3]
<a name="117"/>      link
<a name="118"/>   end
<a name="119"/>
<a name="120"/>   #
<a name="121"/>   # Add the given `TreeNode` to this `TreeNode`'s list of children.
<a name="122"/>   # :Parameters :
<a name="123"/>   # :  `n` - The `TreeNode` to add.
<a name="124"/>   # :  `i` - The index to add at; if omitted then the new node
<a name="125"/>   #            is appended to the end.
<a name="126"/>   # :Fails :
<a name="127"/>   # :  If i is out of range
<a name="128"/>   #
<a name="129"/>   public add(n, i)
<a name="130"/>      /i := 0
<a name="131"/>      insert(self.children, i, n) | fail
<a name="132"/>      n.parent := self
<a name="133"/>      link
<a name="134"/>   end
<a name="135"/>
<a name="136"/>   #
<a name="137"/>   # Get the index of the given child node
<a name="138"/>   #
<a name="139"/>   public get_index(n)
<a name="140"/>      return keyof(self.children, n)
<a name="141"/>   end
<a name="142"/>
<a name="143"/>   #
<a name="144"/>   # Delete the given `TreeNode` from the children.
<a name="145"/>   # :Fails :
<a name="146"/>   # :  If n is not a child of this instance.
<a name="147"/>   #
<a name="148"/>   public remove(n)
<a name="149"/>      return remove_index(get_index(n))
<a name="150"/>   end
<a name="151"/>
<a name="152"/>   #
<a name="153"/>   # Remove the `TreeNode` at the given index from the list of children.
<a name="154"/>   # :Parameters :
<a name="155"/>   # :  `i` - The index
<a name="156"/>   # :Fails :
<a name="157"/>   # :  If i is out of range
<a name="158"/>   #
<a name="159"/>   public remove_index(i)
<a name="160"/>      local c
<a name="161"/>      c := self.children[i] | fail
<a name="162"/>      delete(self.children, i)
<a name="163"/>      c.parent := &amp;null
<a name="164"/>      link
<a name="165"/>   end
<a name="166"/>
<a name="167"/>   #
<a name="168"/>   # Remove all the children.
<a name="169"/>   #
<a name="170"/>   public remove_all()
<a name="171"/>      link remove_list()
<a name="172"/>   end
<a name="173"/>
<a name="174"/>   #
<a name="175"/>   # Move the `TreeNode` to the given index position.
<a name="176"/>   # :Parameters :
<a name="177"/>   # :  `c` - The `TreeNode` to move.
<a name="178"/>   # :  `j` - The new position.
<a name="179"/>   # :Fails :
<a name="180"/>   # :  If c is not a child of this instance, 
<a name="181"/>   #             or j is out of range.
<a name="182"/>   #
<a name="183"/>   public reposition(c, j)
<a name="184"/>      return reposition_index(get_index(c), j)
<a name="185"/>   end
<a name="186"/>
<a name="187"/>   #
<a name="188"/>   # Move the `TreeNode` at position `i` to `j`.
<a name="189"/>   # :Parameters :
<a name="190"/>   # :  `i` - The old position.
<a name="191"/>   # :  `j` - The new position.
<a name="192"/>   # :Fails :
<a name="193"/>   # :  If either index is out of range.
<a name="194"/>   #
<a name="195"/>   public reposition_index(i, j)
<a name="196"/>      link lmove(children, i, j)
<a name="197"/>   end
<a name="198"/>
<a name="199"/>   # Remove the children in the range `i:j`, returning the
<a name="200"/>   # removed children in a list.
<a name="201"/>   # :Parameters :
<a name="202"/>   # :  `i` - The start slice index, default 1
<a name="203"/>   # :  `j` - The end slice index, default 0
<a name="204"/>   # :Fails :
<a name="205"/>   # :  If the range is invalid.
<a name="206"/>   #
<a name="207"/>   #
<a name="208"/>   public remove_list(i, j)
<a name="209"/>      local l
<a name="210"/>      l := lextract(children, i, j) | fail
<a name="211"/>      every (!l).parent := &amp;null
<a name="212"/>      return l
<a name="213"/>   end
<a name="214"/>
<a name="215"/>   # Add all the `TreeNode`s contained in list `l` at index `i`.
<a name="216"/>   #
<a name="217"/>   # :Parameters :
<a name="218"/>   # :  `l` - The list to add
<a name="219"/>   # :  `i` - The index
<a name="220"/>   # :Fails :
<a name="221"/>   # :  If i is out of range
<a name="222"/>   #
<a name="223"/>   public add_list(l, i)
<a name="224"/>      linsert(children, l, i) | fail
<a name="225"/>      every (!l).parent := self
<a name="226"/>      link
<a name="227"/>   end
<a name="228"/>
<a name="229"/>   # Move all the children of `TreeNode` `other`, to this
<a name="230"/>   # `TreeNode`, adding them at index `i`.  `other` will be left empty.
<a name="231"/>   #
<a name="232"/>   # :Parameters :
<a name="233"/>   # :  `other` - The source `TreeNode`.
<a name="234"/>   # :  `i` - The index to add at; if omitted then the new components
<a name="235"/>   #              are appended to the end.
<a name="236"/>   # :Fails :
<a name="237"/>   # :  If i is out of range
<a name="238"/>   #
<a name="239"/>   public move_all(other, i)
<a name="240"/>      return add_list(other.remove_list(), i)
<a name="241"/>   end
<a name="242"/>
<a name="243"/>   #
<a name="244"/>   # Get the parent node, or fail if there is none.
<a name="245"/>   #
<a name="246"/>   public get_parent()
<a name="247"/>      return \self.parent
<a name="248"/>   end
<a name="249"/>
<a name="250"/>   #
<a name="251"/>   # Get the child nodes
<a name="252"/>   #
<a name="253"/>   public get_children()
<a name="254"/>      return children
<a name="255"/>   end
<a name="256"/>
<a name="257"/>   #
<a name="258"/>   # This configures the `TreeNode` so that it is always treated as though it has children
<a name="259"/>   # for display purposes, event though it may in fact have no children.
<a name="260"/>   #
<a name="261"/>   public set_always_expandable(s)
<a name="262"/>      self.always_expandable_flag := need_flag(s)
<a name="263"/>      link
<a name="264"/>   end
<a name="265"/>
<a name="266"/>   #
<a name="267"/>   # Set the expanded flag.  Note that this will not update the GUI, to do that
<a name="268"/>   # call tree.tree_structure_changed() on the tree in which the node resides.
<a name="269"/>   #
<a name="270"/>   public set_expanded(s)
<a name="271"/>      self.is_expanded_flag := need_flag(s)
<a name="272"/>      link
<a name="273"/>   end
<a name="274"/>      
<a name="275"/>   #
<a name="276"/>   # Toggle the opened status of the `TreeNode`. Note that this will not update the GUI, to do that
<a name="277"/>   # call tree.tree_structure_changed() on the tree in which the node resides.
<a name="278"/>   #
<a name="279"/>   public toggle_expanded()
<a name="280"/>      self.is_expanded_flag := toggle_flag(self.is_expanded_flag)
<a name="281"/>      link
<a name="282"/>   end
<a name="283"/>
<a name="284"/>   #
<a name="285"/>   # Succeed iff the node is opened
<a name="286"/>   #
<a name="287"/>   public is_expanded()
<a name="288"/>      succeed \is_expanded_flag
<a name="289"/>   end
<a name="290"/>
<a name="291"/>   #
<a name="292"/>   # Clear all the children
<a name="293"/>   #
<a name="294"/>   public clear_children()
<a name="295"/>      every (!children).parent := &amp;null
<a name="296"/>      clear(children)
<a name="297"/>      link
<a name="298"/>   end
<a name="299"/>
<a name="300"/>   public new()
<a name="301"/>      children := []
<a name="302"/>      return
<a name="303"/>   end
<a name="304"/>end
<a name="305"/>
</pre></body></html>
