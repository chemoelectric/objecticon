#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package xml

import lang

class Tag(Node)
   public name, closed, attributes, empty
   #
   # Set the name of the tag, which is converted to upper case.  Any
   # leading "/" should be omitted.
   #
   public set_name(s) 
      name := map(s, &lcase, &ucase)
   end

   #
   # Succeed if the given tag is a matching closing tag for this tag.
   #
   public balances(other)
      return \other.closed & (name == other.name)
   end

   #
   # Succeed if the tag is a closing tag.
   #
   public is_closed()
      return \closed
   end

   #
   # Indicate that the tag is a closing tag, ie has a leading "/"
   #
   public set_closed()
      closed := 1
   end

   #
   # Succeed if the tag is an empty tag, ie of the form <tag/>.
   #
   public is_empty()
      return \empty
   end

   #
   # Indicate that the tag is an empty tag.
   #
   public set_empty()
      empty := 1
   end

   #
   # Return the attributes map for this tag.
   #
   public get_attributes()
      return attributes
   end

   #
   # Set an attribute for this tag.
   #
   public set_attribute(key, value)
      attributes[map(key, &lcase, &ucase)] := value
   end

   public get_type()
      return "tag"
   end

   public new()
      cast(self,Node).new()
      self.attributes := table()
      return
   end
end


class HtmlParser()
   public doc

   public static const HTML_IDINTRO, HTML_IDCHARS, HTML_KEYCHARS, HTML_VALCHARS, 
      HTML_DELIM, HTML_SPACE, HTML_STANDALONE, HTML_AUTOCLOSE, HTML_ENTITIES, HTML_PUBID_CHAR

   private static init()
      local e

      HTML_SPACE := ' \t\n\r'
      HTML_IDINTRO := &lcase ++ &ucase
      HTML_IDCHARS := HTML_IDINTRO ++ &digits ++ '.-'
      HTML_KEYCHARS := &lcase ++ &ucase ++ "_" ++ &digits
      HTML_VALCHARS := &ascii -- ' \t\n\r>'
      HTML_DELIM := '\"\''
      HTML_PUBID_CHAR := ' \n\r' ++ &lcase ++ &ucase ++ &digits ++ '-\'()+,./:=?;!*#@$_%'
      HTML_STANDALONE := set()
      every insert(HTML_STANDALONE, "IMG" | "BR" | "HR" | "META" | "BASE" | "INPUT" | "AREA" | 
                   "OPTION" | "BASEFONT" | "BGSOUND" | "COL" | "COLGROUP" | "ISINDEX" | 
                   "LINK" | "NEXTID" | "SPACER" | "TBODY" | "TFOOT" | 
                   "THEAD" | "WBR")

      HTML_AUTOCLOSE := set()
      every insert(HTML_AUTOCLOSE, "LI" | "P" | "DD" | "DT" | "FONT")

      HTML_ENTITIES := table()
      every e := ![["amp", "&"], ["lt", "<"], ["gt", ">"], ["quot", "\""],
                   ["nbsp", char(160)], ["iexcl", char(161)], ["cent", char(162)],
                   ["pound", char(163)], ["curren", char(164)], ["yen", char(165)],
                   ["brvbar", char(166)], ["sect", char(167)], ["uml", char(168)],
                   ["copy", char(169)], ["ordf", char(170)], ["laquo", char(171)],
                   ["not", char(172)], ["shy", char(173)], ["reg", char(174)],
                   ["macr", char(175)], ["deg", char(176)], ["plusmn", char(177)],
                   ["sup2", char(178)], ["sup3", char(179)], ["acute", char(180)],
                   ["micro", char(181)], ["para", char(182)], ["middot", char(183)],
                   ["cedil", char(184)], ["sup1", char(185)], ["ordm", char(186)],
                   ["raquo", char(187)], ["frac14", char(188)], ["frac12", char(189)],
                   ["frac34", char(190)], ["iquest", char(191)], ["Agrave", char(192)],
                   ["Aacute", char(193)], ["Acirc", char(194)], ["Atilde", char(195)],
                   ["Auml", char(196)], ["Aring", char(197)], ["AElig", char(198)],
                   ["Ccedil", char(199)], ["Egrave", char(200)], ["Eacute", char(201)],
                   ["Ecirc", char(202)], ["Euml", char(203)], ["Igrave", char(204)],
                   ["Iacute", char(205)], ["Icirc", char(206)], ["Iuml", char(207)],
                   ["ETH", char(208)], ["Ntilde", char(209)], ["Ograve", char(210)],
                   ["Oacute", char(211)], ["Ocirc", char(212)], ["Otilde", char(213)],
                   ["Ouml", char(214)], ["times", char(215)], ["Oslash", char(216)],
                   ["Ugrave", char(217)], ["Uacute", char(218)], ["Ucirc", char(219)],
                   ["Uuml", char(220)], ["Yacute", char(221)], ["THORN", char(222)],
                   ["szlig", char(223)], ["agrave", char(224)], ["aacute", char(225)],
                   ["acirc", char(226)], ["atilde", char(227)], ["auml", char(228)],
                   ["aring", char(229)], ["aelig", char(230)], ["ccedil", char(231)],
                   ["egrave", char(232)], ["eacute", char(233)], ["ecirc", char(234)],
                   ["euml", char(235)], ["igrave", char(236)], ["iacute", char(237)],
                   ["icirc", char(238)], ["iuml", char(239)], ["eth", char(240)],
                   ["ntilde", char(241)], ["ograve", char(242)], ["oacute", char(243)],
                   ["ocirc", char(244)], ["otilde", char(245)], ["ouml", char(246)],
                   ["divide", char(247)], ["oslash", char(248)], ["ugrave", char(249)],
                   ["uacute", char(250)], ["ucirc", char(251)], ["uuml", char(252)],
                   ["yacute", char(253)], ["thorn", char(254)], ["yuml", char(255)]] do
         HTML_ENTITIES[e[1]] := e[2]
   end

   #
   # Parse the string s returning an HtmlDocument object.
   #
   public parse(s)
      local i, node
      doc := HtmlDocument()

      s ? {
         repeat {
            move_to_node()

            if pos(0) then {
               #
               # No opening node found, so put whole in html tags and retry
               #
               return parse("<html>" || s || "</html>")
            }

            i := &pos
            node := parse_node() | break

            case node.get_type() of {
               "doctype" : 
                  doc.add(node)

               "comment" : {
                  doc.add(node)
               }
               
               "tag" : {
                  if not(node.is_closed()) & (node.name == "HTML") then {
                     #
                     # Found the html start point, so parse and return that node.
                     #
                     doc.add(parse_element(node))
                     return doc
                  } else {
                     #
                     # Bad structure, so put html tags around it and start again.
                     #
                     return parse(s[1:i] || "<html>" || s[i:0] || "</html>")
                  }
               }
            }
         }
      }
   end

   #
   # Parse the current input into an {Node}
   #
   # @p
   public parse_node(parent)
      if match("<!DOCTYPE") then
         return parse_doctype()
      if match("<!") then
         return parse_comment(parent)
      if match("<") then
         return parse_tag()
   end

   #
   # Parse and return an Element, given the starting tag
   #
   # @p
   public parse_element(start_tag, parent)
      local res, debug, print_debug, i, node, n

      res := HtmlElement()

      res.name := start_tag.name
      res.attributes := start_tag.attributes

      if \debug then 
         print_debug("Parsing node ", start_tag.name)

      if start_tag.name == "PLAINTEXT" then
         res.add("" ~== remove_entities(tab(0)))
      else if not(start_tag.is_empty() | 
                  html_is_standalone_tag(start_tag.name)) then {
         repeat {
            res.add("" ~== remove_entities(move_to_node()))
            if pos(0) then
               break

            i := &pos
            node := parse_node(res) | break

            if node.get_type() == "tag" then {
               if start_tag.balances(node) then 
                  break

               if html_is_autoclose_tag(start_tag.name) & start_tag.name == node.name then {
                  #
                  # For example <p> ... <p> is treated as <p> ... </p><p>.  The second
                  # <p> has to be rescanned by the caller, so tab back.
                  #
                  tab(i)
                  break
               }

               if node.is_closed() then {
                  #
                  # Mismatched close.  If processing something like a <p>, then assume
                  # a </p> and break; otherwise just ignore.  For example :
                  #   <p> ... </td> -> <p> ... </p></td>
                  # Again, the </td> needs to be rescanned, so tab back.
                  #
                  if html_is_autoclose_tag(start_tag.name) then {
                     tab(i)
                     break
                  }
                  if \debug then
                     print_debug("Skipping closing tag", to_string(node))
               } else {
                  res.add(n := parse_element(node, res))
                  if \debug then 
                     print_debug("Adding node ", to_string(n) || " to" || to_string(start_tag))
               }
            } else {
               #
               # It's either a coment, or something else; just add it to the list of children
               #
               res.add(node)
            }            
         }
      }
      if \debug then 
         print_debug("Finished parsing node ", to_string(start_tag))
      return res
   end

   #
   # DOCTYPE
   #
   # @p
   public parse_doctype()
      local res

      res := DocType()
      ="<!DOCTYPE" | fail

      tab(upto(HTML_IDINTRO))
      res.name := tab(many(HTML_IDCHARS))

      tab(many(HTML_SPACE))
      if ="SYSTEM" then {
         res.external_id := ExternalID()
         tab(many(HTML_SPACE))
         res.external_id.system_id := parse_system_literal()
      } else if ="PUBLIC" then {
         res.external_id := ExternalID()
         tab(many(HTML_SPACE))
         res.external_id.public_id := parse_pubid_literal()
         tab(many(HTML_SPACE))
         res.external_id.system_id := parse_system_literal()
      }
      tab(upto('>')) | fail
      move(1)
      return res
   end

   public parse_system_literal()
      local c, res
      any('\'\"') | fail
      c := move(1)
      res := tab(upto(c)) | fail
      move(1)
      return res
   end

   public parse_pubid_literal()
      local c, res, t
      if any('\'') then
         t := HTML_PUBID_CHAR -- '\''
      else if any('\"') then
         t := HTML_PUBID_CHAR
      else
         fail
      c := move(1)
      res := tab(many(t)) | ""
      =c | fail
      return res
   end

   #
   # Comment - SGML style parsing; different from xml comment in that you can
   # have a legal comment like <!-- abc -- def -->
   # see http://htmlhelp.com/reference/wilbur/misc/comment.html
   #
   # @p
   public parse_comment(parent)
      local res, s, t
      res := Comment()
      ="<!" | fail
      s := ""
      repeat {
         tab(upto('->'))
         if =">" then
            break
         ="--" | fail
         t := tab(find("--")) | fail
         ="--"
         s ||:= t
      }
      res.comment := s
      return res
   end

   #
   # Normal tag
   #
   # @p
   public parse_tag()
      local res, key, c, s, value

      res := Tag()
      ="<" | fail
      if ="/" then
         res.set_closed()
      s := (any(HTML_IDINTRO) & tab(many(HTML_IDCHARS))) | fail
      res.set_name(s)
      repeat {
         tab(upto(HTML_KEYCHARS ++ '/>'))
         if ="/>" then {
            res.set_empty()
            break
         }
         if =">" then
            break

         key := tab(many(HTML_KEYCHARS)) | break

         tab(upto(HTML_VALCHARS ++ '>='))

         if ="=" then {
            tab(upto(HTML_VALCHARS ++ HTML_DELIM))
            if any(HTML_DELIM) then {
               c := move(1)
               s := tab(upto(c) | 0)
               move(1)
            } else
               s := tab(many(HTML_VALCHARS)) | break
            value := remove_entities(s)
         } else
            value := &null

         res.set_attribute(key, value)
      }

      return res
   end

   #
   # Move to the next node (tag, comment, doctype), or end of file.
   #
   # @p
   public move_to_node()
      local s, i, debug, print_debug
      s := ""
      repeat {
         s ||:= tab(upto('<') | 0)
         if pos(0) then
            break
         i := &pos
         if parse_node() then {
            #
            # Found a valid node, so tab back and break
            #
            tab(i)
            break
         }
         #
         # Not a valid node, so tab back and continue
         #
         tab(i)
         s ||:= move(1)
      }

      if \debug then 
         print_debug("Moved to node")

      return s
   end

   #
   # Remove the entity characters from a string.
   #
   # @p
   public remove_entities(s)
      local res, i

      res := ""
      s ? {
         repeat {
            res ||:= tab(upto('&') | 0)
            if pos(0) then
               break
            ="&"
            if ="#" then {
               if i := (256 > integer(tab(many(&digits)))) then {
                  res ||:= char(i)
                  =";"
               } else
                  res ||:= "&#"
            } else {
               if s := \HTML_ENTITIES[tab(many(&ucase ++ &lcase))] then {
                  res ||:= s
                  =";"
               } else
                  res ||:= "&"
            }
         }
      }
      return res
   end

   #
   # Return the document being parsed.
   #
   public get_document()
      return doc
   end

   #
   # Succeed if and only if the tag name is a standalone tag, ie it has no
   # matching closing tag.
   #
   public static html_is_standalone_tag(name)
      return member(HTML_STANDALONE, name)
   end

   #
   # Succeed if and only if the tag implicitly closes when a matching opening
   # tag is encountered at the same level.
   #
   public static html_is_autoclose_tag(name)
      return member(HTML_AUTOCLOSE, name)
   end

end


