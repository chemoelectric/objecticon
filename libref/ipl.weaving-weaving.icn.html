<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>weaving.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     weaving.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures to implement weaving expressions
<a name="6"/>#
<a name="7"/>#	Author:   Ralph E. Griswold
<a name="8"/>#
<a name="9"/>#	Date:     October 22, 1999
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#  This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#  These procedures implement the weaving expressions supported by Painter
<a name="18"/>#  and described in the PDF document "Advanced Weaving" that accompanies
<a name="19"/>#  that application.
<a name="20"/>#
<a name="21"/>############################################################################
<a name="22"/>#
<a name="23"/>#  Links:  strings
<a name="24"/>#
<a name="25"/>############################################################################
<a name="26"/>
<a name="27"/>$define Domain		"12345678"
<a name="28"/>$define DomainForward	"1234567812345678"
<a name="29"/>$define DomainBackward  "8765432187654321"
<a name="30"/>
<a name="31"/>package ipl.weaving
<a name="32"/>
<a name="33"/>procedure Between(p1, p2)
<a name="34"/>
<a name="35"/>   DomainForward ? {
<a name="36"/>      tab(upto(p1[-1]) + 1)
<a name="37"/>      return tab(upto(p2[1]))
<a name="38"/>      }
<a name="39"/>
<a name="40"/>end
<a name="41"/>
<a name="42"/># weaving block
<a name="43"/>procedure Block(p1, p2)			
<a name="44"/>   local i, s, p3, counts
<a name="45"/>
<a name="46"/>   if *p1 &lt; *p2 then p1 := Extend(p1, *p2) | fail
<a name="47"/>   else if *p2 &lt;  *p1 then p2 := Extend(p2, *p1) | fail
<a name="48"/>
<a name="49"/>   counts := []
<a name="50"/>
<a name="51"/>   p2 ? {
<a name="52"/>      while s := tab(upto('{')) do {
<a name="53"/>         every put(counts, !s)
<a name="54"/>         move(1)
<a name="55"/>         put(counts, tab(upto('}')))
<a name="56"/>         move(1)
<a name="57"/>         }
<a name="58"/>      every put(counts, !tab(0))
<a name="59"/>      }
<a name="60"/>
<a name="61"/>   p3 := ""
<a name="62"/>
<a name="63"/>   every i := 1 to *p1 do
<a name="64"/>      p3 ||:= repl(p1[i], counts[i]) 
<a name="65"/>
<a name="66"/>   return p3
<a name="67"/>
<a name="68"/>end
<a name="69"/>
<a name="70"/># weaving downrun
<a name="71"/>procedure DownRun(c1, c2)		
<a name="72"/>
<a name="73"/>   DomainBackward ? {
<a name="74"/>       tab(upto(c1))
<a name="75"/>       return tab(upto(c2) + 1)
<a name="76"/>       }
<a name="77"/>
<a name="78"/>end
<a name="79"/>
<a name="80"/>#  CYCLES WRONG
<a name="81"/>
<a name="82"/># weaving downup
<a name="83"/>procedure DownUp(p1, p2, cycles)	
<a name="84"/>   local i, p3
<a name="85"/>
<a name="86"/>   /cycles := 0
<a name="87"/>
<a name="88"/>   if *p1 &lt; *p2 then p1 := Extend(p1, *p2) | fail
<a name="89"/>   else if *p2 &lt;  *p1 then p2 := Extend(p2, *p1) | fail
<a name="90"/>
<a name="91"/>   p3 := p1[1]
<a name="92"/>
<a name="93"/>   if cycles &gt; 0 then {
<a name="94"/>      DomainForward ? {
<a name="95"/>         tab(upto(p1[-1]) + 1)
<a name="96"/>         p3 ||:= repl(move(8), cycles)
<a name="97"/>         }
<a name="98"/>      }
<a name="99"/>
<a name="100"/>   every i := 1 to *p1 do {
<a name="101"/>      p3 ||:= DownRun(p1[i], p2[i])[2:0]
<a name="102"/>      p3 ||:= UpRun(p2[i], p1[i + 1])[2:0]		# might fail
<a name="103"/>      }
<a name="104"/>
<a name="105"/>   return p3
<a name="106"/>
<a name="107"/>end
<a name="108"/>
<a name="109"/># weaving downto
<a name="110"/>procedure Downto(p1, p2, cycles)	
<a name="111"/>   local p3
<a name="112"/>
<a name="113"/>   p3 := p1
<a name="114"/>
<a name="115"/>   /cycles := 0
<a name="116"/>
<a name="117"/>   if cycles &gt; 0 then {
<a name="118"/>      DomainBackward ? {
<a name="119"/>         tab(upto(p1[-1]) + 1)
<a name="120"/>         p3 ||:= repl(move(8), cycles)
<a name="121"/>         }
<a name="122"/>      }
<a name="123"/>
<a name="124"/>   DomainBackward ? {
<a name="125"/>      tab(upto(p1[-1]) + 1)
<a name="126"/>      return p3 || tab(upto(p2[1])) || p2
<a name="127"/>      }
<a name="128"/>
<a name="129"/>end
<a name="130"/>
<a name="131"/># weaving extension
<a name="132"/>procedure Extend(p, i)			
<a name="133"/>
<a name="134"/>   if *p = 0 then fail
<a name="135"/>
<a name="136"/>   i := integer(i)
<a name="137"/>
<a name="138"/>   return case i of {
<a name="139"/>      *p &gt; i   :  left(p, i)
<a name="140"/>      *p &lt; i   :  left(repl(p, (i / *p) + 1), i)
<a name="141"/>      default  :  p
<a name="142"/>      }
<a name="143"/>
<a name="144"/>end
<a name="145"/>
<a name="146"/># weaving interleave
<a name="147"/>procedure Interleave(p1, p2)		
<a name="148"/>   local i, p3
<a name="149"/>
<a name="150"/>   if *p1 &lt; *p2 then p1 := Extend(p1, *p2) | fail
<a name="151"/>   else if *p2 &lt;  *p1 then p2 := Extend(p2, *p1) | fail
<a name="152"/>
<a name="153"/>   p3 := ""
<a name="154"/>
<a name="155"/>   every i := 1 to *p1 do
<a name="156"/>      p3 ||:= p1[i] || p2[i]
<a name="157"/>
<a name="158"/>   return p3
<a name="159"/>
<a name="160"/>end
<a name="161"/>
<a name="162"/># weaving palindrome
<a name="163"/>procedure Palindrome(p)			
<a name="164"/>
<a name="165"/>   if *p = 1 then return p
<a name="166"/>   else return p || reverse(p[2:-1])
<a name="167"/>
<a name="168"/>end
<a name="169"/>
<a name="170"/># weaving pbox
<a name="171"/>procedure Pbox(p1, p2)			
<a name="172"/>   local p3, i
<a name="173"/>
<a name="174"/>   if *p2 ~= *p1 then p2 := Extend(p2, *p1) | fail
<a name="175"/>
<a name="176"/>   p3 := ""
<a name="177"/>   
<a name="178"/>   every i := !p1 do
<a name="179"/>      p3 ||:= p1[p2[i]]
<a name="180"/>
<a name="181"/>   return p3
<a name="182"/>
<a name="183"/>end
<a name="184"/>
<a name="185"/># weaving permutation
<a name="186"/>procedure Permute(p1, p2)		
<a name="187"/>   local p3, chunk, i, j
<a name="188"/>
<a name="189"/>   j := *p1 % *p2
<a name="190"/>   if j ~= 0 then p1 := Extend(p1, *p1 + *p2 - j) | fail
<a name="191"/>
<a name="192"/>   p3 := ""
<a name="193"/>
<a name="194"/>   p1 ? {
<a name="195"/>      while chunk := move(*p2) do
<a name="196"/>         every i := !p2 do
<a name="197"/>            p3 ||:= chunk[i]
<a name="198"/>      }
<a name="199"/>
<a name="200"/>   return p3
<a name="201"/>
<a name="202"/>end
<a name="203"/>
<a name="204"/>procedure Run(p, count)
<a name="205"/>
<a name="206"/>   DomainForward ? {
<a name="207"/>      tab(upto(p[-1]) + 1)
<a name="208"/>      return repl(move(*Domain), count)
<a name="209"/>      }
<a name="210"/>
<a name="211"/>end
<a name="212"/>
<a name="213"/># weaving Template
<a name="214"/>procedure Template(p1, p2)		
<a name="215"/>   local p3, dlist, i, j, k
<a name="216"/>
<a name="217"/>   dlist := []
<a name="218"/>
<a name="219"/>   every i := 1 to *p1 do
<a name="220"/>      put(dlist, p1[i] - p1[1])
<a name="221"/>
<a name="222"/>   p3 := ""
<a name="223"/>
<a name="224"/>   every j := 1 to *dlist do
<a name="225"/>      every i := 1 to *p2 do {
<a name="226"/>         k := p2[i] + dlist[j]
<a name="227"/>         if k &gt; 8 then k -:= 8
<a name="228"/>         p3 ||:= k
<a name="229"/>         }
<a name="230"/>
<a name="231"/>   return p3
<a name="232"/>
<a name="233"/>end
<a name="234"/>
<a name="235"/>#  CYCLES WRONG
<a name="236"/>
<a name="237"/># weaving updown
<a name="238"/>procedure UpDown(p1, p2, cycles)	
<a name="239"/>   local p3, i
<a name="240"/>
<a name="241"/>   /cycles := 0
<a name="242"/>
<a name="243"/>   if *p1 &lt; *p2 then p1 := Extend(p1, *p2) | fail
<a name="244"/>   else if *p2 &lt;  *p1 then p2 := Extend(p2, *p1) | fail
<a name="245"/>
<a name="246"/>   p3 := p1[1]
<a name="247"/>
<a name="248"/>   if cycles &gt; 0 then {
<a name="249"/>      DomainForward ? {
<a name="250"/>         tab(upto(p1[-1]) + 1)
<a name="251"/>         p3 ||:= repl(move(8), cycles)
<a name="252"/>         }
<a name="253"/>      }
<a name="254"/>
<a name="255"/>   every i := 1 to *p1 do {
<a name="256"/>      p3 ||:= UpRun(p1[i], p2[i])[2:0]
<a name="257"/>      p3 ||:= DownRun(p2[i], p1[i + 1])[2:0]		# might fail
<a name="258"/>      }
<a name="259"/>
<a name="260"/>   return p3
<a name="261"/>
<a name="262"/>end
<a name="263"/>
<a name="264"/># weaving uprun
<a name="265"/>procedure UpRun(c1, c2)			
<a name="266"/>
<a name="267"/>   DomainForward ? {
<a name="268"/>       tab(upto(c1))
<a name="269"/>       return tab(upto(c2) + 1)
<a name="270"/>       }
<a name="271"/>
<a name="272"/>end
<a name="273"/>
<a name="274"/># weaving upto
<a name="275"/>procedure Upto(p1, p2, cycles)		
<a name="276"/>   local p3
<a name="277"/>
<a name="278"/>   /cycles := 0
<a name="279"/>
<a name="280"/>   p3 := p1
<a name="281"/>
<a name="282"/>   return p1 || Run(p1, cycles) || Between(p1, p2) || p2
<a name="283"/>
<a name="284"/>end
</pre></body></html>
