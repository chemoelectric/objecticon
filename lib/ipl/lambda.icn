package ipl.functional

global _a, _l

#
# Implementation class for {lambda}
#
package class Lambda()
   private e

   package call(a[])
      local ta, tl
      ta := _a
      _a := a
      tl := _l
      _l := &null
      suspend 1(!e, _a :=: ta, _l :=: tl) do {
         _a :=: ta
         _l :=: tl
      }
      _a := ta
      _l := tl
   end

   package new(e)
      self.e := e
      return
   end
end

#
# This is a procedure for making lambda-style functions.  For example:
#   f := lambda{ _a[1] + 100 }
# sets f to be a function returning its first argument plus 100.  Note
# that args are passed to the function via a global variable _a, since
# icon syntax allows no other way.  Further, although the function can
# use any variables in scope, it cannot declare any itself.  To simulate
# local variables, another global, _l, can be used.  It can be set
# to any value.
# 
# Other examples:-
#   # Return the sum of the arguments, eg f(1,2,3) -> 6
#   # - note that _l must be dereferenced, otherwise the caller sees the
#   #   value before the function is called.
#   f := lambda{{ _l := 0; every _l +:= !_a ; ._l }}
#
procedure lambda(e)
   return Lambda(e).call
end

# Evaluates coexpression {e}, saving the value of {_a} and {_l}.  This
# can be necessary if a lambda calls another lambda which exits via an
# exception or a runtime error.  Note this just does the same as
#      `util.save_vars{..., _a|_l}`
#
# @example
# @   f := lambda{
# @      throw("Something bad")
# @   }
# @
# @   g := lambda{{
# @      write("a[1]=",_a[1])
# @      save_lambda{try{ f(102) }}
# @      # Without save_lambda, _a[1] would now still be 102 (ie the arg given to f)
# @      write("a[1]=",_a[1])
# @   }}
#
procedure save_lambda(e)
   local ta, tl
   ta := _a
   tl := _l
   suspend 1(|@e, _a :=: ta, _l :=: tl) do {
      _a :=: ta
      _l :=: tl
   }
   _a := ta
   _l := tl
end
