#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

import 
   ipl.sort,
   ipl.pdco,
   ipl.lists,
   util

#
# This is the parent class of all the GUI components.  All of
# its methods and variables therefore apply to its sub-classes.
#
class Component(Rect,Align,Connectable)
   public 
      #
      # x position as specified by {set_pos()}, eg "50%"
      #                        
      x_spec,
      #
      # y position as specified by set_pos().
      #
      y_spec,
      #
      # width specifier as specified in set_size(), eg "100%"              
      #
      w_spec, 
      #
      # height specifier as specified in set_size(),
      #
      h_spec, 
      #
      # An integer used to sort the parent's z_children list.
      #
      z,
      #
      # This can be set to alter the tab-focus ordering of the parent
      # container.
      #
      tab_ord,
      #
      # The {Dialog} class instance of which this {Component} is a part.
      #
      parent_dialog,
      #
      # A map of the Icon window graphics attributes, eg "bg"->"blue",
      # "resize"->"on" etc.
      wattribs,
      effective_wattribs,
      #
      # Flags indicating whether the {Component} currently is shaded;
      # {&null} means it isn't.
      is_shaded_flag, 
      effective_is_shaded_flag,
      #
      # Flag to indicate that the {Component} will take care of drawing
      # its own shaded representation.  By default off, meaning this
      # class will shade the component.
      #
      draw_own_shading_flag,
      #
      # Flags indicating whether the {Component} currently is hidden;
      # {&null} means it isn't.
      is_hidden_flag,
      effective_is_hidden_flag,
      #
      # A cloned window created by combining a buffer window with
      # the {Component's} attributes.  The component draws itself
      # into this window.
      cbwin,
      #
      # Flag indicating whether the {Component} accepts keyboard focus
      # by way of the tab key being pressed;  {&null} means it doesn't.
      accepts_focus_flag,
      #
      # Tooltip config
      #
      tooltip,         
      tooltip_start_delay,
      tooltip_end_delay,
      tooltip_follows_mouse_flag,
      #
      # Reference to enclosing {Component} object.
      #
      parent,
      #
      # List of child components
      #
      children,
      #
      # The same children, but sorted in z order.
      #
      z_children,
      #
      # The same children, but sorted in tab order.
      #
      tab_children,
      #
      # Mnemonic key for keyboard accelerators.
      #
      accel,
      #
      # The child which we want to give the focus to.
      #
      preferred_focus,
      #
      # Flags to turn on drag and drop
      #
      allow_drag_flag,
      allow_drop_flag,
      #
      # Mouse pointer.
      #
      pointer,
      #
      # Layout manager
      #
      layout_delegate,
      #
      # Layout constraints
      # 
      constraints,
      #
      # Show layout grid - for layout debugging
      #
      show_layout_flag,
      #
      # If set, inherit wattribs from the parent - on by default.
      #
      inherit_wattribs_flag,
      #
      # Border instance
      #
      border

   #
   # Set the tooltip.  This object is passed to {create_tooltip_component} when a
   # tooltip is to be created.
   #
   public set_tooltip(x)
      self.tooltip := x
      return self
   end

   #
   # Return the tooltip, if any.
   #
   public get_tooltip()
      return \self.tooltip
   end

   #
   # Set the delay in ms before the tooltip appears.
   #
   public set_tooltip_start_delay(x)
      self.tooltip_start_delay := x
      return self
   end

   #
   # Get the tooltip start delay.
   #
   public get_tooltip_start_delay()
      return self.tooltip_start_delay
   end

   #
   # Set the delay in ms before the tooltip disappears after it has been
   # shown; &null means infinite.
   #
   public set_tooltip_end_delay(x)
      self.tooltip_end_delay := x
      return self
   end

   #
   # Get the tooltip end delay.
   #
   public get_tooltip_end_delay()
      return \self.tooltip_end_delay
   end

   #
   # This indicates whether the tooltip follows the mouse around within
   # a component, when the tooltip changes - applicable for example in a Tree
   # which has a tip for each node.  By default off.
   #
   public set_tooltip_follows_mouse(s)
      self.tooltip_follows_mouse_flag := check_flag(s)
      return self
   end

   #
   # Create a tooltip Component.  By default delegates this to the {Style} object,
   # to create a standard {Label}.  The content is then set from the tip, which
   # can be a string or a {Paint} instance.
   #
   public create_tooltip_component(tip)
      local c, s
      c := Gui.style.create_tooltip_label()
      if s := text(tip) then
         c.set_label(s)
      else
         c.set_paint(tip)
      if \self.accel then
         c.set_linked_accel(self)
      return c
   end

   #
   # Set the pointer.  When the mouse moves over the component,
   # the pointer cursor will automatically be set to this value.
   #
   public set_pointer(x)
      self.pointer := x
      return self
   end

   #
   # Return the pointer string, if any.
   #
   public get_pointer()
      return \self.pointer
   end

   #
   # Set the border to use.
   #
   public set_border(b)
      if is_initialized() then {
         (\self.border).finally()
         self.border := b
         (\self.border).initially(self)
         self.invalidate()
      } else
         self.border := b
      return self
   end

   #
   # Return the clip rectangle of {cbwin} as a {Rect}.  Fails if there
   # is no clip.
   #
   public get_cbwin_clip()
      return Rect!cbwin.get_clip()
   end

   #
   # Get the cloned buffer window, as seen by a child component.
   #
   public get_cbwin()
      return \self.cbwin
   end

   #
   # Get the wattribs in effect in the component's cbwin window.
   #
   public get_effective_wattribs()
      return effective_wattribs
   end

   #
   # This method can be overridden to succeed if the component should keep
   # an event rather than allow it to be used by the parent dialog to move
   # the focus between c
   #
   public keeps(e)
   end

   #
   # Succeed if the component is hidden; for example if it is
   # within a tabbed pane not presently visible.
   #
   public is_hidden()
      return \self.effective_is_hidden_flag
   end

   #
   # Succeed if the component is not hidden.
   #
   public is_unhidden()
      return /self.effective_is_hidden_flag
   end

   #
   # Swap the hidden status of the component.
   #
   public toggle_is_hidden()
      return set_is_hidden(toggle_flag(self.is_hidden_flag))
   end

   #
   # Set the hidden status of the component.
   #
   public set_is_hidden(s)
      check_flag(s)
      if s ~=== self.is_hidden_flag then {
         # NB - try invalidate before and after, since invalidating a hidden
         # component is a no-op.
         self.invalidate()
         self.is_hidden_flag := s
         self.hidden_change()
         self.invalidate()
      }
      return self
   end

   #
   # Called to re-compute the effective_is_hidden_flags under this tree.
   #
   public hidden_change()
      is_initialized() | fail
      self.effective_is_hidden_flag := 
         if (\parent).is_hidden() | \self.is_hidden_flag then &yes else &no
      every (!self.children).hidden_change()
   end

   #
   # Succeeds if the component is shaded; fails otherwise.  A
   # shaded component, such as a button, may be displayed
   # differently, and will not generate events.
   #
   public is_shaded()
      return \self.effective_is_shaded_flag
   end

   #
   # Succeed if the component is not shaded.
   #
   public is_unshaded()
      return /self.effective_is_shaded_flag
   end

   #
   # Called to re-compute the effective_is_shaded_flags under this tree.
   #
   public shaded_change()
      is_initialized() | fail
      self.effective_is_shaded_flag := 
         if (\parent).is_shaded() | \self.is_shaded_flag then &yes else &no
      every (!self.children).shaded_change()
   end

   #
   # Flag to indicate that the {Component} will take care of drawing
   # its own shaded representation.  By default off, meaning this
   # class will shade the component.
   #
   public set_draw_own_shading(s)
      check_flag(s)
      if s ~=== self.draw_own_shading_flag then {
         self.draw_own_shading_flag := s
         self.invalidate()
      }
      return self
   end

   #
   # Set the preferred focus, which is the component to which focus is
   # given when a mouse click occurs in this component.  By default,
   # this is set to the component itself.
   #
   public set_preferred_focus(c)
      self.preferred_focus := c
      return self
   end

   #
   # Return the preferred focus.
   #
   public get_preferred_focus()
      return self.preferred_focus
   end

   #
   # Determines whether the component accepts the tab focus
   #
   public accepts_focus()
      return \self.accepts_focus_flag
   end

   #
   # Handle the component's keyboard accelerator key.  By
   # default, this requests the keyboard focus (if the
   # component is configured to accept it).
   #
   public handle_accel(e)
      grab_focus(e)
   end

   #
   # Grab the focus for this component's preferred focus.
   # @param e the causing event, if any.
   #
   public grab_focus(e)
      (\self.parent_dialog).set_focus(find_focus(e), e)
   end

   #
   # Swap the shaded status of the component.
   #
   public toggle_is_shaded()
      self.is_shaded_flag := toggle_flag(self.is_shaded_flag)
      self.shaded_change()
      self.invalidate()
      return self
   end

   #
   # Set the shaded status of the component.
   #
   public set_is_shaded(s)
      check_flag(s)
      if s ~=== self.is_shaded_flag then {
         self.is_shaded_flag := s
         self.shaded_change()
         self.invalidate()
      }
      return self
   end

   #
   # Set the flag indicating that the component accepts tab focus.
   #
   public set_accepts_focus(s)
      self.accepts_focus_flag := check_flag(s)
      return self
   end

   #
   # This draws, or re-draws, the component and all its children in the dialog
   # window.
   #
   public display()
      display_children()
   end

   #
   # Useful function to display the children.
   #
   public display_children()
      every display_child(!self.z_children)
   end

   public display_child(c)
      if c.is_unhidden() then
         c.invoke_display!cbwin.drawable(c.x, c.y, c.w, c.h)
   end

   public invoke_display(rx, ry, rw, rh)
      cbwin.clip(rx, ry, rw, rh).erase_area(rx, ry, rw, rh)
      self.display()
      if \self.show_layout_flag then
         (\layout_delegate).display()
      # Only need to shade if we are shaded and the parent won't shade for us.  This also
      # avoids filtering twice, which makes the result too grey.
      if is_shaded() & not((\parent).is_shaded()) & /draw_own_shading_flag then
         Gui.style.shade_rectangle(self.cbwin, rx, ry, rw, rh)
   end

   #
   # Add the given window attribute and value to those used in
   # this component's cloned buffer window.
   #
   public set_wattrib(attr, val)
      insert(self.wattribs, attr, val)
      return self
   end

   #
   # Remove the given window attribute.
   #
   public remove_wattrib(attr)
      delete(self.wattribs, attr)
      return self
   end

   #
   # Return the window attrib with the given name in the icon attribs
   # list, or fail if none is present.
   #
   public get_wattrib(attr)
      return member(self.wattribs, attr)
   end

   #
   # Clear all wattribs
   #
   public clear_wattribs()
      clear(self.wattribs)
      return self
   end

   #
   # Set all of the wattribs to the given table.
   #
   public set_all_wattribs(t)
      self.wattribs := copy(t)
      return self
   end

   #
   # Copy an attrib from another component to this one.  If the
   # attribute is absent in the other component it is deleted from
   # this one.
   #
   public copy_wattrib(attr, other)
      local val
      if val := other.get_wattrib(attr) then
         set_wattrib(attr, val)
      else
         remove_wattrib(attr)
      return self
   end

   #
   # Set a layout constraint
   #
   public set_constraint(key, val)
      insert(self.constraints, key, val)
      return self
   end

   #
   # Remove a layout constraint
   #
   public remove_constraint(key)
      delete(self.constraints, key)
      return self
   end

   #
   # Get a layout constraint, or fail if it's not present.
   #
   public get_constraint(key)
      return member(self.constraints, key)
   end

   #
   # Clear all constraints
   #
   public clear_constraints()
      clear(self.constraints)
      return self
   end      

   #
   # This method disposes of the component's cloned windows and
   # re-creates them afresh using the current value of the window attribs.
   # 
   # This method may be used to put any changed icon window attributes,
   # set with set_wattrib above, into effect.
   #
   public reset()
      self.finally()
      self.initially()
      self.layout()
      self.invalidate()
      return self
   end

   #
   # Return a z that would ensure a component were on top in the
   # z order.
   #
   public get_top_z()
      return (self.z_children[-1].z + 1) | 1
   end

   #
   # Return a z that would ensure a component were on bottom in the
   # z order.
   #
   public get_bottom_z()
      return (self.z_children[1].z - 1) | -1
   end

   #
   # Which component does the point lie in, searching in z-order?
   #
   public whose_point(ex, ey)
      local c
      every c := back(z_children) do {
         if c.is_unhidden() & c.inside(ex, ey) then
            return c
      }
   end

   #
   # Is the given Point (normally the current event) within this
   # component?
   #
   public in_region(e)
      #
      # Use the point chain if we can
      #
      if e === parent_dialog.point_chain_source then
         return keyof(parent_dialog.point_chain, self)
      else
         return get_clip_rect().inside(e.x, e.y)
   end

   #
   # Succeed if this component is held with the given button press.
   # @param e The mouse press event code - Mouse.LEFT_PRESS, Mouse.RIGHT_PRESS or Mouse.MIDDLE_PRESS
   #
   public is_held(e)
      return keyof(\parent_dialog.held[e], self)
   end

   #
   # Method called when the component gets the keyboard focus; may be extended.
   # @param e the event causing the change of focus, if any
   #
   public got_focus(e)
      focus_changed(e)
      fire(Event.GOT_FOCUS, e)
   end

   #
   # Return the Icon window of the dialog in which the component resides.
   #
   public get_parent_win()
      return (\self.parent_dialog).get_win()
   end

   #
   # Return the Icon buffer window of the dialog in which the component resides.
   #
   public get_parent_buffer_win()
      return (\self.parent_dialog).get_buffer_win()
   end

   #
   # Succeed if this component has the dialog's focus.
   #
   public has_focus()
      return (\self.parent_dialog).focus === self
   end

   #
   # Method called when the component loses the keyboard focus; may be extended.
   # @param e the event causing the change of focus, if any
   #
   public lost_focus(e)
      focus_changed(e)
      fire(Event.LOST_FOCUS, e)
   end

   #
   # This is invoked when the focus is got/lost; by default it just
   # calls invalidate.
   # @param e the event causing the change of focus, if any
   #
   public focus_changed(e)
      invalidate()
   end

   #
   # Set the x and y position of the component.  Each coordinate
   # can be either an absolute pixel position, or can be given in
   # the form of a percentage plus or minus an offset.
   # @param x_spec   The x specification.
   # @param y_spec   The y specification.
   # @example
   # @ c.set_pos(100, "25%")
   # @ c.set_pos("50%-20", "25%+100")
   #
   public set_pos(x_spec, y_spec)
      self.x_spec := x_spec
      self.y_spec := y_spec
      return self
   end

   #
   # Set the x specification
   # @param x_spec   The x specification.
   #
   public set_x(x_spec)
      self.x_spec := x_spec
      return self
   end

   #
   # Set the y specification
   # @param y_spec   The y specification.
   #
   public set_y(y_spec)
      self.y_spec := y_spec
      return self
   end

   #
   # Set the z value.
   # @param z   The z value.
   #
   public set_z(z)
      self.z := z
      return self
   end

   #
   # Set the size of the component.  The parameters are in the
   # same format as for {set_pos()}
   # above.  Some components will
   # set sensible default sizes, but for others the size must be
   # set explicitly.
   #
   public set_size(w_spec, h_spec)
      self.w_spec := w_spec
      self.h_spec := h_spec
      return self
   end

   #
   # Set the width specification
   # @param w_spec   The width specification.
   #
   public set_width(w_spec)
      self.w_spec := w_spec
      return self
   end

   #
   # Set the height specification
   # @param h_spec   The height specification.
   #
   public set_height(h_spec)
      self.h_spec := h_spec
      return self
   end

   #
   # Set the alignment of the component.  Options for
   # {x_align} are ``l'', ``c'' and ``r'', for left, centre, and right
   # alignment.  Options for {y_align} are ``t'', ``c'' and ``b'', 
   # for top centre and bottom alignment.  The default alignment is ``l'', ``t''.
   #
   # @param x_align   The x alignment
   # @param y_align   The y alignment
   #
   public set_align(x_align, y_align)
      self.x_align := x_align
      self.y_align := y_align
      return self
   end

   #
   # Set the x alignment
   # @param x_align   The x alignment
   #
   public set_x_align(x_align)
      self.x_align := x_align
      return self
   end

   #
   # Set the y alignment
   # @param y_align   The y alignment
   #
   public set_y_align(y_align)
      self.y_align := y_align
      return self
   end

   #
   # Set the position and size of the component.
   # @see set_pos
   # @see set_size
   #
   public set_geometry(x_spec, y_spec, w_spec, h_spec)
      self.x_spec := x_spec
      self.y_spec := y_spec
      self.w_spec := w_spec
      self.h_spec := h_spec
      return self
   end

   #
   # Set the tab priority, which affects the tab focus ordering of the parent.
   #
   public set_tab_ord(x)
      self.tab_ord := x
      return self
   end

   #
   # Set the accelerator key, which will be used with the Alt
   # key to provide keyboard accelerators.
   #
   public set_accel(k)
      self.accel := k
      return self
   end

   #
   # Get the accelerator key, if any.
   #
   public get_accel()
      return \self.accel
   end

   #
   # Get the component's parent component, or fail if there is none.
   #
   public get_parent()
      return \self.parent
   end

   #
   # Set the component's parent component.
   #
   public set_parent(c)
      self.parent := c
      return self
   end

   # Generate the chain of components starting with this component and
   # going up through the parents.
   #
   public gen_parents()
      local t
      t := self
      while \t do {
         suspend t
         t := t.parent
      }
   end

   #
   # Complete the final setup before display by initializing the parent
   # dialog reference and creating the cloned windows.
   #
   public initially()
      local t
      /cbwin | syserr("initially called out of sequence")
      \self.parent | runerr("incorrect ancestry (parent null)")
      parent_dialog := parent.get_parent_dialog()
      self.effective_is_hidden_flag := Yes{ parent.is_hidden() | \self.is_hidden_flag }
      self.effective_is_shaded_flag := Yes{ parent.is_shaded() | \self.is_shaded_flag }
      Gui.style.polish(self)
      self.effective_wattribs := if /inherit_wattribs_flag then table() else copy(parent.get_effective_wattribs())
      every t := key(self.wattribs) do {
         if member(Gui.CONTEXT_WATTRIB_SET, t) then
            insert(self.effective_wattribs, t, self.wattribs[t])
         else
            runerr("Invalid (non-graphics context) attribute for component", t)
      }
      self.compute_z_order()
      self.compute_tab_order()
      cbwin := if /inherit_wattribs_flag then
         fresh_clone_win_with(parent.get_cbwin(), self.wattribs)
      else
         clone_win_with(parent.get_cbwin(), self.wattribs)
      (\self.border).initially(self)
      every (!self.children).initially()
   end

   #
   # Returns the dialog holding the component, or fail if unset
   #
   public get_parent_dialog()
      return \self.parent_dialog
   end

   #
   # Sets the owning Dialog of the component.
   #
   # @param c   The parent dialog.
   #
   public set_parent_dialog(c)
      self.parent_dialog := c
      return self
   end

   #
   # This method may be extended.  It is invoked just before the
   # window is closed.
   #
   public finally()
      \cbwin | syserr("finally called out of sequence")
      reset_layout()
      (\self.border).finally()
      self.cbwin.close()
      self.cbwin := &null
      every (!self.children).finally()
      self.parent_dialog := &null
   end

   #
   #
   # Parse a position specification into an absolute value.
   # @param total   The total value
   # @param s  The size specifier 
   #
   public parse_pos(total, s)
      local pct, off
      s ? {
         if pct := 0.01 * integer(tab(upto('%'))) then {
            move(1) 
            if ="-" then
               off := -integer(tab(0)) | fail
            else if ="+" then
               off := integer(tab(0)) | fail
            else off := 0
         } else {
            pct := 0
            off := integer(tab(0)) | fail
         }
      }
      return integer(pct * total + off)
   end

   public get_preferred_width()
      return integer(self.w_spec) | get_default_width() | (\layout_delegate).get_preferred_width() | runerr("width must be specified")
   end

   public get_preferred_height(pw)
      local i
      if i := integer(self.h_spec) then
         return i
      /pw := get_preferred_width()
      return get_default_height(pw) | (\layout_delegate).get_preferred_height(pw) | runerr("height must be specified")
   end

   #
   # Size this component using compute_absolutes, and then layout all
   # its children.
   #
   public resize()
      compute_absolutes()
      layout()
      return self
   end

   public get_default_width()
   end

   public get_default_height()
   end

   public set_layout(l)
      self.layout_delegate := l
      (\l).set_parent(self)
      return self
   end

   #
   # Given that this component's size and position has already been
   # calculated, this method lays out all of its children.
   #
   public layout()
      if /layout_delegate then
         every (!children).compute_absolutes()
      else
         layout_delegate.layout()
      every (!children).layout()
   end

   public shift(dx, dy)
      self.x +:= dx
      self.y +:= dy
      every (!children).shift(dx, dy)
   end

   public reset_all_layouts()
      reset_layout()
      every (!self.children).reset_all_layouts()
      return self
   end

   public reset_layout()
      (\layout_delegate).reset()
      return self
   end

   public reset_layout_chain()
      every gen_parents().reset_layout()
      return self
   end

   #
   # Compute the absolute positions and sizes from the
   # specifications given by {set_pos()} and {set_size()}.
   #
   public compute_absolutes()
      local wspec, hspec
      #
      # Check for unspecified fields
      #
      \self.x_spec | runerr("x position unspecified")
      \self.y_spec | runerr("y position unspecified")

      self.x := parent.x + parse_pos(parent.w, self.x_spec) | runerr("invalid x position specification", self.x_spec)
      self.y := parent.y + parse_pos(parent.h, self.y_spec) | runerr("invalid y position specification", self.y_spec)
      wspec := \self.w_spec | get_preferred_width()
      self.w := parse_pos(parent.w, wspec) | runerr("invalid width specification", wspec)
      hspec := \self.h_spec | get_preferred_height(self.w)
      self.h := parse_pos(parent.h, hspec) | runerr("invalid height specification", hspec)

      #
      # Adjust x, y based on alignments
      #
      case self.x_align of {
         Align.C : self.x -:= self.w / 2
         Align.R : self.x -:= self.w
         Align.L : &null
         default : runerr("incorrect x alignment specifier", self.x_align)
      }
      case self.y_align of {
         Align.C : self.y -:= self.h / 2
         Align.B : self.y -:= self.h
         Align.T : &null
         default : runerr("incorrect y alignment specifier", self.y_align)
      }
   end

   public build_point_chain(l, ex, ey)
      local c
      if c := whose_point(ex, ey) then {
         c.build_point_chain(l, ex, ey)
         put(l, c)
      }
   end

   #
   # Traverse all the components, including subcomponents, with a
   # post-order traversal.
   #
   public traverse_postorder()
      every (!self.children).traverse_postorder()
      coact(self)
   end

   #
   # Traverse all the components, including subcomponents, with a
   # pre-order traversal.
   #
   public traverse_preorder()
      coact(self)
      every (!self.children).traverse_preorder()
   end

   #
   # Return the preferred focus, if it accepts focus.
   #
   public find_focus(e)
      if self.preferred_focus.is_unshaded() & 
         self.preferred_focus.is_unhidden() &
         self.preferred_focus.accepts_focus(e) then
         return self.preferred_focus
   end

   #
   # Search for a component with the matching accelerator key within
   # components rooted at this component.
   #
   public find_accel(e)
      local c, f

      if self.is_unshaded() & self.is_unhidden() then {
         # Note this is a pre-order search.  This is needed for TabSet, which
         # wants to handle its tabs' accelerator keys.

         if match_accel(e) then
            return self

         every c := !self.children do {
            if f := c.find_accel(e) then
               return f
         }
      }
   end

   #
   # Generate the focusable children of this tree of components, in tab focus order.
   #
   public gen_focusable(e)
      local c
      every c := Seq{traverse_tab_order()} do {
         if c.accepts_focus(e) & c.is_unhidden() & c.is_unshaded() then
            suspend c
      }
   end

   #
   # Succeed if the given (key) event matches this component's accelerator.
   #
   public match_accel(e)
      return self.accel === e
   end

   #
   # Traverse the components under this tree in the order in which
   # tab focus should iterate over them.
   #
   public traverse_tab_order()
      coact(self)
      every (!self.tab_children).traverse_tab_order()
   end

   #
   # Invalidate the {Component}'s rectangle on the screen, optionally
   # intersected with {r}.
   #
   public invalidate(r)
      if self.is_live() & self.is_unhidden() then
         parent_dialog.invalidate_rect(if /r then get_clip_rect()
                                       else r.intersect(get_clip_rect()))
      return self
   end

   # Invoke layout() and return self.
   #
   public do_layout()
      layout()
      return self
   end

   #
   # Get the clipping rectangle of this component, ie the rectangle actually
   # visible (ignoring other overlapping components).  Fails if the component is
   # not visible at all.
   #
   public get_clip_rect()
      local r, c
      c := r := self
      repeat {
         c := c.parent
         if /c then
            return r
         r := r.intersect(c) | fail
      }
   end

   #
   # Compute the z_children list.
   #
   public compute_z_order()
      self.z_children := isort(self.children, component_zsort)
   end

   #
   # Compute the tab order list.
   #
   public compute_tab_order()
      self.tab_children := isort(self.children, component_tabsort)
   end

   private static component_zsort(c)
      return c.z
   end

   private static component_tabsort(c)
      return c.tab_ord
   end

   #
   # Add the {Component} to the list of children.
   #
   # @param c   The {Component} to add.
   # @param i   The index to add at; if omitted then the new component
   # @          is appended to the end.
   # @fail      If i is out of range
   #
   public add(c, i)
      /i := 0
      insert(self.children, i, c) | fail
      c.set_parent(self)
      if is_initialized() then {
         compute_z_order()
         compute_tab_order()
         c.initially()
      }
      return self
   end

   #
   # Get the index of the given child component
   #
   public get_index(c)
      return keyof(self.children, c)
   end

   #
   # Remove the {Component} from the list of children.
   # @param c   The {Component} to remove.
   # @fail      If c is not a child of this instance.
   #
   public remove(c)
      return remove_index(get_index(c))
   end

   #
   # Remove the {Component} at the given index from the list of children.
   # @param i    The index
   # @fail      If i is out of range
   #
   public remove_index(i)
      local c
      c := self.children[i] | fail
      c.set_parent(&null)
      delete(self.children, i)
      if is_initialized() then {
         compute_z_order()
         compute_tab_order()
         c.finally()
      }
      return self
   end

   #
   # Remove all the children.
   #
   public remove_all()
      local c
      every c := !children do {
         c.set_parent(&null)
         c.finally()
      }
      clear(children)
      if is_initialized() then {
         compute_z_order()
         compute_tab_order()
      }
      return self
   end

   #
   # Move the {Component} to the given index position.
   # @param c   The {Component} to move.
   # @param j   The new position.
   # @fail      If c is not a child of this instance, 
   # @           or j is out of range.
   #
   public reposition(c, j)
      return reposition_index(get_index(c), j)
   end

   #
   # Move the {Component} at position {i} to {j}.
   # @param i   The old position.
   # @param j   The new position.
   # @fail      If either index is out of range.
   #
   public reposition_index(i, j)
      lmove(children, i, j) | fail
      if is_initialized() then {
         compute_z_order()
         compute_tab_order()
      }
      return self
   end

   #
   # Succeed iff the component has been initialized with {initially()}, but
   # not yet cleaned up with {finally()}.
   #
   public is_initialized()
      return \self.parent_dialog
   end

   #
   # Succeed iff the component has been initialized AND has a position and
   # size on the screen, ie has been laid out by its parent.
   #
   public is_live()
      return \self.x & \self.parent_dialog
   end

   #
   # Get the list of {Components} in this {Container}.
   # @return   The list of {Components}
   #
   public get_children()
      return self.children
   end

   #
   # Drag and drop helper to invoke drag_reset
   #
   public invoke_drag_reset(e)
      every (!self.children).invoke_drag_reset(e)
      drag_reset(e)
   end

   #
   # Invoked on a drag gesture; if the  component wishes to start a drag and drop session,
   # it should succeed and return the drag content, otherwise it should fail.  The drag
   # content is subsequently stored in the `content` of the current `Drag` object.
   #
   # NB - this method will only be invoked if the allow_drag flag is non-null.
   #
   # @param e the event, an instance of WindowEvent
   #
   public can_drag(e)
   end

   #
   # Invoked after `can_drag` succeeds, at the beginning of an operation.  Two pointers, "dnd positive" and
   # "dnd negative" should be defined to indicate to the user whether the current operation has
   # a potential drop or not.  By default, this method just uses two pre-defined pointers.
   #
   public define_dnd_pointers(drag)
      cbwin.copy_pointer("dnd negative", "circle")
      cbwin.copy_pointer("dnd positive", "hand2")
   end

   #
   # Invoked during a drag.  The component may update itself to indicate a potential drop
   # location.  If it succeeds, then this component becomes the "drag holder".  It is the only
   # component for which drag_event() is called in the future.  Should the method fail, then
   # the component ceases to be the "drag holder" and other components are tried again.
   #
   # NB - this method will only be invoked if the allow_drop flag is non-null.
   #
   # @param drag the current Drag object.
   # @param e the drag event
   #
   public drag_event(drag, e)
   end

   #
   # Invoked on the "drag holder", ie after the drag_event() method has succeeded for a
   # particular event.  The method indicates whether the current location is suitable for
   # a drop.  The mouse cursor is updated accordingly.   The component remains the "drag
   # holder" regardless of whether this method succeeds or fails.  On success, the data
   # returned is put into the content field of a Drag object, which is passed to
   # {perform_drop()} on a drop event.
   #
   # @param drag the current Drag object.
   # @param e the drag event
   #
   public can_drop(drag, e)
   end

   #
   # Invoked on a drop.  The component's can_drop() method has previously succeeded during
   # the drag.  However, the component can still reject the drop if it so wishes.
   #
   # If the component accepts the drop, it should handle it and succeed;
   # otherwise it should fail.
   #
   # NB - this method will only be invoked if the allow_drop flag is non-null.
   #
   # @param d the current Drag object representing the drag
   # @param d the current Drag object representing the drop.
   # @param e the drop event
   #
   public perform_drop(drag, drop, e)
   end

   #
   # Invoked on the component that started the drag, after a successful drop
   # @param d the current Drag object representing the drag
   # @param d the current Drag object representing the drop.
   # @param e the drop event
   #
   public end_drag(drag, drop, e)
   end

   #
   # Invoked at the end of drag and drop (on all components) to clear any drag state
   # @param e the last event
   #
   public drag_reset(e)
   end

   #
   # Configure whether the component allows drags, if it is so capable.
   #
   public set_allow_drag(s)
      self.allow_drag_flag := check_flag(s)
      return self
   end

   #
   # Configure whether the component allows drops, if it is so capable.
   #
   public set_allow_drop(s)
      self.allow_drop_flag := check_flag(s)
      return self
   end

   #
   # Configure whether to inherit wattribs from the parent; on by default.
   #
   public set_inherit_wattribs(s)
      self.inherit_wattribs_flag := check_flag(s)
      return self
   end

   #
   # Set whether the component will show the layout grid, if any.
   #
   public set_show_layout(s)
      self.show_layout_flag := check_flag(s)
      return self
   end

   public set_bg(v)
      set_wattrib("bg", v)
      return self
   end

   public set_fg(v)
      set_wattrib("fg", v)
      return self
   end

   public set_draw_op(v)
      set_wattrib("draw_op", v)
      return self
   end

   public set_font(v)
      set_wattrib("font", v)
      return self
   end

   public set_leading(v)
      set_wattrib("leading", v)
      return self
   end

   public set_line_width(v)
      set_wattrib("line_width", v)
      return self
   end

   public set_line_style(v)
      set_wattrib("line_style", v)
      return self
   end

   public set_pattern(v)
      set_wattrib("pattern", v)
      return self
   end

   public new()
      Connectable.new()
      self.wattribs := table()
      self.children := []
      self.x_align := Align.L
      self.y_align := Align.T
      self.constraints := table()
      self.preferred_focus := self
      self.z := self.tab_ord := 0
      self.tooltip_start_delay := Dialog.TOOLTIP_START_DELAY
      self.tooltip_end_delay := Dialog.TOOLTIP_END_DELAY
      self.inherit_wattribs_flag := 1
      return
   end
end
