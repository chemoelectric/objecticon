############################################################################
#
#	File:     tables.icn
#
#	Subject:  Procedures for table manipulation
#
#	Author:   Ralph E. Griswold
#
#	Date:     August 20, 1996
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#	Contributor:  Alan Beale
#
############################################################################
#
# 	keylist(T)	  produces list of keys in table T.
#
#	kvallist(T)	  produces values in T ordered by sorted order
#			  of keys.
#
#	tbleq(T1, T2)	  tests equivalences of tables T1 amd T2.
#  
#	tblunion(T1, T2)  approximates T1 ++ T2.
#
#	tblinter(T1, T2)  approximates T1 ** T2.
#
#	tbldiff(T1, T2)	  approximates T1 -- T2.
#
#	tblinvrt(T)	  produces a table whose keys are T's values and
#			  whose values are T's keys.
#
#	tbldflt(T)	  produces the default value for T.
#
#	twt(T)		  produces a two-way table based on T.
#
#	vallist(T)	  produces list of values in table T.
#
############################################################################
#
#  For the operations on tables that mimic set operations, the
#  correspondences are only approximate and do not have the mathematical
#  properties of the corresponding operations on  sets.  For example, table
#  "union" is not symmetric or transitive.
#
#  Where there is potential asymmetry, the procedures "favor" their
#  first argument.
#
#  All the procedures that return tables return new tables and do not
#  modify their arguments.
#
############################################################################

package ipl.tables

# table union
procedure tblunion(T1, T2)			
   local T3, x

   T3 := copy(T1)

   every x := key(T2) do
      insert(T3, x, T2[x])

   return T3

end

# table intersection
procedure tblinter(T1, T2)			
   local T3, x

   T3 := table(tbldflt(T1))

   every x := key(T1) do
      if member(T2, x) then insert(T3, x, T1[x])
   
   return T3

end

# table difference
procedure tbldiff(T1, T2)			
   local T3, x

   T3 := copy(T1)

   every x := key(T2) do
      delete(T3, x)

   return T3

end

# table inversion
procedure tblinvrt(T)				
   local T1, x

   T1 := table(tbldflt(T))

   every x := key(T) do
      insert(T1, T[x], x)

   return T1

end

# table default
procedure tbldflt(T)				
   static probe

   initial probe := []			# only need one

   return T[probe]

end

# two-way table
procedure twt(T)				
   local T1, x

   T1 := copy(T)

   every x := key(T) do
      insert(T1, T[x], x)

   return T1

end

# list of keys in table
procedure keylist(tbl)			
   local lst

   lst := []
   every put(lst, key(tbl))
   return sort(lst)

end

procedure kvallist(T)
   local result

   result := []
   
   every put(result, T[!keylist(T)])

   return result

end

# table equivalence
procedure tbleq(tbl1, tbl2)		
   local x
   static prod

   initial prod := []

   if *tbl1 ~= *tbl2 then fail
   if tbl1[prod] ~=== tbl2[prod] then fail
   else every x := key(tbl1) do
      if not(member(tbl2, x)) |
         (tbl2[x] ~=== tbl1[x]) then fail
   return tbl2

end

# list of table values
procedure vallist(tbl)		
   local list1

   list1 := []
   every put(list1, !tbl)
   return sort(list1)

end

# set of table values
procedure valset(tbl)		
   local set1

   set1 := set()
   every insert(set1, !tbl)
   return set1

end

# Generate key-value pairs as a sequence of 2-element lists.  NB - for each
# invocation, the same list is returned every time, with the values replaced.
#
procedure entries(t)
   local l, e
   l := []
   every e := key(t, 1) do {
      put(l, e)
      if *l = 2 then {
         suspend l
         while pop(l)
      }
   }
end

# Return a flat list, with alternating key-value entries.
procedure flatten(t)
   local l
   l := []
   every put(l, key(t, 1))
   return l
end

# Return an (unsorted) list of pairs of key-values.
procedure entrylist(t)
   local l, e, r
   r := []
   l := []
   every e := key(t, 1) do {
      put(l, e)
      if *l = 2 then {
         put(r, l)
         l := []
      }
   }
   return r
end
