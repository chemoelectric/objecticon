<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>ebcdic.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     ebcdic.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures to convert between ASCII and EBCDIC
<a name="6"/>#
<a name="7"/>#	Author:   Alan Beale
<a name="8"/>#
<a name="9"/>#	Date:     August 14, 1996
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#     These procedures assist in use of the ASCII and EBCDIC character sets,
<a name="18"/>#     regardless of the native character set of the host:
<a name="19"/>#
<a name="20"/>#     Ascii128()    Returns a 128-byte string of ASCII characters in
<a name="21"/>#                   numerical order.  Ascii128() should be used in
<a name="22"/>#                   preference to &amp;ascii for applications which might
<a name="23"/>#                   run on an EBCDIC host.
<a name="24"/>#
<a name="25"/>#     Ascii256()    Returns a 256-byte string representing the 256-
<a name="26"/>#                   character ASCII character set.  On an EBCDIC host,
<a name="27"/>#                   the order of the second 128 characters is essentially
<a name="28"/>#                   arbitrary.
<a name="29"/>#
<a name="30"/>#     Ebcdic()      Returns a 256-byte string of EBCDIC characters in
<a name="31"/>#                   numerical order.
<a name="32"/>#
<a name="33"/>#     AsciiChar(i)  Returns the character whose ASCII representation is i.
<a name="34"/>#
<a name="35"/>#     AsciiOrd(c)   Returns the position of the character c in the ASCII
<a name="36"/>#                   collating sequence.
<a name="37"/>#
<a name="38"/>#     EbcdicChar(i) Returns the character whose EBCDIC representation is i.
<a name="39"/>#
<a name="40"/>#     EbcdicOrd(c)  Returns the position of the character c in the EBCDIC
<a name="41"/>#                   collating sequence.
<a name="42"/>#
<a name="43"/>#     MapEtoA(s)    Maps a string of EBCDIC characters to the equivalent
<a name="44"/>#                   ASCII string, according to a plausible mapping.
<a name="45"/>#
<a name="46"/>#     MapAtoE(s)    Maps a string of ASCII characters to the equivalent
<a name="47"/>#                   EBCDIC string, according to a plausible mapping.
<a name="48"/>#
<a name="49"/>#     Control(c)    Returns the "control character" associated with the
<a name="50"/>#                   character c.  On an EBCDIC host, with $ representing
<a name="51"/>#                   an EBCDIC character with no 7-bit ASCII equivalent,
<a name="52"/>#                   Control("$") may not be identical to "\^$", as
<a name="53"/>#                   translated by ICONT (and neither result is particularly
<a name="54"/>#                   meaningful).
<a name="55"/>#
<a name="56"/>############################################################################
<a name="57"/>#
<a name="58"/>#   Notes:
<a name="59"/>#
<a name="60"/>#       There is no universally accepted mapping between ASCII and EBCDIC.
<a name="61"/>#       See the SHARE Inc. publication "ASCII and EBCDIC Character Set and
<a name="62"/>#       Code Issues in Systems Application Architecture" for more information
<a name="63"/>#       than you would ever want to have on this subject.
<a name="64"/>#
<a name="65"/>#       The mapping of the first 128 characters defined below by Ascii128()
<a name="66"/>#       is the most commonly accepted mapping, even though it probably
<a name="67"/>#       is not exactly like the mapping used by your favorite PC to mainframe
<a name="68"/>#       file transfer utility.  The mapping of the second 128 characters
<a name="69"/>#       is quite arbitrary, except that where an alternate translation of
<a name="70"/>#       ASCII char(n) is popular, this translation is assigned to
<a name="71"/>#       Ascii256()[n+129].
<a name="72"/>#
<a name="73"/>#       The behavior of all functions in this package is controlled solely
<a name="74"/>#       by the string literals in the _Eascii() procedure.  Therefore you
<a name="75"/>#       may modify these strings to taste, and still obtain consistent
<a name="76"/>#       results, provided that each character appears exactly once in the
<a name="77"/>#       result of _Eascii().
<a name="78"/>#
<a name="79"/>#       Yes, it's really true that the EBCDIC "\n" (NL, char(16r15)) is not
<a name="80"/>#       the same as "\l" (LF, char(16r25)).  How can that be?  "Don't blame
<a name="81"/>#       me, man, I didn't do it."
<a name="82"/>#
<a name="83"/>############################################################################
<a name="84"/>
<a name="85"/>package ipl.ebcdic
<a name="86"/>
<a name="87"/>procedure _Eascii()
<a name="88"/>    static EinAorder
<a name="89"/>    initial
<a name="90"/>        EinAorder :=
<a name="91"/>#            NUL SOH STX ETX EOT ENQ ACK BEL BS  HT  NL  VT  FF  CR  SO  SI
<a name="92"/>           "\x00\x01\x02\x03\x37\x2d\x2e\x2f\x16\x05\x15\x0b\x0c\x0d\x0e\x0f"||
<a name="93"/>#            DLE DC1 DC2 DC3 DC4 NAK SYN ETB CAN EM  SUB ESC FS  GS  RS  US
<a name="94"/>           "\x10\x11\x12\x13\x3c\x3d\x32\x26\x18\x19\x3f\x27\x1c\x1d\x1e\x1f"||
<a name="95"/>#            sp  !   "   #   $   %   &amp;   '   (   )   *   +   ,   -   .   /
<a name="96"/>           "\x40\x5a\x7f\x7b\x5b\x6c\x50\x7d\x4d\x5d\x5c\x4e\x6b\x60\x4b\x61"||
<a name="97"/>#            0   1   2   3   4   5   6   7   8   9   :   ;   &lt;   =   &gt;   ?
<a name="98"/>           "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\x7a\x5e\x4c\x7e\x6e\x6f"||
<a name="99"/>#            @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
<a name="100"/>           "\x7c\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xd1\xd2\xd3\xd4\xd5\xd6"||
<a name="101"/>#            P   Q   R   S   T   U   V   W   X   Y   Z   $&lt;  \   $&gt;  ^   _
<a name="102"/>           "\xd7\xd8\xd9\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xad\xe0\xbd\x5f\x6d"||
<a name="103"/>#            `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
<a name="104"/>           "\x79\x81\x82\x83\x84\x85\x86\x87\x88\x89\x91\x92\x93\x94\x95\x96"||
<a name="105"/>#            p   q   r   s   t   u   v   w   x   y   z   $(  |   $)  ~   DEL
<a name="106"/>           "\x97\x98\x99\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xc0\x4f\xd0\xa1\x07"||
<a name="107"/>           "\x04\x06\x08\x09\x0a\x14\x17\x1a\x1b\x20\x25\x21\x22\x23\x24\x28_
<a name="108"/>            \x29\x2a\x2b\x2c\x30\x31\x33\x34\x35\x36\x38\x39\x3a\x3b\x3e\xff_
<a name="109"/>            \x41\x42\x43\x44\x4a\x45\x46\x47\x48\x49\x51\x52\x53\x54\x55\x56_
<a name="110"/>            \x57\x58\x59\x62\x63\x64\x65\x66\x67\x68\x69\x70\x71\x72\x73\x74_
<a name="111"/>            \x75\x76\x77\x78\x80\x8a\x8c\x8d\x8e\x8f\x90\x9a\x9c\x9d\x9e\x9f_
<a name="112"/>            \xa0\xaa\xab\xac\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9_
<a name="113"/>            \xba\xbb\xbc\xbe\xbf\xca\xcb\xcc\xcd\xce\xcf\xda\xdb\xdc\xdd\xde_
<a name="114"/>            \xdf\xe1\xea\xeb\xec\xed\xee\xef\xfa\xfb\xfc\x8b\x6a\x9b\xfd\xfe"
<a name="115"/>    return EinAorder
<a name="116"/>end
<a name="117"/>
<a name="118"/>procedure Ascii128()
<a name="119"/>    if "\l" == "\n" then return string(&amp;ascii)
<a name="120"/>    return _Eascii()[1+:128]
<a name="121"/>end
<a name="122"/>
<a name="123"/>procedure Ascii256()
<a name="124"/>    if "\l" == "\n" then return string(&amp;cset)
<a name="125"/>    return _Eascii()
<a name="126"/>end
<a name="127"/>
<a name="128"/>procedure Ebcdic()
<a name="129"/>    if "\l" ~== "\n" then return &amp;cset
<a name="130"/>    return map(&amp;cset, _Eascii(), &amp;cset)
<a name="131"/>end
<a name="132"/>
<a name="133"/>procedure AsciiChar(i)
<a name="134"/>    if "\l" == "\n" then return char(i)
<a name="135"/>    return _Eascii()[0 &lt; i+1] | runerr(205,i)
<a name="136"/>end
<a name="137"/>
<a name="138"/>procedure AsciiOrd(c)
<a name="139"/>    if "\l" == "\n" then return ord(c)
<a name="140"/>    return ord(MapEtoA(c))
<a name="141"/>end
<a name="142"/>
<a name="143"/>procedure EbcdicChar(i)
<a name="144"/>    if "\l" ~== "\n" then return char(i)
<a name="145"/>    return map(char(i), _Eascii(), &amp;cset)
<a name="146"/>end
<a name="147"/>
<a name="148"/>procedure EbcdicOrd(c)
<a name="149"/>    if "\l" ~== "\n" then return ord(c)
<a name="150"/>    return ord(MapAtoE(c))
<a name="151"/>end
<a name="152"/>
<a name="153"/>procedure MapEtoA(s)
<a name="154"/>    return map(s, _Eascii(), &amp;cset)
<a name="155"/>end
<a name="156"/>
<a name="157"/>procedure MapAtoE(s)
<a name="158"/>    return map(s, &amp;cset, _Eascii())
<a name="159"/>end
<a name="160"/>
<a name="161"/>procedure Control(c)
<a name="162"/>    return AsciiChar(iand(AsciiOrd(c),16r1f))
<a name="163"/>end
</pre></body></html>
