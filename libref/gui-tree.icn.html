<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>tree.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: tree.icn 8656 2020-11-08 19:36:43Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package gui
<a name="10"/>
<a name="11"/>import util, graphics, ipl.pdco
<a name="12"/>
<a name="13"/>#
<a name="14"/># This class represents a tree object.  A `Event.TREE_NODE_EXPANSION` event occurs when
<a name="15"/># a node is expanded/contracted.  Also, the events generated by the parent class
<a name="16"/># `SelectableScrollArea` are inherited.
<a name="17"/>#
<a name="18"/>abstract class BaseTree(SelectableScrollArea)
<a name="19"/>   public 
<a name="20"/>      root_node,
<a name="21"/>      default_icon_paint,
<a name="22"/>      fixed_col_w,
<a name="23"/>      col_w,
<a name="24"/>      img_w,
<a name="25"/>      img_h,
<a name="26"/>      plus,
<a name="27"/>      minus,
<a name="28"/>      last_expanded,
<a name="29"/>      show_root_flag,
<a name="30"/>      show_root_handles_flag
<a name="31"/>
<a name="32"/>   public static const
<a name="33"/>      COL_PAD               # X spacing around node images (if used)
<a name="34"/>
<a name="35"/>   private static init()
<a name="36"/>      local sz
<a name="37"/>      sz := scale(16)
<a name="38"/>      ImageCache.copy_key_with_resize("gui.CLOSED_FOLDER", "gui.CLOSED_FOLDER_16", sz, sz)
<a name="39"/>      ImageCache.copy_key_with_resize("gui.OPEN_FOLDER", "gui.OPEN_FOLDER_16", sz, sz)
<a name="40"/>      ImageCache.copy_key_with_resize("gui.FILE", "gui.FILE_16", sz, sz)
<a name="41"/>      COL_PAD := scale(2)
<a name="42"/>   end
<a name="43"/>   
<a name="44"/>   public abstract get_node_data_width(n)
<a name="45"/>
<a name="46"/>   public abstract draw_node_data(n, xp, yp)
<a name="47"/>
<a name="48"/>   public invalidate_node_images()
<a name="49"/>      col_w := img_w := img_h := &amp;null
<a name="50"/>      invalidate_line_height()
<a name="51"/>      link
<a name="52"/>   end
<a name="53"/>
<a name="54"/>   public override initially()
<a name="55"/>      # Ensure we start off with an up-to-date representation.
<a name="56"/>      tree_structure_changed()
<a name="57"/>      SelectableScrollArea.initially()
<a name="58"/>      self.plus.initially(self)
<a name="59"/>      self.minus.initially(self)
<a name="60"/>      plus.w = minus.w | runerr("Handle image widths differ")
<a name="61"/>      plus.h = minus.h | runerr("Handle image heights differ")
<a name="62"/>      every (!default_icon_paint).initially(self)
<a name="63"/>   end
<a name="64"/>
<a name="65"/>   public override finally()
<a name="66"/>      SelectableScrollArea.finally()
<a name="67"/>      self.plus.finally()
<a name="68"/>      self.minus.finally()
<a name="69"/>      every (!default_icon_paint).finally()
<a name="70"/>   end
<a name="71"/>
<a name="72"/>   #
<a name="73"/>   # Expand all the nodes in the `Tree`.  Nodes with no children
<a name="74"/>   # are not expanded unless the force flag is set to &amp;yes.
<a name="75"/>   #
<a name="76"/>   public expand(force)
<a name="77"/>      if \root_node then {
<a name="78"/>         root_node.expand(force)
<a name="79"/>         tree_structure_changed()
<a name="80"/>      }
<a name="81"/>      link
<a name="82"/>   end
<a name="83"/>
<a name="84"/>   #
<a name="85"/>   # Set the default icons for each `Node` in the `Tree`.  The parameters should be
<a name="86"/>   # three distinct `Paint` objects.
<a name="87"/>   #
<a name="88"/>   public set_default_icon_paint(i1, i2, i3)
<a name="89"/>      if is_initialized() then {
<a name="90"/>         every (!default_icon_paint).finally()
<a name="91"/>         self.default_icon_paint := [i1, i2, i3]
<a name="92"/>         every (!default_icon_paint).initially(self)
<a name="93"/>         invalidate_node_images()
<a name="94"/>         compute_and_invalidate()
<a name="95"/>      } else
<a name="96"/>         self.default_icon_paint := [i1, i2, i3]
<a name="97"/>      link
<a name="98"/>   end
<a name="99"/>
<a name="100"/>   # Set the handle `Paint`s (ie the little + and - icons).  The two
<a name="101"/>   # parameters should be distinct instances.
<a name="102"/>   #
<a name="103"/>   public set_handle_paint(p, m)
<a name="104"/>      if is_initialized() then {
<a name="105"/>         every (plus | minus).finally()
<a name="106"/>         self.plus := p
<a name="107"/>         self.minus := m
<a name="108"/>         every (plus | minus).initially(self)
<a name="109"/>         invalidate()
<a name="110"/>         plus.w = minus.w | runerr("Handle image widths differ")
<a name="111"/>         plus.h = minus.h | runerr("Handle image heights differ")
<a name="112"/>      } else {
<a name="113"/>         self.plus := p
<a name="114"/>         self.minus := m
<a name="115"/>      }
<a name="116"/>      link
<a name="117"/>   end
<a name="118"/>
<a name="119"/>   #
<a name="120"/>   # Set the root node of the `Tree`.
<a name="121"/>   #
<a name="122"/>   public set_root_node(r)
<a name="123"/>      root_node := r
<a name="124"/>      if /r then
<a name="125"/>         set_contents([])
<a name="126"/>      else {
<a name="127"/>         root_node.is_expanded_flag := &amp;yes
<a name="128"/>         invalidate_node_images()
<a name="129"/>         set_contents(flatten())
<a name="130"/>         set_selections([])
<a name="131"/>      }
<a name="132"/>      link
<a name="133"/>   end
<a name="134"/>
<a name="135"/>   #
<a name="136"/>   # Get the root node of the tree
<a name="137"/>   #
<a name="138"/>   public get_root_node()
<a name="139"/>      return root_node
<a name="140"/>   end
<a name="141"/>
<a name="142"/>   public tree_structure_changed()
<a name="143"/>      local sels
<a name="144"/>      if \root_node then {
<a name="145"/>         sels := object_get_selections()
<a name="146"/>         set_contents(flatten())
<a name="147"/>         object_set_selections(sels)
<a name="148"/>      }
<a name="149"/>      link
<a name="150"/>   end
<a name="151"/>
<a name="152"/>   #
<a name="153"/>   # Set whether root handles are shown (default yes).
<a name="154"/>   #
<a name="155"/>   public set_show_root_handles(s)
<a name="156"/>      self.show_root_handles_flag := need_flag(s)
<a name="157"/>      self.tree_structure_changed()
<a name="158"/>      link
<a name="159"/>   end
<a name="160"/>
<a name="161"/>   #
<a name="162"/>   # Set whether the root is shown (default yes).
<a name="163"/>   #
<a name="164"/>   public set_show_root(s)
<a name="165"/>      self.show_root_flag := need_flag(s)
<a name="166"/>      self.tree_structure_changed()
<a name="167"/>      link
<a name="168"/>   end
<a name="169"/>
<a name="170"/>   #
<a name="171"/>   # Use a fixed column width, and let the node draw the icons
<a name="172"/>   #
<a name="173"/>   public set_fixed_col_w(w)
<a name="174"/>      self.fixed_col_w := need_integer(w, 0)
<a name="175"/>      link
<a name="176"/>   end
<a name="177"/>
<a name="178"/>   public compute_img_wh()
<a name="179"/>      local n, icon_paint
<a name="180"/>      if /fixed_col_w then {
<a name="181"/>         img_w := img_h := 0
<a name="182"/>         every n := Seq{(\root_node).traverse_all_preorder()} do {
<a name="183"/>            icon_paint := \n.icon_paint | default_icon_paint
<a name="184"/>            img_w &lt;:= icon_paint[1].w
<a name="185"/>            img_w &lt;:= icon_paint[2].w
<a name="186"/>            img_w &lt;:= icon_paint[3].w
<a name="187"/>            img_h &lt;:= icon_paint[1].h
<a name="188"/>            img_h &lt;:= icon_paint[2].h
<a name="189"/>            img_h &lt;:= icon_paint[3].h
<a name="190"/>         }
<a name="191"/>
<a name="192"/>         #
<a name="193"/>         # The column width is slightly wider than the bitmap width
<a name="194"/>         #
<a name="195"/>         col_w := img_w + 2 * COL_PAD
<a name="196"/>      } else
<a name="197"/>         col_w := fixed_col_w
<a name="198"/>   end
<a name="199"/>
<a name="200"/>   #
<a name="201"/>   # This method returns a flat list of all the `Nodes` in the tree that are
<a name="202"/>   # currently displayed.
<a name="203"/>   # :Returns :
<a name="204"/>   # :  A list of nodes.
<a name="205"/>   #
<a name="206"/>   public flatten()
<a name="207"/>      local l, sub
<a name="208"/>      l := []
<a name="209"/>      if \self.show_root_flag then {
<a name="210"/>         if \self.show_root_handles_flag then
<a name="211"/>            flatten2(l, root_node, "n")
<a name="212"/>         else
<a name="213"/>            flatten2(l, root_node, "")
<a name="214"/>      } else {
<a name="215"/>         if \self.show_root_handles_flag then {
<a name="216"/>            if *root_node.children = 1 then {
<a name="217"/>               flatten2(l, root_node.children[1], "n")
<a name="218"/>            } else {
<a name="219"/>               flatten2(l, root_node.children[1], "d")
<a name="220"/>               every sub := root_node.children[2 to *root_node.children - 1] do 
<a name="221"/>                  flatten2(l, sub, "f")
<a name="222"/>               flatten2(l, root_node.children[-1], "u")
<a name="223"/>            }
<a name="224"/>         } else {
<a name="225"/>            every flatten2(l, !root_node.children, "")
<a name="226"/>         }
<a name="227"/>      }
<a name="228"/>
<a name="229"/>      return l
<a name="230"/>   end
<a name="231"/>
<a name="232"/>   public flatten2(l, n, dl)
<a name="233"/>      local sub
<a name="234"/>      n.draw_line := dl
<a name="235"/>      n.depth := *dl
<a name="236"/>      put(l, n)
<a name="237"/>      if n.is_expanded() then {
<a name="238"/>         every sub := n.children[1 to *n.children - 1] do 
<a name="239"/>            flatten2(l, sub, dl || "f")
<a name="240"/>         flatten2(l, n.children[-1], dl || "u")
<a name="241"/>      }
<a name="242"/>   end
<a name="243"/>
<a name="244"/>   public override handle_lpress(e)
<a name="245"/>      local l, l_off, N, curr_sel, curr_cursor, yp, xp
<a name="246"/>      if l := get_line_under_pointer(e) then {
<a name="247"/>         l_off := get_cum_line_height(l) - get_area_y()
<a name="248"/>         N := self.contents[l]
<a name="249"/>         if (N.depth &gt; 0) &amp; (*N.children &gt; 0) | \N.always_expandable_flag then {
<a name="250"/>            #
<a name="251"/>            # Check for click on little +/- icon.
<a name="252"/>            #
<a name="253"/>            yp := self.view.y + get_height_for_line(l) / 2 + l_off - plus.h / 2
<a name="254"/>            xp := self.get_subject_x() + N.depth * col_w - col_w / 2  - plus.w / 2
<a name="255"/>            if (xp &lt;= e.x &lt; xp + plus.w) &amp; (yp &lt;= e.y &lt; yp + plus.h) then {
<a name="256"/>               curr_sel := *get_selections()
<a name="257"/>               curr_cursor := self.cursor
<a name="258"/>               N.toggle_expanded()
<a name="259"/>               self.last_expanded := N
<a name="260"/>               tree_structure_changed()
<a name="261"/>               parent_dialog.release(self.view, Mouse.LEFT_PRESS)
<a name="262"/>               if curr_cursor ~=== self.cursor then
<a name="263"/>                  fire(Event.CURSOR_MOVED, e)
<a name="264"/>               # Just monitor the number of selections to detect a
<a name="265"/>               # change.  This gives a different to result to what we
<a name="266"/>               # would get with start_handle/end_handle, which is
<a name="267"/>               # based on selected line numbers.
<a name="268"/>               if *get_selections() ~= curr_sel then
<a name="269"/>                  fire(Event.SELECTION_CHANGED, e)
<a name="270"/>               fire(Event.TREE_NODE_EXPANSION, e)
<a name="271"/>               return
<a name="272"/>            }
<a name="273"/>         }
<a name="274"/>      }
<a name="275"/>      SelectableScrollArea.handle_lpress(e)
<a name="276"/>   end
<a name="277"/>
<a name="278"/>   public get_last_expanded()
<a name="279"/>      return self.last_expanded
<a name="280"/>   end
<a name="281"/>
<a name="282"/>   public override draw_line(xp, yp, lh, i, sel, cur, hi, ov)
<a name="283"/>      local N, dashed, lp, j, icon_paint, img, little, y0, thick, thick2
<a name="284"/>
<a name="285"/>      y0 := yp + lh / 2
<a name="286"/>      thick := Gui.FINE_WIDTH
<a name="287"/>      thick2 := thick / 2
<a name="288"/>      N := contents[i]
<a name="289"/>      use {
<a name="290"/>         dashed := view.cbwin.clone(),
<a name="291"/>         {
<a name="292"/>            dashed.set_masked_pattern("gray")
<a name="293"/>            lp := xp
<a name="294"/>            every j := 1 to N.depth - 1 do {
<a name="295"/>               if N.draw_line[j] == ("f"|"d") then
<a name="296"/>                  dashed.fill_rectangle(lp + col_w / 2 - thick2, yp, thick, lh)
<a name="297"/>               
<a name="298"/>               lp +:= col_w
<a name="299"/>            }
<a name="300"/>            if N.depth &gt; 0 then {
<a name="301"/>               case N.draw_line[N.depth] of {
<a name="302"/>                  "d": dashed.fill_rectangle(lp + col_w / 2 - thick2, y0, thick, lh / 2 + 1)
<a name="303"/>                  "f": dashed.fill_rectangle(lp + col_w / 2 - thick2, yp, thick, lh)
<a name="304"/>                  "u": dashed.fill_rectangle(lp + col_w / 2 - thick2, yp, thick, lh / 2 + 1)
<a name="305"/>               }
<a name="306"/>               dashed.fill_rectangle(lp + col_w / 2, y0 - thick2, col_w + 1, thick)
<a name="307"/>
<a name="308"/>               lp +:= col_w
<a name="309"/>            }
<a name="310"/>
<a name="311"/>            icon_paint := \N.icon_paint | default_icon_paint
<a name="312"/>            if (*N.children = 0) &amp; /N.always_expandable_flag then
<a name="313"/>               img := icon_paint[3]
<a name="314"/>            else {
<a name="315"/>               if \N.is_expanded_flag then {
<a name="316"/>                  img := icon_paint[2]
<a name="317"/>                  little := minus
<a name="318"/>                  if *N.children &gt; 0 then
<a name="319"/>                     dashed.fill_rectangle(lp + col_w / 2 - thick2, y0, thick, lh / 2 + 1)
<a name="320"/>               } else {
<a name="321"/>                  img := icon_paint[1]
<a name="322"/>                  little := plus
<a name="323"/>               }
<a name="324"/>               # Erase first as the little +/- are not opaque images, and we may have drawn a line here.
<a name="325"/>               view.cbwin.erase_area(lp - col_w / 2 - plus.w / 2, y0 - plus.h / 2, plus.w, plus.h)
<a name="326"/>               little.draw(view.cbwin, lp - col_w / 2 - plus.w / 2, y0 - plus.h / 2)
<a name="327"/>            }
<a name="328"/>            if /fixed_col_w then {
<a name="329"/>               (\img).draw(view.cbwin, lp + col_w / 2 - img.w / 2, y0 - img.h / 2)
<a name="330"/>               draw_node_data(N, lp + col_w, yp, lh)
<a name="331"/>               draw_line_sel_cur(lp + col_w, yp, get_node_data_width(N), lh, sel, cur, hi, ov)
<a name="332"/>            } else {
<a name="333"/>               draw_node_data(N, lp, yp, lh)
<a name="334"/>               draw_line_sel_cur(lp, yp, get_node_data_width(N), lh, sel, cur, hi, ov)
<a name="335"/>            }
<a name="336"/>         }
<a name="337"/>      }
<a name="338"/>   end
<a name="339"/>
<a name="340"/>   public override new()
<a name="341"/>      SelectableScrollArea.new()
<a name="342"/>      set_handle_paint(ImagePaint().set_cache("gui.PLUS"),
<a name="343"/>                       ImagePaint().set_cache("gui.MINUS"))
<a name="344"/>      set_default_icon_paint(ImagePaint().set_cache("gui.CLOSED_FOLDER"), 
<a name="345"/>                             ImagePaint().set_cache("gui.OPEN_FOLDER"),
<a name="346"/>                             ImagePaint().set_cache("gui.FILE"))
<a name="347"/>      show_root_flag := show_root_handles_flag := &amp;yes
<a name="348"/>      return
<a name="349"/>   end
<a name="350"/>end
<a name="351"/>
<a name="352"/>#
<a name="353"/># The basic tree, which displays simple textual node data.
<a name="354"/>#
<a name="355"/>class Tree(BaseTree)
<a name="356"/>   public override calculate_line_height()
<a name="357"/>      local res
<a name="358"/>      if /col_w then
<a name="359"/>         compute_img_wh()
<a name="360"/>      res:= view.cbwin.get_line_height()
<a name="361"/>      #
<a name="362"/>      # Ensure the line height is slightly greater than the
<a name="363"/>      # bitmap height
<a name="364"/>      #
<a name="365"/>      res &lt;:= \img_h + 2 * Gui.Y_INSET
<a name="366"/>      return res
<a name="367"/>   end
<a name="368"/>
<a name="369"/>   public override calculate_subject_width()
<a name="370"/>      local mw, n
<a name="371"/>      mw := 0
<a name="372"/>      if /fixed_col_w then {
<a name="373"/>         every n := !self.contents do
<a name="374"/>            mw &lt;:= col_w * n.depth + col_w + view.cbwin.text_width(n.label)
<a name="375"/>      } else {
<a name="376"/>         every n := !self.contents do
<a name="377"/>            mw &lt;:= col_w * n.depth + view.cbwin.text_width(n.label)
<a name="378"/>      }
<a name="379"/>
<a name="380"/>      return mw + 2 * Gui.TEXT_INSET
<a name="381"/>   end
<a name="382"/>
<a name="383"/>   public override get_node_data_width(n)
<a name="384"/>      return view.cbwin.text_width(n.label) + 2 * Gui.TEXT_INSET
<a name="385"/>   end
<a name="386"/>
<a name="387"/>   public override draw_node_data(n, xp, yp)
<a name="388"/>      local W
<a name="389"/>      W := view.cbwin
<a name="390"/>      W.draw_string(xp + Gui.TEXT_INSET,
<a name="391"/>                    yp + (line_height + W.get_font_ascent() - W.get_font_descent()) / 2,
<a name="392"/>                    n.label)
<a name="393"/>   end
<a name="394"/>end
<a name="395"/>
<a name="396"/>#
<a name="397"/># A tree which delegates interpretation of the node data to
<a name="398"/># an `ItemPaint` instance.
<a name="399"/>#
<a name="400"/>class ItemPaintTree(BaseTree)
<a name="401"/>   public
<a name="402"/>      item_paint,
<a name="403"/>      item_border
<a name="404"/>
<a name="405"/>   public override initially()
<a name="406"/>      \self.item_paint | runerr("ItemPaint not set")
<a name="407"/>      BaseTree.initially()
<a name="408"/>      self.item_paint.initially(self)
<a name="409"/>      self.item_border.initially(self)
<a name="410"/>   end
<a name="411"/>
<a name="412"/>   public override finally()
<a name="413"/>      BaseTree.finally()
<a name="414"/>      self.item_paint.finally()
<a name="415"/>      self.item_border.finally()
<a name="416"/>   end
<a name="417"/>
<a name="418"/>   public set_item_paint(r)
<a name="419"/>      if is_initialized() then {
<a name="420"/>         (\self.item_paint).finally()
<a name="421"/>         self.item_paint := r
<a name="422"/>         self.item_paint.initially(self)
<a name="423"/>      } else
<a name="424"/>         self.item_paint := r
<a name="425"/>      link
<a name="426"/>   end
<a name="427"/>
<a name="428"/>   #
<a name="429"/>   # Set a border to draw along with each Paint instance.
<a name="430"/>   #
<a name="431"/>   public set_item_border(b)
<a name="432"/>      if is_initialized() then {
<a name="433"/>         (\self.item_border).finally()
<a name="434"/>         self.item_border := b
<a name="435"/>         self.item_border.initially(self)
<a name="436"/>      } else
<a name="437"/>         self.item_border := b
<a name="438"/>      link
<a name="439"/>   end
<a name="440"/>
<a name="441"/>   public override calculate_line_height()
<a name="442"/>      local h, h1, bh
<a name="443"/>      if /col_w then
<a name="444"/>         compute_img_wh()
<a name="445"/>      bh := item_border.get_total_height()
<a name="446"/>      if h := item_paint.get_constant_height(view.cbwin) + bh then {
<a name="447"/>         #
<a name="448"/>         # Ensure the line height is slightly greater than the
<a name="449"/>         # bitmap height
<a name="450"/>         #
<a name="451"/>         h &lt;:= \img_h + 2 * Gui.Y_INSET
<a name="452"/>      } else {
<a name="453"/>         h := []
<a name="454"/>         every h1 := item_paint.get_height(view.cbwin, (!self.contents).label) + bh do {
<a name="455"/>            h1 &lt;:= \img_h + 2 * Gui.Y_INSET
<a name="456"/>            put(h, h1)
<a name="457"/>         }
<a name="458"/>      }
<a name="459"/>      return h
<a name="460"/>   end
<a name="461"/>
<a name="462"/>   public override calculate_subject_width()
<a name="463"/>      local cw, mw, n
<a name="464"/>      mw := 0
<a name="465"/>      if /fixed_col_w then {
<a name="466"/>         if cw := item_paint.get_constant_width(self.cbwin) then {
<a name="467"/>            every n := !self.contents do
<a name="468"/>               mw &lt;:= col_w * n.depth + col_w + cw
<a name="469"/>         } else {
<a name="470"/>            every n := !self.contents do
<a name="471"/>               mw &lt;:= col_w * n.depth + col_w + item_paint.get_width(view.cbwin, n.label)
<a name="472"/>         }
<a name="473"/>      } else {
<a name="474"/>         if cw := item_paint.get_constant_width(self.cbwin) then {
<a name="475"/>            every n := !self.contents do
<a name="476"/>               mw &lt;:= col_w * n.depth + cw
<a name="477"/>         } else {
<a name="478"/>            every n := !self.contents do
<a name="479"/>               mw &lt;:= col_w * n.depth + item_paint.get_width(view.cbwin, n.label)
<a name="480"/>         }
<a name="481"/>      }
<a name="482"/>
<a name="483"/>      return mw + item_border.get_total_width()
<a name="484"/>   end
<a name="485"/>
<a name="486"/>   public override get_node_data_width(n)
<a name="487"/>      return (item_paint.get_constant_width(self.cbwin) | 
<a name="488"/>              item_paint.get_width(view.cbwin, n.label)) + item_border.get_total_width()
<a name="489"/>   end
<a name="490"/>
<a name="491"/>   public override draw_node_data(n, xp, yp, lh)
<a name="492"/>      local r, s
<a name="493"/>      s := item_paint.get_size(view.cbwin, n.label)
<a name="494"/>      r := Rect(xp, yp, s.w + item_border.get_total_width(), lh)
<a name="495"/>      item_paint.draw_rect(view.cbwin, n.label, item_border.float(r, s))
<a name="496"/>      item_border.draw_rect(view.cbwin, r)
<a name="497"/>   end
<a name="498"/>
<a name="499"/>   public override draw_line_sel_cur(x, y, w, h, sel, cur, hi, ov)
<a name="500"/>      if \sel then
<a name="501"/>         Gui.style.fill_selection_rectangle(view.cbwin, x, y, w, h)
<a name="502"/>      case \cur of {
<a name="503"/>         "f": item_border.draw_focus(view.cbwin, x, y, w, h)
<a name="504"/>         "d": item_border.draw_dashed(view.cbwin, x, y, w, h)
<a name="505"/>      }
<a name="506"/>      case \hi of {
<a name="507"/>         "t": Gui.style.fill_highlight_rectangle(view.cbwin, x, y, w, INTER_LINE_WIDTH)
<a name="508"/>         "b": Gui.style.fill_highlight_rectangle(view.cbwin, x, y + h - INTER_LINE_WIDTH, w, INTER_LINE_WIDTH)
<a name="509"/>         "m": item_border.draw_highlight(view.cbwin, x, y, w, h)
<a name="510"/>      }
<a name="511"/>      if \ov then
<a name="512"/>         Gui.style.fill_over_rectangle(view.cbwin, x, y, w, h)
<a name="513"/>   end
<a name="514"/>
<a name="515"/>   public override new()
<a name="516"/>      BaseTree.new()
<a name="517"/>      self.set_item_border(NullBorder().
<a name="518"/>                           set_x_align(Align.L))
<a name="519"/>      return
<a name="520"/>   end
<a name="521"/>end
</pre></body></html>
