package plan9

import io, lang, util, exception, ipl.strings, ipl.pdco

package record RAttach(tag, qid)
package record RAuth(tag, aqid)
package record RClunk(tag)
package record RCreate(tag, qid, iounit)
package record RError(tag, ename)
package record RFlush(tag)
package record ROpen(tag, qid, iounit)
package record RRead(tag, data)
package record RRemove(tag)
package record RStat(tag, stat)
package record RVersion(tag, msize, version)
package record RWalk(tag, wqid)
package record RWrite(tag, count)
package record RWstat(tag)
package record TAttach(tag, fid, afid, uname, aname)
package record TAuth(tag, afid, uname, aname)
package record TClunk(tag, fid)
package record TCreate(tag, fid, name, perm, mode)
package record TFlush(tag, oldtag)
package record TOpen(tag, fid, mode)
package record TRead(tag, fid, offset, count)
package record TRemove(tag, fid)
package record TStat(tag, fid)
package record TVersion(tag, msize, version)
package record TWalk(tag, fid, newfid, wname)
package record TWrite(tag, fid, offset, data)
package record TWstat(tag, fid, stat)
package record Tinvalid()

record Info(mode, atime, mtime, length, name, uid, gid, muid)
record Qid(type, version, path)

# This class represents a single entry in a file hierarchy, which can
# be constructed and served to 9P clients.  This class just deals with
# the metadata, such as permissions, user ids and so on.  The detail
# of how data is stored (be it file or directory data), is left to the
# subclasses.
#
abstract class File9P()
   private readable
      parent,
      name,
      perm,
      qversion,
      qpath,
      atime,
      mtime,
      uid,
      gid,
      muid,
      fixed

   private static 
      qpath_seq, user
      
   private static init()
      qpath_seq := 0
      user := Files.file_to_string("/env/user") | "none"
   end

   public get_length()
      return 0
   end

   public set_length(len)
      link
   end

   public modified(uid)
      self.qversion +:= 1
      self.muid := uid
      self.mtime := Time.get_system_seconds()
      link
   end

   public open(mode)
      link
   end

   public close()
      link
   end

   public get_file_key()
      link
   end

   public path_unreferenced()
      link
   end

   # Return the parent, or fail if this is the root directory.
   #
   public get_parent()
      return .\self.parent
   end

   public get_info()
      return Info(perm, atime, mtime, get_length(), name, uid, gid, muid)
   end

   # Set the file's settings from the given `Info` record.
   #
   # Note that the file's mode, mtime and gid are protected by the
   # fixed flag, since, unlike the other two editable settings (name
   # and length), they can't be protected by file permissions (see the
   # comments relating to TWstat in Session9P below).
   #
   public set_info(x)
      if \fixed & (\x.mode | \x.mtime | \x.gid) then throw("Permission denied")
      set_perm(\x.mode)
      set_mtime(\x.mtime)
      set_name(\x.name)
      set_length(\x.length)
      set_gid(\x.gid)
      link
   end

   # Note that normally `set_parent` should not be called; rather
   # `add_child` in the parent directory should be used.  This method
   # is public in order to allow files to point upwards to a
   # directory, but for the directory to not link downwards to them,
   # so that they don't appear in the directory's contents.
   #
   public set_parent(x)
      self.parent := x
      link
   end

   public set_name(x)
      # Must be string since it's used as a table key
      x := need_string(x)
      (\parent).rename_child(self, x)
      self.name := x
      link
   end

   # Shorthand for `set_perm(x, &yes)`
   #
   public set_fixed_perm(x)
      return set_perm(x, &yes)
   end

   # Set the permissions mode to `x`, and the fixed flag to `y`.  If
   # this latter flag is set, then the permissions mode, modification
   # time and group id are all protected from modification regardless
   # of the normal permission rules.
   #
   # For a directory, there is no need to specify DMDIR, as this is
   # or'ed to `x` automatically.
   #
   public set_perm(x, y)
      if is(self,Dir9P) then 
         x := ior(x, Mode9.DMDIR)
      else
         iand(x, Mode9.DMDIR) = 0 | rthrow("Cannot set DMDIR in a regular file")
      self.perm := x
      self.fixed := y
      link
   end

   public set_qversion(x)
      self.qversion := x
      link
   end

   public set_mtime(x)
      self.mtime := x
      link
   end

   public set_atime(x)
      self.atime := x
      link
   end

   public set_uid(x)
      self.uid := x
      link
   end

   public set_gid(x)
      self.gid := x
      link
   end

   public set_muid(x)
      self.muid := x
      link
   end

   public get_qid()
      return Qid(ishift(perm, -24), qversion, qpath)
   end

   # Create a new instance with the given filename.
   #
   public new(name)
      set_name(name)
      self.qversion := 0
      self.qpath := (qpath_seq +:= 1)
      self.mtime := self.atime := Time.get_system_seconds()
      self.uid := self.gid := self.muid := user
      self.perm := if is(self,Dir9P) then ior(8r777, Mode9.DMDIR) else 8r666
      return
   end
end

# A `File9P` which is a directory, rather than a regular file.  The
# details of how directory information is stored is left to
# subclasses.  The optional methods are only needed for writable
# directories.
#
abstract class Dir9P(File9P)
   public optional add_child(x)
   public optional remove_child(x)
   public abstract get_child(x)
   package optional rename_child(x, s)
   public abstract gen_children()
   public optional create_child(name, uid, perm)
end

# An implementation of `Dir9P` which keeps its children in a simple table.
#
class TableDir9P(Dir9P)
   private const
      ent

   public override add_child(x)
      if member(ent, x.name) then
         rthrow("Can't add child named " || x.name || " - already exists", x)
      insert(ent, x.name, x)
      x.set_parent(self)
      link
   end

   public override remove_child(x)
      delete(ent, x.name)
      link
   end

   public override get_child(x)
      return .member(ent, x)
   end

   public override gen_children()
      suspend .!ent
   end

   #
   # Clear all child entries, leaving the directory empty.
   #
   public clear()
      default.clear(ent)
      link
   end

   public is_empty()
      succeed *ent = 0
   end

   package override rename_child(x, s)
      if ent[x.name] === x & x.name ~== s then {
         if member(ent, s) then
            rthrow("Can't change name to " || s || " - already exists")
         delete(ent, x.name)
         insert(ent, s, x)
      }
      link
   end

   protected new_dir_child(name, uid, perm)
      return TableDir9P(name).
         set_uid(uid).
         set_muid(uid).
         set_gid(self.gid).
         set_perm(perm)
   end

   protected new_regular_child(name, uid, perm)
      return StringFile9P(name).
         set_uid(uid).
         set_muid(uid).
         set_gid(self.gid).
         set_perm(perm)
   end

   public override create_child(name, uid, perm)
      local n
      n := if iand(perm, Mode9.DMDIR) = 0 then
         new_regular_child(name, uid, perm)
      else
         new_dir_child(name, uid, perm)
      add_child(n)
      return n
   end

   public override new(n)
      Dir9P.new(n)
      ent := table()
      return
   end
end

#
# This is just a `TableDir9P` named "/"
#
class Root9P(TableDir9P)
   public override new()
      TableDir9P.new("/")
      return
   end
end

# A `File9P` which is a regular file, rather than a directory.  The
# detail of how the file's data is represented is left to subclasses,
# who should implement the `read` and `write` methods as appropriate.
#
abstract class Regular9P(File9P)
   public optional write(s, pos)
   public optional read(pos, count)
end

# An implementation of `Regular9P` which keeps its file content in a string.
#
class StringFile9P(Regular9P)
   private readable
      data

   public override set_length(len)
      if len > *data then
         data ||:= repl("\0", len - *data)
      else
         data := data[1+:len]
      link
   end

   public override write(s, pos)
      if iand(self.perm, Mode9.DMAPPEND) = 0 then {
         if pos > *data then
            data ||:= repl("\0", pos - *data - 1) || s
         else
            data[pos:min(pos + *s, *data + 1)] := s
      } else
         data ||:= s
      return *s
   end

   public override read(pos, count)
      if pos > *data then
         return
      else
         return data[pos:min(pos + count, *data + 1)]
   end

   public override get_length()
      return *data
   end

   public set_data(s)
      s := need_string(s)
      data := s
      link
   end

   public override new(n)
      Regular9P.new(n)
      data := ""
      return
   end
end

# An implementation of `Regular9P` in which writes append to the end
# of the content, whilst reads consume from the start.  In both read
# and write, position is ignored.
#
class FifoFile9P(Regular9P)
   private readable
      data

   public override set_length(len)
      if len > *data then
         data ||:= repl("\0", len - *data)
      else
         data := data[1+:len]
      link
   end

   public override write(s, pos)
      data ||:= s
      return *s
   end

   public override read(pos, count)
      local s
      data ? {
         s := move(count) | tab(0)
         data := tab(0)
      }
      return s
   end

   public override get_length()
      return *data
   end

   public set_data(s)
      s := need_string(s)
      data := s
      link
   end

   public add(s)
      s := need_string(s)
      write(s)
      link
   end

   public override new(n)
      Regular9P.new(n)
      data := ""
      return
   end
end

# An implementation of `Regular9P` in which the content is split into
# a queue of messages.  Writes append to the end, whilst reads consume
# from the start.  Reads never consume more than one message in the
# queue.  In both read and write, position is ignored.
#
class QueueFile9P(Regular9P)
   private
      q
   private readable
      len

   public override write(s, pos)
      add(s)
      return *s
   end

   public override read(pos, count)
      local s
      if *q = 0 then
         return
      s := pop(q)
      if *s > count then {
         s ? {
            s := move(count)
            push(q, tab(0))
         }
      }
      len -:= *s
      return s
   end

   public override set_length(n)
      local s
      if n <= 0 then
         clear()
      else if n > len then
         add(repl("\0", n - len))
      else {
         while len - *q[-1] >= n do {
            s := pull(q)
            len -:= *s
         }
         if len > n then {
            # 0 < len-n  < *q[-1]
            q[-1][0 -: len - n] := ""
            len := n
         }
      }
      link
   end

   public override get_length()
      return .len
   end

   public clear()
      q := []
      len := 0
      link
   end

   public get_queue_length()
      return *q
   end

   public get_content()
      local s
      s := ""
      every s ||:= !q
      return s
   end

   public add(s)
      s := need_string(s)
      if *s > 0 then {
         len +:= *s
         put(q, s)
      }
      link
   end

   public remove()
      local s
      if *q > 0 then {
         s := pop(q)
         len -:= *s
         return s
      }
   end

   public override new(n)
      Regular9P.new(n)
      clear()
      return
   end
end

package class Comms9P()
   public static const
      Tversion,
      Tauth,
      Tattach,
      Tflush,
      Twalk,
      Topen,
      Tcreate,
      Tread,
      Twrite,
      Tclunk,
      Tremove,
      Tstat,
      Twstat,
      Rversion,
      Rauth,
      Rattach,
      Rerror,
      Rflush,
      Rwalk,
      Ropen,
      Rcreate,
      Rread,
      Rwrite,
      Rclunk,
      Rremove,
      Rstat,
      Rwstat,
      AEXEC,
      AWRITE,
      AREAD,
      MAX_32,
      MAX_64

   private static init()
      Tversion :=     100
      Rversion :=     101
      Tauth :=        102
      Rauth :=        103
      Tattach :=      104
      Rattach :=      105
      Rerror :=       107
      Tflush :=       108
      Rflush :=       109
      Twalk :=        110
      Rwalk :=        111
      Topen :=        112
      Ropen :=        113
      Tcreate :=      114
      Rcreate :=      115
      Tread :=        116
      Rread :=        117
      Twrite :=       118
      Rwrite :=       119
      Tclunk :=       120
      Rclunk :=       121
      Tremove :=      122
      Rremove :=      123
      Tstat :=        124
      Rstat :=        125
      Twstat :=       126
      Rwstat :=       127

      AEXEC :=        1
      AWRITE :=       2
      AREAD :=        4

      MAX_32 :=       16rffffffff
      MAX_64 :=       16rffffffffffffffff
   end

   public static int_to_bytes(n, w)
      local s
      s := ""
      every 1 to w do {
         s ||:= char(iand(n, 255))
         n := ishift(n, -8)
      }
      return s
   end

   public static bytes_to_int(s)
      local n, ch
      n := 0
      every ch := back(s) do
         n := ishift(n, 8) + ord(ch)
      return n
   end

   public static encode_qid(q)
      return int_to_bytes(q.type, 1) || 
         int_to_bytes(q.version, 4) || 
         int_to_bytes(q.path,8)
   end

   public static encode_stat(qid, info)
      return encode_data_len2("\0\0\0\0\0\0" || 
                              encode_qid(qid) || 
                              int_to_bytes(info.mode, 4) ||
                              int_to_bytes(info.atime, 4) || 
                              int_to_bytes(info.mtime, 4) || 
                              int_to_bytes(info.length, 8) ||
                              encode_data_len2(info.name) ||
                              encode_data_len2(info.uid) ||
                              encode_data_len2(info.gid) ||
                              encode_data_len2(info.muid))
   end

   public static decode_wstat(s)
      local i, t
      i := Info()
      s ? {
         move(21) | fail          # tab past qid
         t := get_int4() | fail
         if t ~= MAX_32 then i.mode := t
         t := get_int4() | fail
         if t ~= MAX_32 then i.atime := t
         t := get_int4() | fail
         if t ~= MAX_32 then i.mtime := t
         t := get_int8() | fail
         if t ~= MAX_64 then i.length := t
         t := get_data_len2() | fail
         if *t > 0 then i.name := t
         t := get_data_len2() | fail
         if *t > 0 then i.uid := t
         t := get_data_len2() | fail
         if *t > 0 then i.gid := t
         t := get_data_len2() | fail
         if *t > 0 then i.muid := t
      }
      return i
   end

   public static encode_int4(n)
      return int_to_bytes(n, 4)
   end

   public static encode_int2(n)
      return int_to_bytes(n, 2)
   end

   public static encode_data_len2(s)
      return encode_int2(*s) || s
   end

   public static encode_data_len4(s)
      return encode_int4(*s) || s
   end

   public static get_int8()
      return bytes_to_int(move(8))
   end

   public static get_int4()
      return bytes_to_int(move(4))
   end

   public static get_int2()
      return bytes_to_int(move(2))
   end

   public static get_int1()
      return ord(move(1))
   end

   public static get_data_len2()
      return move(get_int2())
   end

   public static get_data_len4()
      return move(get_int4())
   end

   public static get(f)
      local s, size, body
      s := f.reads(4) | fail
      size := (s ? get_int4()) - 4 | return Tinvalid()
      body := f.reads(size) | fail
      return decode_body(body) | Tinvalid()
   end

   public static decode_body(body)
      local type, f1, f2, f3, f4, tag, n
      body ? {
         type := ord(move(1)) | fail
         tag := get_int2() | fail
         case type of {
            Tversion: {
               f1 := get_int4() | fail
               f2 := get_data_len2() | fail
               pos(0) | fail
               return TVersion(tag, f1, f2)
            }
            Tauth: {
               f1 := get_int4() | fail    # afid
               f2 := get_data_len2() | fail    # uname
               f3 := get_data_len2() | fail    # aname
               pos(0) | fail
               return TAuth(tag, f1, f2, f3)
            }
               
            Tattach: {
               f1 := get_int4() | fail    # fid
               f2 := get_int4() | fail    # afid
               f3 := get_data_len2() | fail    # uname
               f4 := get_data_len2() | fail    # aname
               pos(0) | fail
               return TAttach(tag, f1, f2, f3, f4)
            }

            Tflush: {
               f1 := get_int2() | fail     # oldtag
               pos(0) | fail
               return TFlush(tag, f1)
            }

            Twalk: {
               f1 := get_int4() | fail    # fid
               f2 := get_int4() | fail    # newfid
               n := get_int2() | fail     # nwname
               f3 := []
               every 1 to n do
                  put(f3, get_data_len2()) | fail
               pos(0) | fail
               return TWalk(tag, f1, f2, f3)
            }

            Topen: {
               f1 := get_int4() | fail    # fid
               f2 := get_int1() | fail    # mode
               pos(0) | fail
               return TOpen(tag, f1, f2)
            }

            Tcreate: {
               f1 := get_int4() | fail    # fid
               f2 := get_data_len2() | fail    # name
               f3 := get_int4() | fail    # perm
               f4 := get_int1() | fail    # mode
               pos(0) | fail
               return TCreate(tag, f1, f2, f3, f4)
            }

            Tread: {
               f1 := get_int4() | fail    # fid
               f2 := get_int8() | fail    # offset
               f3 := get_int4() | fail    # count
               pos(0) | fail
               return TRead(tag, f1, f2, f3)
            }

            Twrite: {
               f1 := get_int4() | fail    # fid
               f2 := get_int8() | fail    # offset
               f3 := get_data_len4() | fail    # data
               pos(0) | fail
               return TWrite(tag, f1, f2, f3)
            }

            Tclunk: {
               f1 := get_int4() | fail    # fid
               pos(0) | fail
               return TClunk(tag, f1)
            }
            Tremove: {
               f1 := get_int4() | fail    # fid
               pos(0) | fail
               return TRemove(tag, f1)
            }

            Tstat: {
               f1 := get_int4() | fail    # fid
               pos(0) | fail
               return TStat(tag, f1)
            }

            Twstat: {
               f1 := get_int4() | fail         # fid
               f2 := get_data_len2() | fail    # stat
               pos(0) | fail
               return TWstat(tag, f1, f2)
            }

            default: fail
         }
      }
   end

   public static encode(x)
      local s
      case classof(x) of {
         RVersion: {
            return encode_int4(13 + *x.version) ||
               char(Rversion) ||
               encode_int2(x.tag) ||
               encode_int4(x.msize) ||
               encode_data_len2(x.version)
         }

         RAttach: {
            return encode_int4(20) ||
               char(Rattach) ||
               encode_int2(x.tag) ||
               x.qid
         }

         RAuth: {
            return encode_int4(20) ||
               char(Rauth) ||
               encode_int2(x.tag) ||
               x.aqid
         }

         RClunk: {
            return encode_int4(7) ||
               char(Rclunk) ||
               encode_int2(x.tag)
         }

         RFlush: {
            return encode_int4(7) ||
               char(Rflush) ||
               encode_int2(x.tag)
         }

         RRemove: {
            return encode_int4(7) ||
               char(Rremove) ||
               encode_int2(x.tag)
         }

         RWstat: {
            return encode_int4(7) ||
               char(Rwstat) ||
               encode_int2(x.tag)
         }

         RError: {
            return encode_int4(9 + *x.ename) ||
               char(Rerror) ||
               encode_int2(x.tag) ||
               encode_data_len2(x.ename)
         }

         RWalk: {
            s := encode_int4(9 + 13 * *x.wqid) ||
               char(Rwalk) ||
               encode_int2(x.tag) ||
               encode_int2(*x.wqid)
            every s ||:= !x.wqid
            return s
         }

         RCreate: {
            return encode_int4(24) ||
               char(Rcreate) ||
               encode_int2(x.tag) ||
               x.qid ||
               encode_int4(x.iounit)
         }

         ROpen: {
            return encode_int4(24) ||
               char(Ropen) ||
               encode_int2(x.tag) ||
               x.qid ||
               encode_int4(x.iounit)
         }

         RWrite: {
            return encode_int4(11) ||
               char(Rwrite) ||
               encode_int2(x.tag) ||
               encode_int4(x.count)
         }

         RRead: {
            return encode_int4(11 + *x.data) ||
               char(Rread) ||
               encode_int2(x.tag) ||
               encode_data_len4(x.data)
         }

         RStat: {
            return encode_int4(9 + *x.stat) ||
               char(Rstat) ||
               encode_int2(x.tag) || 
               encode_data_len2(x.stat)
         }

         default:
            syserr("Bad type to encode")
      }
   end
end

# An interface represeting a database of users.  This is used to
# determine permitted file operations.
#
abstract class Users()
   public abstract is_member(group, user)
   public abstract is_leader(group, user)
end

# Simple default Users database
#
class DefaultUsers(Users)
   public override is_member(group, user)
      succeed group == user
   end

   public override is_leader(group, user)
      succeed group == user
   end
end

package record Group(name, leader, members)

# Users database read from /adm/users file.
#
class AdmUsers(Users)
   private
      source,
      groups

   private parse(s)
      local l, leader, members
      l := List{separate(s, ':')}
      if *l ~= 4 then
         fail
      leader := ("" ~== l[3])
      members := Set{separate("" ~== l[4])}
      return Group("" ~== l[2], leader, members)
   end

   public refresh()
      local s, g
      s := Files.file_to_string(source) | fail
      groups := table()
      every g := parse(separate_lines(s)) do
         insert(groups, g.name, g)
      link
   end

   public override is_member(group, user)
      local g
      if g := member(groups, group) then
         succeed member(g.members, user)
   end

   public override is_leader(group, user)
      local g
      if g := member(groups, group) then {
         # If there is no specific leader then any member is a leader.
         succeed if /g.leader then 
            member(g.members, user)
         else
            g.leader == user
      }
   end

   public new(source)
      /source := "/adm/users"
      self.source := source
      refresh() | fail
      return
   end
end

# This interface represents the data from which the session responds
# to incoming messages.  Errors are indicated by the various methods
# by throwing exceptions.
#
# Paths are arbitrary objects.  Several paths may represent the same
# underlying actual server file if desired, but usually there is a
# one-to-one correspondence.  In the former case, `get_file_key()`
# should be overridden so that files with the exclusive bit set are
# handled correctly; also care should be taken so that `get_qid()`
# returns a `Qid` with the same path for the underlying file.
#
abstract class Data9P()
   # Return the root path.  `aname` is from the `TAttach` message.
   public abstract get_root(aname)

   # Return the parent path of the path `p`, failing if this is a root
   # path.
   public abstract get_parent(p)

   # Return the child of the path `p` with the given name; fail if
   # there is no such path.
   public abstract get_child(p, name)

   # Generate the children of path `p`.  Note that this generator may not
   # be used to exhaustion, and any resource it uses (such as a
   # `DirStream`) must be enclosed in a `use_seq` to ensure correct
   # cleanup.
   public abstract gen_children(p)

   # Remove the child path `p2` from directory given by path `p1`.
   public abstract remove_child(p1, p2)

   # Create and return new child path under the directory given by path `p`.
   public abstract create_child(p, name, uid, perm)

   # This is invoked to note that the given path `p` has been modified
   # by user `uid`.
   public abstract modified(p, uid)

   # Open the given path `p`, and return another (possibly different)
   # path on which to carry out future i/o operations (read, write and
   # close).
   public abstract open(p, mode)

   # Write the string `s` to the path `p` at position `pos`.
   public abstract write(p, s, pos)

   # Read `count` bytes from path `p` at position `pos`.  Returns
   # `&null` on end-of-file.
   public abstract read(p, pos, count)

   # Close the given path
   public abstract close(p)

   # Return an `Info` record for the given path `p`.
   public abstract get_info(p)

   # Set the given path's settings from the given `Info` record.
   public abstract set_info(p, x)

   # Return a `Qid` record for the given path.
   public abstract get_qid(p)

   # Return a key for the given path, which will be identical to the
   # key returned for another path which represents the same file on
   # the server.  This is used to determine whether a file with the
   # exclusive mode bit set can be opened.
   #
   # By default this simply returns `p`, and only needs to be
   # overridden if several paths represent the same actual file.
   #
   public get_file_key(p)
      return p
   end

   # Invoked when the given path is no longer referenced, if the
   # session's `track_refs` flags is set.
   #
   public path_unreferenced(p)
      link
   end

   # This method is used to create the asynchronous `Task` state.  By default
   # it saves `ThrowHandlerState` and `CleanupState`.
   #
   public create_task_state()
      return States(ThrowHandlerState(), CleanupState())
   end
end

#
# This class (which may be used as a mixin-style class), contains
# implementations of the various methods which modify the filesystem.
# Each throws an exception indicating the file system is read-only.
#
abstract class ReadOnlyData9P(Data9P)
   protected read_only()
      throw("Read-only filesystem")
   end

   public override remove_child(p1, p2)
      read_only()
   end

   public override create_child(p, name, uid, perm)
      read_only()
   end

   public override modified(p, uid)
      read_only()
   end

   public override write(p, s, pos)
      read_only()
   end

   public override set_info(p, x)
      read_only()
   end
end

# An implementation of `Data9P` which uses `File9P` instances to
# implement each method, except get_root, which must be implemented in
# subclasses to provide the root of the tree for each mount.
#
abstract class FileData9P(Data9P)
   public override get_parent(p)
      return p.get_parent()
   end

   public override get_child(p, name)
      return p.get_child(name)
   end

   public override gen_children(p)
      suspend p.gen_children()
   end

   public override remove_child(p1, p2)
      link p1.remove_child(p2)
   end

   public override create_child(p, name, uid, perm)
      return p.create_child(name, uid, perm)
   end

   public override modified(p, uid)
      link p.modified(uid)
   end

   public override open(p, mode)
      return p.open(mode)
   end

   public override write(p, s, pos)
      return p.write(s, pos)
   end

   public override read(p, pos, count)
      return p.read(pos, count)
   end

   public override close(p)
      link p.close()
   end

   public override get_info(p)
      return p.get_info()
   end

   public override set_info(p, x)
      link p.set_info(x)
   end

   public override get_qid(p)
      return p.get_qid()
   end

   public override get_file_key(p)
      return p.get_file_key()
   end

   public override path_unreferenced(p)
      link p.path_unreferenced()
   end
end

# A `FileData9P` which always operates on a single file tree.  Each
# mount will therefore see the same tree, and the attach parameter is
# ignored.
#
class TreeData9P(FileData9P)
   public const
      root

   public override get_root(aname)
      return root
   end

   public new(root)
      self.root := root
      return
   end
end

package record Fid(path, uid, omode, dir)
package record WorkItem(req, resp, worker)

# The main server class, which manages a 9P server session.
#
class Session9P()
   private const
      fids,        # table mapping fid numbers to Fid() records
      open_cnt,    # table counting no. of fids open for i/o by file keys
      ref_cnt

   private
      data, 
      users,
      track_refs,
      verbose

   # Vars used just by async_io
   private
      writer,      # The writer task
      valid,       # Set of valid (non-flushed) WorkItems
      done_flag,   # Flag to indicate writer to exit
      queue        # Queue of WorkItems for output

   private new_fid(n, path, uid, mode)
      if member(fids, n) then
         throw("Fid already in use: " || n)
      insert(fids, n, Fid(path, uid, mode))
      if \mode then
         open_cnt[data.get_file_key(path)] +:= 1
      inc_ref(path)
   end

   private del_fid(n)
      local x, k, i
      x := member(fids, n) | throw("No such fid: " || n)
      delete(fids, n)
      if \x.omode then {
         k := data.get_file_key(x.path)
         i := (open_cnt[k] -:= 1)
         if i < 0 then
            syserr("negative open path count in Session9P")
         if i = 0 then
            delete(open_cnt, k)
      }
      dec_ref(x.path)
   end

   private is_path_open(path)
      succeed member(open_cnt, data.get_file_key(path))
   end

   private lookup(n, t)
      local o
      o := member(fids, n) | throw("No such fid: " || n)
      tmp(o.path, t)
      return o
   end

   private path_string(path)
      local s, t, n
      s := ""
      t := path
      repeat {
         n := data.get_info(t).name
         if n == "/" then
            s := "/" || s
         else if *s = 0 then
            s := n
         else
            s := n || "/" || s
         t := data.get_parent(t) | break
      }
      return s
   end

   public dump()
      local e
      write("Fids(",*fids,")")
      every e := !sort(fids) do
         write(e[1], " -> Fid(", path_string(e[2].path), ", ", e[2].uid, ", ", if \e[2].omode then "open" else "closed", ")")
      write("Open counts(",*open_cnt,")")
      every e := !sort(open_cnt) do {
         writes(path_string(e[1]), " -> ")
         every writes(!e[2], " ")
         write()
      }
      write("Ref counts(",*ref_cnt,")")
      every e := !sort(ref_cnt) do {
         write(path_string(e[1]), "(",image(e[1]), ") -> ", e[2])
      }
   end

   private has_perm(info, uid, p)
      local m
      # see uid.c
      m := iand(info.mode, 7)
      if iand(p, m) = p then
         return
      if uid == info.uid then {
         m := ior(m, iand(ishift(info.mode, -6), 7))
         if iand(p, m) = p then
            return
      }
      if users.is_member(info.gid, uid) then {
         m := ior(m, iand(ishift(info.mode, -3), 7))
         if iand(p, m) = p then
            return
      }
   end

   private inc_ref(p)
      if \track_refs then {
         ref_cnt[p] +:= 1
         if \verbose then write("INC: ",image(p), " to ", ref_cnt[p])
      }
   end

   public is_path_referenced(p)
      succeed member(ref_cnt, p)
   end

   public is_path_unreferenced(p)
      return not member(ref_cnt, p)
   end

   private dec_ref(p)
      local i
      if \track_refs then {
         i := (ref_cnt[p] -:= 1)
         if \verbose then write("DEC: ",image(p)," to ", i)
         if i < 0 then
            syserr("negative reference count in Session9P")
         if i = 0 then {
            delete(ref_cnt, p)
            data.path_unreferenced(p)
         }
      }
   end

   # Add path p to the temporary path list and increment its refcount.
   private tmp(p, t)
      if \track_refs then {
         put(t, p)
         inc_ref(p)
      }
      return p
   end

   private respond(x)
      local t, y, f, e
      t := []  # A list of paths temporarily used by respond_impl
      clean{ (y := try1{respond_impl(x, t)}) | (f := &why) }
      every e := !t do
         clean{ try1{dec_ref(e)} | (/f := &why) }
      return if /f then y else RError(x.tag, f)
   end

   private respond_impl(x, t)
      local o, qids, e, s, i, p, info, n, perm
      case classof(x) of {
         TVersion:
            return RVersion(65535, 8216, "9P2000")
         TAttach: {
            p := tmp(data.get_root(x.aname), t)
            new_fid(x.fid, p, x.uname)
            return RAttach(x.tag, Comms9P.encode_qid(data.get_qid(p)))
         }
         TClunk: {
            o := lookup(x.fid, t)
            del_fid(x.fid)
            if \o.omode then {
               data.close(o.path)
               if iand(o.omode, FileOpt9.ORCLOSE) ~= 0 then {
                  p := tmp(data.get_parent(o.path), t)
                  data.remove_child(p, o.path)
                  data.modified(p, o.uid)
               }
            }
            return RClunk(x.tag)
         }
         TRemove: {
            o := lookup(x.fid, t)
            del_fid(x.fid)
            info := data.get_info(o.path)
            if iand(info.mode, Mode9.DMDIR) ~= 0 & tmp(data.gen_children(o.path), t) then
               throw("Directory not empty")
            p := tmp(data.get_parent(o.path), t)
            has_perm(data.get_info(p), o.uid, Comms9P.AWRITE) | throw("Permission denied")
            if \o.omode then
               data.close(o.path)
            data.remove_child(p, o.path)
            data.modified(p, o.uid)
            return RRemove(x.tag)
         }
         TCreate: {
            o := lookup(x.fid, t)
            /o.omode | throw("Fid already open")
            # See notes for more details.
            if iand(x.perm, Mode9.DMDIR) ~= 0 & x.mode ~= FileOpt9.OREAD then
               throw("Invalid mode for creating a directory")
            info := data.get_info(o.path)
            iand(info.mode, Mode9.DMDIR) ~= 0 | throw("Attempt to create in a regular file")
            has_perm(info, o.uid, Comms9P.AWRITE) | throw("Permission denied")
            if tmp(data.get_child(o.path, x.name), t) then
               throw("Create with name which already exists")
            perm := if iand(x.perm, Mode9.DMDIR) = 0 then
               iand(x.perm, ior(icom(8r666), iand(info.mode, 8r666)))
            else
               iand(x.perm, ior(icom(8r777), iand(info.mode, 8r777)))
            p := tmp(data.create_child(o.path, x.name, o.uid, perm), t)
            p := tmp(data.open(p, x.mode), t)
            data.modified(o.path, o.uid)
            del_fid(x.fid)
            new_fid(x.fid, p, o.uid, x.mode)
            return RCreate(x.tag, Comms9P.encode_qid(data.get_qid(p)), 0)
         }
         TOpen: {
            o := lookup(x.fid, t)
            /o.omode | throw("Fid already open")
            info := data.get_info(o.path)
            # Same as for TCreate above.
            if iand(info.mode, Mode9.DMDIR) ~= 0 & x.mode ~= FileOpt9.OREAD then
               throw("Invalid mode for opening a directory")
            if iand(info.mode, Mode9.DMEXCL) ~= 0 & is_path_open(o.path) then
               throw("Exclusive use file already open")
            i := case iand(x.mode, 3) of {
               FileOpt9.OREAD : Comms9P.AREAD
               FileOpt9.OWRITE : Comms9P.AWRITE
               FileOpt9.ORDWR : ior(Comms9P.AREAD, Comms9P.AWRITE)
               FileOpt9.OEXEC : Comms9P.AEXEC
               default: throw("Strange permissions value")
            }
            if iand(x.mode, FileOpt9.OTRUNC) ~= 0 then
               i := ior(i, Comms9P.AWRITE)
            has_perm(info, o.uid, i) | throw("Permission denied")
            if iand(x.mode, FileOpt9.ORCLOSE) ~= 0 then {
               p := tmp(data.get_parent(o.path), t)
               has_perm(data.get_info(p), o.uid, Comms9P.AWRITE) | throw("Permission denied")
            }
            p := tmp(data.open(o.path, x.mode), t)
            del_fid(x.fid)
            new_fid(x.fid, p, o.uid, x.mode)
            # OTRUNC means the file is to be truncated, unless the file is append-only
            if iand(info.mode, Mode9.DMAPPEND) = 0 & iand(x.mode, FileOpt9.OTRUNC) ~= 0 then {
               data.set_info(p, Info(,,, 0))
               data.modified(p, o.uid)
            }
            return ROpen(x.tag, Comms9P.encode_qid(data.get_qid(p)), 0)
         }
         TWalk: {
            o := lookup(x.fid, t)
            /o.omode | throw("Cannot clone open fid")
            p := o.path
            qids := []
            every e := !x.wname do {
               # End on non-directory
               info := data.get_info(p)
               if iand(info.mode, Mode9.DMDIR) = 0 then
                  break
               if e == ".." then
                  p := tmp(data.get_parent(p), t)   # Note parent of root is root
               else {
                  # Check directory exec permission.  The 9P intro man
                  # page says
                  #    "A walk in a directory is regarded as
                  #     executing the directory, not reading it."
                  has_perm(info, o.uid, Comms9P.AEXEC) | {
                     # For consistency with fossil, we give a
                     # different error message to the usual "File does
                     # not exist" if we just did a break.  See 9p.c in
                     # fossil.
                     if *qids = 0 then
                        throw("Permission denied")
                     break
                  }
                  p := tmp(data.get_child(p, e), t) | break
               }
               put(qids, Comms9P.encode_qid(data.get_qid(p)))
            }
            if *qids = *x.wname then {
               new_fid(x.newfid, p, o.uid)
               return RWalk(x.tag, qids)
            } 
            if *qids = 0 then
               throw("File does not exist")
            return RWalk(x.tag, qids)
         }
         TWrite: {
            o := lookup(x.fid, t)
            (iand(\o.omode, 3) = (FileOpt9.OWRITE | FileOpt9.ORDWR)) |
               throw("Write on file not open for writing")
            info := data.get_info(o.path)
            if iand(info.mode, Mode9.DMDIR) ~= 0 then
               throw("Attempt to write to directory")
            n := data.write(o.path, x.data, x.offset + 1)
            data.modified(o.path, o.uid)
            return RWrite(x.tag, n)
         }
         TRead: {
            o := lookup(x.fid, t)
            (iand(\o.omode, 3) = (FileOpt9.OREAD | FileOpt9.OEXEC | FileOpt9.ORDWR)) |
               throw("Read on file not open for reading")
            info := data.get_info(o.path)
            if iand(info.mode, Mode9.DMDIR) ~= 0 then {
               if x.offset = 0 then {
                  o.dir := []
                  every e := tmp(data.gen_children(o.path), t) do
                     put(o.dir, Comms9P.encode_stat(data.get_qid(e), data.get_info(e)))
               }
               s := ""
               while *s + *o.dir[1] <= x.count do
                  s ||:= get(o.dir)
            } else {
               s := data.read(o.path, x.offset + 1, x.count)
               # In case of end-of-file
               /s := ""
            }
            return RRead(x.tag, s)
         }
         TStat: {
            o := lookup(x.fid, t)
            return RStat(x.tag, Comms9P.encode_stat(data.get_qid(o.path), data.get_info(o.path)))
         }
         TWstat: {
            o := lookup(x.fid, t)
            i := Comms9P.decode_wstat(x.stat)  | throw("Invalid wstat data")
            info := data.get_info(o.path)
            if \i.name then {
               # The name can be changed by anyone with write
               # permission in the parent directory
               p := tmp(data.get_parent(o.path), t)
               has_perm(data.get_info(p), o.uid, Comms9P.AWRITE) | throw("Permission denied")
               if tmp(data.get_child(p, i.name), t) then
                  throw("Name already exists")
            }
            if \i.length then {
               # The length can be changed by anyone with write
               # permission on the file.
               has_perm(info, o.uid, Comms9P.AWRITE) | throw("Permission denied")
               if i.length ~= 0 & iand(info.mode, Mode9.DMDIR) ~= 0 then
                  throw("Cannot set length of directory to non-zero value")
            }
            if \i.mtime | \i.mode then {
               # The mode and mtime can be changed by the owner of the
               # file or the group leader of the file's current group.
               (info.uid == o.uid) | users.is_leader(info.gid, o.uid) | throw("Permission denied")
               if \i.mode & iand(i.mode, Mode9.DMDIR) ~= iand(info.mode, Mode9.DMDIR) then
                  throw("Directory bit cannot be changed")
            }
            if \i.gid then {
               # The gid can be changed: by the owner if also a member
               # of the new group; or by the group leader of the
               # file's current group if also leader of the new group
               (info.uid == o.uid & users.is_member(i.gid, o.uid)) |
                  (users.is_leader(info.gid, o.uid) & users.is_leader(i.gid, o.uid)) | throw("Permission denied")
            }
            if \i.atime | \i.uid | \i.muid then
               throw("Invalid value set in wstat")

            data.set_info(o.path, i)
            if \i.name then
               data.modified(p, o.uid)
            if \i.length then
               data.modified(o.path, o.uid)

            return RWstat(x.tag)
         }
         TFlush:
            return RFlush(x.tag)
         TAuth:
            throw("Authorization not required")
         default:
            throw("Unknown message type")
      }
   end

   # This method loops, reading and writing 9P messages using file `f`
   # until end-of-file or error on `f`.  Messages are processed sequentially.
   #
   public io(f)
      local x, y
      while x := Comms9P.get(f) do {
         if \verbose then write("GOT: ", to_string(x))
         if is(x, Tinvalid) then
            next
         y := respond(x)
         if \verbose then write("SEND: ", to_string(y))
         f.writes1(Comms9P.encode(y)) | fail
      }
   end

   private async_worker(item, sched)
      local t
      t := Task(sched, create {
         if member(valid, item) then {
            item.resp := respond(item.req)
            if member(valid, item) then {
               put(queue, item)
               wakeup_writer()
            }
         }
         t.revert()
      }, data.create_task_state())
      return t.start()
   end

   private clear_valid()
      local e
      while e := ?valid do {
         if \verbose then write("CLEARING: ", to_string(e.req))
         delete(valid, e)
         (\e.worker).interrupt()
      }
   end

   private async_writer(sched, f)
      local ts, item, t
      t := Task(sched, create {
         use {
            ts := TaskStream(f, t).set_close_underlying(&no),
            repeat {
               while /done_flag & *queue = 0 do
                  t.sleep()
               # If the queue is empty then done_flag must be set, so
               # break.  Otherwise, send - so we flush the queue
               # before exiting even after done_flag set.
               item := get(queue) | break
               if member(valid, item) then {
                  if \verbose then write("SEND: ", to_string(item.resp))
                  ts.writes1(Comms9P.encode(item.resp)) |
                     if \verbose then write("ERROR ON SEND: ", to_string(item.resp), ": ", &why)
                  delete(valid, item)
               }
            }
         }
         # There shouldn't be any remaining outstanding requests (they
         # should have been flushed), but just in case, interrupt any
         # that are there.
         clear_valid()
         if \verbose then write("WRITER EXITING")
         t.revert()
      }, CleanupState())
      return t.start()
   end

   private wakeup_writer()
      # Note that the writer task polls as well a sleeps.
      if writer.is_sleeping() then
         writer.notify()
   end

   # This method returns immediately after starting a new
   # `Task` in `Scheduler` `sched`).  This `Task` will process each
   # incoming message in its own `Task`, so that each message can be
   # processed asynchronously.
   #
   public async_io(sched, f)
      local x, e, t, ts, item
      t := Task(sched, create {
         done_flag := &null
         valid := set()
         queue := []
         writer := async_writer(sched, f)
         use {
            ts := TaskStream(f, t).set_close_underlying(&no),
            while x := Comms9P.get(ts) do {
               if \verbose then write("GOT: ", to_string(x))
               if is(x, Tinvalid) then
                  next
               item := WorkItem(x)
               if is(x, TFlush) then {
                  item.resp := respond(x)
                  every e := !valid do {
                     if e.req.tag = x.oldtag then {
                        if \verbose then write("FLUSHING: ", to_string(e.req))
                        delete(valid, e)
                        (\e.worker).interrupt()
                     }
                  }
                  insert(valid, item)
                  put(queue, item)
                  wakeup_writer()
               } else {
                  insert(valid, item)
                  item.worker := async_worker(item, sched)
               }
            }
         }
         done_flag := 1
         wakeup_writer()
         if \verbose then write("READER EXITING")
         t.revert()
      }, data.create_task_state())
      return t.start()
   end

   # This method returns immediately after starting a new `Task` in
   # `Scheduler` `sched`, which calls `io()` on `f` (after wrapping it
   # in a `TaskStream`).  Thus messages are processed sequentially one
   # after another, but in a background task.
   #
   public io_task(sched, f)
      local t, ts
      t := Task(sched, create {
         use {
            ts := TaskStream(f, t).set_close_underlying(&no),
            io(ts)
         }
         t.revert()
      }, data.create_task_state())
      return t.start()
   end

   public set_data(d)
      data := d
      link
   end

   public set_users(u)
      users := u
      link
   end

   public set_verbose(x)
      self.verbose := need_flag(x)
      link
   end

   public set_track_refs(x)
      self.track_refs := need_flag(x)
      link
   end

   # Create a new instance.  `d` should be an instance of `Data9P` and
   # optionally `u` should be an instance of `Users`; by default an
   # instance of `DefaultUsers` is used.
   #
   public new(d, u)
      /u := DefaultUsers()
      self.fids := table()
      self.open_cnt := table(0)
      self.ref_cnt := table(0)
      set_data(d)
      set_users(u)
      return
   end
end
