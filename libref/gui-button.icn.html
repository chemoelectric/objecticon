<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>button.icn</title></head><body><pre>
<a name="1"/>#
<a name="2"/># $Id: button.icn 8128 2020-01-21 12:56:03Z rparlett $
<a name="3"/>#
<a name="4"/># This file is in the public domain.
<a name="5"/>#
<a name="6"/># Author: Robert Parlett (parlett@dial.pipex.com)
<a name="7"/>#
<a name="8"/>
<a name="9"/>package gui
<a name="10"/>
<a name="11"/>import 
<a name="12"/>   graphics,
<a name="13"/>   util,
<a name="14"/>   lang
<a name="15"/>
<a name="16"/>#
<a name="17"/># This is the parent class of the button classes, including
<a name="18"/># checkboxes.
<a name="19"/>#
<a name="20"/># A `Button` produces a `Event.BUTTON_PRESS` when the button is
<a name="21"/># depressed, and code `Event.BUTTON_RELEASE` when it is released,
<a name="22"/># as well as an `Event.ACTION`.
<a name="23"/># 
<a name="24"/># By default, when a button holds the keyboard focus a dashed
<a name="25"/># line appears just within the button.  Then, when return is
<a name="26"/># pressed an `Event.ACTION` is generated.  The method
<a name="27"/># `Dialog.set_initial_focus()` can be used to have the button
<a name="28"/># have the focus when the dialog is first displayed.
<a name="29"/>#
<a name="30"/># Buttons also repeatedly produce a `Event.BUTTON_HELD` whilst they
<a name="31"/># are held down, rather like a repeating keyboard press.  The
<a name="32"/># delay between the initial repeat event and subsequent repeat
<a name="33"/># events is set in the `Style` object.
<a name="34"/>#
<a name="35"/>abstract class Button(Toggle,Component)
<a name="36"/>   public 
<a name="37"/>      is_down,
<a name="38"/>      parent_button_group,
<a name="39"/>      repeat_delay,
<a name="40"/>      no_click_focus_flag,
<a name="41"/>      toggles_flag,
<a name="42"/>      repeat_ticker,
<a name="43"/>      held_event,
<a name="44"/>      middle_listeners,
<a name="45"/>      right_listeners
<a name="46"/>
<a name="47"/>   public set_parent_button_group(x)
<a name="48"/>      self.parent_button_group := x
<a name="49"/>      link
<a name="50"/>   end
<a name="51"/>
<a name="52"/>   #
<a name="53"/>   # Set the no-click-focus behaviour.  If set, the component will
<a name="54"/>   # not get the focus on a left click.
<a name="55"/>   #
<a name="56"/>   public set_no_click_focus(s)
<a name="57"/>      self.no_click_focus_flag := need_flag(s)
<a name="58"/>      link
<a name="59"/>   end
<a name="60"/>
<a name="61"/>   public override finally()
<a name="62"/>      stop_held()
<a name="63"/>      Component.finally()
<a name="64"/>   end
<a name="65"/>
<a name="66"/>   public repeat_tick()
<a name="67"/>      repeat {
<a name="68"/>         # Note that repeat_delay can be null here: if we press and
<a name="69"/>         # hold over a greyed-out button, then the button is enabled,
<a name="70"/>         # and then we drag, we get the drag events (which start this
<a name="71"/>         # ticker), but not the original press, which would set
<a name="72"/>         # repeat_delay.
<a name="73"/>         if Prog.get_runtime_millis() &gt; \repeat_delay then
<a name="74"/>            fire(Event.BUTTON_HELD, held_event)
<a name="75"/>         repeat_ticker.sleep(Gui.REPEAT_RATE)
<a name="76"/>      }
<a name="77"/>   end
<a name="78"/>
<a name="79"/>   public start_held(ev)
<a name="80"/>      held_event := ev
<a name="81"/>      repeat_ticker.start()
<a name="82"/>   end
<a name="83"/>
<a name="84"/>   public stop_held()
<a name="85"/>      repeat_ticker.stop()
<a name="86"/>   end
<a name="87"/>
<a name="88"/>   public handle_lpress(e)
<a name="89"/>      local b
<a name="90"/>      if /self.is_down then {
<a name="91"/>         self.is_down := &amp;yes
<a name="92"/>         start_held(e)
<a name="93"/>         self.repeat_delay := Prog.get_runtime_millis() + Gui.REPEAT_DELAY
<a name="94"/>         every b := !(\self.parent_button_group).buttons do {
<a name="95"/>            if b.is_unhidden() &amp; b.is_unshaded() then {
<a name="96"/>               parent_dialog.hold(b, e.code)
<a name="97"/>               b.repeat_delay := self.repeat_delay
<a name="98"/>            }
<a name="99"/>         }
<a name="100"/>         self.invalidate()
<a name="101"/>         fire(Event.BUTTON_PRESS, e)
<a name="102"/>      }
<a name="103"/>   end
<a name="104"/>
<a name="105"/>   public handle_ldrag(e)
<a name="106"/>      #
<a name="107"/>      # Button held down; toggle on/off as it goes over the button 
<a name="108"/>      #
<a name="109"/>      if self.in_region(e) then {
<a name="110"/>         if /self.is_down then {
<a name="111"/>            self.is_down := &amp;yes
<a name="112"/>            start_held(e)
<a name="113"/>            invalidate()
<a name="114"/>         }
<a name="115"/>      } else
<a name="116"/>         clear_down()
<a name="117"/>   end
<a name="118"/>
<a name="119"/>   public handle_lrelease(e)
<a name="120"/>      if \self.is_down then {
<a name="121"/>         clear_down()
<a name="122"/>         fire(Event.BUTTON_RELEASE, e)
<a name="123"/>         on_action(e)
<a name="124"/>      }
<a name="125"/>      repeat_delay := &amp;null
<a name="126"/>   end
<a name="127"/>
<a name="128"/>   public clear_down()
<a name="129"/>      if \self.is_down then {
<a name="130"/>         self.is_down := &amp;null
<a name="131"/>         stop_held()
<a name="132"/>         invalidate()
<a name="133"/>      }
<a name="134"/>      link
<a name="135"/>   end
<a name="136"/>
<a name="137"/>   public on_action(e)
<a name="138"/>      if \self.toggles_flag then
<a name="139"/>         toggle_action(e)
<a name="140"/>      fire(Event.ACTION, e)
<a name="141"/>   end
<a name="142"/>
<a name="143"/>   public on_interrupted()
<a name="144"/>      # Avoid a little glitch which happens when a button is greyed out
<a name="145"/>      # while held down, leaving it stuck like that, since it never gets the
<a name="146"/>      # release event.
<a name="147"/>      clear_down()
<a name="148"/>   end
<a name="149"/>
<a name="150"/>   #
<a name="151"/>   # Visualize the given (keyboard) event, by making the button go
<a name="152"/>   # down for a short time (`Gui.VISUALIZE_DELAY` ms), before making
<a name="153"/>   # it go up again, and then calling `on_action`
<a name="154"/>   #
<a name="155"/>   public visualize_action(e)
<a name="156"/>      local t
<a name="157"/>      if /self.is_down then {
<a name="158"/>         self.is_down := &amp;yes
<a name="159"/>         self.invalidate()
<a name="160"/>         t := Dispatcher.new_task{{
<a name="161"/>            t.sleep(Gui.VISUALIZE_DELAY)
<a name="162"/>            clear_down()
<a name="163"/>            on_action(e)
<a name="164"/>            t.revert()
<a name="165"/>         }}
<a name="166"/>         t.start()
<a name="167"/>      }
<a name="168"/>      link
<a name="169"/>   end
<a name="170"/>
<a name="171"/>   public override handle_accel(e)
<a name="172"/>      if /self.no_click_focus_flag then
<a name="173"/>         grab_focus(e)
<a name="174"/>      visualize_action(e)
<a name="175"/>   end
<a name="176"/>
<a name="177"/>   public handle_key(e)
<a name="178"/>      if e.code === ("\r" | "\l" | " ") then
<a name="179"/>         visualize_action(e)
<a name="180"/>   end
<a name="181"/>
<a name="182"/>   #
<a name="183"/>   # Set the checked status according to the given flag.
<a name="184"/>   #
<a name="185"/>   public override set_is_checked(s)
<a name="186"/>      need_flag(s)
<a name="187"/>      if s ~=== self.is_checked_flag then {
<a name="188"/>         Toggle.set_is_checked(s)
<a name="189"/>         self.invalidate()
<a name="190"/>      }
<a name="191"/>      link
<a name="192"/>   end
<a name="193"/>
<a name="194"/>   public override accepts_focus(e)
<a name="195"/>      if (\e).code === Mouse.LEFT_PRESS &amp; \self.no_click_focus_flag then
<a name="196"/>         fail
<a name="197"/>      succeed Component.accepts_focus(e)
<a name="198"/>   end
<a name="199"/>
<a name="200"/>   #
<a name="201"/>   # Set the button so that when it is pressed, it toggles
<a name="202"/>   # between two states, as indicated by the is_checked
<a name="203"/>   # flag.
<a name="204"/>   #
<a name="205"/>   # Instances of Checkbox have this flag on by default, but 
<a name="206"/>   # TextButton and IconButton do not.  When the flag is on,
<a name="207"/>   # the latter classes indicate their checked status by
<a name="208"/>   # showing the button as being "down".
<a name="209"/>   #
<a name="210"/>   public set_toggles(s)
<a name="211"/>      self.toggles_flag := need_flag(s)
<a name="212"/>      link
<a name="213"/>   end
<a name="214"/>
<a name="215"/>   #
<a name="216"/>   # If this flag is set, then the middle mouse button acts in the
<a name="217"/>   # same way as the left mouse button.
<a name="218"/>   #
<a name="219"/>   public set_use_middle(s)
<a name="220"/>      need_flag(s)
<a name="221"/>      every (!\middle_listeners).disconnect()
<a name="222"/>      middle_listeners := if /s then
<a name="223"/>         &amp;null
<a name="224"/>      else
<a name="225"/>         [ connect(handle_lpress, Event.MOUSE_MIDDLE_PRESS).last_listener,
<a name="226"/>           connect(handle_ldrag, Event.MOUSE_MIDDLE_DRAG).last_listener,
<a name="227"/>           connect(handle_lrelease, Event.MOUSE_MIDDLE_RELEASE).last_listener ]
<a name="228"/>      link
<a name="229"/>   end
<a name="230"/>
<a name="231"/>   #
<a name="232"/>   # If this flag is set, then the right mouse button acts in the
<a name="233"/>   # same way as the left mouse button.
<a name="234"/>   #
<a name="235"/>   public set_use_right(s)
<a name="236"/>      need_flag(s)
<a name="237"/>      every (!\right_listeners).disconnect()
<a name="238"/>      right_listeners := if /s then
<a name="239"/>         &amp;null
<a name="240"/>      else
<a name="241"/>         [ connect(handle_lpress, Event.MOUSE_RIGHT_PRESS).last_listener,
<a name="242"/>           connect(handle_ldrag, Event.MOUSE_RIGHT_DRAG).last_listener,
<a name="243"/>           connect(handle_lrelease, Event.MOUSE_RIGHT_RELEASE).last_listener ]
<a name="244"/>      link
<a name="245"/>   end
<a name="246"/>
<a name="247"/>   public override new()
<a name="248"/>      Component.new()
<a name="249"/>      repeat_ticker := Dispatcher.new_task{repeat_tick()}
<a name="250"/>      self.accepts_focus_flag := &amp;yes
<a name="251"/>      connect(handle_lpress, Event.MOUSE_LEFT_PRESS)
<a name="252"/>      connect(handle_ldrag, Event.MOUSE_LEFT_DRAG)
<a name="253"/>      connect(handle_lrelease, Event.MOUSE_LEFT_RELEASE)
<a name="254"/>      connect(handle_key, Event.KEY_PRESS)
<a name="255"/>      connect(on_interrupted, Event.INTERRUPTED)
<a name="256"/>      return
<a name="257"/>   end
<a name="258"/>end
</pre></body></html>
