import parser

class Comment()
   public const
      comment,
      fields,
      keys

   private list_extract1(sym)
      return if sym.decl_obj.size() = 1 then
         sym.decl_obj.get_first_token().get_pad()
      else
         sym.obj.get_first_token().get_pad()
   end

   private list_extract2(sym)
      return if sym.decl_obj.get_ids().size() = 1 then
         sym.decl_obj.get_first_token().get_pad()
      else
         sym.obj.get_first_token().get_pad()
   end

   private get_comment_str(sym)
      return case classof(sym) of {
         ClassVariable : list_extract1(sym)
         GlobalSymbol :  list_extract2(sym)         
         default : sym.obj.get_first_token().get_pad()
      }
   end

   public new(sym)
      local s, l, key, val
      comment := []
      fields := table()
      keys := []
      get_comment_str(sym) ? {
         while s := tab(upto('#')) do {
            move(1)
            l := tab(upto('\n\r') | 0)
            l ? {
               if (tab(many(' \t')), ="@") then {
                  if key := tab(many(&lcase)) then {
                     val := [tab(0)]
                     if /fields[key] := [] then
                        put(keys, key)
                     put(fields[key], val)
                  } else if \key then {
                     #
                     # Continuation - add to end of last field.
                     #
                     put(fields[key][-1], tab(0))
                  } else
                     put(comment, l)
               } else
                  put(comment, l)
            }
         }
      }
      #
      # Strip off any empty lines at the front and beginning of
      # the comment.
      #
      while *comment[1] = 0 do
         pop(comment)
      while *comment[-1] = 0 do
         pull(comment)

      return
   end
end
