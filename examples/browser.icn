import 
   gui, 
   lang, 
   mail,
   graphics,
   http,
   util,
   io,
   net,
   xml,
   posix,
   ipl.sort,
   ipl.options,
   ipl.strings,
   ipl.caseless

global opts

$load EXIT "rpp.EXIT_24.gif"
$load NEXT "rpp.NEXT_24.gif"
$load PREV "rpp.PREV_24.gif"
$load HOME "rpp.HOME_24.gif"
$load STOP "rpp.STOP_24.gif"
$load PASTE "rpp.PASTE_24.gif"
$load REFRESH0 "rpp.REFRESH_24.gif"
$load BROKEN_LINK "rpp.BROKEN_LINK_24.gif"

class Req()
   public const
      url, callback, kind, form_data

   public new(url, callback, kind, form_data)
      self.url := url
      self.callback := callback
      self.kind := kind
      self.form_data := form_data
      return
   end
end

class Resp()
   public const
      err, url, data, fname, kind

   public new(err, url, data, fname, kind)
      self.err := err
      self.url := url
      self.data := data
      self.fname := fname
      self.kind := kind
      return
   end
end

class CacheEntry()
   public const
      url, data, fname

   public new(url, data, fname)
      self.url := url
      self.data := data
      self.fname := fname
      return
   end
end

class Cache()
   private t, total, lim

   public get(url)
      return member(t, string(url.str()))
   end

   private del(ent)
      local k
      k := string(ent.url.str())
      total -:= *ent.data
      delete(t, k)
   end

   public add(ent)
      local k, old
      k := string(ent.url.str())
      if old := member(t, k) then
         del(old)
      while *t > 0 &  total + *ent.data > lim do
         del(?t)
      insert(t, k, ent)
      total +:= *ent.data
      return
   end

   public new(lim)
      t := table()
      self.lim := lim
      total := 0
      return
   end
end

class Worker()
   private
      parent, httpc

   private readable
      doing, task
   
   public static const NORMAL, NAVIGATE, REFRESH

   private static init()
      NORMAL := 1
      NAVIGATE := 2
      REFRESH := 3
   end

   public cancel()
      if \doing then {
         task.interrupt()
         httpc.abort()
      }
   end

   private dwrite(a[])
      writes("[", serial(self), "] ")
      write!a
   end

   private writing_line(ev)
      dwrite("Sent: ", ev)
   end

   private read_line(ev)
      dwrite("Got : ", ev)
   end

   private read_string(ev)
      dwrite("Got : data - 0x", Format.int_to_string(*ev, 16), " bytes")
   end

   private writing_string(ev)
      dwrite("Sent: data - 0x", Format.int_to_string(*ev, 16), " bytes")
   end

   private failed(ev)
      dwrite("Failed ", &why, repl(" ", 20))
   end

   private retrying(ev)
      dwrite("Retrying ", &why, repl(" ", 20))
   end

   private other(ev, src, type)
      dwrite(type)
   end

   public read()
      if \doing then return httpc.get_read()
   end

   public count()
      return if \doing then 1 else 0
   end

   private static ls_sort(x)
      return map(x[1])
   end

   private cvt_file(f)
      local e, l, maxl, maxsz, maxuid, maxgid, t, path, rs, now, tf
      if Files.is_directory(f) then {
         l := isort(Files.list(f), ls_sort) | fail
         now := Time.get_system_seconds()
         return use {
            rs := RamStream(),
            {
               rs.out("<html><pre>")
               maxsz := maxl := maxuid := maxgid := 0
               every e := !l do {
                  maxl <:= *e[1]
                  maxsz <:= *e[2].size
                  maxuid <:= *e[2].uid
                  maxgid <:= *e[2].gid
               }
               path := Files.get_path(f)
               every e := !l do {
                  t := e[2]
                  tf := if now - t.mtime > 180 * 86400 then
                     Time(t.mtime + Time.SYSTEM_BASE_OFFSET).format("MMM dd  yyyy")
                  else
                     Time(t.mtime + Time.SYSTEM_BASE_OFFSET).format("MMM dd HH:mm")
                  rs.out(t.mode_str || "  " || left(t.uid, maxuid + 1) || left(t.gid, maxgid + 1) ||
                         right(t.size, maxsz) || " " || tf || " " ||
                         "<a href=\"file://" || path.child(e[1]).canonical().str() || "\">" || e[1] || "</a>" || "\n")
               }
               rs.out("</pre></html>")
               rs.str()
            }
         }
      } else
         return Files.file_to_string(f)
   end

   private run()
      local r, s, data, hreq, hres, fname, ce
      repeat {
         while *parent.queue = 0 do
            task.sleep()
         doing := 1
         r := pop(parent.queue)
         if r.url.protocol == "file" then {
            if data := cvt_file(r.url.get_path()) then
               r.callback(Resp(, r.url, data, r.url.get_file_last(1), r.kind))
            else
               r.callback(Resp(&why, r.url,,, r.kind))
         } else if r.kind ~= REFRESH & (ce := parent.cache.get(r.url)) then
            r.callback(Resp(, r.url, ce.data, ce.fname, r.kind))
         else use {
            s := RamStream(),
            {
               hreq := HttpRequest().
                  set_output_stream(s). 
                  set_url(r.url)
               if is(r.form_data, Message) then
                  hreq.set_multipart_form_data(r.form_data)
               else
                  hreq.set_html_form_data(\r.form_data)
               if hres := httpc.retrieve(hreq) then {
                  data := s.str()
                  fname := hres.get_content_disposition_filename() | hres.url.get_file_last(1)
                  if hreq.method == "GET"  then
                     parent.cache.add(CacheEntry(hres.url, data, fname))
                  r.callback(Resp(, hres.url, data, fname, r.kind))
               } else {
                  if /httpc.abort_flag then
                     r.callback(Resp(&why, r.url,,, r.kind))
               }
            }
         }
         doing := &null
      }
   end

   public new(parent)
      self.parent := parent
      task := Dispatcher.new_task{run()}
      httpc := HttpClient().
         set_task(task).
         set_ssl_verify(&no).
         set_cookies(parent.cookies)

      if \opts["l"] then {
         httpc.connect(failed, HttpClient.FAILED_EVENT).
            connect(retrying, HttpClient.RETRYING_EVENT).
            connect(read_line, NetClient.READ_LINE_EVENT).
            connect(read_string, NetClient.READ_STRING_EVENT).
            connect(writing_line, NetClient.WRITING_LINE_EVENT).
            connect(writing_string, NetClient.WRITING_STRING_EVENT).
            connect(other, NetClient.CONNECTING_EVENT).
            connect(other, NetClient.CONNECTED_EVENT).
            connect(other, NetClient.CLOSED_EVENT).
            connect(other, HttpClient.COMPLETE_EVENT)
      }
      return
   end
end

class Tbl(Border)
   public inner

   public get_max_width()
      local w1
      w1 := inner.layout_delegate.get_max_width()  + border.get_total_width()
      return if \title then
         max(w1, title.get_max_width() + 2 * TITLE_OFFSET)
      else
         w1
   end

   public new(url)
      cast(self,Border).new()
      inner := Component().
         set_layout(TableLayout().set_doi(0).set_dii(0).set_adjust_preferred_sizes(&yes))
      set_content(inner)
      set_border(NullBorder())
      return
   end
end

class Img(Label)
   private img_url, link_url, wrote, imgw, imgh, img_data, img_name, form, map, held

   public got_data(res)
      if \res.err then
         set_paint(ImagePaint().set_cache("rpp.BROKEN_LINK"))
      else {
         set_paint(ImagePaint().
                      set_image(res.data).
                      set_max_size(imgw, imgh).
                      set_fill_dimensions(2))
         if /paint.win then
            set_paint(ImagePaint().set_cache("rpp.BROKEN_LINK"))
         else {
            img_name := res.fname
            img_data := res.data
         }
      }
   end

   private copy_image()
      parent_dialog.own_selection(Selection.CLIPBOARD, URLSelectionOwner([img_url]))
   end

   private copy_link(u)
      parent_dialog.own_selection(Selection.CLIPBOARD, URLSelectionOwner([u]))
   end

   private save_image()
      local f, s
      f := parent_dialog.file_dialog
      f.set_file(\img_name)
      f.show_modal(parent_dialog)
      if s := f.get_result() then {
         if Files.string_to_file(s, img_data) then
            parent_dialog.msg("Saved OK", 3000)
         else
            parent_dialog.msg(&why, 3000)
      }
   end

   private handle_rpress(e)
      local pm, pm_menu, u
      pm_menu := Menu()
      pm_menu.add(TextMenuItem().
                  set_label("Copy image").
                  connect(copy_image, Event.ACTION))
      if u := \wrote then
         pm_menu.add(TextMenuItem().
                     set_label("Copy link").
                     connect(create copy_link(u), Event.ACTION))
      if \img_data then
         pm_menu.add(TextMenuItem().
                     set_label("Save image...").
                     connect(save_image, Event.ACTION))
      pm := PopupMenu()
      pm.popup(parent_dialog, pm_menu, e.x, e.y)
   end

   private handle_lrelease(e, src)
      if \wrote then
         parent_dialog.goto(wrote, Worker.NORMAL)
   end

   private handle_form_lrelease(e, src)
      if in_region(e) then
         form.submit(e, src)
   end

   private handle_exit(e)
      if \wrote then {
         parent_dialog.clear_msg()
         wrote := &null
         set_pointer()
      }
   end

   private which_url(e)
      local m, u
      in_region(e) | fail
      if m := parent_dialog.get_map(\map) &
         u := m.over_url(e.x - x - border.get_l_inset(), 
                         e.y - y - border.get_t_inset()) then 
         return u
      return \link_url
   end

   private handle_lpress(e)
      held := wrote
      set_pointer()
   end

   private handle_ldrag(e)
      local u
      if u := which_url(e) & u === held then {
         if wrote ~=== u then {
            parent_dialog.msg(u.str())
            wrote := u
         }
      } else if \wrote then {
         parent_dialog.clear_msg()
         wrote := &null
      }
   end

   private handle_move(e)
      local u
      if u := which_url(e) then {
         if wrote ~=== u then {
            set_pointer("hand1")
            parent_dialog.msg(u.str())
            wrote := u
         }
      } else if \wrote then {
         parent_dialog.clear_msg()
         wrote := &null
         set_pointer()
      }
   end

   public new(img_url, link_url, form, imgw, imgh, map)
      cast(self,Label).new()
      self.imgw := imgw
      self.imgh := imgh
      self.img_url := img_url
      self.form := form
      self.link_url := link_url
      self.map := map
      if \form then {
         set_pointer("hand1")
         connect(self.handle_form_lrelease, Event.MOUSE_LEFT_RELEASE)
      } else if \map | \link_url then {
         connect(self.handle_move, Event.MOUSE_MOVEMENT)
         connect(self.handle_ldrag, Event.MOUSE_LEFT_DRAG)
         connect(self.handle_lpress, Event.MOUSE_LEFT_PRESS)
         connect(self.handle_lrelease, Event.MOUSE_LEFT_RELEASE)
         connect(self.handle_exit, Event.MOUSE_EXIT)
      }
      connect(self.handle_rpress, Event.MOUSE_RIGHT_PRESS)
      set_paint(NullPaint())
      set_border(NullBorder())
      return
   end
end

class FormEntry()
   public reset() end

   public get_baseline_off() 
      return 0
   end

   public defer get_value(ev, src, multipart_flag)
end

class FormToggle(ToggleTextButton, FormEntry)
   private const
      value,
      init_checked

   public reset()
      set_is_checked(init_checked)
   end

   public get_value(ev, src)
      if is_checked() then 
         return value
   end

   public new(value, init_checked)
      cast(self,ToggleTextButton).new()
      self.value := value
      self.init_checked := init_checked
      set_is_checked(init_checked)
      return
   end
end

class FormButton(TextButton, FormEntry)
   private const
      value

   public get_value(ev, src)
      if src === self then
         return value
   end

   public get_baseline_off() 
      return cbwin.get_font_descent() + border.get_b_inset()
   end

   public new(value)
      cast(self,TextButton).new()
      self.value := value
      set_label(value)
      return
   end
end

class Hidden(FormEntry)
   private const
      value

   public get_value()
      return value
   end

   public new(value)
      self.value := value
      return
   end
end

class FormLabel()
   public const
      id
   public
      comp

   public new(id)
      self.id := id
      return
   end
end

class FormBrowse(Component, FormEntry)
   private const
      tf

   public get_value(ev, src, multipart_flag)
      return if /multipart_flag then
         tf.get_contents()
      else
         Files.file_to_string(tf.get_contents())
   end

   public get_filename()
      return Files.get_path(tf.get_contents()).get(-1)
   end

   public get_baseline_off() 
      return cbwin.get_font_descent() + Gui.Y_INSET
   end

   public reset()
      tf.set_contents(u"")
   end

   private on_browse()
      local f, s
      f := parent_dialog.file_dialog
      f.show_modal(parent_dialog)
      if s := f.get_result() then
         tf.set_contents(s)
   end

   public new()
      cast(self,Component).new()
      set_layout(GridLayout().set_doi(0).set_dii(0))
      tf := TextField().set_size(150).set_contents(u"")
      add(tf)
      add(TextButton().set_label("Browse...").connect(on_browse, Event.ACTION))
      return
   end
end

class FormImgX(FormEntry)
   private const
      img

   public get_value(ev, src)
      if src === img then
         return ev.x - img.x
   end

   public new(img)
      self.img := img
      return
   end
end

class FormImgY(FormEntry)
   private const
      img

   public get_value(ev, src)
      if src === img then
         return ev.y - img.y
   end

   public new(img)
      self.img := img
      return
   end
end

class FormTextField(TextField, FormEntry)
   private const
      init_val

   public get_baseline_off() 
      return cbwin.get_font_descent() + border.get_b_inset()
   end

   public reset()
      set_contents(init_val)
   end

   public get_value()
      return get_contents()
   end

   public new(init_val)
      cast(self,TextField).new()
      self.init_val := init_val
      set_contents(init_val)
      return
   end
end

class FormEditableTextList(EditableTextList, FormEntry)
   private const
      init_val

   public reset()
      set_contents_str(init_val)
      set_cursor(1, 1)
   end

   public get_value()
      return get_contents_str()
   end

   public new(init_val)
      cast(self,EditableTextList).new()
      self.init_val := init_val
      set_contents_str(init_val)
      return
   end
end

class FormList(gui.List, FormEntry)
   private const
      init_val

   public get_baseline_off() 
      return cbwin.get_font_descent() + view.border.get_b_inset() + border.get_b_inset()
   end

   public reset()
      set_selection(init_val)
   end

   public get_value(ev, src)
      return object_get_selection()
   end

   public new(list, init_val)
      cast(self,gui.List).new()
      self.init_val := init_val
      set_selection_list(list)
      set_selection(init_val)
      return
   end
end

class Form()
   private readable
      url,
      parent,
      method,
      enctype,
      items,
      labels,   # table of FormLabels with ids set (the "for" attribute)
      cbgs,
      ids       # table of Components with ids set ("id" attribute) which will be matched to entries in labels.

   private make_cgi_table(ev, src)
      local t, k, c, v, x
      t := table()
      every k := key(items) do {
         every c := !items[k] do {
            if v := c.get_value(ev, src) then {
               (x := member(t, k)) | insert(t, k, x := [])
               put(x, v)
            }
         }
      }
      return t
   end

   private make_cgi_message(ev, src)
      local k, v, c, m, mp, m2
      m := Message()
      mp := Multipart()
      every k := key(items) do {
         every c := !items[k] do {
            if v := c.get_value(ev, src, 1) then {
               m2 := Message()
               if is(c, FormBrowse) then {
                  m2.set_content_disposition(ContentDisposition.parse("form-data; name=\"" || k || "\"; filename=\"" || c.get_filename() || "\"")) | next
                  m2.set_content_type(ContentType.parse("application/octet-stream")) | next
               } else
                  m2.set_content_disposition(ContentDisposition.parse("form-data; name=\"" || k || "\"")) | next
               m2.set_decoded_content(v)
               mp.add_part(m2)
            }
         }
      }
      m.set_header("Content-Type", "multipart/form-data")
      m.set_content_object(mp) | stop("Failed to set_content_object:",m.get_reason())
      return m
   end

   public reset(ev, src)
      every (!!items).reset()
   end

   public submit(ev, src)
      if map(method) == "post" then {
         if map(enctype) == "multipart/form-data" then
            parent.goto(url, Worker.NORMAL, make_cgi_message(ev, src))
         else 
            parent.goto(url, Worker.NORMAL, make_cgi_table(ev, src))
      } else
         parent.goto(clone(url).set_cgi_parameters(make_cgi_table(ev, src)), Worker.NORMAL)
   end

   public add(name, item)
      local x
      (x := member(items, name)) | insert(items, name, x := [])
      put(x, item)
   end

   public add_label(l)
      insert(labels, l.id, l)
   end

   public link_label(id, curr_label, comp)
      # If we have a label in the context, and the for and id tags
      # make sense, link the comp to the label; otherwise put the comp
      # in ids so its id can be resolved at the end of the form.
      if \curr_label & (/curr_label.id | /id | curr_label.id == id) then
         /curr_label.comp := comp
      else
         insert(ids, \id, comp)
   end

   public resolve_link_labels()
      local id
      every id := key(ids) do
         /member(labels, id).comp := ids[id]
   end

   public get_cbg(name)
      local x
      (x := member(cbgs, name)) | insert(cbgs, name, x := CheckBoxGroup())
      return x
   end

   public new(parent, url, method, enctype)
      self.parent := parent
      self.url := url
      self.method := method
      self.enctype := enctype
      self.items := table()
      self.cbgs := table()
      self.labels := table()
      self.ids := table()
      return
   end
end

record TableContext(tbl, caption, x, y, occ, cell_border, tr)
record ListContext(tbl, index, root)
record DefListContext(tbl)
record FieldSetContext(legend)
record MapContext(map)
record SelectContext(options, sel)
record Context(base, form, form_label, url, fg, link_fg, font, align, pre, underline, strike, 
               baseline_off, face, size, bold, italic, kind, table, list, def_list, fieldset, select, map)

class MapArea()
   public const
      shape, coords, url

   public new(shape, coords, url)
      self.shape := shape
      self.coords := coords
      self.url := url
      return
   end
end

class Map()
   private const
      l

   public over_url(x, y)
      local e, co
      every e := !l do {
         co := e.coords
         case e.shape of {
            "rect": if (co[1] <= x <= co[3]) & (co[2] <= y <= co[4]) then
               return e.url
         }
      }
   end

   public add_area(area)
      put(l, area)
   end

   public new()
      l := []
      return
   end
end

class MessageLabel(Label)
   private
      want, keep

   public set(p, n)
      local t
      want := p
      if /keep then {
         /p := NullPaint()
         set_paint(p)
         if \n then {
            keep := 1
            t := Dispatcher.new_task{{
               t.sleep(n)
               keep := &null
               set_paint(\want)
               t.revert()
            }}
            t.start()
         }
      }
   end
end

class Browser(Dialog)
   private
      prev_button,
      message_label,
      close_button,
      search_field,
      next_button,
      workers,
      top_panel,
      status_ticker,
      history,
      history_pos,
      running,
      stop_button,
      home_button,
      paste_url_button,
      refresh_button,
      start_page,
      view_img,
      page_url,
      page_data,
      page_name,
      copy_page_url_item,
      save_page_item,
      maps

   private readable
      queue,
      cookies,
      cache,
      file_dialog

   public static const 
      COLORS,
      FACES,
      SIZES

   private static init()
      COLORS := table(,
                      "aqua", "#00FFFF",
                      "black", "#x000000",
                      "blue", "#0000CC",
                      "fuchsia", "#FF00FF",
                      "gray", "#808080",
                      "green", "#008000",
                      "lime", "#00FF00",
                      "maroon", "#800000",
                      "navy", "#000080",
                      "olive", "#808000",
                      "purple", "#800080",
                      "red", "#FF0000",
                      "silver", "#C0C0C0",
                      "teal", "#008080",
                      "white", "#FFFFFF",
                      "yellow", "#FFFF00")

      FACES := table(,
                     "serif", "serif",
                     "sans-serif", "sans",
                     "monospace", "mono",
                     "sans", "sans",
                     "mono", "mono",
                     "typewriter", "typewriter",
                     "cursive", "serif",
                     "fantasy", "serif",
                     "helvetica", "sans",
                     "arial", "sans",
                     "times", "serif",
                     "times new roman", "serif",
                     "courier", "typewriter")

      SIZES := [7,9,11,14,17,20,23]
   end

   public end_dialog()
   end

   public get_map(s)
      return member(maps, s)
   end

   private convert_color(el, name)
      local s
      if s := el.get_attribute(name) then {
         return if s[1] == "#" then
            s
         else
            member(COLORS, map(trim(string(s))))
      }
   end

   private synch_font(context)
      local s
      s := member(FACES, map(trim(separate(string(context.face))))) | "sans"
      if \context.bold then
         s ||:= ",bold"
      if \context.italic then
         s ||:= ",italic"
      s ||:= "," || SIZES[context.size]
      context.font := s
   end

   private status()
      local i, r, s
      repeat {
         status_ticker.sleep(200)
         i := *queue
         every i +:= (!workers).count()
         if (i > 0) | (i ~=== running) then {
            if i = 0 then {
               msg("Done")
               stop_button.set_is_shaded(&yes)
            } else {
               r := 0
               every r +:= (!workers).read()
               s := i || " running requests"
               if r > 0 then
                  s ||:= ", read " || r || " bytes"
               msg(s)
               stop_button.set_is_shaded(&no)
            }
            running := i
            if i = 0 then {
               top_panel.reset_all_layouts()
               top_panel.layout()
               top_panel.invalidate()
            }
         }
      }
   end

   public init_dialog()
      local u
      every (!workers).task.start()
      status_ticker.start()
      if \start_page then {
         if u := URL.parse(start_page) then
            goto(u, Worker.NORMAL)
         else
            msg("Invalid url")
      } else
         on_home()
   end

   private on_close_button(ev)
      dispose()
   end

   private on_next(ev)
      goto(history[history_pos +:= 1], Worker.NAVIGATE)
      update_grey()
   end

   private on_prev(ev)
      goto(history[history_pos -:= 1], Worker.NAVIGATE)
      update_grey()
   end

   private cancel()
      every (!workers).cancel()
      clear(queue)
   end

   private on_quit(ev)
      dispose()
   end
   
   private start_worker(req)
      local w
      put(queue, req)
      running := &null
      every w := !workers do 
         if w.task ~=== Dispatcher.scheduler.curr_task then
            w.task.notify()
   end

   private update_grey()
      prev_button.set_is_shaded(if history_pos > 1 then &no else &yes)
      next_button.set_is_shaded(if history_pos < *history then &no else &yes)
      refresh_button.set_is_shaded(if history[history_pos] then &no else &yes)
      copy_page_url_item.set_is_shaded(if \page_url then &no else &yes)
      save_page_item.set_is_shaded(if \page_data then &no else &yes)
   end

   private is_html(s)
      s ? {
         while tab(upto('<')) do {
            if matchcl("<!doctype" | "<html") then
               return
            # Expect html comment (see htmlparser.icn)
            ="<!" | fail
            repeat {
               tab(upto('->'))
               if u">" then
                  break
               ="--" | fail
               tab(find("--")) | fail
               ="--"
            }
         }
      }
   end

   private set_top_data(res)
      local doc, base, n, s, row, c
      if \view_img then {
         view_img.close()
         view_img := &null
      }
      if \res.err then {
         s := u"<html><h1>Error:</h1>Getting " || res.url.str() || u"<br><br>" || res.err || u"</html>"
         page_data := &null
      } else if is_html(res.data) then {
         s := page_data := res.data
      } else if view_img := Window.open_image(res.data, cbwin) then {
         row := Image().set_border(NullBorder()).set_window(view_img)
         page_data := res.data
      } else {
         s := u"<html><h1>Problem:</h1>Displaying " || res.url.str() || u"<br><br>This does not seem to be an HTML document</html>"
         page_data := res.data
      }

      page_name := res.fname
      page_url := res.url
      if res.kind = Worker.NORMAL then {
         while *history > history_pos do
            pull(history)
         put(history, page_url)
         history_pos +:= 1
      }
      update_grey()
      search_field.set_contents(page_url.str())

      if /view_img then {
         Files.string_to_file("/tmp/browser.html",s)
         s := Text.liberal_ucs(s)
         doc := HtmlParser().parse(s)
         if \opts["f"] then
            to_stdout(doc, 3)
         base := page_url
         if n := doc.get_root_element().search_tree(u"BASE") then
            base := URL.parse(n.get_attribute(u"HREF"))

         row := TextFlow()
         c := Context()
         c.base := base
         c.face := "sans"
         c.fg := "black"
         c.link_fg := "blue"
         c.size := 3
         c.baseline_off := 0
         c.kind := res.kind   # Tells images whether to refresh or not
         synch_font(c)
         maps := table()
         if n := doc.get_root_element().search_tree(u"BODY") then {
            row.set_bg(convert_color(n, u"BGCOLOR"))
            c.fg := convert_color(n, u"TEXT")
            c.link_fg := convert_color(n, u"LINK")
         }

         traverse(doc, row, c)
      }
      top_panel.set_area_y(0)
      top_panel.view.inner.finally()
      top_panel.set_inner(row)
      row.initially()
      top_panel.layout()
      top_panel.invalidate()
      change_pointer(DEFAULT_POINTER)
   end

   private mk_link(base, s)
      if match(u"http://" | u"https://" | u"file://", map(s)) then
         return URL.parse(s)
      else if \base then
         return base.get_relative(s)
   end

   private traverse_a(e, p, context)
      local url,c 
       if url := mk_link(context.base, e.get_attribute(u"HREF") | (u"#" || e.get_attribute(u"NAME"))) then {
          c := copy(context)
          c.url := url
          c.fg := c.link_fg
          return traverse(e, p, c)
       }
   end

   private traverse_hN(e, p, context)
      local c
      put_para(p)
      c := copy(context)
      c.size := 7 - e.name[-1]
      c.bold := 1
      synch_font(c)
      traverse(e, p, c)
      put_para(p)
   end

   private parse_size(s, curr)
      local i
      i := if any('+\-', s[1]) then
         curr + integer(s)
      else
         integer(s)
      return (0 < \i <= 7, i)
   end

   private traverse_font(e, p, context)
      local c
      c := copy(context)
      c.fg := convert_color(e, u"COLOR")
      c.face := e.get_attribute(u"FACE")
      c.size := parse_size(e.get_attribute(u"SIZE"), c.size)
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_tt(e, p, context)
      local c
      c := copy(context)
      c.face := "mono"
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_big(e, p, context)
      local c
      c := copy(context)
      if c.size < 7 then {
         c.size +:= 1
         synch_font(c)
      }
      traverse(e, p, c)
   end

   private traverse_small(e, p, context)
      local c
      c := copy(context)
      if c.size > 1 then {
         c.size -:= 1
         synch_font(c)
      }
      traverse(e, p, c)
   end

   private traverse_sup(e, p, context)
      local c
      c := copy(context)
      if c.size > 1 then {
         c.size -:= 1
         synch_font(c)
      }
      c.baseline_off +:= 1
      traverse(e, p, c)
   end

   private traverse_sub(e, p, context)
      local c
      c := copy(context)
      if c.size > 1 then {
         c.size -:= 1
         synch_font(c)
      }
      c.baseline_off -:= 1
      traverse(e, p, c)
   end

   private traverse_b(e, p, context)
      local c
      c := copy(context)
      c.bold := 1
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_i(e, p, context)
      local c
      c := copy(context)
      c.italic := 1
      synch_font(c)
      traverse(e, p, c)
   end

   private traverse_u(e, p, context)
      local c
      c := copy(context)
      c.underline := 1
      traverse(e, p, c)
   end

   private traverse_s(e, p, context)
      local c
      c := copy(context)
      c.strike := 1
      traverse(e, p, c)
   end

   private traverse_form(e, p, context)
      local m, c, t
      m := e.get_attribute(u"METHOD") | "get"
      t := e.get_attribute(u"ENCTYPE") | "application/x-www-form-urlencoded"
      c := copy(context)
      c.form := Form(self, mk_link(context.base, e.get_attribute(u"ACTION")), m, t)
      traverse(e, p, c)
      (\c.form).resolve_link_labels()
   end

   private traverse_label(e, p, context)
      local c, l, id
      \context.form | fail
      id := e.get_attribute(u"FOR")
      l := FormLabel(id)
      if \id then
         context.form.add_label(l)
      c := copy(context)
      c.form_label := l
      traverse(e, p, c)
   end

   private add_component(p, c, context, align)
      /align := "absbottom"
      put(p.input, ComponentCmd(c, context, align))
      p.add(c)
   end

   private traverse_img(e, p, context)
      local q, url, border, iw, ih, align, map, s
      if url := mk_link(context.base, e.get_attribute(u"SRC")) then {
         iw := (0 <= integer(e.get_attribute(u"WIDTH")))
         ih := (0 <= integer(e.get_attribute(u"HEIGHT")))
         if (s := e.get_attribute(u"USEMAP")) & (s[1] == u"#") then
            map := default.map(string(s[2:0]))
         q := Img(url, context.url,, iw, ih, map)
         border := (0 < integer(e.get_attribute(u"BORDER"))) | 0
         if border > 0 then
            q.set_border(PlainBorder().set_line_width(border))
         start_worker(Req(url, q.got_data, context.kind))
         align := convert_comp_align(e, u"ALIGN") | Align.B
         add_component(p, q, context, align)
      }
   end

   private traverse_select(e, p, context)
      local q, id, c, sc
      \context.form | fail
      id := e.get_attribute(u"ID")
      sc := SelectContext()
      sc.options := []
      sc.sel := 1
      c := copy(context)
      c.select := sc
      traverse(e, p, c)
      q := FormList(sc.options, sc.sel). 
         set_font(context.font).
         set_fg(context.fg)
      if e.get_attribute(u"DISABLED") then
         q.set_is_shaded(&yes)
      else
         context.form.add(e.get_attribute(u"NAME"), q)
      context.form.link_label(id, context.form_label, q)
      add_component(p, q, context, Align.B)
   end

   private traverse_option(e, p, context)
      local sc
      sc := \context.select | fail
      put(sc.options, e.get_trimmed_string_content())
      if e.get_attribute(u"SELECTED") then
         sc.sel := *sc.options
   end

   private traverse_textarea(e, p, context)
      local q, w, h, mW, id
      \context.form | fail
      id := e.get_attribute(u"ID")
      mW := cbwin.clone().set_font(context.font)
      w := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + mW.text_width(repl("x", e.get_attribute(u"COLS")))) | 200
      h := (2 * Gui.BORDER_WIDTH + e.get_attribute(u"ROWS") * mW.get_font_height()) | 100
      mW.uncouple()
      q := FormEditableTextList(e.get_trimmed_string_content()).
         set_font(context.font).
         set_fg(context.fg).
         set_size(w, h)
      if e.get_attribute(u"DISABLED") then
         q.set_is_shaded(&yes)
      else {
         if e.get_attribute(u"READONLY") then
            q.set_is_editable(&no)
         context.form.add(e.get_attribute(u"NAME"), q)
      }
      context.form.link_label(id, context.form_label, q)
      add_component(p, q, context)
   end

   private traverse_input(e, p, context)
      local q, s, k, v, size, mW, id, url, checked, align
      \context.form | fail
      s := string(map(e.get_attribute(u"TYPE"))) | "text"
      case s of {
         "file": {
            q := FormBrowse().
                  set_font(context.font).
                  set_fg(context.fg)
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else
               context.form.add(e.get_attribute(u"NAME"), q)
            add_component(p, q, context, Align.B)
         }
         "submit" : {
            v := e.get_attribute(u"VALUE")
            if /v | (*v = 0) then
               v := u"Submit"
            q := FormButton(v).
                  set_font(context.font).
                  set_fg(context.fg).
                  connect(context.form.submit, Event.ACTION)
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else
               context.form.add(e.get_attribute(u"NAME"), q)
            add_component(p, q, context, Align.B)
         }
         "image" : {
            if url := mk_link(context.base, e.get_attribute(u"SRC")) then {
               q := Img(url,, context.form)
               start_worker(Req(url, q.got_data, context.kind))
               if e.get_attribute(u"DISABLED") then
                  q.set_is_shaded(&yes)
               else {
                  if k := e.get_attribute(u"NAME") then {
                     context.form.add(k || ".x", FormImgX(q))
                     context.form.add(k || ".y", FormImgY(q))
                  } else {
                     context.form.add("x", FormImgX(q))
                     context.form.add("y", FormImgY(q))
                  }
               }
               align := convert_comp_align(e, u"ALIGN") | Align.B
               add_component(p, q, context, align)
            }
         }
         "reset" : {
            v := e.get_attribute(u"VALUE")
            if /v | (*v = 0) then
               v := u"Reset"
            q := FormButton(v).
               set_font(context.font).
               set_fg(context.fg).
               connect(context.form.reset, Event.ACTION)
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            add_component(p, q, context, Align.B)
         }
         "hidden": {
            context.form.add(e.get_attribute(u"NAME"), Hidden(e.get_attribute(u"VALUE")))
         }
         "radio": {
            v := e.get_attribute(u"VALUE") | u"on"
            id := e.get_attribute(u"ID")
            checked := if e.get_attribute(u"CHECKED") then &yes else &no
            q := FormToggle(v, checked).
               set_paint(ImagePaint().set_cache("gui.DIAMOND_UP")).
               set_paint_down(ImagePaint().set_cache("gui.DIAMOND_DOWN")).
               set_border(NullBorder())
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else
               context.form.add(e.get_attribute(u"NAME"), q)
            add_component(p, q, context, Align.B)
            context.form.link_label(id, context.form_label, q)
            context.form.get_cbg(e.get_attribute(u"NAME")).add(q)
         }
         "checkbox": {
            v := e.get_attribute(u"VALUE") | u"on"
            id := e.get_attribute(u"ID")
            checked := if e.get_attribute(u"CHECKED") then &yes else &no
            q := FormToggle(v, checked).
               set_paint(ImagePaint().set_cache("gui.BOX_UP")).
               set_paint_down(ImagePaint().set_cache("gui.BOX_DOWN")).
               set_border(NullBorder())
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else
               context.form.add(e.get_attribute(u"NAME"), q)
            add_component(p, q, context, Align.B)
            context.form.link_label(id, context.form_label, q)
         }
         "text" | "password": {
            v := e.get_attribute(u"VALUE") | u""
            id := e.get_attribute(u"ID")
            mW := cbwin.clone().set_font(context.font)
            size := (2 * (Gui.BORDER_WIDTH + Gui.TEXT_INSET) + mW.text_width(repl("x", e.get_attribute(u"SIZE")))) | 160
            mW.uncouple()
            q := FormTextField(v).
               set_fg(context.fg).
               set_font(context.font).
               set_size(size).
               connect(context.form.submit, Event.ACTION)
            if s == "password" then
               q.set_displaychar("*")
            if e.get_attribute(u"DISABLED") then
               q.set_is_shaded(&yes)
            else {
               if e.get_attribute(u"READONLY") then
                  q.set_is_editable(&no)
               context.form.add(e.get_attribute(u"NAME"), q)
            }
            context.form.link_label(id, context.form_label, q)
            add_component(p, q, context, Align.B)
         }
      }
      traverse(e, p, context)
   end

   private show_parents(c)
      write("chain of ",image(c))
      while \c do {
         write("\tc=",image(c))
         c := c.parent
      }
   end

   private show_input(ii, l)
      local s,a
      case classof(ii) of {
         TextCmd: {
            s := ii.s
            if *s > 30 then 
               s[30:0] := "...("||*s||")"
            a := ""
            a ||:= "fg="|| \ii.attr.fg
            a ||:= " font="|| \ii.attr.font
            write(repl("   ",l), image(s),"  ",a) 
         }
         ComponentCmd: show_structure(ii.c, l)
         default: write(repl("   ",l),image(ii))
      }
   end

   private show_output(xo, l)
      local s,a
      s := "Text @"||xo.x||","||xo.y
      s ||:= xo.s
      if *s > 30 then 
         s[30:0] := "...("||*s||")"
      a := ""
      a ||:= "fg="|| \xo.attr.fg
      a ||:= " font="|| \xo.attr.font
      write(repl("   ",l), image(s),"  ",a) 
   end

   private show_structure(c, l)
      local s, v, short
      /l := 0
      short := s := ""
      short ||:= "w="||\c.w||" h="||\c.h
      if is(c, TextFlow) then short ||:= "  " || *c.input || " items"
      if c.get_constraint("eol") then s ||:= "eol "
      if \c.get_constraint("x_fill") then s ||:= "x_fill "
      if v := c.get_constraint("x_weight") then s ||:= "x_weight=" || v
      if v := c.get_constraint("x_align") then s ||:= "x_align=" || v
      write(repl("   ",l), image(c),short,"\t\t\t",s)
      if is(c, TextFlow) then {
         every show_input((!c.input), l+1)
      } else
         every show_structure((!c.children), l+1)
   end

   private traverse_div(e, p, context)
      put_new_row(p)
      traverse(e, p, context)
   end

   private traverse_br(e, p, context)
      local clear
      clear := case string(map(e.get_attribute(u"CLEAR"))) of {
         "left": Align.L
         "right": Align.R
         "all"|"both": "all"
      }
      put(p.input, BreakCmd(clear))
   end

   private traverse_hr(e, p, context)
      put_new_row(p)
      add_component(p, Line().set_width(5), context)
      put_new_row(p)
   end

   private traverse_q(e, p, context)
      put(p.input, TextCmd(u"\u201c", context))
      traverse(e, p, context)
      put(p.input, TextCmd(u"\u201d", context))
   end

   private traverse_p(e, p, context)
      local c
      c := copy(context)
      put_para(p)
      c.align := case string(map(e.get_attribute(u"ALIGN"))) of {
         "left": Align.L
         "center": Align.C
         "right": Align.R
      }
      traverse(e, p, c)
      put_para(p)
   end

   private traverse_pre(e, p, context)
      local c
      put_para(p)
      c := copy(context)
      c.face := "mono"
      synch_font(c)
      c.pre := 1
      traverse(e, p, c)
      put_para(p)
   end

   private put_para(p)
      put(p.input, ParaCmd())
   end

   private put_new_row(p)
      put(p.input, NewRowCmd())
   end

   private traverse_center(e, p, context)
      local c
      c := copy(context)
      c.align := Align.C
      traverse(e, p, c)
   end

   private convert_valign(el, name)
      return case string(map(el.get_attribute(name))) of {
         "top": Align.T
         "middle": Align.C
         "bottom"|"baseline": Align.B
      }
   end

   private convert_halign(el, name)
      return case string(map(el.get_attribute(name))) of {
         "left": Align.L
         "center": Align.C
         "right": Align.R
      }
   end

   private convert_cap_align(el, name)
      return case string(map(el.get_attribute(name))) of {
         "left": Align.L
         "right": Align.R
         "top": Align.T
         "bottom": Align.B
      }
   end

   private convert_comp_align(el, name)
      return case map(string(el.get_attribute(name))) of {
         "left": Align.L
         "right": Align.R
         "baseline"|"bottom": Align.B
         "texttop"|"top": Align.T
         "middle" | "center" | "centre": Align.C
         "absbottom":  "absbottom"
         "absmiddle":  "absmiddle"
      }
   end

   private traverse_table(e, p, context)
      local ct, tbl, width, border, cellpadding, cellspacing, cell_border, align, c

      tbl := Tbl()
      if width := (0 <= integer(e.get_attribute(u"WIDTH"))) then
         tbl.set_width(width)
      border := integer(e.get_attribute(u"BORDER")) | 0
      cellpadding := integer(e.get_attribute(u"CELLPADDING")) | 0
      cellspacing := integer(e.get_attribute(u"CELLSPACING")) | 2
      tbl.inner.layout_delegate.set_doi(cellspacing).set_dii(cellspacing/2)
      if border > 0 then
         tbl.set_border(PlainBorder().set_line_width(border))
      tbl.set_bg(convert_color(e, u"BGCOLOR"))

      cell_border := if border > 0 then
         CompoundBorder().
            set_outer(PlainBorder().set_line_width(1)).
            set_inner(EmptyBorder().set_insets(cellpadding, cellpadding, cellpadding, cellpadding))
         else
            EmptyBorder().set_insets(cellpadding, cellpadding, cellpadding, cellpadding)
      align := convert_comp_align(e, u"ALIGN") | Align.C

      c := copy(context)
      c.table := ct := TableContext()
      ct.tbl := tbl
      ct.x := ct.y := 1
      ct.occ := set()
      ct.cell_border := cell_border
      traverse(e, p, c)

      if not(align === (Align.L | Align.R)) then
         put_new_row(p)
      if \c.table.caption then
         add_component(p, c.table.caption, context, align)
      else
         add_component(p, tbl, context, align)

      if not(align === (Align.L | Align.R)) then
         put_new_row(p)
   end

   private traverse_caption(e, p, context)
      local ct, cap, main, c, align
      ct := \context.table | fail
      /ct.caption | fail

      # A Tbl with two TextFlows; the caption and another containing just the table itself.
      ct.caption := Tbl()
      cap := TextFlow().set_dominant_width(TextFlow.DEFAULT_WIDTH)
      c := copy(context)
      c.align := Align.C
      traverse(e, cap, c)
      main := TextFlow()
      add_component(main, ct.tbl, context)
      align := convert_cap_align(e, u"ALIGN") | Align.T
      case align of {
         Align.T: {
            cap.set_constraint("eol", &yes)
            ct.caption.inner.add(cap).add(main)
         }
         Align.B: {
            main.set_constraint("eol", &yes)
            ct.caption.inner.add(main).add(cap)
         }
         Align.L: {
            ct.caption.inner.add(cap).add(main)
         }
         Align.R: {
            ct.caption.inner.add(main).add(cap)
         }
      }
   end

   private traverse_tr(e, p, context)
      local ct
      ct := \context.table | fail
      ct.tr := e
      if ct.x > 1 then {
         ct.x := 1
         ct.y +:= 1
      }
      traverse(e, p, context)
      if ct.x > 1 then {
         ct.x := 1
         ct.y +:= 1
      }
      ct.tr := &null
   end

   private traverse_td(e, p, context)
      local ct, row, c, colspan, rowspan, width, valign
      ct := \context.table | fail
      while member(ct.occ, ct.x || "," || ct.y) do
         ct.x +:= 1
      valign := convert_valign(e | \ct.tr, u"VALIGN") |  Align.C
      row := TextFlow().
         set_constraint("x", ct.x). 
         set_constraint("y", ct.y).
         set_border(ct.cell_border).
         set_v_align(valign)
      colspan := (0 < integer(e.get_attribute(u"COLSPAN"))) | 1
      row.set_constraint("w", colspan)
      rowspan := (0 < integer(e.get_attribute(u"ROWSPAN"))) | 1
      row.set_constraint("h", rowspan)
      row.set_bg(convert_color(e | \ct.tr, u"BGCOLOR"))
      every insert(ct.occ, (ct.x to ct.x + colspan - 1) || "," || (ct.y to ct.y + rowspan - 1))
      if width := e.get_attribute(u"WIDTH") then {
         if width := (0 <= integer(width)) then
            row.set_width(width)
         else if width[-1] == "%" & width := (0 <= integer(width[1:-1])) then
            row.set_constraint("pct_w", width)
      }
      ct.tbl.inner.add(row)

      c := copy(context)
      if e.name == u"TH" then {
         c.bold := 1
         c.size := min(c.size + 1, 7)
         synch_font(c)
         c.align := convert_halign(e | \ct.tr, u"ALIGN") | Align.C
      } else
         c.align := convert_halign(e | \ct.tr, u"ALIGN") | Align.L
      ct.x +:= colspan

      traverse(e, row, c)
   end

   private traverse_list(e, p, context)
      local tbl, lc, c
      tbl := Tbl()
      c := copy(context)
      lc := ListContext()
      lc.tbl := tbl
      lc.index := 0
      lc.root := e
      c.list := lc
      traverse(e, p, c)
      put_new_row(p)
      add_component(p, tbl, context)
      put_new_row(p)
   end

   private traverse_li(e, p, context)
      local lc, row
      lc := \context.list | fail
      row := TextFlow()
      if lc.root.name == u"OL" then
         put(row.input, TextCmd((lc.index +:= 1) || u".\ua0\ua0\ua0", context))
      else
         put(row.input, TextCmd(u"\u2022\ua0\ua0\ua0", context))
      lc.tbl.inner.add(row)
      row := TextFlow() .set_constraint("eol", &yes)
      lc.tbl.inner.add(row)
      traverse(e, row, context)
   end

   private traverse_dl(e, p, context)
      local tbl, dc, c
      tbl := Tbl()
      tbl.inner.layout_delegate.set_fix_col1(&yes)
      dc := DefListContext()
      dc.tbl := tbl
      c := copy(context)
      c.def_list := dc
      traverse(e, p, c)
      put_new_row(p)
      add_component(p, tbl, context)
      put_new_row(p)
   end

   private traverse_dt(e, p, context)
      local dc, row
      dc := \context.def_list | fail
      row := TextFlow() .set_constraint("eol", &yes).set_constraint("w", 2)
      dc.tbl.inner.add(row)
      traverse(e, row, context)
   end

   private traverse_dd(e, p, context)
      local dc, row
      dc := \context.def_list | fail
      row := TextFlow() .set_constraint("eol", &no)
      put(row.input, TextCmd(u"\u2022\ua0\ua0\ua0", context))
      dc.tbl.inner.add(row)
      row := TextFlow() .set_constraint("eol", &yes)
      dc.tbl.inner.add(row)
      traverse(e, row, context)
   end

   private traverse_blockquote(e, p, context)
      local tbl, row
      put_new_row(p)
      tbl := Tbl()
      add_component(p, tbl, context)
      row := TextFlow()
      put(row.input, TextCmd(u"\ua0\ua0\ua0\ua0", context))
      tbl.inner.add(row)
      row := TextFlow() .set_constraint("eol", &yes)
      tbl.inner.add(row)
      traverse(e, row, context)
      put_new_row(p)
   end

   private traverse_fieldset(e, p, context)
      local tbl, row, c, fc
      put_new_row(p)
      tbl := Tbl().set_border(CompoundBorder().
                              set_outer(SunkenBorder().set_line_width(1)).
                              set_inner(EmptyBorder()))
      add_component(p, tbl, context)
      row := TextFlow()
      tbl.inner.add(row)
      fc := FieldSetContext()
      c := copy(context)
      c.fieldset := fc
      traverse(e, row, c)
      tbl.set_title(\fc.legend)
      put_new_row(p)
   end

   private traverse_legend(e, p, context)
      local fc
      fc := \context.fieldset | fail
      /fc.legend | fail
      fc.legend := TextFlow().
         set_dominant_width(TextFlow.MAX_WIDTH)
      traverse(e, fc.legend, context)
   end

   private traverse_map(e, p, context)
      local c, mc
      mc := MapContext()
      mc.map := Map()
      c := copy(context)
      c.map := mc
      traverse(e, p, c)
      insert(maps, map(string(e.get_attribute(u"NAME"))), mc.map)
   end

   private traverse_area(e, p, context)
      local mc, s, coords
      mc := \context.map | fail
      if s := e.get_attribute(u"COORDS") then {
         coords := []
         every put(coords, integer(separate(s)))
         mc.map.add_area(MapArea(map(string(e.get_attribute(u"SHAPE"))), 
                                 coords,
                                 mk_link(context.base, e.get_attribute(u"HREF"))))
      }
   end

   private traverse_text(e, p, context)
      put(p.input, TextCmd(e, context))
   end

   private traverse(n, p, context)
      local e
      every e := !n.children do {
         if text(e) then
            traverse_text(e, p, context)
         else if is(e, HtmlElement) then {
            case string(e.name) of {
               "TITLE"|"META"|"LINK"|"SCRIPT"|"STYLE": {}
               "A": traverse_a(e, p, context)
               "FORM": traverse_form(e, p, context)
               "LABEL": traverse_label(e, p, context)
               "FONT": traverse_font(e, p, context)
               "IMG": traverse_img(e, p, context)
               "SELECT": traverse_select(e, p, context)
               "OPTION": traverse_option(e, p, context)
               "TEXTAREA": traverse_textarea(e, p, context)
               "INPUT": traverse_input(e, p, context)
               "DIV": traverse_div(e, p, context)
               "BIG": traverse_big(e, p, context)
               "SMALL": traverse_small(e, p, context)
               "SAMP"|"KBD"|"CODE"|"TT": traverse_tt(e, p, context)
               "DFN"|"B": traverse_b(e, p, context)
               "EM"|"CITE"|"I": traverse_i(e, p, context)
               "BR": traverse_br(e, p, context)
               "HR": traverse_hr(e, p, context)
               "CENTER": traverse_center(e, p, context)
               "H" || (1 to 6): traverse_hN(e, p, context)
               "TABLE": traverse_table(e, p, context)
               "CAPTION": traverse_caption(e, p, context)
               "TR": traverse_tr(e, p, context)
               "TD"|"TH": traverse_td(e, p, context)
               "DIR"|"MENU"|"OL"|"UL": traverse_list(e, p, context)
               "LI": traverse_li(e, p, context)
               "DL": traverse_dl(e, p, context)
               "DT": traverse_dt(e, p, context)
               "DD": traverse_dd(e, p, context)
               "BLOCKQUOTE": traverse_blockquote(e, p, context)
               "P": traverse_p(e, p, context)
               "Q": traverse_q(e, p, context)
               "INS"|"U": traverse_u(e, p, context)
               "DEL"|"STRIKE"|"S": traverse_s(e, p, context)
               "SUP": traverse_sup(e, p, context)
               "SUB": traverse_sub(e, p, context)
               "LISTING"|"PRE": traverse_pre(e, p, context)
               "FIELDSET": traverse_fieldset(e, p, context)
               "LEGEND": traverse_legend(e, p, context)
               "MAP": traverse_map(e, p, context)
               "AREA": traverse_area(e, p, context)
               default : traverse(e, p, context)
            }
         }
      }
   end

   public goto(url, kind, form_data)
      cancel()
      start_worker(Req(url, set_top_data, kind, form_data))
   end

   private on_search_field(ev)
      local s, u
      s := search_field.get_contents()
      if *s = 0 then
         fail
      if u := URL.parse(s) then
         goto(u, Worker.NORMAL)
      else
         msg("Invalid url")
   end

   public msg(s, n)
      message_label.set(TextPaint(s), n)
   end

   public clear_msg()
      message_label.set()
   end

   public new(s, cookies)
      cast(self,Dialog).new()
      self.setup()
      self.cookies := cookies
      self.cache := Cache(8*1024*1024)
      file_dialog := FileDialog()
      start_page := s
      queue := []
      workers := []
      every 1 to 6 do
         put(workers, Worker(self))
      status_ticker := Dispatcher.new_task{status()}
      top_panel.
         set_inner(Component().set_size(10,10)).
         use_default_keys()
      history := []
      history_pos := 0
      update_grey()
      running := 0
      return
   end

   private on_stop(ev)
      cancel()
   end

   private on_home(ev)
      goto(URL.parse(u"file://" || ucs(Files.get_path(Files.get_home()).child(".oibrowser.html").str())), Worker.NORMAL)
   end

   private handle_paste_response(target_type, data, e)
      if /data then
         fail
      data ?:= tab(upto('\r\n'))
      search_field.set_contents(data)
   end

   private on_paste_url(ev)
      request_selection(Selection.CLIPBOARD, 
                        ["text/uri-list", Selection.UTF8_STRING_TARGET, Selection.STRING_TARGET], 
                        handle_paste_response, 
                        ev)
   end

   private on_refresh(ev)
      goto(history[history_pos], Worker.REFRESH)
      update_grey()
   end

   private on_icon_event(ev)
   end

   private on_copy_page_url_item(ev)
      own_selection(Selection.CLIPBOARD, URLSelectionOwner([page_url]))
   end

   private on_save_page_item(ev)
      local s
      file_dialog.set_file(\page_name)
      file_dialog.show_modal(self)
      if s := file_dialog.get_result() then {
         if Files.string_to_file(s, page_data) then
            msg("Saved OK", 3000)
         else
            msg(&why, 3000)
      }
   end

   private setup()
      local quit_menu_item, paint_27, paint_32, paint_19, paint_24, paint_37, paint_29, paint_34, layout_1, panel_1, paint_13, paint_26, paint_31, paint_39, paint_23, paint_20, paint_28, paint_33, paint_12, paint_25, paint_30, paint_38, border_1, menu_bar_1, menu_1, layout_2
      self.set_label("Browser")
      self.set_min_height(250)
      self.set_resize(&yes)
      paint_13 := TextPaint("File")
      paint_38 := TextPaint("Copy page")
      copy_page_url_item := TextMenuItem().
         connect(on_copy_page_url_item, Event.ACTION).
         set_paint_mid(paint_38)
      paint_39 := TextPaint("Save page...")
      save_page_item := TextMenuItem().
         connect(on_save_page_item, Event.ACTION).
         set_paint_mid(paint_39)
      paint_12 := TextPaint("Quit")
      quit_menu_item := TextMenuItem().
         connect(on_quit, Event.ACTION).
         set_paint_mid(paint_12)
      menu_1 := Menu().
         set_accel("f").
         set_paint_mid(paint_13).
         add(copy_page_url_item).
         add(save_page_item).
         add(quit_menu_item)
      menu_bar_1 := MenuBar().
         set_size("100").
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("l_inset", 0).
         set_constraint("r_inset", 0).
         set_constraint("t_inset", 0).
         set_constraint("x_fill", &yes).
         add(menu_1)
      self.add(menu_bar_1)
      paint_20 := ImagePaint().
         set_cache("rpp.EXIT_24")
      paint_19 := TextPaint("Close")
      close_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_19).
         set_accel("c").
         connect(self.on_close_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_20)
      paint_24 := ImagePaint().
         set_cache("rpp.HOME_24")
      paint_23 := TextPaint("Home")
      home_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_23).
         set_accel("n").
         connect(self.on_home, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_24)
      paint_26 := ImagePaint().
         set_cache("rpp.REFRESH_24")
      paint_25 := TextPaint("Refresh")
      refresh_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_25).
         connect(self.on_refresh, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_26)
      paint_28 := ImagePaint().
         set_cache("rpp.PREV_24")
      paint_27 := TextPaint("Prev")
      prev_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_27).
         connect(self.on_prev, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_28)
      paint_30 := ImagePaint().
         set_cache("rpp.NEXT_24")
      paint_29 := TextPaint("Next")
      next_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_29).
         connect(self.on_next, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_30)
      paint_32 := ImagePaint().
         set_cache("rpp.STOP_24")
      paint_31 := TextPaint("Stop")
      stop_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_31).
         connect(self.on_stop, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_32)
      paint_34 := ImagePaint().
         set_cache("rpp.PASTE_24")
      paint_33 := TextPaint("Paste URL")
      paste_url_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_33).
         connect(self.on_paste_url, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_34)
      layout_1 := GridLayout().
         set_doi(0).
         set_dii(2).
         set_extra("cells")
      panel_1 := Panel().
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_align", Align.L).
         set_layout(layout_1).
         add(close_button).
         add(home_button).
         add(refresh_button).
         add(prev_button).
         add(next_button).
         add(stop_button).
         add(paste_url_button)
      self.add(panel_1)
      search_field := TextField().
         set_size("100").
         set_align(Align.C, Align.T).
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         connect(self.on_search_field, Event.ACTION).
         set_contents("")
      self.add(search_field)
      top_panel := ComponentScrollArea().
         set_size("651", "337").
         set_font("sans,9").
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("y_fill", &yes).
         set_constraint("y_weight", 1.0)
      self.add(top_panel)
      paint_37 := TextPaint("")
      border_1 := CompoundBorder().
         set_outer(SunkenBorder()).
         set_inner(EmptyBorder().
            set_l_inset(3)).
         set_x_align(Align.L)
      message_label := MessageLabel().
         set_size("100").
         set_align(Align.L, Align.B).
         set_fg("red").
         clear_constraints().
         set_constraint("b_inset", 0).
         set_constraint("l_inset", 0).
         set_constraint("r_inset", 0).
         set_constraint("x_fill", &yes).
         set_border(border_1).
         set_paint(paint_37)
      self.add(message_label)
      self.connect(self.on_close_button, Event.WINDOW_CLOSE_BUTTON)
      self.connect(self.on_icon_event, Event.ICON)
      layout_2 := GridLayout().
         set_extra("cells")
      self.set_layout(layout_2)
      self.set_focus(search_field.find_focus())
   end
end

procedure main(a)
   local d, s, cookies, t, bak
   opts := options(a, "-f! -k: -l!")
   cookies := \opts["k"] | System.getenv("GETURL_COOKIES")
   if \cookies then {
      t := decode(Files.file_to_string(cookies)) |
         write(FileStream.stderr, "Couldn't read/decode cookie file ", cookies, ": ", &why)
   }
   ImageCache.name_image("rpp.EXIT_24", EXIT)
   ImageCache.name_image("rpp.NEXT_24", NEXT)
   ImageCache.name_image("rpp.PREV_24", PREV)
   ImageCache.name_image("rpp.HOME_24", HOME)
   ImageCache.name_image("rpp.REFRESH_24", REFRESH0)
   ImageCache.name_image("rpp.PASTE_24", PASTE)
   ImageCache.name_image("rpp.STOP_24", STOP)
   ImageCache.name_image("rpp.BROKEN_LINK", BROKEN_LINK)
   s := ucs(a[1])
   /t := table()
   d := Browser(s, t)
   d.show_modal()

   if \cookies then {
      bak := cookies || ".bak"
      Files.string_to_file(bak, encode(Cookie.expire_cookies(t))) | 
         stop("Couldn't encode to temp cookie file ", bak, ": ", &why)
      # Use rename not move to ensure it's atomic
      Files.rename(bak, cookies) | stop("Couldn't rename cookie file ", bak, ": ", &why)
   }
end

### Ivib-v2 layout: $.layout
