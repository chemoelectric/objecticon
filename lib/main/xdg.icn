package xdg

import 
   io,
   util,
   lang,
   gui,
   cairo,
   ipl.tables,
   ipl.strings,
   ipl.wildcard,
   ipl.sort,
   ipl.pdco

# An object for parsing and holding the parts of a locale string, like
# "en_GB.utf8".
#
class Locale()
   public const
      lang, country, encoding, modifier

   public new(s)
      s ? {
         lang := tab(upto('_.@') | 0)
         if ="_" then
            country := tab(upto('.@') | 0)
         if ="." then
            encoding := tab(upto('@') | 0)
         if ="@" then
            modifier := tab(0)
      }
      return
   end
end

# An object for holding info about a theme and the icons in its
# various directories.
#
package class ThemeIndex()
   public const
      directories,   # A list of ThemeDirectory objects
      parents        # A list of parent theme names (strings)

   public new(directories, parents)
      self.directories := directories
      self.parents := parents
      return
   end   
end

# Encapsulates a directory in a theme.  This is not an actual directory,
# but gives the meta information about the several actual directories
# that it does relate to.  These actual directories are located under
# the various elements of the base directories path, and each one has
# an element in the cached_dirs member.
#
# For example an index.theme file may contain the directory group:-
#   [16x16/intl]
#   Size=16
#   Context=International
#   Type=Threshold
#
# This is represented by a ThemeDirectory.  Then, each element from
# gen_data_dirs() is appended to the theme name to give an actual
# directory :-
#
#   "/home/rparlett/.local/share/16x16/intl"
#   "/usr/local/share/16x16/intl"
#   "/usr/share/16x16/intl"
#  
# and the cached contents of those directories are stored in CachedDir
# instances in the cached_dirs list.
#
package class ThemeDirectory()
   public const
      type,         # Type, a string
      size,         # Sizes etc, all integers
      minsize,      #         
      maxsize,
      threshold,
      cached_dirs   # A list of CachedDir objects

   public matches_size(desired_size, scalable_flag)
      case type of {
         "Fixed": succeed desired_size = size
         "Threshold": {
            succeed size - threshold <= desired_size <= size + threshold
         }
         "Scalable": {
            if \scalable_flag then
               succeed minsize <= desired_size <= maxsize
         }
      }
   end

   public directory_size_distance(desired_size, scalable_flag)
      case type of {
         "Fixed": return abs(desired_size - size)
         "Threshold": {
            if desired_size < size - threshold then 
               return minsize - desired_size
            if desired_size > size + threshold then 
               return desired_size - maxsize
            return 0
         }
         "Scalable": {
            if \scalable_flag then {
               if desired_size < minsize then
                  return minsize - desired_size
               if desired_size > maxsize then
                  return desired_size - maxsize
               return 0
            }
         }
      }
   end

   public new(type, size, minsize, maxsize, threshold, cached_dirs)
      self.type := type
      self.size := size
      self.minsize := minsize
      self.maxsize := maxsize
      self.threshold := threshold
      self.cached_dirs := cached_dirs
      return
   end
end

#
# Encapsulates cached info about a directory.
#
package class CachedDir()
   public const
      file_path,    # A FilePath, giving the directory
      contents      # A set of strings, being the entries in the directory.

   # If f (no path) is in the directory, return its full path.
   #
   public access(f)
      if member(contents, f) then
         return file_path.child(f).str()
   end

   public new(file_path, contents)
      self.file_path := file_path
      self.contents := contents
      return
   end
end

#
# Represents info from a ".desktop" file
#
class DesktopEntry()
   public const
      name,                 # Descriptive name (ucs, mandatory)
      icon,                 # Icon name (string)
      source,               # Source file (string)
      exec,                 # Exec entry (ucs, mandatory)
      exec_line,            # optional ExecLine entry (ucs)
      path,                 # Path entry (ucs)
      terminal,             # Terminal entry (flag)
      initial_preference    # InitialPreference entry (integer or &null)

   package
      list_pos              # Used internally for initial_preference sort

   public static const
      # A command (including any flag) to prefix to the `subst_file`
      # result for an entry with the terminal flag set.  It may be
      # configured via the environment variable `OI_XDG_TERM_CMD`.  If
      # unset, a search is made for a default.
      #
      TERM_CMD

   private static find_term_cmd()
      local s
      every s := ["xterm" | "konsole" | "rxvt", "-e"] | ["gnome-terminal", "--"] do {
         if Files.find_exe(s[1]) then
            return s[1] || " " || s[2]
      }
      return "xterm -e"
   end

   private static init()
      TERM_CMD := env_string("OI_XDG_TERM_CMD") | find_term_cmd()
   end

   private static gen_args(s)
      local t
      static ch
      initial ch := ~' \t\n'
      s ? while tab(upto(ch)) do {
         if ="\"" then {
            t := ""
            repeat {
               t ||:= tab(upto('\\"') | 0)
               if ="\\" then
                  t ||:= move(1)
               else {
                  move(1)
                  break
               }
            }
         } else
            t := tab(many(ch))
         suspend t
      }
   end

   private expand_code(s, file, line, col)
      local t, ch, iflag
      t := ""
      s ? {
         while t ||:= tab(upto('%')) do {
            move(1)
            t ||:= case string(ch := move(1)) of {
               "%": "%"
               "i": 1("" ~== \icon, iflag := &yes)
               "c": name
               "k": ucs(source) | "Not utf-8"
               !"uUfF": \file
               "L": \line
               "C": \col
               "P": if \line then if \col then line || ":" || col else line
               !"dDnNvM": fail
               default: ch
            } | fail
         }
         if \iflag then
            suspend u"--icon"
         return t || tab(0)
      }
   end

   #
   # Substitute a single file (an absolute path or a URL), a line and
   # a column number (all are optional), into the Exec command,
   # generating a sequence of resulting arguments.
   #
   public subst_file_args(file, line, col)
      local s
      file := need_ucs(\file)
      if line := need_integer(\line, 1) then
         col := need_integer(\col, 1)
      s := exec
      if \line then
         s := \exec_line
      if \terminal then
         s := TERM_CMD || " " || s
      suspend expand_code(gen_args(s), file, line, col)
   end

   #
   # Helpful method to return the results of `subst_file_args()`
   # as a list.
   #
   public subst_file_list(file, line, col)
      return ipl.pdco.List{ subst_file_args(file, line, col) }
   end

   #
   # This takes the results of `subst_file_args()` and produces a
   # single string suitable for execution by the shell.
   #
   public subst_file_shell(file, line, col)
      return String{ Format.shell_escape(subst_file_args(file, line, col)), " " }
   end

   public new(name, icon, source, exec, exec_line, path, terminal, initial_preference)
      self.name := name
      self.icon := icon
      self.source := source
      self.exec := exec
      self.exec_line := exec_line
      self.path := path
      self.terminal := terminal
      self.initial_preference := initial_preference
      return
   end
end

#
# This class contains static methods relating to the base directory specification.
#
final abstract class BaseDir()
   #
   # Ensure XDG_DATA_HOME exists, or try and create it.
   #
   public static ensure_data_home()
      local f, c, s
      if s := env_string("XDG_DATA_HOME") then
         Files.is_directory(s) | return error("File specified by XDG_DATA_HOME is not a directory")
      else {
         f := FilePath(Files.get_home())
         every c := ".local" | "share" do {
            f := f.child(c)
            s := f.str()
            Files.is_directory(s) | Files.mkdir(s) | return error("Couldn't create data directory " || s || ": " || &why)
         }
      }
      return s
   end

   #
   # Ensure XDG_CONFIG_HOME exists, or try and create it.
   #
   public static ensure_config_home()
      local s
      if s := env_string("XDG_CONFIG_HOME") then
         Files.is_directory(s) | return error("File specified by XDG_CONFIG_HOME is not a directory")
      else {
         s := FilePath(Files.get_home()).child(".config").str()
         Files.is_directory(s) | Files.mkdir(s) | return error("Couldn't create config directory " || s || ": " || &why)
      }
      return s
   end

   #
   # Return the XDG_DATA_HOME directory
   #
   public static get_data_home()
      return env_string("XDG_DATA_HOME") | FilePath(Files.get_home()).walk(".local", "share").str()
   end

   #
   # Return the XDG_CONFIG_HOME directory
   #
   public static get_config_home()
      return env_string("XDG_CONFIG_HOME") | FilePath(Files.get_home()).child(".config").str()
   end

   #
   # Return the XDG_DATA_DIRS path
   #
   public static get_data_dirs()
$if _MS_WIN32
      return env_string("XDG_DATA_DIRS") | "C:\\usr\\local\\share;C:\\usr\\share"
$else
      return env_string("XDG_DATA_DIRS") | "/usr/local/share:/usr/share"
$endif
   end

   #
   # Return the XDG_CONFIG_DIRS path
   #
   public static get_config_dirs()
$if _MS_WIN32
      return env_string("XDG_CONFIG_DIRS") | "C:\\etc\\xdg"
$else
      return env_string("XDG_CONFIG_DIRS") | "/etc/xdg"
$endif
   end

   #
   # Generate the base directories, being `get_data_home()` followed
   # by the elements of `get_data_dirs()`
   #
   public static gen_data_dirs()
      suspend get_data_home() | Files.split_paths(get_data_dirs())
   end
end

#
# Some static helper methods.
#
package final abstract class Util()
   private static const
      LC_MESSAGES,        # A Locale object giving the LC_MESSAGES locale info
      INI_LC_KEYS         # A list of strings used to choose locale-based keys in
                          # ini files

   private static init()
      LC_MESSAGES := Locale(env_string("LC_ALL" | "LC_MESSAGES" | "LANG") | "C")
      INI_LC_KEYS := []
      every put(INI_LC_KEYS, 
                LC_MESSAGES.lang || "_" || \LC_MESSAGES.country || "@" || \LC_MESSAGES.modifier |
                LC_MESSAGES.lang || "_" || \LC_MESSAGES.country |
                LC_MESSAGES.lang || "@" || \LC_MESSAGES.modifier |
                LC_MESSAGES.lang |
                &null)
   end

   private static unescape(s)
      local t, ch
      t := ""
      s ? {
         while t ||:= string(tab(upto('\\'))) do {
            move(1)
            t ||:= case ch := string(move(1)) of {
               "s": " "
               "t": "\t"
               "n": "\n"
               "r": "\r"
               default: ch
            }
         }
         return t || tab(0)
      }
   end

   # Note that this is more liberal than the desktop entry spec
   # indicates, since we want to parse the mimeapps.list file, which
   # has keys with chars outside &letters ++ &digits ++ '-'
   #
   private static parse_key_val(group)
      local key, val, enc, t
      key := trim(tab(upto('[='))) | fail
      if ="[" then {
         enc := string(tab(upto(']'))) | fail
         move(1)
         tab(many(' '))
      }
      ="=" | fail
      tab(many(' '))
      val := unescape(tab(0))
      (t := member(group, key)) | insert(group, key, t := table())
      insert(t, enc, val)
   end

   private static resolve_lc(group)
      local key, sel, t
      every key := default.key(group) do {
         t := member(group, key)
         if sel := member(t, !INI_LC_KEYS) then
            insert(group, key, sel)
         else
            # No matching locale (or fallback without locale), so
            # delete the key entirely.
            delete(group, key)
      }
   end

   private static parse_ini_file(s)
      local group, groups, gn, l
      groups := table()
      every l := separate_lines(s) do l ? {
         if pos(0) | match("#") then
            next
         if ="[" & gn := tab(upto(']')) then {
            group := table()
            insert(groups, gn, group)
         } else
            parse_key_val(\group)
      }
      every resolve_lc(!groups)
      return groups
   end

   public static load_ini_file(f)
      return parse_ini_file(ucs(Files.file_to_string(f)))
   end

   public static cache_icon(f, size, exact)
      # If it's an SVG file, then simply scale to the desired size and
      # return the key.
      return if endswith(f, ".svg" | ".svgz") then
         ImageCache.get_scaled_svg_key(f, size, size)
      else if /exact then
         ImageCache.get_key(f)
      else
         ImageCache.get_key_with_resize(f, size, size)
   end
end

#
# This class contains static methods for looking up XDG icon theme data.
#
final abstract class IconTheme()
   private static
      THEMES,             # A map of theme names (string) to ThemeIndex objects.
      FIND_ICON_CACHE,    # A cache of find_icon() results, mapping string key to icon
                          #   name (string)
      ICON_FALLBACK_CACHED_DIRS  # A list of CachedDir objects

   private static readable
      theme,
      scalable_flag

   private static init()
      refresh()
   end

   #
   # Reload all the settings and reset everything.
   #
   public static refresh()
      THEMES := table()
      FIND_ICON_CACHE := table()
      theme := get_current_theme()
      ICON_FALLBACK_CACHED_DIRS := setup_icon_fallback_cached_dirs()
      scalable_flag := &yes
   end

   #
   # Set the icon theme; fails if the theme is invalid.
   #
   public static set_theme(s)
      s := need_string(s)
      get_theme_index(s) | fail
      theme := s
      clear(FIND_ICON_CACHE)
      link
   end

   private static dir_set1(f)
      local s, res
      res := set()
      repeat {
         s := f.read_line() | fail
         if /s then
            return res
         insert(res, s)
      }
   end

   private static dir_set(dir)
      local f
      return use {
         f := DirStream(dir),
         dir_set1(f)
      }
   end

   private static gen_theme_directories(tm)
      suspend separate(member(member(tm, u"Icon Theme"), u"Directories"))
   end

   private static gen_theme_parents(tm)
      suspend string(separate(member(member(tm, u"Icon Theme"), u"Inherits")))
   end

   # Build a ThemeIndex object given the name and the ini table.
   private static build_theme_index(theme, tm)
      local d, subdir, f, dirs, ds, m, cd,
         type, size, minsize, maxsize, threshold
      dirs := []
      every subdir := gen_theme_directories(tm) do {
         if m := member(tm, subdir) &
            size := integer(member(m, u"Size")) then 
         {
            type := string(member(m, u"Type")) | "Threshold"
            threshold := integer(member(m, u"Threshold")) | 2
            minsize := integer(member(m, u"MinSize")) | size
            maxsize := integer(member(m, u"MaxSize")) | size
            cd := []
            every d := BaseDir.gen_data_dirs() do {
               f := FilePath(d).walk("icons", theme).append(FilePath(subdir))
               if ds := dir_set(f.str()) & *ds > 2 then
                  put(cd, CachedDir(f, ds))
            }
            if *cd > 0 then
               put(dirs, ThemeDirectory(type, size, minsize, maxsize, threshold, cd))
         }
      }
      return ThemeIndex(dirs, ipl.pdco.List{gen_theme_parents(tm)})
   end

   private static setup_icon_fallback_cached_dirs()
      local d, p, r, ds
      r := []
      every d := BaseDir.gen_data_dirs() do {
         p := FilePath(d).child("icons")
         if ds := dir_set(p.str()) & *ds > 2 then
            put(r, CachedDir(p, ds))
      }
      return r
   end

   private static get_theme_index1(name)
      local d, m
      every d := BaseDir.gen_data_dirs() do {
         if m := build_theme_index(name, Util.load_ini_file(FilePath(d).walk("icons", name, "index.theme").str())) then
            return m
      }
   end

   private static get_theme_index(name)
      local m
      if not(m := member(THEMES, name)) then {
         m := get_theme_index1(name)
         insert(THEMES, name, m)
      }
      return \m
   end

   #
   # Find an icon given the icon name (string) and integer size.
   #
   public static find_icon(icon, size)
      local k, v
      icon := need_string(icon)
      size := need_integer(size)
      k := icon || "/" || size
      if not(v := member(FIND_ICON_CACHE, k)) then {
         v := find_icon_helper(icon, size, theme, set()) | lookup_fallback_icon(icon)
         insert(FIND_ICON_CACHE, k, v)
      }
      return \v
   end

   #
   # This calls `find_icon`, caches the result in `ImageCache`, and
   # returns the cache key.  The parameter `exact` flag indicates
   # whether the found icon should be resized to exactly `size`.
   #
   public static find_icon_and_cache(icon, size, exact)
      return Util.cache_icon(find_icon(icon, size), size, exact)
   end

   private static get_current_theme()
      local f, theme, d
      every theme := env_string("OI_THEME") | "oxygen" | "gnome" do {
         every d := BaseDir.gen_data_dirs() do {
            f := FilePath(d).walk("icons", theme, "index.theme").str()
            if Files.access(f) then
               return theme
         }
      }
      return "hicolor"
   end

   private static find_icon_helper(icon, size, theme, tried)
      local theme_index
      if member(tried, theme) then
         fail
      insert(tried, theme)
      theme_index := get_theme_index(theme) | fail

      # Try this theme, failing that try recursively with the theme's parents.
      return lookup_icon(theme_index, icon, size) | 
         find_icon_helper(icon, size, !theme_index.parents, tried)
   end

   private static lookup_fallback_icon(icon)
      return has_icon(!ICON_FALLBACK_CACHED_DIRS, icon)
   end

   private static has_icon(cached_dir, icon)
      local ex, f
      if f := cached_dir.access(icon || ".png") then
         return f
      if \scalable_flag then {
         every ex := ".svg" | ".svgz" do {
            if f := cached_dir.access(icon || ex) then {
               # Try to load cairo; if fail then don't look for svg files again.
               if /Context.LOADED then {
                  scalable_flag := &null
                  fail
               }
               return f
            }
         }
      }
   end

   private static lookup_icon(theme_index, icon, size)
      local subdir, f, minimal_size, closest_filename, ms
      every subdir := !theme_index.directories do {
         if subdir.matches_size(size, scalable_flag) then {
            # Search in all the CachedDirs in the subdir
            if f := has_icon(!subdir.cached_dirs, icon) then
               return f
         }
      }
      minimal_size := lang.Limit.MaxWord
      every subdir := !theme_index.directories do {
         if (ms := subdir.directory_size_distance(size, scalable_flag)) < minimal_size then {
            if f := has_icon(!subdir.cached_dirs, icon) then {
               closest_filename := f
               minimal_size := ms
            }
         }
      }
      return \closest_filename
   end
end

#
# This class contains static methods for looking up XDG mime data.
#
final abstract class Mime()
   private static
      GLOBS,              # A Globs instance for file pattern matching.
      ICONS,              # A map of mime-type (string) to list of icon names (strings)
      GENERIC_ICONS,      #   - ditto -
      MIME_SUBCLASSES,    # A map of mime-type (string) to lists of mime-types (strings)
      MIME_ALIASES,       #   - ditto -
      MIME_ALTERNATIVES,  # A cache of alternative_mime_types() results,
                          #   mapping mime-type (string) to lists of mime-types (strings)
      DESKTOP_ENTRIES     # A map of mime-types (string) to list of DesktopEntry objects.

   private static init()
      refresh()
   end

   #
   # Reload all the settings and reset everything.
   #
   public static refresh()
      MIME_ALTERNATIVES := table()
      GLOBS := read_globs()
      ICONS := read_icons()
      GENERIC_ICONS := read_generic_icons()
      MIME_ALIASES := read_mime_aliases()
      MIME_SUBCLASSES := read_mime_subclasses()
      DESKTOP_ENTRIES := read_desktop_entries()
   end

   private static parse_glob_file(g, s)
      local weight, type, pattern, l
      every l := separate_lines(s) do l ? {
         if weight := integer(tab(upto(':'))) & 
            move(1) &
            type := string(tab(upto(':'))) &
            move(1) &
            pattern := tab(0) then 
         {
            g.add(pattern, weight, type)
         }
      }
   end

   private static need_mime_type(mt)
      return map(need_string(mt))
   end

   #
   # Given a filename (not a path), return the corresponding mime type.
   #
   public static get_mime_type_for_file(f)
      return GLOBS.lookup(f).mime_type
   end

   #
   # Generate the generic icons defined for the given mime type.
   #
   public static gen_generic_icons(mt)
      suspend .!member(GENERIC_ICONS, need_mime_type(mt))
   end

   #
   # Generate the icons defined for the given mime type.
   #
   public static gen_icons(mt)
      suspend .!member(ICONS, need_mime_type(mt))
   end

   #
   # Generate all the icons defined for the given mime type, namely
   # the default icon formed from substituting / for -; then the icons
   # and then the generic icons.
   #
   public static gen_all_icons(mt)
      mt := need_mime_type(mt)
      suspend map(mt, "/", "-") | .!member(ICONS | GENERIC_ICONS, mt)
   end

   #
   # Generate the alternative mime types for the given mime type.
   # This recursively traverses the subclasses and aliases and
   # generates all possible alternatives.
   #
   public static alternative_mime_types(mt)
      local l
      mt := need_string(mt)
      if not(l := member(MIME_ALTERNATIVES, mt)) then {
         l := []
         alternative_mime_types1(mt, l, set())
         insert(MIME_ALTERNATIVES, mt, l)
      }
      suspend !.l
   end

   private static alternative_mime_types1(mt, l, seen)
      local sub, mmt
      mmt := map(mt)
      if member(seen, mmt) then
         fail
      put(l, mt)
      insert(seen, mmt)
      every alternative_mime_types1(!member(MIME_ALIASES, mmt), l, seen)
      if sub := member(MIME_SUBCLASSES, mmt) then
         every alternative_mime_types1(!sub, l, seen)
      else if match("text/", mmt) then
         alternative_mime_types1("text/plain", l, seen)
      else if not match("inode/", mmt) then
         alternative_mime_types1("application/octet-stream", l, seen)
   end

   #
   # This calls `find_icon_for_file`, caches the result in
   # `ImageCache`, and returns the cache key.
   #
   # The `exact` parameter has the same effect as in
   # `find_icon_and_cache`.
   #
   public static find_icon_for_file_and_cache(file, size, exact)
      return Util.cache_icon(find_icon_for_file(file, size), size, exact)
   end

   private static read_generic_icons()
      local d, t, s, k, v, l
      t := table()
      every d := BaseDir.gen_data_dirs() do {
         if s := Files.file_to_string(FilePath(d).walk("mime", "generic-icons").str()) then {
            every l := separate_lines(s) do l ? {
               if k := map(tab(upto(':'))) &
                  move(1) &
                  v := tab(0) then
               {
                  inserts(t, k, v)
               }
            }
         }
      }
      return t
   end

   private static read_icons()
      local d, t, s, k, v, l
      t := table()
      every d := BaseDir.gen_data_dirs() do {
         if s := Files.file_to_string(FilePath(d).walk("mime", "icons").str()) then {
            every l := separate_lines(s) do l ? {
               if k := map(tab(upto(':'))) &
                  move(1) &
                  v := tab(0) then
               {
                  inserts(t, k, v)
               }
            }
         }
      }
      return t
   end

   private static read_mime_aliases()
      local d, t, s, k, v, l
      t := table()
      every d := BaseDir.gen_data_dirs() do {
         if s := Files.file_to_string(FilePath(d).walk("mime", "aliases").str()) then {
            every l := separate_lines(s) do l ? {
               if k := map(tab(upto(' '))) &
                  move(1) &
                  v := tab(0) then
               {
                  inserts(t, k, v)
               }
            }
         }
      }
      return t
   end

   private static read_mime_subclasses()
      local d, t, s, k, v, l
      t := table()
      every d := BaseDir.gen_data_dirs() do {
         if s := Files.file_to_string(FilePath(d).walk("mime", "subclasses").str()) then {
            every l := separate_lines(s) do l ? {
               if k := map(tab(upto(' '))) &
                  move(1) &
                  v := tab(0) then
               {
                  inserts(t, k, v)
               }
            }
         }
      }
      return t
   end

   private static read_globs()
      local d, g, s
      g := Globs()
      every d := Reverse{ BaseDir.gen_data_dirs() } do {
         if s := ucs(Files.file_to_string(FilePath(d).walk("mime", "globs2").str())) then
            parse_glob_file(g, s)
      }
      return g
   end

   #
   # Find an icon given a filename (not a path) and integer size.
   #
   public static find_icon_for_file(file, size)
      return IconTheme.find_icon(gen_all_icons(alternative_mime_types(get_mime_type_for_file(file))),
                                 size)
   end

   private static true_key(dm, key)
      succeed map(member(dm, key)) == "true"
   end

   private static build_desktop_entry(dm, src)
      local name, icon, exec, path, terminal, try_exec, 
         initial_preference, exec_line
      member(dm, u"Type") == "Application" | fail
      name := member(dm, u"Name") | fail

      # A TryExec entry means testing if such an exe is on the path;
      # if not ignore the entry
      if try_exec := member(dm, u"TryExec") then
         Files.find_exe(try_exec) | fail

      icon := string(member(dm, u"Icon"))
      exec := member(dm, u"Exec") | fail
      exec_line := member(dm, u"ExecLine")
      path := member(dm, u"Path")
      terminal := Yes{ true_key(dm, u"Terminal") }
      initial_preference := integer(member(dm, u"InitialPreference"))
      return DesktopEntry(name, icon, src, exec, exec_line, path, terminal, initial_preference)
   end

   private static gen_desktop_mime_types(dm)
      suspend "" ~== map(string(separate(member(dm, u"MimeType"), ';')))
   end

   private static scan_application_dir(p, prefix, t, u)
      local l, e, de, mt, dm, src, key
      l := Files.ucs_list(p.str()) | fail
      every e := !l do {
         if not(Files.is_hidden(e.name)) then {
            if e.stat.mode_str[1] == "d" then {
               scan_application_dir(p.child(e.name), prefix || e.name || "-", t, u)
            } else if endswith(e.name, ".desktop") then {
               key := prefix || e.name
               if (not member(t, key)) & 
                  src := p.child(e.name).str() &
                  dm := Util.load_ini_file(src) &
                  dm := member(dm, u"Desktop Entry")
               then {
                  # A Hidden entry adds a null entry to t, to mask any further
                  # occurrences of the key; it is deleted below after scanning
                  # is complete.
                  if true_key(dm, u"Hidden") then
                     insert(t, key, &null)
                  else if de := build_desktop_entry(dm, src) then {
                     insert(t, key, de)
                     every mt := gen_desktop_mime_types(dm) do
                        inserts(u, mt, de)
                  }
               }
            }
         }
      }
   end

   private static process_mimeapps_list(mm, t, u)
      local a, k, mime_type, l, d
      every a := member(mm, u"Added Associations" | u"Default Applications") do {
         # Each entry gives a mime type and list of desktop files, so
         # we look each one up in t.  The resulting list prepends to any
         # desktop entries there already.
         every k := key(a) do {
            mime_type := map(string(k))
            if l := member(u, mime_type) then {
               every d := Reverse{ member(t, separate(member(a, k), ';')) } do {
                  # Keep the list unique, by deleting the element (if present)
                  # we're about to push on the front.
                  delete(l, keyof(l, d))
                  push(l, d)
               }
            } else {
               insert(u, 
                      mime_type,
                      ipl.pdco.List{ member(t, separate(member(a, k), ';')) })
            }
         }
      }
      if a := member(mm, u"Removed Associations") then {
         # Each entry gives a mime type and list of desktop files to
         # remove from the corresponding list in u.
         every k := key(a) do {
            mime_type := map(string(k))
            if l := member(u, mime_type) then {
               # Lookup the DesktopEntry (in t) and then delete it from l.
               every d := member(t, separate(member(a, k), ';')) do
                  delete(l, keyof(l, d))
            }
         }
      }
   end

   private static prefcmp(d1, d2)
      local ip1, ip2
      ip1 := \d1.initial_preference | -1
      ip2 := \d2.initial_preference | -1
      return if ip1 = ip2 then d2.list_pos - d1.list_pos else ip2 - ip1
   end

   private static sort_by_preference(l)
      local e, i
      # Do nothing if they're all unset
      \ (!l).initial_preference | fail
      # The list_pos is used to maintain the original ordering if the
      # preferences for two entries are the same.
      i := *l
      every e := !l do {
         e.list_pos := i
         i -:= 1
      }
      qsort(l, prefcmp)
   end

   private static read_desktop_entries()
      local d, t, u, f, mm, k
      t := table()    # maps desktop entry names (ucs, eg u"kate.desktop") to DesktopEntry object
      u := table()    # mime-type (string) to list of DesktopEntry
      every d := BaseDir.gen_data_dirs() do
         scan_application_dir(FilePath(d).child("applications"), u"", t, u)

      # Delete hidden (null) entries from t
      every k := key(t) do {
         if /t[k] then
            delete(t, k)
      }

      # Sort each list of DesktopEntry by the initial preference field.
      every sort_by_preference(!u)

      # Process customisations from the mimeapps.lists files.
      every d := Reverse{ BaseDir.gen_data_dirs() } do {
         f := FilePath(d).walk("applications", "mimeapps.list").str()
         if mm := Util.load_ini_file(f) then
            process_mimeapps_list(mm, t, u)
      }

      return u
   end

   #
   # Given a file path (as a string), if the path represents an
   # existing directory, then the desktop entries for mime type
   # "inode/directory" are returned; otherwise
   # `gen_desktop_entries_for_file()` is called on the last path
   # component.
   #
   public static gen_desktop_entries_for_path(file)
      suspend if Files.is_directory(file) then
         gen_desktop_entries("inode/directory")
      else
         gen_desktop_entries_for_file(FilePath(file).get(-1))
   end

   #
   # Generate the `DesktopEntry` objects suitable for a particular
   # filename (without path), with the most suitable first.
   #
   public static gen_desktop_entries_for_file(file)
      suspend Unique{gen_desktop_entries(alternative_mime_types(get_mime_type_for_file(file)))}
   end

   #
   # Given a mime type (string), generate the corresponding `DesktopEntry` objects, in preference order.
   #
   public static gen_desktop_entries(mt)
      suspend .!member(DESKTOP_ENTRIES, need_mime_type(mt))
   end
end

#
# An entry in the `Globs` object.
#
package class GlobMatch()
   public const
      weight,      # The integer weight
      mime_type,   # The mime mime_type (string)
      pattern      # An optional wildcard pattern.

   public new(weight, mime_type, pattern)
      self.weight := weight
      self.mime_type := mime_type
      self.pattern := pattern
      return
   end
end

# A helper class used to store wildcard ("globbing") information
# associated with mime-types.
#
package class Globs()
   private const
      literal,
      simple,
      other

   public lookup(f)
      local i, v, fm
      need_text(f)
      f := ucs(f) | fail
      fm := map(f)
      if v := member(literal, f | fm) then
         return v
      every i := upto('.', f) do {
         if v := member(simple, (f | fm)[i + 1:0]) then
            return v
      }
      every v := !other do {
         if v.pattern.match_all(f | fm) then
            return v
      }
   end

   #
   # Add an entry.  p is the pattern (ucs), weight an integer and mime_type
   # the mime type (string).
   #
   public add(p, weight, mime_type)
      local x, t, k
      if p == "__NOGLOBS__" then {
         every t := literal | simple | other do {
            every k := key(t) do {
               if Text.caseless_compare(t[k].mime_type, mime_type) = 0 then
                  delete(t, k)
            }
         }
      } else if upto('*?[', p) then {
         if match("*.", p) & not upto('*?[', p[3:0]) then {
            p := p[3:0]
            x := member(simple, p)
            if /x | (weight > x.weight) then
               insert(simple, p, GlobMatch(weight, mime_type))
         } else {
            x := member(other, p)
            if /x | (weight > x.weight) then
               insert(other, p, GlobMatch(weight, mime_type, Wildcard(p)))
         }
      } else {
         x := member(literal, p)
         if /x | (weight > x.weight) then
            insert(literal, p, GlobMatch(weight, mime_type))
      }
      link
   end

   public new()
      literal := table()
      simple := table()
      other := table()
      return
   end
end
