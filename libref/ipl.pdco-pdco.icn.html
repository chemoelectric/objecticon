<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>pdco.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     pdco.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures for programmer-defined control operations
<a name="6"/>#
<a name="7"/>#	Authors:  Ralph E. Griswold and Robert J. Alexander
<a name="8"/>#
<a name="9"/>#	Date:     June 10, 2001
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>
<a name="17"/>package ipl.pdco
<a name="18"/>
<a name="19"/>import
<a name="20"/>   io(RamStream),
<a name="21"/>   ipl.lists(lmap, lrotate),
<a name="22"/>   ipl.numbers(mod1),
<a name="23"/>   ipl.periodic(repeater),
<a name="24"/>   ipl.sort(need_callable_def),
<a name="25"/>   datastruct(EqSet),
<a name="26"/>   numbers(Rat),
<a name="27"/>   lang(equals),
<a name="28"/>   util(save_state, HandlerState, ce_param, need_integer,
<a name="29"/>        need_ucs, use, need_text, need_callable, same_string_type,
<a name="30"/>        need_numeric)
<a name="31"/>
<a name="32"/># Adds tabby to treadling sequence
<a name="33"/>procedure AddTabby(e, i)	
<a name="34"/>   /i :=  4	# number of regular treadles
<a name="35"/>
<a name="36"/>   suspend Inter![e, create |((i + 1) | (i + 2))]
<a name="37"/>
<a name="38"/>end
<a name="39"/>
<a name="40"/># Parallel evaluation with last result used for short sequences
<a name="41"/>procedure Allpar(L[])	
<a name="42"/>   local i, L1, done
<a name="43"/>
<a name="44"/>   if *L = 0 then fail
<a name="45"/>
<a name="46"/>   L1 := list(*L)
<a name="47"/>
<a name="48"/>   done := list(*L, &amp;no)
<a name="49"/>
<a name="50"/>   every i := 1 to *L do L1[i] := @L[i] | fail
<a name="51"/>
<a name="52"/>   repeat {
<a name="53"/>      suspend L1
<a name="54"/>      every i := 1 to *L do
<a name="55"/>         if /done[i] &amp; not( L1[i] := @L[i] ) then {
<a name="56"/>            done[i] := &amp;yes
<a name="57"/>            /!done | fail
<a name="58"/>            }
<a name="59"/>      }
<a name="60"/>
<a name="61"/>end
<a name="62"/>
<a name="63"/># PDCO to model alternation
<a name="64"/>procedure Alt(e[])	
<a name="65"/>   local x
<a name="66"/>   every x := !e do
<a name="67"/>      suspend |@x
<a name="68"/>
<a name="69"/>end
<a name="70"/>
<a name="71"/># Produce sequence of approximations for the continued-fraction
<a name="72"/># sequence e
<a name="73"/>procedure CFapprox(e)	
<a name="74"/>  local prev_n, prev_m, n, m, t
<a name="75"/>
<a name="76"/>  prev_n := [1]
<a name="77"/>  prev_m := [0, 1]
<a name="78"/>
<a name="79"/>  put(prev_n, (@e).d) | fail
<a name="80"/>
<a name="81"/>  while t := @e do {
<a name="82"/>     n := t.d * get(prev_n) + t.n * prev_n[1]
<a name="83"/>     m := t.d * get(prev_m) + t.n * prev_m[1]
<a name="84"/>     suspend Rat(n, m)
<a name="85"/>     put(prev_n, n)
<a name="86"/>     put(prev_m, m)
<a name="87"/>     if t.d ~= 0 then {		# renormalize
<a name="88"/>        every !prev_n /:= t.d
<a name="89"/>        every !prev_m /:= t.d
<a name="90"/>        }
<a name="91"/>     }
<a name="92"/>
<a name="93"/>end
<a name="94"/>
<a name="95"/># PDCO to compare result sequences of e1 and e2
<a name="96"/>procedure Compare(e1, e2)	
<a name="97"/>   local x1
<a name="98"/>
<a name="99"/>   while x1 := @e1 do
<a name="100"/>      (x1 === @e2) | fail
<a name="101"/>   return not @e2
<a name="102"/>
<a name="103"/>end
<a name="104"/>
<a name="105"/># This is like `Compare` above, but uses `lang.equals()`, as opposed to
<a name="106"/># `===`, for comparison.
<a name="107"/>#
<a name="108"/>procedure CompareEq(e1, e2)	
<a name="109"/>   local x1
<a name="110"/>
<a name="111"/>   while x1 := @e1 do
<a name="112"/>      equals(x1,  @e2) | fail
<a name="113"/>   return not @e2
<a name="114"/>
<a name="115"/>end
<a name="116"/>
<a name="117"/>
<a name="118"/># PDCO to generate integers not in sequence
<a name="119"/>procedure Complint(e)	
<a name="120"/>   local i, j			# EXPECTS MONOTONE NON-DECREASING SEQUENCE
<a name="121"/>
<a name="122"/>   j := 0
<a name="123"/>
<a name="124"/>   while i := need_integer(@e) do {
<a name="125"/>      suspend j to i - 1
<a name="126"/>      j := i + 1
<a name="127"/>      }
<a name="128"/>
<a name="129"/>   suspend seq(j)
<a name="130"/>
<a name="131"/>end
<a name="132"/>
<a name="133"/># PDCO for generalized Lisp conditional
<a name="134"/>procedure Cond(L[])	
<a name="135"/>   local i, x
<a name="136"/>
<a name="137"/>   every i := 1 to *L do
<a name="138"/>      if x := @L[i] then {
<a name="139"/>         suspend x
<a name="140"/>         suspend |@L[i]
<a name="141"/>         fail
<a name="142"/>         }
<a name="143"/>
<a name="144"/>end
<a name="145"/>
<a name="146"/># PDCO to generate the cumulative sum of the terms of e
<a name="147"/>procedure Cumsum(e)		
<a name="148"/>   local i
<a name="149"/>
<a name="150"/>   i := 0
<a name="151"/>
<a name="152"/>   while i +:= @e do
<a name="153"/>      suspend i
<a name="154"/>
<a name="155"/>end
<a name="156"/>
<a name="157"/># PDCO to produce sum
<a name="158"/>procedure Sum(e)		
<a name="159"/>   local i
<a name="160"/>
<a name="161"/>   i := 0
<a name="162"/>
<a name="163"/>   while i +:= @e
<a name="164"/>
<a name="165"/>   return i
<a name="166"/>end
<a name="167"/>
<a name="168"/># PDCO to produce product
<a name="169"/>procedure Product(e)		
<a name="170"/>   local i
<a name="171"/>
<a name="172"/>   i := 1
<a name="173"/>
<a name="174"/>   while i *:= @e
<a name="175"/>
<a name="176"/>   return i
<a name="177"/>end
<a name="178"/>
<a name="179"/># PDCO to generate the cumulative product of the terms of e
<a name="180"/>procedure Cumproduct(e)		
<a name="181"/>   local i
<a name="182"/>
<a name="183"/>   i := 1
<a name="184"/>
<a name="185"/>   while i *:= @e do
<a name="186"/>      suspend i
<a name="187"/>
<a name="188"/>end
<a name="189"/>
<a name="190"/># Parallel evaluation with shorter sequences re-evaluated
<a name="191"/>procedure Cyclepar(L[])	
<a name="192"/>   local i, L1, done
<a name="193"/>
<a name="194"/>   if *L = 0 then fail
<a name="195"/>
<a name="196"/>   L1 := list(*L)
<a name="197"/>
<a name="198"/>   done := list(*L, &amp;no)
<a name="199"/>
<a name="200"/>   every i := 1 to *L do L1[i] := @L[i] | fail
<a name="201"/>
<a name="202"/>   repeat {
<a name="203"/>      suspend L1
<a name="204"/>      every i := 1 to *L do {
<a name="205"/>         unless L1[i] := @L[i] then {
<a name="206"/>            done[i] := &amp;yes
<a name="207"/>            /!done | fail
<a name="208"/>            L[i] := ^L[i]
<a name="209"/>            L1[i] := @L[i] | fail
<a name="210"/>            }
<a name="211"/>         }
<a name="212"/>      }
<a name="213"/>end
<a name="214"/>
<a name="215"/># "Decimate" e1 by deleting e2-numbered terms (e2 is assumed to be an
<a name="216"/># increasing sequence).  See also `Index`.
<a name="217"/>procedure Decimate(e1, e2)	
<a name="218"/>   local j, count
<a name="219"/>
<a name="220"/>   count := 0
<a name="221"/>
<a name="222"/>   every j := IncreasingFrom(1, e2) do {
<a name="223"/>      every count to j - 2 do
<a name="224"/>         suspend (@e1 | fail)\1
<a name="225"/>      @e1 | fail
<a name="226"/>      count := j
<a name="227"/>      }
<a name="228"/>
<a name="229"/>   suspend |@e1
<a name="230"/>end
<a name="231"/>
<a name="232"/># Produce a decimation sequence from e1 by deleting even-valued terms
<a name="233"/># and replacing odd-valued terms by their position.
<a name="234"/>procedure Decimation(e)	
<a name="235"/>   local i, count
<a name="236"/>
<a name="237"/>   count := 0
<a name="238"/>
<a name="239"/>   while i := need_integer(@e) do {
<a name="240"/>      count +:= 1
<a name="241"/>      if i % 2 = 1 then suspend count
<a name="242"/>      }
<a name="243"/>
<a name="244"/>end
<a name="245"/>
<a name="246"/># PDCO to decollate e according to parity of i
<a name="247"/>procedure Decollate(e, i)	
<a name="248"/>   local j, x
<a name="249"/>
<a name="250"/>   i := ce_param(i) | fail
<a name="251"/>   i := need_integer(\i) | 1
<a name="252"/>
<a name="253"/>   i %:= 2
<a name="254"/> 
<a name="255"/>   j := 0
<a name="256"/>
<a name="257"/>   while x := @e do {
<a name="258"/>      j +:= 1
<a name="259"/>      if j % 2 = i then suspend x
<a name="260"/>      }
<a name="261"/>
<a name="262"/>end
<a name="263"/>
<a name="264"/># PDCO producing the difference of the values in e
<a name="265"/>procedure Delta(e)	
<a name="266"/>   local i, j
<a name="267"/>
<a name="268"/>   i := need_numeric(@e) | fail
<a name="269"/>
<a name="270"/>   while j := need_numeric(@e) do {
<a name="271"/>      suspend j - i
<a name="272"/>      i := j
<a name="273"/>      }
<a name="274"/>
<a name="275"/>end
<a name="276"/>
<a name="277"/># PDCO to elevate e1 mod n to n values.
<a name="278"/>procedure Elevate(e1, m, n)	
<a name="279"/>   local shafts, i, j, k
<a name="280"/>
<a name="281"/>   m := need_integer(ce_param(m)) | fail
<a name="282"/>   n := need_integer(ce_param(n)) | fail
<a name="283"/>
<a name="284"/>   shafts := list(m)
<a name="285"/>
<a name="286"/>   every !shafts := []
<a name="287"/>
<a name="288"/>   every i := 1 to m do
<a name="289"/>      every put(shafts[i], i to n by m)
<a name="290"/>
<a name="291"/>   while j := @e1 do {
<a name="292"/>      i := j % m + 1
<a name="293"/>      k := get(shafts[i])
<a name="294"/>      suspend k
<a name="295"/>      put(shafts[i], k)
<a name="296"/>      }
<a name="297"/>
<a name="298"/>end
<a name="299"/>
<a name="300"/># PDCO to model `every e1 do e2`
<a name="301"/>procedure Every(e1, e2)	
<a name="302"/>
<a name="303"/>   while @e1 do @^e2
<a name="304"/>
<a name="305"/>end
<a name="306"/>
<a name="307"/># Evaluate `e1` and for each result, evaluate `e2`, failing should it
<a name="308"/># fail.  Succeed when `e1` is exhausted (and hence each evaluation of
<a name="309"/># `e2` succeeded).
<a name="310"/>#
<a name="311"/># Examples :-
<a name="312"/># ~
<a name="313"/>#    # Are the characters in string s in ascending
<a name="314"/>#    # lexicographic order?
<a name="315"/>#    if All{ i := 1 to *s - 1,
<a name="316"/>#            s[i] &lt;&lt;= s[i + 1] }
<a name="317"/>#    then write("Yes")
<a name="318"/>#
<a name="319"/>#    # Are all the elements of list l positive?
<a name="320"/>#    if All{ e := !l, e &gt; 0 }
<a name="321"/>#    then write("Yes")
<a name="322"/># ~
<a name="323"/>procedure All(e1, e2)
<a name="324"/>   while @e1 do @^e2 | fail
<a name="325"/>   return
<a name="326"/>end
<a name="327"/>
<a name="328"/># PDCO to extend `e` to `count` results
<a name="329"/>procedure ExtendSeq(e, count)	
<a name="330"/>   local fl
<a name="331"/>
<a name="332"/>   count := need_integer(ce_param(count)) | fail
<a name="333"/>   if count &lt; 1 then fail
<a name="334"/>
<a name="335"/>   repeat {
<a name="336"/>      suspend |@e do {
<a name="337"/>         count -:= 1
<a name="338"/>         if count = 0 then fail
<a name="339"/>         fl := &amp;yes
<a name="340"/>         }
<a name="341"/>      if /fl then fail
<a name="342"/>      e := ^e
<a name="343"/>      fl := &amp;no
<a name="344"/>      }
<a name="345"/>
<a name="346"/>end
<a name="347"/>
<a name="348"/># Extract results of even-numbered arguments according to odd-numbered
<a name="349"/># values.
<a name="350"/>procedure Extract(L[])	
<a name="351"/>   local i, n, L1
<a name="352"/>
<a name="353"/>   L1 := list(*L/2)
<a name="354"/>
<a name="355"/>   repeat {
<a name="356"/>      i := 1
<a name="357"/>      while i &lt; *L do {
<a name="358"/>         n := @L[i] | fail
<a name="359"/>         every 1 to n do
<a name="360"/>            L1[(i + 1)/2] := @L[i + 1] | fail
<a name="361"/>         L[i + 1] := ^L[i + 1]
<a name="362"/>         i +:= 2
<a name="363"/>         }
<a name="364"/>      suspend L1
<a name="365"/>      } 
<a name="366"/>
<a name="367"/>end
<a name="368"/>
<a name="369"/># Reversal of `Lifo` evaluation
<a name="370"/>procedure Fifo(L[])	
<a name="371"/>   local L1, j
<a name="372"/>
<a name="373"/>   L1 := list(*L)
<a name="374"/>
<a name="375"/>   j := *L
<a name="376"/>
<a name="377"/>   repeat {
<a name="378"/>      if L1[j] := @L[j] then {
<a name="379"/>         if j = 1 then
<a name="380"/>            suspend L1
<a name="381"/>         else
<a name="382"/>            j -:= 1
<a name="383"/>      } else {
<a name="384"/>         if j = *L then fail
<a name="385"/>         L[j] := ^L[j]
<a name="386"/>         j +:= 1
<a name="387"/>      }
<a name="388"/>   }
<a name="389"/>end
<a name="390"/>
<a name="391"/># PDCO for friendly sequence starting at `state` shaft mod `mod`
<a name="392"/>procedure Friendly(mod, state, e)	
<a name="393"/>   local value
<a name="394"/>
<a name="395"/>   mod := ce_param(mod) | fail
<a name="396"/>   state := ce_param(state) | fail
<a name="397"/>
<a name="398"/>   mod := need_integer(mod)
<a name="399"/>   state := need_integer(\state) | ?mod
<a name="400"/>
<a name="401"/>   repeat {
<a name="402"/>      suspend state
<a name="403"/>      value := @e | fail
<a name="404"/>      if value % 2 = 0 then state +:= 1
<a name="405"/>      else state -:= 1
<a name="406"/>      state := mod1(state, mod)
<a name="407"/>      }
<a name="408"/>
<a name="409"/>end
<a name="410"/>
<a name="411"/># PDCO to produces the result of concatenating the
<a name="412"/># sequences for `L[1], L[2], ...`
<a name="413"/>procedure Galt(L[])		
<a name="414"/>   local C
<a name="415"/>
<a name="416"/>   every C := !L do
<a name="417"/>      suspend |@C
<a name="418"/>
<a name="419"/>end
<a name="420"/>
<a name="421"/># PDCO to model generalized conjunction: `L[1] &amp; L[2] &amp; ...`
<a name="422"/>procedure Gconj(L[])	
<a name="423"/>   local v, j
<a name="424"/>
<a name="425"/>   j := 1
<a name="426"/>
<a name="427"/>   repeat {
<a name="428"/>      if v := @L[j] then {
<a name="429"/>         if j = *L then
<a name="430"/>            suspend v
<a name="431"/>         else
<a name="432"/>            j +:= 1
<a name="433"/>      } else {
<a name="434"/>         if j = 1 then fail
<a name="435"/>         L[j] := ^L[j]
<a name="436"/>         j -:= 1
<a name="437"/>      }
<a name="438"/>   }
<a name="439"/>end
<a name="440"/>
<a name="441"/># Generates histogram for `e1`
<a name="442"/>procedure Histo(e1)		
<a name="443"/>   local results, seq
<a name="444"/>
<a name="445"/>   seq := []
<a name="446"/>
<a name="447"/>   while put(seq, @e1)
<a name="448"/>
<a name="449"/>   results := list(max ! seq, 0)
<a name="450"/>
<a name="451"/>   every results[!seq] +:= 1
<a name="452"/>
<a name="453"/>   suspend !results
<a name="454"/>
<a name="455"/>end
<a name="456"/>
<a name="457"/>#
<a name="458"/># Return a frequency table, counting the distinct results generated by
<a name="459"/># `e`.
<a name="460"/>#
<a name="461"/>procedure Freq(e)
<a name="462"/>   local t
<a name="463"/>   t := table(0)
<a name="464"/>   while t[@e] +:= 1
<a name="465"/>   return t
<a name="466"/>end
<a name="467"/>
<a name="468"/># PDCO to filter out non-increasing values in integer sequence
<a name="469"/>procedure Increasing(e)	
<a name="470"/>   local last, current
<a name="471"/>
<a name="472"/>   last := need_integer(@e) | fail
<a name="473"/>
<a name="474"/>   suspend last
<a name="475"/>
<a name="476"/>   while current := need_integer(@e) do {
<a name="477"/>      if current &gt; last then {
<a name="478"/>         suspend current
<a name="479"/>         last := current
<a name="480"/>         }
<a name="481"/>      }
<a name="482"/>
<a name="483"/>end
<a name="484"/>
<a name="485"/># Like `Increasing`, but an initial value is provided; any values less
<a name="486"/># than `last` are removed from the beginning of `e`.
<a name="487"/>procedure IncreasingFrom(last, e)	
<a name="488"/>   local current
<a name="489"/>
<a name="490"/>   last := need_integer(ce_param(last)) - 1 | fail
<a name="491"/>
<a name="492"/>   while current := need_integer(@e) do {
<a name="493"/>      if current &gt; last then {
<a name="494"/>         suspend current
<a name="495"/>         last := current
<a name="496"/>         }
<a name="497"/>      }
<a name="498"/>
<a name="499"/>end
<a name="500"/>
<a name="501"/>
<a name="502"/># PDCO to produce `e2`-th terms from `e1`.  `e2` should generate
<a name="503"/># ascending indices.  See also `Decimate`.
<a name="504"/>procedure Index(e1, e2)		
<a name="505"/>   local j, count
<a name="506"/>
<a name="507"/>   count := 0
<a name="508"/>
<a name="509"/>   every j := IncreasingFrom(1, e2) do {
<a name="510"/>      every count to j - 2 do
<a name="511"/>         @e1 | fail
<a name="512"/>      suspend (@e1 | fail)\1
<a name="513"/>      count := j
<a name="514"/>      }
<a name="515"/>
<a name="516"/>end
<a name="517"/>
<a name="518"/># PDCO to produce results of `L[1], L[2], ...` alternately
<a name="519"/>procedure Inter(L[])	
<a name="520"/>
<a name="521"/>   suspend |@!L
<a name="522"/>
<a name="523"/>end
<a name="524"/>
<a name="525"/># PDCO to model the Lisp conditional
<a name="526"/>procedure Lcond(L[])	
<a name="527"/>   local i
<a name="528"/>
<a name="529"/>   every i := 1 to *L by 2 do
<a name="530"/>      if @L[i] then {
<a name="531"/>         suspend |@L[i + 1]
<a name="532"/>         fail
<a name="533"/>         }
<a name="534"/>
<a name="535"/>end
<a name="536"/>
<a name="537"/># PDCO to produce length of sequence `e`.
<a name="538"/>procedure Length(e)	
<a name="539"/>   local i
<a name="540"/>
<a name="541"/>   i := 0
<a name="542"/>
<a name="543"/>   while @e do i +:= 1
<a name="544"/>
<a name="545"/>   return i
<a name="546"/>
<a name="547"/>end
<a name="548"/>
<a name="549"/># Generate the results from the several expressions in the same
<a name="550"/># left-to-right order as in normal icon evaluation.
<a name="551"/># 
<a name="552"/># For example `Lifo{1 to 3, !"ab"}` generates [1,"a"], [1,"b"], [2,
<a name="553"/># "a"] etc.
<a name="554"/>#
<a name="555"/># Note that the same list instance is suspended each time, and should
<a name="556"/># not be altered.
<a name="557"/>#
<a name="558"/>procedure Lifo(L[])	
<a name="559"/>   local L1, j
<a name="560"/>
<a name="561"/>   L1 := list(*L)
<a name="562"/>
<a name="563"/>   j := 1
<a name="564"/>
<a name="565"/>   repeat {
<a name="566"/>      if L1[j] := @L[j] then {
<a name="567"/>         if j = *L then
<a name="568"/>            suspend L1
<a name="569"/>         else
<a name="570"/>            j +:= 1
<a name="571"/>      } else {
<a name="572"/>         if j = 1 then fail
<a name="573"/>         L[j] := ^L[j]
<a name="574"/>         j -:= 1
<a name="575"/>      }
<a name="576"/>   }
<a name="577"/>end
<a name="578"/>
<a name="579"/># PDCO to model the limitation expression, `e1 \ e2`.
<a name="580"/>procedure Limit(e1, e2)	
<a name="581"/>   local i, x
<a name="582"/>
<a name="583"/>   while i := need_integer(@e2, 0) do {
<a name="584"/>      every 1 to i do
<a name="585"/>         if x := @e1 then suspend x
<a name="586"/>         else break
<a name="587"/>      e1 := ^e1
<a name="588"/>      }
<a name="589"/>
<a name="590"/>end
<a name="591"/>
<a name="592"/>#
<a name="593"/># Create a list from the result sequence of the given co-expression.
<a name="594"/>#
<a name="595"/># For example :-
<a name="596"/># ~
<a name="597"/>#     List{(e := 0 to 9, e * e)}
<a name="598"/># ~
<a name="599"/># produces the list
<a name="600"/># ~
<a name="601"/>#     [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
<a name="602"/># ~
<a name="603"/>procedure List(e)		
<a name="604"/>   local t
<a name="605"/>   t := []
<a name="606"/>   while put(t, @e)
<a name="607"/>   return t
<a name="608"/>end
<a name="609"/>
<a name="610"/>#
<a name="611"/># Create a set from the result sequence of the given co-expression.
<a name="612"/>#
<a name="613"/># For example :-
<a name="614"/># ~
<a name="615"/>#    Set{(e := 0 to 9, e * e)}
<a name="616"/># ~
<a name="617"/># produces the set
<a name="618"/># ~
<a name="619"/>#    {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}
<a name="620"/># ~
<a name="621"/>procedure Set(e)		
<a name="622"/>   local t
<a name="623"/>   t := set()
<a name="624"/>   while insert(t, @e)
<a name="625"/>   return t
<a name="626"/>end
<a name="627"/>
<a name="628"/>
<a name="629"/># Construct a table from a result sequence.  The expression `e` should
<a name="630"/># produce 2-element lists (or records) representing key-value pairs to
<a name="631"/># add to the table.
<a name="632"/>#
<a name="633"/># An optional second parameter provides a default value for the table.
<a name="634"/>#
<a name="635"/># For example :-
<a name="636"/># ~
<a name="637"/>#    Table{(i := 1 to 4, [i, i * i])}
<a name="638"/># ~
<a name="639"/># produces the table
<a name="640"/># ~
<a name="641"/>#    {1-&gt;1, 2-&gt;4, 3-&gt;9, 4-&gt;16}
<a name="642"/># ~
<a name="643"/>procedure Table(e, def)
<a name="644"/>   local t, x
<a name="645"/>   t := table(ce_param(def)) | fail
<a name="646"/>   while x := @e do
<a name="647"/>      insert(t, x[1], x[2])
<a name="648"/>   return t
<a name="649"/>end
<a name="650"/>
<a name="651"/>#
<a name="652"/># Build a string from the results of the co-expression `e`, separated
<a name="653"/># by the string `sep` (default "").  If `sep` is ucs, or any of the
<a name="654"/># results of `e` are `ucs`, then the result is `ucs`, otherwise it is
<a name="655"/># a string.
<a name="656"/>#
<a name="657"/># Note that for some use cases, `String2` below may be much faster
<a name="658"/># than this procedure.
<a name="659"/>#
<a name="660"/>procedure String(e, sep)
<a name="661"/>   local s
<a name="662"/>   sep := ce_param(sep) | fail
<a name="663"/>   if /sep then {
<a name="664"/>      s := ""
<a name="665"/>      while s ||:= @e
<a name="666"/>   } else {
<a name="667"/>      sep := need_text(sep)
<a name="668"/>      # Ensure result is same type as sep, even if the sequence is empty.
<a name="669"/>      s := sep[1:1]
<a name="670"/>      while s ||:= @e || sep
<a name="671"/>      # Ensure that -*sep below is correct
<a name="672"/>      sep := same_string_type(sep, s)
<a name="673"/>      s[-*sep:0] := ""
<a name="674"/>   }
<a name="675"/>   return s
<a name="676"/>end
<a name="677"/>
<a name="678"/>#
<a name="679"/># This is an alternative to `String`, which may be preferable in one
<a name="680"/># of two situations.  Firstly, if any of the elements (or the
<a name="681"/># separator) are `ucs` strings, or secondly if generating the elements
<a name="682"/># involves separate string allocations.  Both can lead to excessive
<a name="683"/># allocations, and hence garbage collections.  This procedure avoids
<a name="684"/># those allocations by using an intermediate `RamStream` buffer to
<a name="685"/># generate the result.
<a name="686"/>#
<a name="687"/># This procedure has two minor limitations; firstly, it cannot process
<a name="688"/># non-8-bit csets generated by `e` (they will generate a runtime
<a name="689"/># error); secondly it should not be used with `util.clean` if any
<a name="690"/># activation of `e` might not return (eg because of an exception).
<a name="691"/># `String3` below addresses these limitations, at a performance cost.
<a name="692"/>#
<a name="693"/>procedure String2(e, sep)
<a name="694"/>   local t, f, rs, s
<a name="695"/>   sep := ce_param(sep) | fail
<a name="696"/>   rs := RamStream()
<a name="697"/>   if /sep then {
<a name="698"/>      while t := @e do {
<a name="699"/>         if /f &amp; type(t) == "ucs" then f := &amp;yes
<a name="700"/>         rs.out(t)
<a name="701"/>      }
<a name="702"/>      s := rs.done()
<a name="703"/>   } else {
<a name="704"/>      sep := need_text(sep)
<a name="705"/>      if type(sep) == "ucs" then {
<a name="706"/>         f := &amp;yes
<a name="707"/>         sep := string(sep)
<a name="708"/>      }
<a name="709"/>      while t := @e do {
<a name="710"/>         if /f &amp; type(t) == "ucs" then f := &amp;yes
<a name="711"/>         rs.out(t); rs.out(sep)
<a name="712"/>      }
<a name="713"/>      s := rs.done()
<a name="714"/>      s[-*sep:0] := ""
<a name="715"/>   }
<a name="716"/>   return if /f then s else need_ucs(s)
<a name="717"/>end
<a name="718"/>
<a name="719"/>#
<a name="720"/># This is like `String2`, but addresses the limitations described.
<a name="721"/>#
<a name="722"/>procedure String3(e, sep)
<a name="723"/>   local t, f, rs, s
<a name="724"/>   sep := ce_param(sep) | fail
<a name="725"/>   use {
<a name="726"/>      rs := RamStream(),
<a name="727"/>      {
<a name="728"/>         if /sep then {
<a name="729"/>            while t := need_text(@e) do {
<a name="730"/>               if /f &amp; type(t) == "ucs" then f := &amp;yes
<a name="731"/>               rs.out(t)
<a name="732"/>            }
<a name="733"/>            s := rs.str()
<a name="734"/>         } else {
<a name="735"/>            sep := need_text(sep)
<a name="736"/>            if type(sep) == "ucs" then {
<a name="737"/>               f := &amp;yes
<a name="738"/>               sep := string(sep)
<a name="739"/>            }
<a name="740"/>            while t := need_text(@e) do {
<a name="741"/>               if /f &amp; type(t) == "ucs" then f := &amp;yes
<a name="742"/>               rs.out(t); rs.out(sep)
<a name="743"/>            }
<a name="744"/>            s := rs.str()
<a name="745"/>            s[-*sep:0] := ""
<a name="746"/>         }
<a name="747"/>      }
<a name="748"/>   }
<a name="749"/>   return if /f then s else need_ucs(s)
<a name="750"/>end
<a name="751"/>
<a name="752"/># Lower trimming
<a name="753"/>procedure LowerTrim(e)	
<a name="754"/>   local i
<a name="755"/>
<a name="756"/>   while i := @e do {
<a name="757"/>      i -:= 1
<a name="758"/>      if i ~= 0 then suspend i
<a name="759"/>      }
<a name="760"/>
<a name="761"/>end
<a name="762"/>
<a name="763"/># PDCO to map values of `e1` in the order they first appear to values of `e2` (as needed)
<a name="764"/>procedure Map(e1, e2)		
<a name="765"/>   local maptbl, x
<a name="766"/>
<a name="767"/>   maptbl := table()
<a name="768"/>
<a name="769"/>   while x := @e1 do {
<a name="770"/>      /maptbl[x] := (@e2 | fail)
<a name="771"/>      suspend maptbl[x]
<a name="772"/>      }
<a name="773"/>
<a name="774"/>end
<a name="775"/>
<a name="776"/># PDCO to force odd/even sequence
<a name="777"/>procedure OddEven(e)	
<a name="778"/>   local val, val_old
<a name="779"/>
<a name="780"/>   while val := @e do {
<a name="781"/>      if val % 2 = \val_old % 2 then
<a name="782"/>         suspend val_old + 1
<a name="783"/>      suspend val
<a name="784"/>      val_old := val
<a name="785"/>      }
<a name="786"/>
<a name="787"/>end
<a name="788"/>
<a name="789"/># PDCO to produce results of concatenating the sequence for `e` and
<a name="790"/># then its reverse.
<a name="791"/>procedure Palin(e)	
<a name="792"/>   local tail, x
<a name="793"/>
<a name="794"/>   tail := []
<a name="795"/>
<a name="796"/>   while x := @e do {
<a name="797"/>      suspend x
<a name="798"/>      push(tail, x)
<a name="799"/>      } 
<a name="800"/>
<a name="801"/>   suspend !tail
<a name="802"/>
<a name="803"/>end
<a name="804"/>
<a name="805"/>
<a name="806"/># Parallel evaluation terminating on shortest sequence.
<a name="807"/>procedure Parallel(L[])	
<a name="808"/>   local i, L1
<a name="809"/>
<a name="810"/>   L1 := list(*L)
<a name="811"/>
<a name="812"/>   repeat {
<a name="813"/>      every i := 1 to *L do
<a name="814"/>         L1[i] := @L[i] | fail
<a name="815"/>      suspend L1
<a name="816"/>      }
<a name="817"/>
<a name="818"/>end
<a name="819"/>
<a name="820"/># PDCO to produce pattern palindrome
<a name="821"/>procedure PatternPalin(e)	
<a name="822"/>   local tail, x
<a name="823"/>
<a name="824"/>   tail := []
<a name="825"/>   while x := @e do {
<a name="826"/>      suspend x
<a name="827"/>      push(tail, x)
<a name="828"/>   }
<a name="829"/>
<a name="830"/>   get(tail)
<a name="831"/>
<a name="832"/>   pull(tail)
<a name="833"/>
<a name="834"/>   suspend !tail
<a name="835"/>
<a name="836"/>end
<a name="837"/>
<a name="838"/># PDCO to generate the periodic part of `e`; `limit` values (default
<a name="839"/># 300) are used to find the period.
<a name="840"/>procedure Period(e, limit)		
<a name="841"/>   local result
<a name="842"/>
<a name="843"/>   limit := ce_param(limit) | fail
<a name="844"/>   limit := need_integer(\limit) | 300
<a name="845"/>
<a name="846"/>   result := []
<a name="847"/>
<a name="848"/>   every put(result, |@e) \ limit
<a name="849"/>
<a name="850"/>   result := repeater(result)
<a name="851"/>
<a name="852"/>   suspend !result[2]
<a name="853"/>
<a name="854"/>end
<a name="855"/>
<a name="856"/># This PDCO permutes each n-subsequence of `e1` by the n positional
<a name="857"/># values in lists from `e2`.  If a list does not consist of all the
<a name="858"/># integers in the range 1 to n, "interesting" things happen (see the
<a name="859"/># use of map() for transpositions).
<a name="860"/>#
<a name="861"/>procedure Permute(e1, e2)	
<a name="862"/>   local temp1, temp2, chunk, i
<a name="863"/>
<a name="864"/>   repeat {
<a name="865"/>      temp1 := @e2 | fail
<a name="866"/>      temp2 := []
<a name="867"/>      every put(temp2, i := 1 to *temp1)
<a name="868"/>      chunk := []
<a name="869"/>      every 1 to i do
<a name="870"/>         put(chunk, @e1) | fail
<a name="871"/>      suspend !lmap(temp1, temp2, chunk)
<a name="872"/>      }
<a name="873"/>
<a name="874"/>end
<a name="875"/>
<a name="876"/># PDCO to generate pivot points from `e % m`; `m` defaults to 100
<a name="877"/>procedure Pivot(e, m)		
<a name="878"/>   local current, direction, new
<a name="879"/>
<a name="880"/>   m := ce_param(m) | fail
<a name="881"/>   m := need_integer(\m) | 100
<a name="882"/>
<a name="883"/>   direction := "+"
<a name="884"/>
<a name="885"/>   current := @e % m | fail
<a name="886"/>
<a name="887"/>   suspend current
<a name="888"/>
<a name="889"/>   repeat {
<a name="890"/>      new := @e % m | break
<a name="891"/>      if new = current then next
<a name="892"/>      case direction of {
<a name="893"/>         "+":  {
<a name="894"/>            if new &gt; current then {
<a name="895"/>               current := new
<a name="896"/>               next
<a name="897"/>               }
<a name="898"/>            else {
<a name="899"/>               suspend current
<a name="900"/>               current := new
<a name="901"/>               direction := "-"
<a name="902"/>               }
<a name="903"/>            }
<a name="904"/>         "-":  {
<a name="905"/>            if new &lt; current then {
<a name="906"/>               current := new
<a name="907"/>               next
<a name="908"/>               }
<a name="909"/>            else {
<a name="910"/>               suspend current
<a name="911"/>               current := new
<a name="912"/>               direction := "+"
<a name="913"/>               }
<a name="914"/>            }
<a name="915"/>         }
<a name="916"/>
<a name="917"/>      }
<a name="918"/>
<a name="919"/>   return current
<a name="920"/>
<a name="921"/>end
<a name="922"/>
<a name="923"/># Generates the positions at which `v` occurs in `e`.
<a name="924"/>procedure Positions(e, v)	
<a name="925"/>   local count, x
<a name="926"/>
<a name="927"/>   v := ce_param(v) | fail
<a name="928"/>
<a name="929"/>   count := 0
<a name="930"/>
<a name="931"/>   while x := @e do {
<a name="932"/>      count +:= 1
<a name="933"/>      if x === v then suspend count
<a name="934"/>      }
<a name="935"/>
<a name="936"/>end
<a name="937"/>
<a name="938"/># PDCO to generate positions at which `e1` and `e2` differ
<a name="939"/>procedure PosDiff(e1, e2)	
<a name="940"/>   local i, x, y
<a name="941"/>
<a name="942"/>   i := 0
<a name="943"/>
<a name="944"/>   while x := @e1 &amp; y := @e2 do {
<a name="945"/>      i +:= 1
<a name="946"/>      if x ~=== y then suspend i
<a name="947"/>      }
<a name="948"/>
<a name="949"/>end
<a name="950"/>
<a name="951"/># PDCO to generate produces results of `L[1], L[2], ...` at random
<a name="952"/>procedure Random(L[])	
<a name="953"/>   local x
<a name="954"/>
<a name="955"/>   while x := @?L do suspend x
<a name="956"/>
<a name="957"/>end
<a name="958"/>
<a name="959"/># PDCO to model repeated alternation, `|e`.
<a name="960"/>procedure Repalt(e)	
<a name="961"/>   local fl
<a name="962"/>   repeat {
<a name="963"/>      suspend |@e do
<a name="964"/>         fl := &amp;yes
<a name="965"/>      if /fl then fail
<a name="966"/>      e := ^e
<a name="967"/>      fl := &amp;no
<a name="968"/>      }
<a name="969"/>
<a name="970"/>end
<a name="971"/>
<a name="972"/>
<a name="973"/># PDCO to "reduce" the sequence `e` by starting with the value `x` and
<a name="974"/># repetitively applying binary operation `op` to the current value and
<a name="975"/># values from `e`.
<a name="976"/>#
<a name="977"/>procedure Reduce(op, x, e)	
<a name="978"/>   local v
<a name="979"/>
<a name="980"/>   op := ce_param(op) | fail
<a name="981"/>   x := ce_param(x) | fail
<a name="982"/>
<a name="983"/>   op := need_callable(op, 2)
<a name="984"/>
<a name="985"/>   while v := @e do
<a name="986"/>      x := op(x, v)
<a name="987"/>
<a name="988"/>   return x
<a name="989"/>
<a name="990"/>end
<a name="991"/>
<a name="992"/># PDCO to repeat the sequence for `e1` `e2` times
<a name="993"/>procedure Repeat(e1, e2)	
<a name="994"/>   local i
<a name="995"/>
<a name="996"/>   while i := need_integer(@e2) do {
<a name="997"/>      every 1 to i do {
<a name="998"/>         suspend |@e1
<a name="999"/>         e1 := ^e1
<a name="1000"/>         }
<a name="1001"/>      }
<a name="1002"/>
<a name="1003"/>end
<a name="1004"/>
<a name="1005"/># PDCO for remove duplicate adjacent values in a sequence
<a name="1006"/>procedure RemoveDupl(e)	
<a name="1007"/>   local old, new
<a name="1008"/>
<a name="1009"/>   old := @e | fail
<a name="1010"/>   suspend old
<a name="1011"/>
<a name="1012"/>   repeat {
<a name="1013"/>      new := @e | fail
<a name="1014"/>      if new === old then next
<a name="1015"/>      else {
<a name="1016"/>         suspend new
<a name="1017"/>         old := new
<a name="1018"/>         }
<a name="1019"/>      }
<a name="1020"/>
<a name="1021"/>end
<a name="1022"/>
<a name="1023"/># PDCO to replicate each value in `e1` by the corresponding integer
<a name="1024"/># value in `e2`.
<a name="1025"/>procedure Repl(e1, e2)	
<a name="1026"/>   local x, i
<a name="1027"/>
<a name="1028"/>   while x := @e1 do {
<a name="1029"/>      i := @\e2 | 1
<a name="1030"/>      suspend (1 to i) &amp; x
<a name="1031"/>      }
<a name="1032"/>
<a name="1033"/>end
<a name="1034"/>
<a name="1035"/># PDCO to model limited iteration, ie
<a name="1036"/># ~
<a name="1037"/>#   every e1 \ e2 do e3`
<a name="1038"/># ~
<a name="1039"/>procedure Resume(e1, e2, e3)	
<a name="1040"/>   local i
<a name="1041"/>
<a name="1042"/>   while i := need_integer(@e2, 0) do {
<a name="1043"/>      e1 := ^e1
<a name="1044"/>      every 1 to i do if @e1 then @^e3 else break
<a name="1045"/>   }
<a name="1046"/>
<a name="1047"/>end
<a name="1048"/>
<a name="1049"/># PDCO to produce the results of `e` in reverse order.
<a name="1050"/>procedure Reverse(e)
<a name="1051"/>   local result
<a name="1052"/>   result := []
<a name="1053"/>   while push(result, @e)
<a name="1054"/>   suspend !result
<a name="1055"/>end
<a name="1056"/>
<a name="1057"/># PDCO to rotate the sequence for `e` left by `i`; negative
<a name="1058"/># `i` rotates to the right.
<a name="1059"/>procedure Rotate(e, i)		
<a name="1060"/>   local result, x
<a name="1061"/>
<a name="1062"/>   i := need_integer(ce_param(i)) | fail
<a name="1063"/>
<a name="1064"/>   result := []
<a name="1065"/>
<a name="1066"/>   if i &lt;= 0 then {		# if not to right, works for infinite sequence
<a name="1067"/>      every 1 to -i do
<a name="1068"/>         put(result, @e) | break
<a name="1069"/>      while x := @e do
<a name="1070"/>         suspend x
<a name="1071"/>      suspend !result
<a name="1072"/>      }
<a name="1073"/>
<a name="1074"/>   else {
<a name="1075"/>      while put(result, @e)
<a name="1076"/>      suspend !lrotate(result, i)
<a name="1077"/>      }
<a name="1078"/>
<a name="1079"/>end
<a name="1080"/>
<a name="1081"/># PDCO to produce multiple of values in sequence, producing `e * j` copies of `e`
<a name="1082"/>procedure Selfrepl(e, j)	
<a name="1083"/>   local i
<a name="1084"/>   j := ce_param(j) | fail
<a name="1085"/>   j := need_integer(\j) | 1
<a name="1086"/>   while i := need_integer(@e) do {
<a name="1087"/>      suspend (1 to i * j) &amp; i
<a name="1088"/>      }
<a name="1089"/>
<a name="1090"/>end
<a name="1091"/>
<a name="1092"/># PDCO to generate the integers not in sequence `e`.
<a name="1093"/>procedure Compl(e)	
<a name="1094"/>   local i, j
<a name="1095"/>
<a name="1096"/>   j := 1
<a name="1097"/>
<a name="1098"/>   while i := need_integer(@e) do {
<a name="1099"/>      suspend j to i - 1
<a name="1100"/>      j := i + 1
<a name="1101"/>      }
<a name="1102"/>
<a name="1103"/>   suspend seq(j)
<a name="1104"/>
<a name="1105"/>end
<a name="1106"/>
<a name="1107"/># PDCO to generate differences in sequences 
<a name="1108"/>procedure Delta2(e1, e2)	
<a name="1109"/>   local C, i
<a name="1110"/>
<a name="1111"/>   C := ^e1
<a name="1112"/>   every 1 to @e2 do @C
<a name="1113"/>
<a name="1114"/>   while i := @C - @e1 do
<a name="1115"/>     suspend i
<a name="1116"/>
<a name="1117"/>end
<a name="1118"/>
<a name="1119"/># Simple evaluation with only success or failure
<a name="1120"/>procedure Simple(L[])	
<a name="1121"/>   local i, L1
<a name="1122"/>
<a name="1123"/>   L1 := list(*L)
<a name="1124"/>
<a name="1125"/>   every i := 1 to *L do
<a name="1126"/>      L1[i] := @L[i] | fail
<a name="1127"/>
<a name="1128"/>   return L1
<a name="1129"/>
<a name="1130"/>end
<a name="1131"/>
<a name="1132"/># PDCO to generate `e1` skipping each `e2` terms
<a name="1133"/>procedure Skip(e1, e2)	
<a name="1134"/>   local gap
<a name="1135"/>
<a name="1136"/>   suspend @e1
<a name="1137"/>
<a name="1138"/>   repeat {
<a name="1139"/>      gap := need_integer(@e2) | fail
<a name="1140"/>      every 1 to gap do
<a name="1141"/>         @e1 | fail
<a name="1142"/>      suspend @e1
<a name="1143"/>      }
<a name="1144"/>
<a name="1145"/>end
<a name="1146"/>
<a name="1147"/># Generalized modular reduction: reduce terms in `e1` (shaft) modulus `e2`
<a name="1148"/>procedure Smod(e1, e2)		
<a name="1149"/>   local i, m
<a name="1150"/>
<a name="1151"/>   while i := @e1 do {
<a name="1152"/>      m := @e2 | fail
<a name="1153"/>      suspend mod1(i, m)
<a name="1154"/>      }
<a name="1155"/>
<a name="1156"/>end
<a name="1157"/>
<a name="1158"/># Fill in gaps between consecutive (integer) values in `e % m`; `m`
<a name="1159"/># defaults to 100
<a name="1160"/>procedure Span(e, m)		
<a name="1161"/>   local i, j
<a name="1162"/>
<a name="1163"/>   m := ce_param(m) | fail
<a name="1164"/>   m := need_integer(\m) | 100
<a name="1165"/>
<a name="1166"/>   j := @e | fail
<a name="1167"/>   while i := mod1(@e, m) do {
<a name="1168"/>      if i &gt; j then suspend j to i - 1
<a name="1169"/>      else if i &lt; j then suspend j to i + 1 by -1
<a name="1170"/>      j := i
<a name="1171"/>      } 
<a name="1172"/>
<a name="1173"/>   suspend j
<a name="1174"/>
<a name="1175"/>end
<a name="1176"/>
<a name="1177"/># PDCO to produce values of `e` until their sum exceeds
<a name="1178"/># `limit`.  Values less than `min` are discarded.
<a name="1179"/>procedure Sumlimit(e, limit, min) 	
<a name="1180"/>   local sum, i
<a name="1181"/>
<a name="1182"/>   limit := ce_param(limit) | fail
<a name="1183"/>   min := ce_param(min) | fail
<a name="1184"/>
<a name="1185"/>   limit := need_integer(\limit) | 2^15
<a name="1186"/>   min := need_integer(\min) | 0
<a name="1187"/>   sum := 0
<a name="1188"/>
<a name="1189"/>   while i := @e do {
<a name="1190"/>      if i &lt; min then next
<a name="1191"/>      if (sum + i) &gt; limit then fail
<a name="1192"/>      sum +:= i
<a name="1193"/>      suspend i
<a name="1194"/>      }
<a name="1195"/>
<a name="1196"/>end
<a name="1197"/>
<a name="1198"/># PDCO to produce the unique results of `e` in the order they first appear.
<a name="1199"/>procedure Unique(e)	
<a name="1200"/>   local done, x
<a name="1201"/>
<a name="1202"/>   done := set()
<a name="1203"/>
<a name="1204"/>   while x := @e do
<a name="1205"/>      unless member(done, x) then {
<a name="1206"/>         insert(done, x)
<a name="1207"/>         suspend x
<a name="1208"/>         }
<a name="1209"/>
<a name="1210"/>end
<a name="1211"/>
<a name="1212"/># This is like `Unique` above, but uses `lang.equals()`, as opposed to
<a name="1213"/># `===`, to determine whether or not a result has been previously
<a name="1214"/># seen.
<a name="1215"/>#
<a name="1216"/>procedure UniqueEq(e)	
<a name="1217"/>   local done, x
<a name="1218"/>
<a name="1219"/>   done := EqSet()
<a name="1220"/>
<a name="1221"/>   while x := @e do
<a name="1222"/>      unless done.member(x) then {
<a name="1223"/>         done.insert(x)
<a name="1224"/>         suspend x
<a name="1225"/>         }
<a name="1226"/>
<a name="1227"/>end
<a name="1228"/>
<a name="1229"/>
<a name="1230"/># Upper sequence trimming
<a name="1231"/>procedure UpperTrim(e)	
<a name="1232"/>   local done, i
<a name="1233"/>
<a name="1234"/>   done := set()
<a name="1235"/>
<a name="1236"/>   while i := @e do {
<a name="1237"/>      unless member(done, i) then
<a name="1238"/>         insert(done, i)
<a name="1239"/>      else suspend i
<a name="1240"/>      }
<a name="1241"/>
<a name="1242"/>end
<a name="1243"/>
<a name="1244"/>
<a name="1245"/># PDCO to produce sequence values alternately: `e(1), e(2), e(1), e(2), e(3), e(2), ...`.
<a name="1246"/>procedure Wobble(e)	
<a name="1247"/>   local x, y
<a name="1248"/>
<a name="1249"/>   x := @e | fail
<a name="1250"/>   suspend x
<a name="1251"/>
<a name="1252"/>   while y := @e do {
<a name="1253"/>      suspend y | x | y
<a name="1254"/>      x := y
<a name="1255"/>      }
<a name="1256"/>
<a name="1257"/>end
<a name="1258"/>
<a name="1259"/>#
<a name="1260"/># Evaluate the given expression, suspending its results, whilst
<a name="1261"/># ignoring any non-fatal runtime errors.  After failure,
<a name="1262"/># `&amp;errortext` can be tested to see whether or not failure was
<a name="1263"/># caused by a runtime error.
<a name="1264"/>#
<a name="1265"/>procedure Safe(e)
<a name="1266"/>   suspend save_state(e, HandlerState(&amp;current))
<a name="1267"/>end
<a name="1268"/>
<a name="1269"/># A useful wrapper around `Safe`.  `Safe` is called with `e` to get
<a name="1270"/># its first result.  If no runerr occurs, then the result produced by
<a name="1271"/># `e` is returned.  If `e` fails, `&amp;null` is returned.  If a runerr
<a name="1272"/># occurs, `errorclear` is called, `&amp;why` is set and the procedure
<a name="1273"/># fails.
<a name="1274"/>#
<a name="1275"/>procedure Safe1(e)
<a name="1276"/>   local v
<a name="1277"/>   v := Safe(e)
<a name="1278"/>   if &amp;errortext then {
<a name="1279"/>      &amp;why := if &amp;errornumber then
<a name="1280"/>         "Runtime error " || &amp;errornumber || ": " || &amp;errortext
<a name="1281"/>      else                                                     
<a name="1282"/>         "Runtime error: " || &amp;errortext                       
<a name="1283"/>      &amp;why ||:= "; Offending value: " || image(&amp;errorvalue)
<a name="1284"/>      errorclear()
<a name="1285"/>   } else
<a name="1286"/>      return v
<a name="1287"/>end
<a name="1288"/>
<a name="1289"/># Dijkstra non-deterministic if construct
<a name="1290"/>procedure If(a[])
<a name="1291"/>   local x, i
<a name="1292"/>   x := []
<a name="1293"/>   every i := 1 to *a by 2 do 
<a name="1294"/>      if @a[i] then 
<a name="1295"/>         put(x, i)
<a name="1296"/>
<a name="1297"/>   if *x = 0 then
<a name="1298"/>      runerr("No guard in If succeeded")
<a name="1299"/>
<a name="1300"/>   i := ?x + 1
<a name="1301"/>   suspend |@a[i]
<a name="1302"/>end
<a name="1303"/>
<a name="1304"/># Dijkstra non-deterministic do construct
<a name="1305"/>procedure Do(a[])
<a name="1306"/>   local x, i
<a name="1307"/>   repeat {
<a name="1308"/>      x := []
<a name="1309"/>      every i := 1 to *a by 2 do
<a name="1310"/>         if @^a[i] then 
<a name="1311"/>            put(x, i)
<a name="1312"/>
<a name="1313"/>      if *x = 0 then
<a name="1314"/>         break
<a name="1315"/>
<a name="1316"/>      @^a[?x + 1]
<a name="1317"/>   }
<a name="1318"/>end
<a name="1319"/>
<a name="1320"/>#
<a name="1321"/># Generate the results of a co-expression as a sequence.
<a name="1322"/>#
<a name="1323"/>procedure Seq(e)
<a name="1324"/>   suspend |@e
<a name="1325"/>end
<a name="1326"/>
<a name="1327"/>#
<a name="1328"/># Succeed (with &amp;null) iff the given co-expression produces a result.
<a name="1329"/>#
<a name="1330"/>procedure Succeeds(e)
<a name="1331"/>   succeed @e
<a name="1332"/>end
<a name="1333"/>
<a name="1334"/>#
<a name="1335"/># Evaluate each element of `e`, suspending on the way the results of
<a name="1336"/># those indicated by the sequence `e1`, which should be ascending.
<a name="1337"/>#
<a name="1338"/>procedure Each(e1, e[])
<a name="1339"/>   local j, x, count
<a name="1340"/>
<a name="1341"/>   count := 0
<a name="1342"/>   every j := IncreasingFrom(1 , e1) do {
<a name="1343"/>      repeat {
<a name="1344"/>         x := e[count +:= 1] | fail
<a name="1345"/>         if count = j then {
<a name="1346"/>            suspend |@x
<a name="1347"/>            break
<a name="1348"/>         }
<a name="1349"/>         while @x
<a name="1350"/>      }
<a name="1351"/>   }
<a name="1352"/>
<a name="1353"/>   while x := e[count +:= 1] do
<a name="1354"/>      while @x
<a name="1355"/>
<a name="1356"/>end
<a name="1357"/>
<a name="1358"/>#
<a name="1359"/># Generate the results of e between the elements i to j.  If j is
<a name="1360"/># &amp;null, then there is no upper limit.  Otherwise, Icon slice index
<a name="1361"/># semantics are used (like l[i:j]), so (j - i) elements at most are
<a name="1362"/># generated.
<a name="1363"/>#
<a name="1364"/>procedure Subseq(e, i, j)
<a name="1365"/>   i := ce_param(i) | fail
<a name="1366"/>   j := ce_param(j) | fail
<a name="1367"/>   i := need_integer(\i) | 1
<a name="1368"/>   \j := need_integer(j)
<a name="1369"/>   if i &gt; \j then
<a name="1370"/>      i :=: j
<a name="1371"/>   every 2 to i do
<a name="1372"/>      @e | fail
<a name="1373"/>   suspend if /j then |@e else |@e \ (j - i)
<a name="1374"/>end
<a name="1375"/>
<a name="1376"/>#
<a name="1377"/># Parallel assignment to each result of e from each corresponding result of f.
<a name="1378"/>#
<a name="1379"/>procedure Assign(e, f)
<a name="1380"/>   while @e := @f
<a name="1381"/>end
<a name="1382"/>
<a name="1383"/>#
<a name="1384"/># Parallel swap between corresponding results of e and f.
<a name="1385"/>#
<a name="1386"/>procedure Swap(e, f)
<a name="1387"/>   while @e :=: @f
<a name="1388"/>end
<a name="1389"/>
<a name="1390"/>#
<a name="1391"/># Generate results from co-expression `e`, while function `f`, applied
<a name="1392"/># to each result, succeeds.
<a name="1393"/>#
<a name="1394"/>procedure TakeWhile(f, e)
<a name="1395"/>   local i
<a name="1396"/>   f := need_callable(ce_param(f)) | fail
<a name="1397"/>   while f(i := @e) do
<a name="1398"/>      suspend i
<a name="1399"/>end
<a name="1400"/>
<a name="1401"/>#
<a name="1402"/># Discard results from co-expression `e`, while function `f`, applied
<a name="1403"/># to each result, succeeds.  Then generate the remainder of the
<a name="1404"/># results from `e`.
<a name="1405"/>#
<a name="1406"/>procedure DropWhile(f, e)
<a name="1407"/>   local i
<a name="1408"/>   f := need_callable(ce_param(f)) | fail
<a name="1409"/>   repeat {
<a name="1410"/>      i := @e | fail
<a name="1411"/>      f(i) | break
<a name="1412"/>   }
<a name="1413"/>   suspend i | |@e
<a name="1414"/>end
<a name="1415"/>
<a name="1416"/>#
<a name="1417"/># Generate results from co-expression `e`, filtered by function `f`.
<a name="1418"/>#
<a name="1419"/>procedure Filter(f, e)
<a name="1420"/>   local i
<a name="1421"/>   f := need_callable(ce_param(f)) | fail
<a name="1422"/>   while i := @e do
<a name="1423"/>      if f(i) then
<a name="1424"/>         suspend i
<a name="1425"/>end
<a name="1426"/>
<a name="1427"/>#
<a name="1428"/># Apply a function, given by the first parameter, to the remaining sequences.
<a name="1429"/>#
<a name="1430"/>procedure Zip(ef, el[])
<a name="1431"/>   local n, f, e, t
<a name="1432"/>   # Allow operators if 1-3 parameters
<a name="1433"/>   if 1 &lt;= *el &lt;= 3 then
<a name="1434"/>      n := *el
<a name="1435"/>   f := need_callable(@ef, n) | fail
<a name="1436"/>   if *el = 0 then
<a name="1437"/>      fail
<a name="1438"/>   repeat {
<a name="1439"/>      t := []
<a name="1440"/>      every e := !el do
<a name="1441"/>         put(t, @e) | fail
<a name="1442"/>      suspend f!t
<a name="1443"/>      if f := @ef then
<a name="1444"/>         f := need_callable(f, n)
<a name="1445"/>   }
<a name="1446"/>end
<a name="1447"/>
<a name="1448"/>#
<a name="1449"/># Succeed (and return &amp;null), if the function `f` succeeds when
<a name="1450"/># applied to all the results from co-expression `e`; fail otherwise.
<a name="1451"/>#
<a name="1452"/>procedure AllOf(f, e)
<a name="1453"/>   local i
<a name="1454"/>   f := need_callable(ce_param(f)) | fail
<a name="1455"/>   while i := @e do
<a name="1456"/>      f(i) | fail
<a name="1457"/>   return
<a name="1458"/>end
<a name="1459"/>
<a name="1460"/>package procedure MinMaxImpl(e, cmp, dir)
<a name="1461"/>   local i, v
<a name="1462"/>   cmp := ce_param(cmp) | fail
<a name="1463"/>   cmp := need_callable_def(cmp)
<a name="1464"/>   v := @e | fail
<a name="1465"/>   while i := @e do {
<a name="1466"/>      if dir * cmp(i, v) &gt; 0 then
<a name="1467"/>         v := i
<a name="1468"/>   }
<a name="1469"/>   return v
<a name="1470"/>end
<a name="1471"/>
<a name="1472"/># Return the maximum element in the sequence `e`, based on the
<a name="1473"/># comparison function `cmp`, which defaults to `Internal.compare`.
<a name="1474"/>#
<a name="1475"/>procedure Max(e, cmp)
<a name="1476"/>   return MinMaxImpl(e, cmp, 1)
<a name="1477"/>end
<a name="1478"/>
<a name="1479"/># Return the minimum element in the sequence `e`, based on the
<a name="1480"/># comparison function `cmp`, which defaults to `Internal.compare`.
<a name="1481"/>#
<a name="1482"/>procedure Min(e, cmp)
<a name="1483"/>   return MinMaxImpl(e, cmp, -1)
<a name="1484"/>end
<a name="1485"/>
<a name="1486"/>#
<a name="1487"/># A useful function to calculate the maximum of a sequence of
<a name="1488"/># non-negative numbers.  Unlike `Max` above, the empty sequence makes
<a name="1489"/># sense, and returns 0.  It is equivalent to :-
<a name="1490"/>#
<a name="1491"/># ~~~
<a name="1492"/>#   Reduce{ "&lt;", 0, ... }
<a name="1493"/># ~~~
<a name="1494"/>procedure MaxNN(e)
<a name="1495"/>   local x, v
<a name="1496"/>   x := 0
<a name="1497"/>   while v := @e do
<a name="1498"/>      x &lt;:= v
<a name="1499"/>
<a name="1500"/>   return x
<a name="1501"/>end
<a name="1502"/>
<a name="1503"/>#
<a name="1504"/># A convenient wrapper around the `echo()` builtin function.  `e` is
<a name="1505"/># evaluated, and if successful, a co-expression is returned which
<a name="1506"/># endlessly repeats the result.
<a name="1507"/>#
<a name="1508"/>procedure Echo(e)
<a name="1509"/>   local f
<a name="1510"/>   f := create echo(@e)
<a name="1511"/>   if @f then
<a name="1512"/>      return f
<a name="1513"/>end
<a name="1514"/>
<a name="1515"/>#
<a name="1516"/># This is rather like alternation, but stops after the first expression
<a name="1517"/># which generates any results.  For example,
<a name="1518"/># ~
<a name="1519"/>#   First{ 1+1=3, 1 to 3, !"abc" }
<a name="1520"/># ~
<a name="1521"/># generates 1 to 3, from its second argument.
<a name="1522"/>#
<a name="1523"/>procedure First(a[])
<a name="1524"/>   local e, fl
<a name="1525"/>   every e := !a do {
<a name="1526"/>      suspend |@e do
<a name="1527"/>         fl := &amp;yes
<a name="1528"/>      if \fl then
<a name="1529"/>         fail
<a name="1530"/>   }
<a name="1531"/>end
</pre></body></html>
