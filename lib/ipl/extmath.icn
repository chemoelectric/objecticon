package ipl.math

#-------------------------------------------------------------------------------
# Name:        oipl.math
# Purpose:     Extended Library of mathematical functions
#
# Author:      Oleg Baharew aka ArqricCat (IDP Team)
#
# Created:     27.07.2013
# Copyright:   (c) IDP Team, 2013
# Licence:     MIT License

# Class summary:

#  ExtMath - a class that provides an expanded set of mathematical functions that are 
#  implemented as static methods of this class.
  
#  Methods defined in this class:
#     * to_sys(x,n) - convert number to system with base n
#     * from_sys(x,n) - convert number from system with base n
#     * to_sys2(x,n1,n2) - convert number from system with base n1 to system with base n2
#     * root(x,y) - yth root from x
#     * discriminant(a,b,c) - discriminant of quadratic equation
#     * sgn(x) - signum function
#     * frac(x) - fraction part
#     * floor(x) -  largest integer not greater than x
#     * ceil(x) - smallest integer not less than x
#     * heavyside(x) - Heavyside function
#     * heavyside2(x) - Discrete Heavyside function
#     * rect(x) - rectangle function
#     * tri(x) - triangle function
#     * saw(x,a) - saw function (a is optional parameter)
#     * sinc(x) - normalized sinc function
#     * sinc2(x) - unnormalized sinc function
#     * weierstrass(a,b,x) - Weierstrass function
#     * si(x) - sine integral
#     * ci(x) - cosine integral
#     * erf(x) - error function
#     * erfc(x) - complicated error function
#     * gd(x) - guderman function
#     * arcgd(x) - inverse Guderman function
#     * sec(x) - secans
#     * cosec(x) - cosecans
#     * ctg(x) - cotangent
#     * ei(x) - exponent integral
#     * li(x) - logarithm integral
#     * cth(x) - cotangent
#     * sech(x) - hyperbolic secans
#     * csch(x) - hyperbolic cosecans
#     * fusc(x) - fusc function
#     * prostaferethic(x) - prostaferethic function
#     * gompertz(a,b,c,x) - Gompertz function
#     * gauss(mu,sigma,x) - Gauss function

import 
   util(Math),
   ipl.factors(factorial)



class ExtMath()
public static const 
   syms,
   eiler

   private static init()
   syms := &digits++&ucase
   eiler := 0.5772156649015328606065120
   end

   public static to_sys(x,n)
      local r,s,i,t,res
      s := list()
      t := list()
      while x >= 1 do {
         r := x%n
         put(s,r)
         x := integer(x/n)
      }
      every i := *s to 1 by -1 do {
         put(t,syms[s[i]+1])
      }
      res:=""
      every i := 1 to *t do {
         res ||:= t[i]
      }
      return res
      end

   public static from_sys(x,n)
      local r,t,i
      r := 0
      x := reverse(x)
      every i := 1 to *x do {
	 if x[i] == !syms then t := find(x[i],syms)-1
         r +:= t*(n^(i-1))	    
      }
      return r
   end

   public static to_sys2(x,n1,n2)
   local tmp
   tmp := from_sys(x,n1)
   return to_sys(tmp,n2)
   end 

   public static root(x,y)
   return x^(1.0/y)
   end

   public static discriminant(a,b,c)
   return (b^2) - 4 * a * c
   end

   public static sgn(x)
   if x < 0 then return -1 else {
     if x = 0 then return 0 else return 1
   } 
   end
 
   public static frac(x)
   return abs(x - integer(x))
   end

   public static floor(x)
   return integer(x - frac(x))
   end

   public static ceil(x)
   if frac(x) = 0 then return x else return 1 + floor(x)
   end

   public static heavyside(x)
   if x < 0 then return 0 else {
      if x = 0 then return 0.5 else return 1
   }
   end

   public static heavyside2(x)
   if x < 0 then return 0 else return 1
   end

   public static rect(x)
   if abs(x) > 0.5 then return 0 else {
      if abs(x) = 0.5 then return 0.5 else return 1
   }
   end

   public static tri(x)
   if abs(x) < 1 then return 1 - abs(x) else return 0
   end

   public static saw(x,a)
   local tmp
   /a := 1
   tmp := x/a
   return tmp - floor(tmp + 0.5)
   end

   public static sinc(x)
   if x = 0 then return 1 else return Math.sin(Math.PI * x)/(Math.PI * x)
   end

   public static sinc2(x)
   if x = 0 then return 1 else return Math.sin(x)/x
   end
   
   public static weierstrass(a,b,x)
   local i,k,m,s
   i:=0
   s:=0
   while i < 10 do {
      k := Math.cos(Math.PI*x*(a^i))
      m := b^i
      s +:= k*m
      i +:= 1
   }
   return s
   end

   public static si(x)
   local i,g,s,k,v
   i := 0
   s := 0
   while i < 20 do {
      k := (2*i)+1
      g := (-1)^i
      v := (g*(x^k))/(factorial(k)*k)
      s +:= v
      i +:= 1
   }
   return s
  end

   public static ci(x)
   local i,s,k
   s := eiler+Math.log(x,Math.E)
   i :=1
   while i<20 do {
      k := (((-1.0)^i)*(x^(2.0*i)))/(factorial(2.0*i)*2.0*i)
      s +:= k
      i +:= 1
   }
   return s
   end  

   public static erf(x)
   local a,b,c,s,i
   a := 2.0 / Math.sqrt(Math.PI)
   s := 0
   every i:=0 to 20 do {
      b := 2*i + 1
      c := ((-1)^i * (x^b)) / (b * factorial(i))
      s +:= c
   }
   return a * s
   end

   public static erfc(x)
   return 1 - erf(x)
   end

   public static gd(x)
   return 2 * Math.atan(Math.exp(x)) - (Math.PI / 2.0)
   end

   public static arcgd(x)
   return 0.5 * Math.log((1.0+Math.sin(x))/(1.0-Math.sin(x)))
   end

   public static sec(x)
   return 1.0 / Math.cos(x)
   end

   public static cosec(x)
   return 1.0 / Math.sin(x)
   end

   public static ctg(x)
   return Math.cos(x) / Math.sin(x)
   end

   public static ei(x)
   local s,i,a
   s := Math.log(x) + eiler
   every i := 1 to 20 do {
      a := (x^i) / (factorial(i)*i)
      s +:= a
   }
   return s 
   end

   public static li(x)
   return ei(Math.log(x))
   end

   public static cth(x)
   return 1.0 / tanh(x)
   end

   public static sech(x)
   return 1.0 / cosh(x)
   end

   public static csch(x)
   return 1.0 / sinh(x)
   end
   
   public static fusc(x)
   local a,b
   a := 1
   b := 0
   while x ~= 0 do {
      if x%2 = 0 then {
         a := a+b
         x := x/2
      } else {
         b := a+b 
         x := (x-1)/2
     }
   }
   return b
   end

   public static prostaferethic(x)
   return integer((x^2)/4.0)
   end

   public static gompertz(a,b,c,x)
   return a*Math.exp(b*Math.exp(c*x))
   end

   public static gauss(mu,sigma,x)
   local a,b,c
   a := 1.0/(sigma*Math.sqrt(2*Math.PI))
   b := ((x-mu)^2)/(2*(sigma^2))
   c := Math.exp(-b)
   return a*c
   end
end
