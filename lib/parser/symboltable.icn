package parser

import 
   util(Connectable, SetFields, error), 
   lang(fatal), 
   io

$include "posix.icn"

class Symbol()
   public const
      scanned_file,
      obj,
      name

   public get_package()
      return \scanned_file.pack
   end

   public get_fq_name()
      return (\scanned_file.pack || "." || name) | name
   end

   package new(scanned_file, obj, name)
      self.scanned_file := scanned_file
      self.obj := obj
      self.name := name
      return
   end
end

class ProcedureSymbol(Symbol)
end

class BuiltinSymbol(Symbol)
   package new(name)
      self.name := name
      return
   end
end

class RecordSymbol(Symbol)
end

class GlobalSymbol(Symbol)
   public const
      decl_obj

   package new(scanned_file, obj, name, decl_obj)
      cast(self,Symbol).new(scanned_file, obj, name)
      self.decl_obj := decl_obj
      return
   end
end

class ClassSymbol(Symbol)
   package
      fields,
      supers,
      resolved_supers, 
      implemented_fields,
      implemented_classes

   public get_supers()
      suspend .!supers
   end

   public add_super(s)
      put(supers, s)
   end

   public get_resolved_supers()
      suspend .!resolved_supers
   end

   package add_resolved_super(c)
      put(self.resolved_supers, c)
   end

   public get_implemented_fields()
      suspend .!self.implemented_fields
   end

   public get_implemented_field(n)
      return .\self.implemented_fields[n]
   end

   public get_implemented_classes()
      suspend .!self.implemented_classes
   end

   package add_implemented_class(c)
      local f
      put(self.implemented_classes, c)
      every f := !c.fields do
         /self.implemented_fields[f.name] := f
   end

   public get_field(n)
      return .\self.fields[n]
   end

   public get_fields()
      suspend .!self.fields
   end

   package add_field(f)
      self.fields[f.name] := f
   end

   package new(scanned_file, obj, name)
      cast(self,Symbol).new(scanned_file, obj, name)
      self.fields := table()
      self.supers := []
      self.resolved_supers := []
      self.implemented_fields := table()
      self.implemented_classes := []
      return
   end
end

class ClassField(Symbol)
   public const
      defining_class

   package new(defining_class, obj, name)
      cast(self,Symbol).new(defining_class.scanned_file, obj, name)
      self.defining_class := defining_class
      return
   end
end

class ClassVariable(ClassField)
   public const
      decl_obj

   package new(defining_class, obj, name, decl_obj)
      cast(self,ClassField).new(defining_class, obj, name)
      self.decl_obj := decl_obj
      return
   end
end

class ClassMethod(ClassField)
end

class ScannedFile()
   public const
      filename

   private readable
      obj,
      strinv

   private const
      imports,
      links,
      invocables,
      resolved_invocables,
      symbols

   private readable
      pack

   package set_obj(obj)
      self.obj := obj
   end

   package set_package(pack)
      self.pack := pack
   end
      
   package add_symbol(sym)
      symbols[sym.name] := sym
   end

   public get_symbol(name)
      return .\symbols[name]
   end

   public get_symbols()
      suspend .!symbols
   end

   package add_import(i)
      imports[i.name] := i
   end

   public get_import(name)
      return .\imports[name]
   end

   public get_imports()
      suspend .!imports
   end

   public get_resolved_invocables()
      suspend .!resolved_invocables
   end

   package add_resolved_invocable(sym)
      put(resolved_invocables, sym)
   end

   public get_invocables()
      suspend .!invocables
   end

   package add_invocable(sym)
      put(invocables, sym)
   end

   package set_strinv(v)
      self.strinv := v
   end

   public get_links()
      suspend .!links
   end

   package add_link(sym)
      put(links, sym)
   end

   public convert_dottedidentexpr(n)
      local ls
      if is(n, Token) then
         return n.s
      ls := Util.dottedid2string(n.child(1))
      if (ls == (\pack | "default")) | member(imports, ls) then
         return ls || "." || n.child(3).s
      return convert_dottedidentexpr(n.child(1))
   end

   package new(filename)
      self.filename := filename
      self.imports := table()
      self.symbols := table()
      self.links := []
      self.invocables := []
      self.resolved_invocables := []
      return
   end
end

class ImportDec()
   public const
      qualified,
      name

   private const 
      syms

   package add(sym)
      insert(syms, sym)
   end

   public has(sym)
      return member(syms, sym)
   end

   package new(name, qualified)
      self.name := name
      self.qualified := qualified
      self.syms := set()
      return
   end
end

class SymbolTable(Connectable,SetFields)
   private
      package_db,
      symbol_table, 
      scanned_files,
      scanned_packages,
      file_mode

   public static const
      SCANNING_EVENT,
      PREFER_SRC,
      PREFER_U,
      ALWAYS_SRC,
      ALWAYS_U

   private static const
      BUILTINS

   private static init()
      SCANNING_EVENT := "scanning"
      PREFER_SRC := "prefer_src"
      PREFER_U := "prefer_u"
      ALWAYS_SRC := "always_src"
      ALWAYS_U := "always_u"
      BUILTINS := set()
      every insert(BUILTINS, function())
   end

   private parse(f)
      local p, prog
      p := Parser()
      prog := p.parse_file(f) | fail
      return prog
   end

   public dump()
      local e, f
      every e := !sort(symbol_table) do {
         write(e[1],"->",subtype(e[2]), " in file ", (\e[2].scanned_file).filename | "-")
         if is(e[2], ClassSymbol) then {
            every f := !sort(\e[2].implemented_fields) do {
               write("\t", f[1], "->", subtype(f[2]), " from ", f[2].defining_class.name)
            }
         }
      }
   end

   private add_symbol(sym)
      local k
      k := sym.get_fq_name()
      if \symbol_table[k] then
         return error("Symbol " || k || " already defined in " || symbol_table[k].scanned_file.filename)
      symbol_table[k] := sym
      sym.scanned_file.add_symbol(sym)
      return
   end

   private get_stem(f)
      if map(f[-4:0]) == ".icn" then
         return f[1:-4]
      if map(f[-2:0]) == ".u" then
         return f[1:-2]
      return f
   end

   private match_stem(f)
      local fu, fi
      fu := f || ".u"
      fi := f || ".icn"
      case file_mode of {
         PREFER_SRC : {
            if Files.access(fi, R_OK) then 
               return fi
            if Files.access(fu, R_OK) then
               return fu
         }
         PREFER_U : {
            if Files.access(fu, R_OK) then
               return fu
            if Files.access(fi, R_OK) then 
               return fi
         }
         ALWAYS_SRC : {
            if Files.access(fi, R_OK) then 
               return fi
         }
         ALWAYS_U : {
            if Files.access(fu, R_OK) then
               return fu
         }
      }
   end

   private path_find(f)
      local p, s, t

      f := get_stem(f)

      # First of all see if it exists without any search
      if t := match_stem(f) then
         return t

      p := Files.get_path(f)
      # We never append absolute paths to the search path
      if p.is_absolute() then
         fail

      # Search all the elements in the path
      every s := Files.get_path(Files.split_paths(getenv("OIPATH"))).append(p).str() do {
         if t := match_stem(s) then
            return t
      }
   end

   private scan(f)
      local sf, i, s, g
      # Standardize by getting rid of the extension
      f := get_stem(f)
      if member(scanned_files, f) then
         return
      g := match_stem(f) | return error("No .icn or .u file at " || f)
      fire(SCANNING_EVENT, g)
      sf := ScannedFile(g)
      scanned_files[f] := sf
      if map(g[-4:0]) == ".icn" then
         scan_src(sf) | fail
      else
         scan_u(sf) | fail
      if \sf.pack then
         scan_package(sf.pack) | fail
      every i := sf.get_imports() do
         scan_package(i.name) | fail
      every s := sf.get_links() do
         scan_file_on_path(s) | fail

      return
   end

   private scan_src(sf)
      local c, d, e, f, s, i, prog

      prog := parse(sf.filename) | fail
      sf.set_obj(prog)

      every d := prog.gen() do {
         case classof(d) of {
            Global : {
               every s := d.gen() do
                  add_symbol(GlobalSymbol(sf, s, s.str(), d)) | fail
            }
            Procedure : add_symbol(ProcedureSymbol(sf, d, d.get_name().str())) | fail
            Class : {
               c := ClassSymbol(sf, d, d.get_name().str())
               every c.add_super(d.get_supers().gen().str())
               every e := d.gen() do {
                  case classof(e) of {
                     FieldList: {
                        every f := e.gen() do
                           c.add_field(ClassVariable(c, f, f.str(), e))
                     }
                     DeferredMethod | Method:
                        c.add_field(ClassMethod(c, e, e.get_name().str()))
                  }
               }
               add_symbol(c) | fail
            }

            Record : add_symbol(RecordSymbol(sf, d, d.get_name().str())) | fail
            Package : sf.set_package(d.get_name().str())
            Import : {
               every e := d.gen() do {
                  if is(e, Id) then
                     sf.add_import(ImportDec(e.str()))
                  else {
                     s := e.get_package().str()
                     if not(i := sf.get_import(s)) then {
                        i := ImportDec(s, 1)
                        sf.add_import(i)
                     }
                     every i.add(e.gen().str())
                  }
               }
            }
            Link : {
               every s := d.gen().str() do {
                  # Strip quotes
                  if s[1] == "\"" then
                     s := s[2:-1]
                  sf.add_link(s)
               }
            }
            Invocable : {
               every e := d.gen() do {
                  if is(e, Id) then {
                     s := e.str()
                     if s == "all" then
                        sf.set_strinv(1)
                     else {
                        if s[1] == "\"" then
                           s := s[2:-1]
                        sf.add_invocable(s)
                     }
                  }
               }
            }
            default : fatal(self, "Unknown global dec type:" || image(d))
         }
      }
      return
   end

   private scan_u(sf)
      local s, r, uf, d, c, e
      s := Files.file_to_string(sf.filename) | return error("Couldn't read " || sf.filename)
      r := UReader()
      uf := (s ? r.scan_decls()) | return error("Couldn't scan ufile: " || &why)
      sf.set_obj(uf)
      sf.set_package(uf.pack)
      every sf.add_import(uf.get_imports())
      sf.set_strinv(uf.strinv)
      every sf.add_invocable(uf.get_invocables())
      every sf.add_link(uf.get_links())
      every d := uf.get_symbols() do {
         case classof(d) of {
            UGlobal : add_symbol(GlobalSymbol(sf, d, d.name, d)) | fail
            UProcedure : add_symbol(ProcedureSymbol(sf, d, d.name)) | fail
            UClass : {
               c := ClassSymbol(sf, d, d.name)
               every c.add_super(d.get_supers())
               every e := d.get_fields() do {
                  case classof(e) of {
                     UMethod :
                        c.add_field(ClassMethod(c, e, e.name))
                     UVariable :
                        c.add_field(ClassVariable(c, e, e.name, e))
                     default :
                        fatal(self, "Unknown type:" || image(e))
                  }
               }
               add_symbol(c) | fail
            }
            URecord : add_symbol(RecordSymbol(sf, d, d.name)) | fail
            default : fatal(self, "Unknown ufile type:" || image(d))
         }
      }
      return
   end

   public scan_file_on_path(f)
      local s
      s := path_find(f) | return error("Couldn't find " || f || " on path")
      return scan_file(s)
   end

   public scan_file(f)
      return scan(Files.get_path(f).canonical().str())
   end

   private ensure_package_db()
      local d, p, s, f
      if \package_db then
         return
      package_db := table()
      every d := chdir() | Files.split_paths(getenv("OIPATH")) do {
         p := Files.get_path(d).canonical()
         s := p.str()
         if /package_db[s] then {
            if f := open(p.child("packages.txt").str(), "r") then {
               package_db[s] := scan_packtxt(f) | {
                  f.close()
                  fail
               }
               f.close()
            } else
               package_db[s] := table()
         }
      }
      return
   end

   private scan_packtxt(f)
      local s, t, u
      t := table()
      while s := read(f) do {
         if s == ">package" then {
            s := read(f) | return error("corrupt - package name expected following package")
            u := /t[s] := set() | return error("corrupt - duplicate package entry")
         } else
            insert(\u, s) | return error("corrupt - package expected")
      }
      return t
   end

   public get_all_packages()
      ensure_package_db() | fail
      suspend key(!package_db)
   end

   public scan_package(p)
      local d, fs, seen, f
      if member(scanned_packages, p) then
         return
      insert(scanned_packages, p)
      ensure_package_db() | fail
      every d := key(package_db) do {
         if fs := \package_db[d, p] then {
            if \seen then
               return error("located package " || p || " in multiple directories")
            every f := Files.get_path(d).child(!fs).str()  do
               scan(f) | fail
            seen := 1
         }
      }
      if /seen then
         return error("cannot resolve package " || p)
      return
   end

   public gen_symbol_names()
      suspend key(symbol_table)
   end

   public gen_symbols()
      suspend .!symbol_table
   end

   public add_builtins()
      local x
      every x := !BUILTINS do
         symbol_table[x] := BuiltinSymbol(x)
   end

   public gb_locate(name)
      local x
      if x := glocate(name) then
         return x
      if member(BUILTINS, name) then
         return symbol_table[name] := BuiltinSymbol(name)
   end

   public glocate(name)
      return .\symbol_table[name]
   end

   public get_scanned_file(f)
      return .\scanned_files[get_stem(Files.get_path(f).canonical().str())]
   end

   public resolve_n(sf, name)
      local r, i
      r := []
      name ? if upto('.') then {
         if ="default." then
            name := tab(0)
         put(r, gb_locate(name))
         return r
      }
      if \sf.pack then
         put(r, glocate(sf.pack || "." || name))
      else
         put(r, gb_locate(name))
      every i := sf.get_imports() do {
         if /i.qualified | i.has(name) then
            put(r, glocate(i.name || "." || name))
      }
      if \sf.pack & (*r = 0) then
         put(r, gb_locate(name))
      return r
   end

   public resolve(sf, name)
      local l
      l := resolve_n(sf, name) | fail
      if *l = 0 then
         return error("Couldn't resolve symbol " || name)
      if *l > 1 then
         return error("Ambiguous symbol " || name)
      return l[1]
   end

   public resolve_classes()
      resolve_invocables() | fail
      resolve_supers() | fail
      compute_inheritance() | fail
      return
   end

   public gen_type(c)
      local e
      every e := !symbol_table do
         if is(e, c) then
            suspend e
   end

   private resolve_invocables()
      local sf, s, x
      every sf := !scanned_files do {
         every s := sf.get_invocables() do {
            x := resolve(sf, s) | fail
            sf.add_resolved_invocable(x)
         }
      }
      return
   end

   private resolve_supers()
      local c, sup_name, sup
      every c := gen_type(ClassSymbol) do {
         every sup_name := c.get_supers() do {
            sup := resolve(c.scanned_file, sup_name) | fail
            is(sup, ClassSymbol) | return error("Superclass of " || c.name || " not a class")
            c.add_resolved_super(sup)
         }
      }
      return
   end

   private compute_inheritance()
      local c, queue, seen, x
      every c := gen_type(ClassSymbol) do {
         seen := set()
         queue := [c]
         while x := pop(queue) do {
            if member(seen, x) then
               next
            insert(seen, x)
            c.add_implemented_class(x)
            every put(queue, !x.resolved_supers)
         }
      }
      return
   end

   public set_file_mode(s)
      self.file_mode := s
   end

   protected set_one(f)
      case f.attr of {
         "file_mode" : set_file_mode(f.string_val())
         default : fail
      }
      return
   end

   public new(a[])
      cast(self,Connectable).new()
      symbol_table := table()
      scanned_files := table()
      scanned_packages := set()
      file_mode := PREFER_SRC
      set_fields(a)
      return
   end
end
