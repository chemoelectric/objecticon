#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package util

import lang, ipl.scan(max_many), ipl.strings(replace)

final abstract class Format()
   public static const
      SIG_DIGITS

   private static init()
      # Max number of significant digits output by numeric_to_string
      SIG_DIGITS := 14
   end
      
   #
   # Convert an integer to a string.
   #
   # @param base   The desired base of the result.
   # @param p      The minimum width of the result, padding with zeroes
   # @             if necessary.
   #
   public static int_to_string(subject, base, p)
      local s, n, digs, neg
      s := ""
      /base := 16
      /p := 1
      n := integer(subject) | runerr(101, subject)
      if n < 0 then {
         n := -n
         neg := 1
      }
      digs := "0123456789ABCDEF"[1:base + 1] | runerr("invalid base", base)
      while n > 0 do {
         s := digs[n % base + 1] || s
         n /:= base
      }

      if p > *s then
         s := repl("0", p - *s) || s

      if \neg then
         s := "-" || s

      return s
   end

   #
   # Convert a numeric to a string.
   #
   # @param p  The number of decimal places to produce (default 4).
   # @param f  A cset of flags.  If c contains {'e'} then the output is
   # @         in scientific notation.  If c contains {','} then commas
   # @         are introduced into the non-fractional part of the number;
   # @         if c contains {'+'} then a leading + is added to positive
   # @         numbers.  If c contains {'s'} then trailing fractional
   # @         zeroes are replaced with spaces, whilst {'z'} means drop
   # @         such zeroes altogether.
   # @           
   #
   public static numeric_to_string(subject, p, f)
      local n1, s, t, lim, d, zs, dig, i, n

      /f := ''
      n := numeric(subject) | runerr(102, subject)
      /p := 4
      n1 := abs(n)
      if not any(f, "e") & type(n1) == "integer" then 
         s := string(n1) || repl("0", p)
      else {
         t := norm(n1)
         lim := if any(f, "e") then p else p + t[2]
         if lim >= -1 then {
            s := ""
            d := t[1]
            if lim > SIG_DIGITS then {
               zs := repl("0", lim - SIG_DIGITS)
               lim := SIG_DIGITS
            }
            every 0 to lim do {
               s ||:= dig := integer(d)
               d := (d - dig) * 10.0
            }
            if integer(d) >= 5 then {
               (every i := *s to 1 by -1 do
                if s[i] := 10 > s[i] + 1 then break
                else s[i] := 0
                ) | {          # need to add 1 to left of s
                   s := "1" || s
                   if any(f, "e") then {
                      s[-1] := ""
                      t[2] +:= 1
                   }
                }
            }
            s ||:= \zs
            s := repl("0", 0 < p + 1 - *s) || s
         } 
         else s := repl("0", p + 1)
      }

      if any(f, ",") then
         every s[*s - p - 3 to 1 by -3] ||:= ","

      if p > 0 then {
         s[-p - 1] ||:= "."
         if any(f, "s"| "z") then {
            "0" ~== s[i := *s to *s - p + 1 by -1]         
            s[i + 1 : 0] := if any(f, "s") then
               repl(" ", *s - i)
            else ""
         }
      }
      if n < 0 & upto('123456789', s) then
         s := "-" || s
      else
         if any(f, "+") then 
            s := "+" || s

      return if any(f, "e") then
         s || "E" || (if t[2] < 0 then "-" else "+") || 
         right(abs(t[2]), 3, "0")
      else s   
   end

   private static norm(n)
      local m, e, ve
      static pwr
      initial pwr := [1e1, 1e2, 1e4, 1e8, 1e16, 1e32]

      if n = 0.0 then
         return [0.0, 0]

      m := if n < 1.0 then 1.0 / n else n
      e := 0

      if not(pwr[1 + (ve := 1 to *pwr)] > m) then {
         while m /:= (m >= pwr[ve]) do
            e +:= 2 ^ (ve - 1)
         ve -:= 1
      }

      # invariant : 1 <= m < pwr[1 + ve] & m * 10 ^ e = m0 
      while m >= 10.0 do {
         if m /:= (m >= pwr[ve]) then
            e +:= 2 ^ (ve - 1)
         ve -:= 1
      }

      if n < 1.0 then {
         e := -e
         if m := 10.0 / (1.0 ~= m) then 
            e -:= 1
      }
      return [m, e]
   end

   private static unescape_char(ch)
      return case string(ch) of {
         "n": "\n"
         "l": "\l"
         "b": "\b"
         "d": "\d"
         "e": "\e"
         "r": "\r"
         "t": "\t"
         "v": "\v"
         "f": "\f"
         default:  ch
      }
   end

   #
   # Remove escape sequences from the subject.
   #
   public static unescape(subject)
      local res
      res := ""
      subject ? repeat {
         res ||:= string(tab(upto('\\') | 0))
         move(1) | break
         res ||:= string(if any('01234567') then
                         char(iand("8r" || tab(max_many('01234567', 3)), 8r377))
         else if ="x" then
         char("16r" || tab(max_many(&digits ++ 'abcdefABCDEF', 2)))
         else if ="u" then
         uchar("16r" || tab(max_many(&digits ++ 'abcdefABCDEF', 4)))
         else if ="U" then
         uchar("16r" || tab(max_many(&digits ++ 'abcdefABCDEF', 6))) |
         return error("code point out of range")
         else if ="^" then
         char(iand(ord(move(1)), 8r37))
         else 
         unescape_char(move(1))) | "\0"
      }
      return if type(subject) == "ucs" then ucs(res) | error("invalid utf-8 escape sequence") else res
   end

   #
   # Remove escape sequences from the subject, but return the corresponding cset rather than
   # a string.
   #
   public static cset_unescape(subject)
      local l, state, c, prev, esc_flag
      state := 0
      l := []
      subject ? until pos(0) do {
         if any('\\') then {
            esc_flag := &yes
            move(1)
            c := (if any('01234567') then
                  iand("8r" || tab(max_many('01234567', 3)), 8r377)
            else if ="x" then
            integer("16r" || tab(max_many(&digits ++ 'abcdefABCDEF', 2)))
            else if ="u" then
            integer("16r" || tab(max_many(&digits ++ 'abcdefABCDEF', 4)))
            else if ="U" then
            (16r10FFFF >= integer("16r" || tab(max_many(&digits ++ 'abcdefABCDEF', 6)))) |
            return error("code point out of range")
            else if ="^" then
            iand(ord(move(1)), 8r37)
            else 
            ord(unescape_char(move(1)))) | 0
         } else {
            esc_flag := &no
            c := ord(move(1))
         }

         case state of {
            0: {
               prev := c
               state := 1
            }
            1 : {
               if /esc_flag & (c = 45) then
                  state := 2
               else {
                  put(l, prev)
                  put(l, prev)
                  prev := c
               }                     
            }
            2 : {
               put(l, prev)
               put(l, c)
               state := 0
            }
         }
      }
      if state = 1 then {
         put(l, prev)
         put(l, prev)
      }
      else if state = 2 then
         return error("incomplete cset range");
      return Text.create_cset(l)
   end

   #
   # Unescape a string in shell escape format.
   #
   public static shell_unescape(s)
      local t, ch
      t := ""
      s ? repeat {
         t ||:= tab(upto('\\') | 0)
         ch := (move(1), move(1)) | break
         t ||:= ch
      }
      return t
   end

   # Convert a string into shell format by escaping certain special
   # shell characters.
   #
   public static shell_escape(s)
      local t, ch
      t := ""
      s ? repeat {
         t ||:= tab(upto('|\\*?@+&#()<>[]({}!$`\'\" ') | 0)
         ch := move(1) | break
         t ||:= "\\" || ch
      }
      return t
   end

   # Convert a string into rc shell format by enclosing in single quotes
   #
   public static rc_escape(s)
      return if upto('=^|*?&#()<>[]{}$`\' ', s) then
         "'" || replace(s, "'", "''") || "'"
      else
         s
   end

   #
   # Convert the subject integer into words, eg 231 to "Two Hundred and Thirty-One"
   #
   public static int_to_words(subject)
      local n, s, i, m
      static small, tens, pwr10, pwr10num

      initial {
         small := ["One", "Two", "Three", "Four", "Five", "Six",
                   "Seven", "Eight", "Nine", "Ten", "Eleven", 
                   "Twelve", "Thirteen", "Fourteen", "Fifteen",
                   "Sixteen", "Seventeen", "Eighteen", "Nineteen"]

         tens := ["Ten", "Twenty", "Thirty", "Forty", "Fifty", "Sixty",
                  "Seventy", "Eighty", "Ninety"]

         pwr10 := ["Million", "Thousand", "Hundred"]

         pwr10num := [1000000, 1000, 100]
      }

      n := integer(subject) | runerr(101, subject)

      s := ""

      every i := 1 to *pwr10num do
         if (m := n / pwr10num[i]) > 0 then {
            if *s > 0 then
               s ||:= " "

            s ||:= int_to_words(m) || " " || pwr10[i]

            n %:= pwr10num[i]
         }

      if n = 0 then {
         if *s = 0 then
            s := "Zero"
      } else {
         if *s > 0 then
            s ||:= " and "

         if n < 20 then
            s ||:= small[n]
         else {
            s ||:= tens[n / 10]
            if n % 10 > 0 then
               s ||:= "-" || small[n % 10]
         }
      }

      return s
   end
end
