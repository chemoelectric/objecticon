import 
   gui,
   io,
   posix,
   graphics,
   net,
   lang,
   util,
   xdg,
   ipl.lists,
   ipl.options,
   ipl.sort,
   ipl.pdco,
   ipl.wildcard,
   ipl.functional,
   ipl.filegui,
   ipl.childwait,
   ipl.vt,
   ipl.columnize,
   ipl.strings,
   ipl.browser,
   ipl.io

global opts, glob_cmds

$if _PNG
$load HOURGLASS "rpp.HOURGLASS_24.png"
$load KEYBOARD "rpp.KEYBOARD_24.png"
# Named HELP1 to avoid a clash with Key.HELP
$load HELP1 "rpp.HELP_64.png"
$load ABOUT "rpp.ABOUT_64.png"
$else
$load HOURGLASS "rpp.HOURGLASS_24.gif"
$load KEYBOARD "rpp.KEYBOARD_24.gif"
$load HELP1 "rpp.HELP_64.gif"
$load ABOUT "rpp.ABOUT_64.gif"
$endif
$load EXIT "rpp.EXIT_24.gif"
$load FLOWTERM_LOGO "rpp.FLOWTERM_LOGO.png"

abstract class Runner()
   public abstract get_command()
end

class ImmediateRunner(Runner)
   public const
      cmd

   public override get_command()
      return cmd
   end

   public new(cmd)
      self.cmd := cmd
      return
   end
end

abstract class ExternalRunner(Runner)
   public abstract get_working_dir()

   public abstract get_command_list()
end

class LaunchRunner(ExternalRunner)
   public const
      cmd,
      wd

   public override get_working_dir()
      return \wd
   end

   public override get_command()
      return cmd
   end

   public override get_command_list()
      return ["/bin/sh", "-c", "exec " || get_command()]
   end

   public new(cmd, wd)
      self.cmd := cmd
      self.wd := wd
      return
   end
end

class DesktopRunner(ExternalRunner)
   public const
      # The DesktopEntry giving the command and other parameters.
      desktop_entry,
      # The string to substitute to create a command to run
      subst,
      # The url itself (a URL object).
      url

   public override get_working_dir()
      return \desktop_entry.path
   end

   private line_param()
      local line
      if url.scheme == "file" then
         line := integer(url.extract_cgi_parameters()["line"][1])
      return line
   end

   public override get_command()
      return desktop_entry.subst_file_shell(subst, line_param())
   end

   public override get_command_list()
      return desktop_entry.subst_file_list(subst, line_param())
   end

   public new(desktop_entry, url, subst)
      self.desktop_entry := desktop_entry
      self.url := url
      self.subst := subst
      return
   end
end

class OpenWithMenu(MenuWithPopup)
   private const
      term

   public override create_popup(item)
      return Menu().
         add(TextMenuItem().
                connect(create term.copy_text(item.runner.get_command()),
                        Event.ACTION).
                set_label("Copy command"))
   end

   public override new(term)
      MenuWithPopup.new()
      self.term := term
      return
   end
end

class OpenWithMenuItem(TextMenuItem)
   public const
      runner

   public override new(runner)
      TextMenuItem.new()
      self.runner := runner
      return
   end
end

class TerminalMenu(DynamicMenu)
   public override populate()
      move_all(parent_component.parent_dialog.tabs.which_one.create_context_menu())
   end
end

class ColumnsMenu(DynamicMenu)
   public override populate()
      move_all(parent_component.parent_dialog.tabs.which_one.create_columns_context_menu())
   end
end

class MiscMenu(DynamicMenu)
   public override populate()
      move_all(parent_component.parent_dialog.tabs.which_one.create_misc_menu())
   end
end

class FlowTermDialog(Dialog)
   private readable
      favourite_dirs,
      tabs,
      menu_bar,
      file_dialog

   public
      last_log_file

   private on_quit(ev)
      dispose()
   end

   public goto_tab(t)
      tabs.set_which_one(t)
      on_tabs_changed()
   end

   public do_tab_cmd(l)
      local s, t, cmd
      # l is a list of strings (not ucs).
      t := tabs.which_one
      while s := get(l) do {
         s ? if =":" then {
            cmd := tab(0)
            \t | return error("Command before tab directory: " || cmd)
            t.do_tab_cmd(cmd) | fail
         } else {
            done_tab_cmds(t)
            t := Terminal(if *s > 0 then s else &null,, tabs.which_one) | fail
         }
      }
      done_tab_cmds(t)
      link
   end

   public done_tab_cmds(t)
      local a
      # Add t if it's not already added in the TabSet
      if /(\t).parent then {
         a := if \t.adjacent_flag then tabs.which_one
         add_tab(t, a)
         if \t.select_flag | /tabs.which_one then
            goto_tab(t)
      }
   end

   private add_tab(t, adjacent)
      local i
      t.set_is_hidden(&yes)
      i := tabs.get_index(\adjacent) + 1
      tabs.add(t, i)
      if is_live() then
         tabs.do_layout().invalidate()
   end

   public new_tab(sel, dir, other, adjacent)
      local t
      t := Terminal(dir, other, tabs.which_one) | {
         tabs.which_one.info_msg(&why)
         fail
      }
      add_tab(t, adjacent)
      if \sel then
         goto_tab(t)
      return t
   end

   private on_new_tab(ev)
      new_tab(&yes)
   end

   private on_xdg_refresh(ev)
      IconTheme.refresh()
      Mime.refresh()
      tabs.which_one.info_msg("XDG database reloaded")
   end

   private on_html_click(url)
      tabs.which_one.open_link(url)
   end

   private show_html(src)
      local d
      d := HTMLMessageDialog().
         set_label("FlowTerm")
      d.browser.
         set_accepts_focus(&no).
         set_border(NullBorder()).
         set_page(src).
         set_size(scale(550), scale(350)).
         connect(on_html_click, SimpleBrowser.LINK_LEFT_CLICKED)
      d.show_modal(self)
   end

   private on_about(ev)
      show_html("<html><h1><img src=img:rpp.ABOUT_64 width=64 height=64 align=absmiddle/>&nbsp;About FlowTerm</h1>_
<h2>Author</h2>Robert Parlett_
<h2>Contact</h2><a href=mailto:2rparlett@gmail.com</a>2rparlett@gmail.com</a>_
<h2>Version</h2>" || &version ||
"</html>")
   end

   private on_help(ev)
      show_html("<html><h1><img src=img:rpp.HELP_64 width=64 height=64 align=absmiddle/>&nbsp;FlowTerm Help</h1>_
FlowTerm is a terminal emulator which uses web-like hyperlinks._
<p>_
It requires an additional set of programs, <i>FlowTerm extras</i>, in order to be fully functional._
<p>_
Simple command line option help can be obtained by running :-_
<pre>    flowterm -help</pre>_
<p>_
Full documentation can be found at <a href=\"http://objecticon.sourceforge.net/FlowTerm.html\">this page</a>._
<p>_
The FlowTerm extras can be downloaded <a href=\"https://sourceforge.net/projects/objecticon/files/misc/flowterm-extras.tar.gz/download\">here</a>._
</html>")
   end

   private on_favourite_dirs(ev)
      FavouriteDirectoriesDialog().show_modal(self)
   end

   public override component_setup()
      local i, t
      t := \tabs.which_one | tabs.children[1]
      if i := \opts["width"] then {
         t.output.
            set_width().
            set_vt_width(i)
      } else
         set_width(scale(1200))

      if i := \opts["height"] then {
         t.output.
            set_height().
            set_vt_height(i)
      } else
         set_height(scale(850))
   end

   private on_tabs_rpress(e)
      local t, m, pm
      t := tabs.which_tab(e) | fail
      m := Menu().
         add(TextMenuItem().
             set_label("New").
             connect(create t.new_tab(), Event.ACTION)).
         add(TextMenuItem().
             set_label("Close").
             connect(create t.close_tab(), Event.ACTION)).
         add(TextMenuItem().
             set_label("Clone").
             connect(create t.clone_tab(), Event.ACTION)).
         add(MenuSeparator()).
         move_all(tabs.which_one.create_link_menu(mk_file_URL(t.cwd)))
      pm := PopupMenu().
         connect(create tabs.set_which_highlight(), Event.POPUP_CLOSED)
      tabs.set_which_highlight(t)
      pm.popup(self, m, e.x, e.y)
   end

   private on_tabs_mpress(e)
      local t
      t := tabs.which_tab(e) | fail
      tabs.which_one.insert_link(mk_file_URL(t.cwd), e)
   end

   private on_tabs_changed(e)
      tabs.which_one.tab_active()
   end

   public override new()
      local quit_menu_item, file_menu, terminal_menu, columns_menu, 
         new_tab_item, favourite_dirs_item, xdg_refresh_item,
         help_menu, misc_menu, about_item, help_item
      Dialog.new()
      set_resize(&yes)
      file_dialog := FileDialog().set_remember_size(&yes)
      new_tab_item := TextMenuItem().
         connect(on_new_tab, Event.ACTION).
         set_label("New Tab")
      favourite_dirs_item := TextMenuItem().
         connect(on_favourite_dirs, Event.ACTION).
         set_label("Favourite dirs...")
      xdg_refresh_item := TextMenuItem().
         connect(on_xdg_refresh, Event.ACTION).
         set_label("Refresh XDG")
      quit_menu_item := TextMenuItem().
         connect(on_quit, Event.ACTION).
         set_label("Quit")
      file_menu := Menu().
         set_label("File").
         add(new_tab_item).
         add(favourite_dirs_item).
         add(xdg_refresh_item).
         add(quit_menu_item)
      terminal_menu := TerminalMenu().
         set_label("Terminal")
      columns_menu := ColumnsMenu().
         set_label("List")
      misc_menu := MiscMenu().
         set_label("Misc")
      help_item := TextMenuItem().
         connect(on_help, Event.ACTION).
         set_label("Help...")
      about_item := TextMenuItem().
         connect(on_about, Event.ACTION).
         set_label("About...")
      help_menu := Menu().
         set_label("Help").
         add(help_item).
         add(about_item)
      menu_bar := MenuBar().
         set_size(scale(100)).
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("l_inset", 0).
         set_constraint("r_inset", 0).
         set_constraint("t_inset", 0).
         set_constraint("b_inset", 0).
         set_constraint("x_fill", &yes).
         add(file_menu).
         add(columns_menu).
         add(terminal_menu).
         add(misc_menu).
         add(help_menu)
      self.add(menu_bar)
      tabs := TabSet().
         clear_constraints().
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("y_fill", &yes).
         set_constraint("y_weight", 1.0).
         set_constraint("l_inset", 0).
         set_constraint("r_inset", 0).
         set_constraint("t_inset", 0).
         set_constraint("b_inset", 0).
         set_remember_focus(&yes).
         set_draggable_tabs(&yes).
         set_accepts_focus(&no).
         connect(on_tabs_rpress, Event.MOUSE_RIGHT_PRESS).
         connect(on_tabs_mpress, Event.MOUSE_MIDDLE_PRESS).
         connect(on_tabs_changed, Event.SELECTION_CHANGED)
      self.add(tabs)
      self.connect(self.on_quit, Event.WINDOW_CLOSE_BUTTON)
      self.set_layout(GridLayout().set_extra("cells"))
      set_label(\opts["t"] | "FlowTerm")
      return
   end
end

class Columns(LineBasedScrollArea)
   private readable
      data,
      item_border,
      item_paint,
      gutter,
      held,
      over,
      highlight,
      multi_begin,
      cursor

   private
      quieten,
      data_w,
      col_w,
      n_rows,
      prev_columnize_dw

   public static 
      FOCUS_DASHED_WIDTH

   private static init()
      local v
      if v := scale(\opts["lfw"]) then {
         if v < 1 then
            help_stop("Invalid -lfw: scaled value >= 1 required")
      }
      FOCUS_DASHED_WIDTH := \v | Gui.DASHED_WIDTH
   end

   public override initially()
      \self.item_paint | runerr("ItemPaint not set")
      LineBasedScrollArea.initially()
      self.item_paint.initially(self)
      self.item_border.initially(self)
   end

   public override finally()
      LineBasedScrollArea.finally()
      self.item_paint.finally()
      self.item_border.finally()
   end

   #
   # Set a border to draw along with each item.
   #
   public set_item_border(b)
      if is_initialized() then {
         (\self.item_border).finally()
         self.item_border := b
         self.item_border.initially(self)
      } else
         self.item_border := b
      link
   end

   public set_item_paint(r)
      if is_initialized() then {
         (\self.item_paint).finally()
         self.item_paint := r
         self.item_paint.initially(self)
      } else
         self.item_paint := r
      link
   end

   public override get_tooltip(e)
      local t, s
      if t := object_get_over() then {
         s := item_paint.get_size(view.cbwin, t)
         if s.w + item_border.get_total_width() > view.w + get_area_x() then
            return t.annotation
      }
   end

   public override draw_line(xp, yp, lh, i)
      local e, j, r, s, k, W
      every j := 1 to *col_w do {
         k := i + (j - 1) * n_rows
         e := data[k] | break
         s := item_paint.get_size(view.cbwin, e)
         r := Rect(xp, yp, s.w + item_border.get_total_width(), lh)
         if k === highlight then  {
            use {
               W := view.cbwin.clone(),
               {
                  W.set_fg(Style.FOCUS_COLOR)
                  item_paint.draw_rect(W, e, item_border.float(r, s))
                  item_border.draw_rect(W, r)
               }
            }
         } else {
            item_paint.draw_rect(view.cbwin, e, item_border.float(r, s))
            item_border.draw_rect(view.cbwin, r)
         }
         if k === cursor then {
            if should_draw_focus() then
               item_border.draw_focus_rect(view.cbwin, r, FOCUS_DASHED_WIDTH)
            else
               item_border.draw_dashed_rect(view.cbwin, r)
         }
         if k === over then 
            Gui.style.fill_over_rectangle(view.cbwin, r.x, r.y, r.w, r.h)
         xp +:= col_w[j] + gutter
      }
   end

   public override calculate_subject_width()
      do_columnize(predict_view_width(w, vsb))
      return col_w[1]
   end

   private invalidate_columnize()
      data_w := prev_columnize_dw := &null
      link
   end

   public override focus_changed(e) 
      if is_live() then
         invalidate_line(get_row_for_index(\cursor))
   end

   public override layout()
      invalidate_subject_width()
      invalidate_line_count()
      ScrollArea.layout()
   end

   public override set_internal_fields()
      local had_vsb
      had_vsb := self.vsb
      ScrollArea.set_internal_fields()
      if had_vsb ~=== self.vsb then {
         invalidate_subject_width()
         invalidate_line_count()
         ScrollArea.set_internal_fields()
      }
   end

   public override get_default_subject_height(dw)
      do_columnize(dw)
      return n_rows * get_line_height()
   end

   private do_columnize(dw)
      local cr, tb
      if \prev_columnize_dw &
         (dw = prev_columnize_dw |
          (*col_w = 1 & dw < prev_columnize_dw)) then
         return
      prev_columnize_dw := dw
      if /data_w then {
         tb := item_border.get_total_width( )
         data_w := ipl.pdco.List{ item_paint.get_width(view.cbwin, (!data)) + tb }
      }
      cr := columnize(data_w, dw, gutter)
      n_rows := cr.rows
      col_w := cr.width
   end

   public override calculate_line_height()
      return item_paint.get_constant_height(view.cbwin) + item_border.get_total_height() | runerr("Need a constant height")
   end

   public override calculate_line_count()
      do_columnize(predict_view_width(w, vsb))
      return n_rows
   end

   public get_element_under_pointer(e)
      local i, j, d, s, r, xp, yp, fs, k
      i := get_line_under_pointer(e) | fail
      xp := get_subject_x()
      yp := get_subject_y() + get_line_height() * (i - 1)
      every j := 1 to *col_w do {
         if xp <= e.x < xp + col_w[j] then {
            k := i + (j - 1) * n_rows
            d := data[k] | fail
            s := item_paint.get_size(view.cbwin, d)
            r := Rect(xp, yp, col_w[j], get_line_height())
            fs := item_border.float(r, s)
            if fs.inside(e.x, e.y) then
               return k
            else
               fail
         }
         xp +:= col_w[j] + gutter
      }
   end

   public quieten_cursor()
      (/quieten & parent_dialog.get_held_count() = 0) | fail
      set_over()
      # No need to synch_pointer since we call this method out of the
      # vt's keyboard handler.
      quieten := &yes
   end

   public unquieten_cursor()
      quieten := &null
   end

   private handle_move(ev)
      unquieten_cursor()
   end

   private handle_in_chain(e)
      local k, f
      (/quieten & parent_dialog.get_held_count() = 0) | fail
      if e.code === (Key.CONTROL_L | Key.CONTROL_R) then {
         if /e.release then
            f := &yes
      } else f := \e.ctrl
      if /f & (k := get_element_under_pointer(e)) then
         set_over(k)
      else
         set_over()
   end

   private handle_exit(e)
      parent_dialog.get_held_count() = 0 | fail
      set_over()
   end

   private handle_interrupted(e)
      set_highlight()
      set_over()
      held := &null
   end

   public set_over(n)
      if n ~=== over then {
         invalidate_line(get_row_for_index(\over))
         over := n
         invalidate_line(get_row_for_index(\over))
         view.set_pointer(if /over then &null else "hand1")
         fire("over-changed")
      }
      link
   end

   public handle_lmdrag(e)
      if \held = get_element_under_pointer(e) then {
         set_highlight(held)
         set_over(held)
      } else {
         set_highlight()
         set_over()
      }
   end

   public handle_lrelease(e)
      \held | fail
      if \over then {
         set_highlight()
         fire("lclicked", e)
      }
      held := &null
   end

   public handle_mrelease(e)
      \held | fail
      if \over then {
         set_highlight()
         fire("mclicked", e)
      }
      held := &null
   end

   public get_row_for_index(n)
      return (n - 1) % \n_rows + 1
   end

   public get_col_for_index(n)
      return (n - 1) / \n_rows + 1
   end

   public set_cursor(n)
      if cursor ~=== n then {
         invalidate_line(get_row_for_index(\cursor))
         cursor := n
         constrain_cursor()
         invalidate_line(get_row_for_index(\cursor))
      }
      link
   end

   public set_highlight(n)
      if highlight ~=== n then {
         set_cursor(\n)
         invalidate_line(get_row_for_index(\highlight))
         highlight := n
         ensure_line_visible(get_row_for_index(\highlight)) 
         invalidate_line(get_row_for_index(\highlight))
      }
      link
   end

   public get_highlight()
      return .\highlight
   end

   public get_held()
      return .\held
   end

   public get_over()
      return .\over
   end

   public object_get_cursor()
      return data[\cursor]
   end

   public object_get_multi_begin()
      return data[\multi_begin]
   end

   public object_get_over()
      return data[\over]
   end

   public object_set_cursor(o)
      return set_cursor(keyof(data, o))
   end
   
   public get_cursor()
      return .\cursor
   end

   public get_multi_begin()
      return .\multi_begin
   end

   public handle_lpress(e)
      parent_dialog.get_held_count() = 1 | fail
      if \over then {
         if /e.shift then {
            set_highlight(over)
            held := over
         } else {
            set_cursor(over)
            ensure_line_visible(get_row_for_index(over)) 
         }
      } 
   end

   public handle_mpress(e)
      parent_dialog.get_held_count() = 1 | fail
      if \over then {
         set_multi_begin(cursor)
         set_highlight(over)
         held := over
      } 
   end

   public handle_key_page_up(e)
      local t
      t := get_page_movement(cursor, -1)
      t <:= n_rows * (get_col_for_index(cursor) - 1) + 1
      return t
   end

   public handle_key_page_down(e)
      local t
      t := get_page_movement(cursor, 1)
      t >:= n_rows * get_col_for_index(cursor)
      return t
   end

   public handle_key_up(e)
      return cursor - 1
   end

   public handle_key_down(e)
      return cursor + 1
   end

   public handle_key_left(e)
      local t
      (cursor > 1) | fail
      t := cursor - n_rows
      if t < 1 then {
         t +:= *col_w * n_rows - 1
         if t > *data then
            t -:= n_rows
      }
      return t
   end

   public handle_key_right(e)
      local t
      t := cursor + n_rows
      if t > *data then {
         t := (t - 1) % n_rows + 2
         t <= n_rows | fail
      }
      return t
   end

   public handle_key_home(e)
      return 1
   end

   public handle_key_end(e)
      return *data
   end

   public handle_return(e)
      local t
      \cursor | fail
      ensure_line_visible(get_row_for_index(cursor))
      set_highlight(cursor)
      t := Dispatcher.new_task{{
         t.sleep(Gui.VISUALIZE_DELAY)
         set_highlight()
         fire("lclicked", e)
         t.revert()
      }}
      t.start()
   end

   private handle_key_move(f)
      \cursor | fail
      set_cursor(f())
      ensure_line_visible(get_row_for_index(cursor))
   end

   public handle_key(e)
      case e.code of {
         Key.HOME : handle_key_move(handle_key_home)
         Key.END : handle_key_move(handle_key_end)
         Key.PGUP : handle_key_move(handle_key_page_up)
         Key.PGDN : handle_key_move(handle_key_page_down)
         Key.UP : handle_key_move(handle_key_up)
         Key.DOWN : handle_key_move(handle_key_down)
         Key.LEFT : handle_key_move(handle_key_left)
         Key.RIGHT : handle_key_move(handle_key_right)
         "\r" | "\l": handle_return(e)
      }
   end

   public constrain_cursor()
      if *data = 0 then
         cursor := &null
      else {
         /cursor := 1
         cursor <:= 1
         cursor >:= *data
      }
   end

   public set_multi_begin(d)
      self.multi_begin := d
      link
   end

   public set_held(d)
      self.held := d
      link
   end

   public data_changed()
      # multi_begin, over, held and highlight are cleared, since we
      # store these as indices (which may change) rather than the
      # underlying objects.  cursor is left, however, and so the
      # underlying object may change.
      set_over()
      set_held()
      set_highlight()
      set_multi_begin()
      invalidate_columnize()
      invalidate_subject_width()
      invalidate_line_count()
      compute_and_invalidate()
      constrain_cursor()
      link
   end

   public set_data(l)
      self.data := l
      data_changed()
      link
   end

   public set_gutter(n)
      self.gutter := n
      link
   end

   public override keeps(e)
      succeed member(Key.CURSOR, e.code)
   end

   public override new()
      LineBasedScrollArea.new()
      data := []
      gutter := scale(8)
      item_paint := TextItemPaint()
      item_border := NullBorder().set_x_align(Align.L)
      view.
         connect(handle_lpress, Event.MOUSE_LEFT_PRESS).
         connect(handle_mpress, Event.MOUSE_MIDDLE_PRESS).
         connect(handle_lmdrag, Event.MOUSE_LEFT_DRAG).
         connect(handle_lrelease, Event.MOUSE_LEFT_RELEASE).
         connect(handle_lmdrag, Event.MOUSE_MIDDLE_DRAG).
         connect(handle_mrelease, Event.MOUSE_MIDDLE_RELEASE).
         connect(handle_in_chain, Event.IN_POINT_CHAIN).
         connect(handle_exit, Event.MOUSE_EXIT).
         connect(handle_move, Event.MOUSE_MOVEMENT)
      connect(handle_interrupted, Event.INTERRUPTED)
      connect(handle_key, Event.KEY_PRESS)
      return
   end
end

procedure mk_file_URL(s)
   return URL(ucs(Files.file_to_url(s)))
end

class FilterEditList(EditList)
   protected override open_popup(ev)
      local t
      t := parent.parent
      set_selection_only()
      synch_set_selection_list(t.get_filter_list())
      EditList.open_popup(ev)
   end

   public override create_view()
      return TextField().
         set_border(EmptyBorder().set_l_inset(Gui.TEXT_INSET).set_r_inset(Gui.TEXT_INSET))
   end
end

#
# Helper class for the common bits of the three directory list classes below.
#
abstract class ListHelper(DropDown)
   private on_popup_menu_closed(ev, src)
      if /src.selected then
         popup.clear_selections()
      else
         close_popup()
   end

   protected open_popup_menu(e, m)
      local pm
      pm := PopupMenu().
         connect(on_popup_menu_closed, Event.POPUP_CLOSED)
      pm.popup(popup, m, e.x, e.y)
      popup.set_selections([popup.get_cursor()])
   end
end

class FavouritesList(ButtonOnlyList, ListHelper)
   public override create_button()
      local b
      b := IconButton().set_paint(ImagePaint().set_cache("gui.FAVOURITES_24"))
      theme_toolbar_button(b, "emblem-favorite")
      return b
   end

   private cursor_to_url()
      return mk_file_URL(popup.object_get_cursor())
   end

   private on_rpress(e)
      open_popup_menu(e, parent.parent.create_link_menu(cursor_to_url()))
   end

   private on_mrelease(ev)
      popup.get_cursor() = popup.get_line_under_pointer(ev) | fail
      parent.parent.insert_link(cursor_to_url(), ev)
      close_popup()
   end

   protected override open_popup(ev)
      local t
      t := parent.parent
      set_selection_list(t.get_favourites_directories())
      object_set_selection(t.cwd) | set_selection()
      ButtonOnlyList.open_popup(ev)
   end

   public override create_popup()
      local l
      l := ItemPaintList().
         set_item_paint(StringDirItemPaint()).
         set_item_border(EmptyBorder().
                            set_insets(Gui.TEXT_INSET, Gui.TEXT_INSET, 0, 0).
                            set_x_align(Align.L))
      l.view.
         connect(on_rpress, Event.MOUSE_RIGHT_PRESS).
         connect(on_mrelease, Event.MOUSE_MIDDLE_RELEASE)
      return l
   end
end

record ShellVar(key, value)

# Store objects rather than just strings in the history list to avoid
# confusion when the dir changes whilst the history list is open.
# With just strings we wouldn't be able to match up the selected
# string with a position in the (possibly changed) history.

record HistoryEntry(dir)

class HistoryEntryItemPaint(StringDirItemPaint)
   public override get_string(data)
      return data.dir
   end
end

class HistoryList(ButtonOnlyList, ListHelper)
   public override create_button()
      local b
      b := IconButton().set_paint(ImagePaint().set_cache("rpp.HOURGLASS_24"))
      theme_toolbar_button(b, "view-history")
      return b
   end

   private cursor_to_url()
      return mk_file_URL(popup.object_get_cursor().dir)
   end

   private on_rpress(e)
      open_popup_menu(e, parent.parent.create_link_menu(cursor_to_url()))
   end

   private on_mrelease(ev)
      popup.get_cursor() = popup.get_line_under_pointer(ev) | fail
      parent.parent.insert_link(cursor_to_url(), ev)
      close_popup()
   end

   protected override open_popup(ev)
      local t
      t := parent.parent
      set_selection_list(copy(t.history))
      set_selection(t.history_pos)
      ButtonOnlyList.open_popup(ev)
   end

   public override create_popup()
      local l
      l := ItemPaintList().
         set_item_paint(HistoryEntryItemPaint()).
         set_item_border(EmptyBorder().
                            set_insets(Gui.TEXT_INSET, Gui.TEXT_INSET, 0, 0).
                            set_x_align(Align.L))
      l.view.
         connect(on_rpress, Event.MOUSE_RIGHT_PRESS).
         connect(on_mrelease, Event.MOUSE_MIDDLE_RELEASE)
      return l
   end
end

class FileTrailListEx(FileTrailList, ListHelper)
   private cursor_to_url()
      return mk_file_URL(p.child(popup.object_get_cursor().name).ucs())
   end

   private on_rpress(e)
      open_popup_menu(e, parent.parent.parent.create_link_menu(cursor_to_url()))
   end

   private on_mrelease(ev)
      popup.get_cursor() = popup.get_line_under_pointer(ev) | fail
      parent.parent.parent.insert_link(cursor_to_url(), ev)
      close_popup()
   end

   public override create_popup()
      local l
      l := FileTrailList.create_popup()
      l.view.
         connect(on_rpress, Event.MOUSE_RIGHT_PRESS).
         connect(on_mrelease, Event.MOUSE_MIDDLE_RELEASE)
      return l
   end
end

class FileTrailButtonEx(FileTrailButton)
   private button_to_url()
      return mk_file_URL(p.ucs())
   end

   private on_rpress(e)
      local m, pm
      m := parent.parent.parent.create_link_menu(button_to_url()) | fail
      pm := PopupMenu().
         connect(create set_border_whilst_entered(&yes), Event.POPUP_CLOSED)
      set_border_whilst_entered(&no)
      pm.popup(self, m, e.x, e.y)
   end

   private on_mrelease(ev)
      parent.parent.parent.insert_link(button_to_url(), ev)
   end

   public override new(p, tt)
      FileTrailButton.new(p, tt)
      connect(on_rpress, Event.MOUSE_RIGHT_PRESS)
      connect(on_mrelease, Event.MOUSE_MIDDLE_RELEASE)
      return
   end   
end

class FileTrailEx(FileTrail)
   public override create_trail_list(p, child)
      return FileTrailListEx(p, child)
   end

   public override create_trail_button(p, tt)
      return FileTrailButtonEx(p, tt)
   end
end

record MenuCommand(label, verb)

class Terminal(TabItem, VtUI)
   public static const
      SHOW_NAME_ONLY,
      SHOW_DATE,
      SHOW_SIZE,
      DEFAULT_HISTORY_SIZE,
      DEFAULT_LIST_WIDTH,
      DEFAULT_LIST_HEIGHT

   private
      prev_button,
      next_button,
      date_button,
      name_button,
      size_button,
      favourites_list,
      message_label,
      search_panel,
      search_field,
      search_label, 
      search_close_button,
      search_next_button,
      search_prev_button, 
      history_list,
      trail,
      best_focus,         # Either columns or output (the vt)
      log_file,
      log,
      terminal_menu_commands,
      columns_menu_commands,
      misc_menu_commands

   private readable
      ascending,
      sorter,
      annotate_opt,
      filter,
      refresh_button,
      up_button,
      home_button,
      close_button,
      focus_columns_button,
      output,
      columns,
      split,
      columns_pos_table,
      history,
      history_pos,
      io_task,
      check_cwd_time_task,
      pid, 
      tty,
      input,
      cwd,
      cwd_mtime,
      cwd_list,
      show_hidden_menu_item,
      mix_entries_menu_item,
      sort_dirs_menu_item,
      filter_dirs_menu_item,
      dont_quieten_menu_item,
      revert_tab,
      adjacent_flag,
      shell,
      shell_args,
      shell_vars,
      auto_close_flag,
      select_flag,
      title,
      history_size,
      added_favourites

   private static init()
      SHOW_NAME_ONLY := "name only"
      SHOW_DATE := "date"
      SHOW_SIZE := "size"
      DEFAULT_HISTORY_SIZE := env_int("OI_FLOWTERM_DEFAULT_HISTORY_SIZE", 1) | 100
      DEFAULT_LIST_WIDTH := env_real("OI_FLOWTERM_DEFAULT_LIST_WIDTH", 50) | 300
      DEFAULT_LIST_HEIGHT := env_real("OI_FLOWTERM_DEFAULT_LIST_HEIGHT", 50) | 300
   end

   public set_select(f)
      self.select_flag := need_flag(f)
      link
   end

   public set_adjacent(f)
      self.adjacent_flag := need_flag(f)
      link
   end

   public set_auto_close(f)
      self.auto_close_flag := need_flag(f)
      link
   end

   public set_shell(s)
      self.shell := s
      link
   end

   public add_shell_arg(s)
      put(shell_args, string(s))
      link
   end

   public add_shell_var(s)
      local k, v
      string(s) ? {
         if k := tab(find("=")) then {
            move(1)
            v := tab(0)
         } else
            k := tab(0)
      }
      put(shell_vars, ShellVar(k, v))
      link
   end

   public override get_label_width()
      return scale(100)
   end

   public override link_left_clicked(url)
      open_link(url)
   end

   public override vt_size_changed(cols, rows)
      if \opts["v"] then
         write("Vt size changed to: ", cols, ",", rows)
      tty.set_size(cols, rows)
   end

   public set_title(s)
      self.title := s
      update_title()
      link
   end

   public set_list_width(n)
      columns.set_width(n)
      if is_live() then {
         split.first.set_width().reset_layout()
         split.do_layout().invalidate()
      }
      link
   end

   public set_list_height(n)
      columns.set_height(n)
      if is_live() then {
         split.first.set_height().reset_layout()
         split.do_layout().invalidate()
      }
      link
   end

   private check_live(s)
      return is_live() | error(s || " only applies to an already open tab")
   end

   private check_new(s)
      return not is_live() | error(s || " only applies to a new tab")
   end

   private check_param(s, param)
      return \param | error(s || " expects a parameter")
   end

   private check_flag_param(s, param)
      return flag(\param) | error(s || " expects a flag parameter")
   end

   public do_tab_cmd(s)
      local param
      s := ucs(s) | return error("Not a ucs string")
      s ? if s := tab(upto('=')) then
         param := (move(1), tab(0))
      case map(string(s)) of {
         "sh" : {
            check_new(s) | fail
            set_shell(param)
         }
         "sh-arg" : {
            check_new(s) | fail
            add_shell_arg(param)
         }
         "sh-var" : {
            check_new(s) | fail
            add_shell_var(param)
         }
         "run" : {
            check_param(s, param) | fail
            run_prog(param)
         }
         "font" : {
            check_param(s, param) | fail
            output.set_vt_font(param) | return error("Invalid parameter to font: " || &why)
         }
         "font-size" : {
            check_live(s) | fail
            check_param(s, param) | fail 
            do_change_vt_font_size(param) | fail
         }
         "key" : {
            check_param(s, param) | fail
            do_custom_key(param) | fail
         }
         "terminal-menu" : {
            check_param(s, param) | fail
            do_custom_menu(terminal_menu_commands, param) | fail
         }
         "list-menu" : {
            check_param(s, param) | fail
            do_custom_menu(columns_menu_commands, param) | fail
         }
         "misc-menu" : {
            check_param(s, param) | fail
            do_custom_menu(misc_menu_commands, param) | fail
         }
         "reset-keys" : output.reset_custom_keys()
         "reset-terminal-menus" : do_reset_custom_menus(terminal_menu_commands)
         "reset-list-menus" : do_reset_custom_menus(columns_menu_commands)
         "reset-misc-menus" : do_reset_custom_menus(misc_menu_commands)
         "fg": output.set_normal_fg(param) | return error("Invalid parameter to fg: " || &why)
         "bg": output.set_normal_bg(param) | return error("Invalid parameter to bg: " || &why)
         "reverse-fg": output.set_reverse_fg(param) | return error("Invalid parameter to reverse-fg: " || &why)
         "reverse-bg": output.set_reverse_bg(param) | return error("Invalid parameter to reverse-bg: " || &why)
         "scroll": {
            /param := Vt.DEFAULT_HISTORY_SIZE
            param := (0 <= integer(param)) | return error("Integer >= 0 expected to scroll")
            output.set_history_size(param)
         }
         "list-width": {
            /param := DEFAULT_LIST_WIDTH
            param := (0 <= integer(param)) | return error("Integer >= 0 expected to list-width")
            set_list_width(scale(param))
         }
         "list-height": {
            /param := DEFAULT_LIST_HEIGHT
            param := (0 <= integer(param)) | return error("Integer >= 0 expected to list-height")
            set_list_height(scale(param))
         }
         "auto-close" : {
            /param := &yes
            param := check_flag_param(s, param) | fail
            set_auto_close(param)
         }
         "dont-quieten" : {
            if /param then
               toggle_dont_quieten_menu_item()
            else {
               param := check_flag_param(s, param) | fail
               (param === dont_quieten_menu_item.get_status()) | toggle_dont_quieten_menu_item()
            }
         }
         "title" : set_title(param)
         "fav-dir" : {
            check_param(s, param) | fail
            push(added_favourites, FilePath(param).canonical().ucs())
         }
         "max-list" : {
            if /param then {
               if /split.second.is_hidden_flag then
                  on_max_list()
               else
                  on_restore()
            } else {
               param := check_flag_param(s, param) | fail
               if /param then
                  on_restore()
               else
                  on_max_list()
            }
         }
         "max-term" : {
            if /param then {
               if /split.first.is_hidden_flag then
                  on_max_terminal()
               else
                  on_restore()
            } else {
               param := check_flag_param(s, param) | fail
               if /param then
                  on_restore()
               else
                  on_max_terminal()
            }
         }
         "adjacent" : {
            check_new(s) | fail
            /param := &yes
            param := check_flag_param(s, param) | fail
            set_adjacent(param)
         }
         "list-focus" : {
            if /param then
               toggle_focus_columns_button()
            else {
               param := check_flag_param(s, param) | fail
               # We call on_focus_columns_button() even if the state
               # is already set to param so that the focus is sure to
               # be set to the list (if on) or the terminal (if off).
               focus_columns_button.set_is_checked(param)
               on_focus_columns_button()
            }
         }
         "reorient" | "re-orient" : {
            if /param then
               on_reorient()
            else {
               param := check_flag_param(s, param) | fail
               (param === split.sizer.is_horizontal_flag) | on_reorient()
            }
         }
         "sort-name" : {
            if /param then
               on_name_button()
            else {
               param := check_flag_param(s, param) | fail
               do_set_sort(Files.name_cmp, param)
            }
         }
         "sort-date" : {
            if /param then
               on_date_button()
            else {
               param := check_flag_param(s, param) | fail
               do_set_sort(Files.date_cmp, param)
            }
         }
         "sort-size" : {
            if /param then
               on_size_button()
            else {
               param := check_flag_param(s, param) | fail
               do_set_sort(Files.size_cmp, param)
            }
         }
         "show-name-only" : on_show_name_only()
         "show-date" : {
            if /param then {
               if annotate_opt === SHOW_DATE then
                  on_show_name_only()
               else
                  on_show_date()
            } else {
               param := check_flag_param(s, param) | fail
               if /param then
                  on_show_name_only()
               else
                  on_show_date()
            }
         }
         "show-size" : {
            if /param then {
               if annotate_opt === SHOW_SIZE then
                  on_show_name_only()
               else
                  on_show_size()
            } else {
               param := check_flag_param(s, param) | fail
               if /param then
                  on_show_name_only()
               else
                  on_show_size()
            }
         }
         "mix-entries" : {
            if /param then
               toggle_mix_entries_menu_item()
            else {
               param := check_flag_param(s, param) | fail
               (param === mix_entries_menu_item.get_status()) | toggle_mix_entries_menu_item()
            }
         }
         "show-hidden" : {
            if /param then
               toggle_show_hidden_menu_item()
            else {
               param := check_flag_param(s, param) | fail
               (param === show_hidden_menu_item.get_status()) | toggle_show_hidden_menu_item()
            }
         }
         "sort-dirs" : {
            if /param then
               toggle_sort_dirs_menu_item()
            else {
               param := check_flag_param(s, param) | fail
               (param === sort_dirs_menu_item.get_status()) | toggle_sort_dirs_menu_item()
            }
         }
         "filter-dirs" : {
            if /param then
               toggle_filter_dirs_menu_item()
            else {
               param := check_flag_param(s, param) | fail
               (param === filter_dirs_menu_item.get_status()) | toggle_filter_dirs_menu_item()
            }
         }
         "select" : {
            check_new(s) | fail
            /param := &yes
            param := check_flag_param(s, param) | fail
            set_select(param)
         }
         "history": {
            /param := DEFAULT_HISTORY_SIZE
            param := (0 < integer(param)) | return error("Integer > 0 expected to history")
            history_size := param
         }
         "search" : {
            if /param then
               toggle_search_panel()
            else {
               param := check_flag_param(s, param) | fail
               (param === Yes{split.second.get_index(search_panel)}) | toggle_search_panel()
            }
         }
         "start-log" : {
            check_live(s) | fail
            start_log(param)
         }
         "end-log" : {
            check_live(s) | fail
            on_end_log()
         }
         "string": {
            check_param(s, param) | fail
            output.put_user_string(param)
         }
         "send-vt": {
            check_live(s) | fail
            check_param(s, param) | fail
            send_vt(param)
         }
         "send-tty": {
            check_param(s, param) | fail
            send_tty(param)
         }
         "filter": {
            /param := u"*"
            filter.set_contents(param)
            resort_cwd(&yes)
         }
         "url" : {
            check_live(s) | fail
            check_param(s, param) | fail
            param := URL(param) | return error("Invalid url: " || &why)
            open_link(param)
         }
         "copy-cwd": {
            check_live(s) | fail
            on_copy_cwd()
         }
         "copy": {
            check_live(s) | fail
            output.handle_copy()
         }
         "copy-urls": {
            check_live(s) | fail
            output.handle_copy_links()
         }
         "paste": {
            check_live(s) | fail
            # The artificial event is for the benefit of insert_link()
            handle_paste(WinEvent(,,,, 0))
         }
         "paste-alt": {
            check_live(s) | fail
            handle_paste(WinEvent(,,,, Key.MOD_META))
         }
         "paste-escaped": {
            check_live(s) | fail
            handle_paste_escaped()
         }
         "pgup": {
            check_live(s) | fail
            output.handle_pgup()
         }
         "pgdn": {
            check_live(s) | fail
            output.handle_pgdn()
         }
         "top": {
            check_live(s) | fail
            output.goto_top()
         }
         "bottom": {
            check_live(s) | fail
            output.goto_bottom()
         }
         "select-all": {
            check_live(s) | fail
            output.handle_select_all()
         }
         "close-tab": {
            check_live(s) | fail
            close_tab()
         }
         "clone-tab": {
            check_live(s) | fail
            clone_tab()
         }
         "new-tab": {
            check_live(s) | fail
            new_tab()
         }
         "quit": {
            check_live(s) | fail
            on_quit()
         }
         "home": {
            check_live(s) | fail
            on_home_button()
         }
         "refresh": {
            check_live(s) | fail
            on_refresh_button()
         }
         "up": {
            check_live(s) | fail
            on_up_button()
         }
         "prev": {
            check_live(s) | fail
            on_prev_button()
         }
         "next": {
            check_live(s) | fail
            on_next_button()
         }
         "open-history": {
            check_live(s) | fail
            history_list.on_button_press()
         }
         "open-filter": {
            check_live(s) | fail
            filter.on_button_press()
         }
         "focus-filter": {
            on_focus_filter()
         }
         "open-favourites": {
            check_live(s) | fail
            favourites_list.on_button_press()
         }
         "open-menu": {
            check_live(s) | fail
            if /param then
               parent_dialog.menu_bar.set_which_highlight(parent_dialog.menu_bar.menus[1])
            else {
               param := parent_dialog.menu_bar.menus[integer(param)] | return error("Valid menu index expected for open-menu")
               parent_dialog.menu_bar.set_which_open(param)
            }
         }
         "info": {
            check_live(s) | fail
            check_param(s, param) | fail
            info_msg(param)
         }
         "tab-right": {
            check_live(s) | fail
            on_tab_right()
         }
         "tab-left": {
            check_live(s) | fail
            on_tab_left()
         }
         "move-tab-right": {
            check_live(s) | fail
            on_move_tab_right()
         }
         "move-tab-left": {
            check_live(s) | fail
            on_move_tab_left()
         }
         default: return error("Invalid command: " || s)
      }
      link
   end

   private send_tr_nl(s)
      send_tty(replace(s, u"\n", u"\r"))
   end

   private handle_paste(e)
      output.goto_bottom()
      parent_dialog.request_selection(Selection.CLIPBOARD, 
                                      [Selection.URI_LIST_TARGET, Selection.UTF8_STRING_TARGET, Selection.STRING_TARGET], 
                                      lpartial(handle_paste_response, e))
   end

   private split_url_response(data)
      suspend URL(words(ucs(data), '\r\n'))
   end

   private handle_paste_response(ev, target_type, data)
      if target_type == Selection.URI_LIST_TARGET then
         every insert_link(split_url_response(data), ev)
      else
         send_tr_nl(text_convert(selection_convert(target_type, data), "ucs"))
   end

   private handle_paste_escaped(e)
      output.goto_bottom()
      parent_dialog.request_selection(Selection.CLIPBOARD, 
                                      [Selection.UTF8_STRING_TARGET, Selection.STRING_TARGET], 
                                      lpartial(handle_paste_escaped_response, e))
   end

   private handle_paste_escaped_response(ev, target_type, data)
      send_tty(Format.shell_escape(text_convert(selection_convert(target_type, data), "ucs")))
   end

   private do_change_vt_font_size(s)
      local n
      n := real(s) | return error("Real number expected to font-size")
      if any('+\-', s) then
         n +:= output.font_size
      n <:= 1.0
      output.set_vt_font(output.font_family || "," || n)
      link
   end

   private next_index_right()
      return parent.get_index(self) % *parent.children + 1
   end

   private next_index_left()
      return (parent.get_index(self) + *parent.children - 2) % *parent.children + 1
   end

   private on_tab_right()
      parent_dialog.goto_tab(parent.children[next_index_right()])
   end

   private on_tab_left()
      parent_dialog.goto_tab(parent.children[next_index_left()])
   end

   private on_move_tab_right()
      parent.reposition(self, next_index_right()).
         invalidate_line_break().
         do_layout().
         invalidate()
   end

   private on_move_tab_left()
      parent.reposition(self, next_index_left()).
         invalidate_line_break().
         do_layout().
         invalidate()
   end

   private static parse_key(s)
      local c
      s := string(s)
      return (s[1] == "x" & char(Format.string_to_int(s[2:0]))) |
             (s[1] == "u" & uchar(Format.string_to_int(s[2:0]))) |
             (s := map(s, &lcase, &ucase) & not match("MOD_", s) &
                       c := Class.getq(Key, s) & type(c) == "integer" & c)
   end

   private on_quit()
      parent_dialog.dispose()
   end


   private do_custom_key(param)
      local code, bits, mask, verb
      param ? {
         code := parse_key(tab((upto(',') | 0)\1)) | return error("Invalid key identifier")
         if pos(0) then {
            # Remove all bindings for code.
            output.remove_custom_key(code)
         } else {
            move(1)
            bits := Vt.string_to_key_mask(tab(upto(',')\1)) | return error("Missing or invalid bits number")
            move(1)
            mask := Vt.string_to_key_mask(tab((upto(',') | 0)\1)) | return error("Invalid mask number")
            if pos(0) then {
               output.remove_custom_key(code, bits, mask)
            } else {
               move(1)
               verb := tab(0)
               output.add_custom_key(code, 
                                     bits, 
                                     mask, 
                                     custom_key_func, 
                                     verb) | return error("Failed to add key function: " || &why)
            }
         }
      }
      link
   end

   private remove_menu_command(list, label)
      local e
      if (e := !list).label == label then
         ldel1(list, e)
   end

   private add_menu_command(list, label, verb)
      put(list, MenuCommand(label, verb))
   end

   private do_custom_menu(list, param)
      local label, verb
      param ? {
         label := tab(upto(',') | 0)
         if label == "-" | endswith(label, "/-") then
            # Separator
            add_menu_command(list, label)
         else if pos(0) then {
            # Remove any binding for label.
            remove_menu_command(list, label)
         } else {
            move(1)
            verb := tab(0)
            remove_menu_command(list, label)
            add_menu_command(list, label, verb)
         }
      }
      link
   end

   private static find_menu_child(m, s)
      local e
      every e := !m.children do
         if is(e, TextMenuItem) & e.paint_mid.str == s then
            return e
      e := Menu().set_label(s)
      m.add(e)
      return e
   end

   private create_custom_menu_item(s, c)
      return if s == "-" then
         MenuSeparator()
      else
         TextMenuItem().set_label(s).connect(create custom_key_func(c.verb), Event.ACTION)
   end

   private create_custom_menu(list)
      local res, c, m, s
      res := Menu()
      every c := !list do {
         m := res
         c.label ? {
            while s := tab(upto('/')) do {
               m := find_menu_child(m, s)
               move(1)
            }
            s := tab(0)
            m.add(create_custom_menu_item(s, c))
         }
      }
      return res
   end

   private do_reset_custom_menus(list)
      clear(list)
   end

   private custom_key_func(verb)
      do_tab_cmd(verb) | info_msg(&why)
   end

   private on_max_terminal()
      split.hide_first()
   end

   private on_max_list()
      split.hide_second()
   end

   private on_restore()
      split.hide_neither()
   end

   private on_reorient(e)
      split.reorient()
   end

   public override link_middle_clicked(urls, ev)
      every insert_link(!urls, ev)
   end

   public override quieten_cursor()
      columns.quieten_cursor()
   end

   public override send_tty(s)
      s := need_string(s)
      put(input, s)
      # We may be in the io_task already since some writes to the vt
      # cause it to output something (eg device attr string).  So in
      # that case we must not interrupt.  Otherwise, the io_task
      # must be sleeping in poll().  Interrupt it so it goes round
      # its loop again, and polls for both input and output.
      /io_task | (Dispatcher.get_curr_task() === io_task) | io_task.interrupt()
      link
   end

   public override msg(s, n)
      message_label.set(s, n)
   end

   private static env_put(env, key, val)
      local i
      key ||:= "="
      every i := 1 to *env do {
         if match(key, env[i]) then {
            if /val then
               delete(env, i)
            else
               env[i] := key || val
            return
         }
      }
      if \val then
         put(env, key || val)
   end

   private setup_shell()
      local env, sh, xd, fp, s, sh2, t, v
      env := System.environ()
      every v := !shell_vars do
         env_put(env, v.key, v.value)
      env_put(env, "FLOWTERM", "1")
      env_put(env, "TERM", "xterm")
      sh := \shell | System.getpw(System.getuid()).shell
      if /sh | *sh = 0 then
         sh := "/bin/sh"
      if /opts["nx"] then {
         s := \opts["x"] | Files.get_home() || "/flowterm-extras"
         fp := FilePath(s).child("bin").canonical()
         xd := fp.str()
         if Files.access(xd) then {
            env_put(env, "PATH", xd || ":" || System.getenv("PATH"))
            t := FilePath(sh).get(-1)
            if t == ("bash" | "zsh") then {
               sh2 := fp.child(t).str()
               if Files.access(sh2) then
                  sh := sh2
               else
                  info_msg("Unable to access extras " || t || " shell '" || sh2 || "'")
            }
         } else
            info_msg("Unable to access extras bin directory '" || xd || "'")
      }
      tty := PttyStream() | fail
$if _DARWIN
      # Darwin doesn't seem to allow NONBLOCK flag on a tty
      (pid := System.fork()) | {
         save_why{ tty.close() }
         fail
      }
$else
      (tty.flag(FileOpt.NONBLOCK) &
       pid := System.fork()) | {
          save_why{ tty.close() }
          fail
      }
$endif
      if pid > 0 then {
         # Parent
         return
      } else {
         # Child
         System.setsid() | stop(&why)
         tty.close()
         tty := tty.open_slave() | stop(&why)
         tty.dup2(FileStream.stdout) | stop(&why)
         tty.dup2(FileStream.stdin) | stop(&why)
         tty.dup2(FileStream.stderr) | stop(&why)
         tty.close()
         Files.chdir(cwd)
         Files.bulk_close(50)
         System.exec(sh, shell_args, env) | stop(&why)
         syserr("Not reached")
      }
   end

   private static on_shell_exit(r)
      if \opts["v"] then
         write("Shell process exited: ", to_string(r))
   end

   public get_pats()
      return ipl.pdco.List{ Wildcard(separate(filter.get_contents(), ';')) }
   end

   public tab_active()
      # The tab has been selected; check for a cwd change in case the
      # cd has been renamed or deleted in another tab.
      if is_live() then
         check_cwd_change()
   end

   private check_cwd_change()
      set_cwd(cwd ~== ucs(System.getcwd(pid)))
   end

   private update_grey()
      prev_button.set_is_shaded(No{ history_pos < *history })
      next_button.set_is_shaded(No{ history_pos > 1 })
   end

   private send_vt(s)
      output.input(s)
   end

   private check_cwd_time()
      local t
      repeat {
         if t := get_ns_mtime(cwd) then {
            if t ~= cwd_mtime then
               refresh_cwd()
         }
         check_cwd_time_task.sleep(500)
      }
   end

   private service_tty()
      local x, s, n, i, some_in
      repeat {
         # The some_in flag ensures we don't send anything to the tty
         # until we've seen some input (a prompt).  This is since
         # readline will misinterpret what's in the buffer before it
         # starts up, muddling up \n with \r, because readline clears the
         # ICRNL bit in the termios c_iflag structure (see rltty.c).
         i := if *input > 0 & \some_in then Poll.IN + Poll.OUT else Poll.IN
         x := io_task.poll([tty, i]) | {
            if /io_task.interrupt_why then {
               err_msg("IO problem polling tty: " || &why)
               break
            } else {
               # We were interrupted, meaning that some input has gone into the
               # buffer; so go round again.
               next
            }
         }
         if DescStream.poll_out_test(x[1]) then {
            s := get(input) | syserr("Poll out, but input buffer empty")
            n := tty.out(s) | {
               err_msg("IO problem on tty output: " || &why)
               break
            }
            if n < *s then
               push(input, s[n + 1:0])
            if \opts["v"] then
               write("Out: ", image(s[1:n + 1]))
         } else if DescStream.poll_in_test(x[1]) then {
            s := tty.in(1048576) | {
$if _LINUX
               # See notes for explanation
               if x[1] = Poll.IN & errno() = Errno.EAGAIN then {
                  if \opts["v"] then
                     write("Got Poll.IN and EAGAIN reading tty: continuing")
                  next
               }
$endif
               err_msg("IO problem on tty input: " || &why)
               break
            }
            if /s then {
               err_msg("EOF on tty")
               break
            }
            if \opts["v"] then
               write("In: ", image(s))
            (\log).writes1(s)
            send_vt(s)
            check_cwd_change()
            some_in := &yes
         } else {
            tty.improve_why()
            err_msg("IO problem on tty, neither poll in or out ready: " || &why)
            break
         }
      }
      if \auto_close_flag then
         # invoke later since we can't call finally() from within the io_task
         parent_dialog.invoke_later{close_tab()}
      io_task.revert()
   end

   public static launch_prog(runner)
      local pid, cmd, args
      if \opts["v"] then write("Launch runner: ", to_string(runner, 3, &yes))
      pid := System.fork() | fail
      if pid > 0 then {
         # Parent
         ChildWait.add_pid(pid, on_prog_exit)
         return
      }
      # Set the working directory for the child process
      Files.chdir(runner.get_working_dir() | Files.get_home())
      # Get the command to run, as a list.
      args := runner.get_command_list()
      cmd := pop(args) | stop("Empty command list")
      System.setpgid()
      null_stdio()
      Files.bulk_close(50)
      System.exec(cmd, args) | stop(&why)
      syserr("Not reached")
   end

   private static on_prog_exit(r)
      if \opts["v"] then
         write("Child application exited: ",to_string(r))
   end

   private do_clone(l)
      local t, cmd
      t := Terminal(, self, self)
      every cmd := !l do {
         # We will get an empty string with just a "clone:" URL.
         if *cmd > 0 then 
            t.do_tab_cmd(cmd) | fail
      }
      parent_dialog.done_tab_cmds(t)
      finish_clone(t)
      link
   end

   private static get_ucs_decoded_path(url)
      return ucs(url.get_decoded_path()) | error("URL decoded path not UTF-8")
   end

   public open_link(url)
      local r
      case string(url.scheme) of {
         "text": send_tty(get_ucs_decoded_path(url)) | info_msg(&why)
         "tab": {
            parent_dialog.do_tab_cmd(ipl.pdco.List{ URL.percent_decode(separate(url.get_path(), ';')) }) |
               info_msg(&why)
         }
         "clone": {
            do_clone(ipl.pdco.List{ URL.percent_decode(separate(url.get_path(), ';')) }) |
               info_msg(&why)
         }
         default: {
            if r := get_runners(url) then {
               if is(r, ExternalRunner) then
                  launch_prog(r)
               else
                  run_prog(r.get_command())
            } else
               info_msg(&why)
         }
      }
   end

   public insert_link(url, ev)
      local s, es, r
      case string(url.scheme) of {
         "file": {
            if s := get_ucs_decoded_path(url) then {
               es := if /ev.meta & /ev.meta5 & url.is_local_file() & cwd ~== "/" then {
                  if cwd == s then
                     u"./"
                  else if match(cwd || "/", s) then
                     u"./" || s[*cwd + 2:0]
                  else
                     s
               } else
                  s
               es := Format.shell_escape(es)
               if url.is_local_file() & Files.is_directory(s) then {
                  if es[-1] ~== "/" then
                     es ||:= "/"
               }
               send_tty(es || " ")
            } else
               info_msg(&why)
         }
         "text": send_tty(get_ucs_decoded_path(url) || " ") | info_msg(&why)
         "run" | "launch": {
            if r := get_runners(url) then
               send_tty(r.get_command() || " ")
            else
               info_msg(&why)
         }
         default:
            send_tty(url.ucs() || " ")
      }
   end

   public err_msg(s)
      send_vt("\n\e[31m(Message from terminal:) " || s || "\e[m")
      info_msg(s)
   end

   private get_runners(url, ex_dir)
      local s, cd, de, fl
      case string(url.scheme) of {
         "file" : {
            url.is_local_file() | return error("Can't run a file on another host (" || url.host || ")")
            s := get_ucs_decoded_path(url) | fail
            if /ex_dir & Files.is_directory(s) then
               return ImmediateRunner("cd " || Format.shell_escape(s))
            every de := Mime.gen_desktop_entries_for_path(s) do {
               fl := &yes
               suspend DesktopRunner(de, url, s)
            }
            return if /fl then error("No matching desktop entry for this URL")
         }
         "run" : {
            s := get_ucs_decoded_path(url) | fail
            return ImmediateRunner(s)
         }
         "launch" : {
            s := get_ucs_decoded_path(url) | fail
            if cd := member(url.extract_cgi_parameters(), "wd")[1] then
               cd := ucs(cd) | return error("CD decoded path not UTF-8")
            return LaunchRunner(s, cd)
         }
         default : {
            every de := Mime.gen_desktop_entries("x-scheme-handler/" || string(url.scheme)) do {
               fl := &yes
               suspend DesktopRunner(de, url, url.ucs())
            }
            return if /fl then error("No desktop entry for url scheme " || url.scheme)
         }
      }
   end

   private on_columns_lclick()
      local item
      if item := columns.object_get_cursor() then
         open_link(item_to_url(item))
   end

   private item_to_url(item)
      return mk_file_URL(FilePath(cwd).child(item.name).ucs())
   end

   private on_columns_mclick(ev)
      local item, r, i, j
      if \ev.shift & i := columns.get_cursor() & j := columns.get_multi_begin() then
         r := if i > j then columns.data[j + 1:i + 1] else columns.data[i:j]
      /r := [columns.object_get_cursor()]
      every item := !\r do
         insert_link(item_to_url(item), ev)
   end

   private on_columns_over_changed(ev)
      local item
      if item := columns.object_get_over() then
         msg(item_to_url(item).ucs())
      else
         msg()
   end

   public copy_text(s)
      parent_dialog.own_selection(Selection.CLIPBOARD, 
                                  StaticTextSelectionOwner(s))
   end

   public copy_url(url)
      parent_dialog.own_selection(Selection.CLIPBOARD,
                                  URLSelectionOwner([url]))
   end 

   private on_copy_cwd(e)
      copy_text(cwd)
   end

   private open_in_new_tab(dir)
      parent_dialog.new_tab(, dir,, self)
   end

   private on_start_log(e)
      start_log()
   end

   private start_log(dest)
      local d, dl, fl, s
      /log | return info_msg("Already logging to " || log_file.ucs())
      if /dest then {
         d := parent_dialog.file_dialog
         dl := [cwd]
         fl := [u"log"]
         if \parent_dialog.last_log_file then {
            push(dl, parent_dialog.last_log_file.parent().ucs())
            push(fl, parent_dialog.last_log_file.get(-1))
         }
         if \log_file then {
            push(dl, log_file.parent().ucs())
            push(fl, log_file.get(-1))
         }
         d.set_directories(dl).
            set_files(fl).
            set_existing_file_mode(FileDialog.WARN).
            show_modal(parent_dialog)
         dest := d.get_result_path() | fail
      } else
         dest := FilePath(dest).canonical()
      s := dest.ucs() | return info_msg(u"Log file not UTF-8")
      if log := open(s, "w") then {
         parent_dialog.last_log_file := log_file := dest
         info_msg("Logging to file " || s)
      } else
         info_msg("Failed to open " || s || ": " || ucs(&why))
   end

   private close_log()
      \log | fail
      log.close()
      log := &null
   end

   private on_end_log()
      \log | return info_msg("Not logging")
      close_log()
      info_msg("Closed log file " || log_file.ucs())
   end

   private add_custom_menus(m, list)
      local t
      m.move_all(create_custom_menu(list))
      # Tidy recursively.
      every t := Seq{m.traverse_postorder()} do
         if is(t, Menu) then
            t.tidy()
      return m
   end

   public override create_context_menu()
      local m
      m := Menu()
      if output.get_current_text_selection() then
         m.add(TextMenuItem().
               set_label("Copy text").
               connect(output.handle_copy, Event.ACTION))
      if output.get_current_links_selection() then
         m.add(TextMenuItem().
               set_label("Copy URLs").
               connect(output.handle_copy_links, Event.ACTION))
      m.add(TextMenuItem().
            set_label("Paste").
            connect(handle_paste, Event.ACTION))
      m.add(TextMenuItem().
            set_label("Paste escaped").
            connect(handle_paste_escaped, Event.ACTION))
      m.add(TextMenuItem().
            set_label("Select all").
            connect(output.handle_select_all, Event.ACTION))
      m.add(MenuSeparator())
      m.add(TextMenuItem().
            set_label("Reorient").
            connect(on_reorient, Event.ACTION))
      if /split.first.is_hidden_flag then
         m.add(TextMenuItem().
               set_label("Maximize").
               connect(on_max_terminal, Event.ACTION))
      if \split.sizer.is_hidden_flag then
         m.add(TextMenuItem().
               set_label("Restore").
               connect(on_restore, Event.ACTION))
      if not search_panel.is_live() then
         m.add(TextMenuItem().
               set_label("Search").
               connect(open_search_panel, Event.ACTION))
      if /log then
         m.add(TextMenuItem().
               set_label("Log...").
               connect(on_start_log, Event.ACTION))
      else
         m.add(TextMenuItem().
               set_label("End log").
               connect(on_end_log, Event.ACTION))

      return add_custom_menus(m, terminal_menu_commands)
   end

   public create_misc_menu()
      local m
      m := Menu().
         add(dont_quieten_menu_item)

      return add_custom_menus(m, misc_menu_commands)
   end

   private on_open_with(ev, src)
      local r
      r := src.runner
      if ev.code === Mouse.MIDDLE_RELEASE then
         send_tty(r.get_command() || " ")
      else
         launch_prog(r)
   end

   private create_open_with_menu_item(r)
      local m, de
      de := r.desktop_entry
      m := OpenWithMenuItem(r).
         set_label(de.name).
         connect(on_open_with, Event.ACTION)
      m.set_paint_left(ImagePaint().set_cache(IconTheme.find_icon_and_cache(\de.icon, Gui.MENU_ICON_SIZE, &yes)))
      return m
   end

   private create_open_with_menu(url)
      local m, r
      m := OpenWithMenu(self).set_label("Open with")
      every r := get_runners(url, &yes) do {
         if is(r, DesktopRunner) then
            m.add(create_open_with_menu_item(r))
      }
      if *m.children > 0 then
         return m
   end

   public override create_link_menu(url)
      local m, r, udp
      m := Menu()
      if url.scheme == ("file" | "text") &
         udp := get_ucs_decoded_path(url) then
      {
         m.add(TextMenuItem().
               set_label("Copy").
               connect(create copy_text(udp), Event.ACTION))
      }
      m.add(TextMenuItem().
            set_label("Copy URL").
            connect(create copy_url(url), Event.ACTION))
      if r := get_runners(url) then
         m.add(TextMenuItem().
            set_label("Copy command").
            connect(create copy_text(r.get_command()), Event.ACTION))
      if url.scheme == "file" then {
         if url.is_local_file() & \udp then {
            if Files.is_directory(udp) then {
               m.add(TextMenuItem().
                     set_label("Open in new tab").
                     connect(create open_in_new_tab(udp), Event.ACTION))
            }
            m.add(create_open_with_menu(url))
         }
      } else
         m.add(create_open_with_menu(url))
      return m
   end

  private on_columns_rpress(e)
      local i, m, pm, item, url
      pm := PopupMenu()
      if item := columns.data[i := columns.get_over()] then {
         url := item_to_url(item) | fail
         columns.set_highlight(i).set_over()
         m := create_link_menu(url)
         pm.connect(on_popup_closed, Event.POPUP_CLOSED)
      } else
         m := create_columns_context_menu()
      pm.popup(parent_dialog, m, e.x, e.y)
   end

   public override get_tab_tooltip()
      if tab_w - label_border.get_total_width() < cbwin.text_width(paint.str) then
         return paint.str
   end

   private on_show_name_only(e)
      annotate_opt ~===:= SHOW_NAME_ONLY | fail
      annotate_cwd_list()
      columns.data_changed()
   end

   private on_show_date(e)
      annotate_opt ~===:= SHOW_DATE | fail
      annotate_cwd_list()
      columns.data_changed()
   end

   private on_show_size(e)
      annotate_opt ~===:= SHOW_SIZE | fail
      annotate_cwd_list()
      columns.data_changed()
   end

   private toggle_mix_entries_menu_item()
      mix_entries_menu_item.toggle_is_checked()
      on_mix_entries_menu_item()
   end

   private on_mix_entries_menu_item(e)
      annotate_cwd_list()
      resort_cwd()
      sort_dirs_menu_item.set_is_shaded(mix_entries_menu_item.get_status())
   end

   private toggle_sort_dirs_menu_item()
      sort_dirs_menu_item.toggle_is_checked()
      on_sort_dirs_menu_item()
   end

   private on_sort_dirs_menu_item(e)
      annotate_cwd_list()
      resort_cwd()
   end

   private toggle_filter_dirs_menu_item()
      filter_dirs_menu_item.toggle_is_checked()
      on_filter_dirs_menu_item()
   end

   private on_filter_dirs_menu_item(e)
      resort_cwd(&yes)
   end

   private toggle_dont_quieten_menu_item()
      dont_quieten_menu_item.toggle_is_checked()
      on_dont_quieten_menu_item()
   end

   private on_dont_quieten_menu_item(e)
      output.set_dont_quieten(dont_quieten_menu_item.get_status())
   end

   private toggle_show_hidden_menu_item()
      show_hidden_menu_item.toggle_is_checked()
      on_show_hidden_menu_item()
   end

   private on_show_hidden_menu_item(e)
      resort_cwd(&yes)
   end

   public create_columns_context_menu()
      local m
      m := Menu()
      if annotate_opt ~=== SHOW_NAME_ONLY then
         m.add(TextMenuItem().
            set_label("Name only").
            connect(on_show_name_only , Event.ACTION))
      if annotate_opt ~=== SHOW_DATE then
         m.add(TextMenuItem().
            set_label("Show date").
            connect(on_show_date, Event.ACTION))
      if annotate_opt ~=== SHOW_SIZE then
         m.add(TextMenuItem().
            set_label("Show size").
            connect(on_show_size, Event.ACTION))
      m.add(MenuSeparator())
      m.add(mix_entries_menu_item)
      m.add(show_hidden_menu_item)
      m.add(sort_dirs_menu_item)
      m.add(filter_dirs_menu_item)
      m.add(MenuSeparator())
      m.add(TextMenuItem().
            set_label("Reorient").
            connect(on_reorient, Event.ACTION))
      if /split.second.is_hidden_flag then
         m.add(TextMenuItem().
               set_label("Maximize").
               connect(on_max_list, Event.ACTION))
      if \split.sizer.is_hidden_flag then
         m.add(TextMenuItem().
               set_label("Restore").
               connect(on_restore, Event.ACTION))

      return add_custom_menus(m, columns_menu_commands)
   end

   private on_popup_closed()
      columns.set_highlight()
   end

   private run_prog(s)
      send_tty(s || "\r")
   end

   public goto_dir(d)
      d := ucs(d) | fail
      run_prog("cd " || Format.shell_escape(d))
   end

   private synch_paints_and_resort()
      synch_paints()
      resort_cwd()
   end

   private synch_paints()
      local cp, np, sp, dp, sz
      sz := Gui.TOOLBAR_ICON_SIZE
      cp := CompoundPaint().set_top(ImagePaint().set_cache(if /ascending then "gui.TINY_ARROW_DOWN" else "gui.TINY_ARROW_UP"))
      np := ImagePaint().set_cache(ImageCache.get_scaled_svg_key_alt("gui.FONT_SVG", "gui.FONT_24", sz, sz))
      sp := ImagePaint().set_cache(ImageCache.get_scaled_svg_key_alt("gui.FILESIZE_SVG", "gui.FILESIZE_24", sz, sz))
      dp := ImagePaint().set_cache(ImageCache.get_scaled_svg_key_alt("gui.CLOCK_SVG", "gui.CLOCK_24", sz, sz))
      case sorter of {
         Files.name_cmp: {
            name_button.set_paint(cp.set_bottom(np))
            date_button.set_paint(dp)
            size_button.set_paint(sp)
         }
         Files.size_cmp: {
            name_button.set_paint(np)
            date_button.set_paint(dp)
            size_button.set_paint(cp.set_bottom(sp))
         }
         Files.date_cmp: {
            name_button.set_paint(np)
            date_button.set_paint(cp.set_bottom(dp))
            size_button.set_paint(sp)
         }
      }
   end

   private do_set_sort(sorter, ascending)
      if self.sorter ~=== sorter | self.ascending ~=== ascending then {
         self.sorter := sorter
         self.ascending := ascending
         synch_paints_and_resort()
      }
   end

   private on_date_button(ev)
      if sorter === Files.date_cmp then
         ascending := toggle_flag(ascending)
      else
         sorter := Files.date_cmp
      synch_paints_and_resort()
   end

   private on_name_button(ev)
      if sorter === Files.name_cmp then
         ascending := toggle_flag(ascending)
      else
         sorter := Files.name_cmp
      synch_paints_and_resort()
   end

   private on_size_button(ev)
      if sorter === Files.size_cmp then
         ascending := toggle_flag(ascending)
      else
         sorter := Files.size_cmp
      synch_paints_and_resort()
   end

   private static get_ns_mtime(f)
      local st
      st := Files.stat(f) | fail
      return st.mtime * 1000000000 + st.mtime_ns
   end

   private load_cwd_list()
      cwd_mtime := get_ns_mtime(cwd) | 0
      (cwd_list := Files.ucs_list(cwd, AnnotatedListEntryWithIcon)) | {
         info_msg("Failed to read cwd: " || &why)
         cwd_list := []
      }
   end

   private annotate_cwd_list()
      local e, fl, now
      # flag indicates whether to annotate dirs with size/date
      fl := Yes{ mix_entries_menu_item.is_checked() | sort_dirs_menu_item.is_checked() }
      now := Time.get_system_seconds()
      every e := !cwd_list do {
         if /fl & e.stat.mode_str[1] == "d" then
            e.annotate_name()
         else case annotate_opt of {
            SHOW_NAME_ONLY : e.annotate_name()
            SHOW_DATE : e.annotate_date(now)
            SHOW_SIZE : e.annotate_size()
            default : syserr("Bad annotate_opt")
         }
      }
   end

   private sort_cwd_list()
      local dirs, files, e, s, t, pats, show_hidden, filter_dirs
      pats := get_pats()
      dirs := []
      files := []
      show_hidden := show_hidden_menu_item.get_status()
      filter_dirs := filter_dirs_menu_item.get_status()
      every e := !cwd_list do {
         s := e.name
         t := e.stat.mode_str[1]
         if ((/filter_dirs & t == "d") | (!pats).match_all(s))\1 &
            (\show_hidden | not(Files.is_hidden(s))) then {
            if t == "d" then
               Files.is_relative_dir(s) | put(dirs, e)
            else
               put(files, e)
         }
      }
      if mix_entries_menu_item.is_checked() then
         while put(files, get(dirs))
      else {
         if sort_dirs_menu_item.is_checked() then
            qsort(dirs, if /ascending then sorter else flip(sorter))
         else
            qsort(dirs, Files.name_cmp)
      }
      qsort(files, if /ascending then sorter else flip(sorter))
      columns.set_data(dirs ||| files)
   end

   private resort_cwd(track_cursor)
      local i, ino, prev_ino, info, vis, high, held, over, c
      \cwd | fail
      if is_live() then {
         if \track_cursor & c := columns.get_cursor() then {
            # Set vis to &yes if the last highlight is currently visible; also get the ino of
            # the last highlight.  Note that get_line_info() will fail if the terminal is maximized
            # and the split is horizontal (since columns then has zero height).
            if info := columns.get_line_info() then
               vis := Yes{ info.first_whole <= columns.get_row_for_index(c) 
                                            <= info.last_whole }
            ino := columns.object_get_cursor().stat.ino
            high := Yes{ c = columns.get_highlight() }
            held := Yes{ c = columns.get_held() }
            over := Yes{ c = columns.get_over() }
            prev_ino := columns.object_get_multi_begin().stat.ino
         }
         sort_cwd_list()
         # Search for the old ino in the new data.  If found, set the highlight and if the old
         # cursor was visible, ensure the new one is too.
         if \track_cursor & i := Positions{(!columns.data).stat.ino, \ino} then {
            columns.set_cursor(i).set_multi_begin()
            if \vis then
               columns.ensure_line_visible(columns.get_row_for_index(i))
            if \high then
               columns.set_highlight(i)
            if \held then
               columns.set_held(i)
            if \over then
               columns.set_over(i)
            if i := Positions{(!columns.data).stat.ino, \prev_ino} then
               columns.set_multi_begin(i)
         } else
            columns.set_cursor().set_multi_begin()
         # Since the pointer may be over the files list, update the pointer.
         parent_dialog.resynch_pointer()
      } else
         sort_cwd_list()
   end

   public get_filter_list()
      local e, l, ex
      ex := table(0)
      every e := !cwd_list do {
         (e.stat.mode_str[1] == "d") |
            Files.is_hidden(e.name) |
            (ex[Files.get_extension(e.name)] +:= 1)
      }
      l := [u"*"]
      every e := back(sort(ex, 2)) do
         put(l, "*." || e[1])
      return l
   end

   private refresh_cwd()
      load_cwd_list()
      annotate_cwd_list()
      resort_cwd(&yes)
   end

   private update_title()
      set_paint(AbbreviatedTextPaint(\title | FilePath(cwd).get(-1)))
   end

   private set_cwd(s)
      local lh, t, i
      s := ucs(s) | fail
      if \cwd then {
         lh := columns.object_get_cursor().name
         insert(columns_pos_table, 
                cwd,
                FileDialogPos(lh, columns.get_area_y()))
      }
      cwd := s
      trail.set_path(cwd)
      load_cwd_list()
      annotate_cwd_list()
      sort_cwd_list()

      if is_live() then {
         if t := member(columns_pos_table, cwd) then {
            i := Positions{(!columns.data).name, \t.cursor_name}
            columns.set_area_y(t.area_y).set_area_x(0).set_cursor(i)
         } else
            columns.set_area_y(0).set_area_x(0).set_cursor()
         parent_dialog.resynch_pointer()
      }

      (cwd == history[history_pos].dir) | {
         every 1 to history_pos - 1 do
            pop(history)
         push(history, default.HistoryEntry(cwd))
         history_pos := 1
         while *history > history_size do
            pull(history)
         update_grey()
      }
      update_title()
      link
   end

   public get_favourites_directories()
      return FileDialog.unique_ucs_list{ !added_favourites | FavouriteDirectoriesDialog.gen_directories_plus() }
   end

   private on_trail(ev)
      goto_dir(ev)
   end

   private on_columns_move(ev)
      output.unquieten_cursor()
   end

   private clone_key_table(other)
      local code, entry
      every code := other.output.gen_custom_key_codes() do {
         every entry := other.output.gen_custom_key_entries(code) do {
            output.add_custom_key(code, 
                                  entry.bits,
                                  entry.mask,
                                  custom_key_func,
                                  entry.data) | syserr("Failed to clone existing key table entry")
         }
      }
   end

   public override new(dir, other, revert_tab)
      local start_dir, c, e
      TabItem.new()
      self.revert_tab := revert_tab
      setup()
      setup_search_panel()
      label_border.set_x_align(Align.L)
      columns.
         set_item_paint(AnnotatedIconFilesItemPaint()).
         set_item_border(EmptyBorder().
                             set_insets(Gui.TEXT_INSET, Gui.TEXT_INSET, 0, 0).
                             set_x_align(Align.L)).
         connect(on_columns_lclick, "lclicked").
         connect(on_columns_mclick, "mclicked").
         connect(on_columns_over_changed, "over-changed")
      columns.view.
         connect(on_columns_rpress, Event.MOUSE_RIGHT_PRESS).
         connect(on_columns_move, Event.MOUSE_MOVEMENT)
      trail.
         set_height().
         set_constraint("l_inset", scale(10)).
         connect(on_trail, FileTrail.DIR_CHANGED_EVENT)
      output.
         set_ui(self)
      if \opts["v"] then
         output.set_verbose(&yes)

      sort_dirs_menu_item := CheckBoxMenuItem().
         set_label("Sort dirs").
         set_keep_open_on_shift(&yes).
         connect(on_sort_dirs_menu_item, Event.ACTION)
      mix_entries_menu_item := CheckBoxMenuItem().
         set_label("Mix files & dirs").
         set_keep_open_on_shift(&yes).
         connect(on_mix_entries_menu_item, Event.ACTION)
      show_hidden_menu_item := CheckBoxMenuItem().
         set_label("Show hidden files").
         set_keep_open_on_shift(&yes).
         connect(on_show_hidden_menu_item, Event.ACTION)
      filter_dirs_menu_item := CheckBoxMenuItem().
         set_label("Filter dirs").
         set_keep_open_on_shift(&yes).
         connect(on_filter_dirs_menu_item, Event.ACTION)
      dont_quieten_menu_item := CheckBoxMenuItem().
         set_label("Don't quieten cursor").
         set_keep_open_on_shift(&yes).
         connect(on_dont_quieten_menu_item, Event.ACTION)

      favourites_list.set_size().set_selection_list([])
      filter.set_selection_list([u"*"]).set_use_wheel(&no)
      history_list.set_size().set_selection_list([])
      input := []
      theme_toolbar_button(close_button, "window-close")
      theme_toolbar_button(prev_button, "go-previous")
      theme_toolbar_button(next_button, "go-next")
      theme_toolbar_button(up_button, "go-up")
      theme_toolbar_button(home_button, "go-home")
      theme_toolbar_button(refresh_button, "view-refresh")
      theme_toolbar_button(focus_columns_button, "key-enter")

      if \other then {
         clone_key_table(other)
         if other.focus_columns_button.is_checked() then {
            focus_columns_button.set_is_checked(&yes)
            columns.set_accepts_focus(&yes)
         }
         split.first.set_size(other.split.first.w_spec, other.split.first.h_spec)
         split.second.set_size(other.split.second.w_spec, other.split.second.h_spec)
         columns.set_size(other.columns.w_spec, other.columns.h_spec)
         if \other.split.sizer.is_horizontal_flag then
            split.reorient()
         if \other.split.first.is_hidden_flag then
            on_max_terminal()
         else if \other.split.second.is_hidden_flag then
            on_max_list()
         sorter := other.sorter
         ascending := other.ascending
         annotate_opt := other.annotate_opt
         auto_close_flag := other.auto_close_flag
         c := if \other.is_hidden_flag then other.remembered_focus else other.parent_dialog.get_focus()
         set_remembered_focus(if c === other.columns then columns else output)
         log_file := other.log_file
         output.
            set_normal_fg(other.output.normal_fg).
            set_normal_bg(other.output.normal_bg).
            set_reverse_fg(other.output.reverse_fg).
            set_reverse_bg(other.output.reverse_bg).
            set_font(other.output.font_family || "," || other.output.font_size).
            set_history_size(other.output.get_actual_history_size()) | syserr("Clone output setting failed: " || &why)
         set_shell(other.shell)
         shell_args := copy(other.shell_args)
         shell_vars := copy(other.shell_vars)
         sort_dirs_menu_item.set_is_checked(other.sort_dirs_menu_item.get_status()).
            set_is_shaded(other.sort_dirs_menu_item.is_shaded_flag)
         filter_dirs_menu_item.set_is_checked(other.filter_dirs_menu_item.get_status())
         mix_entries_menu_item.set_is_checked(other.mix_entries_menu_item.get_status())
         show_hidden_menu_item.set_is_checked(other.show_hidden_menu_item.get_status())
         dont_quieten_menu_item.set_is_checked(other.dont_quieten_menu_item.get_status())
         history := clone(other.history)
         history_pos := other.history_pos
         history_size := other.history_size
         terminal_menu_commands := copy(other.terminal_menu_commands)
         columns_menu_commands := copy(other.columns_menu_commands)
         misc_menu_commands := copy(other.misc_menu_commands)
         columns_pos_table := clone(other.columns_pos_table)
         filter.set_contents(other.filter.get_contents())
         added_favourites := clone(other.added_favourites)
         set_cwd(other.cwd)
      } else {
         columns.set_size(scale(DEFAULT_LIST_WIDTH), scale(DEFAULT_LIST_HEIGHT))
         sorter := Files.name_cmp
         annotate_opt := SHOW_NAME_ONLY
         set_remembered_focus(output)
         shell_args := []
         shell_vars := []
         history := []
         history_pos := 0
         history_size := DEFAULT_HISTORY_SIZE
         terminal_menu_commands := []
         columns_menu_commands := []
         misc_menu_commands := []
         columns_pos_table := table()
         if \dir then {
            if dir := Files.realpath(dir) then
               start_dir := ucs(dir) | info_msg("Start directory not UTF-8")
            else
               info_msg("Invalid tab start directory: " || &why)
         }
         /start_dir := ucs(Files.getcwd()) | u"/"
         added_favourites := [start_dir]
         set_cwd(start_dir)
         # Apply global default tab options; should only fail on first time through.
         every e := !glob_cmds do
            do_tab_cmd(e) | fail
      }
      on_dont_quieten_menu_item()
      synch_paints()
      update_grey()
      return
   end

   public override initially()
      TabItem.initially()
      setup_shell() | fatalerr("Failed to setup shell: " || &why)
      io_task := Dispatcher.new_task{service_tty()}
      io_task.start()
      check_cwd_time_task := Dispatcher.new_task{check_cwd_time()}
      check_cwd_time_task.start()
   end

   public override finally()
      TabItem.finally()
      check_cwd_time_task.stop()
      io_task.stop()
      System.kill(pid, Signal.SIGHUP)
      tty.close()
      close_log()
      ChildWait.add_pid(pid, on_shell_exit)
      revert_tab := check_cwd_time_task := io_task := tty := pid := &null
   end

   private on_favourites_list(ev)
      goto_dir(favourites_list.object_get_selection())
   end

   private on_history_list(ev)
      local he
      he := history_list.object_get_selection()
      history_pos := keyof(history, he) | fail
      update_grey()
      goto_dir(he.dir)
   end

   private on_home_button(ev)
      goto_dir(Files.get_home())
   end

   private on_refresh_button(ev)
      refresh_cwd()
   end

   private on_up_button(ev)
      local t
      t := FilePath(cwd)
      if t.size() > 1 then
         goto_dir(t.parent().str())
   end

   private on_close_button(ev)
      close_tab()
   end

   private finish_clone(t)
      local i
      # Now the new tab is live, copy some column settings.
      i := Positions{(!t.columns.data).name, 
                     columns.object_get_cursor().name}
      t.columns.
         set_area_y(columns.get_area_y()).
         set_area_x(columns.get_area_x()).
         set_cursor(i)
   end

   public clone_tab()
      finish_clone(parent_dialog.new_tab(&yes,, self, self))
   end

   public new_tab()
      parent_dialog.new_tab(&yes,,, self)
   end

   public close_tab()
      local t, i
      if *parent.children = 1 then
         parent_dialog.dispose()
      else {
         if parent.which_one === self then {
            # We're closing the currently selected tab, so choose a new
            # one to be the current tab.
            (i := parent.get_index(\revert_tab)) | {
               i := parent.get_index(self)
               if i > 1 then
                  i -:= 1
               else
                  i +:= 1
            }
            t := parent.children[i] | syserr("Couldn't find other tab")
            parent_dialog.goto_tab(t)
         }
         parent.
            remove(self).
            do_layout().
            invalidate()
      }
   end

   private on_filter_action(ev)
      resort_cwd(&yes)
      set_best_focus()
   end

   private on_filter_content_changed(ev)
      if filter.was_applied(ev) then
         on_filter_action()
   end

   private on_filter_popup_closed(ev)
      set_best_focus()
   end

   private set_best_focus()
      parent_dialog.set_focus(best_focus)
   end

   private on_prev_button(ev)
      local he
      (history_pos < *history) | fail
      he := history[history_pos +:= 1]
      update_grey()
      goto_dir(he.dir)
   end

   private on_next_button(ev)
      local he
      (history_pos > 1) | fail
      he := history[history_pos -:= 1]
      update_grey()
      goto_dir(he.dir)
   end

   private on_focus_filter()
      local c
      c := filter.find_focus()
      if is_live() then
         parent_dialog.set_focus(c)
      else
         set_remembered_focus(c)
   end

   private toggle_focus_columns_button()
      focus_columns_button.toggle_is_checked()
      on_focus_columns_button()
   end

   private on_focus_columns_button(ev)
      local f, c
      f := focus_columns_button.get_status()
      columns.set_accepts_focus(f)
      c := if /f then output else columns
      if is_live() then
         parent_dialog.set_focus(c)
      else
         set_remembered_focus(c)
   end

   private on_columns_focus(ev)
      best_focus := columns
   end

   private on_vt_focus(ev)
      best_focus := output
   end

   private toggle_search_panel()
      if split.second.get_index(search_panel) then
         close_search_panel()
      else
         open_search_panel()
   end

   private open_search_panel()
      split.second.
         add(search_panel, 0)
      if is_live() then {
         split.second.
            reset_layout().
            do_layout().
            invalidate()
         parent_dialog.set_focus(search_field)
      }
   end

   private close_search_panel()
      split.second.
         remove(search_panel)
      if is_live() then {
         split.second.
            reset_layout().
            do_layout().
            invalidate()
         parent_dialog.set_focus(output)
      }
   end

   public override search_msg(s)
      /s := ""
      search_label.set_label(s)
   end

   private on_search_field()
      output.do_search(search_field.get_contents())
   end

   private on_search_next()
      output.do_search_next()
   end

   private on_search_prev()
      output.do_search_prev()
   end

   private setup_search_panel()
      search_panel := Component().
         set_constraint("eol", &yes).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_layout(GridLayout().set_doi(0).set_dii(2).set_extra("cells"))
      search_close_button := IconButton().
         set_tooltip(TextPaint("Close")).
         connect(close_search_panel, Event.ACTION).
         set_no_click_focus(&yes).
         set_paint(ImagePaint().set_cache("gui.CLOSE_24"))
      search_panel.add(search_close_button)
      search_field := TextField().
         set_width(scale(150)).
         set_contents(u"").
         connect(on_search_field, Event.CONTENT_CHANGED).
         connect(on_search_field, Event.ACTION)
      search_panel.add(search_field)
      search_prev_button := IconButton().
         set_tooltip(TextPaint("Prev")).
         connect(self.on_search_prev, Event.ACTION).
         set_no_click_focus(&yes).
         set_paint(ImagePaint().set_cache("gui.PREV_24"))
      search_panel.add(search_prev_button)
      search_next_button := IconButton().
         set_tooltip(TextPaint("Next")).
         connect(self.on_search_next, Event.ACTION).
         set_no_click_focus(&yes).
         set_paint(ImagePaint().set_cache("gui.NEXT_24"))
      search_panel.add(search_next_button)
      search_label := Label().
         set_label("").
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("l_inset", 5).
         set_width(scale(75))
      search_panel.add(search_label)

      theme_toolbar_button(search_close_button, "window-close")
      theme_toolbar_button(search_prev_button, "go-previous")
      theme_toolbar_button(search_next_button, "go-next")
   end

   private setup()
      local paint_2, paint_14, paint_27, paint_32, paint_45, paint_7, layout_4, paint_11, paint_37, paint_42, panel_4, paint_29, split_content_3, split_content_4, paint_9, layout_6, paint_13, paint_31, paint_6, layout_3, paint_10, paint_23, paint_41, paint, paint_3, paint_28, paint_8, border_1, layout_5, paint_12, paint_30, paint_40
      paint_10 := ImagePaint().
         set_cache("rpp.EXIT_24")
      paint_9 := TextPaint("Close")
      close_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_9).
         connect(self.on_close_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_10)
      paint_8 := ImagePaint().
         set_cache("gui.HOME_24")
      paint := TextPaint("Home")
      home_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint).
         connect(self.on_home_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_8)
      paint_3 := ImagePaint().
         set_cache("gui.UP_24")
      paint_2 := TextPaint("Up")
      up_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_2).
         connect(self.on_up_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_3)
      paint_7 := ImagePaint().
         set_cache("gui.REFRESH_24")
      paint_6 := TextPaint("Refresh")
      refresh_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_6).
         connect(self.on_refresh_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_7)
      paint_12 := ImagePaint().
         set_cache("gui.PREV_24")
      paint_11 := TextPaint("Prev")
      prev_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_11).
         connect(self.on_prev_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_12)
      paint_14 := ImagePaint().
         set_cache("gui.NEXT_24")
      paint_13 := TextPaint("Next")
      next_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_13).
         connect(self.on_next_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_14)
      paint_41 := TextPaint("History")
      history_list := HistoryList().
         set_size(scale(37), scale(30)).
         clear_constraints().
         set_tooltip(paint_41).
         connect(self.on_history_list, Event.SELECTION_CHANGED)
      paint_45 := ImagePaint().
         set_cache("rpp.KEYBOARD_24")
      paint_42 := TextPaint("List focus")
      focus_columns_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_42).
         connect(self.on_focus_columns_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&yes).
         set_paint(paint_45)
      paint_23 := TextPaint("Filter")
      filter := FilterEditList().
         set_size(scale(150)).
         set_align(Align.L, Align.B).
         clear_constraints().
         set_constraint(Grid.X_ALIGN, Align.L).
         set_constraint(Grid.X_FILL, &yes).
         set_tooltip(paint_23).
         connect(self.on_filter_action, Event.ACTION).
         connect(self.on_filter_content_changed, Event.CONTENT_CHANGED).
         connect(self.on_filter_popup_closed, Event.POPUP_CLOSED).
         set_selection_list([""])
      paint_28 := ImagePaint().
         set_cache("gui.FONT_24")
      paint_27 := TextPaint("Sort by name")
      name_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_27).
         connect(self.on_name_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_28)
      paint_30 := ImagePaint().
         set_cache("gui.CLOCK_24")
      paint_29 := TextPaint("Sort by date")
      date_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_29).
         connect(self.on_date_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_30)
      paint_32 := ImagePaint().
         set_cache("gui.FILESIZE_24")
      paint_31 := TextPaint("Sort by size")
      size_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(paint_31).
         connect(self.on_size_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(paint_32)
      paint_37 := TextPaint("Favourite directories")
      favourites_list := FavouritesList().
         set_size(scale(37), scale(30)).
         clear_constraints().
         set_tooltip(paint_37).
         connect(self.on_favourites_list, Event.SELECTION_CHANGED)
      trail := FileTrailEx().
         set_size(scale(200), scale(20)).
         clear_constraints().
         set_constraint(Grid.X_ALIGN, Align.L).
         set_constraint(Grid.X_FILL, &yes).
         set_constraint(Grid.X_WEIGHT, 1.0)
      layout_6 := GridLayout().
         set_doi(scale(0)).
         set_dii(scale(2)).
         set_extra("cells")
      panel_4 := Panel().
         clear_constraints().
         set_constraint(Grid.EOL, &yes).
         set_constraint(Grid.X_ALIGN, Align.L).
         set_constraint(Grid.X_FILL, &yes).
         set_constraint(Grid.X_WEIGHT, 1.0).
         set_layout(layout_6).
         add(close_button).
         add(home_button).
         add(up_button).
         add(refresh_button).
         add(prev_button).
         add(next_button).
         add(history_list).
         add(focus_columns_button).
         add(filter).
         add(name_button).
         add(date_button).
         add(size_button).
         add(favourites_list).
         add(trail)
      self.add(panel_4)
      columns := Columns().
         set_size(scale(300), scale(300)).
         clear_constraints().
         set_constraint(Grid.X_FILL, &yes).
         set_constraint(Grid.X_WEIGHT, 1.0).
         set_constraint(Grid.Y_FILL, &yes).
         set_constraint(Grid.Y_WEIGHT, 1.0).
         connect(self.on_columns_focus, Event.GOT_FOCUS)
      layout_5 := GridLayout().
         set_doi(scale(0)).
         set_extra("cells")
      split_content_3 := Component().
         clear_constraints().
         set_layout(layout_5).
         add(columns)
      output := Vt().
         set_size(scale(100), scale(100)).
         clear_constraints().
         set_constraint(Grid.EOL, &yes).
         set_constraint(Grid.X_FILL, &yes).
         set_constraint(Grid.X_WEIGHT, 1.0).
         set_constraint(Grid.Y_FILL, &yes).
         set_constraint(Grid.Y_WEIGHT, 1.0).
         connect(self.on_vt_focus, Event.GOT_FOCUS)
      layout_4 := GridLayout().
         set_doi(scale(0)).
         set_extra("cells")
      split_content_4 := Component().
         clear_constraints().
         set_layout(layout_4).
         add(output)
      split := Split().
         clear_constraints().
         set_constraint(Grid.EOL, &yes).
         set_constraint(Grid.X_FILL, &yes).
         set_constraint(Grid.X_WEIGHT, 1.0).
         set_constraint(Grid.Y_FILL, &yes).
         set_constraint(Grid.Y_WEIGHT, 1.0).
         set_left(split_content_3).
         set_right(split_content_4)
      self.add(split)
      paint_40 := TextPaint("")
      border_1 := CompoundBorder().
         set_outer(SunkenBorder()).
         set_inner(EmptyBorder().
            set_l_inset(scale(3))).
         set_x_align(Align.L)
      message_label := MessageLabel().
         set_fg("red").
         clear_constraints().
         set_constraint(Grid.B_INSET, scale(0)).
         set_constraint(Grid.L_INSET, scale(0)).
         set_constraint(Grid.R_INSET, scale(0)).
         set_constraint(Grid.X_ALIGN, Align.L).
         set_constraint(Grid.X_FILL, &yes).
         set_border(border_1).
         set_paint(paint_40)
      self.add(message_label)
      layout_3 := GridLayout().
         set_extra("cells")
      self.set_layout(layout_3)
   end
end

procedure usage(opts)
   local u
   write("Usage: flowterm [OPTIONS] [ALL TAB OPTS] [DIRS/PER TAB OPTS]")
   options_help(opts)
   write()
   help_line("Tab options/commands begin with a ':', as follows :-")
   write()
   help_line(":max-list=FLAG", "Toggle or set whether the file list is maximized")
   help_line(":max-term=FLAG", "Toggle or set whether the terminal is maximized")
   help_line(":list-focus=FLAG", "Toggle or set whether the file list accepts keyboard focus")
   help_line(":reorient=FLAG", "Toggle or set the orientation of the file list/terminal split.  Vertical split is \"yes\", horizontal \"no\"")
   help_line(":sort-name=FLAG", "Sort the file list by name, or if the file list is already sorted by name, toggle the sort order.  With a parameter, set the sort order (ascending is \"no\", descending is \"yes\")")
   help_line(":sort-date=FLAG", "As `sort-name`, but sort by date (newest first is \"no\", oldest first is \"yes\")")
   help_line(":sort-size=FLAG", "As `sort-name`, but sort by size (biggest first is \"no\", smallest first is \"yes\")")
   help_line(":show-name-only", "Show only the name in the file list")
   help_line(":show-date=FLAG", "Toggle or set whether to show the date in the file list")
   help_line(":show-size=FLAG", "Toggle or set whether to show the size in the file list")
   help_line(":mix-entries=FLAG", "Toggle or set whether or not to mix directories and files together in the list")
   help_line(":show-hidden=FLAG", "Toggle or set whether or not to show hidden files and directories in the list")
   help_line(":sort-dirs=FLAG", "Toggle or set whether or not to sort the directory portion of the list in the same way as the files (by default, the directories are always sorted by name)")
   help_line(":filter-dirs=FLAG", "Toggle or set whether or not to filter directories using the filter setting (by default, the directories are not filtered)")
   help_line(":dont-quieten=FLAG", "Toggle or set whether to turn off the default cursor quietening behaviour.")
   help_line(":select=FLAG", "Set whether to make this tab the selected tab.  The default is \"yes\"")
   help_line(":history=INTEGER", "Specify the directory history size.  The default is 100")
   help_line(":adjacent=FLAG", "Set whether to add this tab adjacent to the current tab, rather than at the end of all the tabs.  The default is \"yes\"")
   help_line(":sh=STRING", "Specify the shell to run.  The default is null, meaning use the user's default shell")
   help_line(":sh-arg=STRING", "Specify an argument to pass to the shell; may be given several times to give multiple arguments")
   help_line(":sh-var=NAME=STRING", "Specify an environment variable setting to pass to the shell; may be given several times to give multiple variables.  If just NAME is given (with no =), then NAME is deleted from the environment")
   help_line(":run=STRING", "Run the given string in the shell; the same as :send-tty with a carriage return appended")
   help_line(":font=FONT", "Set the font, which should be fixed width.  The default is the font 'fixed'")
   help_line(":fg=COLOUR", "Specify the foreground colour.  The default is null, meaning use the dialog's foreground colour")
   help_line(":bg=COLOUR", "Specify the background colour.  The default is null, meaning use the dialog's foreground colour")
   help_line(":reverse-fg=COLOUR", "Specify the reverse-mode foreground colour.  The default is null, meaning use the background colour")
   help_line(":reverse-bg=COLOUR", "Specify the reverse-mode background colour.  The default is null, meaning use the foreground colour")
   help_line(":scroll=INTEGER", "Specify the scroll history size.  The default is 500")
   help_line(":list-width=INTEGER", "The width of the list component in pixels. The default is 300 scaled pixels")
   help_line(":list-height=INTEGER", "The height of the list component in pixels. The default is 300 scaled pixels")
   help_line(":auto-close=FLAG", "Set whether to automatically close the tab if the forked shell process ends.  The default is \"yes\"")
   help_line(":title=STRING" , "Set the title of the tab.  The default is null, meaning show the shell's current directory")
   help_line(":key=KEY,BITS,MASK,COMMAND", "Set/clear a custom key setting.  See the full documentation page for details")
   help_line(":terminal-menu=LABEL,COMMAND", "Set/clear a custom menu setting in the terminal menu.  See the full documentation page for details")
   help_line(":list-menu=LABEL,COMMAND", "Set/clear a custom menu setting in the list menu.")
   help_line(":misc-menu=LABEL,COMMAND", "Set/clear a custom menu setting in the misc menu.")
   help_line(":reset-keys", "Reset custom key settings back to their default state")
   help_line(":reset-terminal-menus", "Reset (clear) custom terminal menu settings")
   help_line(":reset-list-menus", "Reset (clear) custom list menu settings")
   help_line(":reset-misc-menus", "Reset (clear) custom misc menu settings")
   help_line(":string=STRING", "Insert a string as though typed by the user; like :send-tty, but quietens the cursor and goes to the bottom of the terminal content")
   help_line(":search=FLAG", "Toggle or set the visibility of the search panel")
   help_line(":filter=PATTERN", "Set the list filter to the given pattern.  The default is \"*\", meaning show all files")
   help_line(":focus-filter", "Give the filter field the keyboard focus")
   help_line(":send-tty=STRING", "Send a string directly to the pseudo-terminal")
   help_line(":fav-dir=DIR", "Add a directory to the favourites list")
   write()
   help_line("The following commands only apply to the currently active tab (not new tabs) :-")
   write()
   help_line(":start-log=DEST", "Start logging to file DEST")
   help_line(":end-log", "End logging")
   help_line(":font-size=REAL", "Set the font size.  If the parameter starts with + or -, the value is relative to the present size")
   help_line(":url=URL", "Activate a URL as though clicked by the user")
   help_line(":copy-cwd", "Copy the current directory to the clipboard")
   help_line(":copy", "Copy the current selection to the clipboard")
   help_line(":copy-urls", "Copy any URLs in the current selection to the clipboard")
   help_line(":paste", "Paste from the clipboard")
   help_line(":paste-alt", "Paste from the clipboard, with no relative URL file paths (like middle click with the alt key)")
   help_line(":paste-escaped", "Paste from the clipboard, with shell escaping")
   help_line(":pgup", "Go up one page")
   help_line(":pgdn", "Go down one page")
   help_line(":top", "Go to the top")
   help_line(":bottom", "Go to the bottom")
   help_line(":select-all", "Select all text")
   help_line(":close-tab", "Close the tab")
   help_line(":clone-tab", "Clone the tab")
   help_line(":new-tab", "Open a new tab")
   help_line(":quit", "Quit the program")
   help_line(":home", "Go to the home directory")
   help_line(":refresh", "Refresh the columns list")
   help_line(":up", "Go up one directory level")
   help_line(":prev", "Go to the previous directory in the history")
   help_line(":next", "Go to the next directory in the history")
   help_line(":open-history", "Open the history list")
   help_line(":open-filter", "Open the filter list")
   help_line(":open-favourites", "Open the favourites list")
   help_line(":open-menu=N", "Open top-level menu bar; with optional parameter N, also open sub-menu index N")
   help_line(":info=MSG", "Output MSG to the status bar")
   help_line(":tab-left", "Select the next tab to the left")
   help_line(":tab-right", "Select the next tab to the right")
   help_line(":move-tab-left", "Move the current tab to the left")
   help_line(":move-tab-right", "Move the current tab to the right")
   help_line(":send-vt=STRING", "Send a string directly to the terminal")

   u := URL("http://objecticon.sourceforge.net/FlowTerm.html")
   write()
   writes("For more details, visit ")
   if FileStream.stdout.is_flowterm_tty() then
      write(Files.begin_link(u), u.str(), Files.end_link())
   else
      write(u.str())
   exit(0)
end

procedure main(a)
   local d, t
   opts := options(a, [Opt("x",string,"The location of the 'flowterm-extras' directory; by default 'flowterm-extras' in your home directory.  This directory's 'bin' subdirectory is added to the front of the PATH variable"),
                       Opt("nx",,"Don't add any flowterm extras directory to the PATH.  The -x option is ignored"),
                       Opt("v",,"Verbose output"),
                       Opt("lfw",real,"REAL#Use the given width in unscaled pixels for the focus rectangle in the file list"),
                       Opt("width",integer_range(1),"CHARS#The preferred width of the terminal, in characters.  This only applies to the first visible terminal tab"),
                       Opt("height",integer_range(1),"LINES#The preferred height of the terminal, in lines.  This only applies to the first visible terminal tab"),
                       Opt("t",string,"The window title, by default \"FlowTerm\"")],
                       usage)
   ImageCache.
      name_image("rpp.HELP_64", HELP1).
      name_image("rpp.ABOUT_64", ABOUT).
      name_image("rpp.HOURGLASS_24", HOURGLASS).
      name_image("rpp.KEYBOARD_24", KEYBOARD).
      name_image("rpp.EXIT_24", EXIT)
   insert(Dialog.ROOT_WATTRIBS, WAttrib.ICON, Pixels(FLOWTERM_LOGO))
   glob_cmds := []
   while a[1,1] == ":" do
      put(glob_cmds, pop(a)[2:0])
   if *a = 0 then
      put(a, "")
   d := FlowTermDialog()
   d.do_tab_cmd(a) | help_stop(&why)
   t := \d.tabs.which_one | d.tabs.children[1]
   d.set_focus(t.remembered_focus)
   d.show_modal()
   if \opts["v"] then write("Exiting")
end

### Ivib-v2 layout: layouts/$.layout
