package util

import ipl.functional

class Connectable()
   private listeners

   #
   # Helper method to create and fire an Event object from the given parameters.
   #
   public fire(type, param)
      local l

      if /type then 
         runerr("null type to fire")

      every l := !listeners do {
         if /l.type | l.type === type then
            l.proc(param, self, type)
      }
      return self
   end

   #
   # Create and connect a `Listener` to this object.  To get the actual `Listener`
   # instance, use `last_listener()`.
   # @return self
   #
   public connect(proc, etype)
      local l
      if type(proc) == "co-expression" then
         proc := exprf(proc)
      l := Listener(proc,
                    etype)
      listeners := copy(listeners)
      put(listeners, l)
      return self
   end

   #
   # This is like `connect`, but the listener is automatically disconnected
   # after it is fired `n` times.  `n` defaults to 1.
   # @return self
   #
   public connect_n(proc, etype, n)
      local x
      /n := 1
      if type(proc) == "co-expression" then
         proc := exprf(proc)
      connect(lambda{{ 
         proc!_a
         n -:= 1
         if n = 0 then
            disconnect(x)
      }}, etype)
      x := last_listener()
      return self
   end

   #
   # This returns the last listener in the listener list.  Just after
   # a call to `connect()`, this will be the `Listener` object just
   # added.  This can then be passed (for example) to `disconnect()`.
   #
   public last_listener()
      return .listeners[-1]
   end

   #
   # Remove all {Listener}s with method pointers associated
   # with the given object.
   #
   public disconnect_object(obj)
      local t, l
      t := []
      every l := !listeners do
         if is_methp_with_object(l.proc, obj) then
            l.disable()
         else 
            put(t, l)
      listeners := t
      return self
   end

   private static native is_methp_with_object(mp, o)

   #
   # Remove all {Listener}s with the given proc field.
   #
   public disconnect_proc(proc)
      local t, l
      t := []
      every l := !listeners do {
         if l.proc === proc then
            l.disable()
         else 
            put(t, l)
      }
      listeners := t
      return self
   end

   #
   # Remove all {Listener}s with the given type field.
   #
   public disconnect_type(type)
      local t, l
      t := []
      every l := !listeners do {
         if l.type === type then
            l.disable()
         else 
            put(t, l)
      }
      listeners := t
      return self
   end

   #
   # Remove a Listener previously added by {connect}
   #
   public disconnect(l)
      local t
      t := []
      every put(t, l ~=== !listeners)
      l.disable()
      listeners := t
      return self
   end

   #
   # Reconnect a Listener previously added by {connect} and
   # then removed by {disconnect}.
   #
   public reconnect(l)
      listeners := copy(listeners)
      l.reenable()
      put(listeners, l)
      return self
   end

   public new()
      listeners := []
      return
   end
end

