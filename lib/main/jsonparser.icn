package json

import 
   exception

class JSONParser()
   public static const 
      WS_CHAR,
      UNESCAPED_CHAR

   private
      true,
      false,
      null

   private static init()
      WS_CHAR := ' \t\n\r'
      UNESCAPED_CHAR := '\x20-\x21\x23-\x5B\x5D-\U10FFFF'
   end

   public set_true(x)
      self.true := x
      return self
   end

   public set_false(x)
      self.false := x
      return self
   end

   public set_null(x)
      self.null := x
      return self
   end

   private parse_number()
      local s
      s := =("-" | "") || 
         (="0" | (tab(any('123456789')) || (tab(many(&digits)) | ""))) ||
         ((="." || tab(many(&digits))) | "") ||
         ((="e" || (tab(any('+\-')) | "") || tab(many(&digits))) | "") | throw("Invalid number")
      return numeric(s) | throw("Number out of range")
   end

   private parse_string()
      local s, t, ch
      ="\""
      s := move(0)
      repeat {
         s ||:= tab(many(UNESCAPED_CHAR))
         if pos(0) then
            throw("Unclosed quote")
         if ="\"" then
            break
         if ="\\" then {
            ch := move(1) | throw("Unclosed quote")
            s ||:= tcase string(ch) of {
               "\"": "\""
               "\\": "\\"
               "/": "/"
               "b": "\b"
               "f": "\f"
               "n": "\n"
               "r": "\r"
               "t": "\t"
               "u": {
                  many(&digits ++ 'ABCDEFabcdef', t := move(4)) = 5 | throw("Invalid \\u escape")
                  uchar(integer("16r" || t))
               }
               default: throw("Invalid escape char in string: " || ch)
            }
         } else
            throw("Invalid char in string:" || image(&subject[&pos]))
      }
      return s
   end

   private parse_value()
      return if ="false" then
         false
      else if ="true" then
         true
      else if ="null" then
         null
      else if any('[') then
         parse_array()
      else if any('{') then
         parse_object()
      else if any('-' ++ &digits) then
         parse_number()
      else if any('\"') then
         parse_string()
      else
         throw("Unexpected char: " || &subject[&pos])
   end

   private next_token()
      tab(many(WS_CHAR))
   end

   private parse_array()
      local res
      res := []
      ="["
      next_token()
      if ="]" then
         return res
      repeat {
         put(res, parse_value())
         next_token()
         if ="]" then
            return res
         ="," | throw(", expected")
         next_token()
      }
      return res
   end

   private parse_object()
      local res, m, v
      res := table()
      ="{"
      next_token()
      if ="}" then
         return res
      repeat {
         m := parse_string()
         next_token()
         =":" | throw(": expected")
         next_token()
         v := parse_value()
         next_token()
         insert(res, m, v)
         if ="}" then
            return res
         ="," | throw(", expected")
         next_token()
      }
      return res
   end

   private end_check(o)
      next_token()
      pos(0) | throw("Extraneous input:" || tab(0))
      return o
   end

   private parse_impl()
      next_token()
      return if any('[') then
         parse_array()
      else if any('{') then
         parse_object()
      else
         throw("[ or { expected")
   end

   public parse(s)
      return s ? simple_try{ end_check(parse_impl()) }
   end

   public new()
      true := &yes
      false := &no
      return
   end
end
