package gui

class ItemPaintTree(Tree)
   public
      item_paint,
      item_border

   public initially()
      \self.item_paint | runerr("ItemPaint not set")
      Tree.initially()
      self.item_paint.initially(self)
      self.item_border.initially(self)
   end

   public finally()
      Tree.finally()
      self.item_paint.finally()
      self.item_border.finally()
   end

   public set_item_paint(r)
      if is_initialized() then {
         (\self.item_paint).finally()
         self.item_paint := r
         self.item_paint.initially(self)
      } else
         self.item_paint := r
      return self
   end

   #
   # Set a border to draw along with each Paint instance.
   #
   public set_item_border(b)
      if is_initialized() then {
         (\self.item_border).finally()
         self.item_border := b
         self.item_border.initially(self)
      } else
         self.item_border := b
      return self
   end

   public calculate_line_height()
      local h, h1
      if /col_w then
         compute_img_wh()
      if h := item_paint.get_constant_height(view.cbwin) +
         item_border.get_total_height() then 
      {
         #
         # Ensure the line height is slightly greater than the
         # bitmap height
         #
         h <:= \img_h + 4
      } else {
         h := []
         every h1 := item_paint.get_height(view.cbwin, (!self.contents).label) + 
                   item_border.get_total_height() do 
         {
            h1 <:= \img_h + 4
            put(h, h1)
         }
      }
      return h
   end

   public calculate_subject_width()
      local cw, mw, n
      mw := 0
      if /fixed_col_w then {
         if cw := item_paint.get_constant_width(self.cbwin) then {
            every n := !self.contents do
               mw <:= col_w * n.depth + col_w + cw
         } else {
            every n := !self.contents do
               mw <:= col_w * n.depth + col_w + item_paint.get_width(view.cbwin, n.label)
         }
      } else {
         if cw := item_paint.get_constant_width(self.cbwin) then {
            every n := !self.contents do
               mw <:= col_w * n.depth + cw
         } else {
            every n := !self.contents do
               mw <:= col_w * n.depth + item_paint.get_width(view.cbwin, n.label)
         }
      }

      return mw + item_border.get_total_width()
   end

   public get_node_data_width(n)
      return (item_paint.get_constant_width(self.cbwin) | 
              item_paint.get_width(view.cbwin, n.label)) + item_border.get_total_width()
   end

   public draw_node_data(n, xp, yp, lh)
      local r, s
      s := item_paint.get_size(view.cbwin, n.label)
      r := Rect(xp, yp, s.w + item_border.get_total_width(), lh)
      item_paint.draw_rect(view.cbwin, n.label, item_border.float(r, s))
      item_border.draw_rect(view.cbwin, r)
   end

   public new()
      Tree.new()
      self.set_item_border(NullBorder().
                           set_x_align(Align.L))
      return
   end
end

