<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>cartog.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     cartog.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures for cartographic projection 
<a name="6"/>#
<a name="7"/>#	Authors:  Gregg M. Townsend and William S. Evans
<a name="8"/>#
<a name="9"/>#	Date:     May 24, 2000
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#	These procedures project geographic coordinates.
<a name="18"/>#
<a name="19"/>#	rectp(x1, y1, x2, y2, xm, ym) defines a rectangular projection.
<a name="20"/>#	pptrans(L1, L2) defines a planar projective transformation.
<a name="21"/>#	utm(a, f) defines a latitude/longitude to UTM projection.
<a name="22"/>#
<a name="23"/>#	project(p, L) projects a list of coordinates.
<a name="24"/>#	invp(p) returns the inverse of projection p.
<a name="25"/>#	compose(p1, p2, ...) creates a composite projection.
<a name="26"/>#
<a name="27"/>############################################################################
<a name="28"/>#
<a name="29"/>#	rectp(x1, y1, x2, y2, xm, ym) returns a rectangular projection
<a name="30"/>#	in which the point (x1, y1) maps to (x2, y2).  If xm is specified,
<a name="31"/>#	distances in the projected coordinate system are scaled by xm.  If
<a name="32"/>#	ym is also specifed, xm scales x values while ym scales y values.
<a name="33"/>#
<a name="34"/>############################################################################
<a name="35"/>#
<a name="36"/>#	pptrans(L1, L2) returns a planar projective transform that maps
<a name="37"/>#	the four points in L1 to the four points in L2.  Each of the two
<a name="38"/>#	lists contains 8 coordinates: [x1, y1, x2, y2, x3, y3, x4, y4].
<a name="39"/>#
<a name="40"/>############################################################################
<a name="41"/>#
<a name="42"/>#	utm(a, f) returns a projection from latitude and longitude to
<a name="43"/>#	Universal Transverse Mercator (UTM) representation.  The reference
<a name="44"/>#	ellipsoid is specified by a, the equatorial radius in metres, and f,
<a name="45"/>#	the flattening.  Alternatively, f can be omitted with a specifying
<a name="46"/>#	a string, such as "Clarke66"; if a is also omitted, "WGS84" is used.
<a name="47"/>#	See ellipsoid() in geodat.icn for the list of possible strings.
<a name="48"/>#
<a name="49"/>#	The input list contains signed numeric values: longitude and
<a name="50"/>#	latitude, in degrees, in that order (x before y).  The output list
<a name="51"/>#	contains triples: an integer zone number followed by real-valued
<a name="52"/>#	UTM x and y distances in metres.  No "false easting" is applied.
<a name="53"/>#
<a name="54"/>############################################################################
<a name="55"/>#
<a name="56"/>#	project(p, L) applies a projection, reading a list of coordinates
<a name="57"/>#	and returning a new list of transformed coordinates.
<a name="58"/>#
<a name="59"/>############################################################################
<a name="60"/>#
<a name="61"/>#	invp(p) returns the inverse of projection p, or fails if no
<a name="62"/>#	inverse projection is available.
<a name="63"/>#
<a name="64"/>############################################################################
<a name="65"/>#
<a name="66"/>#	compose(p1, p2, ..., pn) returns the projection that is the
<a name="67"/>#	composition of the projections p1, p2, ..., pn.  The composition
<a name="68"/>#	applies pn first.
<a name="69"/>#
<a name="70"/>############################################################################
<a name="71"/>#
<a name="72"/>#	UTM conversion algorithms are based on:
<a name="73"/>#
<a name="74"/>#		Map Projections: A Working Manual
<a name="75"/>#		John P. Snyder
<a name="76"/>#		U.S. Geological Survey Professional Paper 1395
<a name="77"/>#		Washington: Superintendent of Documents, 1987
<a name="78"/>#
<a name="79"/>#	Planar projective transformation calculations come from:
<a name="80"/>#
<a name="81"/>#		Computing Plane Projective Transformations (Method 1)
<a name="82"/>#		Andrew Zisserman, Robotics Research Group, Oxford
<a name="83"/>#		in CVOnline (R. Fisher, ed.), found 22 February 2000 at:
<a name="84"/>#	http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/EPSRC_SSAZ/node11.html
<a name="85"/>#
<a name="86"/>############################################################################
<a name="87"/>#
<a name="88"/>#   Links: geodat, io, lu, numbers, strings
<a name="89"/>#
<a name="90"/>############################################################################
<a name="91"/>
<a name="92"/>
<a name="93"/>
<a name="94"/>package ipl.cartog
<a name="95"/>
<a name="96"/>import
<a name="97"/>   ipl.geodat(ellipsoid),
<a name="98"/>   ipl.lu(lu_back_sub, lu_decomp),
<a name="99"/>   util(Math)
<a name="100"/>
<a name="101"/>
<a name="102"/>
<a name="103"/>#  Procedures and globals named with a "ctg_" prefix are 
<a name="104"/>#  not intended for access outside this file.
<a name="105"/>
<a name="106"/>global ctg_eps_ptab		# table of [axis, flatng], keyed by eps name
<a name="107"/>
<a name="108"/>
<a name="109"/>
<a name="110"/>####################  General Projection Support  ####################
<a name="111"/>
<a name="112"/>
<a name="113"/>
<a name="114"/>#  project(p, L) projects a list of coordinates, returning a new list.
<a name="115"/>
<a name="116"/># project a list of coordinates
<a name="117"/>procedure project(p, L)			
<a name="118"/>   return p.proj(p, L)
<a name="119"/>end
<a name="120"/>
<a name="121"/>
<a name="122"/>
<a name="123"/>#  invp(p) returns the inverse of projection p.
<a name="124"/>
<a name="125"/># return inversion of projection
<a name="126"/>procedure invp(p)			
<a name="127"/>   return (\p.inv)(p)
<a name="128"/>end
<a name="129"/>
<a name="130"/>
<a name="131"/>
<a name="132"/>
<a name="133"/>####################  Rectangular Projection  ####################
<a name="134"/>
<a name="135"/>
<a name="136"/>
<a name="137"/>record ctg_rect(	# rectangular projection record
<a name="138"/>   proj,		# projection procedure
<a name="139"/>   inv,			# inversion procedure
<a name="140"/>   xmul,		# x multiplier 
<a name="141"/>   ymul,		# y multiplier
<a name="142"/>   xadd,		# x additive factor
<a name="143"/>   yadd			# y additive factor
<a name="144"/>   )
<a name="145"/>
<a name="146"/>
<a name="147"/>
<a name="148"/>#  rectp(x1, y1, x2, y2, xm, ym) -- define rectangular projection
<a name="149"/>
<a name="150"/># define rectangular projection
<a name="151"/>procedure rectp(x1, y1, x2, y2, xm, ym)	
<a name="152"/>   local p
<a name="153"/>
<a name="154"/>   /xm := 1.0
<a name="155"/>   /ym := xm
<a name="156"/>   p := ctg_rect()
<a name="157"/>   p.proj := ctg_rect_proj
<a name="158"/>   p.inv := ctg_rect_inv
<a name="159"/>   p.xmul := real(xm)
<a name="160"/>   p.ymul := real(ym)
<a name="161"/>   p.xadd := x2 - x1 * xm
<a name="162"/>   p.yadd := y2 - y1 * ym
<a name="163"/>   return p
<a name="164"/>end
<a name="165"/>
<a name="166"/>
<a name="167"/>
<a name="168"/>#  ctg_rect_proj(p, L) -- project using rectangular projection
<a name="169"/>
<a name="170"/>procedure ctg_rect_proj(p, L)
<a name="171"/>   local i, a, xmul, ymul, xadd, yadd
<a name="172"/>
<a name="173"/>   a := list()
<a name="174"/>   xmul := p.xmul
<a name="175"/>   ymul := p.ymul
<a name="176"/>   xadd := p.xadd
<a name="177"/>   yadd := p.yadd
<a name="178"/>   every i := 1 to *L by 2 do {
<a name="179"/>      put(a, xmul * L[i] + xadd)
<a name="180"/>      put(a, ymul * L[i+1] + yadd)
<a name="181"/>      }
<a name="182"/>   return a
<a name="183"/>end
<a name="184"/>
<a name="185"/>
<a name="186"/>
<a name="187"/>#  ctg_rect_inv(p) -- invert rectangular projection
<a name="188"/>
<a name="189"/>procedure ctg_rect_inv(p)
<a name="190"/>   local q
<a name="191"/>
<a name="192"/>   q := copy(p)
<a name="193"/>   q.xmul := 1.0 / p.xmul
<a name="194"/>   q.ymul := 1.0 / p.ymul
<a name="195"/>   q.xadd := -p.xadd / p.xmul
<a name="196"/>   q.yadd := -p.yadd / p.ymul
<a name="197"/>   return q
<a name="198"/>end
<a name="199"/>
<a name="200"/>
<a name="201"/>
<a name="202"/>################  Planar Projective Transformation  ###############
<a name="203"/>
<a name="204"/>
<a name="205"/>
<a name="206"/>record ctg_ppt(		# planar projective transformation record
<a name="207"/>   proj,		# projection procedure
<a name="208"/>   inv,			# inversion procedure
<a name="209"/>   org,			# origin points
<a name="210"/>   tgt,			# target points
<a name="211"/>   h11, h12, h13,	# transformation matrix: (x' y' 1) = H (x y 1)
<a name="212"/>   h21, h22, h23,
<a name="213"/>   h31, h32, h33
<a name="214"/>   )
<a name="215"/>
<a name="216"/>
<a name="217"/>
<a name="218"/>#  pptrans(L1, L2) -- define planar projective transformation 
<a name="219"/>
<a name="220"/># define planar projective transformation
<a name="221"/>procedure pptrans(L1, L2)	
<a name="222"/>   local p, M, I, B
<a name="223"/>   local x1, x2, x3, x4, y1, y2, y3, y4
<a name="224"/>   local x1p, x2p, x3p, x4p, y1p, y2p, y3p, y4p
<a name="225"/>
<a name="226"/>   *L1 = 8 | runerr(205, L1)
<a name="227"/>   *L2 = 8 | runerr(205, L2)
<a name="228"/>
<a name="229"/>   p := ctg_ppt()
<a name="230"/>   p.proj := ctg_ppt_proj
<a name="231"/>   p.inv := ctg_ppt_inv
<a name="232"/>   p.org := copy(L1)
<a name="233"/>   p.tgt := copy(L2)
<a name="234"/>
<a name="235"/>   B := copy(L1)
<a name="236"/>   every (x1 | y1 | x2 | y2 | x3 | y3 | x4 | y4) := get(B)
<a name="237"/>   B := copy(L2)
<a name="238"/>   every (x1p | y1p | x2p | y2p | x3p | y3p | x4p | y4p) := get(B)
<a name="239"/>
<a name="240"/>   M := [
<a name="241"/>      [ x1, y1, 1., 0., 0., 0., -x1p * x1, -x1p * y1], 
<a name="242"/>      [ 0., 0., 0., x1, y1, 1., -y1p * x1, -y1p * y1], 
<a name="243"/>      [ x2, y2, 1., 0., 0., 0., -x2p * x2, -x2p * y2], 
<a name="244"/>      [ 0., 0., 0., x2, y2, 1., -y2p * x2, -y2p * y2], 
<a name="245"/>      [ x3, y3, 1., 0., 0., 0., -x3p * x3, -x3p * y3], 
<a name="246"/>      [ 0., 0., 0., x3, y3, 1., -y3p * x3, -y3p * y3], 
<a name="247"/>      [ x4, y4, 1., 0., 0., 0., -x4p * x4, -x4p * y4], 
<a name="248"/>      [ 0., 0., 0., x4, y4, 1., -y4p * x4, -y4p * y4] 
<a name="249"/>      ]
<a name="250"/>   I := list(8)
<a name="251"/>   B := copy(L2)
<a name="252"/>
<a name="253"/>   lu_decomp(M, I) | fail		# if singular, fail
<a name="254"/>   lu_back_sub(M, I, B)
<a name="255"/>   every (p.h11 | p.h12 | p.h13 | p.h21 | p.h22 | p.h23 | p.h31 | p.h32) :=
<a name="256"/>      get(B)
<a name="257"/>   p.h33 := 1.0
<a name="258"/>
<a name="259"/>   return p
<a name="260"/>end
<a name="261"/>
<a name="262"/>
<a name="263"/>
<a name="264"/>#  ctg_ppt_proj(p, L) -- project using planar projective transformation
<a name="265"/>
<a name="266"/>procedure ctg_ppt_proj(p, L)
<a name="267"/>   local a, i, x, y, d, h11, h12, h13, h21, h22, h23, h31, h32, h33
<a name="268"/>
<a name="269"/>   h11 := p.h11
<a name="270"/>   h12 := p.h12
<a name="271"/>   h13 := p.h13
<a name="272"/>   h21 := p.h21
<a name="273"/>   h22 := p.h22
<a name="274"/>   h23 := p.h23
<a name="275"/>   h31 := p.h31
<a name="276"/>   h32 := p.h32
<a name="277"/>   h33 := p.h33
<a name="278"/>   a := list()
<a name="279"/>
<a name="280"/>   every i := 1 to *L by 2 do {
<a name="281"/>      x := L[i]
<a name="282"/>      y := L[i+1]
<a name="283"/>      d := h31 * x + h32 * y + h33
<a name="284"/>      every put(a, (h11 * x + h12 * y + h13) / d | (h21 * x + h22 * y + h23) / d)
<a name="285"/>      }
<a name="286"/>
<a name="287"/>   return a
<a name="288"/>end
<a name="289"/>
<a name="290"/>
<a name="291"/>
<a name="292"/>#  ctg_ppt_inv(p, L) -- invert planar projective transformation
<a name="293"/>
<a name="294"/>procedure ctg_ppt_inv(p)
<a name="295"/>   return pptrans(p.tgt, p.org)
<a name="296"/>end
<a name="297"/>
<a name="298"/>
<a name="299"/>
<a name="300"/>###############  Universal Transverse Mercator Projection  ###############
<a name="301"/>
<a name="302"/>
<a name="303"/>
<a name="304"/>#  UTM conversion parameters
<a name="305"/>
<a name="306"/>$define k0	0.9996		# central meridian scaling factor for UTM
<a name="307"/>$define M0	0.0		# M0 = 0 because y origin is at phi=0
<a name="308"/>
<a name="309"/>
<a name="310"/>record ctg_utm(		# UTM projection record
<a name="311"/>   proj,		# projection procedure
<a name="312"/>   inv,			# inversion procedure
<a name="313"/>   a,			# polar radius
<a name="314"/>   f,			# flattening
<a name="315"/>   e,			# eccentricity
<a name="316"/>   esq,			# eccentricity squared
<a name="317"/>   epsq,		# e prime squared 
<a name="318"/>   c0, c2, c4, c6, c8	# other conversion constants
<a name="319"/>   )
<a name="320"/>
<a name="321"/>
<a name="322"/>
<a name="323"/>#  utm(a, f) -- define UTM projection
<a name="324"/>
<a name="325"/># define UTM projection
<a name="326"/>procedure utm(a, f)		
<a name="327"/>   local p,  af
<a name="328"/>
<a name="329"/>   p := ctg_utm()
<a name="330"/>   p.proj := ctg_utm_proj
<a name="331"/>   p.inv := ctg_utm_inv
<a name="332"/>
<a name="333"/>   if /f then {
<a name="334"/>      af := ellipsoid(a) | fail
<a name="335"/>      a := af[1]
<a name="336"/>      f := af[2]
<a name="337"/>   }
<a name="338"/>   p.a := a			# p.a = equatorial radius
<a name="339"/>   p.f := f			# p.f = flattening
<a name="340"/>   p.esq := 2 * f - f ^ 2	# p.esq = eccentricity squared 
<a name="341"/>   p.epsq := p.esq / (1 - p.esq)
<a name="342"/>   p.e := Math.sqrt(p.esq)		# p.e = eccentricity
<a name="343"/>   p.c0 := p.a * (1 - (p.e^2) / 4 - 3 * (p.e^4) / 64 - 5 * (p.e^6) / 256)
<a name="344"/>   p.c2 := p.a * (3 * (p.e^2) / 8 + 3 * (p.e^4) / 32 + 45 * (p.e^6) / 1024)
<a name="345"/>   p.c4 := p.a * (15 * (p.e^4) / 256 + 45 * (p.e^6) / 1024)
<a name="346"/>   p.c6 := p.a * (35 * (p.e^6) / 3072)
<a name="347"/>   return p
<a name="348"/>end
<a name="349"/>
<a name="350"/>
<a name="351"/>
<a name="352"/>#  ctg_utm_proj(p, L) -- project using UTM projection  (Snyder, p61)
<a name="353"/>
<a name="354"/>procedure ctg_utm_proj(p, L)
<a name="355"/>   local ulist, epsq, lat, lon, zone, phi, lambda, lamzero, cosphi
<a name="356"/>   local i, N, T, C, A, M, x, u, y
<a name="357"/>
<a name="358"/>   ulist := list()
<a name="359"/>   epsq := p.epsq
<a name="360"/>
<a name="361"/>   every i := 1 to *L by 2 do {
<a name="362"/>      lon := numeric(L[i])
<a name="363"/>      lat := numeric(L[i+1])
<a name="364"/>      zone := (185 + integer(lon)) / 6
<a name="365"/>      phi := Math.dtor(lat)				# latitude in radians
<a name="366"/>      lambda := Math.dtor(lon)			# longitude in radians
<a name="367"/>      lamzero := Math.dtor(-183 + 6 * zone)		# central meridian of zone
<a name="368"/>      N := p.a / Math.sqrt(1 - p.esq * Math.sin(phi) ^ 2)		# (8-12)
<a name="369"/>      T := Math.tan(phi) ^ 2					# (4-20)
<a name="370"/>      cosphi := Math.cos(phi)
<a name="371"/>      C := epsq * cosphi ^ 2				# (8-13)
<a name="372"/>      A := (lambda - lamzero) * cosphi			# (8-15)
<a name="373"/>      M := p.c0*phi - p.c2*Math.sin(2.*phi) + p.c4*Math.sin(4.*phi) - p.c6*Math.sin(6.*phi)
<a name="374"/>      x := k0 * N * (A + (1 - T + C) * A^3 / 6. +
<a name="375"/>         (5. - 18. * T + T^2 + 72. * C - 58. * epsq) * A^5 / 120.)
<a name="376"/>      u := A^2 / 2 + (5 - T + 9 * C + 4 * C^2) * A^4 / 24 +
<a name="377"/>         (61. - 58. * T + T^2 + 600. * C - 330. * epsq) * A^6 / 720.
<a name="378"/>      y := k0 * (M - M0 + N * Math.tan(phi) * u)
<a name="379"/>      every put(ulist, zone | x | y)
<a name="380"/>      }
<a name="381"/>   return ulist
<a name="382"/>end
<a name="383"/>
<a name="384"/>
<a name="385"/>
<a name="386"/>#  ctg_utm_inv(p) -- invert UTM projection
<a name="387"/>
<a name="388"/>procedure ctg_utm_inv(p)
<a name="389"/>   local q, e, e1
<a name="390"/>
<a name="391"/>   q := copy(p)
<a name="392"/>   q.proj := ctg_iutm_proj
<a name="393"/>   q.inv := ctg_iutm_inv
<a name="394"/>   e := q.e
<a name="395"/>   e1 := (1 - Math.sqrt(1 - e^2)) / (1 + Math.sqrt(1 - e^2))
<a name="396"/>   q.c0 := q.a * (1 - e^2 / 4. - 3. * e^4 / 64. - 5. * e^6 / 256.)
<a name="397"/>   q.c2 := 3. * e1 / 2. - 27. * e1^3 / 32.
<a name="398"/>   q.c4 := 21. * e1^2 / 16. - 55. * e1^4 / 32.
<a name="399"/>   q.c6 := 151. * e1^3 / 96.
<a name="400"/>   q.c8 := 1097. * e1^4 / 512.
<a name="401"/>   return q
<a name="402"/>end
<a name="403"/>
<a name="404"/>
<a name="405"/>
<a name="406"/>#  ctg_iutm_proj(p, L) -- project using inverse UTM projection  (Snyder, p63)
<a name="407"/>
<a name="408"/>procedure ctg_iutm_proj(p, L)
<a name="409"/>   local a, esq, epsq
<a name="410"/>   local lllist, i, x, y, zone
<a name="411"/>   local lam0, mu, phi1, sin1, cos1, tan1, phi, lam, t1, t2, C1, T1, N1, R1, D
<a name="412"/>
<a name="413"/>   a := p.a
<a name="414"/>   esq := p.esq
<a name="415"/>   epsq := p.epsq
<a name="416"/>   lllist := list()
<a name="417"/>
<a name="418"/>   every i := 1 to *L by 3 do {
<a name="419"/>      zone := L[i]
<a name="420"/>      x := L[i + 1]
<a name="421"/>      y := L[i + 2]
<a name="422"/>      lam0 := Math.dtor(-183 + 6 * zone)		# central meridian of zone
<a name="423"/>      mu := y / (k0 * p.c0)
<a name="424"/>      phi1 := mu + p.c2 * Math.sin(2. * mu) + p.c4 * Math.sin(4. * mu) +
<a name="425"/>         p.c6 * Math.sin(6. * mu) + p.c8 * Math.sin(8. * mu)
<a name="426"/>      sin1 := Math.sin(phi1)
<a name="427"/>      cos1 := Math.cos(phi1)
<a name="428"/>      tan1 := Math.tan(phi1)
<a name="429"/>      t1 := 1 - esq * sin1^2
<a name="430"/>      t2 := Math.sqrt(t1)
<a name="431"/>      C1 := epsq * cos1^2
<a name="432"/>      T1 := tan1^2
<a name="433"/>      N1 := a / t2
<a name="434"/>      R1 := a * (1 - esq) / (t1 * t2)
<a name="435"/>      D := x / (N1 * k0)
<a name="436"/>      phi := phi1 - (N1 * tan1 / R1) *
<a name="437"/>         (D^2 / 2. - (5. + 3.*T1 + 10.*C1 - 4.*C1*C1 - 9.*epsq) * D^4 / 24. + 
<a name="438"/>            (61. + 90.*T1 + 298.*C1 + 45.*T1*T1 - 252.*epsq - 3. * C1*C1) *
<a name="439"/>            D^6 / 720.)
<a name="440"/>      lam := lam0 + (D - (1 + 2 * T1 + C1) * D^3 / 6. +
<a name="441"/>         (5. - 2. * C1 + 28. * T1 - 3. * C1 * C1 + 
<a name="442"/>         8. * epsq + 24. * T1 * T1) * D^5 / 120.) / cos1
<a name="443"/>      every put(lllist, Math.rtod(lam) | Math.rtod(phi))
<a name="444"/>      }
<a name="445"/>   
<a name="446"/>   return lllist
<a name="447"/>end
<a name="448"/>
<a name="449"/>
<a name="450"/>
<a name="451"/>#  ctg_iutm_inv(p, L) -- invert inverse UTM projection
<a name="452"/>
<a name="453"/>procedure ctg_iutm_inv(p)
<a name="454"/>   return utm(p.a, p.f)
<a name="455"/>end
<a name="456"/>
<a name="457"/>
<a name="458"/>
<a name="459"/>################## Composing projections #############################
<a name="460"/>
<a name="461"/>record ctg_comp(		# composition of two projections
<a name="462"/>   proj,			# projection procedure (always ctg_comp_proj)
<a name="463"/>   inv,				# inverse (always ctg_comp_inv)
<a name="464"/>   projList			# list of projections in composition,
<a name="465"/>				# first is applied first, etc.
<a name="466"/>   )
<a name="467"/>
<a name="468"/># compose --	produce a projection that applies the LAST projection
<a name="469"/>#		in a[] first, etc.
<a name="470"/>
<a name="471"/># define composite projection
<a name="472"/>procedure compose(a[])		
<a name="473"/>   local q, r
<a name="474"/>
<a name="475"/>   q := ctg_comp()
<a name="476"/>   q.proj := ctg_comp_proj
<a name="477"/>   q.inv := ctg_comp_inv
<a name="478"/>   q.projList := []
<a name="479"/>   every r := !a do
<a name="480"/>      push(q.projList, r)
<a name="481"/>   return q
<a name="482"/>end
<a name="483"/>
<a name="484"/>procedure ctg_comp_proj(p, L)
<a name="485"/>   local r
<a name="486"/>
<a name="487"/>   every r := !(p.projList) do
<a name="488"/>      L := project(r, L)
<a name="489"/>   return L
<a name="490"/>end
<a name="491"/>
<a name="492"/>procedure ctg_comp_inv(p)
<a name="493"/>   local q, r
<a name="494"/>
<a name="495"/>   q := ctg_comp()
<a name="496"/>   q.proj := ctg_comp_proj
<a name="497"/>   q.inv := ctg_comp_inv
<a name="498"/>   q.projList := []
<a name="499"/>   every r := !(p.projList) do
<a name="500"/>      push(q.projList, invp(r))
<a name="501"/>   return q
<a name="502"/>end
</pre></body></html>
