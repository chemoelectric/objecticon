<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Data structure abstractions</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="pandoc.css" />
</head>
<body>
<a href="index.html">Contents</a>
<header id="title-block-header">
<h1 class="title">Data structure abstractions</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#fundamental-classes">Fundamental classes</a><ul>
<li><a href="#capabilities">Capabilities</a></li>
<li><a href="#wrapping-builtin-instances">Wrapping builtin instances</a></li>
</ul></li>
<li><a href="#lists">Lists</a><ul>
<li><a href="#linked-lists">Linked lists</a></li>
<li><a href="#sub-list-views">Sub-list views</a></li>
</ul></li>
<li><a href="#tables">Tables</a><ul>
<li><a href="#sorttable">SortTable</a><ul>
<li><a href="#rank">Rank</a></li>
<li><a href="#tree-nodes">Tree nodes</a></li>
<li><a href="#iteration">Iteration</a></li>
</ul></li>
<li><a href="#eqtable">EqTable</a></li>
<li><a href="#weakreftable">WeakrefTable</a></li>
</ul></li>
<li><a href="#sets">Sets</a></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<p>Object Icon inherits builtin lists, tables and sets from Icon. These are suitable for almost all purposes, but occasionally something different is needed. The <a href="libref/index.html?datastruct-package.html"><code>datastruct</code></a> package provides some object-oriented abstractions which can help.</p>
<h1 id="fundamental-classes">Fundamental classes</h1>
<p>The three most important classes are <a href="libref/index.html?datastruct.List.html">List</a>, <a href="libref/index.html?datastruct.Table.html">Table</a> and <a href="libref/index.html?datastruct.Set.html">Set</a>. Each is an abstract class with methods which reflect the operations of its builtin counterpart.</p>
<h2 id="capabilities">Capabilities</h2>
<p>Each data structure instance has zero or more of several capabilities, reflected by an integer flag value returned by a <code>get_mode()</code> method. This is the same technique used by <a href="libref/index.html?io.Stream.html"><code>io.Stream</code></a> to report whether a Stream is readable, writable, etc. But in this case the capabilities reflect how (if at all) the particular data structure may be altered. Sets and tables (but not lists) additionally have an <code>ORDER</code> capability, meaning entries are stored in order, and thus will be generated ready-sorted during iteration.</p>
<h2 id="wrapping-builtin-instances">Wrapping builtin instances</h2>
<p>Each of the three types of builtin datastructure has two corresponding <code>datastruct</code> wrapper classes. One is a general purpose wrapper providing full access to the underlying data via the particular class’s methods. The other is rather more useful, and provides just a read-only view of the underlying data. For lists, the classes are <a href="libref/index.html?datastruct.BuiltinList.html"><code>datastruct.BuiltinList</code></a> and <a href="libref/index.html?datastruct.UnmodifiableBuiltinList.html"><code>datastruct.UnmodifiableBuiltinList</code></a> respectively, with the other classes being similarly named.</p>
<p>To see how the read-only wrapper could be useful, consider a class which has a private builtin list member variable, and wishes to expose its content to callers. Exposing the private variable would of course allow the list’s content to be changed by the caller. Providing a copy of the list might be expensive. Returning a read-only wrapper avoids these problems. For example :-</p>
<pre><code>class Something()
   private l     # A list.

   ...
   public get_data()
      return UnmodifiableBuiltinList(l)
   end
   ...
end

# A user of the above
x := Something()
...
# Examine the elements
l := x.get_data()
every e := l.gen() do {
    ...
}
l.put(&quot;Junk&quot;)   # Runtime error</code></pre>
<p>One might legitimately object to the overhead of creating many instances of <code>UnmodifiableBuiltinList</code>. At the cost of an extra instance variable this could be avoided :-</p>
<pre><code>class Something()
   private const
      l,     # A list.
      ul     # Its wrapper
   ...
   public get_data()
      return ul
   end

   public new()
      ul := UnmodifiableBuiltinList(l := [])
      ...
      return
   end
end</code></pre>
<p>Note that the use of <code>const</code> ensures that <code>ul</code> and <code>l</code> cannot get out of synch after the instance is instantiated.</p>
<h1 id="lists">Lists</h1>
<h2 id="linked-lists">Linked lists</h2>
<p><a href="libref/index.html?datastruct.LinkedList.html"><code>datastruct.LinkedList</code></a>, implements a Lisp-style singly linked list, so that distinct lists can share tail portions of their data :-</p>
<pre><code>l1 := LinkedList(5, 4, 57, 12, 14)
# The tail list from element 4
l2 := l1.from(4)
# Now l2 is LinkedList(12,14)
# Add an element on the front and back
l2.push(1000)
l2.put(99)
# Now l2 is LinkedList(1000,12,14,99)
# and l1 is LinkedList(5,4,57,12,14,99)</code></pre>
<p>More useful is <a href="libref/index.html?datastruct.DoublyLinkedList.html"><code>datastruct.DoublyLinkedList</code></a>, with several operations possible in constant time, which would take linear time using other types of list. For example, given two lists of arbitrary length, the following splices all of the nodes of the second list onto the end of the first, in constant time, leaving the second list empty :-</p>
<pre><code>l1 := DoublyLinkedList( ... )
l2 := DoublyLinkedList( ... )
l1.splice(0, l2)</code></pre>
<p>The opposite of splicing is “extracting”, which removes part of a list, returning it as a new list.</p>
<pre><code>l1 := DoublyLinkedList( ... )
n1 := l1.node(100); n2 := l1.node(-100)
l2 := DoublyLinkedList.unsafe_extract_nodes(n1, n2)</code></pre>
<p>The last operation is again constant time. Note that the caller has to ensure that the <a href="libref/index.html?datastruct.DoublyLinkedListNode.html">nodes</a> form a valid sub-list, with <code>n2</code> coming after <code>n1</code>, otherwise both source and output lists will be nonsensical; hence the name of the method. Note also that this is a static method (rather than an instance method of the list); list nodes can in fact be manipulated independently of their enclosing list structure.</p>
<p>One final point to mention about <code>DoublyLinkedList</code> is that, like <code>LinkedList</code>, getting the size is an “O(n)” operation.</p>
<h2 id="sub-list-views">Sub-list views</h2>
<p><a href="libref/index.html?datastruct.SubList.html"><code>datastruct.SubList</code></a> is a view of part of another list; it stores no data itself :-</p>
<pre><code>l1 := BuiltinList( [5,4,57,12,14,99,200] )
# A view of l1[4:7]
l2 := SubList(l1, 4, 7)
# Change l1
l1.push(1)
l1.at(5) := 101
# l1 is now BuiltinList(1,5,4,57,101,14,99,200)
# l2 is now SubList(57,101,14)
# Now modify l2 to change l1
l2.at(1) := 300
# l1 is now BuiltinList(1,5,4,300,101,14,99,200)
# l2 is now SubList(300,101,14)</code></pre>
<h1 id="tables">Tables</h1>
<h2 id="sorttable">SortTable</h2>
<p><a href="libref/index.html?datastruct.SortTable.html"><code>datastruct.SortTable</code></a> is a <code>Table</code> which implements the <code>ORDER</code> capability described above, using a red-black binary tree :-</p>
<pre><code>t := SortTable()
t.insert(&quot;Zebra&quot;, 120)
t.insert(&quot;Human&quot;, 10)
t.insert(&quot;Aardvark&quot;, 34)
# t is now SortTable(&quot;Aardvark&quot;-&gt;34;&quot;Human&quot;-&gt;10;&quot;Zebra&quot;-&gt;120)</code></pre>
<h3 id="rank">Rank</h3>
<p>A <code>SortTable</code> can also quickly obtain the “rank” of a particular key, which means its position in the sorted key order. For example</p>
<pre><code>t.rank(&quot;Human&quot;)</code></pre>
<p>gives <code>2</code>, since “Human” is the second key in order. Conversely, the <code>select</code> method gives the key for a particular rank :-</p>
<pre><code>t.select(2)</code></pre>
<p>gives “Human”. <code>select</code> uses standard Icon indexing, so <code>t.select(-1)</code> will give the highest ordered key (“Zebra”).</p>
<h3 id="tree-nodes">Tree nodes</h3>
<p><code>SortTable</code> has several methods which return references to the nodes in the red-black tree. Each node contains a (read-only) key and a value, which may be freely edited at any time to update the table entry’s value.</p>
<p>A node may be obtained when a new entry is added to the table (<a href="libref/index.html?datastruct.SortTable.html%23new_node"><code>datastruct.SortTable.new_node()</code></a>), by key <a href="libref/index.html?datastruct.SortTable.html%23find_node"><code>datastruct.SortTable.find_node()</code></a>, or by rank <a href="libref/index.html?datastruct.SortTable.html%23node"><code>datastruct.SortTable.node()</code></a>.</p>
<p>The node may be removed from the tree with <a href="libref/index.html?datastruct.SortTableNode.html%23unlink"><code>datastruct.SortTableNode.unlink()</code></a>.</p>
<h3 id="iteration">Iteration</h3>
<p><code>SortTable</code> and <code>SortTableNode</code> provide methods to iterate forward or backward over keys, values and nodes. These iterators are robust against any changes to the underlying tree structure may change, with one exception: the last entry returned must not be deleted before the next entry is generated. For example, this is not allowed :-</p>
<pre><code>   t := SortTable(,, &quot;Cat&quot;, 12, &quot;Mouse&quot;, 2, &quot;Gerbil&quot;, 1)
   # Generate the nodes (in ascending sort order)
   e := create t.nodes()
   n := @e
   # n is now the SortTableNode(key=&quot;Cat&quot;, val=12)
   n.unlink()
   # t now has two remaining elements
   n := @e       # Runtime error: Node has been unlinked</code></pre>
<p>Since it is often useful to iterate and remove elements in the same loop, the method <a href="libref/index.html?datastruct.SortTableNode.html%23move_unlink"><code>datastruct.SortTableNode.move_unlink()</code></a> may be used instead, together with a <code>while</code> loop. For example, the following procedure will iterate over a table and delete even-numbered keys :-</p>
<pre><code>procedure del(t)
   local n
   # Get the first node by rank
   n := t.node(1)
   while
      n := if n.key % 2 = 0 then
         n.move_unlink(1)
      else
         n.get_next()
end</code></pre>
<h2 id="eqtable">EqTable</h2>
<p><a href="libref/index.html?datastruct.EqTable.html"><code>datastruct.EqTable</code></a> uses the <a href="libref/index.html?lang.equals.html"><code>lang.equals</code></a> procedure (and its cousin, <a href="libref/index.html?lang.hash.html"><code>lang.hash</code></a>) to determine table membership rather than the usual identity operator (<code>===</code>), which is quite often useful. For example :-</p>
<pre><code># A table with two entries.
t := EqTable(,
             [1], 1,
             [2], 2)
# Modify the second entry&#39;s value.
t.insert([2], 200)
# Now we still have two entries ( [1]-&gt;1 and [2]-&gt;200 )
# (with a regular table we would have 3).</code></pre>
<h2 id="weakreftable">WeakrefTable</h2>
<p><a href="libref/index.html?datastruct.WeakrefTable.html"><code>datastruct.WeakrefTable</code></a> wraps its keys in weak references. Thus on a garbage collection, the keys may “disappear”, and the size of the table reduce :-</p>
<pre><code># Set up some keys.
k1 := []; k2 := []; k3 := []; k4 := []
# Create a table with four entries.
t := WeakrefTable(, k1, 1,
                    k2, 2,
                    k3, 3,
                    k4, 4)
# Make two of the keys only referenced by the table.
k2 := k4 := &amp;null
# Do a garbage collection
collect()
# Now t is reduced
t.size()     # 2 (k1-&gt;1 and k3-&gt;3)</code></pre>
<h1 id="sets">Sets</h1>
<p>The functionality of any <code>Table</code> can easily be extended into <code>Set</code> form using <a href="libref/index.html?datastruct.TableSet.html"><code>datastruct.TableSet</code></a>, which provides a set view of the keys. <a href="libref/index.html?datastruct.EqSet.html"><code>datastruct.EqSet</code></a> is a particularly convenient subclass of <code>TableSet</code> which wraps the <code>EqTable</code> described above :-</p>
<pre><code># A three-element set
s := EqSet( [1], [2], [3] )
# Insert an element
s.insert([2])
# The size is still 3 (not 4, as a regular set would have).</code></pre>
<a href="index.html">Contents</a>
</body>
</html>
