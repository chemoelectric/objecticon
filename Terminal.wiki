#summary terminal - an experimental terminal program
<wiki:toc max_depth="3" />
= Introduction =
This page provides some notes about one of the programs in the `examples` directory, namely `terminal`.  It is an experimental replacement for terminal emulator programs like `xterm` and `konsole`.

= Tabs =
The program presents one or more tabs to the user, each of which is contains an independent shell process.  Each tab contains a split pane.  To the left (or top if so oriented), is a list of the contents of the shell process's current directory.  To the right (or bottom) is a fairly conventional terminal emulator, albeit one with some important extensions.

http://objecticon.googlecode.com/svn/wiki/terminal-full.jpg

= Clickable links =
The most significant thing that the `terminal` program does differently to conventional terminal emulators like `xterm`, is the provision of clickable hyperlinks to files and other objects.  For example, look at the following image, showing the output of `ls`.

http://objecticon.googlecode.com/svn/wiki/terminal-link.png

As the mouse pointer moves over the filename output by `ls`, the mouse pointer changes and the link is highlighted.  Left-clicking on the link opens the system-registered application for viewing that particular file type; right-clicking brings up a context menu.

This effect is achieved by a combination of two things.  Firstly, the terminal emulator understands special escape sequences which encapsulate file links in much the same way as a web browser understands HTML anchor tags.  Secondly, a small collection of programs, including `ls`, have been modified to produce these special escape sequences, and thus provide the desired links in the terminal emulator.  To continue the web analogy, if the terminal emulator is the browser, then these programs are the equivalent of web servers, but instead of producing HTML containing anchor tags, they produce their normal textual output, but containing embedded link escape sequences.

The modified programs include `ls`, `grep` and `find`.  Although the selection of programs cannot be complete, it is large enough to considerably improves the usability of the shell.

These modified programs are provided in a separate download; the section [Terminal#The_termlinks-extras_programs Termlinks extras] below explains more.
= Graphical completion =
Another frustation of using the shell which the `terminal` program tries to address is filename completion (in fact completion in general, not just files).  Users of bash will certainly be familiar with how annoying its completion facility can be.  To alleviate this distress, another escape sequence is employed, and `bash` is modified to send this escape sequence when tab completion occurs (in fact, `bash` is not modified, rather its readline library, which is statically linked into it, is modified instead).

With this modification, a popup list appears to implement tab completion, as shown in the following image :-

http://objecticon.googlecode.com/svn/wiki/terminal-popup.png

The user may now use the mouse or the cursor keys in order to select from the list in the normal way.
= Toolbar =
The various items in the toolbar should be mostly self-explanatory.

http://objecticon.googlecode.com/svn/wiki/terminal-toolbar.png

Going from left to right, we have the close tab button, the goto home directory button, go up one level button and refresh directory button.

Then comes buttons to go backward and forward in the history, and to display the history as a drop-down list (the egg timer icon).

Next is the "columns focus" button, which is a toggle button.  When set, it allows the list to take the keyboard focus.  The cursor keys can then be used to navigate, and the return key used to "open" the currently selected item (equivalent to left-clicking).

The drop-down edit list is a filter, which restricts the files on view in the list.  The contents of the drop-down provides a convenient list of file extensions in the current directory.  The filter resets to `*` (display all) whenever the directory is changed.

The three buttons to the right of the filter drop-down are used to control the sort used in the list, which is by default alphabetic in descending order.  The small arrow in the corner of the button indicates which sort is in use, and whether it is ascending or descending.  Clicking on the button with the arrow toggles the order between ascending and descending, whilst clicking on one of the other buttons sets the sort to the corresponding button, leaving the order unchanged.

Next to the sort buttons comes the favourites button.  This is a list of directories, which can be edited via the "Favourite dirs..." item in the File menu.

Finally, to the right of that comes the file trail.  This shows the current directory.  Clicking on one of the file names in the trail changes the directory.  Also, clicking on one of the slash separators pops up the list of directories for that location.  Selecting from one goes to that directory.  The following image shows that in action :-

http://objecticon.googlecode.com/svn/wiki/terminal-trail.png

== Popup menus ==
Both the file list and terminal portions of the tab have popup menus.  They appear either by clicking in an area without links, or via the menu bar at the top of the window.

The terminal menu is shown below.

http://objecticon.googlecode.com/svn/wiki/terminal-vt-menu.png

The first four items relate to copy and paste.  Reorient toggles the horizontal/vertical orientation of the split.  Horizontal orientation is especially useful if you have a directory containing many very long file names.  The maximize and minimize options make the terminal take up all of the tab's space, or none of the space, respectively.

The file list's popup menu is as follows :-

http://objecticon.googlecode.com/svn/wiki/terminal-list-menu.png

The first two items indicate that the date or size should be shown alongside the name.  To reduce clutter, this is only applied to directory entries if the "Sort dirs" or "Mix files & dirs" option is checked.  "Sort dirs" means apply the same sort to directories as to files; normally they are just sorted by alphabetical order regardless of the sort option selected in the toolbar.  "Mix files & dirs" means sort and display files and directories together; normally directories come first.

When a URL link (or an entry in the file list) is left-clicked, a menu such as the following is shown.  Some entries may not appear, depending on the type of the link.  The clicked URL turns red.

http://objecticon.googlecode.com/svn/wiki/terminal-url-menu.png

"Copy" will copy the filename to the clipboard, appropriately shell-escaped with backslashes, whereas "Copy URL" just copies the source URL to the clipboard.  "Insert command" sends the text of the command that a left-click would run, to the shell process (this would normally be echoed by the shell, and appear on the terminal).  "Open with" is a submenu listing all of the system's dekstop applications which can recognise this file or URL type.  For files, "Rename" opens a window where the file can be renamed.  This is the only file manager-like option which the `terminal` program provides.

= The termlinks-extras programs =

This is a collection of common utility programs, modified to provide output containing escape sequences recognised by the terminal program.  For example, a version of `ls` is provided which turns each file output into a clickable link to a `file:` URL.

To build the termlinks-extras programs, proceeds as follows.

Firstly, download the `.tar.gz` file, from the following link :-

[https://drive.google.com/open?id=0B0V-oOspWt47Y0cxZHd5cDVaRFE&authuser=0 termlinks-extras.tar.gz]

It is best to extract this file in your home directory, since it will then be found automatically by the `terminal` program.  (If you extract it somewhere else, then you will need to provide the `-x` option to tell `terminal` where).

In any case, extract it as follows :-
{{{
tar xfz termlinks-extras.tar.gz
}}}

This will create a `termlinks-extras` directory.  Cd into that directory, and run

{{{
./build.sh
}}}

A considerable amount of output will be produced, but if everything was successful, the message "Finished OK" will be printed.  In that case, a directory `bin` will have been created, containing the resulting executables.  The `build.sh` script doesn't actually install anything outside of its directory, and can simply be deleted if you no longer have any use for it.

= Escape sequences =
There are two special escape sequences recognised by the terminal, as follows.
== The link escape sequence ==
This takes the form
{{{
\e[!"url"Lvisible-text\e[!L
}}}
where `\e` is the escape character (ascii 27), `url` is a URL, (with the normal percent encoding), and `visible-text` is the text which appears on the screen to represent the clickable URL.  In fact, the above actually represents two separate escape sequences; the second comes after the `visible-text`, in order to denote its endpoint.  If you're familiar with HTML, then you will see the similarity with an anchor tag.  The first escape sequence mirrors the opening `<A HREF=URL>` tag, and the second the closing `</A>` tag, whilst `visible-text` fulfils the same role as the content between the tags.

Most URLs in these escape sequences will be `file` URLs, but as explained below, other types of URLs, including custom ones, are allowed too.  These can be particularly useful when they are placed in simple "favourites" files which, when printed to the terminal, provide a selection of clickable links to launch applications, open new tabs, and so on.

Some examples of a link escape sequences are :-
{{{
\e[!"file:///some/file/or/other.txt?line=120"LA file with an associated line number\e[!L
\e[!"http://www.google.com"LA link to google\e[!L
\e[!"launch:konqueror"LOpen konqueror\e[!L
}}}

== The popup escape sequence ==
This escape sequence is used to provide a more friendly and usable name completion system.  The sequence takes the form :-
{{{
\e[!"k1";"i1";"k2";"i2";"k3";"i3",....,"kn","in"P
}}}
In other words, there are `n` pairs of string parameters.  All parameters are URL encoded.  On receipt of this escape sequence, the terminal pops up a list, showing each of the `k` parameters.  When one is selected, its corresponding `i` parameter is sent to the output, as though it had been typed.

Unlike the link escape sequence, this sequence only really makes sense when it is generated by a program.

= URL schemes =
== file: ==
A file URL has the following syntax :-
{{{
file://[host]/path[?line=line-no]
}}}
If the `path` (which includes the `/` to its left), is a directory then clicking on the link sends a `cd` command to the shell process in order to change its current working directory.

Otherwise, the file associations database is searched to find an application to launch to view the file.  If found, then the application is launched by forking a new process.

The optional `host` element is just used to check whether the URL refers to a file on the host running the terminal program.  If not, then there is no point trying to launch an application for it, and an error message is shown in the message bar.

The `line-no` is passed to the application if its desktop entry file contains an entry `ExecLine=...`, as opposed to the normal `Exec=...`.  The `ExecLine` string may contain an escape sequence `%L` into which the line number is substituted.  Both the `ExecLine` entry and the `%L` escape are entirely non-standard unfortunately, so you must create your own `.desktop` file in order to make use of them.  An example which I use to launch `emacs` is :-
{{{
[Desktop Entry]
Version=1.0
Encoding=UTF-8
Name=GNU Emacs
GenericName=Text Editor
Comment=View and edit files
MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;application/json;
Exec=emacs %F
ExecLine=emacs +%L %F
Icon=emacs
Type=Application
Terminal=false
Categories=Utility;Development;TextEditor;
InitialPreference=20
}}}
This is placed in my `~/.local/share/applications` directory.  The effect of launching this desktop entry file with the URL
{{{
file:///home/rparlett/prog.c?line=124
}}}
is then to launch the program
{{{
emacs +124 /home/rparlett/prog.c
}}}
== launch: ==
A launch URL has the following syntax :-
{{{
launch:command-string[?wd=working-dir]
}}}
Both `command-string` and `working-dir` portions are URL encoded.  When clicked, a launch URL forks a new process, sets its current directory to `working-dir` (or the user's home directory if `working-dir` was omitted), and then runs `command-string`, which may include bash shell syntax.

An example of a launch URL is :-
{{{
launch:qemu-system-x86_64 -hda ubuntu.img -m 3G -vga vmware?wd=/mnt/disk/qemu-stuff
}}}
== text: ==
A text URL has the following syntax :-
{{{
text:string
}}}
The `string` is URL encoded.  The effect of clicking on such a link is simply to send the string to the input of the forked shell process.  In other words, the effect is the same as if the string had been typed at the keyboard.

An example might be :-
{{{
text:hello world
}}}
If we were to click on a link with this URL, then "hello world" would be sent to the shell process, which would then echo it back so it appeared on the screen (unless it was running a command at the time).
== run: ==
A text URL has the following syntax :-
{{{
run:command-string
}}}
The `command-string` is URL encoded.  The effect of clicking on such a link is, like a text URL, simply to send the string to the input of the forked shell process, with a carriage return appended, causing the command to be run (unless the shell process is doing something else).

An example :-
{{{
run:ps -a
}}}
Clicking on a link with this URL would run the command "ps -a".

Note that the difference between a launch URL and a run URL is that a launch URL forks a new process which runs independently of the shell, whilst run just sends the command string to the shell for execution as though it had been typed at the keyboard.
== tab: ==
A tab URL enables new tabs to be opened and configured when it is clicked.  It has the following syntax :-
{{{
tab:arg1[;arg2][;arg3]...
}}}
Each "argument" is URL encoded.  Each argument is either a directory name, which opens a new tab with that directory as a starting point, or a string beginning with ":" which configures the tab just opened.  These configuration options are the same as described in the section below on command line options.  An empty string argument just opens a new tab, without setting its directory.  If any configuration options come before a directory argument, then they apply to the currently selected tab.

An example of a tab URL is :-
{{{
tab:/mnt/disk/films;:reorient;:sort-date;:sort-date;:select
}}}

When clicked, this URL opens a new tab, changes its directory to `/mnt/disk/films`, toggles the orientation of the split, sets the sort to ascending date order, and selects the tab.
== Other URL schemes ==
All other URL schemes are handled by looking up the desktop entry matching the mime type `x-scheme-handler/[scheme]`.  The matching application is then launched in a forked process.

= Favourites files and other useful tips =
It is very easy and useful to create small shell script files which simple output links which can be clicked on.  These links can be `file:` URLs, in order to change to particular directories, or launch specific files.  They could also use some of the custom schemes mentioned [Terminal#URL_schemes above], which can launch applications, open new tabs, and so on.

For example, if I created the following file, called it `favs`, and put it somewhere on my path (and made it executable)
{{{
#!/bin/bash
cat <<EOF
\e[!"tab:/mnt/sg1/music;:reorient;:sort-date;:sort-date;:mix-entries;:select"LMusic tab\e[!L
\e[!"launch:qemu-system-x86_64 -hda caldera.img -m 3G -net nic -net bridge -enable-kvm?wd=/mnt/qemu-stuff"Lcaldera emulation\e[!L
\e[!"launch:konsole -e ssh rparlett@somehost"Lssh to somehost\e[!L
\e[!"file:///tmp"Lcd to /tmp\e[!L
EOF
}}}
then whenever I typed `favs` at the prompt, the above links would be printed, and I would simply have to click on one of them to perform the desired action.

Note that creating the above file with a text editor does present one problem, namely how to input the escape character (ascii 27), shown in the above as the two characters '\e'.  In emacs, this character can be input by typing control-q, and then pressing the escape key.

= The TERMLINKS environment variable =
One problem that faces programs that output the special link and popup escape sequences (such as the `termlinks-extras` programs), is the question of what kind of terminal the program is connected to.  It is obviously undesirable to output these escape sequences on a conventional terminal, since the output will be garbled.  However, detecting the type of the terminal is awkward.   Therefore, a simple environment variable is set, which is used by programs to determine whether or not to output the special escape sequences.  The following values are used :-
 * *0 or unset* Don't output special escape sequences.
 * *1* Output special escape sequences, but only if the output file is a tty.  This is the default setting at `terminal` startup.
 * *2* Always output special escape sequences
The last option can be useful if using a pipeline.  For example, assuming `TERMLINKS` is `1`, the output of
{{{
ls -t | head
}}}
will not contain escape sequences, since `ls` will detect that its output is a pipe, rather than a tty.  (For the same reason, if you use colour ls output, you won't see colours either).

To fix this, set `TERMLINKS` to `2` when invoking `ls`, thus :-
{{{
TERMLINKS=2 ls -t | head
}}}

= Limitations =
The terminal emulator has a few features which are found in `xterm`, but which are not implemented :-
 * Blinking characters
 * Embedded escape sequences
 * Double width and double height characters

The coordination between the file list and the terminal emulator also has some limitations.  The list's current directory is kept synchronized with the shell process's current directory, as read from the file `/proc/<pid>/cwd`, where `pid` is the shell process's process id.  This means that the list doesn't synchronize with a sub-shell process.  For example, if you start another shell program, such as `zsh`, as in
{{{
bash $ zsh
$ cd /tmp
}}}
then the list won't synchronize to `/tmp`, since the original bash process is still in whatever directory it was in when `zsh` started.  If you know you won't return to bash, you can instead type
{{{
bash $ exec zsh
$ cd /tmp
}}}
Then it will work as desired, since `zsh` has taken over (and replaced) the bash shell's process.

The `screen` program also suffers from the same problem, since it starts its own processes.  Also, since it implements its own internal terminal emulation,  it cannot understand understand the special escape sequences used by `terminal`.  Therefore it is desirable to set `TERMLINKS` to zero (or unset it) before launching `screen`.
{{{
$ TERMLINKS=0 screen
}}}
In view of these limitations, there is in fact no advantage to running `screen` in the `terminal` program, and it may just as well be started in a conventional terminal emulator program :-
{{{
$ konsole -e screen
}}}

= Command line options =
`terminal` accepts the following command-line options :-

 * *-x* The location of the termlinks extras bin directory; by default `termlinks-extras/bin` in your home directory.  This directory is added to the front of the `PATH` variable.
 * *-nx* Don't add any termlinks extras directory to the `PATH`.  The `-x` option is ignored.
 * *-v* Provide some verbose output (useful for debugging).
 * *-h* Set the history scrollback size.
 * *-hs* Start each tab by default with a horizontal rather than a vertical split.
 * *-tfg* The foreground colour of the terminal.
 * *-tbg* The backround colour of the terminal.
 * *-trevfg* The reverse-mode foreground colour of the terminal, by default simply the terminal background.
 * *-trevbg* The reverse-mode background colour of the terminal, by default simply the terminal foreground.
 * *-tfont* The terminal font.  This must be a monospace font.  By default, "fixed" at the default font size.

In addition to these options, one or more tabs can be configured on the command line.  Passing a directory name as an argument will add a new tab with that directory as a starting point.  Passing a string beginning with ":" will configure the tab.  The following configuration options are allowed :-

 * *:minimize* Minimize the space for the terminal, so the files list takes all the space.
 * *:maximize* Maximize the space for the terminal, so the files list is not visible.
 * *:normal-size* Return to normal split between file list and terminal.
 * *:list-focus* Allow keyboard focus in the file list.
 * *:reorient or :re-orient* Toggle the orientation of the file list/terminal split.
 * *:sort-name* Sort the file list by name, or if the file list is already sorted by name, toggle the sort order.
 * *:sort-date* As `sort-name`, but sort by date.
 * *:sort-size* As `sort-name`, but sort by size.
 * *:show-name-only* Show only the name in the file list.
 * *:show-date* Show name and date in the file list.
 * *:show-size* Show name and size in the file list.
 * *:mix-entries* Toggle whether or not to mix directories and files together in the list.
 * *:show-hidden* Toggle whether or not to show hidden files and directories in the list.
 * *:sort-dirs* Toggle whether or not to sort the directory portion of the list in the same way as the files (by default, the directories are always sorted by name).
 * *:select* Make this tab the selected tab.

For example, the following example starts the program with four tabs with various options :-
{{{
terminal ~ \
         ~/objecticon \
         /mnt/disk/Documents :reorient :sort-date :sort-date :mix-entries \
         /mnt/disk/Music :reorient :sort-date :sort-date
}}}

Note how in the last two tabs `:sort-date` is given twice in order to give ascending date sort (ie newest at the top).
