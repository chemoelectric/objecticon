############################################################################
#
#	File:     gen.icn
#
#	Subject:  Procedures for meta-variant code generation
#
#	Author:   Ralph E. Griswold
#
#	Date:     April 30, 1993
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#  These procedures are for use with code produced by a meta-variant
#  translator.  As given here, they produce an identity translation.
#  Modifications can be made to effect variant translations.
#
############################################################################

#  main() calls program(), which is produced by the meta-variant
#  translation.

package ipl.gen

import io

procedure main(program)

   program()

end

# e1 | e2
procedure Alt_(e1, e2)			

   return "(" || e1 || "|" || e2 || ")"

end

# e1 ! e2
procedure Apply_(e1, e2)		

   return "(" || e1 || "!" || e2 || ")"

end

# e1 op e2
procedure Asgnop_(op, e1, e2)		

   return "(" || e1 || " " || op || " " || | e2 || ")"

end

# e1 ?:= e2
procedure Augscan_(e1, e2)		

   return "(" || e1 || " ?:= " || e2 || ")"

end

# e1 & e2
procedure Bamper_(e1, e2)		

   return "(" || e1 || " & " || e2 || ")"

end

# e1 op e2
procedure Binop_(op, e1, e2)		

   return "(" || e1 || " " ||  op || " " ||  e2 || ")"

end

# break e
procedure Break_(e)			

   return "break " || e

end

# case e of { caselist }
procedure Case_(e, clist)		

   return "case " || e || " of {" || clist || "}"

end

# e1 : e2
procedure Cclause_(e1, e2)		

   return e1 || " : " || e2 || "\n"

end

# e1 ; e2 in case list
procedure Clist_(e1, e2)		

   return e1 || ";" || e2

end

# 's'
procedure Clit_(e)			

   return "'" || e || "'"

end

# { e1; e2; ... }
procedure Compound_(es[])		
   local result

   if *es = 0 then return "{}\n"

   result := "{\n"
   every result ||:= !es || "\n"

   return result || "}\n"

end

# create e
procedure Create_(e)			

   return "create " || e

end

# default: e
procedure Default_(e)			

   return "default: " || e

end

# end
procedure End_()			

   write("end")

   return

end

# every e
procedure Every_(e)			

   return "every " || e

end

# every e1 do e2
procedure Every_Do_(e1, e2)		

   return "every " || e1 || " do " || e2

end

# fail
procedure Fail_()			

   return "fail"

end

# e . f
procedure Field_(e1, e2)		

   return "(" || e1 || "." || e2 || ")"

end

# global v1, v2, ...
procedure Global_(vs[])		
   local result

   result := ""
   every result ||:= !vs || ", "

   write("global ", result[1:-2])
   
   return

end

# if e1 then e2
procedure If_(e1, e2)			

   return "if " || e1 || " then " || e2

end

# if e1 then e2 else e3
procedure If_Else_(e1, e2, e3)		

   return "if " || e1 || " then " || e2 || " else " || e3

end

# i
procedure Ilit_(e)			

   return e

end

# initial e
procedure Initial_(s)			

   write("initial ", s)

   return

end

# e0(e1, e2, ...)
procedure Invoke_(e0, es[])		
   local result

   if *es = 0 then return e0 || "()"

   result := ""
   every result ||:= !es || ", "

   return e0 || "(" || result[1:-2] || ")"

end

# &s
procedure Key_(s)			

   return "&" || s

end

# e1 \ e2
procedure Limit_(e1, e2)		

   return "(" || e1 || "\\" || e2 || ")"

end

# link "v1, v2, ..." (problem)
procedure Link_(vs)			

   write("link ", vs)

end

# [e1, e2, ... ]
procedure List_(es[])			
   local result

   if *es = 0 then return "[]"

   result := ""
   every result ||:= !es || ", "

   return "[" || result[1:-2] || "]"

end

# local v1, v2, ...
procedure Local_(vs[])			
   local result

   result := ""
   every result ||:= !vs || ", "

   write("local ", result[1:-2])
   
   return

end

# next
procedure Next_()			

   return "next"

end

# &null
procedure Null_()			

   return ""

end

# (e1, e2, ... )
procedure Paren_(es[])			
   local result

   if *es = 0 then return "()"

   result := ""
   every result ||:= !es || ", "

   return "(" || result[1:-2] || ")"

end

# e0{e1, e2, ... }
procedure Pdco_(e0, es[])		
   local result

   if *es = 0 then return e0 || "{}"

   result := ""
   every result ||:= !es || ", "

   return e0 || "{" || result[1:-2] || "}"

end

# procedure s(v1, v2, ...)
procedure Proc_(s, es[])		
   local result, e

   if *es = 0 then write("procedure ", s, "()")

   result := ""
   every e := !es do
      if e == "[]" then result[-2:0] := e || ", "
      else result ||:= (\e | "") || ", "

   write("procedure ", s, "(", result[1:-2], ")")

   return

end

# record s(v1, v2, ...)
procedure Record_(s, es[])		
   local result, field

   if *es = 0 then write("record ", s, "()")

   result := ""
   every field := !es do
      result ||:= (\field | "") || ", "

   write("record ", s, "(", result[1:-2], ")")

   return

end

# used in code generation
procedure Reduce_(s[])			

   every write(!s)

   return

end

# repeat e
procedure Repeat_(e)			

   return "repeat " || e

end

# return e
procedure Return_(e)			

   return "return " || e

end

procedure Rlit_(e)

   return e

end

# e1 ? e2
procedure Scan_(e1, e2)			

   return "(" || e1  || " ? " || e2 || ")"

end

# e1[e2 op  e3]
procedure Section_(op, e1, e2, e3)	

   return e1 || "[" || e2 || op || e3 || "]"

end

# "s"
procedure Slit_(s)			

   return image(s)

end

# static v1, v2, ..
procedure Static_(ev[])			
   local result

   result := ""
   every result ||:= !ev || ", "

   write("static ", result[1:-2])
   
   return

end

# e1[e2]
procedure Subscript_(e1, e2)		

   return e1 || "[" || e2 || "]"

end

# suspend e
procedure Suspend_(e)			

   return "suspend " || e

end

# suspend e1 do e2
procedure Suspend_Do_(e1, e2)		

   return "suspend " || e1 || " do " || e2

end

# e1 to e2
procedure To_(e1, e2)			

   return "(" || e1 || " to " || e2 || ")"

end

# e1 to e2 by e3
procedure To_By_(e1, e2, e3)		

   return "(" || e1 || " to " || e2 || " by " || e3 || ")"

end

# |e
procedure Repalt_(e)			

   return "(|" || e || ")"

end

# op e
procedure Unop_(op, e)			

   return "(" || op || e || ")"

end

# not e
procedure Not_(e)			

   return "not(" || e || ")"

end

# until e
procedure Until_(e)			

   return "until " || e

end

# until e1 do e2
procedure Until_Do_(e1, e2)		

   return "until " || e1 || " do " || e2

end

# v
procedure Var_(s)			

   return s

end

# while e
procedure While_(e)			

   return "while " || e

end

# while e1 do e2
procedure While_Do_(e1, e2)		

   return "while " || e1 || " do " || e2

end
