<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>imsutils.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     imsutils.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures to manipulate image specifications
<a name="6"/>#
<a name="7"/>#	Author:   Ralph E. Griswold
<a name="8"/>#
<a name="9"/>#	Date:     May 2, 2001
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#  This file contains procedures that manipulate string representations for
<a name="18"/>#  images.
<a name="19"/>#
<a name="20"/>#	patident(imx1, imx2)
<a name="21"/>#	XDrawTile(win, xoff, yoff, pattern, magnif, mode)
<a name="22"/>#	XDrawRows(win, xoff, yoff, imx, magnif, mode)
<a name="23"/>#	bits2hex(s)
<a name="24"/>#	decspec(pattern)
<a name="25"/>#	getpatt(line)
<a name="26"/>#	getpattnote(line)
<a name="27"/>#	hex2bits(s)
<a name="28"/>#	hexspec(pattern)
<a name="29"/>#	legalpat(tile)
<a name="30"/>#	legaltile(tile)
<a name="31"/>#	pat2xbm(pattern, name)
<a name="32"/>#	tilebits(imx)
<a name="33"/>#	pdensity(pattern)
<a name="34"/>#	pix2pat(window, x, y, cols, rows)
<a name="35"/>#	readims(input)
<a name="36"/>#	readimsline(input)
<a name="37"/>#	rowbits(pattern)
<a name="38"/>#	imstoimx(ims)
<a name="39"/>#	imxtoims(imx)
<a name="40"/>#	showbits(pattern)
<a name="41"/>#	tiledim(pattern)
<a name="42"/>#	pheight(pattern)
<a name="43"/>#	pwidth(pattern)
<a name="44"/>#	xbm2rows(input)
<a name="45"/>#
<a name="46"/>############################################################################
<a name="47"/>#
<a name="48"/>#  Requires:  Version 8.11 graphics
<a name="49"/>#
<a name="50"/>############################################################################
<a name="51"/>#
<a name="52"/>#  Links:  convert
<a name="53"/>#
<a name="54"/>############################################################################
<a name="55"/>
<a name="56"/>package ipl.imsutils
<a name="57"/>
<a name="58"/>import
<a name="59"/>   io(read, reads, write, writes),
<a name="60"/>   ipl.convert(exbase10)
<a name="61"/>
<a name="62"/>record tdim(w, h)
<a name="63"/>
<a name="64"/>#
<a name="65"/>#  Test whether two image matrices are equivalent
<a name="66"/>
<a name="67"/>procedure patident(imx1, imx2)
<a name="68"/>   local i
<a name="69"/>
<a name="70"/>   if *imx1 ~= *imx2 then fail
<a name="71"/>   if **imx1 ~= **imx2 then fail
<a name="72"/>
<a name="73"/>   every i := 1 to *imx1 do
<a name="74"/>      if imx1[i] ~== imx2[1] then fail
<a name="75"/>
<a name="76"/>   return imx2
<a name="77"/>
<a name="78"/>end
<a name="79"/>#
<a name="80"/>#  Draw a tile at a given location.  If mode is nonnull, the
<a name="81"/>#  area on which the tile is drawn is erased.
<a name="82"/>
<a name="83"/>procedure XDrawTile(win, xoff, yoff, pattern, magnif, mode)
<a name="84"/>   local x, y, row, pixel, dims, arglist
<a name="85"/>
<a name="86"/>   if magnif = 1 then win.draw_image(xoff, yoff, pattern, mode)
<a name="87"/>   else {
<a name="88"/>      if \mode then {
<a name="89"/>         dims := tiledim(pattern)
<a name="90"/>         win.erase_area(xoff, yoff, dims.w * magnif, dims.h * magnif)
<a name="91"/>         }
<a name="92"/>      y := yoff
<a name="93"/>      every row := rowbits(pattern) do {		# draw a row
<a name="94"/>         x := xoff
<a name="95"/>         arglist := []
<a name="96"/>         every pixel := !row do {
<a name="97"/>            if pixel = "1" then every put(arglist, x | y | magnif | magnif)
<a name="98"/>            x +:= magnif
<a name="99"/>            }
<a name="100"/>         y +:= magnif
<a name="101"/>         if *arglist = 0 then next
<a name="102"/>         win.fill_rectangle ! arglist
<a name="103"/>         }
<a name="104"/>      }
<a name="105"/>
<a name="106"/>   return
<a name="107"/>
<a name="108"/>end
<a name="109"/>#
<a name="110"/>#  Draw image matrix at a given location.  If mode is nonnull, the
<a name="111"/>#  area on which the tile is drawn is erased.
<a name="112"/>
<a name="113"/>procedure XDrawRows(win, xoff, yoff, imx, magnif, mode)
<a name="114"/>   local x, y, row, pixel, arglist
<a name="115"/>
<a name="116"/>   /magnif := 1
<a name="117"/>
<a name="118"/>   y := yoff
<a name="119"/>
<a name="120"/>   if \mode then
<a name="121"/>      win.erase_area(xoff, yoff, *imx[1] * magnif, *imx * magnif)
<a name="122"/>
<a name="123"/>   every row := !imx do {		# draw a row
<a name="124"/>      x := xoff
<a name="125"/>      arglist := []
<a name="126"/>
<a name="127"/>      if magnif = 1 then {
<a name="128"/>         every pixel := !row do {
<a name="129"/>            if pixel == "1" then every put(arglist, x | y)
<a name="130"/>            x +:= 1
<a name="131"/>            }
<a name="132"/>         y +:= 1
<a name="133"/>         }
<a name="134"/>      else {
<a name="135"/>         every pixel := !row do {
<a name="136"/>            if pixel = "1" then every put(arglist, x | y | magnif | magnif)
<a name="137"/>            x +:= magnif
<a name="138"/>            }
<a name="139"/>         y +:= magnif
<a name="140"/>         }
<a name="141"/>      if *arglist = 0 then next
<a name="142"/>      if magnif = 1 then win.drawpoint ! arglist else win.fill_rectangle ! arglist
<a name="143"/>      }
<a name="144"/>
<a name="145"/>   return
<a name="146"/>
<a name="147"/>end
<a name="148"/>
<a name="149"/>#
<a name="150"/>#  Convert bit string to hex pattern string
<a name="151"/>
<a name="152"/>procedure bits2hex(s)
<a name="153"/>   static bittab
<a name="154"/>   local hex
<a name="155"/>
<a name="156"/>   initial {
<a name="157"/>      bittab := table()
<a name="158"/>      bittab["0000"] := "0"
<a name="159"/>      bittab["1000"] := "1"
<a name="160"/>      bittab["0100"] := "2"
<a name="161"/>      bittab["1100"] := "3"
<a name="162"/>      bittab["0010"] := "4"
<a name="163"/>      bittab["1010"] := "5"
<a name="164"/>      bittab["0110"] := "6"
<a name="165"/>      bittab["1110"] := "7"
<a name="166"/>      bittab["0001"] := "8"
<a name="167"/>      bittab["1001"] := "9"
<a name="168"/>      bittab["0101"] := "a"
<a name="169"/>      bittab["1101"] := "b"
<a name="170"/>      bittab["0011"] := "c"
<a name="171"/>      bittab["1011"] := "d"
<a name="172"/>      bittab["0111"] := "e"
<a name="173"/>      bittab["1111"] := "f"
<a name="174"/>      }
<a name="175"/>
<a name="176"/>   hex := ""
<a name="177"/>
<a name="178"/>   s ? {
<a name="179"/>       while hex := bittab[move(4)] || hex
<a name="180"/>       unless pos(0) then hex := bittab[left(tab(0), 4, "0")] || hex
<a name="181"/>       }
<a name="182"/>
<a name="183"/>   return hex
<a name="184"/>
<a name="185"/>end
<a name="186"/>
<a name="187"/>#
<a name="188"/>#  Convert pattern specification to decimal form
<a name="189"/>
<a name="190"/>procedure decspec(pattern)
<a name="191"/>   local cols, chunk, dec
<a name="192"/>
<a name="193"/>   pattern ? {
<a name="194"/>      upto('#') | return pattern
<a name="195"/>      cols := tab(upto(','))
<a name="196"/>      move(2)
<a name="197"/>      chunk := (cols + 3) / 4
<a name="198"/>      dec := cols || ","
<a name="199"/>      while dec ||:= integer("16r" || move(chunk)) || ","
<a name="200"/>      }
<a name="201"/>
<a name="202"/>   return dec[1:-1]
<a name="203"/>
<a name="204"/>end
<a name="205"/>
<a name="206"/>#
<a name="207"/>#  Get pattern from line.  It trims off leading and trailing whitespace
<a name="208"/>#  and removes any annotation (beginning with a # after the first whitespace
<a name="209"/>
<a name="210"/>procedure getpatt(line)
<a name="211"/>
<a name="212"/>   line ? {
<a name="213"/>      tab(many(' \t'))
<a name="214"/>      return tab(upto(' \t') | 0)
<a name="215"/>      }
<a name="216"/>
<a name="217"/>end
<a name="218"/>
<a name="219"/>#
<a name="220"/>#  Get pattern annotation.  It returns an empty string if there is
<a name="221"/>#  no annotation.
<a name="222"/>
<a name="223"/>procedure getpattnote(line)
<a name="224"/>
<a name="225"/>   line ? {
<a name="226"/>      tab(many(' \t'))			# remove leading whitespace
<a name="227"/>      tab(upto(' \t')) | return ""	# skip pattern
<a name="228"/>      tab(upto('#')) | return ""	# get to annotation
<a name="229"/>      tab(many('# \t'))			# get rid of leading junk
<a name="230"/>      return tab(0)			# annotation
<a name="231"/>      }
<a name="232"/>
<a name="233"/>end
<a name="234"/>
<a name="235"/>#  Convert hexadecimal string to bits
<a name="236"/>
<a name="237"/>procedure hex2bits(s)
<a name="238"/>   static hextab
<a name="239"/>   local bits
<a name="240"/>
<a name="241"/>   initial {
<a name="242"/>      hextab := table()
<a name="243"/>      hextab["0"] := "0000"
<a name="244"/>      hextab["1"] := "0001"
<a name="245"/>      hextab["2"] := "0010"
<a name="246"/>      hextab["3"] := "0011"
<a name="247"/>      hextab["4"] := "0100"
<a name="248"/>      hextab["5"] := "0101"
<a name="249"/>      hextab["6"] := "0110"
<a name="250"/>      hextab["7"] := "0111"
<a name="251"/>      hextab["8"] := "1000"
<a name="252"/>      hextab["9"] := "1001"
<a name="253"/>      hextab["a"] := "1010"
<a name="254"/>      hextab["b"] := "1011"
<a name="255"/>      hextab["c"] := "1100"
<a name="256"/>      hextab["d"] := "1101"
<a name="257"/>      hextab["e"] := "1110"
<a name="258"/>      hextab["f"] := "1111"
<a name="259"/>      }
<a name="260"/>
<a name="261"/>   bits := ""
<a name="262"/>
<a name="263"/>   map(s) ? {
<a name="264"/>      while bits ||:= hextab[move(1)]
<a name="265"/>      }
<a name="266"/>
<a name="267"/>   return bits
<a name="268"/>
<a name="269"/>end
<a name="270"/>
<a name="271"/>#
<a name="272"/>#  Convert pattern to hexadecimal form
<a name="273"/>
<a name="274"/>procedure hexspec(pattern)
<a name="275"/>   local cols, chunk, hex
<a name="276"/>
<a name="277"/>   pattern ? {
<a name="278"/>      if find("#") then return pattern
<a name="279"/>      cols := tab(upto(','))
<a name="280"/>      move(1)
<a name="281"/>      chunk := (cols + 3) / 4
<a name="282"/>      hex := cols || ",#"
<a name="283"/>      while hex ||:= right(exbase10(tab(upto(',') | 0), 16), chunk, "0") do
<a name="284"/>         move(1) | break
<a name="285"/>      }
<a name="286"/>
<a name="287"/>   return hex
<a name="288"/>
<a name="289"/>end
<a name="290"/>
<a name="291"/>#
<a name="292"/>#  Succeed if tile is legal and small enough for (X) pattern.  Other
<a name="293"/>#  windows systems may be more restrictive.
<a name="294"/>
<a name="295"/>procedure legalpat(tile)
<a name="296"/>
<a name="297"/>   legaltile(tile) | fail
<a name="298"/>
<a name="299"/>   tile ? {
<a name="300"/>      if 0 &lt; integer(tab(upto(','))) &lt;= 32 then return tile
<a name="301"/>      else fail
<a name="302"/>      }
<a name="303"/>
<a name="304"/>end
<a name="305"/>
<a name="306"/>#
<a name="307"/>#  Succeed if tile is legal.  Accepts tiles that are too big for
<a name="308"/>#  patterns.
<a name="309"/>
<a name="310"/>procedure legaltile(tile)
<a name="311"/>
<a name="312"/>   map(tile) ? {				# first check syntax
<a name="313"/>      (tab(many(&amp;digits)) &amp; =",") | fail
<a name="314"/>      if ="#" then (tab(many('0123456789abcdef')) &amp; pos(0)) | fail
<a name="315"/>      else {
<a name="316"/>         while tab(many(&amp;digits)) do {
<a name="317"/>            if pos(0) then break	# okay; end of string
<a name="318"/>            else ="," | fail
<a name="319"/>            }
<a name="320"/>         pos(0) | fail	# non-digit
<a name="321"/>         }
<a name="322"/>      }
<a name="323"/>
<a name="324"/>   return hexspec(decspec(tile)) == tile
<a name="325"/>
<a name="326"/>end
<a name="327"/>
<a name="328"/>#
<a name="329"/>#  Convert pattern specification to an XBM image file.
<a name="330"/>
<a name="331"/>procedure pat2xbm(pattern, name)
<a name="332"/>   local dims, chunk, row
<a name="333"/>
<a name="334"/>   /name := "noname"
<a name="335"/>
<a name="336"/>   dims := tiledim(pattern)
<a name="337"/>
<a name="338"/>
<a name="339"/>   write("#define ", name, "_width ", dims.w)
<a name="340"/>   write("#define ", name, "_height ", dims.h)
<a name="341"/>   write("static char ", name, "_bits[] = {")
<a name="342"/>
<a name="343"/>   chunk := (dims.w + 3) / 4
<a name="344"/>
<a name="345"/>   pattern ? {
<a name="346"/>      tab(upto('#') + 1)
<a name="347"/>      while row := move(chunk) do {
<a name="348"/>         if *row % 2 ~= 0 then row := "0" || row
<a name="349"/>         row ? {
<a name="350"/>            tab(0)
<a name="351"/>            while writes("0x", move(-2), ",")
<a name="352"/>            }
<a name="353"/>         write()
<a name="354"/>         }
<a name="355"/>      }
<a name="356"/>
<a name="357"/>   write("};")
<a name="358"/>
<a name="359"/>end
<a name="360"/>
<a name="361"/>#
<a name="362"/>#  Count the number of bits set in a tile
<a name="363"/>
<a name="364"/>procedure tilebits(imx)
<a name="365"/>   local bits
<a name="366"/>
<a name="367"/>   bits := 0
<a name="368"/>
<a name="369"/>   every bits +:= !!imx
<a name="370"/>
<a name="371"/>   return bits
<a name="372"/>
<a name="373"/>end
<a name="374"/>
<a name="375"/>#
<a name="376"/>#  Compute density (percentage of black bits) of pattern
<a name="377"/>
<a name="378"/>procedure pdensity(pattern)
<a name="379"/>
<a name="380"/>   local dark, dims
<a name="381"/>
<a name="382"/>   dims := tiledim(pattern)
<a name="383"/>
<a name="384"/>   hexspec(pattern) ? {
<a name="385"/>      dark := 0
<a name="386"/>      every rowbits(pattern) ? {
<a name="387"/>         every upto('1') do
<a name="388"/>            dark +:= 1
<a name="389"/>            }
<a name="390"/>      return dark / real(dims.w * dims.h)
<a name="391"/>      }
<a name="392"/>
<a name="393"/>end
<a name="394"/>
<a name="395"/>#
<a name="396"/>#  Procedure to produce pattern specification from a section of a window.
<a name="397"/>
<a name="398"/>procedure pix2pat(window, x, y, cols, rows)
<a name="399"/>   local c,  pattern, pixels, y0, pix
<a name="400"/>
<a name="401"/>   pattern := ""
<a name="402"/>
<a name="403"/>   every y0 := 0 to rows - 1 do {
<a name="404"/>      pixels := ""
<a name="405"/>      pix := window.get_pixels(x, y0 + y, cols, 1)
<a name="406"/>      every c := pix.gen() do
<a name="407"/>         pixels ||:= (if c === "0,0,0" then "1" else "0")
<a name="408"/>      pix.close()
<a name="409"/>      pattern ||:= bits2hex(pixels)
<a name="410"/>      }
<a name="411"/>
<a name="412"/>   if *pattern = 0 then fail		# out of bounds specification
<a name="413"/>   else return cols || ",#" || pattern
<a name="414"/>
<a name="415"/>end
<a name="416"/>
<a name="417"/>#
<a name="418"/>#  Read pattern.  It skips lines starting with a #,
<a name="419"/>#  empty lines, and trims off any trailing characters after the
<a name="420"/>#  first whitespace of a pattern.
<a name="421"/>
<a name="422"/>procedure readims(input)
<a name="423"/>   local line
<a name="424"/>
<a name="425"/>   while line := read(input) do
<a name="426"/>      line ? {
<a name="427"/>         if pos(0) | ="#" then next
<a name="428"/>         return tab(upto(' \t') | 0)
<a name="429"/>         }
<a name="430"/>
<a name="431"/>   fail
<a name="432"/>
<a name="433"/>end
<a name="434"/>
<a name="435"/>#  
<a name="436"/>#  Read pattern line.  It skips lines starting with a # and empty lines but
<a name="437"/>#  does not trim off any trailing characters after the first whitespace of
<a name="438"/>#  a pattern.
<a name="439"/>
<a name="440"/>procedure readimsline(input)
<a name="441"/>   local line
<a name="442"/>
<a name="443"/>   while line := read(input) do
<a name="444"/>      line ? {
<a name="445"/>         if pos(0) | ="#" then next
<a name="446"/>         return tab(0)
<a name="447"/>         }
<a name="448"/>
<a name="449"/>   fail
<a name="450"/>
<a name="451"/>end
<a name="452"/>
<a name="453"/>#
<a name="454"/>#  Generate rows of bits in a pattern.  Doesn't work correctly for small
<a name="455"/>#  patterns.  (Why?)
<a name="456"/>
<a name="457"/>procedure rowbits(pattern)
<a name="458"/>   local row, dims, chunk, hex
<a name="459"/>
<a name="460"/>   dims := tiledim(pattern)
<a name="461"/>
<a name="462"/>   hexspec(pattern) ? {
<a name="463"/>      tab(upto(',') + 2)
<a name="464"/>      hex := tab(0)
<a name="465"/>      chunk := *hex / dims.h
<a name="466"/>      hex ? {
<a name="467"/>         while row := right(hex2bits(move(chunk)), dims.w, "0") do
<a name="468"/>            suspend reverse(row)
<a name="469"/>         }
<a name="470"/>      }
<a name="471"/>
<a name="472"/>end
<a name="473"/>
<a name="474"/>#
<a name="475"/>#  Produce an image matrix from a image string
<a name="476"/>
<a name="477"/>procedure imstoimx(ims)
<a name="478"/>   local imx
<a name="479"/>
<a name="480"/>   imx := []
<a name="481"/>
<a name="482"/>   every put(imx, rowbits(ims))
<a name="483"/>
<a name="484"/>   return imx
<a name="485"/>
<a name="486"/>end
<a name="487"/>
<a name="488"/>#
<a name="489"/>#  Convert row list to pattern specification
<a name="490"/>
<a name="491"/>procedure imxtoims(imx)
<a name="492"/>   local pattern
<a name="493"/>
<a name="494"/>   pattern := *imx[1] || ",#"
<a name="495"/>
<a name="496"/>   every pattern ||:= bits2hex(!imx)
<a name="497"/>
<a name="498"/>   return pattern
<a name="499"/>
<a name="500"/>end
<a name="501"/>
<a name="502"/>#  Show bits of a pattern
<a name="503"/>
<a name="504"/>procedure showbits(pattern)
<a name="505"/>
<a name="506"/>   every write(rowbits(pattern))
<a name="507"/>
<a name="508"/>   write()
<a name="509"/>
<a name="510"/>   return
<a name="511"/>
<a name="512"/>end
<a name="513"/>
<a name="514"/>
<a name="515"/>#
<a name="516"/>#  Produce dimensions of the tile for a pattern
<a name="517"/>
<a name="518"/>procedure tiledim(pattern)
<a name="519"/>   local cols
<a name="520"/>
<a name="521"/>   hexspec(pattern) ? {
<a name="522"/>      cols := integer(tab(upto(',')))
<a name="523"/>      move(2)
<a name="524"/>      return tdim(cols, *tab(0) / ((cols + 3) / 4))
<a name="525"/>      }
<a name="526"/>
<a name="527"/>end
<a name="528"/>
<a name="529"/>#
<a name="530"/>#  Produce height of a pattern specification
<a name="531"/>
<a name="532"/>procedure pheight(pattern)
<a name="533"/>   local cols
<a name="534"/>
<a name="535"/>   hexspec(pattern) ? {
<a name="536"/>      cols := integer(tab(upto(',')))
<a name="537"/>      move(2)
<a name="538"/>      return  *tab(0) / ((cols + 3) / 4)
<a name="539"/>      }
<a name="540"/>
<a name="541"/>end
<a name="542"/>
<a name="543"/>#
<a name="544"/>#  Produce width of a pattern specification
<a name="545"/>
<a name="546"/>procedure pwidth(pattern)
<a name="547"/>
<a name="548"/>   hexspec(pattern) ? {
<a name="549"/>      return integer(tab(upto(',')))
<a name="550"/>      }
<a name="551"/>
<a name="552"/>end
<a name="553"/>
<a name="554"/>#
<a name="555"/>#  Generate rows of bits from an XBM file.  Note:  This apparently
<a name="556"/>#  is not quite right if there are more than 2 hex digits per
<a name="557"/>#  literal.
<a name="558"/>
<a name="559"/>procedure xbm2rows(input)
<a name="560"/>   local imagex,  row, hex, width, height, chunks
<a name="561"/>   static hexdigit
<a name="562"/>
<a name="563"/>   initial hexdigit := &amp;digits ++ 'abcdef'
<a name="564"/>
<a name="565"/>   imagex := ""
<a name="566"/>
<a name="567"/>   read(input) ? {
<a name="568"/>      tab(find("width") + 6)
<a name="569"/>      tab(upto(&amp;digits))
<a name="570"/>      width := integer(tab(many(&amp;digits)))
<a name="571"/>      }
<a name="572"/>
<a name="573"/>   read(input) ? {
<a name="574"/>      tab(find("height") + 6)
<a name="575"/>      tab(upto(&amp;digits))
<a name="576"/>      height := integer(tab(many(&amp;digits)))
<a name="577"/>      }
<a name="578"/>
<a name="579"/>   chunks := (width / 8) + if (width % 8) &gt; 0 then 1 else 0
<a name="580"/>
<a name="581"/>   while imagex ||:= reads(input, 500000)	# Boo! -- can do better
<a name="582"/>
<a name="583"/>   imagex ? {
<a name="584"/>      every 1 to height do {
<a name="585"/>         row := ""
<a name="586"/>         every 1 to chunks do {
<a name="587"/>            unless hex := tab(any(hexdigit)) || tab(any(hexdigit)) then {
<a name="588"/>               tab(find("0x") + 2)
<a name="589"/>               hex := move(2)
<a name="590"/>               }
<a name="591"/>            row ||:= case hex of {
<a name="592"/>              "00":    "00000000"
<a name="593"/>              "ff":    "11111111"
<a name="594"/>               default: reverse(right(hex2bits(hex), 8, "0"))
<a name="595"/>               }
<a name="596"/>            }
<a name="597"/>         suspend left(row, width)
<a name="598"/>         }
<a name="599"/>      }
<a name="600"/>
<a name="601"/>end
</pre></body></html>
