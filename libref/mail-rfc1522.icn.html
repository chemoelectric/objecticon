<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>rfc1522.icn</title></head><body><pre>
<a name="1"/>package mail
<a name="2"/>
<a name="3"/>import util, lang, ipl.base64
<a name="4"/>
<a name="5"/>class RFC1522()
<a name="6"/>   public static const
<a name="7"/>      Q_PRINTABLE_CHAR,
<a name="8"/>      LWSP_CHAR
<a name="9"/>
<a name="10"/>   private static init()
<a name="11"/>      Q_PRINTABLE_CHAR := &amp;letters ++ &amp;digits
<a name="12"/>      LWSP_CHAR := ' \t'
<a name="13"/>   end
<a name="14"/>
<a name="15"/>   #
<a name="16"/>   # Convert the given string using rfc1522 encoding, ie to one potentially
<a name="17"/>   # including "encoded words".
<a name="18"/>   #
<a name="19"/>   # :Parameters :
<a name="20"/>   # :  `s` - the source string, either string or ucs
<a name="21"/>   # :  `alphabet` - the cset of characters which don't need to be encoded,
<a name="22"/>   #        by default `&amp;ascii`, minus `'=?'` if `s` contains `"=?"`, so we
<a name="23"/>   #        don't pass through things that look like encoded words but aren't.
<a name="24"/>   # :Parameters :
<a name="25"/>   # :  `delimeter` - the cset of word delimeters, by default `' \t'`.
<a name="26"/>   # :  `charset` - the charset to use, default is UTF-8 for a ucs string
<a name="27"/>   #        and ISO-8859-1 for a string.
<a name="28"/>   # :  `encoding` - either "B" (the default) or "Q"
<a name="29"/>   #
<a name="30"/>   public static encode(s, alphabet, delimeter, charset, encoding)
<a name="31"/>      local t, pre, res, i, j, k, na, adj
<a name="32"/>      /alphabet := if find("=?", s) then &amp;ascii -- '=?' else &amp;ascii
<a name="33"/>      /delimeter := LWSP_CHAR
<a name="34"/>      if type(s) == "ucs" then {
<a name="35"/>         /charset := "UTF-8"
<a name="36"/>         s := string(s)
<a name="37"/>      } else
<a name="38"/>         /charset := "ISO-8859-1"
<a name="39"/>      /encoding := "B"
<a name="40"/>
<a name="41"/>      pre := "=?" || charset || "?" || encoding || "?"
<a name="42"/>      res := ""
<a name="43"/>      na := ~alphabet
<a name="44"/>      s ? {
<a name="45"/>         while i := upto(na) do {
<a name="46"/>            # Go back to the beginning of the word to encode.
<a name="47"/>            j := i
<a name="48"/>            while j &gt; &amp;pos &amp; not any(delimeter,, j - 1) do
<a name="49"/>               j -:= 1
<a name="50"/>            # ... and go forward to the end.
<a name="51"/>            k := upto(delimeter,, j + 1) | 0
<a name="52"/>
<a name="53"/>            # On decoding, whitespace-only between adjacent encoded-words
<a name="54"/>            # is ignored.  In that case therefore it must be included in
<a name="55"/>            # the encoded-word itself, and a space added to separate the
<a name="56"/>            # encoded words.
<a name="57"/>            #
<a name="58"/>            if /adj | upto(~LWSP_CHAR,,, j) then
<a name="59"/>               res ||:= tab(j)
<a name="60"/>            else
<a name="61"/>               res ||:= " "
<a name="62"/>
<a name="63"/>            t := tab(k)
<a name="64"/>            res ||:= pre
<a name="65"/>            case Text.lower(encoding) of {
<a name="66"/>               "b": {
<a name="67"/>                  res ||:= base64encode(t)
<a name="68"/>               }
<a name="69"/>               "q": {
<a name="70"/>                  t ? until pos(0) do {
<a name="71"/>                     res ||:= tab(many(Q_PRINTABLE_CHAR)) |
<a name="72"/>                        (=" ", "_") |
<a name="73"/>                        "=" || Format.int_to_string(ord(move(1)), 16, 2)
<a name="74"/>                  }
<a name="75"/>               }
<a name="76"/>               default:
<a name="77"/>                  runerr("Unknown content word encoding", encoding)
<a name="78"/>            }
<a name="79"/>            res ||:= "?="
<a name="80"/>            adj := &amp;yes
<a name="81"/>         }
<a name="82"/>         return res || tab(0)
<a name="83"/>      }
<a name="84"/>   end
<a name="85"/>
<a name="86"/>   private static q_decode(s)
<a name="87"/>      local r
<a name="88"/>      r := ""
<a name="89"/>      s ? {
<a name="90"/>         while r ||:= tab(upto('_=')) do {
<a name="91"/>            r ||:= if ="_" then
<a name="92"/>               " "
<a name="93"/>            else {
<a name="94"/>               move(1)
<a name="95"/>               char(Format.string_to_int(move(2))) | return error("Bad q-encoded data")
<a name="96"/>            }
<a name="97"/>         }
<a name="98"/>         return r || tab(0)
<a name="99"/>      }
<a name="100"/>   end
<a name="101"/>
<a name="102"/>   #
<a name="103"/>   # This does the reverse of `encode`.  Any encoded words are expanded and
<a name="104"/>   # the result is returned.  The result may be a ucs string if any encoded word
<a name="105"/>   # had utf-8 encoding; otherwise the result is a normal string.
<a name="106"/>   # :Parameters :
<a name="107"/>   # :  `s` - the source string.
<a name="108"/>   #
<a name="109"/>   public static decode(s)
<a name="110"/>      local charset, encoding, data, res, t, adj
<a name="111"/>      res := ""
<a name="112"/>      s ? {
<a name="113"/>         while t := tab(find("=?")) do {
<a name="114"/>            #
<a name="115"/>            # Whitespace between adjacent encoded-words must be ignored.
<a name="116"/>            #
<a name="117"/>            if /adj | upto(~LWSP_CHAR, t) then
<a name="118"/>               res ||:= t
<a name="119"/>
<a name="120"/>            move(2)
<a name="121"/>            charset := tab(upto('?')) | return error("Badly formed encoded word")
<a name="122"/>            move(1)
<a name="123"/>            encoding := tab(upto('?')) | return error("Badly formed encoded word")
<a name="124"/>            move(1)
<a name="125"/>            data := tab(upto('?')) | return error("Badly formed encoded word")
<a name="126"/>            t := case Text.lower(encoding) of {
<a name="127"/>               "b": base64decode(data) | fail
<a name="128"/>               "q": q_decode(data) | fail
<a name="129"/>               default:
<a name="130"/>                  return error("Unknown content word encoding: " || encoding)
<a name="131"/>            }
<a name="132"/>            if Text.lower(charset) == "utf-8" then
<a name="133"/>               t := ucs(t) | return error("Encoded word data not proper UTF-8")
<a name="134"/>            res ||:= t
<a name="135"/>            ="?="  | return error("Encoded word did not end with ?=")
<a name="136"/>            adj := &amp;yes
<a name="137"/>         }
<a name="138"/>         return res || tab(0)
<a name="139"/>      }
<a name="140"/>   end
<a name="141"/>end
</pre></body></html>
