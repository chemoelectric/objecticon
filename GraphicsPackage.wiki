#summary Low-level graphics interface.
<wiki:toc max_depth="3" />
= Introduction =
Object Icon's graphic facilities are based on Icon's, but with quite a large number of features omitted, and a few added, most notably support for transluscent colours, alpha channels and compositing.  Also, the programming interface is re-cast into an object-oriented form, consistent with the rest of the library.

The following notable features in Icon's graphic facilities are omitted from Object Icon's :-

 * The notion of a window as a file; in Object Icon a window is merely an object.
 * Mutable colors.
 * The use of a window as a sort of terminal, with a notional cursor position.
 * Gamma correction
 * The bit manipulation drawops and the color reversal flag.
 * The Icon image string and pattern string formats

Icon's graphics facilities are described in the following document :-
http://www.cs.arizona.edu/icon/docs/ipd281.htm

== Opening a window ==

Use the constructor of `Window` to open a window.  This gives a hidden window of size 1 pixel by 1 pixel, with default attributes.  These can then be modified using setter methods before the window is made visible by setting the canvas type to "normal".  For example :-
{{{
   w := Window().
      set_size(200,200).
      set_fg("red").
      set_bg("light grey").
      set_font("serif,24").
      erase_area().
      set_canvas("normal") | stop(&why)
}}}
The `Window` class has methods for manipulating the window and drawing in it.

== Setting Window attributes ==

The various setter methods for setting window attributes are summarised in the following table.

|| *Method* || *Parameter(s)* || *Description* ||
||set_bg||string||Background color||
||set_canvas||string||Window visibility||
||clip||4xinteger||Clipping region||
||unclip||-||Unset clipping region||
||set_draw_op||string||Compositing operator||
||set_dx||integer||Window horizontal offset||
||set_dy||integer||Window vertical offset||
||set_fg||string||Foreground color||
||set_font||string||Current text font||
||set_geometry||4xinteger||Window position and size||
||set_height||integer||Window height||
||set_icon||string or Pixels||Window icon||
||set_image||string or Pixels||Draw an image and set window size to image size||
||set_input_mask||string||Mask of mouse/keyboard events||
||set_label||string||Window label (title)||
||set_line_style||string||Line style to use in drawing||
||set_line_width||integer||Line style to use in drawing||
||set_max_height||integer||Maximum window height||
||set_max_size||2xinteger||Maximum window size||
||set_max_width||integer||Maximum window width||
||set_min_height||integer||Minimum window height||
||set_min_size||2xinteger||Minimum window size||
||set_min_width||integer||Minimum window width||
||set_pattern||string or Pixels||Image to use to fill instead of foreground colour||
||set_pointer||string||Mouse pointer||
||set_pos||2xinteger||Window position on screen||
||set_transient_for||Window||Transient-for window||
||set_x||integer||Window x position||
||set_y||integer||Window y position||
||set_resize||flag||Resizable flag||
||set_size||2xinteger||Window size||
||set_width||integer||Window width||

Most of the attributes have corresponding `get` methods.

== Fonts ==
Fonts follow the same format as in Icon, with some minor enhancements.  The environment variable `OIFONT` specifies the default font to use in a window, and `OIFONTSIZE` specifies the default fontsize; if not given the default font size is 12.  Font sizes need not be integers.  Font sizes can also be specified as relative to the default font size, byprefixing with a `+` or a `-`.  So for example, if `OIFONTSIZE` was set to "11.5", then "sans" would be the same as "sans,11.5", and "sans,+2" would be the same as "sans,13.5".  A static method in the `Window` class, `get_default_font_size()`, returns the default font size.

On X11, Xft, Fontconfig and Freetype are used for fonts.  With fontconfig, further customization can be achieved by editing the `~/.fonts.conf` file and defining patterns for the following family names :-

|| *Icon font family* || *Xft family name* || *Default value* ||
|| fixed || Object Icon fixed || mono ||
|| mono || Object Icon mono || mono ||
|| typewriter || Object Icon typewriter || courier ||
|| sans || Object Icon sans || helvetica ||
|| serif || Object Icon serif || times ||

An example entry, which makes the Icon mono family use the "Deja Vu Sans Mono" font, is as follows :-
{{{
<match target="pattern">
   <test name="family">
      <string>Object Icon mono</string>
   </test>
   <edit name="family" mode="prepend" binding="same">
      <string>Deja Vu Sans Mono</string>
   </edit>
 </match>
}}}
 
A font specifier may specify a string to be interpreted directly by the platform's font system.  When using fontconfig, this is done by prepending the string "fc:" to the specifier (for example, "fc:Bitstream Vera Sans-11").  The result of the `get_font()` method will in fact always be in this platform-specific format.  Note that the setting of `OIFONTSIZE` has no effect on a font specified in this way.

== Colours and Palettes ==
Colour specifications and palettes follow the same format as in Icon, with an enhancement to allow specification of transluscent colours.  For a colour specified numerically, a fourth optional value can be added to specify the alpha value.  For a colour specified with a string name, a percentage may be appended to give the tranluscency.  For example :-
{{
"45874,0,0,52428"   # 70% red, 80% alpha
"dark blue 50%"
}}

== Images and the Pixels class ==
Image data is represented using the `Pixels` class.  This is just a two-dimensional array of pixel data, stored in various formats.  Pixel data can come from a number of sources :-

 * An image file.  Possible formats are gif, png and jpeg; the latter two depend on the right libraries being available.
 * Raw image data stored as a string, also in gif, png or jpeg format.
 * An image grabbed from part of a `Window`
 * A blank image

To create an instance from an image file use the `Pixels` constructor, passing the filename.  The constructor is also used to create an instance from raw data.  This can easily be done using the preprocessor `$load` directive to compile image data into the executable.  An example of this would be
{{{
$load FLINTSTONES "/tmp/flintstones.jpg"

...
   i := Pixels(FLINTSTONES)
...
}}}
The `$load` directive defines the preprocessor symbol `FLINTSTONES` with the value being a string containing the contents of the specified file.   An advantage of using this technique is that the image file does not of course have to be present at runtime (only at compile time).

To get pixels from a `Window`, use its `get_pixels` method, and to create a new blank image,  use the `Pixels` constructor, passing width, height and optionally the desired underlying format.  For example :-
{{{
   i := Pixels(3, 3, Pixels.RGBA32)
}}}
creates a 3x3 image using 32 bits per pixel.  Some formats do not store an alpha channel; in this case reading back from the image always gives an opaque pixel.

Paletted images are supported.  Rather than storing pixel data directly, indices into a palette of colours are stored instead.  Additional methods in `Pixels` are provided for editing the palette for such formats.

A `Pixels` image can be used with a `Window` in several ways :-

 * The image can be written to the window with `draw_image`
 * The image can be used as a fill pattern with `set_pattern`; it is then used instead of the foreground colour.
 * The window icon can be set with `set_icon`
 * The window's contents and size can be set according to an image with `set_image`.

After use, a `Pixels` instance should be closed in order to free the memory it uses.
== Compositing and draw_op ==
The compositing operator used by the drawing functions can be set using `set_draw_op`.  The possible values are :-

"atop", "clear", "dest", "dest atop", "dest in", "dest out", "dest over", "in", "out", "over", "source", "xor"

The default is "over".

Here is an example to illustrate how different draw operators can be used.  This example creates a circular mask, then combines it with an image using the "in" operator, and finally adds a blue background using the "dest over" operator.

{{{
import io, graphics, ipl.graphics

$load CAT "/tmp/cheetah_cubs.jpg"

procedure circle_mask(d)
   local p, i, j, r2, r, s, a
   p := Pixels(d, d, Pixels.A8)
   r := d / 2
   r2 := r * r
   every j := 0 to d - 1 do
      every i := 0 to d - 1 do
         if (s := (i - r)^2 + (j - r)^2) < r2 then {
            a := ((r2 - s) * 65535) / r2
            p.set_rgba(i, j, 0,0,0, a)
         }
   return p
end

procedure main()
   local cat, cm, w

   # Create a image of the cheetahs
   cat := Pixels(CAT) | stop(&why)

   # Create a circular mask image.  The parameter gives the diameter.
   # The further away from the centre of the circle, the more
   # transparent is the mask, with the centre being opaque.
   cm := circle_mask(cat.get_width())

   w := Window().
      # Copy the circle mask to w; "source" must be used here so that
      # the mask is copied to w (rather than combined with the w's
      # underlying background).
      set_draw_op("source").
      set_image(cm).
      # Now draw the cat using the "in" operator.  Where the alpha
      # value of the mask (and hence w) is more opaque, more of the
      # cat image is written to w.  Conversely, where it is more
      # transparent, less of the cat image is written.  The alpha
      # values in w are unchanged.
      set_draw_op("in").
      draw_image(,, cat).
      # Finally set a background colour.  Where w is opaque, less blue
      # is written; where transparent, more.  Afterwards, the alpha
      # values of w will be 100% opaque.
      set_fg("very light blue").
      set_draw_op("dest over").
      fill_rectangle().
      set_canvas("normal")

   until WQuit(w) do delay(10)

   every (w | cat | cm).close()
end
}}}
The cheetah image looks like this in its raw form :-

http://objecticon.googlecode.com/svn/wiki/cheetah_cubs.jpg

The resulting window is as follows :-

http://objecticon.googlecode.com/svn/wiki/maskresult.png

== Filters ==
The `filter` method is used to efficiently transform a rectangular area of pixels, according to one of several pre-defined filters.  The available filters are as follows :-

 * *linear*.  The linear filter accepts 3 float parameters followed by 3 optional integer parameters (which default to zero).  Each pair provides a linear transformation to apply to the red, green and blue values of each pixel.  For example
{{{
W.filter("linear,0.6,0.75,1.0")
}}}
 * *shade*.  This filter accepts three integer parameters.  It is a rather specialised filter, used to "grey-out" gui components.  The first parameter specifies a range of grey bands.  The grey band of the background is calculated.  Then each pixel's grey band value is calculated.  If it differs from the background's band value, then a new grey pixel is calculated by multipling the existing pixel's grey band value by the second parameter, and adding the third parameter.  The default filter used by the "gui" package is :-
{{{
W.filter("shade,4,5000,40000")
}}}
 Note that the maximum possible new pixel value is `4*5000 + 40000 = 60000`, within the defined range of values (ie, `0 - 65535`).
 * *invert*.  This filter takes no parameters.  Each pixel's red, green and blue values is replaced with the value 65535 - _current value_.
 * *coerce*.  This filter takes one string parameter, namely a palette.  Each pixel is coerced into the permitted colors in that palette.  Thus the following example transforms the image into one in which each pixel has one of 256 possible greyscale values.
{{{
W.filter("coerce,g256")
}}}

== Events ==
Events are generated from a window as lists.  The first element of the list gives the event code, which is one of the following.  The number and type of the other elements depends on the code.

|| *Type* || *Description* ||
|| Mouse.LEFT_PRESS || Mouse left button press ||
|| Mouse.MIDDLE_PRESS || Mouse middle button press ||
|| Mouse.RIGHT_PRESS || Mouse right button press ||
|| Mouse.LEFT_RELEASE || Mouse left button release ||
|| Mouse.MIDDLE_RELEASE || Mouse middle button release ||
|| Mouse.RIGHT_RELEASE || Mouse right button release ||
|| Mouse.DRAG || Mouse drag with any button down ||
|| Mouse.MOVEMENT || Mouse movement with no button down ||
|| Mouse.WHEEL_UP || Mouse wheel upward direction ||
|| Mouse.WHEEL_DOWN || Mouse wheel downward direction ||
|| Mouse.ENTER || Mouse cursor enters window ||
|| Mouse.EXIT || Mouse cursor leaves window ||
|| Window.RESIZE || Window resized ||
|| Window.CLOSE_BUTTON || Window close button pressed ||
|| Window.INVOKE_LATER || Internal use by gui package ||
|| Selection.REQUEST || Another application has requested a selection ||
|| Selection.RESPONSE || Another application has responded to a request for a selection ||
|| Selection.CLEAR || A selection must be cleared ||
|| String or ucs || A key representing the given string has been pressed or released ||
|| Positive integer || A key with the numeric code has been pressed or released ||

The class `Key` contains a several constants which match the numeric key codes in the last class of event in the above table.

The keyboard and mouse events all produce a list of 5 items (including the initial code) :-
 # Code
 # Mouse x position
 # Mouse y position
 # Timestamp in milliseconds
 # Keyboard state flags, being a combination of
   * Key.MOD_SHIFT - the shift key was pressed
   * Key.MOD_LOCK - the caps lock key was pressed
   * Key.MOD_CTRL - the ctrl key was pressed
   * Key.MOD_META - the meta key was pressed
   * Key.MOD_META2
   * Key.MOD_META3
   * Key.MOD_META4
   * Key.MOD_META5
   * Key.MOD_RELEASE - the key event was a release (rather than a press).
