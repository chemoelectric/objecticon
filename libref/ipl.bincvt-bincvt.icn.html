<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>bincvt.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     bincvt.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures to convert binary data
<a name="6"/>#
<a name="7"/>#	Author:   Robert J. Alexander
<a name="8"/>#
<a name="9"/>#	Date:     October 16, 1996
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#  These procedures are normally used for processing of binary data
<a name="14"/>#  read from, or to be written to, a file.
<a name="15"/>#
<a name="16"/>############################################################################
<a name="17"/>#
<a name="18"/>#   This file is in the public domain.
<a name="19"/>#
<a name="20"/>############################################################################
<a name="21"/>
<a name="22"/>package ipl.bincvt
<a name="23"/>
<a name="24"/>import util(need_string, need_integer)
<a name="25"/>
<a name="26"/>#
<a name="27"/>#  Convert the bytes of string s into an integer, assuming big-endian
<a name="28"/>#  ordering, and that the input represents an unsigned number.
<a name="29"/>#
<a name="30"/>procedure be_unsigned(s)
<a name="31"/>   local i
<a name="32"/>   s := need_string(s)
<a name="33"/>   i := 0
<a name="34"/>   every i := ord(s) + 256 * i
<a name="35"/>   return i
<a name="36"/>end
<a name="37"/>
<a name="38"/>#
<a name="39"/>#  Convert the bytes of string s into an integer, assuming big-endian
<a name="40"/>#  ordering, and that the input represents a two's complement signed
<a name="41"/>#  number.
<a name="42"/>#
<a name="43"/>procedure be_signed(s)
<a name="44"/>   local i
<a name="45"/>   s := need_string(s)
<a name="46"/>   i := be_unsigned(s)
<a name="47"/>   if ord(s[1]) &gt;= 128 then
<a name="48"/>      i -:= ishift(1, 8 * *s)
<a name="49"/>   return i
<a name="50"/>end
<a name="51"/>
<a name="52"/>#
<a name="53"/># The same as `be_unsigned`, but assuming little-endian ordering.  It
<a name="54"/># is equivalent to :-
<a name="55"/># ~
<a name="56"/>#   be_unsigned(reverse(s))
<a name="57"/># ~
<a name="58"/>#
<a name="59"/>procedure le_unsigned(s)
<a name="60"/>   local i, j
<a name="61"/>   s := need_string(s)
<a name="62"/>   i := 0
<a name="63"/>   j := 1
<a name="64"/>   every i +:= j * ord(s) do
<a name="65"/>      j *:= 256
<a name="66"/>   return i
<a name="67"/>end
<a name="68"/>
<a name="69"/>#
<a name="70"/># The same as `be_signed`, but assuming little-endian ordering.  It is
<a name="71"/># equivalent to :-
<a name="72"/># ~
<a name="73"/>#   be_signed(reverse(s))
<a name="74"/># ~
<a name="75"/>#
<a name="76"/>procedure le_signed(s)
<a name="77"/>   local i
<a name="78"/>   s := need_string(s)
<a name="79"/>   i := le_unsigned(s)
<a name="80"/>   if ord(s[-1]) &gt;= 128 then
<a name="81"/>      i -:= ishift(1, 8 * *s)
<a name="82"/>   return i
<a name="83"/>end
<a name="84"/>
<a name="85"/>#
<a name="86"/># Returns a string from the low order `size` bytes of integer `i`,
<a name="87"/># assuming big-endian ordering.  If `i` is negative, then a two's
<a name="88"/># complement representation is the result.  For example :-
<a name="89"/># ~
<a name="90"/>#  be_string(1234, 4) == "\x00\x00\x04\xd2"
<a name="91"/>#  be_string(-1234, 4) == "\xff\xff\xfb."
<a name="92"/># ~
<a name="93"/># For all `i` in the range `0 &lt;= i &lt;= 2^(8*size) - 1`,
<a name="94"/># ~
<a name="95"/>#  be_unsigned(be_string(i, size)) = i
<a name="96"/># ~
<a name="97"/># and in the range `-(2^((8*size)-1)) &lt;= i &lt;= 2^((8*size)-1) - 1`
<a name="98"/># ~
<a name="99"/>#  be_signed(be_string(i, size)) = i
<a name="100"/># ~
<a name="101"/>#
<a name="102"/>procedure be_string(i, size)
<a name="103"/>   return reverse(le_string(i, size))
<a name="104"/>end
<a name="105"/>
<a name="106"/>#
<a name="107"/># The same as `be_string`, but assuming little-endian ordering. It is
<a name="108"/># equivalent to :-
<a name="109"/># ~
<a name="110"/>#   reverse(be_string(i, size))
<a name="111"/># ~
<a name="112"/>procedure le_string(i, size)
<a name="113"/>   local s
<a name="114"/>   i := need_integer(i)
<a name="115"/>   size := need_integer(size, 1)
<a name="116"/>   s := ""
<a name="117"/>   every 1 to size do {
<a name="118"/>      s ||:= char(iand(i, 16rff))
<a name="119"/>      i := ishift(i, -8)
<a name="120"/>   }
<a name="121"/>   return s
<a name="122"/>end
<a name="123"/>
<a name="124"/>#
<a name="125"/># Returns a string which is a binary representation of integer `i`,
<a name="126"/># which may be negative, in the fewest number of characters necessary,
<a name="127"/># so that for any `i`,
<a name="128"/># ~
<a name="129"/>#     be_signed(be_signed_string(i)) = i
<a name="130"/># ~
<a name="131"/>#
<a name="132"/>procedure be_signed_string(i)
<a name="133"/>   return reverse(le_signed_string(i))
<a name="134"/>end
<a name="135"/>
<a name="136"/>#
<a name="137"/># Returns a string which is a binary representation of non-negative
<a name="138"/># integer `i`, in the fewest number of characters necessary, so
<a name="139"/># that for any valid `i`,
<a name="140"/># ~
<a name="141"/>#     be_unsigned(be_unsigned_string(i)) = i
<a name="142"/># ~
<a name="143"/># The output may be shorter than `be_signed_string`; for example
<a name="144"/># ~
<a name="145"/>#  be_signed_string(200) == "\x00\xc8"
<a name="146"/>#  be_unsigned_string(200) == "\xc8"
<a name="147"/># ~
<a name="148"/># Obviously the output of this procedure shouldn't be given to
<a name="149"/># `be_signed` (the above example of 200 would give a negative result).
<a name="150"/>#
<a name="151"/>procedure be_unsigned_string(i)
<a name="152"/>   return reverse(le_unsigned_string(i))
<a name="153"/>end
<a name="154"/>
<a name="155"/>#
<a name="156"/># The little-endian equivalent of `be_signed_string`.  It is
<a name="157"/># equivalent to :-
<a name="158"/># ~
<a name="159"/>#   reverse(be_signed_string(i))
<a name="160"/># ~
<a name="161"/>procedure le_signed_string(i)
<a name="162"/>   local s, j
<a name="163"/>   i := need_integer(i)
<a name="164"/>   s := ""
<a name="165"/>   repeat {
<a name="166"/>      s ||:= char(j := iand(i, 16rff))
<a name="167"/>      i := ishift(i, -8)
<a name="168"/>      if (i = 0 &amp; j &lt; 128) | (i = -1 &amp; j &gt;= 128) then break
<a name="169"/>   }
<a name="170"/>   return s
<a name="171"/>end
<a name="172"/>
<a name="173"/>#
<a name="174"/># The little-endian equivalent of `be_unsigned_string`.  It is
<a name="175"/># equivalent to :-
<a name="176"/># ~
<a name="177"/>#   reverse(be_unsigned_string(i))
<a name="178"/># ~
<a name="179"/>procedure le_unsigned_string(i)
<a name="180"/>   local s, j
<a name="181"/>   i := need_integer(i, 0)
<a name="182"/>   s := ""
<a name="183"/>   repeat {
<a name="184"/>      s ||:= char(j := iand(i, 16rff))
<a name="185"/>      i := ishift(i, -8)
<a name="186"/>      if i = 0 then break
<a name="187"/>   }
<a name="188"/>   return s
<a name="189"/>end
</pre></body></html>
