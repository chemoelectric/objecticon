#
# $Id$
#
# This file is in the public domain.
#
# Author: Robert Parlett (parlett@dial.pipex.com)
#

package gui

import 
   graphics,
   lang,
   ipl.sets,
   ipl.lists,
   ipl.pdco

#
#
# This is the parent class of a dialog window.
#
class Dialog(Component)
   public static 
      ROOT_WATTRIBS, 
      DEFAULT_POINTER,
      DOUBLE_CLICK_DELAY,        # Repeat event delays
      TOOLTIP_START_DELAY,       # Default tooltip delays
      TOOLTIP_END_DELAY,
      TOOLTIP_CONTINUE_DELAY,
      TOOLTIP_X_OFFSET,
      TOOLTIP_Y_OFFSET

   public 
      win,                     # The dialog's window.
      is_open_flag,            # Flag indicates whether window is open              
      owning_dialog,
      child_dialogs,
      focus,                   # Component with current focus            
      menu_mode,               # Do we have a menu open?
      buffer_win,              # Buffer window for double buffering                 
      click_count,             # Variables controlling multiple clicks
      prev_time,
      prev_event,
      is_blocked_flag,
      resize_attrib,
      drag_gesture_x,
      drag_gesture_y,
      curr_drag,
      curr_drag_holder,
      curr_drop,
      tried_drag,
      tooltip_ticker,
      tooltip_last_obj, 
      tooltip_last_tip, 
      tooltip_state,
      tooltip_start_time,
      tooltip_end_time,
      tooltip_continue_time,
      tooltip_component, 
      point_chain,
      point_chain_source,
      copy_rect,
      held,
      moving,
      selection_requests,
      selections,
      popup_manager,
      popups

   public needs_validate()
      return \copy_rect
   end

   public validate()
      local r

      \copy_rect | fail

      # Copy copy_rect just in case invoke_display invalidates something (and hence
      # changes copy_rect unexpectedly).
      r := copy_rect
      copy_rect := &null

      self.invoke_display(r)

      cbwin.copy_to(win, r.x, r.y, r.w, r.h, r.x, r.y)
   end

   public invalidate_rect(r)
      if /copy_rect then
         copy_rect := Rect(r.x, r.y, r.w, r.h)
      else
         copy_rect := copy_rect.union(r)
   end

   public block()
      self.is_blocked_flag := 1
      self.resize_attrib := if self.win.can_resize() then &yes else &no
      self.win.set_resize(&no)
   end

   public unblock()
      self.is_blocked_flag := &null
      self.win.set_resize(self.resize_attrib)
   end

   #
   # Raise the window
   #
   public raise()
      self.win.raise()
   end

   #
   # Lower the window
   #
   public lower()
      self.win.lower()
   end

   #
   # Returns the number of mouse clicks that have occurred
   # consecutively, with each click in the sequence being less
   # than {DOUBLE_CLICK_DELAY} milliseconds apart.  That variable is by default 500
   # milliseconds, but it may be changing {DOUBLE_CLICK_DELAY}.
   #
   public get_click_count()
      return self.click_count
   end

   public compute_absolutes()
      self.x := -self.win.get_dx()
      self.y := -self.win.get_dy()
      self.w := self.win.get_width()
      self.h := self.win.get_height()
   end

   #
   # Succeed iff the dialog is open.
   #
   public is_open()
      return \self.is_open_flag
   end

   #
   # Change pointer
   #
   public change_pointer(s)
      self.win.set_pointer(s)
   end

   #
   # Return the window width from the "width" or "size" attrib.
   #
   public get_width_attrib()
      local n
      if n := integer(get_wattrib("width")) then
         return n
      get_wattrib("size") ? {
         return integer(tab(upto(',')))
      }
   end

   #
   # Return the window height from the "height" or "size" attrib.
   #
   public get_height_attrib()
      local n
      if n := integer(get_wattrib("height")) then
         return n
      get_wattrib("size") ? {
         tab(upto(','))
         move(1)
         return integer(tab(0))
      }
   end

   #
   # This is a variation on the conventional modal and modeless
   # methods.  The dialog is opened, input to other windows is not blocked, but
   # the call does not return until the window is closed.
   # @param d   The parent dialog, if specified, is blocked until
   # @ the window is closed.
   #
   public show_child(d)
      set_owning_dialog(\d)
      self.show()
      Dispatcher.add(self)
      if \d then {
         d.block()
         Dispatcher.message_loop(self)
         d.unblock()
      } else
         Dispatcher.message_loop(self)
   end

   #
   # Displays the dialog as a modeless dialog.  This 
   # means that window events are processed by this dialog
   # and other open dialogs concurrently.  The call to
   # {show_modeless()} opens the dialog and returns immediately.
   #
   # @param d   This optional parameter specifies the parent dialog.
   # @ When a parent dialog is closed, its child dialogs are automatically closed.
   #
   public show_modeless(d)
      set_owning_dialog(\d)
      self.show()
      Dispatcher.add(self)
      if \d then
         self.is_blocked_flag := d.is_blocked_flag
   end

   #
   # Displays the dialog as a modal dialog.  In other
   # words, window events to any other open dialogs are blocked
   # until the dialog is closed.  This method doesn't return
   # until the dialog is closed.
   # @param d   The parent dialog.  It will not normally be
   # @ needed.
   #
   public show_modal(d)
      local l
      set_owning_dialog(\d)
      self.show()
      l := Dispatcher.list_unblocked()
      every (!l).block()
      Dispatcher.add(self)
      Dispatcher.message_loop(self)
      every (!l).unblock()
   end

   #
   # Set the owning dialog to d, and insert this dialog into
   # the parent's set of child dialogs.
   # 
   private set_owning_dialog(d)
      insert(d.child_dialogs, self)
      self.owning_dialog := d
   end

   #
   # Returns the Icon window associated with the dialog, or fail if unset.
   #
   public get_win()
      return \self.win
   end

   public resize_win(w, h)
      self.win.set_size(w, h)
      self.win.enqueue(Mouse.WINDOW_RESIZE)      
   end

   public initially()
      local t
      self.parent_dialog := self
      self.effective_is_hidden_flag := self.is_hidden_flag
      self.effective_is_shaded_flag := self.is_shaded_flag
      Gui.style.polish(self)
      self.effective_wattribs := copy(self.wattribs)
      every delete(self.effective_wattribs, 
                   "pos" | "x" | "y" | "size" | "width" | "height"|
                   "dx" | "dy" | "canvas" |
                   "min_width" | "min_height" | "min_size" |
                   "max_width" | "max_height" | "max_size")
      self.compute_z_order()
      self.compute_tab_order()
      # Delete "canvas" from the attribs, since canvas=popup may be specified, and we
      # don't want the buffer window to popup.
      t := copy(self.wattribs)
      delete(t, "canvas")
      self.cbwin := self.buffer_win.clone!wattribs_to_list(t) | 
         runerr("Failed to open clone window:" || &why)
      every (!self.children).initially()
   end

   public open_buffer_win()
      # Note that the window attribs are applied in initially() above.  This may be called
      # several times (eg via reset()), so we must start with empty attributes here since we
      # may start with say "bg=blue", then delete that attrib and call reset().  We wouldn't
      # then want "bg=blue" to still be stuck in the root buffer window's context.
      self.buffer_win := Window.open("canvas=hidden") | runerr("couldn't open buffer window:" || &why)
   end

   #
   # Ensure we have size attributes, setting from the preferred width/height if
   # absent
   # 
   private ensure_size()
      if get_wattrib("size") | (get_wattrib("width") & get_wattrib("height")) then
         return

      if get_wattrib("width") then 
         # Got width, need height
         set_wattrib("height", get_preferred_height())
      else if get_wattrib("height") then
         # Got height, need width
         set_wattrib("width", get_preferred_width())
      else
         # Need both
         set_wattrib("size", get_preferred_width() || "," || get_preferred_height())
   end

   public open_visible_win()
      local t, pw
      ensure_size()
      t := wattribs_to_list(self.wattribs)
      put(t, "input_mask=mk")
      if pw := (\owning_dialog).win then
         every put(t, "parent=" | pw)
      self.win := Window.open!t | runerr("Couldn't open window:" || &why)
      # Make the buffer the same size as the visible win.
      self.buffer_win.set_size(self.win.get_width(), self.win.get_height())
   end

   public close_win()
      self.buffer_win.close()
      self.win.close()
   end

   public get_buffer_win()
      return \self.buffer_win
   end

   public enter_menu_mode(c)
      # If already in menu mode, force ourselves out of it.
      if \self.menu_mode then
         self.menu_mode.close_all()
      (/self.menu_mode := c) | syserr("internal error - already in menu mode")
      popups := []
      win.grab_pointer()
   end

   public exit_menu_mode()
      (\self.menu_mode := &null) | syserr("internal error - not  in menu mode.")
      parent_dialog.win.ungrab_pointer()
      popups := &null
   end

   public add_popup(d)
      \popups | syserr("internal error - not  in menu mode.")
      d.popup_manager := self
      put(popups, d)
   end

   public remove_popup(d)
      \popups | syserr("internal error - not  in menu mode.")
      d.popup_manager := &null
      ldel(popups, d)
   end

   public which_popup(ex, ey)
      local p
      every p := back(\popups) do
         if p.inside(ex, ey) then
            return p
   end

   #
   # Sets keyboard focus to the given component.
   #
   public set_focus(c, e)
      if \self.focus === c then
         return

      (\self.focus).lost_focus(e)
      self.focus := c
      (\self.focus).got_focus(e)
   end

   #
   # Clear the keyboard focus.
   #
   public clear_focus(e)
      (\self.focus).lost_focus(e)
      self.focus := &null
   end

   #
   # This empty method is invoked just after the dialog is displayed for the first time.
   #
   public init_dialog()
   end

   #
   # This empty method may be overridden to add components to the
   # dialog.  Alternatively, components may be added in the
   # dialog's {initially} method.
   #
   public component_setup()
   end

   #
   # This empty method may be overridden.  It is invoked just
   # before the dialog window is closed.
   #
   public end_dialog()
   end

   public show()
      self.component_setup()
      self.open_buffer_win()
      self.initially()
      self.open_visible_win()
      self.is_open_flag := 1
      self.resize()
      self.invalidate()
      self.tooltip_init()
      self.init_dialog()
   end

   public dispose()
      self.end_dialog()
      every (!child_dialogs).dispose()
      self.dispose_selections()
      self.tooltip_dispose()
      self.finally()
      Gui.style.dispose_all()
      self.close_win()
      self.is_open_flag := &null
      Dispatcher.del(self)
      if \self.owning_dialog then {
         delete(self.owning_dialog.child_dialogs, self)
         self.owning_dialog.raise()
         self.owning_dialog := &null
      }
      fire(Event.DIALOG_CLOSED)
   end

   public create_point_chain(e)
      local p, flag

      # A popup window lets its event manager create its point chain for it.
      if \popup_manager then
         return

      self.point_chain := []
      self.point_chain_source := e

      every p := back(\popups) do {
         p.point_chain := []
         p.point_chain_source := e
         if p.inside(e.x, e.y) then {
            if /flag then {
               p.build_point_chain(p.point_chain, e.x, e.y)
               flag := 1
            }
            put(p.point_chain, p)
         }
      }

      if self.is_unhidden() & self.inside(e.x, e.y) then {
         if /flag then
            self.build_point_chain(self.point_chain, e.x, e.y)
         put(self.point_chain, self)
      }
   end

   public dispose_selections()
      local e
      every e := !selections do
         e.lost_ownership()
      selections := table()
   end

   private process_selection_request(l)
      local c, data, target
      #write("process_selection-request:",to_string(l))
      target := l[5]
      if c := \selections[l[4]] then {
         #write("\towner=", image(c))
         if target == Selection.TARGETS_TARGET then {
            data := []
            every put(data, c.get_targets())
         } else {
            if c.get_targets() == target then 
               data := c.get_content(target)
         }
      }
      #write("\tdata=", image(data))
      win.send_selection_response(l[2], l[3], l[4], l[5], l[6], data)
   end

   private process_selection_clear(l)
      local c
      #write("process_selection-clear:",to_string(l))
      if c := \selections[l[2]] then {
         c.lost_ownership()
         delete(selections, l[2])
      }
   end

   private process_selection_response(l)
      local req
      #write("process_selection-response:",to_string(l))
      if req := \selection_requests[l[2]] then {
         if /l[4] | (l[3] ~== req.target_types[1]) then {
            # Null data (indicating failure), or mismatch in type.  Pop off
            # the last requested type.
            pop(req.target_types)
            if *req.target_types > 0 then
               # Try next type
               win.request_selection(l[2], req.target_types[1])
            else {
               # Notify of failure by invoking callback with null data
               delete(selection_requests, l[2])
               req.proc(l[3], &null, req.user_data)
            }
         } else {
            # Success; invoke callback procedure
            delete(selection_requests, l[2])
            req.proc(l[3], l[4], req.user_data)
         }
      }
   end

   private process_invoke_later(l)
      l[2](l[3])
   end

   public own_selection(selection, obj)
      local curr
      if curr := \selections[selection] then {
         # Check if current owner is asserting selection.
         if curr === obj then
            return
         curr.lost_ownership()
      } else
         win.own_selection(selection)
      selections[selection] := obj
   end

   public request_selection(selection, target_types, proc, user_data)
      selection_requests[selection] := SelectionRequest(target_types, proc, user_data)
      win.request_selection(selection, target_types[1])
   end

   public process_event(l)
      static consume_same_events
      local e
      initial
         consume_same_events := Mouse.DRAG_OR_MOVEMENT ++ set(Mouse.WINDOW_RESIZE)
      case l[1] of {
         Selection.REQUEST: process_selection_request(l)
         Selection.CLEAR: process_selection_clear(l)
         Selection.RESPONSE: process_selection_response(l)
         Window.INVOKE_LATER: process_invoke_later(l)
         default: {
            if member(consume_same_events, l[1]) then {
               while win.pending()[1] === l[1] do
                  l := self.win.event()
            }

            e := WinEvent!l
            create_point_chain(e)

            if /self.curr_drag then 
               check_dnd(e)

            if \self.curr_drag then
               process_dnd(e)
            else {
               every (!\popups).process_normal(e)
               process_normal(e)
            }
         }
      }
   end

   #
   # Normal event processing - not dnd
   # 
   private process_normal(e)
      static focus_up, focus_down
      local c, ec, old_n_held, t
      initial {
         focus_up := set(Key.SHIFT_TAB, Key.LEFT, Key.UP)
         focus_down := set("\t", Key.RIGHT, Key.DOWN)
      }

      ec := e.code

      old_n_held := *held
      if member(Mouse.PRESS, ec) then {
         check_click_count(e)
         if c := (!self.point_chain).find_focus(e) then
            self.set_focus(c, e)
      }
      else if ec === Mouse.WINDOW_RESIZE then
         handle_resize(e)
      else if \e.meta & /e.release & type(ec) == ("string" | "ucs") then {
         if c := self.find_accel(ec) then {
            if \self.menu_mode then
               self.menu_mode.close_all()
            c.handle_accel(e)
         }
      }

      generate_events(e)

      #
      # If a handler closed us, do no more.
      #
      if /self.is_open_flag then
         return

      #
      # Check for focus keyboard movement, but not in menu mode; this would get muddled up
      # with the menu's cursor movement.
      #
      if /e.release & /self.menu_mode then {
         if member(focus_down, ec) & (/self.focus | 
                                      self.focus.is_hidden() |
                                      self.focus.is_shaded() | 
                                      not(self.focus.keeps(e))) then 
            self.set_focus(find_next_focus(e), e)
         else if member(focus_up, ec) & (/self.focus | 
                                         self.focus.is_hidden() |
                                         self.focus.is_shaded() | 
                                         not(self.focus.keeps(e))) then 
            self.set_focus(find_previous_focus(e), e)
      }

      #
      # The mouse may have moved during the event, so update x,y and
      # re-create the point chain.
      #
      if t := self.win.query_pointer() then {
         e.x := t[1]
         e.y := t[2]
      }
      create_point_chain(e)
      process_tooltip_event(e)

      #
      # Synch the pointer if either there were no buttons down before or after
      # this event.  This means we synch at the start and end of a drag, but not
      # during a drag.
      #
      if (old_n_held | *held) = 0 then
         synch_pointer(e)
   end

   #
   # Artificially "hold" a component down.
   # @param c The component
   # @param e The mouse event
   #
   public hold(c, e)
      local ec
      ec := e.code
      self.held[ec] := copy(\self.held[ec]) | fail
      put(self.held[ec], c)
   end

   #
   # Artificially "release" a component which is held.
   # @param c  The component
   # @param ec The simulated mouse event code
   #
   public release(c, ec)
      self.held[ec] := copy(\self.held[ec]) | fail
      ldel(self.held[ec], c)
   end

   #
   # Return the number of buttons presently held down.
   #
   public get_held_count()
      return *held
   end

   public check_moving(e)
      local s1, s2
      if *held > 0 then
         return
      s1 := elementset(\moving) | set()
      s2 := elementset(point_chain)
      fire_list(s1 -- s2, Event.MOUSE_EXIT, e)
      fire_list(s2 -- s1, Event.MOUSE_ENTER, e)
      moving := copy(point_chain)
   end

   public generate_events(e)
      local ec, ke

      ec := e.code
      if integer(ec) < 0 then {
         # Non-keyboard event
         if member(Mouse.WHEEL, ec) then {
            fire_list(point_chain, ec, e)
         } else if member(Mouse.PRESS, ec) then {
            held[ec] := copy(point_chain)
            fire_list(held[ec], ec, e)
         } else if member(Mouse.DRAG, ec) then {
            fire_list(\held[ec + 6], ec, e)
         } else if ec === Mouse.MOVEMENT then {
            fire_list(point_chain, ec, e)
            check_moving(e)
         } else if member(Mouse.RELEASE, ec) then {
            fire_list(\held[ec + 3], ec, e)
            delete(held, ec + 3)
            check_moving(e)
         } else if member(Mouse.WINDOW, ec) then {
            fire(ec, e)
         }
      } else {
         # Keyboard event
         ke := if \e.release then Event.KEY_RELEASE else Event.KEY_PRESS
         if \self.menu_mode then
            fire_list([self.menu_mode], ke, e)
         else
            fire_list([\self.focus], ke, e)
         self.fire(ke, e)
      }
      fire(Event.ICON, e)
   end

   # 
   private fire_list(l, t, p)
      local c
      every c := !l do {
         if c.is_unshaded() & c.is_unhidden() &
            \c.cbwin & \self.is_open_flag then
            c.fire(t, p)
      }
   end

   #
   # Initialize the tooltip state and ticker.
   # 
   private tooltip_init()
      self.tooltip_state := 0
      self.tooltip_ticker.start()
   end

   #
   # Cleanup the tooltip settings.
   # 
   private tooltip_dispose()
      self.tooltip_ticker.stop()
      if self.tooltip_state = 2 then
         hide_tooltip()
   end

   #
   # Show the tooltip at the given event position.  If e is null, then we update
   # the current tooltip based on its current location.
   # 
   private show_tooltip(obj, tip, e)
      local d, dim, right, bottom, left, top, use_popup_win, ox, oy
      if \self.tooltip_component then {
         ox := tooltip_component.x
         oy := tooltip_component.y
         hide_tooltip()
      }
      self.tooltip_component := obj.create_tooltip_component(tip)
      if /e then  
         self.tooltip_component.set_pos(ox + win.get_dx(),
                                        oy + win.get_dy())
      else
         self.tooltip_component.set_pos(e.x + win.get_dx() + TOOLTIP_X_OFFSET, 
                                        e.y + win.get_dy() + TOOLTIP_Y_OFFSET)
      self.tooltip_component.set_z(get_top_z())
      self.add(self.tooltip_component)
      self.tooltip_component.initially()
      self.tooltip_component.resize()

      # Edges of window in adjusted coordinates
      left := -win.get_dx()
      top := -win.get_dy()
      right := self.w - win.get_dx()
      bottom := self.h - win.get_dy()

      # Note that if we have popups, we use a popup for a tooltip, so that it won't appear
      # below the other popup window.
      if Gui.style.allow_popup(self.tooltip_component) &
         ((*\popups > 0) | \popup_manager |
          (self.tooltip_component.x + self.tooltip_component.w > right) |
          (self.tooltip_component.y + self.tooltip_component.h > bottom)) then 
      {
         dim := win.get_display_size()
         # Recalculate edges, but now of the screen rather than the window.
         left := -win.get_x() - win.get_dx()
         right := dim[1] - win.get_x() - win.get_dx()
         top := -win.get_y() - win.get_dy()
         bottom := dim[2] - win.get_y() - win.get_dy()
         use_popup_win := 1
      }

      #
      # Ensure it's in area; adjust and resize again if not.
      #
      if self.tooltip_component.x + self.tooltip_component.w > right then {
         if /e then
            self.tooltip_component.x_spec := win.get_dx() + max(left, right - self.tooltip_component.w)
         else
            self.tooltip_component.x_spec := win.get_dx() + max(left, e.x - TOOLTIP_X_OFFSET - self.tooltip_component.w)
         self.tooltip_component.resize()
      }
      if self.tooltip_component.y + self.tooltip_component.h > bottom then {
         if /e then
            self.tooltip_component.y_spec := win.get_dy() + max(top, bottom - self.tooltip_component.h)
         else
            self.tooltip_component.y_spec := win.get_dy() + max(top, e.y - TOOLTIP_Y_OFFSET - self.tooltip_component.h)
         self.tooltip_component.resize()
      }

      if \use_popup_win then {
         self.tooltip_component.finally()
         self.remove(self.tooltip_component)
         d := Dialog("canvas=popup", 
                     "dx=", -self.tooltip_component.x, "dy=",-self.tooltip_component.y,
                     "w=", self.tooltip_component.w, "h=",self.tooltip_component.h,
                     "w:x=", win.get_x() + win.get_dx() + self.tooltip_component.x,
                     "w:y=", win.get_y() + win.get_dy() + self.tooltip_component.y)
         self.tooltip_component.set_pos(0, 0)
         d.add(self.tooltip_component)
         d.show_modeless()
      } else
         self.tooltip_component.invalidate()
   end

   #
   # Hide the tooltip label.
   # 
   private hide_tooltip()
      if self.tooltip_component.parent_dialog === self then {
         self.tooltip_component.invalidate()
         self.tooltip_component.finally()
         self.remove(self.tooltip_component)
      } else {
         self.tooltip_component.parent_dialog.dispose()
      }
      self.tooltip_component := &null
   end

   #
   # Tooltip processing during an event.
   # 
   private process_tooltip_event(e)
      if e.code === Mouse.MOVEMENT then
         tooltip_states(e)
      else {
         if tooltip_state = 2 then
            hide_tooltip()
         tooltip_state := 0
      }
   end

   #
   # Tooltip processing on a tick.
   # 
   private process_tooltip_tick()
      local e, t
      #
      # Don't process ticks whilst blocked, or button held.
      #
      if \self.is_blocked_flag | (get_held_count() > 0) then
         return

      t := self.win.query_pointer() | fail

      #
      # Create an artificial event and process it.
      #
      e := WinEvent(0, t[1], t[2])
      create_point_chain(e)
      tooltip_states(e)
   end

   #
   # Tooltip state processing.
   # 
   private tooltip_states(e)
      local obj, t, c, tip

      #
      # If over tooltip, behave as though over current object.
      #
      if (\self.tooltip_component).in_region(e) then {
         if tip := self.tooltip_last_obj.get_tooltip(e) then
            obj := self.tooltip_last_obj
      } else {
         every c := !self.point_chain do {
            if tip := c.get_tooltip(e) then {
               obj := c
               break
            }
         }
      }

      t := Prog.get_runtime_millis()

      #if \obj then 
      #    write("last=",image(obj), "  obj=",image(obj), " tip=",image(tip), "  state=",tooltip_state,
      #      "\n\tt=",t, "   start_time=",image(self.tooltip_start_time) )
      #else
      #    writes(".")

      case self.tooltip_state of {
         0 : {
            if (\obj ~=== self.tooltip_last_obj) |
               (\tip ~=== self.tooltip_last_tip) then {
               self.tooltip_start_time := t + obj.get_tooltip_start_delay()
               self.tooltip_state := 1
            }
         }
         1 : {
            if obj ~=== self.tooltip_last_obj then {
               if /obj then
                  self.tooltip_state := 0
               else
                  self.tooltip_start_time := t + obj.get_tooltip_start_delay()
            } else if t >= self.tooltip_start_time then {
               show_tooltip(obj, tip, e)
               self.tooltip_state := 2
               self.tooltip_end_time := (t + \obj.get_tooltip_end_delay()) | &null
            }
         }
         2 : {
            if obj ~=== self.tooltip_last_obj then {
               if /obj then {
                  hide_tooltip()
                  self.tooltip_state := 3
                  self.tooltip_continue_time := t + TOOLTIP_CONTINUE_DELAY
               } else {
                  show_tooltip(obj, tip, e)
                  self.tooltip_end_time := (t + \obj.get_tooltip_end_delay()) | &null
               }
            } else if tip ~=== self.tooltip_last_tip then {
               if /obj.tooltip_follows_mouse_flag then
                  show_tooltip(obj, tip)
               else
                  show_tooltip(obj, tip, e)
               self.tooltip_end_time := (t + \obj.get_tooltip_end_delay()) | &null
            } else if t >= \self.tooltip_end_time then {
               hide_tooltip()
               self.tooltip_state := 0
               self.tooltip_continue_time := t + TOOLTIP_CONTINUE_DELAY
            }
         }
         3 : {
            if \obj ~=== self.tooltip_last_obj then {
               show_tooltip(obj, tip, e)
               self.tooltip_state := 2
               self.tooltip_end_time := (t + \obj.get_tooltip_end_delay()) | &null
            } else if t >= self.tooltip_continue_time then
               self.tooltip_state := 0
         }
      }

      self.tooltip_last_obj := obj
      self.tooltip_last_tip := tip
   end

   #
   # Synch the mouse cursor pointer with the component it's over.
   #
   public synch_pointer(e)
      local c, ptr
      ptr := DEFAULT_POINTER
      every c := !\self.point_chain do {
         if c.is_unshaded() & (ptr := c.get_pointer(e)) then
            break
      }
      change_pointer(ptr)
   end

   #
   # Exit dnd mode.
   #
   private exit_dnd(e)
      self.curr_drag_holder := self.curr_drop := self.curr_drag := &null
      self.invoke_drag_reset(e)
      if *held = 0 then {
         synch_pointer(e)
         check_moving(e)
      } else
         change_pointer(DEFAULT_POINTER)
   end

   #
   # Drag & drop mode processing
   # 
   private process_dnd(e)
      local o, ec

      ec := e.code
      #
      # Wheel events are treated normally and then passed on as though
      # they were a drag event, in order to keep the drag holder
      # display in synch.
      #
      if member(Mouse.WHEEL, ec) then
         fire_list(point_chain, ec, e)

      if (ec === curr_drag.event.code) | member(Mouse.WHEEL, ec) then {
         # Try the drag holder's drag_event method first...
         if not((\self.curr_drag_holder).drag_event(self.curr_drag, e)) then {
            # No luck with the drag holder, so try to search for a new drag holder.
            self.curr_drag_holder := self.invoke_drag_event(self.curr_drag, e) | &null
         }

         # If we have a drag holder, see if it can drop here.
         if o := (\self.curr_drag_holder).can_drop(self.curr_drag, e) then {
            change_pointer("hand2")
            self.curr_drop := Drag(self.curr_drag_holder, o, e)
         } else {
            change_pointer("exchange")
            self.curr_drop := &null
         }
      } else if ec === curr_drag.event.code + 3 then {
         # If we have a prospective drop from can_drop, try to perform it.
         if (\self.curr_drop).get_source().perform_drop(self.curr_drag, self.curr_drop, e) then
            self.curr_drag.get_source().end_drag(self.curr_drag, self.curr_drop, e)
         delete(self.held, ec + 3)   # Now held should be empty
         exit_dnd(e)
      } else if /e.release & (ec === "\e") then {
         self.held[curr_drag.event.code + 6] := []    # Now held should hold this one empty list
         exit_dnd(e)
      } else if member(Mouse.PRESS, ec) then {        # keep things consistent if other mouse
         held[ec] := []                               # buttons are pressed during the drag
         change_pointer("exchange")
         self.curr_drop := &null
      } else if member(Mouse.RELEASE, ec) then
         delete(held, ec + 3)
   end

   #
   # Check whether we should start a dnd (by setting curr_drag)
   # 
   private check_dnd(e)
      #
      # There must be only one button held, and the event must be
      # a drag.
      #
      if (*self.held = 1) & member(Mouse.DRAG, e.code) then {
         # Note the position of the start of a drag
         /self.drag_gesture_x := e.x
         /self.drag_gesture_y := e.y
         if /self.tried_drag &
            (abs(e.x - self.drag_gesture_x) > 3 |
             abs(e.y - self.drag_gesture_y) > 3 ) then {
                # Try to begin a drag.
                self.curr_drag := self.invoke_can_drag(e) 
                self.tried_drag := 1
                if \self.curr_drag then
                   change_pointer("exchange")
             }
      } else
         self.tried_drag := self.drag_gesture_x := self.drag_gesture_y := &null
   end

   public invoke_can_drag(ev)
      local c, o
      every c := !\self.held[ev.code + 6] do
         if c.is_unshaded() & \c.allow_drag_flag & o := c.can_drag(ev) then
            return Drag(c, o, ev)
   end

   public invoke_drag_event(d, ev)
      local c
      every c := !self.point_chain do
         if c.is_unshaded() & \c.allow_drop_flag & c.drag_event(d, ev) then
            return c
   end

   #
   # Process a resize 
   # 
   private handle_resize(e)
      #
      # Resize buffer canvas
      #
      self.buffer_win.set_size(self.win.get_width(), self.win.get_height())
      self.resize()
      self.invalidate()
   end

   #
   # Maybe increment the click count
   # 
   private check_click_count(e)
      local t

      t := Prog.get_runtime_millis()
      if e.code = (\prev_event).code & prev_event.x = e.x & prev_event.y = e.y & 
                                 (t - prev_time < DOUBLE_CLICK_DELAY) then
         click_count +:= 1
      else
         click_count := 1

      prev_event := e
      prev_time := t
   end

   public get_focus_list(e)
      local l, c
      l := []
      every c := Seq{traverse_tab_order()} do {
         if c === self.focus | (c.accepts_focus(e) & c.is_unhidden() & c.is_unshaded()) then {
            put(l, c)
         }
      }
      return l
   end

   public find_next_focus(e)
      local l, i
      l := get_focus_list(e)
      every i := 1 to *l - 1 do {
         if l[i] === self.focus then
            return l[i + 1]
      }
      return l[1]
   end

   public find_previous_focus(e)
      local l, i
      l := get_focus_list(e)
      every i := 2 to *l do {
         if l[i] === self.focus then
            return l[i - 1]
      }
      return l[-1]
   end

   #
   # This method adds an otherwise meaningless event to the window's event
   # queue.  When that event comes to be processed, the given method in the
   # given object is invoked, with the optional parameter.
   #
   # This is useful if you need to take some action from within an event
   # handler method, but that action has to take place after the current
   # event has completed processing.
   #
   # @param proc    The procedure (or method pointer) to call
   # @param param   An optional parameter which will be passed to the
   #                method.
   #
   public invoke_later(proc, param)
      self.win.pending(Window.INVOKE_LATER, proc, param)
   end

   private static init()
      DOUBLE_CLICK_DELAY := 500
      TOOLTIP_START_DELAY := 1000
      TOOLTIP_END_DELAY := 4000
      TOOLTIP_CONTINUE_DELAY := 1500
      TOOLTIP_X_OFFSET := 5
      TOOLTIP_Y_OFFSET := 15
      DEFAULT_POINTER := "left ptr"
      ROOT_WATTRIBS := table()
   end

   public new(a[])
      cast(self,Component).new()
      self.set_all_wattribs(ROOT_WATTRIBS)
      self.child_dialogs := set()
      self.held := table()
      self.selections := table()
      self.selection_requests := table()
      self.tooltip_ticker := Ticker("interval=200")
      self.tooltip_ticker.connect(self.process_tooltip_tick, Event.TICK)
      set_fields(a)
      return
   end
end

class WinEvent(Point)
   public
      code,
      shift,
      meta,
      ctrl,
      release,
      interval

   public new(code, x, y, ctrl, meta, shift, release, interval)
      self.code := code
      self.x := x
      self.y := y
      self.shift := shift
      self.meta := meta
      self.ctrl := ctrl
      self.release := release
      self.interval := interval
      return
   end
end

class SelectionRequest()
   public const
      proc,
      user_data,
      target_types

   public new(target_types, proc, user_data)
      self.proc := proc
      self.user_data := user_data
      self.target_types := target_types
      return
   end
end

class SelectionOwner()
   public defer get_content(target)
   public defer lost_ownership()
   public defer get_targets()
end

class TextSelectionOwner(SelectionOwner)
   protected defer get_text()

   public get_targets()
      suspend Selection.STRING_TARGET | Selection.UTF8_STRING_TARGET
   end

   public get_content(target)
      case target of {
         Selection.STRING_TARGET: return string(text_convert(get_text(), "string"))
         Selection.UTF8_STRING_TARGET: return string(text_convert(get_text(), "ucs"))
      }
   end
end

#
# This is a helpful component which has zero size, but reacts to accelerator keys
# by firing an action event.
#
# @example
# @  # dispose on alt-x
# @  add(a := Accelerator("accel=x"))
# @  a.connect(dispose, Event.ACTION)
#
class Accelerator(Component)
   public handle_accel(e)
      fire(Event.ACTION, e)
   end

   public new(a[])
      cast(self,Component).new()
      self.x_spec := self.y_spec := self.w_spec := self.h_spec := 0
      set_fields(a)
      return
   end
end

#
# This component provides window control buttons (close and iconify) for
# systems that don't provide such controls themselves.
#
class WindowControl(Component)
   private close_window()
      parent_dialog.win.enqueue(Mouse.WINDOW_CLOSE_BUTTON)
   end

   private iconify_window()
      parent_dialog.win.set_canvas("iconic")
   end

   public new(a[])
      cast(self,Component).new()
      set_layout(GridLayout("flush", "dii=0"))
      attrib("pos=100%,0", "align=r,t")
      add(IconButton("paint=",ImagePaint("cache=gui.WINDOW_ICONIFY_BUTTON"),
                     "border=",EmptyBorder("flush"),
                     "accepts_focus=no",
                     "tooltip=Iconify",
                     "e:action=", iconify_window))
      add(IconButton("paint=",ImagePaint("cache=gui.WINDOW_CLOSE_BUTTON"),
                     "border=",EmptyBorder("flush"),
                     "accepts_focus=no",
                     "tooltip=Close",
                     "e:action=", close_window))
      set_fields(a)
      return
   end
end

