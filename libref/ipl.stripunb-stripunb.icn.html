<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta charset="UTF-8"><title>stripunb.icn</title></head><body><pre>
<a name="1"/>############################################################################
<a name="2"/>#
<a name="3"/>#	File:     stripunb.icn
<a name="4"/>#
<a name="5"/>#	Subject:  Procedures to strip unbalanced material
<a name="6"/>#
<a name="7"/>#	Author:   Richard L. Goerwitz
<a name="8"/>#
<a name="9"/>#	Date:	  May 2, 2001
<a name="10"/>#
<a name="11"/>############################################################################
<a name="12"/>#
<a name="13"/>#   This file is in the public domain.
<a name="14"/>#
<a name="15"/>############################################################################
<a name="16"/>#
<a name="17"/>#	Version:  1.7
<a name="18"/>#
<a name="19"/>############################################################################
<a name="20"/>#  
<a name="21"/>#  This routine strips material from a line which is unbalanced with
<a name="22"/>#  respect to the characters defined in arguments 1 and 2 (unbalanced
<a name="23"/>#  being defined as bal() defines it, except that characters preceded
<a name="24"/>#  by a backslash are counted as regular characters, and are not taken
<a name="25"/>#  into account by the balancing algorithm).
<a name="26"/>#
<a name="27"/>#  One little bit of weirdness I added in is a table argument. Put
<a name="28"/>#  simply, if you call stripunb() as follows,
<a name="29"/>#
<a name="30"/>#      stripunb('&lt;','&gt;',s,&amp;null,&amp;null,t)
<a name="31"/>#
<a name="32"/>#  and if t is a table having the form,
<a name="33"/>#
<a name="34"/>#      key:  "bold"        value: outstr("\e[2m", "\e1m")
<a name="35"/>#      key:  "underline"   value: outstr("\e[4m", "\e1m")
<a name="36"/>#      etc.
<a name="37"/>#
<a name="38"/>#  then every instance of "&lt;bold&gt;" in string s will be mapped to
<a name="39"/>#  "\e2m," and every instance of "&lt;/bold&gt;" will be mapped to "\e[1m."
<a name="40"/>#  Values in table t must be records of type output(on, off).  When
<a name="41"/>#  "&lt;/&gt;" is encountered, stripunb will output the .off value for the
<a name="42"/>#  preceding .on string encountered.
<a name="43"/>#
<a name="44"/>############################################################################
<a name="45"/>#
<a name="46"/>#  Links: scan
<a name="47"/>#
<a name="48"/>############################################################################
<a name="49"/>
<a name="50"/>package ipl.stripunb
<a name="51"/>
<a name="52"/>import
<a name="53"/>   io(read),
<a name="54"/>   ipl.scan(begin_analysis,slashbal)
<a name="55"/>
<a name="56"/>global last_k
<a name="57"/>record outstr(on, off)
<a name="58"/>
<a name="59"/>
<a name="60"/>procedure stripunb(c1,c2,s,i,j,t)
<a name="61"/>
<a name="62"/>    # NB:  Stripunb() returns a string - not an integer (like find,
<a name="63"/>    # upto).
<a name="64"/>
<a name="65"/>    local lookinfor, bothcs, s2, k,  c, compl, a
<a name="66"/>    #global last_k
<a name="67"/>    initial last_k := list()
<a name="68"/>
<a name="69"/>    /c1 := '&lt;'
<a name="70"/>    /c2 := '&gt;'
<a name="71"/>    bothcs := c1 ++ c2
<a name="72"/>    lookinfor := c1 ++ '\\'
<a name="73"/>    c := &amp;cset -- c1 -- c2
<a name="74"/>
<a name="75"/>    a := begin_analysis(s, i, j) | fail
<a name="76"/>    s := a.s; i := a.i; j := a.j
<a name="77"/>
<a name="78"/>    s2 := ""
<a name="79"/>    s ? {
<a name="80"/>	while s2 ||:= tab(upto(lookinfor)) do {
<a name="81"/>	    if ="\\" then {
<a name="82"/>		unless any(bothcs) then
<a name="83"/>		    s2 ||:= "\\"
<a name="84"/>		&amp;pos+1 &gt; j &amp; (return s2)
<a name="85"/>		s2 ||:= move(1)
<a name="86"/>		next
<a name="87"/>	    }
<a name="88"/>	    else {
<a name="89"/>		&amp;pos &gt; j &amp; (return s2)
<a name="90"/>		any(c1) |
<a name="91"/>		    runerr("stripunb:  Unbalanced string, pos(" || &amp;pos || ").\n",s)
<a name="92"/>		if not (k := tab(&amp;pos &lt;= slashbal(c,c1,c2,&amp;subject)))
<a name="93"/>		then {
<a name="94"/>		    # If the last char on the line is the right-delim...
<a name="95"/>		    if (.&amp;subject[&amp;pos:0]||" ") ? slashbal(c,c1,c2)
<a name="96"/>		    # ...then, naturally, the rest of the line is the tag.
<a name="97"/>		    then k := tab(0)
<a name="98"/>		    else {
<a name="99"/>			# BUT, if it's not the right-delim, then we have a
<a name="100"/>			# tag split by a line break.  Blasted things.
<a name="101"/>			return stripunb(c1,c2,&amp;subject||read(),
<a name="102"/>					*.&amp;subject,,t) |
<a name="103"/>			# Can't find the right delimiter.  Parsing error.
<a name="104"/>			runerr("stripunb:  Incomplete tag\n",s[1:80] | s)
<a name="105"/>		    }
<a name="106"/>		}
<a name="107"/>		# T is the maptable.
<a name="108"/>		if \t then {
<a name="109"/>		    k ?:= 2(tab(any(c1)), tab(upto(c2)), move(1), pos(0))
<a name="110"/>		    if k ?:= (="/", tab(0)) then {
<a name="111"/>			compl:= pop(last_k) | runerr("Incomplete tag, ",&amp;subject) 
<a name="112"/>			if k == ""
<a name="113"/>			then k := compl
<a name="114"/>			else k == compl | runerr("Incorrectly paired tag,/tag.")
<a name="115"/>			s2 ||:= \(\t[k]).off
<a name="116"/>		    }
<a name="117"/>		    else {
<a name="118"/>			s2 ||:= \(\t[k]).on
<a name="119"/>			push(last_k, k)
<a name="120"/>		    }
<a name="121"/>		}
<a name="122"/>	    }
<a name="123"/>	}
<a name="124"/>	s2 ||:= tab(0)
<a name="125"/>    }
<a name="126"/>
<a name="127"/>    return s2
<a name="128"/>
<a name="129"/>end
</pre></body></html>
