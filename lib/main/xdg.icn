package xdg

import io, posix, util, ipl.strings, ipl.wildcard, lang, gui, cairo, ipl.pdco

# An object for parsing and holding the parts of a locale string, like
# "en_GB.utf8".
#
class Locale()
   public const
      lang, country, encoding, modifier

   public new(s)
      s ? {
         lang := tab(upto('_.@') | 0)
         if ="_" then
            country := tab(upto('.@') | 0)
         if ="." then
            encoding := tab(upto('@') | 0)
         if ="@" then
            modifier := tab(0)
      }
      return
   end
end

# An object for holding info about a theme and the icons in its
# various directories.
#
class ThemeIndex()
   public const
      directories,   # A list of ThemeDirectory objects
      parents        # A list of parent theme names (strings)

   public new(directories, parents)
      self.directories := directories
      self.parents := parents
      return
   end   
end

# Encapsulates a directory in a theme.  This is not an actual directory,
# but gives the meta information about the several actual directories
# that it does relate to.  These actual directories are located under
# the various elements of the base directories path, and each one has
# an element in the cached_dirs member.
#
# For example an index.theme file may contain the directory group:-
#   [16x16/intl]
#   Size=16
#   Context=International
#   Type=Threshold
#
# This is represented by a ThemeDirectory.  Then, each element from
# gen_base_dirs() is appended to the theme name to give an actual
# directory :-
#
#   "/home/rparlett/.local/share/16x16/intl"
#   "/usr/local/share/16x16/intl"
#   "/usr/share/16x16/intl"
#  
# and the cached contents of those directories are stored in CachedDir
# instances in the cached_dirs list.
#
class ThemeDirectory()
   public const
      type,         # Type, a string
      size,         # Sizes etc, all integers
      minsize,      #         
      maxsize,
      threshold,
      cached_dirs   # A list of CachedDir objects

   public matches_size(desired_size, scalable_flag)
      case type of {
         "Fixed": return desired_size = size
         "Threshold": {
            return size - threshold <= desired_size <= size + threshold
         }
         "Scalable": {
            if \scalable_flag then
               return minsize <= desired_size <= maxsize
         }
      }
   end

   public directory_size_distance(desired_size, scalable_flag)
      case type of {
         "Fixed": return abs(desired_size - size)
         "Threshold": {
            if desired_size < size - threshold then 
               return minsize - desired_size
            if desired_size > size + threshold then 
               return desired_size - maxsize
            return 0
         }
         "Scalable": {
            if \scalable_flag then {
               if desired_size < minsize then
                  return minsize - desired_size
               if desired_size > maxsize then
                  return desired_size - maxsize
               return 0
            }
         }
      }
   end

   public new(type, size, minsize, maxsize, threshold, cached_dirs)
      self.type := type
      self.size := size
      self.minsize := minsize
      self.maxsize := maxsize
      self.threshold := threshold
      self.cached_dirs := cached_dirs
      return
   end
end

#
# Encapsulates cached info about a directory.
#
class CachedDir()
   public const
      file_path,    # A FilePath, giving the directory
      contents      # A set of strings, being the entries in the directory.

   # If f (no path) is in the directory, return its full path.
   #
   public access(f)
      if member(contents, f) then
         return file_path.child(f).str()
   end

   public new(file_path, contents)
      self.file_path := file_path
      self.contents := contents
      return
   end
end

#
# This class contains many static methods for looking up XDG data.
#
class Xdg()
   private static const
      LC_MESSAGES,        # A Locale object giving the LC_MESSAGES locale info
      INI_LC_KEYS,        # A list of strings used to choose locale-based keys in
                          # ini files
      ICON_THEMES,        # A map of theme names (string) to ThemeIndex objects.
      GLOBS,              # A Globs instance for file pattern matching.
      ICONS,              # A map of mime-type (string) to list of icon names (strings)
      GENERIC_ICONS,      #   - ditto -
      MIME_SUBCLASSES,    # A map of mime-type (string) to lists of mime-types (strings)
      MIME_ALIASES,       #   - ditto -
      MIME_ALTERNATIVES,  # A cache of alternative_mime_types() results,
                          #   mapping mime-type (string) to lists of mime-types (strings)
      FIND_ICON_CACHE,    # A cache of find_icon() results, mapping string key to icon
                          #   name (string)
      ICON_FALLBACK_CACHED_DIRS  # A list of CachedDir objects

   private static readable
      icon_theme,
      scalable_flag

   private static init()
      LC_MESSAGES := Locale(getenv_ne("LC_MESSAGES" | "LC_ALL") | "C")
      INI_LC_KEYS := []
      every put(INI_LC_KEYS, 
                LC_MESSAGES.lang || "_" || \LC_MESSAGES.country || "@" || \LC_MESSAGES.modifier |
                LC_MESSAGES.lang || "_" || \LC_MESSAGES.country |
                LC_MESSAGES.lang || "@" || \LC_MESSAGES.modifier |
                LC_MESSAGES.lang |
                &null)
      ICON_THEMES := table()
      MIME_ALTERNATIVES := table()
      GLOBS := read_globs()
      ICONS := read_icons()
      GENERIC_ICONS := read_generic_icons()
      MIME_ALIASES := read_mime_aliases()
      MIME_SUBCLASSES := read_mime_subclasses()
      FIND_ICON_CACHE := table()
      icon_theme := get_current_icon_theme()
      ICON_FALLBACK_CACHED_DIRS := setup_icon_fallback_cached_dirs()
      scalable_flag := &yes
   end

   #
   # Set the icon theme; fails if the theme is invalid.
   #
   public static set_icon_theme(s)
      s := string(s) | runerr(103, s)
      get_theme_index(s) | fail
      icon_theme := s
      clear(FIND_ICON_CACHE)
      return Xdg
   end

   private static getenv_ne(k)
      return "" ~== System.getenv(k)
   end

   #
   # Ensure XDG_DATA_HOME exists, or try and create it.
   #
   public static ensure_data_home()
      local f, c, s
      if s := getenv_ne("XDG_DATA_HOME") then
         Files.is_directory(s) | return error("File specified by XDG_DATA_HOME is not a directory")
      else {
         f := FilePath(Files.get_home())
         every c := ".local" | "share" do {
            f := f.child(c)
            s := f.str()
            Files.is_directory(s) | Files.mkdir(s) | return error("Couldn't create data directory " || s || ": " || &why)
         }
      }
      return s
   end

   #
   # Ensure XDG_CONFIG_HOME exists, or try and create it.
   #
   public static ensure_config_home()
      local s
      if s := getenv_ne("XDG_CONFIG_HOME") then
         Files.is_directory(s) | return error("File specified by XDG_CONFIG_HOME is not a directory")
      else {
         s := FilePath(Files.get_home()).child(".config").str()
         Files.is_directory(s) | Files.mkdir(s) | return error("Couldn't create config directory " || s || ": " || &why)
      }
      return s
   end

   #
   # Return the XDG_DATA_HOME directory
   #
   public static get_data_home()
      return getenv_ne("XDG_DATA_HOME") | FilePath(Files.get_home()).walk(".local", "share").str()
   end

   #
   # Return the XDG_CONFIG_HOME directory
   #
   public static get_config_home()
      return getenv_ne("XDG_CONFIG_HOME") | FilePath(Files.get_home()).child(".config").str()
   end

   #
   # Return the XDG_DATA_DIRS path
   #
   public static get_data_dirs()
      return getenv_ne("XDG_DATA_DIRS") | "/usr/local/share:/usr/share"
   end

   #
   # Return the XDG_CONFIG_DIRS path
   #
   public static get_config_dirs()
      return getenv_ne("XDG_CONFIG_DIRS") | "/etc/xdg"
   end

   #
   # Generate the base directories, being `get_data_home()` followed
   # by the elements of `get_data_dirs()`
   #
   public static gen_base_dirs()
      suspend get_data_home() | Files.split_paths(get_data_dirs())
   end

   private static parse_glob_file(g, s)
      local weight, type, pattern, l
      every l := separate_lines(s) do l ? {
         if weight := integer(tab(upto(':'))) & 
            move(1) &
            type := string(tab(upto(':'))) &
            move(1) &
            pattern := tab(0) then 
         {
            g.add(pattern, weight, type)
         }
      }
   end

   #
   # Given a filename, return the corresponding mime type.
   #
   public static get_mime_type_for_file(f)
      return GLOBS.lookup(f).type
   end

   #
   # Generate the generic icons defined for the given mime type.
   #
   public static gen_generic_icons(mt)
      suspend .!member(GENERIC_ICONS, mt)
   end

   #
   # Generate the icons defined for the given mime type.
   #
   public static gen_icons(mt)
      suspend .!member(ICONS, mt)
   end

   #
   # Generate all the icons defined for the given mime type, namely
   # the default icon formed from substituting / for -; then the icons
   # and then the generic icons.
   #
   public static gen_all_icons(mt)
      suspend map(mt, "/", "-") | .!member(ICONS | GENERIC_ICONS, mt)
   end

   #
   # Generate the alternative mime types for the given mime type.
   # This recursively traverses the subclasses and aliases and
   # generates all possible alternatives.
   #
   public static alternative_mime_types(mt)
      local l
      if not(l := member(MIME_ALTERNATIVES, mt)) then {
         l := []
         alternative_mime_types1(mt, l)
         insert(MIME_ALTERNATIVES, mt, l)
      }
      suspend !l
   end

   private static alternative_mime_types1(mt, l)
      local sub
      if keyof(l, mt) then
         fail
      put(l, mt)
      every alternative_mime_types1(!member(MIME_ALIASES, mt), l)
      if sub := member(MIME_SUBCLASSES, mt) then
         every alternative_mime_types1(!sub, l)
      else if match("text/", mt) then
         alternative_mime_types1("text/plain", l)
      else if not match("inode/", mt) then
         alternative_mime_types1("application/octet-stream", l)
   end

   private static cache_icon(f, size)
      return if endswith(f, ".svg" | ".svgz") then
         ImageCache.get_scaled_svg_key(f, size, size)
      else
         ImageCache.get_key_with_resize(f, size, size)
   end

   #
   # This calls `find_icon`, caches the result in `ImageCache`, and
   # returns the cache key.
   #
   public static find_icon_and_cache(icon, size)
      return cache_icon(find_icon(icon, size), size)
   end

   #
   # This calls `suggest_icon_for_file`, caches the result in
   # `ImageCache`, and returns the cache key.
   #
   public static suggest_icon_for_file_and_cache(file, size)
      return cache_icon(suggest_icon_for_file(file, size), size)
   end

   private static read_generic_icons()
      local d, t, s, k, v, l
      t := table()
      every d := gen_base_dirs() do {
         if s := Files.file_to_string(FilePath(d).walk("mime", "generic-icons").str()) then {
            every l := separate_lines(s) do l ? {
               if k := tab(upto(':')) &
                  move(1) &
                  v := tab(0) then
               {
                  put(member(t, k), v) | insert(t, k, [v])
               }
            }
         }
      }
      return t
   end

   private static read_icons()
      local d, t, s, k, v, l
      t := table()
      every d := gen_base_dirs() do {
         if s := Files.file_to_string(FilePath(d).walk("mime", "icons").str()) then {
            every l := separate_lines(s) do l ? {
               if k := tab(upto(':')) &
                  move(1) &
                  v := tab(0) then
               {
                  put(member(t, k), v) | insert(t, k, [v])
               }
            }
         }
      }
      return t
   end

   private static read_mime_aliases()
      local d, t, s, k, v, l
      t := table()
      every d := gen_base_dirs() do {
         if s := Files.file_to_string(FilePath(d).walk("mime", "aliases").str()) then {
            every l := separate_lines(s) do l ? {
               if k := tab(upto(' ')) &
                  move(1) &
                  v := tab(0) then
               {
                  put(member(t, k), v) | insert(t, k, [v])
               }
            }
         }
      }
      return t
   end

   private static read_mime_subclasses()
      local d, t, s, k, v, l
      t := table()
      every d := gen_base_dirs() do {
         if s := Files.file_to_string(FilePath(d).walk("mime", "subclasses").str()) then {
            every l := separate_lines(s) do l ? {
               if k := tab(upto(' ')) &
                  move(1) &
                  v := tab(0) then
               {
                  put(member(t, k), v) | insert(t, k, [v])
               }
            }
         }
      }
      return t
   end

   private static read_globs()
      local d, g, s
      g := Globs()
      every d := gen_base_dirs() do {
         if s := ucs(Files.file_to_string(FilePath(d).walk("mime", "globs2").str())) then
            parse_glob_file(g, s)
      }
      return g
   end

   private static unescape(s)
      local t, ch
      t := u""
      s ? repeat {
         t ||:= tab(upto('\\') | 0)
         ch := (move(1), move(1)) | break
         t ||:= case ch of {
            u"s": u" "
            u"t": u"\t"
            u"n": u"\n"
            u"r": u"\r"
            default: ch
         }
      }
      return t
   end

   private static parse_key_val(group)
      local key, val, enc, t
      key := tab(many(&letters ++ &digits ++ '-')) | fail
      if ="[" then {
         enc := string(tab(upto(']'))) | fail
         move(1)
      }
      tab(many(' '))
      ="=" | fail
      tab(many(' '))
      val := unescape(tab(0))
      (t := member(group, key)) | insert(group, key, t := table())
      insert(t, enc, val)
   end

   private static resolve_lc(group)
      local key, sel, t
      every key := default.key(group) do {
         t := member(group, key)
         sel := member(t, !INI_LC_KEYS)
         insert(group, key, sel)
      }
   end

   private static parse_ini_file(s)
      local group, groups, gn, l
      groups := table()
      every l := separate_lines(s) do l ? {
         if ="[" & gn := tab(upto(']')) then {
            group := table()
            insert(groups, gn, group)
         } else
            parse_key_val(\group)
      }
      every resolve_lc(!groups)
      return groups
   end

   private static load_ini_file(f)
      return parse_ini_file(ucs(Files.file_to_string(f)))
   end

   private static dir_set1(f)
      local s, res
      res := set()
      repeat {
         s := f.read_line() | fail
         if /s then
            return res
         insert(res, s)
      }
   end

   private static dir_set(dir)
      local f
      return use {
         f := DirStream(dir),
         dir_set1(f)
      }
   end

   private static gen_theme_directories(tm)
      suspend separate(member(member(tm, u"Icon Theme"), u"Directories"))
   end

   private static gen_theme_parents(tm)
      suspend string(separate(member(member(tm, u"Icon Theme"), u"Inherits")))
   end

   # Build a ThemeIndex object given the name and the ini table.
   private static build_theme_index(theme, tm)
      local d, subdir, f, dirs, ds, m, cd,
         type, size, minsize, maxsize, threshold
      dirs := []
      every subdir := gen_theme_directories(tm) do {
         if m := member(tm, subdir) &
            size := integer(member(m, u"Size")) then 
         {
            type := string(member(m, u"Type")) | "Threshold"
            threshold := integer(member(m, u"Threshold")) | 2
            minsize := integer(member(m, u"MinSize")) | size
            maxsize := integer(member(m, u"MaxSize")) | size
            cd := []
            every d := gen_base_dirs() do {
               f := FilePath(d).walk("icons", theme).append(FilePath(subdir))
               if ds := dir_set(f.str()) & *ds > 2 then
                  put(cd, CachedDir(f, ds))
            }
            if *cd > 0 then
               put(dirs, ThemeDirectory(type, size, minsize, maxsize, threshold, cd))
         }
      }
      return ThemeIndex(dirs, ipl.pdco.List{gen_theme_parents(tm)})
   end

   private static setup_icon_fallback_cached_dirs()
      local d, p, r, ds
      r := []
      every d := gen_base_dirs() do {
         p := FilePath(d).child("icons")
         if ds := dir_set(p.str()) & *ds > 2 then
            put(r, CachedDir(p, ds))
      }
      return r
   end

   private static get_theme_index1(name)
      local d, m
      every d := gen_base_dirs() do {
         if m := build_theme_index(name, load_ini_file(FilePath(d).walk("icons", name, "index.theme").str())) then
            return m
      }
   end

   private static get_theme_index(name)
      local m
      if not(m := member(ICON_THEMES, name)) then {
         m := get_theme_index1(name)
         insert(ICON_THEMES, name, m)
      }
      return \m
   end

   #
   # Find an icon given the icon name (string) and integer size.
   #
   public static find_icon(icon, size)
      local k, v
      icon := string(icon) | runerr(103, icon)
      k := icon || "/" || size
      if not(v := member(FIND_ICON_CACHE, k)) then {
         v := find_icon_helper(icon, size, icon_theme, set()) | lookup_fallback_icon(icon)
         insert(FIND_ICON_CACHE, k, v)
      }
      return \v
   end

   #
   # Find an icon given a filename (string) and integer size.
   #
   public static suggest_icon_for_file(file, size)
      local mt, i, f
      every mt := alternative_mime_types(get_mime_type_for_file(file)) do
         every i := gen_all_icons(mt) do {
            if f := find_icon(i, size) then
               return f
         }
   end

   private static get_current_icon_theme()
      local f, theme, d
      every theme := getenv_ne("OITHEME") | "oxygen" | "gnome" do {
         every d := gen_base_dirs() do {
            f := FilePath(d).walk("icons", theme, "index.theme").str()
            if Files.access(f) then
               return theme
         }
      }
      return "hicolor"
   end

   private static find_icon_helper(icon, size, theme, tried)
      local theme_index
      if member(tried, theme) then
         fail
      insert(tried, theme)
      theme_index := get_theme_index(theme) | fail

      # Try this theme, failing that try recursively with the theme's parents.
      return lookup_icon(theme_index, icon, size) | 
         find_icon_helper(icon, size, !theme_index.parents, tried)
   end

   private static lookup_fallback_icon(icon)
      return has_icon(!ICON_FALLBACK_CACHED_DIRS, icon)
   end

   private static has_icon(cached_dir, icon)
      local ex, f
      if f := cached_dir.access(icon || ".png") then
         return f
      if \scalable_flag then {
         every ex := ".svg" | ".svgz" do {
            if f := cached_dir.access(icon || ex) then {
               # Try to load cairo; if fail then don't look for svg files again.
               if /Context.LOADED then {
                  scalable_flag := &null
                  fail
               }
               return f
            }
         }
      }
   end

   private static lookup_icon(theme_index, icon, size)
      local subdir, f, minimal_size, closest_filename, ms
      every subdir := !theme_index.directories do {
         if subdir.matches_size(size, scalable_flag) then {
            # Search in all the CachedDirs in the subdir
            if f := has_icon(!subdir.cached_dirs, icon) then
               return f
         }
      }
      minimal_size := lang.Limit.MaxWord
      every subdir := !theme_index.directories do {
         if (ms := subdir.directory_size_distance(size, scalable_flag)) < minimal_size then {
            if f := has_icon(!subdir.cached_dirs, icon) then {
               closest_filename := f
               minimal_size := ms
            }
         }
      }
      return \closest_filename
   end
end

#
# An entry in the `Globs` object.
#
class GlobMatch()
   public const
      weight,      # The integer weight
      type,        # The mime type (string)
      pattern      # An optional wildcard pattern.

   public new(weight, type, pattern)
      self.weight := weight
      self.type := type
      self.pattern := pattern
      return
   end
end

# A helper class used to store wildcard ("globbing") information
# associated with mime-types.
#
class Globs()
   private const
      literal,
      simple,
      other

   public lookup(f)
      local i, v, fm
      f := ucs(f) | fail
      fm := map(f)
      if v := member(literal, f | fm) then
         return v
      every i := upto('.', f) do {
         if v := member(simple, (f | fm)[i + 1:0]) then
            return v
      }
      every v := !other do {
         if v.pattern.match(f | fm) then
            return v
      }
   end

   #
   # Add an entry.  p is the pattern (ucs), weight an integer and type
   # the mime type (string).
   #
   public add(p, weight, type)
      local x
      if upto('*?[', p) then {
         if match(u"*.", p) & not upto('*?[', p[3:0]) then {
            p := p[3:0]
            x := member(simple, p)
            if /x | (weight > x.weight) then
               insert(simple, p, GlobMatch(weight, type))
         } else {
            x := member(other, p)
            if /x | (weight > x.weight) then
               insert(other, p, GlobMatch(weight, type, Wildcard(p)))
         }
      } else {
         x := member(literal, p)
         if /x | (weight > x.weight) then
            insert(literal, p, GlobMatch(weight, type))
      }
      return self
   end

   public new()
      literal := table()
      simple := table()
      other := table()
      return
   end
end
