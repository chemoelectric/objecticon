#
# $Id$
#

package net

import 
   lang(fatal),
   util

$include "posix.icn"

#
# Common base class for a client class which holds a connection to a
# server and communicates using CRLF-terminated lines.
#
class NetClient(Connectable, Error, SetFields)
   public static const 
      CONNECTING_EVENT,
      CONNECTED_EVENT,
      CLOSED_EVENT,
      SENDING_STRING_EVENT,
      SENDING_LINE_EVENT,
      READ_LINE_EVENT,
      READ_STRING_EVENT

   private static init()
      CONNECTING_EVENT := "Connecting"
      CONNECTED_EVENT := "Connected"
      CLOSED_EVENT := "Closed"
      SENDING_STRING_EVENT := "Sending string"
      SENDING_LINE_EVENT := "Sending line"
      READ_LINE_EVENT := "Read line"
      READ_STRING_EVENT := "Read string"
   end

   private readable
      path,
      server,
      port,
      connection,
      sbuff,
      timeout

   # 
   # Fail and set the error code, and close the connection.
   #
   protected error_and_close(a)
      error(a)
      close()
   end

   #
   # Set the timeout in ms to use.  If a figure of zero, or &null, is given (the default)
   # then no timeout will be used.
   #
   public set_timeout(timeout)
      return self.timeout := timeout
   end

   #
   # Open the connection.
   #
   public open()
      local n, l1, l2, domain, addr

      if \server then {
         domain := PF_INET
         addr := "inet:" || server || ":" || port
      } else if \path then {
         domain := PF_UNIX
         addr := "unix:" || path
      } else
         fatal(self, "Neither server/port nor path set")

      close() | fail
      connection := socket(domain)

      # If we are using a timeout, put the socket into non-blocking mode
      if \timeout > 0 then
         fflag(connection, O_NONBLOCK)

      fire(CONNECTING_EVENT)
      default.connect(connection, addr) | {
         if \timeout > 0 & &errno = EINPROGRESS then {
            #write("** in progress")
            l1 := [connection]
            l2 := [connection]
            select(&null, l1, l2, timeout) | {
               n := &errno
               close()
               return error("Couldn't connect to " || addr || ":" || strerror(n))
            }
            if *l2 > 0 then {
               close()
               return error("Couldn't connect to " || addr || " (socket error)")
            }
            #write("select success ", *l1, " ", *l2)
         } else {
            # Save errno, close() will overwrite it
            n := &errno
            close()
            return error("Couldn't connect to " || addr || ":" || strerror(n))
         }
      }
      sbuff := ""
      fire(CONNECTED_EVENT)
      return connection
   end

   #
   # Close the connection
   #
   public close()
      if \connection then {
         default.close(connection) | return error("Failed to close connection:" || strerror())
         fire(CLOSED_EVENT)
         connection := &null
      }
      return
   end

   #
   # Set the path to use (implies using PF_UNIX socket domain)
   #
   public set_path(s)
      path := s
   end

   #
   # Set the server to use (implies using PF_INET socket domain)
   #
   public set_server(s)
      server := s
   end

   #
   # Set the port
   #
   public set_port(n)
      port := n
   end

   #
   # Low-level write on the connection. 
   #
   private send(s)
      local i, l1, l2

      while *s > 0 do {
         if \timeout > 0 then {
            l1 := [connection]
            l2 := [connection]
            select(&null, l1, l2, timeout) |
               return error("Send failed:" || strerror())
            if *l2 > 0 then
               return error("Send failed (socket error)")
         }
         i := writes(connection, s) | {
            return error("Failed to write:" || strerror())
         }
         s := s[i+1 : 0]
      }
      return
   end

   #
   # Low-level read on the connection. 
   #
   private recv(len)
      local l1, l2

      if \timeout > 0 then {
         l1 := [connection]
         l2 := [connection]
         select(l1, &null, l2, timeout) |
            return error("Receive failed:" || strerror())
         if *l2 > 0 then
            return error("Receive failed (socket error)")
      }
      return reads(connection, len) | error("Failed to read:" || strerror())
   end

   #
   # Write the given string to the connection.
   #
   public write_str(s)
      fire(SENDING_STRING_EVENT, s)
      return send(s)
   end

   #
   # Write a single line to the connection, appending CRLF to the output stream.
   # 
   public write_line(s)
      /s := ""
      fire(SENDING_LINE_EVENT, s)
      return send(s || "\r\n") 
   end

   #
   # Read a single line from the connection, and return it.
   #
   public read_line()
      local line

      repeat {
         #
         # Look for a line and if found return it.
         #
         sbuff ? {
            if line := tab(find("\r\n")) then {
               move(2)
               sbuff := tab(0)
               fire(READ_LINE_EVENT, line)
               return line
            }
         }
         sbuff ||:= recv(1024) | fail
      }
   end

   #
   # Read up to len bytes on the connection.
   #
   public read_str(len)
      local t
      #
      # Use the line buffer if it has anything in it.
      #
      if *sbuff > 0 then {
         sbuff ? {
            t := move(len) | tab(0)
            sbuff := tab(0)
         }
      } else {
         t := recv(len) | fail
      }
      fire(READ_STRING_EVENT, t)
      return t
   end

   protected set_one(f)
      case f.attr of {
         "timeout": set_timeout(f.int_val())
         "server": set_server(f.string_val())
         "path": set_path(f.string_val())
         "port": set_port(f.int_val())
         default : fail
      }
      return
   end

   public new(a[])
      cast(self,Connectable).new()
      sbuff := ""
      set_fields(a)
      return
   end
end
