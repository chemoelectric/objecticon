package util

import lang(Class)

#
# Succeed iff the sequence generated by {&features} contains the given
# string.
#
procedure has_feature(x)
   static s
   initial {
      s := set()
      every insert(s, &features)
   }
   return member(s, x)
end

#
# Convenient procedure to set {&why} to the given string and fail.
#
procedure error(s)
   &why := s
end

# This class just provides a simple constructor which initializes the
# instance fields in the order they were defined in the class, from
# the given parameters.  In other words, rather like a record
# constructor.  The fields in the subclass must of course be
# accessible to this class's constructor.
#
# @example
# @  class Abc(SimpleConstructor) public const a, b, c end
# @  ...
# @  x := Abc(1,2,3)  # Sets a,b,c to 1,2,3 respectively
#  
class SimpleConstructor()
   public new(a[])
      every Class.get(self, 1 to Class.get_n_instance_fields(self)) := pop(a)
      return
   end
end

# Invoke co-expression {e}, generating its results, in such a way that
# changes to {var} made by {e} will not be seen by the caller, and
# vice versa.
#
# @example
# @ # Sleep in a {io.Task}, within a try block.
# @ save_var{ task.sleep(1000), exception.throw_handler }
#
# @example
# @ # Cleanup some io stuff, without affecting {&why}
# @ save_var{ io_cleanup(), &why }
#
procedure save_var(e, var)
   local t
   t := !var
   repeat {
      suspend 1(@e, !var :=: t) do {
         !var :=: t
         break next
      }
      !var := t
      fail
   }
end

# Invoke co-expression e, generating its results, setting {var} to
# {init} before each invocation.  Further, the value of {var} before
# being set to {init} is saved and restored before each suspension or
# failure.
#
# Safe() and try() follow this general pattern, but are implemented
# separately for the sake of efficiency.
#
procedure with_var(e, var, init)
   local t
   repeat {
      t := !var
      !var := !init
      suspend 1(@e, !var := t) do
         break next
      !var := t
      fail
   }
end

# Like {save_var}, but saves the value of {&subject} and {&pos}
# instead.
#
procedure save_scan(e)
   local ss, sp, tp
   ss := &subject
   sp := &pos
   repeat {
      suspend 1(@e, tp := &pos, &subject :=: ss, &pos := sp, sp := tp) do {
         tp := &pos
         &subject :=: ss
         &pos := sp
         sp := tp
         break next
      }
      &subject := ss
      &pos := sp
      fail
   }
end

# This function saves {&why} before evaluating {e}.  If {e} succeeds,
# {&why} is restored, and the result returned; otherwise {&why} is not
# restored and the procedure fails.
#
procedure protect_why(e)
   local t
   t := &why
   return 1(@e, &why := t)
end
