import 
   gui, 
   io,
   util,
   xml,
   graphics,
   lang,
   mail,
   http,
   net,
   xdg,
   posix,
$ifndef _PLAN9
   ipl.childwait,
$endif
   ipl.options,
   ipl.browser,
   ipl.strings,
   ipl.lists,
   ipl.pdco

global opts

$ifdef _PNG
$load INCREASE_FONT "rpp.INCREASE_FONT_24.png"
$load DECREASE_FONT "rpp.DECREASE_FONT_24.png"
$else
$load INCREASE_FONT "rpp.INCREASE_FONT_24.gif"
$load DECREASE_FONT "rpp.DECREASE_FONT_24.gif"
$endif
$load EXIT "rpp.EXIT_24.gif"
$load STOP "rpp.STOP_24.gif"
$load PASTE "rpp.PASTE_24.gif"
$load CLEAR "rpp.CLEAR_24.gif"
$load BROWSER_LOGO "rpp.BROWSER_LOGO.png"

class Settings2()
   public
      home_url,
      cache_size_mb,
      cache,
      visited,
      visited_size,
      pool_size,
      max_concurrent_downloads,
      destination_dir,
      authentications,
      font_factor

   public new()
      home_url := URL(u"config:")
      cache_size_mb := 8
      pool_size := 6 
      max_concurrent_downloads := 3
      visited := []
      visited_size := 100
      destination_dir := "/tmp"
      font_factor := 1.0
      return
   end
end

class VisitedEntry()
   public const
      url
   public
      title,
      last_time,
      times

   public new(url, title)
      self.url := url
      self.title := title
      self.last_time := Time()
      self.times := 1
      return
   end
end

class PageMenu(DynamicMenu)
   public populate()
      move_all(parent_component.parent_dialog.tabs.which_one.create_page_menu())
   end
end

class BrowserDialog(Dialog, WorkerPoolOwner)
   private readable
      settings,
      visited_set,
      pool,
      tabs,
      file_dialog,
      directory_dialog,
      downloads,
      page_menu

   public
      last_download_dir,
      last_file_dir

$ifdef _PLAN9
   public static launch_prog(de, file)
      local pid, nul, cmd

      pid := System.fork(ior(ForkOpt.RFPROC, ForkOpt.RFFDG, ForkOpt.RFNAMEG, ForkOpt.RFENVG,
                             ForkOpt.RFNOTEG, ForkOpt.RFREND, ForkOpt.RFNOWAIT)) | fail
      if pid > 0 then {
         # Parent
         return
      }

      # Unmount our window directories in /n.  If we didn't do this,
      # and since we are copying the namespace, this would prevent
      # these windows closing until the launched application closes.
      Files.unmount_windows()

      # Set the working directory for the child process
      Files.chdir(\de.path | Files.get_home())
      # Get the command to run.
      cmd := de.subst_file(Format.rc_escape(file))
      if \opts["v"] then 
         write("Command: ", image(cmd))
      if nul := FileStream("/dev/null", FileOpt.RDWR) then {
         every nul.dup2(FileStream.stdin | FileStream.stdout | FileStream.stderr)
         nul.close()
      }
      System.exec("/bin/rc", ["-c", "exec " || cmd]) | stop(&why)
      syserr("Not reached")
   end
$else
   public static launch_prog(de, file)
      local pid, nul, cmd, s
      pid := System.fork() | fail
      if pid > 0 then {
         # Parent
         ChildWait.add_pid(pid, on_prog_exit)
         return
      }
      # Set the working directory for the child process
      Files.chdir(\de.path | Files.get_home())
      # Get the command to run.
      cmd := de.subst_file(Format.shell_escape(file))
      if \opts["v"] then 
         write("Command: ", image(cmd))
      System.setpgid()
      if nul := FileStream("/dev/null", FileOpt.RDWR) then {
         every nul.dup2(FileStream.stdin | FileStream.stdout | FileStream.stderr)
         nul.close()
      }
      System.exec("/bin/sh", ["-c", "exec " || cmd]) | stop(&why)
      syserr("Not reached")
   end

   private static on_prog_exit(r)
      if \opts["v"] then
         write("Child application exited: ", to_string(r))
   end
$endif

   private on_quit(ev)
      dispose()
   end

   private on_tab_changed(ev)
      update_grey()
   end

   public update_grey()
      page_menu.set_is_shaded(No{ is(tabs.which_one, BrowserTab) })
   end

   public initially()
      Dialog.initially()
      pool.initially()
   end

   public finally()
      Dialog.finally()
      pool.finally()
   end

   public update_visited(url, title)
      local e, i, s
      if url.scheme == (u"cache" | u"config") then
         fail
      s := url.str()
      every i := 1 to *settings.visited do {
         e := settings.visited[i]
         # Don't use equals here since the ucs/string interaction may
         # give wrong results; eg on a redirection we get a URL
         # composed of string elements.
         if s == e.url.str() then {
            e.last_time := Time()
            e.title := title
            e.times +:= 1
            delete(settings.visited, i)
            push(settings.visited, e)
            return
         }
      }
      push(settings.visited, VisitedEntry(url, title))
      insert(visited_set, url.str())
      while *settings.visited > settings.visited_size do {
         e := pull(settings.visited)
         delete(visited_set, e.url.str())
      }
   end

   public new_tab(url, referer_url, sel, adjacent)
      local bt, np
      np := if /adjacent then
         # Add to end, unless the DownloadTab is at the end, in which
         # case add at one from the end.
         if is(tabs.children[-1], DownloadTab) then -1 else 0
      else
         # Add after adjacent
         tabs.get_index(adjacent) + 1
      bt := BrowserTab(self, url, referer_url, tabs.which_one).
         set_is_hidden(&yes)
      tabs.add(bt, np)
      if is_live() then
         tabs.do_layout().invalidate()
      if \sel then {
         tabs.set_which_one(bt)
         update_grey()
      }
      return bt
   end

   private on_new_tab(ev)
      new_tab(settings.home_url,, &yes)
   end

   private on_xdg_refresh(ev)
      Xdg.refresh()
      tabs.which_one.msg("XDG database reloaded", 3000)
   end

   private list_visited()
      local s, e, n
      s := "<html><title>Visited</title>" || Browser.get_table_tag() || ""
      s ||:= "<tr><th align=left>Title</th><th align=right>Times&nbsp;</th><th>Last visit</th><th align=left>URL</th></tr>"
      every e := !settings.visited do {
         n := Browser.limit_text(\e.title, scale(200)) | ""
         s ||:= "<tr><td nowrap>" || Browser.to_content(n) || "</td><td align=right>" || e.times || "&nbsp;</td><td>" || 
                e.last_time.format("MMM'&nbsp;'dd'&nbsp;'HH:mm") || "</td>" || Browser.mk_anchor_cell(e.url) || "</tr>"
      }
      s ||:= "</table></html>"
      return s
   end

   private list_all_cookies()
      local s, e
      s := "<html><title>Cookies</title>"
      every e := (!sort(pool.cookies))[1] do
         s ||:= "<a href=config:cookie?q=" || URL.cgi_encode(e) || ">" || e || "</a><br>"
      s ||:= "</html>"
      return s
   end

   private del_cookie(req)
      local t, t1, t2, k, path, name

      (t := req.url.extract_cgi_parameters() &
       k := member(t, "q")[1] &
       path := member(t, "path")[1] & 
       name :=  member(t, "name")[1]) | return error("Bad request")

      if t1 := member(pool.cookies, k) &
         t2 := member(t1, path) then
      {
         delete(t2, name)
         if *t2 = 0 then {
            delete(t1, path)
            if *t1 = 0 then
               delete(pool.cookies, k)            
         }
      }
      return list_cookie(req)
   end

   private del_cookies(req)
      local k
      (k := member(req.url.extract_cgi_parameters(), "q")[1]) | return error("Bad request")
      delete(pool.cookies, k)            
      return list_cookie(req)
   end

   private list_cookie(req)
      local k, s, t, path, ck, t2, name
      (k := member(req.url.extract_cgi_parameters(), "q")[1]) | return error("Bad request")
      s := "<html><title>Cookies</title><h2>Cookies for domain " || k || "</h2><p>"
      if t := member(pool.cookies, k) then {
         s ||:= "<a href=config:del_cookies?q=" || URL.cgi_encode(k) || ">Delete all</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href=config:cookies>Back to list</a>"
         every path := key(t) do {
            t2 := member(t, path)
            every name := key(t2) do {
               ck := member(t2, name)
               s ||:= "<hr><br><table>"
               s ||:= "<tr><td>Name&nbsp;&nbsp;</td><td>" || ck.name || "</td></tr>"
               s ||:= "<tr><td>Value&nbsp;&nbsp;</td><td>" || ck.value || "</td></tr>"
               s ||:= "<tr><td>Expires&nbsp;&nbsp;</td><td>" || (\ck.expires).to_rfc822() || "</td></tr>"
               s ||:= "<tr><td>Domain&nbsp;&nbsp;</td><td>" || \ck.domain || "</td></tr>"
               s ||:= "<tr><td>Path&nbsp;&nbsp;</td><td>" || path || "</td></tr>"
               s ||:= "<tr><td>Secure&nbsp;&nbsp;</td><td>" || \ck.secure || "</td></tr>"
               s ||:= "<tr><td>Comment&nbsp;&nbsp;</td><td>" || \ck.comment || "</td></tr>"
               s ||:= "<tr><td>Version&nbsp;&nbsp;</td><td>" || \ck.version || "</td></tr>"
               s ||:= "</table><br><a href=config:del_cookie?" || URL.make_cgi_string(table(, 
                                                                                            "q", k,
                                                                                            "path", path,
                                                                                            "name", name)) || 
                  ">Delete</a>"
            }
         }
      } else 
         s ||:= "No cookies.&nbsp;&nbsp;<a href=config:cookies>Back to list</a>"
      s ||:= "</html>"
      return s
   end

   private edit_settings(req)
      local t, home, cn, vn, pn, mcd, ff
      (t := req.url.extract_cgi_parameters() &
       home := URL(ucs(member(t, "home")[1])) &
       cn := integer(member(t, "cache")[1]) &
       vn := integer(member(t, "vsize")[1]) &
       pn := integer(member(t, "psize")[1]) &
       ff := real(member(t, "fontfactor")[1]) &
       mcd := integer(member(t, "maxcd")[1])) | return error("Bad request")
      settings.authentications := if member(t, "authentications") then
         pool.authentications
      else
         &null
      settings.cache := if member(t, "persistent_cache") then
         pool.cache
      else
         &null
      settings.home_url := home
      settings.cache_size_mb := cn
      settings.visited_size := vn
      settings.pool_size := pn
      settings.max_concurrent_downloads := mcd
      settings.font_factor := ff
      pool.cache.set_size(settings.cache_size_mb * 1024*1024)
      return config_main("<p><font size=+1 color=green>Settings saved OK; pool size only takes effect on restart, font factor on new tab.</font><p>")
   end

   private config_main(msg)
      local s
      s := "<html><title>Config</title>"
      s ||:= \msg
      s ||:= "<a href=config:cookies >Edit cookies</a><p>_
              <a href=config:visited >Visited pages</a><p>_
              <a href=config:cache >Cache status</a><p>_
              <a href=config:clear_cache >Clear cache</a><p>_
              <a href=config:workers >Worker pool status</a><p>_
              <fieldset><form method=get action=submit >_
                 <legend>Edit settings</legend>_
                 <table>_
                   <tr><td>Home page:</td><td><input type=url name=home value=" || xml_escape(settings.home_url.str(), ~(&letters++&digits)) || " size=50 /></td></tr>_
                   <tr><td>Cache size (MB):</td><td><input type=number min=1 step=1 name=cache value=" || settings.cache_size_mb || " size=50 /></td></tr>_
                   <tr><td>Visited list size:</td><td><input type=number min=10 step=1 name=vsize value=" || settings.visited_size || " size=50 /></td></tr>_
                   <tr><td>Worker pool size:</td><td><input type=number min=5 step=1 name=psize value=" || settings.pool_size || " size=50 /></td></tr>_
                   <tr><td>Max concurrent downloads:</td><td><input type=number min=2 step=1 name=maxcd value=" || 
                           settings.max_concurrent_downloads || " size=50 /></td></tr>_
                   <tr><td>Font size factor:</td><td><input type=number min=0.5 step=0.1 name=fontfactor value=" || settings.font_factor || " size=50 /></td></tr>_
                   <tr><td colspan=2><label><input type=checkbox name=authentications value=yes " || 
                                       (if /settings.authentications then "" else "checked") || "/> Save authentications</label></td></tr>_
                   <tr><td colspan=2><label><input type=checkbox name=persistent_cache value=yes " || 
                                       (if /settings.cache then "" else "checked") || "/> Persistent cache</label></td></tr>_
                 </table>_
                 <p>_
                 <input type=submit />_
              </form></fieldset></html>"
      return s
   end

   private cache_status()
      return pool.cache.get_status()
   end

   private clear_cache()
      pool.cache.clear()
      return config_main("<p><font size=+1 color=green>Cache cleared.</font><p>")
   end

   private workers_status()
      return pool.get_status()
   end

   private do_delay(worker)
      local n
      (n := member(worker.req.url.extract_cgi_parameters(), "n")[1]) | return error("Bad request")
      worker.task.sleep(n)
      return "<html>Complete</html>"
   end

   private do_image(req)
      local n
      (n := member(req.url.extract_cgi_parameters(), "name")[1]) | return error("Bad request")
      return ImageCache.get_named_image(n) | return error("Unknown image")
   end

   private config_handler(worker)
      local req
      req := worker.req
      return case string(req.url.path) of {
         "": config_main()
         "delay": do_delay(worker)
         "visited": list_visited()
         "cookies": list_all_cookies()
         "cookie": list_cookie(req)
         "cache": cache_status()
         "clear_cache": clear_cache()
         "workers": workers_status()
         "del_cookies": del_cookies(req)
         "del_cookie": del_cookie(req)
         "submit": edit_settings(req)
         "image": do_image(req)
         default: error("Bad config request")
      }
   end

   public get_authentication(httpc, dom, realm)
      local d
      d := AuthenticationDialog(dom, realm)
      d.show_modal(self)
      return \d.result
   end

   private on_tabs_rpress(e)
      local t, m, pm
      t := tabs.which_tab(e) | fail
      m := Menu().
         add(TextMenuItem().
             set_label("New").
             connect(create new_tab(settings.home_url,, &yes, t), Event.ACTION))
      if is(t, BrowserTab) then
         m.add(TextMenuItem().
             set_label("Close").
             connect(create t.close_tab(), Event.ACTION)).
         add(TextMenuItem().
             set_label("Clone").
             connect(create t.clone_tab(), Event.ACTION))
      pm := PopupMenu().
         connect(create tabs.set_which_highlight(), Event.POPUP_CLOSED)
      tabs.set_which_highlight(t)
      pm.popup(self, m, e.x, e.y)
   end

   public new(cookies, settings)
      local quit_menu_item, menu_bar, file_menu, new_tab_item, 
         xdg_refresh_item
      Dialog.new()
      self.settings := settings
      self.visited_set := set()
      every insert(visited_set, (!settings.visited).url.str())
      pool := WorkerPool(self, settings.pool_size).
         set_cookies(cookies).
         add_scheme_handler("config", config_handler)
      pool.set_authentications(\settings.authentications)
      pool.set_cache(\settings.cache)
      pool.cache.set_size(settings.cache_size_mb * 1024*1024)
      pool.set_user_agent(\opts["agent"])
      if \opts["l"] then
         pool.set_log_http(&yes)
      file_dialog := FileDialog().set_remember_size(&yes)
      directory_dialog := DirectoryDialog().set_remember_size(&yes)
      last_file_dir := last_download_dir := Files.getcwd()
      set_size(scale(850), scale(750))
      set_resize(&yes)
      new_tab_item := TextMenuItem().
         connect(on_new_tab, Event.ACTION).
         set_label("New Tab")
      xdg_refresh_item := TextMenuItem().
         connect(on_xdg_refresh, Event.ACTION).
         set_label("Refresh XDG")
      quit_menu_item := TextMenuItem().
         connect(on_quit, Event.ACTION).
         set_label("Quit")
      file_menu := Menu().
         set_accel("f").
         set_label("File").
         add(new_tab_item).
         add(xdg_refresh_item).
         add(quit_menu_item)
      page_menu := PageMenu().
         set_accel("p").
         set_label("Page")
      menu_bar := MenuBar().
         set_size(scale(100)).
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("l_inset", 0).
         set_constraint("r_inset", 0).
         set_constraint("t_inset", 0).
         set_constraint("b_inset", 0).
         set_constraint("x_fill", &yes).
         add(file_menu).
         add(page_menu)
      self.add(menu_bar)
      downloads := DownloadTab()
      tabs := TabSet().
         set_size(scale(200), scale(150)).
         clear_constraints().
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("y_fill", &yes).
         set_constraint("y_weight", 1.0).
         set_constraint("l_inset", 0).
         set_constraint("r_inset", 0).
         set_constraint("t_inset", 0).
         set_constraint("b_inset", 0).
         add(downloads).
         connect(on_tab_changed, Event.SELECTION_CHANGED).
         set_remember_focus(&yes).
         set_draggable_tabs(&yes).
         set_accepts_focus(&no).
         connect(on_tabs_rpress, Event.MOUSE_RIGHT_PRESS)
      self.add(tabs)
      self.connect(self.on_quit, Event.WINDOW_CLOSE_BUTTON)
      self.set_layout(GridLayout().set_extra("cells"))
      set_label("Browser")
      return
   end
end

class MessageDialog(Dialog)
   public const text

   public new()
      local close_button
      Dialog.new()
      set_resize(&yes)
      set_remember_size(&yes)
      text := EditableTextList().
         set_size(scale(500), scale(275)).
         set_constraint("eol", &yes).
         set_contents([""]).
         set_is_editable(&no)
      add(text)
      close_button := TextButton().
         connect(dispose, Event.ACTION).
         set_toggles(&no).
         set_paint(TextPaint("Close"))
      add(close_button)
      connect(dispose, Event.WINDOW_CLOSE_BUTTON)
      set_layout(GridLayout().set_extra("cells"))
      return
   end
end

class Download()
   private readable
      parent, req, resp, status, size, full_path, dialog, dest

   public enqueue()
      parent.parent_dialog.pool.enqueue(req)
      status := "Queued"
      return self
   end

   private log(s)
      dialog.text.log([&clock || u": " || Text.liberal_ucs(s)], 500)
   end

   private on_status(ev, src, type)
      local s
      s := type
      case type of {
         HttpClient.RETRYING_EVENT:  s ||:= ": " || &why
         NetClient.CONNECTING_EVENT: s ||:= " to " || src.server || ":" || src.port
      }
      log(s)
   end

   private got_data(r)
      local fname, n, check_eq
      resp := r
      if \r.err then {
         log("Failed to download: " || r.err)
         status := "Failed"
      } else {
         # Ensure illegal path chars (/ and NULL) are removed from fname
         fname := map(resp.fname, "/\0", "--")
         fname := if *fname = 0 then
            "browser.out"
         else
            # Ensure fname is in ucs.  This should mean full_path is in utf8 form since the
            # directories below were selected in the file dialogs.
            Text.liberal_ucs(fname)
         full_path := if \dest then
            if Files.is_directory(dest) then
               Files.ensure_unique_filename(check_eq := FilePath(dest).child(fname).canonical().str())
            else
               check_eq := dest
         else
            Files.ensure_unique_filename(check_eq := FilePath(parent.parent_dialog.settings.destination_dir).child(fname).canonical().str())

         if \r.data then {
            if Files.stat(check_eq).size = *r.data & Files.file_to_string(check_eq) == r.data then {
               log("Existing file " || check_eq || " is identical. (" || Format.numeric_to_string(*r.data, 0, ',') || " bytes)")
               full_path := check_eq
               status := "Done"
            } else if Files.string_to_file(full_path, r.data) then {
               log("Result file:" || full_path || " (" || Format.numeric_to_string(*r.data, 0, ',') || " bytes)")
               status := "Done"
            } else {
               log("Unable to create " || full_path || ": " || &why)
               Files.remove(full_path)
               status := "Failed"
            }
         } else {
            n := Files.stat(r.data_file).size | 0
            if Files.equal_files(r.data_file, check_eq) then {
               log("Existing file " || check_eq || " is identical. (" || Format.numeric_to_string(n, 0, ',') || " bytes)")
               full_path := check_eq
               Files.remove(r.data_file)
               status := "Done"
            } else if Files.move(r.data_file, full_path) then {
               log("Result file:" || full_path || " (" || Format.numeric_to_string(n, 0, ',') || " bytes)")
               status := "Done"
            } else {
               log("Unable to move " || r.data_file || " to " || full_path || ": " || &why)
               every Files.remove(r.data_file | full_path)
               status := "Failed"
            }
         }
      }
   end

   public get_status()
      local w, l
      if w := parent.parent_dialog.pool.get_worker(req) then {
         if l := (0 < w.length()) then {
            size := Format.numeric_to_string(l / 1048576.0, 1)
            status := "Downloading (" || ((w.read() * 100) / l) || "%)"
         } else {
            size := ""
            status := "Downloading (" || Format.numeric_to_string(w.read() / 1048576.0, 1) || "MB)"
         }
      }
      return [req.url.liberal_ucs(), size, status, self]
   end

   public retrying()
      self.status := "New"
      size := ""
      log("Retrying download")
   end

   public new(parent, url, referer, dest)
      self.parent := parent
      self.status := "New"
      self.dest := dest
      size := ""
      self.req := Req(parent, url, referer, got_data, Worker.DOWNLOAD,, on_status)
      self.dialog := MessageDialog().set_label("Item log")
      log("Log for " || url.str())
      return
   end
end

class DownloadTab(TabItem)
   private readable
      paste_url_button,
      destination_button,
      clear_done_button,
      url_field,
      message_label,
      ticker,
      dl,
      url_table

   private update_title()
      local s, n, e
      s := "Downloads"
      n := 0
      every e := !dl do {
         if not(e.status == ("Done" | "Failed")) then
            n +:= 1
      }         
      if n > 0 then
         s ||:= " (" || n || ")"
      set_paint(TabHeaderPaint(s))
   end

   private on_url_field(ev)
      local s, u
      s := url_field.get_contents()
      if *s = 0 then
         fail
      if u := URL(s) then
         download(u)
      else
         msg("Not a valid URL")
   end

   private handle_paste_response(target_type, data, e)
      if /data then
         fail
      data ?:= tab(upto('\r\n'))
      url_field.set_contents(Text.liberal_ucs(data)).grab_focus()
   end

   private on_paste_url(ev)
      parent_dialog.request_selection(Selection.CLIPBOARD, 
                                      ["text/uri-list", Selection.UTF8_STRING_TARGET, Selection.STRING_TARGET], 
                                      handle_paste_response, 
                                      ev)
   end

   private on_copy_urls(ev)
      local l
      l := []
      every put(l, (!url_table.table_content.object_get_gesture_selections())[-1].req.url)
      parent_dialog.own_selection(Selection.CLIPBOARD, URLSelectionOwner(l))
   end

   private on_copy_result(d)
      local s
      s := ucs(d.full_path) | d.full_path
      parent_dialog.own_selection(Selection.CLIPBOARD, 
                                  StaticTextSelectionOwner(s))
   end

   private on_copy_escaped_result(d)
      local s
      s := ucs(d.full_path) | d.full_path
$ifdef _PLAN9
      parent_dialog.own_selection(Selection.CLIPBOARD, 
                                  StaticTextSelectionOwner(Format.rc_escape(s)))
$else
      parent_dialog.own_selection(Selection.CLIPBOARD, 
                                  StaticTextSelectionOwner(Format.shell_escape(s)))
$endif
   end

   private on_delete(d)
      parent_dialog.pool.cancel_req(d.req)
      ldel1(dl, d)
      refresh()
   end

   private on_retry(d)
      d.retrying()
      refresh()
   end

   public msg(s, n)
      message_label.set(s, n)
   end

   private on_set_destination(ev)
      local d
      msg()
      d := parent_dialog.directory_dialog
      d.set_directory(parent_dialog.settings.destination_dir).set_existing_file_mode(DirectoryDialog.REQUIRE).show_modal(parent_dialog)
      parent_dialog.settings.destination_dir := d.get_result()
   end

   private on_clear_done(ev)
      local i
      i := 1
      while i <= *dl do {
         if dl[i].status == ("Done" | "Failed") then
            delete(dl, i)
         else
            i +:= 1
      }
      refresh()
   end

   private refresh()
      ticker.interrupt()
   end

   private static get_possible_desktop_entries(res)
      local mt
      mt := (\res.content_type).to_rfc1521()
      suspend Unique{Xdg.gen_desktop_entries(\mt) | 
                     Xdg.gen_desktop_entries(Xdg.alternative_mime_types(Xdg.get_mime_type_for_file(\res.fname)))}
   end

   private on_table_rpress(ev)
      local popup, menu, l, d, m1, m2, de

      msg()

      # Ensure something is there to popup onto...
      url_table.get_line_under_pointer(ev) | fail
      l := url_table.table_content.object_get_gesture_selections() | fail

      menu := Menu()
      if *l = 1 then {
         d := l[1][-1]
         menu.add(TextMenuItem().
            set_label("Log...").
            connect(create d.dialog.show(parent_dialog), Event.ACTION))
         menu.add(TextMenuItem().
            set_label("Copy URL").
            connect(self.on_copy_urls, Event.ACTION))
         if \d.full_path then {
            menu.add(TextMenuItem().
               set_label("Copy result").
               connect(create on_copy_result(d), Event.ACTION))
            menu.add(TextMenuItem().
               set_label("Copy escaped result").
               connect(create on_copy_escaped_result(d), Event.ACTION))
            m1 := Menu().set_label("Open with")
            every de := get_possible_desktop_entries(d.resp) do {
               m2 := TextMenuItem().
                  set_label(de.name)
               m2.set_paint_left(ImagePaint().set_cache(Xdg.find_icon_and_cache(\de.icon, Gui.MENU_ICON_SIZE, &yes)))
               m2.connect(cocopy{BrowserDialog.launch_prog(de, d.full_path)}, Event.ACTION)
               m1.add(m2)
            }
            if *m1.children > 0 then 
               menu.add(m1)
         }
         if l[1][-1].status == "Failed" then
            menu.add(TextMenuItem().
               set_label("Retry").
               connect(create on_retry(d), Event.ACTION))
         menu.add(TextMenuItem().
               set_label("Delete").
               connect(create on_delete(d), Event.ACTION))
      } else {
         menu.add(TextMenuItem().
            set_label("Copy URLs").
            connect(self.on_copy_urls, Event.ACTION))
      }

      popup := PopupMenu()
      popup.popup(self, menu, ev.x, ev.y)
   end

   private maybe_enqueue_some()
      local i, d
      # Count how many aren't in the pool queue, or working
      i := parent_dialog.settings.max_concurrent_downloads
      every d := !dl do {
         if match("Queued" | "Downloading", d.status) then
            i -:= 1
      }
      # Move any in "New" into available slots.
      every d := !dl do {
         if i <= 0 then
            break
         if d.status == "New" then {
            d.enqueue()
            i -:= 1
         }
      }
   end

   private update_status()
      local l
      l := []
      every put(l, (!dl).get_status())
      equals(l, url_table.get_contents()) | {
         url_table.set_contents(l)
         update_title()
      }
   end

   private tick()
      repeat {
         maybe_enqueue_some()
         update_status()
         ticker.sleep(750)
      }
   end

   public initially()
      TabItem.initially()
      ticker.start()
   end

   public finally()
      TabItem.finally() 
      ticker.stop()
   end

   public download(url, referer, dest)
      put(dl, Download(self, url, referer, dest))
      refresh()
   end

   public new()
      TabItem.new()
      label_border.set_x_align(Align.L)
      setup()
      theme_toolbar_button(paste_url_button, "edit-paste")
      theme_toolbar_button(destination_button, "go-up")
      theme_toolbar_button(clear_done_button)
      ticker := Dispatcher.new_task{tick()}
      dl := []
      update_title()
      return
   end

   private setup()
      local panel, border, w
      destination_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(TextPaint("Destination...")).
         connect(self.on_set_destination, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(ImagePaint().set_cache("gui.UP_24"))
      clear_done_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(TextPaint("Clear done")).
         connect(self.on_clear_done, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(ImagePaint().set_cache("rpp.CLEAR_24"))
      paste_url_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(TextPaint("Paste URL")).
         connect(self.on_paste_url, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(ImagePaint().set_cache("rpp.PASTE_24"))
      panel := Panel().
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_align", Align.L).
         set_layout(GridLayout().set_doi(0).set_dii(2).set_extra("cells")).
         add(destination_button).
         add(clear_done_button).
         add(paste_url_button)
      self.add(panel)
      url_field := TextField().
         set_size(scale(100)).
         set_align(Align.C, Align.T).
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         connect(self.on_url_field, Event.ACTION).
         set_contents(u"")
      self.add(url_field)
      use {
         w := Window(),
         url_table := gui.Table().
            set_size(scale(600), scale(260)).
            set_select_mode(Select.MANY).
            set_constraint("eol", &yes).
            set_contents([]).
            add_column(ItemPaintTableColumn().
                          set_label("URL").
                          set_item_paint(AbbreviatedTextItemPaint()).
                          set_item_border(EmptyBorder().             # Set a border to align with the button text
                                             set_insets(Gui.TEXT_INSET,0,0,0).
                                             set_x_align(Align.L))).
            add_column(TableColumn().set_label("MB").set_column_width(w.text_width("0,000.0")).set_column_align(Align.R)).
            add_column(TableColumn().set_label("State").set_column_width(w.text_width("Downloading (0,000.0MB)")))
      }
      url_table.table_content.connect(self.on_table_rpress, Event.MOUSE_RIGHT_PRESS)
      self.add(url_table)
      border := CompoundBorder().
         set_outer(SunkenBorder()).
         set_inner(EmptyBorder().
            set_l_inset(3)).
         set_x_align(Align.L)
      message_label := MessageLabel().
         set_size(scale(100)).
         set_align(Align.L, Align.B).
         set_fg("red").
         clear_constraints().
         set_constraint("b_inset", 0).
         set_constraint("l_inset", 0).
         set_constraint("r_inset", 0).
         set_constraint("x_fill", &yes).
         set_border(border).
         set_paint(TextPaint(""))
      self.add(message_label)
      self.set_layout(GridLayout().set_extra("cells"))
   end
end

class URLList(SelectableScrollArea)
   public static const
      TITLE_FONT, URL_FONT

   private static init()
      TITLE_FONT := "sans"
      URL_FONT := "sans,-1"
   end
   
   public calculate_line_height()
      local W, v
      use {
         W := view.cbwin.clone().set_font(TITLE_FONT),
         {
            v := W.get_line_height()
            W.set_font(URL_FONT)
            v +:= W.get_line_height()
         }
      }
      return v
   end

   public calculate_subject_width()
      # A nominal minimum width; the width will be expanded by the
      # owning EditList to its own width, and then we use limit_text
      # to draw nicely in the allocated view.
      return scale(250)
   end

   public draw_line_data(xp, yp, lh, i)
      local W
      use {
         W := view.cbwin.clone().set_font(TITLE_FONT),
         {
            W.draw_string(xp + Gui.TEXT_INSET, 
                          yp + W.get_line_ascent(), 
                          limit_text(W, \contents[i].title, view.w - 2 * Gui.TEXT_INSET))
            yp +:= W.get_line_height()
            W.set_font(URL_FONT).set_fg("blue")
            W.draw_string(xp + Gui.TEXT_INSET, 
                          yp + W.get_line_ascent(), 
                          limit_text(W, u"    " || contents[i].url.liberal_ucs(), view.w - 2 * Gui.TEXT_INSET))
         }
      }
   end
end

class URLEditList(IndependentEditList)
   public create_view()
      # Using a standard textfield inhibits cursor up/down from going
      # back/forward in the history, which interacts poorly with the
      # focus.
      return TextField().
         set_border(EmptyBorder().set_l_inset(Gui.TEXT_INSET).set_r_inset(Gui.TEXT_INSET))
   end

   public create_popup()
      set_selection_list(copy(parent.browser.history))
      set_selection(parent.browser.history_pos)
      return URLList()
   end
end

class TabHeaderPaint(Paint)
   public str, icon, icon_win

   public static const
      ICON_SIZE

   private static init()
      ICON_SIZE := scale(16)
   end
   
   public initially(c)
      local iw
      iw := Window.open_image(\icon)
      self.h := max(ICON_SIZE, c.cbwin.get_font_height())
      if \iw then {
         if iw.get_height() ~= ICON_SIZE then {
            icon_win := Window().set_size((iw.get_width() * ICON_SIZE) / iw.get_height(), ICON_SIZE)
            zoom_win(iw, icon_win)
            iw.close()
         } else
            icon_win := iw
         self.w := icon_win.get_width() + Gui.TEXT_INSET + c.cbwin.text_width(str)
      } else
         self.w := c.cbwin.text_width(str)
   end

   public finally()
      (\icon_win).close()
      icon_win := &null
   end

   public draw(W, x, y, w, h)
      if \icon_win then {
         icon_win.copy_to(,,,, W, x, y + (h - icon_win.get_height()) / 2)
         x +:= icon_win.get_width() + Gui.TEXT_INSET
         w -:= icon_win.get_width() + Gui.TEXT_INSET
         W.draw_string(x, y + W.get_font_ascent(), limit_text(W, str, w))
      } else
         W.draw_string(x, y + W.get_font_ascent(), limit_text(W, str, w))
   end

   public label_will_fit(W, w)
      return if \icon_win then
         W.text_width(str) <= w - (icon_win.get_width() + Gui.TEXT_INSET)
      else
         W.text_width(str) <= w
   end

   public new(s, icon)
      self.str := s
      self.icon := icon
      return
   end
end

class BrowserTab(TabItem, BrowserUI)
   private readable
      browser,
      prev_button,
      message_label,
      close_button,
      url_field,
      next_button,
      stop_button,
      home_button,
      paste_url_button,
      refresh_button,
      increase_font_button,
      decrease_font_button,
      title_tt,
      revert_tab,
      search_panel,
      search_field,
      search_label, 
      search_close_button,
      search_next_button,
      search_prev_button, 
      search_pos

   private on_close_button(ev)
      close_tab()
   end

   public close_tab()
      local t, i
      if parent.which_one === self then {
         # Note that parent.get_index may fail even if \revert_tab, since
         # revert_tab may have been removed from the TabSet previously.
         (i := parent.get_index(\revert_tab)) | {
            i := parent.get_index(self)
            # If i=1, there will always be a tab to the right of this one (it may be the download tab).
            if i > 1 then
               i -:= 1
            else
               i +:= 1
         }
         t := parent.children[i] | syserr("Couldn't find other tab")
         parent.set_which_one(t)
         parent_dialog.update_grey()
      }
      parent.
         remove(self).
         do_layout().
         invalidate()
   end

   public clone_tab()
      local t
      t := parent_dialog.new_tab(,, &yes, self)
      t.browser.clone_history(browser)
   end

   public get_label_width()
      return scale(100)
   end

   private on_next(ev)
      browser.do_next()
   end

   private on_prev(ev)
      browser.do_prev()
   end

   public link_left_clicked(url)
      browser.goto(url, browser.page_url)
   end

   public link_middle_clicked(url)
      parent_dialog.new_tab(url, browser.page_url,, self)
   end

   private copy_link(url)
      parent_dialog.own_selection(Selection.CLIPBOARD, URLSelectionOwner([url]))
   end

   private copy_links(urls)
      parent_dialog.own_selection(Selection.CLIPBOARD, URLSelectionOwner(urls))
   end

   private download_links(urls, referer)
      every parent_dialog.downloads.download(!urls, referer)
   end

   private download_links_to_dir(urls, referer)
      local d, f
      d := parent_dialog.directory_dialog
      d.set_directory(parent_dialog.last_download_dir).set_existing_file_mode(DirectoryDialog.REQUIRE).show_modal(parent_dialog)
      f := d.get_result() | fail
      parent_dialog.last_download_dir := d.get_result()
      every parent_dialog.downloads.download(!urls, referer, f)
   end

   private copy_text(s)
      parent_dialog.own_selection(Selection.CLIPBOARD, StaticTextSelectionOwner(s))
   end

   private download(url, referer)
      parent_dialog.downloads.download(url, referer)
   end

   private show_img_error(err)
      local d
      d := MessageDialog().set_label("Image error")
      d.text.set_contents_str(err)
      d.show_modal()
   end

   private download_to_file(url, referer)
      local d, f, d1, f1, full_path
      d := parent_dialog.file_dialog
      d1 := FilePath(parent_dialog.last_download_dir)
      f1 := url.get_decoded_path_last()
      f1 := if *f1 = 0 | *f1 > 32 then
         "browser.out"
      else
         Text.liberal_ucs(f1)
      full_path := d1.child(f1).canonical().str()
      d.set_path(full_path).set_existing_file_mode(FileDialog.WARN).show_modal(parent_dialog)
      f := d.get_result() | fail
      parent_dialog.last_download_dir := d.get_directory()
      parent_dialog.downloads.download(url, referer, f)
   end

   private download_to_dir(url, referer)
      local d, f
      d := parent_dialog.directory_dialog
      d.set_directory(parent_dialog.last_download_dir).set_existing_file_mode(DirectoryDialog.REQUIRE).show_modal(parent_dialog)
      f := d.get_result() | fail
      parent_dialog.last_download_dir := d.get_result()
      parent_dialog.downloads.download(url, referer, f)
   end

   private page_info()
      local s, url
      s := browser.get_page_info() | fail
      url := browser.get_cache().create_url(, s,, ContentType("text", "html"))
      parent_dialog.new_tab(url,, &yes)
   end

   public display_search()
      search_panel.is_live() | open_search_panel()
   end

   private open_search_panel()
      add(search_panel, -1)
      reset_layout()
      layout()
      invalidate()
      update_search_state()
      parent_dialog.set_focus(search_field)
   end

   private close_search_panel()
      remove(search_panel)
      reset_layout()
      layout()
      invalidate()
      parent_dialog.set_focus(browser)
   end

   private on_search_next()
      if search_pos < *browser.sorted_searched then
         search_pos +:= 1
      else
         search_pos := 1
      browser.goto_searched(search_pos)
      update_search_state()
   end

   private on_search_prev()
      if search_pos > 1 then
         search_pos -:= 1
      else
         search_pos := *browser.sorted_searched
      browser.goto_searched(search_pos)
      update_search_state()
   end

   public update_search_state()
      if /browser.sorted_searched then {
         search_next_button.set_is_shaded(&yes)
         search_prev_button.set_is_shaded(&yes)
         search_label.set_label("No search")
      } else if *browser.sorted_searched = 0 then {
         search_next_button.set_is_shaded(&yes)
         search_prev_button.set_is_shaded(&yes)
         search_label.set_label("No results")
      } else {
         search_next_button.set_is_shaded(&no)
         search_prev_button.set_is_shaded(&no)
         search_label.set_label(search_pos || "/" || *browser.sorted_searched)
      }
   end

   private on_search_field()
      browser.do_search(search_field.get_contents())
      search_pos := 1
      browser.goto_searched(search_pos)
      update_search_state()
   end

   private on_select_all(e)
      browser.handle_select_all(e)
   end

   public create_page_menu()
      local m, s, l
      m := Menu()
      if \browser.page_url then {
         m.add(TextMenuItem().
               set_label("Copy page").
               connect(create copy_link(browser.page_url), Event.ACTION))
      }
      if \browser.page_data then {
         m.add(TextMenuItem().
               set_label("Save page...").
               connect(create do_save(browser.page_name, browser.page_data), Event.ACTION))
         if not search_panel.is_live() then
            m.add(TextMenuItem().
                  set_label("Search").
                  set_label_right("^F").
                  connect(open_search_panel, Event.ACTION))
         m.add(TextMenuItem().
               set_label("Select all").
               set_label_right("^A").
               connect(on_select_all, Event.ACTION))
         m.add(TextMenuItem().
               set_label("Page info").
               connect(page_info, Event.ACTION))
      }

      if s := browser.get_current_text_selection() then {
         m.add(TextMenuItem().
               set_label("Copy text").
               set_label_right("^C").
               connect(create copy_text(s), Event.ACTION))
      }
      if l := browser.get_current_links_selection() then {
         m.add(TextMenuItem().
               set_label("Copy links").
               connect(create copy_links(l), Event.ACTION))
         m.add(TextMenuItem().
               set_label("Download links").
               connect(create download_links(l, browser.page_url), Event.ACTION))
         m.add(TextMenuItem().
               set_label("Download links to dir...").
               connect(create download_links_to_dir(l, browser.page_url), Event.ACTION))
      }

      if *m.children > 0 then
         return m
   end

   private populate_link_menu(url, m)
      m.add(TextMenuItem().
            set_label("Copy link").
            connect(create copy_link(url), Event.ACTION))
      m.add(TextMenuItem().
            set_label("Download").
            connect(create download(url, browser.page_url), Event.ACTION))
      m.add(TextMenuItem().
            set_label("Download to file...").
            connect(create download_to_file(url, browser.page_url), Event.ACTION))
      m.add(TextMenuItem().
            set_label("Download to dir...").
            connect(create download_to_dir(url, browser.page_url), Event.ACTION))
   end

   public create_link_menu(url)
      local m
      m := Menu()
      populate_link_menu(url, m)
      return m
   end

   public create_image_menu(img)
      local m, url
      url := if img.img_url.scheme == u"cache" then browser.page_url else img.img_url
      m := Menu()
      m.add(TextMenuItem().
            set_label("Copy image").
            connect(create copy_link(url), Event.ACTION))
      if \img.over then
         populate_link_menu(img.over, m)
      if \img.img_data then
         m.add(TextMenuItem().
               set_label("Save image...").
               connect(create do_save(img.img_name, img.img_data), Event.ACTION))
      if \img.err then
         m.add(TextMenuItem().
               set_label("Show error...").
               connect(create show_img_error(img.err), Event.ACTION))
      return m
   end

   public update_grey(gs)
      prev_button.set_is_shaded(gs.prev)
      next_button.set_is_shaded(gs.nxt)
      refresh_button.set_is_shaded(gs.refresh)
      url_field.b.set_is_shaded(gs.history)
      stop_button.set_is_shaded(gs.stop)
   end

   private on_url_field_selection(ev)
      browser.do_jump(url_field.object_get_selection())
   end

   private on_url_field(ev)
      local s, u
      s := url_field.get_contents()
      if *s = 0 then
         fail
      if u := URL(s) then
         browser.goto(u)
      else
         browser.msg("Invalid url")
   end

   public msg(s, n)
      message_label.set(s, n)
   end

   private static has_data(file, data)
      return Files.stat(file).size = *data & Files.file_to_string(file) == data
   end

   private make_display_file(res)
      local t
      if /res.fname then
         t := Files.make_temp_filename("oibrowser")
      else {
         # Use liberal_ucs here since we will insert it into the desktop entry's command string,
         # which is ucs.  Also, we don't want non-utf files created in the filesystem.
         t := FilePath(Files.get_temp()).child(map(res.fname, "/\0", "--")).liberal_ucs()
         # If the display file has the same data, just return it.
         if has_data(t, res.data) then
            return t
         t := Files.ensure_unique_filename(t)
      }
      Files.string_to_file(t, res.data) | stop(&why)
      return t
   end

   public display_externally(res)
      local de, mt, file
      mt := (\res.content_type).to_rfc1521()
      de := Xdg.gen_desktop_entries(\mt) | Xdg.gen_desktop_entries_for_file(\res.fname) | fail
      if \opts["v"] then 
         write("Desktop entry: ", to_string(de, 3, 1))
      file := make_display_file(res)
      if \opts["v"] then 
         write("Display file: ", image(file))
      BrowserDialog.launch_prog(de, file)
      parent_dialog.update_visited(res.url)
      return
   end

   public browse_for_file(s)
      local d, p
      d := parent_dialog.file_dialog
      if *s = 0 then
         d.set_directory(parent_dialog.last_file_dir).set_files()
      else {
         p := FilePath(s).canonical()
         if Files.is_directory(p.str()) then
            d.set_directory(p.str()).set_files()
         else
            d.set_directory(p.parent().str()).set_file(p.get(-1))
      }
      d.set_existing_file_mode(FileDialog.REQUIRE).show_modal(parent_dialog)
      parent_dialog.last_file_dir := d.get_directory()
      return d.get_result()
   end

   private do_save(name, data)
      local s, d
      d := parent_dialog.file_dialog
      d.set_file(Text.liberal_ucs(map(\name, "/\0", "--")))
      d.set_directory(parent_dialog.last_file_dir).set_existing_file_mode(FileDialog.WARN).show_modal(parent_dialog)
      parent_dialog.last_file_dir := d.get_directory()
      if s := d.get_result() then {
         if Files.string_to_file(s, data) then
            browser.msg("Saved OK", 3000)
         else
            browser.msg(&why, 3000)
      }
   end

   public is_visited(url)
      return member(parent_dialog.visited_set, url.str())
   end

   public page_loaded()
      local ru
      # Don't save pages that didn't load in the visited list.
      if \browser.page_data then {
         parent_dialog.update_visited(browser.page_url, browser.page_title)
         # If we were redirected from the original url, save that too
         # in the visited list.
         ru := browser.page_resp.req.url
         if ru ~=== browser.page_url then
            parent_dialog.update_visited(ru, browser.page_title)
      }
      url_field.set_contents(browser.curr_history_entry.url.liberal_ucs())
      set_title(browser.page_title)
      # If we moved to another tab whilst this tab is loading, this won't
      # change the focus.
      browser.grab_focus()
      update_search_state()
   end

   private static convert_ico_to_png(data)
      return run_convert(StringStream(data),
                         ["-resize", 
                          "x" || TabHeaderPaint.ICON_SIZE,
                          "ico:-[0]",
                          "png:-"])
   end

   private update_title(fres)
      local data, ct
      /fres.err | fail
      data := fres.data
      if endswith(map(fres.fname), ".ico") | 
         (ct := \fres.content_type &
          ct.type == "image" &
          ct.subtype == "x-icon") then
         data := convert_ico_to_png(data) | fail
      set_title(browser.page_title, data)
   end

   public page_fully_loaded()
      update_title(\browser.page_favicon_resp)
   end

   private set_title(s, icon)
      /s := "Browser"
      set_paint(TabHeaderPaint(fill_title(s), icon))
      title_tt := &null
      return self
   end

   # Simple fill function for the potentially multi-line title.
   private static fill_title(s)
      local l
      l := u""
      every l ||:= words(s) || u" "
      l[-1] := u""
      return l
   end

   public get_tab_tooltip()
      # Only produce a tab tooltip if the title will be limited.
      if paint.label_will_fit(cbwin, tab_w - label_border.get_total_width()) then
         fail
      /title_tt := split_string(paint.str, 
                                Gui.style.create_tooltip_label().get_wattrib("font"),
                                scale(500))
      return title_tt
   end

   private on_stop(ev)
      browser.do_stop()
   end

   private on_home(ev)
      browser.goto(parent_dialog.settings.home_url)
   end

   private handle_paste_response(target_type, data, e)
      if /data then
         fail
      data ?:= tab(upto('\r\n'))
      url_field.set_contents(Text.liberal_ucs(data)).grab_focus()
   end

   private on_paste_url(ev)
      parent_dialog.request_selection(Selection.CLIPBOARD, 
                                      ["text/uri-list", Selection.UTF8_STRING_TARGET, Selection.STRING_TARGET], 
                                      handle_paste_response, 
                                      ev)
   end

   private on_refresh(ev)
      browser.do_refresh()
   end

   private on_decrease_font(ev)
      browser.do_decrease_font()
   end

   private on_increase_font(ev)
      browser.do_increase_font()
   end

   public new(browser_dialog, url, referer_url, revert_tab)
      local b
      TabItem.new()
      self.revert_tab := revert_tab
      label_border.set_x_align(Align.L)
      set_title()
      setup()
      set_remembered_focus(browser)
      # Try themed icon buttons
      theme_toolbar_button(close_button, "window-close")
      theme_toolbar_button(prev_button, "go-previous")
      theme_toolbar_button(next_button, "go-next")
      theme_toolbar_button(home_button, "go-home")
      theme_toolbar_button(stop_button)
      theme_toolbar_button(refresh_button, "view-refresh")
      theme_toolbar_button(paste_url_button, "edit-paste")
      theme_toolbar_button(search_close_button, "window-close")
      theme_toolbar_button(search_prev_button, "go-previous")
      theme_toolbar_button(search_next_button, "go-next")
      theme_toolbar_button(increase_font_button, "format-font-size-more")
      theme_toolbar_button(decrease_font_button, "format-font-size-less")
      # Narrow border around outermost TextFlow
      b := scale(2)
      browser.
         set_ui(self).
         set_worker_pool(browser_dialog.pool).
         set_outermost_border(EmptyBorder().set_insets(b, b, b, b)).
         set_font_factor(browser_dialog.settings.font_factor)
      browser.goto(\url, referer_url)
      return
   end

   private setup()
      local panel, border
      close_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(TextPaint("Close")).
         set_accel("c").
         connect(self.on_close_button, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(ImagePaint().set_cache("rpp.EXIT_24"))
      home_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(TextPaint("Home")).
         set_accel("n").
         connect(self.on_home, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(ImagePaint().set_cache("gui.HOME_24"))
      refresh_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(TextPaint("Refresh")).
         connect(self.on_refresh, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(ImagePaint().set_cache("gui.REFRESH_24"))
      prev_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(TextPaint("Prev")).
         connect(self.on_prev, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(ImagePaint().set_cache("gui.PREV_24"))
      next_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(TextPaint("Next")).
         connect(self.on_next, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(ImagePaint().set_cache("gui.NEXT_24"))
      stop_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(TextPaint("Stop")).
         connect(self.on_stop, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(ImagePaint().set_cache("rpp.STOP_24"))
      paste_url_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(TextPaint("Paste URL")).
         connect(self.on_paste_url, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(ImagePaint().set_cache("rpp.PASTE_24"))
      increase_font_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(TextPaint("Increase font size")).
         connect(self.on_increase_font, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(ImagePaint().set_cache("rpp.INCREASE_FONT_24"))
      decrease_font_button := IconButton().
         set_align(Align.L, Align.C).
         clear_constraints().
         set_tooltip(TextPaint("Decrease font size")).
         connect(self.on_decrease_font, Event.ACTION).
         set_no_click_focus(&yes).
         set_toggles(&no).
         set_paint(ImagePaint().set_cache("rpp.DECREASE_FONT_24"))

      panel := Panel().
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_align", Align.L).
         set_layout(GridLayout().set_doi(0).set_dii(2).set_extra("cells")).
         add(close_button).
         add(home_button).
         add(refresh_button).
         add(prev_button).
         add(next_button).
         add(stop_button).
         add(increase_font_button).
         add(decrease_font_button).
         add(paste_url_button)
      self.add(panel)
      url_field := URLEditList().
         set_selection_list([]).
         set_contents(u"").
         set_size(scale(100)).
         set_align(Align.C, Align.T).
         set_direction(Direction.DOWN).
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         connect(self.on_url_field, Event.ACTION).
         connect(self.on_url_field_selection, Event.SELECTION_CHANGED)
      self.add(url_field)
      browser := Browser().
         set_size(scale(650), scale(330)).
         clear_constraints().
         set_constraint("eol", &yes).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("y_fill", &yes).
         set_constraint("y_weight", 1.0)
      self.add(browser)
      border := CompoundBorder().
         set_outer(SunkenBorder()).
         set_inner(EmptyBorder().
            set_l_inset(3)).
         set_x_align(Align.L)
      message_label := MessageLabel().
         set_size(scale(100)).
         set_align(Align.L, Align.B).
         set_fg("red").
         clear_constraints().
         set_constraint("b_inset", 0).
         set_constraint("l_inset", 0).
         set_constraint("r_inset", 0).
         set_constraint("x_fill", &yes).
         set_constraint("eol", &yes).
         set_border(border).
         set_paint(TextPaint(""))
      self.add(message_label)
      self.set_layout(GridLayout().set_extra("cells"))
      search_panel := Component().
         set_constraint("eol", &yes).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_layout(GridLayout().set_doi(0).set_dii(2).set_extra("cells"))
      search_close_button := IconButton().
         set_tooltip(TextPaint("Close")).
         connect(close_search_panel, Event.ACTION).
         set_no_click_focus(&yes).
         set_paint(ImagePaint().set_cache("gui.CLOSE_24"))
      search_panel.add(search_close_button)
      search_field := TextField().
         set_width(scale(150)).
         set_contents(u"").
         connect(on_search_field, Event.CONTENT_CHANGED).
         connect(on_search_field, Event.ACTION)
      search_panel.add(search_field)
      search_prev_button := IconButton().
         set_tooltip(TextPaint("Prev")).
         connect(self.on_search_prev, Event.ACTION).
         set_no_click_focus(&yes).
         set_paint(ImagePaint().set_cache("gui.PREV_24"))
      search_panel.add(search_prev_button)
      search_next_button := IconButton().
         set_tooltip(TextPaint("Next")).
         connect(self.on_search_next, Event.ACTION).
         set_no_click_focus(&yes).
         set_paint(ImagePaint().set_cache("gui.NEXT_24"))
      search_panel.add(search_next_button)
      search_label := Label().
         set_label("").
         set_constraint("x_align", Align.L).
         set_constraint("x_fill", &yes).
         set_constraint("x_weight", 1.0).
         set_constraint("l_inset", 5).
         set_width(scale(75))
      search_panel.add(search_label)
   end
end

procedure main(a)
   local d, url, cookies_file, cookies, bak, settings, settings_file, home, s
   opts := options(a, [Opt("k",string, "FILE#Load cookies from file"),
                       Opt("l",,"Show HTTP headers and data flow"),
                       Opt("agent",string, "Set user agent field"),
                       Opt("v",,"Verbose output")
                       ])
   home := FilePath(Xdg.ensure_data_home()) | stop("Couldn't access data dir: ", &why)
   settings_file := home.child("oibrowser").str()
   cookies_file := \opts["k"] | home.child("oicookies").str()
   cookies := decode_from_file(cookies_file) | table()
   settings := decode_from_file(settings_file) | Settings2()
   ImageCache.
      name_image("rpp.EXIT_24", EXIT).
      name_image("rpp.PASTE_24", PASTE).
      name_image("rpp.STOP_24", STOP).
      name_image("rpp.CLEAR_24", CLEAR).
      name_image("rpp.INCREASE_FONT_24", INCREASE_FONT).
      name_image("rpp.DECREASE_FONT_24", DECREASE_FONT)
   insert(Dialog.ROOT_WATTRIBS, "icon", Pixels(BROWSER_LOGO))
   d := BrowserDialog(cookies, settings)
   if *a = 0 then
      d.new_tab(settings.home_url)
   else {
      every s := !a do {
         url := URL(ucs(s)) | stop("Invalid url: ", s)
         d.new_tab(url)
      }
   }
   d.set_focus(d.tabs.children[1].url_field.find_focus())
   d.show_modal()
   # Save cookies
   bak := cookies_file || ".bak"
   encode_to_file(bak, Cookie.expire_cookies(cookies)) | 
      stop("Couldn't encode to temp cookie file ", bak, ": ", &why)
   # Use rename not move to ensure it's atomic
   Files.rename(bak, cookies_file) | stop("Couldn't rename cookie file ", bak, ": ", &why)
   # Save settings
   encode_to_file(settings_file, settings,, 1)
end
